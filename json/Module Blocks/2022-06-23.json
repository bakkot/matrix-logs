[
{"content":{"body":"Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).","msgtype":"m.text","org.matrix.msc1767.text":"Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block)."},"ts":1655964759236,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$FndVL9IrFTkK7lgo08EIkXiCkS3CusS8A4iAryiImqs"},
{"content":{"body":"Kris Kowal On the other hand `import(\"data:text/javascript, ...\")` is memoized, and it's the closest thing we have to module blocks ","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a>On the other hand `import(\"data:text/javascript, ...\")` is memoized, and it's the closest thing we have to module blocks ","msgtype":"m.text"},"ts":1655969156671,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Fnh-ZRawTGW-M78BjlUWdtxkQfgVXpDy0ePqFFcLQ6E"},
{"content":{"body":"Even if being a primitive does not suffer from the structured clone problem ","msgtype":"m.text"},"ts":1655969238420,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Q8XkJzawn3454s_eBlidwtbQSIsMeutAhFfE8Ad5MZM"},
{"content":{"body":"> <@surma:matrix.org> No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity?\n\nMy intuition is, it'd be cool if it did, but also I don't see why anyone should depend on that","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$IuJS98hu0QnfdKJMHskPQaP0gdCTh4d3SSM2ESNPtDQ?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@surma:matrix.org\">@surma:matrix.org</a><br>No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity?</blockquote></mx-reply>My intuition is, it'd be cool if it did, but also I don't see why anyone should depend on that","m.relates_to":{"m.in_reply_to":{"event_id":"$IuJS98hu0QnfdKJMHskPQaP0gdCTh4d3SSM2ESNPtDQ"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@surma:matrix.org> No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity?\n\nMy intuition is, it'd be cool if it did, but also I don't see why anyone should depend on that","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$IuJS98hu0QnfdKJMHskPQaP0gdCTh4d3SSM2ESNPtDQ?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@surma:matrix.org\">@surma:matrix.org</a><br>No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity?</blockquote></mx-reply>My intuition is, it'd be cool if it did, but also I don't see why anyone should depend on that","mimetype":"text/html"}]},"ts":1655975469321,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5pMAATDquNNOTJbeVpjOqmEzTEGAuDiOGgfK-VJFzLM"},
{"content":{"body":"> <@kriskowal:matrix.org> Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).\n\nThis is a little hard for me to square with, if you use module fragments and have a little module subgraph with a diamond import pattern, you clearly don't expect cloning in that case, or do you?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$FndVL9IrFTkK7lgo08EIkXiCkS3CusS8A4iAryiImqs?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).</blockquote></mx-reply>This is a little hard for me to square with, if you use module fragments and have a little module subgraph with a diamond import pattern, you clearly don't expect cloning in that case, or do you?","m.relates_to":{"m.in_reply_to":{"event_id":"$FndVL9IrFTkK7lgo08EIkXiCkS3CusS8A4iAryiImqs"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).\n\nThis is a little hard for me to square with, if you use module fragments and have a little module subgraph with a diamond import pattern, you clearly don't expect cloning in that case, or do you?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$FndVL9IrFTkK7lgo08EIkXiCkS3CusS8A4iAryiImqs?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).</blockquote></mx-reply>This is a little hard for me to square with, if you use module fragments and have a little module subgraph with a diamond import pattern, you clearly don't expect cloning in that case, or do you?","mimetype":"text/html"}]},"ts":1655975555235,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$gNwaYFKSQ0ONBlBEGeXxqvpewfsNEpAfNFSbaaLHrr0"},
{"content":{"body":"I would expect one fresh instance of each module in the subgraph. The subgraph does not need to be memoized by the loader in order to achieve idempotence within the subgraph.","msgtype":"m.text","org.matrix.msc1767.text":"I would expect one fresh instance of each module in the subgraph. The subgraph does not need to be memoized by the loader in order to achieve idempotence within the subgraph."},"ts":1655995646561,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$C9U-Ad8ln242fWxdMYAPxvw0105KdnA8J0E2V1Bupf8"},
{"content":{"body":"That is to say, I think we agree that importing a module fragment should not produce more than one instance of each of the transitively imported module fragments.","msgtype":"m.text","org.matrix.msc1767.text":"That is to say, I think we agree that importing a module fragment should not produce more than one instance of each of the transitively imported module fragments."},"ts":1655995777310,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$QUzVKcZsCAxnd1pGG9EGlsH3M9JXV7I5NLaRtCq3NaU"},
{"content":{"body":"But I do think it’s acceptable for each dynamic import of a module fragment to instantiate exactly one fresh copy of the module fragment subgraph.","msgtype":"m.text","org.matrix.msc1767.text":"But I do think it’s acceptable for each dynamic import of a module fragment to instantiate exactly one fresh copy of the module fragment subgraph."},"ts":1655995821857,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$yIYbE5l-arJ4q48oENhGU_MYakQUwxC_-cIQMIYZMe4"},
{"content":{"body":"One of the things that I learned from our last conversation, that I quite like, is that every module fragment has an equivalent source text, effectively a single static module record that can be cached on the identity of the fragment. That also implies that it is content addressable and can be cached as a document or in transit. So there’s a lot to recommend that as a feature of transportability.","msgtype":"m.text","org.matrix.msc1767.text":"One of the things that I learned from our last conversation, that I quite like, is that every module fragment has an equivalent source text, effectively a single static module record that can be cached on the identity of the fragment. That also implies that it is content addressable and can be cached as a document or in transit. So there’s a lot to recommend that as a feature of transportability."},"ts":1655996739580,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$1NKvBunqnY1ci2I9Q7wcq7p04KPdYKIQ3STIki6Nj-g"},
{"content":{"body":"But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here.","msgtype":"m.text","org.matrix.msc1767.text":"But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here."},"ts":1655996817223,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$1v_yrIAkLCgf2-p-xv5VeIbRdGJzbEQWqEVZoKcO8Ow"},
{"content":{"body":" * But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here.","m.new_content":{"body":"But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here.","msgtype":"m.text","org.matrix.msc1767.text":"But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here."},"m.relates_to":{"event_id":"$1v_yrIAkLCgf2-p-xv5VeIbRdGJzbEQWqEVZoKcO8Ow","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here."},"ts":1655996927932,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$aTPP9GfJ9Cw3qr_wyhEMbl4f_vEdPnollPV7wX-mjCc"},
{"content":{"body":"But, I’ll concede this idea holds no water at all if there’s a hope that it’ll eventually be possible for a module fragment to be imported or exported between modules. If there’s a hope that would be eventually possible, I think that’s a very different design world.","msgtype":"m.text","org.matrix.msc1767.text":"But, I’ll concede this idea holds no water at all if there’s a hope that it’ll eventually be possible for a module fragment to be imported or exported between modules. If there’s a hope that would be eventually possible, I think that’s a very different design world."},"ts":1655997235898,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$HdnoVyf3Szgf3WeXO4nXUHJTyCpKhtomS8JH05FpF9E"},
{"content":{"body":"(In that world, I would hold the opposite opinion: that fragments should be memoized, but by virtue of being contained within another module that is memoized by full/referrer specifier, and that fragments would not be transportable without the entirety of the surrounding document.)","msgtype":"m.text","org.matrix.msc1767.text":"(In that world, I would hold the opposite opinion: that fragments should be memoized, but by virtue of being contained within another module that is memoized by full/referrer specifier, and that fragments would not be transportable without the entirety of the surrounding document.)"},"ts":1655997337404,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$YalxAm8U_yvAfpKLsVRotkqrkregyr3PsLS4CCcozyg"},
{"content":{"body":"I think this would make module fragments unusable for the bundling case","msgtype":"m.text","org.matrix.msc1767.text":"I think this would make module fragments unusable for the bundling case"},"ts":1655998913536,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$F4gpXWQ3HNeF7HdGHw2QqgGA34IM1_n6s5HhU3oMQFw"},
{"content":{"body":"for example, `module x { console.log(\"happened\"); } module y { import x; } module z { import x; } module w { import y; import x; } import x;`","format":"org.matrix.custom.html","formatted_body":"for example, <code>module x { console.log(&quot;happened&quot;); } module y { import x; } module z { import x; } module w { import y; import x; } import x;</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"for example, `module x { console.log(\"happened\"); } module y { import x; } module z { import x; } module w { import y; import x; } import x;`","mimetype":"text/plain"},{"body":"for example, <code>module x { console.log(&quot;happened&quot;); } module y { import x; } module z { import x; } module w { import y; import x; } import x;</code>","mimetype":"text/html"}]},"ts":1655998954208,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Azh7fo03Pdzsh5_DSZMOxEICbSbGnW8SxQ29WUPJIRo"},
{"content":{"body":"this should really print \"happened\" just once","msgtype":"m.text","org.matrix.msc1767.text":"this should really print \"happened\" just once"},"ts":1655998960430,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$2ZcDvpezOH3Wg1j4hFhIDMfKL09PEEfD2H4kqpmxIOU"},
{"content":{"body":"otherwise we're doing something new and different from how modules work normally","msgtype":"m.text","org.matrix.msc1767.text":"otherwise we're doing something new and different from how modules work normally"},"ts":1655998969605,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$iHeUQK83rxTSpfxhhR8juqrRbmv5Kp331_TjaDAZZNk"},
{"content":{"body":"as Guy pointed out, the internal representation need not mention gensyms, just a bunch of recursive data structures, which can be transported as such (some serializations may need to create a gensym/counter but this is just a local thing; it doesn't leak out)","msgtype":"m.text","org.matrix.msc1767.text":"as Guy pointed out, the internal representation need not mention gensyms, just a bunch of recursive data structures, which can be transported as such (some serializations may need to create a gensym/counter but this is just a local thing; it doesn't leak out)"},"ts":1655999429553,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$p_p_egDOpazsT10-bgBYoGI6L_uXF1Ov9gxlNBTDyIU"},
{"content":{"body":"HTML structured clone, for one, doesn't need gensyms and is fine with just having a recursive structure","msgtype":"m.text","org.matrix.msc1767.text":"HTML structured clone, for one, doesn't need gensyms and is fine with just having a recursive structure"},"ts":1655999451450,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$il1P6Y6jlsH1sOjnA3Ghi9H6Ai--n4HNYLUWiXsprew"},
{"content":{"body":"(of course implementations don't actually work like that, just the spec formalism)","msgtype":"m.text","org.matrix.msc1767.text":"(of course implementations don't actually work like that, just the spec formalism)"},"ts":1655999464246,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$c6TbHGV1Iyl4JhLwsXxKvRxb36vC2QcNO9h36siDfyg"},
{"content":{"body":"> <@littledan:matrix.org> this should really print \"happened\" just once\n\nI agree and think that can be coherent with dynamic import printing \"happened\" once more each time.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$2ZcDvpezOH3Wg1j4hFhIDMfKL09PEEfD2H4kqpmxIOU?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>this should really print &quot;happened&quot; just once</blockquote></mx-reply>I agree and think that can be coherent with dynamic import printing &quot;happened&quot; once more each time.","m.relates_to":{"m.in_reply_to":{"event_id":"$2ZcDvpezOH3Wg1j4hFhIDMfKL09PEEfD2H4kqpmxIOU"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> this should really print \"happened\" just once\n\nI agree and think that can be coherent with dynamic import printing \"happened\" once more each time.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$2ZcDvpezOH3Wg1j4hFhIDMfKL09PEEfD2H4kqpmxIOU?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>this should really print &quot;happened&quot; just once</blockquote></mx-reply>I agree and think that can be coherent with dynamic import printing &quot;happened&quot; once more each time.","mimetype":"text/html"}]},"ts":1656004251078,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$7mUmUWgz0yEEdZQxMwWeQq2baS9AfepVJfG262gojVA"},
{"content":{"body":"Hmm, I also think the dynamic import behavior should match","msgtype":"m.text"},"ts":1656004284785,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$wC8Eku5tOguA8oEQ8Wjr_-xH_GfVjm_y4spxoGzrE64"},
{"content":{"body":"I can sympathize with that.","msgtype":"m.text","org.matrix.msc1767.text":"I can sympathize with that."},"ts":1656004309953,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$9mJFv3cX6pZrSmVRwx9XJsHlxYnR05XsLMtVInR6uR8"},
{"content":{"body":"This is also something which would inhibit bundlers from using module fragments as an output format","msgtype":"m.text"},"ts":1656004312070,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Xq0fVrd2_upi894GAU5ZtpdfrIkSsQItQkg2YG5Y8DY"},
{"content":{"body":"I do not think that follows.","msgtype":"m.text","org.matrix.msc1767.text":"I do not think that follows."},"ts":1656004328928,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$7fWWxVhThaqkb7RJ6jRsZuEggqb5Bl84hPI22CpubKI"},
{"content":{"body":"I’ll mull on the tension between these motivations some more.","msgtype":"m.text","org.matrix.msc1767.text":"I’ll mull on the tension between these motivations some more."},"ts":1656004417986,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$_lCKOTpWxIDtIaomFgaiD713b3wb7WEqRmKTe6RtyFU"},
{"content":{"body":"The problem with bundlers that Dan is trying to show is that if you have this code:\n\n```js\n// main.js\nawait import(\"./dep.js\");\nawait import(\"./dep.js\");\n\n// dep.js (different file)\nconsole.log(\"Hi!\");\n```\n\nyou cannot (if `import()` re-evaluates module blocks) rewrite it to a single file like\n\n```js\n// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(\"Hi!\");\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>The problem with bundlers that Dan is trying to show is that if you have this code:</p>\n<pre><code class=\"language-js\">// main.js\nawait import(&quot;./dep.js&quot;);\nawait import(&quot;./dep.js&quot;);\n\n// dep.js (different file)\nconsole.log(&quot;Hi!&quot;);\n</code></pre>\n<p>you cannot (if <code>import()</code> re-evaluates module blocks) rewrite it to a single file like</p>\n<pre><code class=\"language-js\">// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(&quot;Hi!&quot;);\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The problem with bundlers that Dan is trying to show is that if you have this code:\n\n```js\n// main.js\nawait import(\"./dep.js\");\nawait import(\"./dep.js\");\n\n// dep.js (different file)\nconsole.log(\"Hi!\");\n```\n\nyou cannot (if `import()` re-evaluates module blocks) rewrite it to a single file like\n\n```js\n// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(\"Hi!\");\n}\n```","mimetype":"text/plain"},{"body":"<p>The problem with bundlers that Dan is trying to show is that if you have this code:</p>\n<pre><code class=\"language-js\">// main.js\nawait import(&quot;./dep.js&quot;);\nawait import(&quot;./dep.js&quot;);\n\n// dep.js (different file)\nconsole.log(&quot;Hi!&quot;);\n</code></pre>\n<p>you cannot (if <code>import()</code> re-evaluates module blocks) rewrite it to a single file like</p>\n<pre><code class=\"language-js\">// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(&quot;Hi!&quot;);\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1656004445989,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$zf8pwZwjpnvCO58l-p0liiulTFvVb0FlE2vQ4kPASbU"},
{"content":{"body":" * The problem with bundlers that Dan is trying to show is that if you have this code:\n\n```js\n// main.js\nawait import(\"./dep.js\");\nawait import(\"./dep.js\");\n\n// dep.js (different file)\nconsole.log(\"Hi!\");\n```\n\nyou cannot (if `import()` re-evaluates module blocks) rewrite it to a single file like\n\n```js\n// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(\"Hi!\");\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>The problem with bundlers that Dan is trying to show is that if you have this code:</p>\n<pre><code class=\"language-js\">// main.js\nawait import(&quot;./dep.js&quot;);\nawait import(&quot;./dep.js&quot;);\n\n// dep.js (different file)\nconsole.log(&quot;Hi!&quot;);\n</code></pre>\n<p>you cannot (if <code>import()</code> re-evaluates module blocks) rewrite it to a single file like</p>\n<pre><code class=\"language-js\">// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(&quot;Hi!&quot;);\n}\n</code></pre>\n","m.new_content":{"body":"The problem with bundlers that Dan is trying to show is that if you have this code:\n\n```js\n// main.js\nawait import(\"./dep.js\");\nawait import(\"./dep.js\");\n\n// dep.js (different file)\nconsole.log(\"Hi!\");\n```\n\nyou cannot (if `import()` re-evaluates module blocks) rewrite it to a single file like\n\n```js\n// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(\"Hi!\");\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>The problem with bundlers that Dan is trying to show is that if you have this code:</p>\n<pre><code class=\"language-js\">// main.js\nawait import(&quot;./dep.js&quot;);\nawait import(&quot;./dep.js&quot;);\n\n// dep.js (different file)\nconsole.log(&quot;Hi!&quot;);\n</code></pre>\n<p>you cannot (if <code>import()</code> re-evaluates module blocks) rewrite it to a single file like</p>\n<pre><code class=\"language-js\">// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(&quot;Hi!&quot;);\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The problem with bundlers that Dan is trying to show is that if you have this code:\n\n```js\n// main.js\nawait import(\"./dep.js\");\nawait import(\"./dep.js\");\n\n// dep.js (different file)\nconsole.log(\"Hi!\");\n```\n\nyou cannot (if `import()` re-evaluates module blocks) rewrite it to a single file like\n\n```js\n// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(\"Hi!\");\n}\n```","mimetype":"text/plain"},{"body":"<p>The problem with bundlers that Dan is trying to show is that if you have this code:</p>\n<pre><code class=\"language-js\">// main.js\nawait import(&quot;./dep.js&quot;);\nawait import(&quot;./dep.js&quot;);\n\n// dep.js (different file)\nconsole.log(&quot;Hi!&quot;);\n</code></pre>\n<p>you cannot (if <code>import()</code> re-evaluates module blocks) rewrite it to a single file like</p>\n<pre><code class=\"language-js\">// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(&quot;Hi!&quot;);\n}\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$zf8pwZwjpnvCO58l-p0liiulTFvVb0FlE2vQ4kPASbU","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * The problem with bundlers that Dan is trying to show is that if you have this code:\n\n```js\n// main.js\nawait import(\"./dep.js\");\nawait import(\"./dep.js\");\n\n// dep.js (different file)\nconsole.log(\"Hi!\");\n```\n\nyou cannot (if `import()` re-evaluates module blocks) rewrite it to a single file like\n\n```js\n// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(\"Hi!\");\n}\n```","mimetype":"text/plain"},{"body":" * <p>The problem with bundlers that Dan is trying to show is that if you have this code:</p>\n<pre><code class=\"language-js\">// main.js\nawait import(&quot;./dep.js&quot;);\nawait import(&quot;./dep.js&quot;);\n\n// dep.js (different file)\nconsole.log(&quot;Hi!&quot;);\n</code></pre>\n<p>you cannot (if <code>import()</code> re-evaluates module blocks) rewrite it to a single file like</p>\n<pre><code class=\"language-js\">// bundle.js\n\nimport main;\n\nmodule main {\n  await import(dep);\n  await import(dep);\n}\n\nmodule dep {\n  console.log(&quot;Hi!&quot;);\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1656004472154,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$qyAgqGVMV4Zt7OW1ffzjeRztLzkQLVlfYVRLKOuGmns"},
{"content":{"body":"I see. So behind door A, we get an inconsistency in behavior between static and dynamic import, behind door B, we get an inconsistency between local and remote dynamic import.","msgtype":"m.text","org.matrix.msc1767.text":"I see. So behind door A, we get an inconsistency in behavior between static and dynamic import, behind door B, we get an inconsistency between local and remote dynamic import."},"ts":1656004535160,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Ev9kbO4KtvF57JkwumPNkDUgHxeIdyLNFWT1L9yqRWA"},
{"content":{"body":"By \"remote\" do you mean \"I pass a dynamic import to a worker, and that worker would re-evaluate it\"?","msgtype":"m.text","org.matrix.msc1767.text":"By \"remote\" do you mean \"I pass a dynamic import to a worker, and that worker would re-evaluate it\"?"},"ts":1656004586201,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$OHvR4VH6kdlTglbETND34-jCQ6XsqCQk0gVX_hpLoTw"},
{"content":{"body":"Or \"I pass it to a worker, then the worker passes it back to me, and I will re-evaluate it\"?","msgtype":"m.text","org.matrix.msc1767.text":"Or \"I pass it to a worker, then the worker passes it back to me, and I will re-evaluate it\"?"},"ts":1656004604609,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$zxu5_xZ-FBBM6qO6KaNn3e44g0UTEidS-ZUr9oE0_Gg"},
{"content":{"body":"worker = compartment, or realm, or something else","msgtype":"m.text","org.matrix.msc1767.text":"worker = compartment, or realm, or something else"},"ts":1656004633044,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$mw36rNbH2FfGdEJFMMrZyGDQX9LOOQAWgNEy_2Abs80"},
{"content":{"body":"I wonder if we could attach an \"unique id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace","format":"org.matrix.custom.html","formatted_body":"I wonder if we could attach an &quot;unique id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I wonder if we could attach an \"unique id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace","mimetype":"text/plain"},{"body":"I wonder if we could attach an &quot;unique id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace","mimetype":"text/html"}]},"ts":1656004776034,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$sj7tlLYSMuqcZoNe_6RSOuDJq3RE_qfUKoKVmTOsapI"},
{"content":{"body":" * I wonder if we could attach an \"unique id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique","format":"org.matrix.custom.html","formatted_body":" * I wonder if we could attach an &quot;unique id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The &quot;id to namespace&quot; cache would be per-realm, but the id needs to be globally unique","m.new_content":{"body":"I wonder if we could attach an \"unique id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique","format":"org.matrix.custom.html","formatted_body":"I wonder if we could attach an &quot;unique id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The &quot;id to namespace&quot; cache would be per-realm, but the id needs to be globally unique","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I wonder if we could attach an \"unique id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique","mimetype":"text/plain"},{"body":"I wonder if we could attach an &quot;unique id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The &quot;id to namespace&quot; cache would be per-realm, but the id needs to be globally unique","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$sj7tlLYSMuqcZoNe_6RSOuDJq3RE_qfUKoKVmTOsapI","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I wonder if we could attach an \"unique id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique","mimetype":"text/plain"},{"body":" * I wonder if we could attach an &quot;unique id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The &quot;id to namespace&quot; cache would be per-realm, but the id needs to be globally unique","mimetype":"text/html"}]},"ts":1656004812134,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$fwIrRdZDM77kZVaQyF4J3RvIv5sVZCqSMoEQRJpcEy4"},
{"content":{"body":" * I wonder if we could attach an \"unique numeric id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique","format":"org.matrix.custom.html","formatted_body":" * I wonder if we could attach an &quot;unique numeric id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The &quot;id to namespace&quot; cache would be per-realm, but the id needs to be globally unique","m.new_content":{"body":"I wonder if we could attach an \"unique numeric id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique","format":"org.matrix.custom.html","formatted_body":"I wonder if we could attach an &quot;unique numeric id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The &quot;id to namespace&quot; cache would be per-realm, but the id needs to be globally unique","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I wonder if we could attach an \"unique numeric id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique","mimetype":"text/plain"},{"body":"I wonder if we could attach an &quot;unique numeric id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The &quot;id to namespace&quot; cache would be per-realm, but the id needs to be globally unique","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$sj7tlLYSMuqcZoNe_6RSOuDJq3RE_qfUKoKVmTOsapI","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I wonder if we could attach an \"unique numeric id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique","mimetype":"text/plain"},{"body":" * I wonder if we could attach an &quot;unique numeric id&quot; to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The &quot;id to namespace&quot; cache would be per-realm, but the id needs to be globally unique","mimetype":"text/html"}]},"ts":1656004833801,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$pzLgPUnPA-hYIvvaC1RgoGrhyk8HstFgT3O5ReahZKM"},
{"content":{"body":"This would mean that module namespaces coming from module blocks cannot be garbage collected until the realm is collected, but that's already true for namespaces coming from \"file modules\"","msgtype":"m.text","org.matrix.msc1767.text":"This would mean that module namespaces coming from module blocks cannot be garbage collected until the realm is collected, but that's already true for namespaces coming from \"file modules\""},"ts":1656004907666,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$lcS231xJCadGLE9VM8M0dz04SZqzuFAM1jFvXhxE-lo"},
{"content":{"body":"I presume that if module fragments are idempotent within the lifecycle of a loader (where currently, loader === realm), then they are necessarily retained by the loader.","msgtype":"m.text","org.matrix.msc1767.text":"I presume that if module fragments are idempotent within the lifecycle of a loader (where currently, loader === realm), then they are necessarily retained by the loader."},"ts":1656005341693,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$tzmyJ0ewUwfQK-u_oQ6zJODcLHZZbemzK20CwFePePA"},
{"content":{"body":"Oh true you are right. I was thinkng about module blocks (\"expressions\") that coud otherwise be collected when they become unreachable","msgtype":"m.text","org.matrix.msc1767.text":"Oh true you are right. I was thinkng about module blocks (\"expressions\") that coud otherwise be collected when they become unreachable"},"ts":1656005421162,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$eYSrP3eN5x9a_PBdUKy2B_tMSj84K_ytNTDHFZlHfNY"},
{"content":{"body":"\"static and dynamic\" seems like a much more important consistency to maintain imo","msgtype":"m.text","org.matrix.msc1767.text":"\"static and dynamic\" seems like a much more important consistency to maintain imo"},"ts":1656005728441,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$6HNXkJD6uH6AuYI9USttnY1otQ1ivfWWgFdKBP99F18"},
{"content":{"body":"I’m leaning to agree, if there’s no way to have both.","msgtype":"m.text","org.matrix.msc1767.text":"I’m leaning to agree, if there’s no way to have both."},"ts":1656006753412,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Xq3x1o2maZaWcrkaiq1NWjdlOIhco_H7drIue6dMT5w"},
{"content":{"body":"> <@nicolo-ribaudo:matrix.org> I wonder if we could attach an \"unique numeric id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique\n\nI believe integrating a fragment id into the module memo key is necessary if module blocks and fragments are memoized.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$sj7tlLYSMuqcZoNe_6RSOuDJq3RE_qfUKoKVmTOsapI?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">@nicolo-ribaudo:matrix.org</a><br>I wonder if we could attach an \"unique numeric id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique</blockquote></mx-reply>I believe integrating a fragment id into the module memo key is necessary if module blocks and fragments are memoized.","m.relates_to":{"m.in_reply_to":{"event_id":"$sj7tlLYSMuqcZoNe_6RSOuDJq3RE_qfUKoKVmTOsapI"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@nicolo-ribaudo:matrix.org> I wonder if we could attach an \"unique numeric id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique\n\nI believe integrating a fragment id into the module memo key is necessary if module blocks and fragments are memoized.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$sj7tlLYSMuqcZoNe_6RSOuDJq3RE_qfUKoKVmTOsapI?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">@nicolo-ribaudo:matrix.org</a><br>I wonder if we could attach an \"unique numeric id\" to every module block, similar to the shared registered symbols registry, so that when I receive it back <code>import()</code> can give me back the same module namespace. The \"id to namespace\" cache would be per-realm, but the id needs to be globally unique</blockquote></mx-reply>I believe integrating a fragment id into the module memo key is necessary if module blocks and fragments are memoized.","mimetype":"text/html"}]},"ts":1656006830371,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$0hlV7epEU72tUpQcl47DoUgYvunnyRhwOwxBr1DMzBc"},
{"content":{"body":"Thinking aloud, it also follows that the ModuleBlock is stable across evaluations of the same block. They’re lexical but not lexical closures, so no need for a fresh identity.","msgtype":"m.text","org.matrix.msc1767.text":"Thinking aloud, it also follows that the ModuleBlock is stable across evaluations of the same block. They’re lexical but not lexical closures, so no need for a fresh identity."},"ts":1656006930933,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$I0G3v6N6Jq_8viEYzXm9cErE1qyTIgB4ZVbAL0Sdh7c"},
{"content":{"body":"So having a sequential index as an internal slot of ModuleBlock within a document would work fine.","msgtype":"m.text","org.matrix.msc1767.text":"So having a sequential index as an internal slot of ModuleBlock within a document would work fine."},"ts":1656006988533,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$HjVte1XOVBrcoB3hOWSpWY2kBSVofRqNPV9I8Bxy838"},
{"content":{"body":"Note that there are two things: the identity of the object retunred by the `module {}` syntax, and the identity of the internal module:\n```js\nfunction getModule() { return module {} }\n\ngetModule() === getModule();\nawait import(getModule()) === await import(getModule());\n```\n\nare you talking about both, or only the second one?","format":"org.matrix.custom.html","formatted_body":"<p>Note that there are two things: the identity of the object retunred by the <code>module {}</code> syntax, and the identity of the internal module:</p>\n<pre><code class=\"language-js\">function getModule() { return module {} }\n\ngetModule() === getModule();\nawait import(getModule()) === await import(getModule());\n</code></pre>\n<p>are you talking about both, or only the second one?</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Note that there are two things: the identity of the object retunred by the `module {}` syntax, and the identity of the internal module:\n```js\nfunction getModule() { return module {} }\n\ngetModule() === getModule();\nawait import(getModule()) === await import(getModule());\n```\n\nare you talking about both, or only the second one?","mimetype":"text/plain"},{"body":"<p>Note that there are two things: the identity of the object retunred by the <code>module {}</code> syntax, and the identity of the internal module:</p>\n<pre><code class=\"language-js\">function getModule() { return module {} }\n\ngetModule() === getModule();\nawait import(getModule()) === await import(getModule());\n</code></pre>\n<p>are you talking about both, or only the second one?</p>\n","mimetype":"text/html"}]},"ts":1656007050829,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$z3-wbcWI4Rqs2cluOdxNxjT9-KvbxxuQbzJ1W72Mzto"},
{"content":{"body":"Again, thinking aloud, unless they have shared mutable state, in which case a fresh instance closing over the same ID should also be fine.","msgtype":"m.text","org.matrix.msc1767.text":"Again, thinking aloud, unless they have shared mutable state, in which case a fresh instance closing over the same ID should also be fine."},"ts":1656007056747,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$vcmgVlcdeqJCle7A3-_AmyhIY9fEomWb45RN6Aev5W4"},
{"content":{"body":"Ok, you were already answering 😂","msgtype":"m.text","org.matrix.msc1767.text":"Ok, you were already answering 😂"},"ts":1656007082275,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$6eAhjEhA6ntbzD1g4DgCi-PCinu2gCXmLTLEt8Ea_LA"},
{"content":{"body":"Yeah, I was thinking through the former case. Regardless of whether they’re identical, they would have the same value for the module block sequential number internal slot.","msgtype":"m.text","org.matrix.msc1767.text":"Yeah, I was thinking through the former case. Regardless of whether they’re identical, they would have the same value for the module block sequential number internal slot."},"ts":1656007200605,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$xwOOBAoCPbDt_22mB2Z5PE-dAubEf4HRD4MCW_tHcYE"},
{"content":{"body":"In order for the answer for the latter case to be true.","msgtype":"m.text","org.matrix.msc1767.text":"In order for the answer for the latter case to be true."},"ts":1656007223582,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$r_9GjJrY_6qCqAK5cif22FA0f6boRpcoWh2eEB-24uA"},
{"content":{"body":"Continuing to think aloud, with the approach of sequentially numbering blocks in order to preserve idempotence locally, to stretch that property to another loader (today, just realms), the wire representation of a block or fragment would have to capture the entirety of the originating document, or send each fragment individually with the content address of the surrounding document and the sequential id within the original document.","msgtype":"m.text","org.matrix.msc1767.text":"Continuing to think aloud, with the approach of sequentially numbering blocks in order to preserve idempotence locally, to stretch that property to another loader (today, just realms), the wire representation of a block or fragment would have to capture the entirety of the originating document, or send each fragment individually with the content address of the surrounding document and the sequential id within the original document."},"ts":1656012960035,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$MWvhdwbRl1pjou-ZydQl31LD3o2E-aRYRoZIcigUFis"},
{"content":{"body":"Daniel, Guy and I discussed a couple days ago an approach where every block could have its own static module record that captures just the subgraph of its transitive lexical fragments. That form would not be able to preserve idempotence if it were sent as a value to another realm’s import function.","msgtype":"m.text","org.matrix.msc1767.text":"Daniel, Guy and I discussed a couple days ago an approach where every block could have its own static module record that captures just the subgraph of its transitive lexical fragments. That form would not be able to preserve idempotence if it were sent as a value to another realm’s import function."},"ts":1656013105963,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$cLJLbHvCvENmt7e2eVCmMhUu75yBPngeLYby_5mE8lM"}
]