[
{"content":{"body":"Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).","msgtype":"m.text","org.matrix.msc1767.text":"Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block)."},"ts":1655964759236,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$FndVL9IrFTkK7lgo08EIkXiCkS3CusS8A4iAryiImqs"},
{"content":{"body":"Kris Kowal On the other hand `import(\"data:text/javascript, ...\")` is memoized, and it's the closest thing we have to module blocks ","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a>On the other hand `import(\"data:text/javascript, ...\")` is memoized, and it's the closest thing we have to module blocks ","msgtype":"m.text"},"ts":1655969156671,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Fnh-ZRawTGW-M78BjlUWdtxkQfgVXpDy0ePqFFcLQ6E"},
{"content":{"body":"Even if being a primitive does not suffer from the structured clone problem ","msgtype":"m.text"},"ts":1655969238420,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Q8XkJzawn3454s_eBlidwtbQSIsMeutAhFfE8Ad5MZM"},
{"content":{"body":"> <@surma:matrix.org> No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity?\n\nMy intuition is, it'd be cool if it did, but also I don't see why anyone should depend on that","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$IuJS98hu0QnfdKJMHskPQaP0gdCTh4d3SSM2ESNPtDQ?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@surma:matrix.org\">@surma:matrix.org</a><br>No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity?</blockquote></mx-reply>My intuition is, it'd be cool if it did, but also I don't see why anyone should depend on that","m.relates_to":{"m.in_reply_to":{"event_id":"$IuJS98hu0QnfdKJMHskPQaP0gdCTh4d3SSM2ESNPtDQ"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@surma:matrix.org> No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity?\n\nMy intuition is, it'd be cool if it did, but also I don't see why anyone should depend on that","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$IuJS98hu0QnfdKJMHskPQaP0gdCTh4d3SSM2ESNPtDQ?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@surma:matrix.org\">@surma:matrix.org</a><br>No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity?</blockquote></mx-reply>My intuition is, it'd be cool if it did, but also I don't see why anyone should depend on that","mimetype":"text/html"}]},"ts":1655975469321,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5pMAATDquNNOTJbeVpjOqmEzTEGAuDiOGgfK-VJFzLM"},
{"content":{"body":"> <@kriskowal:matrix.org> Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).\n\nThis is a little hard for me to square with, if you use module fragments and have a little module subgraph with a diamond import pattern, you clearly don't expect cloning in that case, or do you?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$FndVL9IrFTkK7lgo08EIkXiCkS3CusS8A4iAryiImqs?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).</blockquote></mx-reply>This is a little hard for me to square with, if you use module fragments and have a little module subgraph with a diamond import pattern, you clearly don't expect cloning in that case, or do you?","m.relates_to":{"m.in_reply_to":{"event_id":"$FndVL9IrFTkK7lgo08EIkXiCkS3CusS8A4iAryiImqs"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).\n\nThis is a little hard for me to square with, if you use module fragments and have a little module subgraph with a diamond import pattern, you clearly don't expect cloning in that case, or do you?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!QDrcqyQBnPJSClvYwJ:matrix.org/$FndVL9IrFTkK7lgo08EIkXiCkS3CusS8A4iAryiImqs?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesn’t retain the resulting graph of module instances, so some things could be collected earlier. That doesn’t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).</blockquote></mx-reply>This is a little hard for me to square with, if you use module fragments and have a little module subgraph with a diamond import pattern, you clearly don't expect cloning in that case, or do you?","mimetype":"text/html"}]},"ts":1655975555235,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$gNwaYFKSQ0ONBlBEGeXxqvpewfsNEpAfNFSbaaLHrr0"},
{"content":{"body":"I would expect one fresh instance of each module in the subgraph. The subgraph does not need to be memoized by the loader in order to achieve idempotence within the subgraph.","msgtype":"m.text","org.matrix.msc1767.text":"I would expect one fresh instance of each module in the subgraph. The subgraph does not need to be memoized by the loader in order to achieve idempotence within the subgraph."},"ts":1655995646561,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$C9U-Ad8ln242fWxdMYAPxvw0105KdnA8J0E2V1Bupf8"},
{"content":{"body":"That is to say, I think we agree that importing a module fragment should not produce more than one instance of each of the transitively imported module fragments.","msgtype":"m.text","org.matrix.msc1767.text":"That is to say, I think we agree that importing a module fragment should not produce more than one instance of each of the transitively imported module fragments."},"ts":1655995777310,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$QUzVKcZsCAxnd1pGG9EGlsH3M9JXV7I5NLaRtCq3NaU"},
{"content":{"body":"But I do think it’s acceptable for each dynamic import of a module fragment to instantiate exactly one fresh copy of the module fragment subgraph.","msgtype":"m.text","org.matrix.msc1767.text":"But I do think it’s acceptable for each dynamic import of a module fragment to instantiate exactly one fresh copy of the module fragment subgraph."},"ts":1655995821857,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$yIYbE5l-arJ4q48oENhGU_MYakQUwxC_-cIQMIYZMe4"},
{"content":{"body":"One of the things that I learned from our last conversation, that I quite like, is that every module fragment has an equivalent source text, effectively a single static module record that can be cached on the identity of the fragment. That also implies that it is content addressable and can be cached as a document or in transit. So there’s a lot to recommend that as a feature of transportability.","msgtype":"m.text","org.matrix.msc1767.text":"One of the things that I learned from our last conversation, that I quite like, is that every module fragment has an equivalent source text, effectively a single static module record that can be cached on the identity of the fragment. That also implies that it is content addressable and can be cached as a document or in transit. So there’s a lot to recommend that as a feature of transportability."},"ts":1655996739580,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$1NKvBunqnY1ci2I9Q7wcq7p04KPdYKIQ3STIki6Nj-g"},
{"content":{"body":"But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here.","msgtype":"m.text","org.matrix.msc1767.text":"But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here."},"ts":1655996817223,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$1v_yrIAkLCgf2-p-xv5VeIbRdGJzbEQWqEVZoKcO8Ow"},
{"content":{"body":" * But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here.","m.new_content":{"body":"But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here.","msgtype":"m.text","org.matrix.msc1767.text":"But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here."},"m.relates_to":{"event_id":"$1v_yrIAkLCgf2-p-xv5VeIbRdGJzbEQWqEVZoKcO8Ow","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * But caching the content doesn’t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here."},"ts":1655996927932,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$aTPP9GfJ9Cw3qr_wyhEMbl4f_vEdPnollPV7wX-mjCc"},
{"content":{"body":"But, I’ll concede this idea holds no water at all if there’s a hope that it’ll eventually be possible for a module fragment to be imported or exported between modules. If there’s a hope that would be eventually possible, I think that’s a very different design world.","msgtype":"m.text","org.matrix.msc1767.text":"But, I’ll concede this idea holds no water at all if there’s a hope that it’ll eventually be possible for a module fragment to be imported or exported between modules. If there’s a hope that would be eventually possible, I think that’s a very different design world."},"ts":1655997235898,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$HdnoVyf3Szgf3WeXO4nXUHJTyCpKhtomS8JH05FpF9E"},
{"content":{"body":"(In that world, I would hold the opposite opinion: that fragments should be memoized, but by virtue of being contained within another module that is memoized by full/referrer specifier, and that fragments would not be transportable without the entirety of the surrounding document.)","msgtype":"m.text","org.matrix.msc1767.text":"(In that world, I would hold the opposite opinion: that fragments should be memoized, but by virtue of being contained within another module that is memoized by full/referrer specifier, and that fragments would not be transportable without the entirety of the surrounding document.)"},"ts":1655997337404,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$YalxAm8U_yvAfpKLsVRotkqrkregyr3PsLS4CCcozyg"},
{"content":{"body":"I think this would make module fragments unusable for the bundling case","msgtype":"m.text","org.matrix.msc1767.text":"I think this would make module fragments unusable for the bundling case"},"ts":1655998913536,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$F4gpXWQ3HNeF7HdGHw2QqgGA34IM1_n6s5HhU3oMQFw"},
{"content":{"body":"for example, `module x { console.log(\"happened\"); } module y { import x; } module z { import x; } module w { import y; import x; } import x;`","format":"org.matrix.custom.html","formatted_body":"for example, <code>module x { console.log(&quot;happened&quot;); } module y { import x; } module z { import x; } module w { import y; import x; } import x;</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"for example, `module x { console.log(\"happened\"); } module y { import x; } module z { import x; } module w { import y; import x; } import x;`","mimetype":"text/plain"},{"body":"for example, <code>module x { console.log(&quot;happened&quot;); } module y { import x; } module z { import x; } module w { import y; import x; } import x;</code>","mimetype":"text/html"}]},"ts":1655998954208,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Azh7fo03Pdzsh5_DSZMOxEICbSbGnW8SxQ29WUPJIRo"},
{"content":{"body":"this should really print \"happened\" just once","msgtype":"m.text","org.matrix.msc1767.text":"this should really print \"happened\" just once"},"ts":1655998960430,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$2ZcDvpezOH3Wg1j4hFhIDMfKL09PEEfD2H4kqpmxIOU"},
{"content":{"body":"otherwise we're doing something new and different from how modules work normally","msgtype":"m.text","org.matrix.msc1767.text":"otherwise we're doing something new and different from how modules work normally"},"ts":1655998969605,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$iHeUQK83rxTSpfxhhR8juqrRbmv5Kp331_TjaDAZZNk"},
{"content":{"body":"as Guy pointed out, the internal representation need not mention gensyms, just a bunch of recursive data structures, which can be transported as such (some serializations may need to create a gensym/counter but this is just a local thing; it doesn't leak out)","msgtype":"m.text","org.matrix.msc1767.text":"as Guy pointed out, the internal representation need not mention gensyms, just a bunch of recursive data structures, which can be transported as such (some serializations may need to create a gensym/counter but this is just a local thing; it doesn't leak out)"},"ts":1655999429553,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$p_p_egDOpazsT10-bgBYoGI6L_uXF1Ov9gxlNBTDyIU"},
{"content":{"body":"HTML structured clone, for one, doesn't need gensyms and is fine with just having a recursive structure","msgtype":"m.text","org.matrix.msc1767.text":"HTML structured clone, for one, doesn't need gensyms and is fine with just having a recursive structure"},"ts":1655999451450,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$il1P6Y6jlsH1sOjnA3Ghi9H6Ai--n4HNYLUWiXsprew"},
{"content":{"body":"(of course implementations don't actually work like that, just the spec formalism)","msgtype":"m.text","org.matrix.msc1767.text":"(of course implementations don't actually work like that, just the spec formalism)"},"ts":1655999464246,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$c6TbHGV1Iyl4JhLwsXxKvRxb36vC2QcNO9h36siDfyg"}
]