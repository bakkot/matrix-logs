[
{"content":{"body":"Well case insensitivity is terrible anyway","msgtype":"m.text"},"ts":1692754600945,"senderName":"tewuzij","senderId":"@tewuzij:tzchat.org","id":"$t99FSlQR9lO2Br6jtHfYehwNfTypafPHYHGEz2owQkc"},
{"content":{"body":"Databases aren't my area of expertise but if you want fuzzy searching you should normalize your text with NFD and Case Fold and build a search db out of that, rather than making a key with a version-sensitive sorting function","msgtype":"m.text"},"ts":1692755038603,"senderName":"sffc","senderId":"@sffc:mozilla.org","id":"$Xh-fOTp-6bZtTHBGoWftvbUXjt22qDbt_RKplkIYK_I"},
{"content":{"body":"Collator-based matching is really powerful though so maybe there's a valid reason to consider building an index with a Collator-based transform","msgtype":"m.text"},"ts":1692755364559,"senderName":"sffc","senderId":"@sffc:mozilla.org","id":"$A1P_mZHi_82CX6_ndR0lmUlWBsDi7Xx1epP9NZKq3hk"},
{"content":{"body":"I kinda got the idea that collation keys might be better than NFD + case fold for some of these fuzzy comparison/searching cases from https://www.unicode.org/reports/tr10/#Searching but I hear about a lot more real systems using nfd+fold","msgtype":"m.text"},"ts":1692762844868,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_ITmL4TuKFACBS17-Of6spEuB5skt_lXT63oH0aIYks"},
{"content":{"body":"So maybe I misinterpreted that section","msgtype":"m.text"},"ts":1692762885969,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$od4u9pnhXykKELRKTPWCYhl-oX1Yuv_2SKFASp3WmgE"},
{"content":{"body":"(The non-stability point is well noted!)","msgtype":"m.text"},"ts":1692762947496,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$d_7znsltiDQBD-bIOsY5kdpnBoUHyu8zZrPo5jayfbI"},
{"content":{"body":"> if you want fuzzy searching \n\nAFAIK, many RDBMSs (like MySQL, Postgres, and SQL Server) default to case-insensitive collation for text columns. There may be per-DBMS variation in whether accent-insensitive (equivalent to [Unicode tertiary](https://www.unicode.org/reports/tr10/#Asymmetric_Search_Tertiary), I suspect) is the default or not.  But it's safe to assume that the majority of text data stored in relational databases is case-insensitively collated. \n\nSo to an app developer, a DB query like `SELECT lastname FROM inventors WHERE lastname = 'De Havilland'` returning a result like`\"de Haviland\"` isn't \"fuzzy\" or special. It's just the default way that most non-Oracle relational databases have worked for many years.\n\n> normalize your text with NFD and Case Fold and build a search db out of that\n\nSome challenges to this approach:\n* It doubles the storage requirements for any text column, except in the relatively rare case that you don't need to retain the original case of the column. Database performance and cost is generally constrained by data size, so for most large-scale applications it would be a non-starter to store data twice.\n* It requires application code (or code in the DB, like a computed column or trigger) to do the NFD + Case Fold operation when storing new rows. This adds complexity, hurts perf, and introduces failure cases like the two columns getting out of sync. The alternative of relying on the DB itself to take care of collation is easier, faster, and safer. (Assuming collation updates don't corrupt indexes!)\n\nSo it seems unlikely that many DB app developers would want to store an extra, normalized copy of text data.  Instead, they'd probably demand that their hosting providers freeze the collation library. This is what AWS [seems to be doing, FWIW](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL-Collations.html#:~:text=To%20reduce%20the%20possible%20impacts%20of%20the%20glibc%20updates%2C%20RDS%20for%20PostgreSQL%20now%20includes%20an%20independent%20default%20collation%20library.). \n\nA DBMS system relying on the OS's collation library seems dangerously brittle. I'm amazed that Postgres does this. Until today, I assumed that all DBMSs statically linked their collation library, and only revved it like any other backwards-incompatible change: put in a major version release, require rebuilding indexes to pick up the change, fixup or rebuild indexes when upgrading the DBMS, etc.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>if you want fuzzy searching</p>\n</blockquote>\n<p>AFAIK, many RDBMSs (like MySQL, Postgres, and SQL Server) default to case-insensitive collation for text columns. There may be per-DBMS variation in whether accent-insensitive (equivalent to <a href=\"https://www.unicode.org/reports/tr10/#Asymmetric_Search_Tertiary\">Unicode tertiary</a>, I suspect) is the default or not.  But it's safe to assume that the majority of text data stored in relational databases is case-insensitively collated.</p>\n<p>So to an app developer, a DB query like <code>SELECT lastname FROM inventors WHERE lastname = 'De Havilland'</code> returning a result like<code>\"de Haviland\"</code> isn't \"fuzzy\" or special. It's just the default way that most non-Oracle relational databases have worked for many years.</p>\n<blockquote>\n<p>normalize your text with NFD and Case Fold and build a search db out of that</p>\n</blockquote>\n<p>Some challenges to this approach:</p>\n<ul>\n<li>It doubles the storage requirements for any text column, except in the relatively rare case that you don't need to retain the original case of the column. Database performance and cost is generally constrained by data size, so for most large-scale applications it would be a non-starter to store data twice.</li>\n<li>It requires application code (or code in the DB, like a computed column or trigger) to do the NFD + Case Fold operation when storing new rows. This adds complexity, hurts perf, and introduces failure cases like the two columns getting out of sync. The alternative of relying on the DB itself to take care of collation is easier, faster, and safer. (Assuming collation updates don't corrupt indexes!)</li>\n</ul>\n<p>So it seems unlikely that many DB app developers would want to store an extra, normalized copy of text data.  Instead, they'd probably demand that their hosting providers freeze the collation library. This is what AWS <a href=\"https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL-Collations.html#:~:text=To%20reduce%20the%20possible%20impacts%20of%20the%20glibc%20updates%2C%20RDS%20for%20PostgreSQL%20now%20includes%20an%20independent%20default%20collation%20library.\">seems to be doing, FWIW</a>.</p>\n<p>A DBMS system relying on the OS's collation library seems dangerously brittle. I'm amazed that Postgres does this. Until today, I assumed that all DBMSs statically linked their collation library, and only revved it like any other backwards-incompatible change: put in a major version release, require rebuilding indexes to pick up the change, fixup or rebuild indexes when upgrading the DBMS, etc.</p>\n","msgtype":"m.text"},"ts":1692771356402,"senderName":"justingrant","senderId":"@justingrant:matrix.org","id":"$Ih9R8dSQFGu8FeMBylyIgzsAalVqdEcukMb8M8bQUQ4"}
]