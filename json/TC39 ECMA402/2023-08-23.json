[
{"content":{"body":"Well case insensitivity is terrible anyway","msgtype":"m.text"},"ts":1692754600945,"senderName":"tewuzij","senderId":"@tewuzij:tzchat.org","id":"$t99FSlQR9lO2Br6jtHfYehwNfTypafPHYHGEz2owQkc"},
{"content":{"body":"Databases aren't my area of expertise but if you want fuzzy searching you should normalize your text with NFD and Case Fold and build a search db out of that, rather than making a key with a version-sensitive sorting function","msgtype":"m.text"},"ts":1692755038603,"senderName":"sffc","senderId":"@sffc:mozilla.org","id":"$Xh-fOTp-6bZtTHBGoWftvbUXjt22qDbt_RKplkIYK_I"},
{"content":{"body":"Collator-based matching is really powerful though so maybe there's a valid reason to consider building an index with a Collator-based transform","msgtype":"m.text"},"ts":1692755364559,"senderName":"sffc","senderId":"@sffc:mozilla.org","id":"$A1P_mZHi_82CX6_ndR0lmUlWBsDi7Xx1epP9NZKq3hk"},
{"content":{"body":"I kinda got the idea that collation keys might be better than NFD + case fold for some of these fuzzy comparison/searching cases from https://www.unicode.org/reports/tr10/#Searching but I hear about a lot more real systems using nfd+fold","msgtype":"m.text"},"ts":1692762844868,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_ITmL4TuKFACBS17-Of6spEuB5skt_lXT63oH0aIYks"},
{"content":{"body":"So maybe I misinterpreted that section","msgtype":"m.text"},"ts":1692762885969,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$od4u9pnhXykKELRKTPWCYhl-oX1Yuv_2SKFASp3WmgE"},
{"content":{"body":"(The non-stability point is well noted!)","msgtype":"m.text"},"ts":1692762947496,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$d_7znsltiDQBD-bIOsY5kdpnBoUHyu8zZrPo5jayfbI"},
{"content":{"body":"> if you want fuzzy searching \n\nAFAIK, many RDBMSs (like MySQL, Postgres, and SQL Server) default to case-insensitive collation for text columns. There may be per-DBMS variation in whether accent-insensitive (equivalent to [Unicode tertiary](https://www.unicode.org/reports/tr10/#Asymmetric_Search_Tertiary), I suspect) is the default or not.  But it's safe to assume that the majority of text data stored in relational databases is case-insensitively collated. \n\nSo to an app developer, a DB query like `SELECT lastname FROM inventors WHERE lastname = 'De Havilland'` returning a result like`\"de Haviland\"` isn't \"fuzzy\" or special. It's just the default way that most non-Oracle relational databases have worked for many years.\n\n> normalize your text with NFD and Case Fold and build a search db out of that\n\nSome challenges to this approach:\n* It doubles the storage requirements for any text column, except in the relatively rare case that you don't need to retain the original case of the column. Database performance and cost is generally constrained by data size, so for most large-scale applications it would be a non-starter to store data twice.\n* It requires application code (or code in the DB, like a computed column or trigger) to do the NFD + Case Fold operation when storing new rows. This adds complexity, hurts perf, and introduces failure cases like the two columns getting out of sync. The alternative of relying on the DB itself to take care of collation is easier, faster, and safer. (Assuming collation updates don't corrupt indexes!)\n\nSo it seems unlikely that many DB app developers would want to store an extra, normalized copy of text data.  Instead, they'd probably demand that their hosting providers freeze the collation library. This is what AWS [seems to be doing, FWIW](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL-Collations.html#:~:text=To%20reduce%20the%20possible%20impacts%20of%20the%20glibc%20updates%2C%20RDS%20for%20PostgreSQL%20now%20includes%20an%20independent%20default%20collation%20library.). \n\nA DBMS system relying on the OS's collation library seems dangerously brittle. I'm amazed that Postgres does this. Until today, I assumed that all DBMSs statically linked their collation library, and only revved it like any other backwards-incompatible change: put in a major version release, require rebuilding indexes to pick up the change, fixup or rebuild indexes when upgrading the DBMS, etc.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>if you want fuzzy searching</p>\n</blockquote>\n<p>AFAIK, many RDBMSs (like MySQL, Postgres, and SQL Server) default to case-insensitive collation for text columns. There may be per-DBMS variation in whether accent-insensitive (equivalent to <a href=\"https://www.unicode.org/reports/tr10/#Asymmetric_Search_Tertiary\">Unicode tertiary</a>, I suspect) is the default or not.  But it's safe to assume that the majority of text data stored in relational databases is case-insensitively collated.</p>\n<p>So to an app developer, a DB query like <code>SELECT lastname FROM inventors WHERE lastname = 'De Havilland'</code> returning a result like<code>\"de Haviland\"</code> isn't \"fuzzy\" or special. It's just the default way that most non-Oracle relational databases have worked for many years.</p>\n<blockquote>\n<p>normalize your text with NFD and Case Fold and build a search db out of that</p>\n</blockquote>\n<p>Some challenges to this approach:</p>\n<ul>\n<li>It doubles the storage requirements for any text column, except in the relatively rare case that you don't need to retain the original case of the column. Database performance and cost is generally constrained by data size, so for most large-scale applications it would be a non-starter to store data twice.</li>\n<li>It requires application code (or code in the DB, like a computed column or trigger) to do the NFD + Case Fold operation when storing new rows. This adds complexity, hurts perf, and introduces failure cases like the two columns getting out of sync. The alternative of relying on the DB itself to take care of collation is easier, faster, and safer. (Assuming collation updates don't corrupt indexes!)</li>\n</ul>\n<p>So it seems unlikely that many DB app developers would want to store an extra, normalized copy of text data.  Instead, they'd probably demand that their hosting providers freeze the collation library. This is what AWS <a href=\"https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL-Collations.html#:~:text=To%20reduce%20the%20possible%20impacts%20of%20the%20glibc%20updates%2C%20RDS%20for%20PostgreSQL%20now%20includes%20an%20independent%20default%20collation%20library.\">seems to be doing, FWIW</a>.</p>\n<p>A DBMS system relying on the OS's collation library seems dangerously brittle. I'm amazed that Postgres does this. Until today, I assumed that all DBMSs statically linked their collation library, and only revved it like any other backwards-incompatible change: put in a major version release, require rebuilding indexes to pick up the change, fixup or rebuild indexes when upgrading the DBMS, etc.</p>\n","msgtype":"m.text"},"ts":1692771356402,"senderName":"justingrant","senderId":"@justingrant:matrix.org","id":"$Ih9R8dSQFGu8FeMBylyIgzsAalVqdEcukMb8M8bQUQ4"},
{"content":{"body":"> <@justingrant:matrix.org> Got it. So Postgres relies on the OS's glibc for collation instead of statically linking a particular snapshot of a collation library with each release?  Or is the OS's glibc fixed to match Postgres's behavior so that client apps will sort exactly like the DBMS does, even when not running any DB-related code?\n> \n> Regardless, how can this problem actually be solved?  If I want to have a case-insensitive, accent-insensitive DB index, and the rules for accent-insensitive comparison change between ICU releases, then the index has to be rebuilt, right?\n\nAs I understand it, Postgres calls glibc (unless configured to call ICU4C) for collation and expects the output for given input to stay the same, which is assuming a guarantee that glibc (other than the AWS special version) doesn't provide across glibc updates. I'm not a Postgres admin and don't know how the Postgres developers view this or how Postgres continues to do this despite it appearing extremely ill-advised from a collator implementor perspective. https://postgresql.verite.pro/blog/2018/08/27/glibc-upgrade.html (with enough searching, there should also be a blog post out there about a horror story of a Postgres database backup being unrestorable after a glibc update.)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!pGTjbcoTUqwfzHcRaW:matrix.org/$A9JMMB0EtgbovD2JNdsGaOTQXBEp02amFV2Iml5JP_4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@justingrant:matrix.org\">@justingrant:matrix.org</a><br>Got it. So Postgres relies on the OS&#39;s glibc for collation instead of statically linking a particular snapshot of a collation library with each release?  Or is the OS&#39;s glibc fixed to match Postgres&#39;s behavior so that client apps will sort exactly like the DBMS does, even when not running any DB-related code?<br/><br/>Regardless, how can this problem actually be solved?  If I want to have a case-insensitive, accent-insensitive DB index, and the rules for accent-insensitive comparison change between ICU releases, then the index has to be rebuilt, right?</blockquote></mx-reply>As I understand it, Postgres calls glibc (unless configured to call ICU4C) for collation and expects the output for given input to stay the same, which is assuming a guarantee that glibc (other than the AWS special version) doesn't provide across glibc updates. I'm not a Postgres admin and don't know how the Postgres developers view this or how Postgres continues to do this despite it appearing extremely ill-advised from a collator implementor perspective. https://postgresql.verite.pro/blog/2018/08/27/glibc-upgrade.html (with enough searching, there should also be a blog post out there about a horror story of a Postgres database backup being unrestorable after a glibc update.)","m.relates_to":{"m.in_reply_to":{"event_id":"$A9JMMB0EtgbovD2JNdsGaOTQXBEp02amFV2Iml5JP_4"}},"msgtype":"m.text"},"ts":1692774054060,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$HHLoQOzQiFdnJrLy3gv62gPpUgbrXBQ1LgDAwDgkEqk"}
]