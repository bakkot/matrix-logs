[
{"content":{"body":"* Here's the spec for `Set.prototype.isSubsetOf`:\n\n```\n5. Let thisSize be the number of elements in O.[[SetData]].\n6. Let index be 0.\n7. Repeat, while index < thisSize,\n       a. Let e be O.[[SetData]][index].\n       b. Set index to index + 1.\n       c. If e is not empty, then\n              i. Let inOther be ToBoolean(? Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »)).\n              ii. If inOther is false, return false.\n              iii. NOTE: The number of elements in O.[[SetData]] may have increased during execution of otherRec.[[Has]].\n              iv. Set thisSize to the number of elements in O.[[SetData]].\n```\n\nThe test does the following;\n\n1. create a Set with \\[1,2,3\\]\n2. create a SetLike that, everytime we check if it has a value v, deletes that value from the first set.\n3. asserts there's no values left after the call to `isSubsetOf`\n\nThis seems to make sense, but according to the algorithm, that would only work if we make a copy of the set elements in the first place. No such copy is required.\n\nExplanation:\n\nHere's what happens if we run the test using the pseudocode from the spec:\n\n1. index = 0, set = \\[1,2,3\\], size = 3, e = 1, Call other.[\\[Has\\]](vector://vector/webapp/e)\n2. The SetLike, removes 1 from the original set\n3. index = 1, set = \\[2,3\\], size = 2, e = 3. \\<\\< - WE SKIPPED AN ELEMENT BY INCREMENTING INDEX\n4. The element we skipped will remain in the set at the end.\n\nThe test thus fails because we use indexing and skipped an element, and it asserts that we're going through all elements.\n\nI'm assuming V8/SpiderMonkey/etc are doing something different than the spec that passes that test?\n\nRemarkably, `isSupersetOf`, strangely, uses an iterator, not indexing.\n\nNote: I can't make a copy of the set's element because its elements might change during the call (there's a test for it too).","format":"org.matrix.custom.html","formatted_body":"* <p>Here's the spec for <code>Set.prototype.isSubsetOf</code>:</p>\n<pre><code>5. Let thisSize be the number of elements in O.[[SetData]].\n6. Let index be 0.\n7. Repeat, while index &lt; thisSize,\n       a. Let e be O.[[SetData]][index].\n       b. Set index to index + 1.\n       c. If e is not empty, then\n              i. Let inOther be ToBoolean(? Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »)).\n              ii. If inOther is false, return false.\n              iii. NOTE: The number of elements in O.[[SetData]] may have increased during execution of otherRec.[[Has]].\n              iv. Set thisSize to the number of elements in O.[[SetData]].\n</code></pre>\n<p>The test does the following;</p>\n<ol>\n<li>create a Set with [1,2,3]</li>\n<li>create a SetLike that, everytime we check if it has a value v, deletes that value from the first set.</li>\n<li>asserts there's no values left after the call to <code>isSubsetOf</code></li>\n</ol>\n<p>This seems to make sense, but according to the algorithm, that would only work if we make a copy of the set elements in the first place. No such copy is required.</p>\n<p>Explanation:</p>\n<p>Here's what happens if we run the test using the pseudocode from the spec:</p>\n<ol>\n<li>index = 0, set = [1,2,3], size = 3, e = 1, Call other.<a href=\"vector://vector/webapp/e\">[Has]</a></li>\n<li>The SetLike, removes 1 from the original set</li>\n<li>index = 1, set = [2,3], size = 2, e = 3. &lt;&lt; - WE SKIPPED AN ELEMENT BY INCREMENTING INDEX</li>\n<li>The element we skipped will remain in the set at the end.</li>\n</ol>\n<p>The test thus fails because we use indexing and skipped an element, and it asserts that we're going through all elements.</p>\n<p>I'm assuming V8/SpiderMonkey/etc are doing something different than the spec that passes that test?</p>\n<p>Remarkably, <code>isSupersetOf</code>, strangely, uses an iterator, not indexing.</p>\n<p>Note: I can't make a copy of the set's element because its elements might change during the call (there's a test for it too).</p>\n","m.mentions":{},"m.new_content":{"body":"Here's the spec for `Set.prototype.isSubsetOf`:\n\n```\n5. Let thisSize be the number of elements in O.[[SetData]].\n6. Let index be 0.\n7. Repeat, while index < thisSize,\n       a. Let e be O.[[SetData]][index].\n       b. Set index to index + 1.\n       c. If e is not empty, then\n              i. Let inOther be ToBoolean(? Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »)).\n              ii. If inOther is false, return false.\n              iii. NOTE: The number of elements in O.[[SetData]] may have increased during execution of otherRec.[[Has]].\n              iv. Set thisSize to the number of elements in O.[[SetData]].\n```\n\nThe test does the following;\n\n1. create a Set with \\[1,2,3\\]\n2. create a SetLike that, everytime we check if it has a value v, deletes that value from the first set.\n3. asserts there's no values left after the call to `isSubsetOf`\n\nThis seems to make sense, but according to the algorithm, that would only work if we make a copy of the set elements in the first place. No such copy is required.\n\nExplanation:\n\nHere's what happens if we run the test using the pseudocode from the spec:\n\n1. index = 0, set = \\[1,2,3\\], size = 3, e = 1, Call other.[\\[Has\\]](vector://vector/webapp/e)\n2. The SetLike, removes 1 from the original set\n3. index = 1, set = \\[2,3\\], size = 2, e = 3. \\<\\< - WE SKIPPED AN ELEMENT BY INCREMENTING INDEX\n4. The element we skipped will remain in the set at the end.\n\nThe test thus fails because we use indexing and skipped an element, and it asserts that we're going through all elements.\n\nI'm assuming V8/SpiderMonkey/etc are doing something different than the spec that passes that test?\n\nRemarkably, `isSupersetOf`, strangely, uses an iterator, not indexing.\n\nNote: I can't make a copy of the set's element because its elements might change during the call (there's a test for it too).","format":"org.matrix.custom.html","formatted_body":"<p>Here's the spec for <code>Set.prototype.isSubsetOf</code>:</p>\n<pre><code>5. Let thisSize be the number of elements in O.[[SetData]].\n6. Let index be 0.\n7. Repeat, while index &lt; thisSize,\n       a. Let e be O.[[SetData]][index].\n       b. Set index to index + 1.\n       c. If e is not empty, then\n              i. Let inOther be ToBoolean(? Call(otherRec.[[Has]], otherRec.[[SetObject]], « e »)).\n              ii. If inOther is false, return false.\n              iii. NOTE: The number of elements in O.[[SetData]] may have increased during execution of otherRec.[[Has]].\n              iv. Set thisSize to the number of elements in O.[[SetData]].\n</code></pre>\n<p>The test does the following;</p>\n<ol>\n<li>create a Set with [1,2,3]</li>\n<li>create a SetLike that, everytime we check if it has a value v, deletes that value from the first set.</li>\n<li>asserts there's no values left after the call to <code>isSubsetOf</code></li>\n</ol>\n<p>This seems to make sense, but according to the algorithm, that would only work if we make a copy of the set elements in the first place. No such copy is required.</p>\n<p>Explanation:</p>\n<p>Here's what happens if we run the test using the pseudocode from the spec:</p>\n<ol>\n<li>index = 0, set = [1,2,3], size = 3, e = 1, Call other.<a href=\"vector://vector/webapp/e\">[Has]</a></li>\n<li>The SetLike, removes 1 from the original set</li>\n<li>index = 1, set = [2,3], size = 2, e = 3. &lt;&lt; - WE SKIPPED AN ELEMENT BY INCREMENTING INDEX</li>\n<li>The element we skipped will remain in the set at the end.</li>\n</ol>\n<p>The test thus fails because we use indexing and skipped an element, and it asserts that we're going through all elements.</p>\n<p>I'm assuming V8/SpiderMonkey/etc are doing something different than the spec that passes that test?</p>\n<p>Remarkably, <code>isSupersetOf</code>, strangely, uses an iterator, not indexing.</p>\n<p>Note: I can't make a copy of the set's element because its elements might change during the call (there's a test for it too).</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$dUdSADtTCYgrleBoKjWPNwcqmWJt3seXIFXGqCWtb1w","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1747958409948,"senderName":"Hans","senderId":"@hanslarsen:matrix.org","id":"$LqtrQ_QGtlPOzw_s7MGFRTMQr4O5FIHrkWYrBpIFu7o"},
{"content":{"body":"Does this look like an actual error or is it me?","m.mentions":{},"m.relates_to":{"event_id":"$PlY2N_x1py-ck0ko2XmSK36cs3ZCUshSRm9nZVvnk8s","is_falling_back":true,"m.in_reply_to":{"event_id":"$dUdSADtTCYgrleBoKjWPNwcqmWJt3seXIFXGqCWtb1w"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1747958412062,"senderName":"Hans","senderId":"@hanslarsen:matrix.org","id":"$gmuBm0moycHCljFBNapsRFHA6JgzR9E0PRbBuePZ0NQ"},
{"content":{"body":"The test's substep in question: https://github.com/tc39/test262/blob/main/test/staging/sm/Set/is-subset-of.js#L220-L248","m.mentions":{},"m.relates_to":{"event_id":"$PlY2N_x1py-ck0ko2XmSK36cs3ZCUshSRm9nZVvnk8s","is_falling_back":true,"m.in_reply_to":{"event_id":"$gmuBm0moycHCljFBNapsRFHA6JgzR9E0PRbBuePZ0NQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1747958464114,"senderName":"Hans","senderId":"@hanslarsen:matrix.org","id":"$QiM9s40WfSPjAvNW0P0ODCR58QaO7zmB_Q396EYpNXY"},
{"content":{"body":"The confusion is in what Set#delete() does","m.mentions":{},"m.relates_to":{"event_id":"$PlY2N_x1py-ck0ko2XmSK36cs3ZCUshSRm9nZVvnk8s","is_falling_back":true,"m.in_reply_to":{"event_id":"$QiM9s40WfSPjAvNW0P0ODCR58QaO7zmB_Q396EYpNXY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1747988249197,"senderName":"Ms2ger","senderId":"@ms2ger:igalia.com","id":"$v-WLQGvotZcSMYVuvfPHXNhakwmRSUQSYLnqzx8aVbQ"},
{"content":{"body":"In  your step 3, set is not [2, 3] but [empty, 2, 3]","m.mentions":{},"m.relates_to":{"event_id":"$PlY2N_x1py-ck0ko2XmSK36cs3ZCUshSRm9nZVvnk8s","is_falling_back":true,"m.in_reply_to":{"event_id":"$v-WLQGvotZcSMYVuvfPHXNhakwmRSUQSYLnqzx8aVbQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1747988265438,"senderName":"Ms2ger","senderId":"@ms2ger:igalia.com","id":"$DmWOb6u6smEt_xfbB_SGZObix288dfKFBkRyeaGxJlA"},
{"content":{"body":"That is confusing. I would have expected Set to not have holes. So it’s expected to act like an array with O(n) insertions?","m.relates_to":{"event_id":"$PlY2N_x1py-ck0ko2XmSK36cs3ZCUshSRm9nZVvnk8s","is_falling_back":true,"m.in_reply_to":{"event_id":"$DmWOb6u6smEt_xfbB_SGZObix288dfKFBkRyeaGxJlA"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1748039822869,"senderName":"Hans","senderId":"@hanslarsen:matrix.org","id":"$ThGgHMVm4sQi9iWME7K5ywvCOvM0PB3G4vS6YvpJBGY"},
{"content":{"body":"Essentially the model in my mind was more `Map<any, never>` (pardon my typescript) but it seems the expectation is akin to `Array<T>` with a special interface. ","format":"org.matrix.custom.html","formatted_body":"Essentially the model in my mind was more <code>Map&lt;any, never&gt;</code> (pardon my typescript) but it seems the expectation is akin to <code>Array&lt;T&gt;</code> with a special interface.","m.relates_to":{"event_id":"$PlY2N_x1py-ck0ko2XmSK36cs3ZCUshSRm9nZVvnk8s","is_falling_back":true,"m.in_reply_to":{"event_id":"$ThGgHMVm4sQi9iWME7K5ywvCOvM0PB3G4vS6YvpJBGY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1748039926055,"senderName":"Hans","senderId":"@hanslarsen:matrix.org","id":"$TftTTlBDp5-TD-8vv38cGOEC3QyeXzffaELYrevcU4I"},
{"content":{"body":"The specification of Set (and Map) should be understood as an illustrative fiction; actual implementations do not work like it","m.mentions":{},"m.relates_to":{"event_id":"$PlY2N_x1py-ck0ko2XmSK36cs3ZCUshSRm9nZVvnk8s","is_falling_back":true,"m.in_reply_to":{"event_id":"$TftTTlBDp5-TD-8vv38cGOEC3QyeXzffaELYrevcU4I"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1748042285956,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$sKWwNttfC9Lh_zUhIE2LpwkM5SRCwas3TD_p23nXJMg"},
{"content":{"body":"It is written that way to make it clear what behavior is expected but implementations can (and should) use faster data structures which provide the same observable behavior","m.mentions":{},"m.relates_to":{"event_id":"$PlY2N_x1py-ck0ko2XmSK36cs3ZCUshSRm9nZVvnk8s","is_falling_back":true,"m.in_reply_to":{"event_id":"$sKWwNttfC9Lh_zUhIE2LpwkM5SRCwas3TD_p23nXJMg"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1748042321283,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$scywctVrtSClwOb2OPe9u4FXW1NU0fAturjfmK7_GUs"},
{"content":{"body":"#tc39-general:matrix.org is a better place to talk about that if you have further questions though","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/#tc39-general:matrix.org\">#tc39-general:matrix.org</a> is a better place to talk about that if you have further questions though","m.mentions":{},"m.relates_to":{"event_id":"$PlY2N_x1py-ck0ko2XmSK36cs3ZCUshSRm9nZVvnk8s","is_falling_back":true,"m.in_reply_to":{"event_id":"$scywctVrtSClwOb2OPe9u4FXW1NU0fAturjfmK7_GUs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1748042334866,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$v-26dRveWc186l12GT80PcMZju2zglts1MZpBreg7HM"}
]