[
{"content":{"body":"1000 distinct cases, but are they all _meaningfully_ distinct?","format":"org.matrix.custom.html","formatted_body":"1000 distinct cases, but are they all <em>meaningfully</em> distinct?","m.mentions":{},"msgtype":"m.text"},"ts":1759334142584,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$8yf86SACoHnIvcFlju0J3wNJPHsXHPmMBc5zogE15ig"},
{"content":{"body":"I do quite like exhaustively testing large numbers of cases though! (I've been using that exact technique to search for bugs in Temporal implementations.)","m.mentions":{},"msgtype":"m.text"},"ts":1759334221620,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$9-FeneGNyVW08-dDjGw9iMVXiipvAxhnqvub1vukZ3g"},
{"content":{"body":"I think snapshot testing (like Jest has) is a good tool for that. if I had time, I'd build a snapshot testing facility for test262","m.mentions":{},"msgtype":"m.text"},"ts":1759334276925,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$G-9N4bku5CJ5v36wM2n2lWpLK-MYNxo_e_kiiub3QTU"},
{"content":{"body":"at least that way, IMO it'd be clearer that the intention isn't for implementations to conform to the results of the snapshots, but instead to investigate when a snapshot fails","m.mentions":{},"msgtype":"m.text"},"ts":1759334364904,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$wAeu2s4TJWPt1NjjvOiq3f8RioDfRaG3mz-tDjiZ1w4"},
{"content":{"body":"I think that's the risk with a mini-polyfill in test262 - it basically blesses the mini-polyfill as the reference implementation and says to all other implementations, \"you must match this implementation bug-for-bug\"","m.mentions":{},"msgtype":"m.text"},"ts":1759334422839,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$uZo4mEJON6aatQZvjwDmbE0F2NJcg6-oZF8p1bpZJp0"},
{"content":{"body":"anyway, I'll take another look at that PR and see if I have some suggestions to make it work more like \"checking invariant properties of outputs that must hold across multiple inputs\"","m.mentions":{},"msgtype":"m.text"},"ts":1759334516950,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$8CaFP9r-uuuAfvdrd1lEKYcp--buw3LZLarKiGUlUrY"},
{"content":{"body":"> says to all other implementations, \"you must match this implementation bug-for-bug\"\n\nI'd argue that snapshot tests do the same thing except that you don't get to see the implementation which generated those snapshots, so it's harder to tell where the mismatch comes from.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>says to all other implementations, \"you must match this implementation bug-for-bug\"</p>\n</blockquote>\n<p>I'd argue that snapshot tests do the same thing except that you don't get to see the implementation which generated those snapshots, so it's harder to tell where the mismatch comes from.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1759334580388,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$xtR0GTb0Mv0sG2ddFz8z5AD7FFTmPsnAdcMAET79ULI"},
{"content":{"body":"yes, I agree that's a risk as well. I think snapshots could better communicate the intention, though","m.mentions":{},"msgtype":"m.text"},"ts":1759334635053,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$xz2hwfKSRbkAqnFOGds6Y3oh4aGROg9lHfJBN2zgFDQ"},
{"content":{"body":"In my experience using both kinds of tests, the reference implementation has been a lot more useful for this kind of thing.","m.mentions":{},"msgtype":"m.text"},"ts":1759334658176,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$X-T5aiCYUNHASDAZrsIvgXagZvJ0UvKxxDN71mrjQD0"},
{"content":{"body":"In particular, sometimes there is a mismatch, and being able to track down why the implementations diverge is incredibly useful both in the case that my implementation is wrong and in the case that the one in the tests is wrong","m.mentions":{},"msgtype":"m.text"},"ts":1759334684020,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$MvjYrSztrD7x4lEFaI1v63Usuohuizhv9qk7xuk23eY"},
{"content":{"body":"I agree! I have a reference implementation of Temporal and I've found it very useful for writing test262 tests. but I'm not putting that reference implementation into test262","m.mentions":{},"msgtype":"m.text"},"ts":1759334726904,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$iTmLpmb9FwrzWVEVA6hHdjlyfUcynBzIlqGbNMrhb8Y"},
{"content":{"body":"I mean, why not?","msgtype":"m.text"},"ts":1759334837226,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$7lxQ431kklmXWokTMyTvzyRmnQvOYL265aHyhOkHp78"},
{"content":{"body":"For Temporal I suppose it's just very large but when it's small enough to be practical to check for correctness I don't see a strong reason not to.","msgtype":"m.text"},"ts":1759334878116,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Ay0PRiiKwSOcH7sB_J0w4iBuIdrfDv8j9ztAmsYcYMg"},
{"content":{"body":"Obviously it doesn't substitute for having other tests as well, but having some tests of the form \"compare a wide variety of cases vs a known-good implementation\" is great.","msgtype":"m.text"},"ts":1759334955592,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$kzyapWmVXO_Rs0BqY2QghVFFu9HpW589AsOKfahQVYE"},
{"content":{"body":"there was a ton of pushback about creating test262 in the first place because of the concern it would have reference implementations and be a \"blessed\" implementation; i think pragmatism has to lose out here","m.mentions":{},"msgtype":"m.text"},"ts":1759335689817,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$LiTUQBTh6orfoeMSSIRFshAMHbTVQdc-7z3bTbisf8c"},
{"content":{"body":"oh, I'm absolutely not for pragmatism losing out in any way shape or form","m.mentions":{},"msgtype":"m.text"},"ts":1759336136928,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$x3uS5zSRq9IkHYjd1wiZ1TwSIYiI6PRpNG4S_wMNu4A"},
{"content":{"body":"I think it should be possible to restructure that test like I suggested ^ above. maybe testing one invariant property at a time and making it clear what each of those tests is for.","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$8CaFP9r-uuuAfvdrd1lEKYcp--buw3LZLarKiGUlUrY"}},"msgtype":"m.text"},"ts":1759336422325,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$aHywDziUfV31fpZTpMpOpEWj0OTH1Wi6NN81F-3u1iE"},
{"content":{"body":"Richard may also have some suggestions, we discussed this PR at the last maintainers meeting","m.mentions":{},"msgtype":"m.text"},"ts":1759336448930,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$qAaDhkYF43yXxxfpn3G9LVkZE4oFdUrg-RXveZvhFn4"},
{"content":{"body":"So, the test is currently of the form \"for each of these wide variety of cases, all of the following properties should always hold\"","m.mentions":{},"msgtype":"m.text"},"ts":1759336603493,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$1MTPTIUb3i--JTthogdGUvy6Ua6DPrCVzwt1tbe4fBw"},
{"content":{"body":"you would want it to be a bunch of different tests which each repeat all of the setup for the wide variety of cases, and then test one property?","m.mentions":{},"msgtype":"m.text"},"ts":1759336633683,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$-FSwhqrkSC3u67-JU0cRrlQN-65_ieQijhpnAOojx8s"},
{"content":{"body":"that seems worse","m.mentions":{},"msgtype":"m.text"},"ts":1759336648233,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$MYI4epaA4AKg2C_7E3enuhQd8sB9ocZcuntA-xyeUa0"},
{"content":{"body":"also it turns out to be somewhat difficult to cleanly separate: e.g. the `strict` option throws when you exhaust the shortest iterator if the iterators are not the same length, so you either need to not pass that option when testing other properties or you need to compute the expected length and catch that error anyway","format":"org.matrix.custom.html","formatted_body":"also it turns out to be somewhat difficult to cleanly separate: e.g. the <code>strict</code> option throws when you exhaust the shortest iterator if the iterators are not the same length, so you either need to not pass that option when testing other properties or you need to compute the expected length and catch that error anyway","m.mentions":{},"msgtype":"m.text"},"ts":1759339018294,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$k19osS6tehGLtZjSzZORtwSWRktSvYruE-3SkmyIPGU"},
{"content":{"body":"I dunno. I guess, what is the goal of splitting this? As an implementer, the test is fine in its current form (except that it would benefit from having descriptive messages for all the asserts so you know which case failed). When maintaining the tests I personally would find this much easier to maintain than a bunch of duplication across tests, but I'm not a test262 owner. When reviewing, you need to confirm that a.) each of the properties being verified is actually required to hold per spec and b.) the properties are are being verified correctly, which seems like it would be just the same if split up.","m.mentions":{},"msgtype":"m.text"},"ts":1759339763704,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$yNow3HmOdQAhxxNzYk3B0uiCv56uLPnHVAZKAbOUl8c"},
{"content":{"body":"I haven't looked at it since a couple of weeks ago so I'm not sure I have anything more specific to say right now until I have a chance to look at it again","m.mentions":{},"msgtype":"m.text"},"ts":1759339880947,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$mQIh1xOHsrm7lJsMIzj2ExeSoCHXuJYj2oMEaoz2fjA"},
{"content":{"body":"I haven't looked at the PR, but am pretty firmly against including a reference implementation. I'm also against duplication, but that can be handled by common setup or a helper for that (given the stateful nature of iterators).","m.mentions":{},"msgtype":"m.text"},"ts":1759339881739,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$usZqk-_UpaowGRRO0dydKHMn7VZXDYWzZdVMp5lflhg"},
{"content":{"body":"at a minimum I'd want to make very clear in the assertion messages what the expectation is for implementations, i.e. do not blindly conform to this test","m.mentions":{},"msgtype":"m.text"},"ts":1759339954162,"senderName":"ptomato (intermittent availability)","senderId":"@pchimento:igalia.com","id":"$Mzduy2h8_-qFMYzKm5HesaSZxPK0P-2bvhgVYJZRqsw"},
{"content":{"body":"testing the *properties* with foreknowledge of what each iterator will produce should not require even a toy implementation, just a mapping of configuration inputs to expected properties","format":"org.matrix.custom.html","formatted_body":"testing the <em>properties</em> with foreknowledge of what each iterator will produce should not require even a toy implementation, just a mapping of configuration inputs to expected properties","m.mentions":{},"msgtype":"m.text"},"ts":1759339955775,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$jafx68-MpcNONQBCJNi5iYlgX600UekKf3XoPT6ramw"},
{"content":{"body":"I disagree on the reference implementation question but in this case that's not really what's happening. A representative example is, it's computing the expected length of the result iterator based on the lengths of the inputs and the mode:\n\n```\n  var lengths = iterables.map(function(array) {\n    return array.length;\n  });\n\n  var min = Math.min.apply(null, lengths);\n  var max = Math.max.apply(null, lengths);\n\n  // Expected number of iterations.\n  var count;\n  switch (mode) {\n    case \"shortest\":\n      count = min;\n      break;\n    case \"longest\":\n      count = max;\n      break;\n    case \"strict\":\n      count = max;\n      break;\n  }\n```","format":"org.matrix.custom.html","formatted_body":"<p>I disagree on the reference implementation question but in this case that's not really what's happening. A representative example is, it's computing the expected length of the result iterator based on the lengths of the inputs and the mode:</p>\n<pre><code>  var lengths = iterables.map(function(array) {\n    return array.length;\n  });\n\n  var min = Math.min.apply(null, lengths);\n  var max = Math.max.apply(null, lengths);\n\n  // Expected number of iterations.\n  var count;\n  switch (mode) {\n    case \"shortest\":\n      count = min;\n      break;\n    case \"longest\":\n      count = max;\n      break;\n    case \"strict\":\n      count = max;\n      break;\n  }\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1759339960581,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$zwYlM6wU18CPEjf5ak_u4QSw9QPf2jmbUWThq7neb0E"},
{"content":{"body":"Now, it _could_ hardcode these values for each of the 1000 cases it is testing, but... why? This is both clearer and easier to check.","format":"org.matrix.custom.html","formatted_body":"Now, it <em>could</em> hardcode these values for each of the 1000 cases it is testing, but... why? This is both clearer and easier to check.","m.mentions":{},"msgtype":"m.text"},"ts":1759340014814,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$0uCqMOk5agPNl_bhduddF5haG1bQ2bzMeh4G0zZxXLE"},
{"content":{"body":"that code looks good to me","m.mentions":{},"msgtype":"m.text"},"ts":1759340027507,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$KadUon8FBOLWosExo-NbF-FQi4GhI_whIxaQvdEN0hE"},
{"content":{"body":"and given that there probably are multiple files that need it, it should manifest as a helper function","m.mentions":{},"msgtype":"m.text"},"ts":1759340088916,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$Ziq29XP_B6dSMGJV-YCkgvkT2eh5NS9TPYusFdeY3Hg"},
{"content":{"body":"As is there is only one file which needs this.","m.mentions":{},"msgtype":"m.text"},"ts":1759340129132,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Xj7144NbSNMWdLmFPzRYaJNrQjB7PzbN9IVk_C7NYVY"},
{"content":{"body":"then the file is probably covering too much","m.mentions":{},"msgtype":"m.text"},"ts":1759340155431,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$sHBK2_UqEfGMkkWrDBFefN09-2OXc5I3AqHjxF_NUZE"},
{"content":{"body":"The other tests are mostly asserting on one precise output","m.mentions":{},"msgtype":"m.text"},"ts":1759340159431,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Jx9jvn1sOs7ocLDPAOgVQgNiNR4G8Qtr3Uw2rMrrZ48"},
{"content":{"body":"(or errors)","m.mentions":{},"msgtype":"m.text"},"ts":1759340190575,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$LlJwxWzW5jigVJWPZfAvOytbPVmd3ZTXZuFGU8fTuE4"},
{"content":{"body":"so, again, why do we care about \"covering too much\" for these kinds of many-inputs many-properties tests? Why is that important?","m.mentions":{},"msgtype":"m.text"},"ts":1759340254569,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$C96i8VHPc17ErNQ3uu_TdU03c4KQmhRZ3-jb8dV9GLo"},
{"content":{"body":"sidebar: what does \"helper\" mean in this context? a new file in the harness? if we factor out all code which is shared across files into a file in the harness the harness is going to get very big very quickly","m.mentions":{},"msgtype":"m.text"},"ts":1759340334124,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$chHCDKuKW8r2GjOHt2nLyn51ZwpdL7jJKsgAolU0QDA"},
{"content":{"body":"because test262 can only report one failure per file","m.mentions":{},"msgtype":"m.text"},"ts":1759340338193,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$YGSlNXunhgT5zlhsokuHBZKu2jVtPGBUOTFA8rmlLGk"},
{"content":{"body":"a file in https://github.com/tc39/test262/tree/main/harness","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$chHCDKuKW8r2GjOHt2nLyn51ZwpdL7jJKsgAolU0QDA"}},"msgtype":"m.text"},"ts":1759340402686,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$a1E9Ub_3UUqY7oRq_WufVZh6WAbgtPCKyFXxeQlGFS8"},
{"content":{"body":"yeah, but we still verify multiple properties at a time all over the place - there's lots of `verifyProperty` calls, rather than one test for enumerability, one test for writability, etc","format":"org.matrix.custom.html","formatted_body":"yeah, but we still verify multiple properties at a time all over the place - there's lots of <code>verifyProperty</code> calls, rather than one test for enumerability, one test for writability, etc","m.mentions":{"user_ids":["@gibson042:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$YGSlNXunhgT5zlhsokuHBZKu2jVtPGBUOTFA8rmlLGk"}},"msgtype":"m.text"},"ts":1759340538408,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$x7IjsqxjiRugQRfaSXwyD5rtQ-aKk1zFuiU-LRLOwLk"},
{"content":{"body":"when I'm doing an implementation I don't really care - I will fix the one failure and re-run until the errors go away","m.mentions":{},"msgtype":"m.text"},"ts":1759340552800,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$N28S-xcD5PGb2haceR7xcSg10DekrxYzGd_utSkYqPs"},
{"content":{"body":"`verifyProperty` encompasses multiple assertions, but it's testing one logical thing (a property of an object)","format":"org.matrix.custom.html","formatted_body":"<code>verifyProperty</code> encompasses multiple assertions, but it's testing one logical thing (a property of an object)","m.mentions":{},"msgtype":"m.text"},"ts":1759340627831,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$pzJgP5936YgxVOGh15YJbw6UMVkFEAENTleodNp_8ek"},
{"content":{"body":"at minimum, complete testing of `Iterator.zip` and `Iterator.zipKeyed` do not belong in a single file","format":"org.matrix.custom.html","formatted_body":"at minimum, complete testing of <code>Iterator.zip</code> and <code>Iterator.zipKeyed</code> do not belong in a single file","m.mentions":{},"msgtype":"m.text"},"ts":1759340658729,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$y69pE0K287oiJFf6NVAUhmykauwV3rX6ZiuSbpyAQ4I"},
{"content":{"body":"Those are not in the same file, no","m.mentions":{},"msgtype":"m.text"},"ts":1759340714273,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$AmKt0K3INDTW2YYcpqozIhMTfAfLYUAkhlLCuqYapUE"},
{"content":{"body":"(but they can't share the `count` code above because the input shapes are different)","format":"org.matrix.custom.html","formatted_body":"(but they can't share the <code>count</code> code above because the input shapes are different)","m.mentions":{},"msgtype":"m.text"},"ts":1759340735745,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$wGB7SwXHM8-9l8duQd8iuwTsFRFgabSQBHjZnVZlyDQ"},
{"content":{"body":"* there was a ton of pushback about creating test262 in the first place because of the concern it would have reference implementations and be a \"blessed\" implementation; i think pragmatism has to lose out here (if the alternative is an implementation)","m.mentions":{},"m.new_content":{"body":"there was a ton of pushback about creating test262 in the first place because of the concern it would have reference implementations and be a \"blessed\" implementation; i think pragmatism has to lose out here (if the alternative is an implementation)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$LiTUQBTh6orfoeMSSIRFshAMHbTVQdc-7z3bTbisf8c","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1759341278151,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$B03638tkwlq2IVcHjCSnkOYrIF6huYuvNeoFfu0CETs"},
{"content":{"body":"splitting the one test into two: https://github.com/anba/test262/pull/1","m.mentions":{},"msgtype":"m.text"},"ts":1759342497446,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$g6QXCTkSffam4zq3ohy6lM4JkPtmUXucUbkYpM8ZXAU"},
{"content":{"body":"I don't think it makes to split it further and frankly I don't think this is really an improvement, but is this what you're looking for?","m.mentions":{},"msgtype":"m.text"},"ts":1759342513189,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$e11vr8v3aq5ok5zVpu84w9QbgZOMYjMImmBXYt95HVw"}
]