[
{"content":{"body":"Seems like the sort of thing where if your concern was interop, step 1 would be an exhaustive test suite.","m.mentions":{},"msgtype":"m.text"},"ts":1710293087287,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$Fu1IsGIRYoNutZmmnKZMXLOkGIPmbcUzxJzP2rjXkI0"},
{"content":{"body":"I guess my biggest concern is whether we can maybe prevent other implementors from spending time evaluating that algorithm, if it‘s not actually important or useful for it to be actually be implemented as-is to the letter of the spec.","m.mentions":{},"msgtype":"m.text"},"ts":1710293366575,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$Pk9rdLY0uXsUxOdXprzPntJS3fyP7pBioZgAJhTipA8"},
{"content":{"body":"It’s not clear to me at least what the algorithm is actually based on","m.mentions":{},"msgtype":"m.text"},"ts":1710293385717,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$b2Zex3Z9p8eRrGNLD30-peNQAiLmTqlFgkLzJUZIS-k"},
{"content":{"body":"For example, was is written based on reading the double definition in the IEEE 754 spec and then attempting to put together an algorithm for parsing that? Or else was it written by looking at existing parsing code for double-parsing functions (`strtod` or whatever)?","format":"org.matrix.custom.html","formatted_body":"For example, was is written based on reading the double definition in the IEEE 754 spec and then attempting to put together an algorithm for parsing that? Or else was it written by looking at existing parsing code for double-parsing functions (<code>strtod</code> or whatever)?","m.mentions":{},"msgtype":"m.text"},"ts":1710293486757,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$J4gvGLxBwWfINdq8tuL4r2fJ6ZvsiyTvmBEaFKe6gM8"},
{"content":{"body":"I would personally be happy with us just adding a non-normative Note to the end or that algorithm, saying something like\n> _Note: In practice, rather than handcrafting an implementation of the above algorithm, most existing implementations use double-parsing functions from libraries such as [double-conversion](https://github.com/google/double-conversion) and [fast_float](https://github.com/fastfloat/fast_float)._\n…or whatever similar wording we might be able to get agreement on.","format":"org.matrix.custom.html","formatted_body":"<p>I would personally be happy with us just adding a non-normative Note to the end or that algorithm, saying something like</p>\n<blockquote>\n<p><em>Note: In practice, rather than handcrafting an implementation of the above algorithm, most existing implementations use double-parsing functions from libraries such as <a href=\"https://github.com/google/double-conversion\">double-conversion</a> and <a href=\"https://github.com/fastfloat/fast_float\">fast_float</a>.</em><br>…or whatever similar wording we might be able to get agreement on.</p>\n</blockquote>\n","m.mentions":{},"msgtype":"m.text"},"ts":1710293756894,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$MXJLq2AwMv4nhmeKpuw745z-K1CrmtgCbTavqodVpIA"},
{"content":{"body":" * I would personally be happy with us just adding a non-normative Note to the end or that algorithm, saying something like\n\n> _Note: In practice, rather than handcrafting an implementation of the above algorithm, most existing implementations use double-parsing functions from libraries such as [double-conversion](https://github.com/google/double-conversion) and [fast\\_float](https://github.com/fastfloat/fast_float)._\n\n…or whatever similar wording we might be able to get agreement on.","format":"org.matrix.custom.html","formatted_body":" * <p>I would personally be happy with us just adding a non-normative Note to the end or that algorithm, saying something like</p>\n<blockquote>\n<p><em>Note: In practice, rather than handcrafting an implementation of the above algorithm, most existing implementations use double-parsing functions from libraries such as <a href=\"https://github.com/google/double-conversion\">double-conversion</a> and <a href=\"https://github.com/fastfloat/fast_float\">fast_float</a>.</em></p>\n</blockquote>\n<p>…or whatever similar wording we might be able to get agreement on.</p>\n","m.mentions":{},"m.new_content":{"body":"I would personally be happy with us just adding a non-normative Note to the end or that algorithm, saying something like\n\n> _Note: In practice, rather than handcrafting an implementation of the above algorithm, most existing implementations use double-parsing functions from libraries such as [double-conversion](https://github.com/google/double-conversion) and [fast\\_float](https://github.com/fastfloat/fast_float)._\n\n…or whatever similar wording we might be able to get agreement on.","format":"org.matrix.custom.html","formatted_body":"<p>I would personally be happy with us just adding a non-normative Note to the end or that algorithm, saying something like</p>\n<blockquote>\n<p><em>Note: In practice, rather than handcrafting an implementation of the above algorithm, most existing implementations use double-parsing functions from libraries such as <a href=\"https://github.com/google/double-conversion\">double-conversion</a> and <a href=\"https://github.com/fastfloat/fast_float\">fast_float</a>.</em></p>\n</blockquote>\n<p>…or whatever similar wording we might be able to get agreement on.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$MXJLq2AwMv4nhmeKpuw745z-K1CrmtgCbTavqodVpIA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710293773598,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$JnOyxKxFKxX1pzCoFSAmmmgPFw5zmuhSwwT6Zl4onFg"},
{"content":{"body":"I think it’s also worth noting that the ES spec doesn’t rely on the HTML floating-point algorithm for double parsing, and I think the CSS spec doesn’t either.\n\nAnd so also worth noting that because of that, implementations do double-parsing in places in their code other than just for HTML attribute values — notably, in the JavaScript-handling sources, and in the CSS sources.\n\nAnd so, in the engine sources, implementations have common/shared code for double-parsing that‘s called into from the HTML-attribute parsing code, and the JavaScript parsing code, and the CSS parsing code.\n\nGiven all that, it seems very unlikely that any engine over the long run is going to have a specific implementation of the HTML floating-point algorithm that’s separate from their shared double-parsing code. (I realize that Ladybird does now, but I think that’s likely to change eventually — for various reasons, maybe including performance.)","m.mentions":{},"msgtype":"m.text"},"ts":1710294360641,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$R_IrwaTtRtLd9S4Cvyj5omFNGe5VGoetoVqS9YuvsbY"},
{"content":{"body":"I’m personally happy with the existing level of WPT coverage that we have for this — with https://github.com/web-platform-tests/wpt/pull/44355 now merged. What I’m less happy about is the effect it may have for causing implementors be unaware that existing engines don’t implement the algorithm as-is, and for causing implementors to potentially waste time.","m.mentions":{},"msgtype":"m.text"},"ts":1710294819305,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$2tSU-kp_k-rI6e3SyYxkxabVuQ2b06-3Ipy0CE05eTE"},
{"content":{"body":"I mean, in general it's pretty rare to implement spec algorithms as-is, especially for low-level stuff like numbers and strings. https://infra.spec.whatwg.org/#algorithm-conformance and all that.","m.mentions":{},"msgtype":"m.text"},"ts":1710294901488,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$GxnOOEjGC-3i56p5kU0tez6GRLi8fsHj0O0nCg8gS2o"},
{"content":{"body":"True, but in most cases what’s implemented in engines is an algorithm that’s handcrafted to be a workalike that’s functionally equivalent to the spec algorithm — rather than instead being implemented by just calling some code in a third-party library that you don’t know actually fully conforms to the requirements in the spec as written.","m.mentions":{},"msgtype":"m.text"},"ts":1710295084322,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$_DVKh4iOQm8r4z4Yx2CuZ4Tt56rRXl9drU1fUm3QaUI"},
{"content":{"body":"Anyway, I don’t mean to beat this into the ground and I’m not bringing it up to be pedantic about it — instead, I’m just wondering whether it’s a place where we might be able to save implementors some trouble by putting a little more information in the spec, even if just a non-normative note.","m.mentions":{},"msgtype":"m.text"},"ts":1710295214553,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$X_iZ7EVHRUbpuN9YlP8Qy7T8Y3eE5qDog5xN5GaWN0w"},
{"content":{"body":"And if so, I’d be very happy to raise a PR for it.","m.mentions":{},"msgtype":"m.text"},"ts":1710295238801,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$xQbaqsQDq-kHK0_WxXxjwOGfdVti02FEwvPRTvj3QIU"},
{"content":{"body":"I guess I'd personally like to hear if the implementers of the relevant parts of the browser were confused by the spec, or not. I guess we have one testimonial from yourself, but more would be helpful before concluding its a problem.","m.mentions":{},"msgtype":"m.text"},"ts":1710295316861,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$wBs6IuRA3aX815-wbKgtV_NdLs73vfwftT9bTlJ3Tr4"},
{"content":{"body":"Fair enough","m.mentions":{},"msgtype":"m.text"},"ts":1710295506588,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$_PkJHWhxdFgEHPumEqBwGNSxcGIbjjrI3Vwx64meBwM"},
{"content":{"body":"I assume all the implementations besides Servo and Ladybird long predate the spec","m.mentions":{},"msgtype":"m.text"},"ts":1710320085012,"senderName":"Ms2ger","senderId":"@ms2ger:igalia.com","id":"$O6-RWm5qldY7B-hwEe7fRKSqyWKX0PF6DecP3qzn5ZU"},
{"content":{"body":"yeah I reckon so","m.mentions":{},"msgtype":"m.text"},"ts":1710320114394,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$zVGk_ADC8RsL0SkjlEn0J9Z0xOreSx0iO00TuP_CZeM"},
{"content":{"body":"I think what is first- and third-party code can shift over time and it's not really the job of the specification to go into the weeds about that. If you find a library or function call that happens to match the requirements in the specification and passes all the tests, and is better in some measurable way over what you had before, more power to you. From what Jeffrey wrote about ISO C that at least doesn't match the spirit of the HTML language as it allows for less precision. HTML in theory also allows for that due to the overarching \"limits may apply\", but also encourages implementers to push those limits. I'm not sure a note would really help with this as it would have to go into the weeds as I have done here to properly convey all the nuances.","m.mentions":{},"msgtype":"m.text"},"ts":1710320513335,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$SM1NaHa5bxO7VjghcLKmdv3_-3Ex7IBlTIZUnblV7uY"},
{"content":{"body":"Yeah, as far as a note, I can imaging that it would be challenging to get the wording right","m.mentions":{},"msgtype":"m.text"},"ts":1710320568058,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$LJRsZWMb1ZA-zizaqflwjK75rocOub3WfscHyC9R8zk"},
{"content":{"body":"Also by the way, I realize I misspoke a bit about something: While it’s true that the Blink and Gecko and WebKit use double-conversion or fast_float — they don’t _just _ use those. Instead they have to do preprocessing to skip ASCII whitespace — not Unicode whitespace, and specifically not U+000B, and _maybe_ to skip/ignore any leading plus sign.\n\nfast_float uses a `from_chars` implementation rather than `strtod` — and `from_chars` on its own per-spec doesn’t skip/ignore leading whitespace. The docs say it also doesn’t skip/ignore a leading plus sign, but it seems to me that maybe the fast_float `from_chars` at least actually does.\n\nAnd I’m not sure if the double parser in double-conversion skips leading plus signs and whitespace — but if it _does_ skip whitespace, it would do it for Unicode whitespace, not the ASCII whitespace subset.\n\nSo anyway, to conform to the HTML algorithm, engines using any third-party libraries would need to do preprocessing on the strings — to skip/ignore the right kind of whitespace and (possibly) the plus sign.","format":"org.matrix.custom.html","formatted_body":"<p>Also by the way, I realize I misspoke a bit about something: While it’s true that the Blink and Gecko and WebKit use double-conversion or fast_float — they don’t _just _ use those. Instead they have to do preprocessing to skip ASCII whitespace —&nbsp;not Unicode whitespace, and specifically not U+000B, and <em>maybe</em> to skip/ignore any leading plus sign.</p>\n<p>fast_float uses a <code>from_chars</code> implementation rather than <code>strtod</code> — and <code>from_chars</code> on its own per-spec doesn’t skip/ignore leading whitespace. The docs say it also doesn’t skip/ignore a leading plus sign, but it seems to me that maybe the fast_float <code>from_chars</code> at least actually does.</p>\n<p>And I’m not sure if the double parser in double-conversion skips leading plus signs and whitespace —&nbsp;but if it <em>does</em> skip whitespace, it would do it for Unicode whitespace, not the ASCII whitespace subset.</p>\n<p>So anyway, to conform to the HTML algorithm, engines using any third-party libraries would need to do preprocessing on the strings — to skip/ignore the right kind of whitespace and (possibly) the plus sign.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1710321095643,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$AZoUgZwN1id-cuOibUrM6vqvhMQJR7FBsP637XBxYaU"},
{"content":{"body":"(and with that I’ll be quiet, and go back to trying to figure out how to correctly handle find-in-page for closed `details` that are nested…)","format":"org.matrix.custom.html","formatted_body":"(and with that I’ll be quiet, and go back to trying to figure out how to correctly handle find-in-page for closed <code>details</code> that are nested…)","m.mentions":{},"msgtype":"m.text"},"ts":1710321212649,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$vcrYrv8hHi4jsEoTYU6oa75vWW15ISm2YqU9vSO69JY"},
{"content":{"body":"How does one \"copy\" or \"clone\" an infra struct? There are several definitions for \"clone\" in infra, but none specifically for structs. Can we just say \"copy\" or \"clone\" manually?","m.mentions":{},"msgtype":"m.text"},"ts":1710335896507,"senderName":"Dominic Farolino","senderId":"@domfarolino:matrix.org","id":"$JwEcR7370nlPxJL4GtWbFvBEKD1SSFGtl0ToEuuxlc4"},
{"content":{"body":"I'd ask infra for a definition","m.mentions":{},"msgtype":"m.text"},"ts":1710336091582,"senderName":"Ms2ger","senderId":"@ms2ger:igalia.com","id":"$ALhmAq3pNvMYyf7lV_rGli2mnHmf0QISa1ib69QSkVY"},
{"content":{"body":"Hmm, maybe URL.parse() should be added: https://twitter.com/kilianvalkhof/status/1765312128188088454 (I disagree with the assertion there, but it seems reasonable to have a URL-or-null abstraction)","m.mentions":{},"msgtype":"m.text"},"ts":1710336223299,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$Q82WA-EovY8BFHfdmgWQeWJZCBgE2AjeNenRZ45lFGI"},
{"content":{"body":"Dominic Farolino: usually you clone a struct manually. Often enough some special processing needs to be done on one or more of the items (e.g. if one of the items is a list, do you want to clone the list or pass it by reference?)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@domfarolino:matrix.org\">Dominic Farolino</a>: usually you clone a struct manually. Often enough some special processing needs to be done on one or more of the items (e.g. if one of the items is a list, do you want to clone the list or pass it by reference?)","m.mentions":{"user_ids":["@domfarolino:matrix.org"]},"msgtype":"m.text"},"ts":1710342518491,"senderName":"Noam Rosenthal","senderId":"@noamr:matrix.org","id":"$i3evxRNNs26BEocZGfA6a5q_aVolpPJtEyg0ufbAQ0Q"},
{"content":{"body":"It seems reasonable to define a shallow clone for structs. We have that for lists and maps. Thus far nobody needed it for structs I guess. Should be a fairly straightforward PR.","m.mentions":{},"msgtype":"m.text"},"ts":1710342681411,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$KxdJc0y8yn5X-RCmkgBFl7-1Jilyd5bqFJh3WTjHY4w"},
{"content":{"body":"> <@annevk:matrix.org> Hmm, maybe URL.parse() should be added: https://twitter.com/kilianvalkhof/status/1765312128188088454 (I disagree with the assertion there, but it seems reasonable to have a URL-or-null abstraction)\n\nYes, having to use a try block every time you want to parse a URL is indeed very frustrating. If we had an expression-level way to catch an error and return a value, it wouldn't be as big of an issue, but in the absence of JS having that, we absolutely should have a non-throwing way to parse a URL (returning null on failure, definitely).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$Q82WA-EovY8BFHfdmgWQeWJZCBgE2AjeNenRZ45lFGI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:matrix.org\">@annevk:matrix.org</a><br>Hmm, maybe URL.parse() should be added: https://twitter.com/kilianvalkhof/status/1765312128188088454 (I disagree with the assertion there, but it seems reasonable to have a URL-or-null abstraction)</blockquote></mx-reply>Yes, having to use a try block every time you want to parse a URL is indeed very frustrating. If we had an expression-level way to catch an error and return a value, it wouldn't be as big of an issue, but in the absence of JS having that, we absolutely should have a non-throwing way to parse a URL (returning null on failure, definitely).","m.mentions":{"user_ids":["@annevk:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Q82WA-EovY8BFHfdmgWQeWJZCBgE2AjeNenRZ45lFGI"}},"msgtype":"m.text"},"ts":1710344163710,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$vYr4irFbpDNNY2iV8LE8XlbTCcQDmpOAUgOQnvViRZQ"},
{"content":{"body":"Reopened https://github.com/whatwg/url/issues/372 cc Adam Rice ","format":"org.matrix.custom.html","formatted_body":"Reopened https://github.com/whatwg/url/issues/372 cc <a href=\"https://matrix.to/#/@ricea:matrix.org\">Adam Rice</a>","m.mentions":{"user_ids":["@ricea:matrix.org"]},"msgtype":"m.text"},"ts":1710344471723,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$Y52q2XnIGCrVSjt8SxjKO7B_Ok2HZIiDknge3I_h6FE"},
{"content":{"body":"> <@sideshowbarker:matrix.org> I think it’s also worth noting that the ES spec doesn’t rely on the HTML floating-point algorithm for double parsing, and I think the CSS spec doesn’t either.\n> \n> And so also worth noting that because of that, implementations do double-parsing in places in their code other than just for HTML attribute values — notably, in the JavaScript-handling sources, and in the CSS sources.\n> \n> And so, in the engine sources, implementations have common/shared code for double-parsing that‘s called into from the HTML-attribute parsing code, and the JavaScript parsing code, and the CSS parsing code.\n> \n> Given all that, it seems very unlikely that any engine over the long run is going to have a specific implementation of the HTML floating-point algorithm that’s separate from their shared double-parsing code. (I realize that Ladybird does now, but I think that’s likely to change eventually — for various reasons, maybe including performance.)\n\nFWIW, +1 to having a single double-parsing algorithm that all of ES, CSS, and HTML can use ... if that's web-compatible. See also https://github.com/whatwg/infra/issues/189.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$R_IrwaTtRtLd9S4Cvyj5omFNGe5VGoetoVqS9YuvsbY?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@sideshowbarker:matrix.org\">@sideshowbarker:matrix.org</a><br>I think it’s also worth noting that the ES spec doesn’t rely on the HTML floating-point algorithm for double parsing, and I think the CSS spec doesn’t either.<br/><br/>And so also worth noting that because of that, implementations do double-parsing in places in their code other than just for HTML attribute values — notably, in the JavaScript-handling sources, and in the CSS sources.<br/><br/>And so, in the engine sources, implementations have common/shared code for double-parsing that‘s called into from the HTML-attribute parsing code, and the JavaScript parsing code, and the CSS parsing code.<br/><br/>Given all that, it seems very unlikely that any engine over the long run is going to have a specific implementation of the HTML floating-point algorithm that’s separate from their shared double-parsing code. (I realize that Ladybird does now, but I think that’s likely to change eventually — for various reasons, maybe including performance.)</blockquote></mx-reply>FWIW, +1 to having a single double-parsing algorithm that all of ES, CSS, and HTML can use ... if that's web-compatible. See also https://github.com/whatwg/infra/issues/189.","m.mentions":{"user_ids":["@sideshowbarker:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$R_IrwaTtRtLd9S4Cvyj5omFNGe5VGoetoVqS9YuvsbY"}},"msgtype":"m.text"},"ts":1710345468662,"senderName":"Jeffrey Yasskin","senderId":"@jyasskin:matrix.org","id":"$WFGx2SV3Ff1Ao33xocwXFR5GDEAA9Btiqk5tTleUzWk"},
{"content":{"body":"I'm not sure we should share with ES until we know how the long term number types thing plays out. It came up before and the main reason not to do it was to preserve infinite precision, which seems like a worthwhile goal for a high-level language.","m.mentions":{},"msgtype":"m.text"},"ts":1710345581869,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$2YW2IfnkENFlZef-gcI2wvZDxNLYMc5vGWhaoH8inGk"},
{"content":{"body":"CSS & HTML I can see though.","m.mentions":{},"msgtype":"m.text"},"ts":1710345601131,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$GdxmwVcoG6H97dMe0QYavQzP88JwFA8ZutOZFsOyvUY"},
{"content":{"body":"I don't feel strongly about the details, but we could explicitly divide the algorithm into 2 pieces: First we parse the string into an infinite-precision real number, which pins down syntax like whitespace and leading-plus behavior. Then we define the Real->IEEE 754 conversion, which establishes than 0 ULPs of error are allowed, and the round-to-even behavior. If ES wants to preserve infinite-precision arithmetic for a while after the string is parsed, that's fine; they just only call the first algorithm.","m.mentions":{},"msgtype":"m.text"},"ts":1710346507318,"senderName":"Jeffrey Yasskin","senderId":"@jyasskin:matrix.org","id":"$H6KbRW7kSqYBSD3SeUW6Q3v9UhxAdEstQO6B08_9odo"},
{"content":{"body":" * I don't feel strongly about the details, but we could explicitly divide the algorithm into 2 pieces: First we parse the string into an infinite-precision real number, which pins down syntax like whitespace and leading-plus behavior. Then we define the Real->IEEE 754 conversion, which establishes that 0 ULPs of error are allowed, and the round-to-even behavior. If ES wants to preserve infinite-precision arithmetic for a while after the string is parsed, that's fine; they just only call the first algorithm.","m.mentions":{},"m.new_content":{"body":"I don't feel strongly about the details, but we could explicitly divide the algorithm into 2 pieces: First we parse the string into an infinite-precision real number, which pins down syntax like whitespace and leading-plus behavior. Then we define the Real->IEEE 754 conversion, which establishes that 0 ULPs of error are allowed, and the round-to-even behavior. If ES wants to preserve infinite-precision arithmetic for a while after the string is parsed, that's fine; they just only call the first algorithm.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$H6KbRW7kSqYBSD3SeUW6Q3v9UhxAdEstQO6B08_9odo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710346518051,"senderName":"Jeffrey Yasskin","senderId":"@jyasskin:matrix.org","id":"$G3BsTzclt5LBnda_DLwCe9ka_6GbGQgxm4So1KByIH4"},
{"content":{"body":"Hi all. The HTML spec says, under [§4.13.4](https://html.spec.whatwg.org/#custom-elements-api), for \"Element definition\" list of steps, specifically step 18:\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\nThis suggests that e.g. `define(`foo-bar`, class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element)  ` will _not_ \"upgrade\" elements like `<span is=\"foo-bar\"></span>` (`span` is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the `name` for the element is `foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName` is same as `name` (step 5) since `extends` is null, and so only `foo-bar` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4</a>, for \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.<br>This suggests that e.g. <code>define(</code>foo-bar<code>, class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element)  <code>will _not_ \"upgrade\" elements like</code>&lt;span is=\"foo-bar\"&gt;<code> (</code>span<code>is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the</code>name<code>for the element is</code>foo-bar<code>, after all (established at the outset of the aforementioned list of steps), while </code>localName<code>is same as</code>name<code>(step 5) since</code>extends<code>is null, and so only</code>foo-bar` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n</blockquote>\n","m.mentions":{},"msgtype":"m.text"},"ts":1710352909225,"senderName":"judge_sour_dough_bread","senderId":"@judge_sour_dough_bread:matrix.org","id":"$GcDam_SMIUdyXxhLq8tAVe1kJAnvwvi1SF0WJclww_A"},
{"content":{"body":" * Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\nThis suggests that e.g. `define(`foo-bar`, class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element)  `will _not_ \"upgrade\" elements like`\\<span is=\"foo-bar\">` (`span`is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName`is same as`name`(step 5) since`extends`is null, and so only`foo-bar\\` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.<br>This suggests that e.g. <code>define(</code>foo-bar<code>, class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element)  <code>will _not_ \"upgrade\" elements like</code>&lt;span is=\"foo-bar\"&gt;<code> (</code>span<code>is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the</code>name<code>for the element is</code>foo-bar<code>, after all (established at the outset of the aforementioned list of steps), while </code>localName<code>is same as</code>name<code>(step 5) since</code>extends<code>is null, and so only</code>foo-bar` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n</blockquote>\n","m.mentions":{},"m.new_content":{"body":"Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\nThis suggests that e.g. `define(`foo-bar`, class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element)  `will _not_ \"upgrade\" elements like`\\<span is=\"foo-bar\">` (`span`is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName`is same as`name`(step 5) since`extends`is null, and so only`foo-bar\\` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.<br>This suggests that e.g. <code>define(</code>foo-bar<code>, class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element)  <code>will _not_ \"upgrade\" elements like</code>&lt;span is=\"foo-bar\"&gt;<code> (</code>span<code>is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the</code>name<code>for the element is</code>foo-bar<code>, after all (established at the outset of the aforementioned list of steps), while </code>localName<code>is same as</code>name<code>(step 5) since</code>extends<code>is null, and so only</code>foo-bar` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n</blockquote>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$GcDam_SMIUdyXxhLq8tAVe1kJAnvwvi1SF0WJclww_A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710352970368,"senderName":"judge_sour_dough_bread","senderId":"@judge_sour_dough_bread:matrix.org","id":"$Ud4n_Ckjur_AjucNtKKkTLgk5upkRDUvcxYmqDQ1WpE"},
{"content":{"body":" * Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\n\nThis suggests that e.g. `define(`foo-bar`, class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element)  `will _not_ \"upgrade\" elements like`\\<span is=\"foo-bar\">` (`span`is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName`is same as`name`(step 5) since`extends`is null, and so only`foo-bar\\` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.</p>\n</blockquote>\n<p>This suggests that e.g. <code>define(</code>foo-bar<code>, class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element)  <code>will _not_ \"upgrade\" elements like</code>&lt;span is=\"foo-bar\"&gt;<code> (</code>span<code>is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the</code>name<code>for the element is</code>foo-bar<code>, after all (established at the outset of the aforementioned list of steps), while </code>localName<code>is same as</code>name<code>(step 5) since</code>extends<code>is null, and so only</code>foo-bar` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\n\nThis suggests that e.g. `define(`foo-bar`, class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element)  `will _not_ \"upgrade\" elements like`\\<span is=\"foo-bar\">` (`span`is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName`is same as`name`(step 5) since`extends`is null, and so only`foo-bar\\` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.</p>\n</blockquote>\n<p>This suggests that e.g. <code>define(</code>foo-bar<code>, class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element)  <code>will _not_ \"upgrade\" elements like</code>&lt;span is=\"foo-bar\"&gt;<code> (</code>span<code>is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the</code>name<code>for the element is</code>foo-bar<code>, after all (established at the outset of the aforementioned list of steps), while </code>localName<code>is same as</code>name<code>(step 5) since</code>extends<code>is null, and so only</code>foo-bar` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$GcDam_SMIUdyXxhLq8tAVe1kJAnvwvi1SF0WJclww_A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710352984320,"senderName":"judge_sour_dough_bread","senderId":"@judge_sour_dough_bread:matrix.org","id":"$1WSngxJ_CxLTkEtfZtRlK-t0EBlH6_p0HyUrUAc2UMc"},
{"content":{"body":" * Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\n\nThis suggests that e.g. `define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element) will _not_ \"upgrade\" elements like`\\<span is=\"foo-bar\">` (`span`is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName`is same as`name`(step 5) since`extends`is null, and so only`foo-bar\\` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.</p>\n</blockquote>\n<p>This suggests that e.g. <code>define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element) will <em>not</em> \"upgrade\" elements like<code>\\&lt;span is=\"foo-bar\"&gt;</code> (<code>span</code>is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the<code>name</code>for the element is<code>foo-bar</code>, after all (established at the outset of the aforementioned list of steps), while <code>localName</code>is same as<code>name</code>(step 5) since<code>extends</code>is null, and so only<code>foo-bar\\</code> element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\n\nThis suggests that e.g. `define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element) will _not_ \"upgrade\" elements like`\\<span is=\"foo-bar\">` (`span`is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName`is same as`name`(step 5) since`extends`is null, and so only`foo-bar\\` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.</p>\n</blockquote>\n<p>This suggests that e.g. <code>define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element) will <em>not</em> \"upgrade\" elements like<code>\\&lt;span is=\"foo-bar\"&gt;</code> (<code>span</code>is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the<code>name</code>for the element is<code>foo-bar</code>, after all (established at the outset of the aforementioned list of steps), while <code>localName</code>is same as<code>name</code>(step 5) since<code>extends</code>is null, and so only<code>foo-bar\\</code> element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$GcDam_SMIUdyXxhLq8tAVe1kJAnvwvi1SF0WJclww_A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710353009834,"senderName":"judge_sour_dough_bread","senderId":"@judge_sour_dough_bread:matrix.org","id":"$3hh-gKB_8_J5iH0s7ZGseYxXTZTM79oDnr1xrF7xSgQ"},
{"content":{"body":" * Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\n\nThis suggests that e.g. `define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element) will _not_ \"upgrade\" elements like`<span is=\"foo-bar\"><!-- ... --></span>` (`span`is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName` is same as`name` (step 5) since`extends` is null, and so only`<foo-bar><!-- ... --></foo-bar>` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.</p>\n</blockquote>\n<p>This suggests that e.g. <code>define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element) will <em>not</em> \"upgrade\" elements like<code>&lt;span is=\"foo-bar\"&gt;&lt;!-- ... --&gt;&lt;/span&gt;</code> (<code>span</code>is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the<code>name</code>for the element is<code>foo-bar</code>, after all (established at the outset of the aforementioned list of steps), while <code>localName</code> is same as<code>name</code> (step 5) since<code>extends</code> is null, and so only<code>&lt;foo-bar&gt;&lt;!-- ... --&gt;&lt;/foo-bar&gt;</code> element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\n\nThis suggests that e.g. `define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element) will _not_ \"upgrade\" elements like`<span is=\"foo-bar\"><!-- ... --></span>` (`span`is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName` is same as`name` (step 5) since`extends` is null, and so only`<foo-bar><!-- ... --></foo-bar>` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.</p>\n</blockquote>\n<p>This suggests that e.g. <code>define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element) will <em>not</em> \"upgrade\" elements like<code>&lt;span is=\"foo-bar\"&gt;&lt;!-- ... --&gt;&lt;/span&gt;</code> (<code>span</code>is an example, any other known HTML element will do as well), correct? To explain how I have assumed this: the<code>name</code>for the element is<code>foo-bar</code>, after all (established at the outset of the aforementioned list of steps), while <code>localName</code> is same as<code>name</code> (step 5) since<code>extends</code> is null, and so only<code>&lt;foo-bar&gt;&lt;!-- ... --&gt;&lt;/foo-bar&gt;</code> element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$GcDam_SMIUdyXxhLq8tAVe1kJAnvwvi1SF0WJclww_A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710353071073,"senderName":"judge_sour_dough_bread","senderId":"@judge_sour_dough_bread:matrix.org","id":"$fENv_Fd1pDAiEZk0jhI40hSqE0B8DcaLZs12BBCKd2M"},
{"content":{"body":" * Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\n\nThis suggests that e.g. `define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element) will _not_ \"upgrade\" elements like`<span is=\"foo-bar\"><!-- ... --></span>` (`span` can be replaced with any other known HTML element for the sake of the example), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName` is same as`name` (step 5) since`extends` is null, and so only`<foo-bar><!-- ... --></foo-bar>` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.</p>\n</blockquote>\n<p>This suggests that e.g. <code>define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element) will <em>not</em> \"upgrade\" elements like<code>&lt;span is=\"foo-bar\"&gt;&lt;!-- ... --&gt;&lt;/span&gt;</code> (<code>span</code> can be replaced with any other known HTML element for the sake of the example), correct? To explain how I have assumed this: the<code>name</code>for the element is<code>foo-bar</code>, after all (established at the outset of the aforementioned list of steps), while <code>localName</code> is same as<code>name</code> (step 5) since<code>extends</code> is null, and so only<code>&lt;foo-bar&gt;&lt;!-- ... --&gt;&lt;/foo-bar&gt;</code> element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all. The HTML spec says, under [§4.13.4, \"The `CustomElementRegistry` interface\"](https://html.spec.whatwg.org/#custom-elements-api), for the \"Element definition\" list of steps, specifically step 18:\n\n> Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.\n\nThis suggests that e.g. `define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })` (autonomous custom element) will _not_ \"upgrade\" elements like`<span is=\"foo-bar\"><!-- ... --></span>` (`span` can be replaced with any other known HTML element for the sake of the example), correct? To explain how I have assumed this: the`name`for the element is`foo-bar`, after all (established at the outset of the aforementioned list of steps), while `localName` is same as`name` (step 5) since`extends` is null, and so only`<foo-bar><!-- ... --></foo-bar>` element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all. The HTML spec says, under <a href=\"https://html.spec.whatwg.org/#custom-elements-api\">§4.13.4, \"The <code>CustomElementRegistry</code> interface\"</a>, for the \"Element definition\" list of steps, specifically step 18:</p>\n<blockquote>\n<p>Let upgrade candidates be all elements that are shadow-including descendants of document, whose namespace is the HTML namespace and whose local name is localName, in shadow-including tree order. Additionally, if extends is non-null, only include elements whose is value is equal to name.</p>\n</blockquote>\n<p>This suggests that e.g. <code>define(\"foo-bar\", class FooBarElement extends HTMLElement { /* ... */ })</code> (autonomous custom element) will <em>not</em> \"upgrade\" elements like<code>&lt;span is=\"foo-bar\"&gt;&lt;!-- ... --&gt;&lt;/span&gt;</code> (<code>span</code> can be replaced with any other known HTML element for the sake of the example), correct? To explain how I have assumed this: the<code>name</code>for the element is<code>foo-bar</code>, after all (established at the outset of the aforementioned list of steps), while <code>localName</code> is same as<code>name</code> (step 5) since<code>extends</code> is null, and so only<code>&lt;foo-bar&gt;&lt;!-- ... --&gt;&lt;/foo-bar&gt;</code> element(s) in the document will be upgraded. Can someone tell me my reading of the spec is correct?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$GcDam_SMIUdyXxhLq8tAVe1kJAnvwvi1SF0WJclww_A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710353530410,"senderName":"judge_sour_dough_bread","senderId":"@judge_sour_dough_bread:matrix.org","id":"$Aws5Hr2aGb5vebBhXPUVuriAQr-FFyXss5wFvIUuXfk"}
]