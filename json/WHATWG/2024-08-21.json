[
{"content":{"body":"Turning it off, at least for now, sounds good; thank you!","msgtype":"m.text"},"ts":1724202083646,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$xl8O66LnsYKnf8FlrX9-vnDu5bT4MKq8Kff0Uhb_sy4"},
{"content":{"body":"I'm not convinced Privacy & Security sections are a net positive. They need to be an integral part of feature design.","m.mentions":{},"msgtype":"m.text"},"ts":1724223756430,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$6QihPZIG1r1eS8bmj9h6Mpx_RvOFfVxYNxkXfbeF7gI"},
{"content":{"body":"Not a WHATWG steering commitee member, but I think we all know that privacy/security/a11y is seldomly well-solved when done as an afterthought. So, it would be more important to have this required for all specs during design phase (as anne says, I believe?) and thus enable these checks for all new specs","m.mentions":{},"msgtype":"m.text"},"ts":1724226999759,"senderName":"freddy","senderId":"@fbraun:mozilla.org","id":"$61gh8olETuP3vAQOZzTwXLulejDGGv6pu4wynLg_zlw"},
{"content":{"body":"(Solutionism: Maybe there's could be a tag, like \"legacy-no-security-privacy-section\" that could be applied to old specs _and_ do the check such that that new specs will get the warning)","format":"org.matrix.custom.html","formatted_body":"(Solutionism: Maybe there's could be a tag, like \"legacy-no-security-privacy-section\" that could be applied to old specs <em>and</em> do the check such that that new specs will get the warning)","m.mentions":{},"msgtype":"m.text"},"ts":1724227059373,"senderName":"freddy","senderId":"@fbraun:mozilla.org","id":"$mzzaNPxPN4zrdeiaGnZISb2-xe7FrsbpIEDcd5uv_8g"},
{"content":{"body":"No, I'm saying these sections don't help. They often lead to people making normative statements in these sections that really should be part of the processing model.","m.mentions":{},"msgtype":"m.text"},"ts":1724227486085,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$SMP8duMYqdkxTUq-LsF2rLkNSc04sYiP-8oZa2nBp4w"},
{"content":{"body":"I'm not ready to make a blanket statement that the sections don't help, but I will strongly agree that I've seen that antipattern quite often.","m.mentions":{},"msgtype":"m.text"},"ts":1724227773528,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$tyRDuwY3nEVox0DXqRZhRC6mp_GhteKtPMb9GRdDY6s"},
{"content":{"body":"I guess they feel more like explainer sections than spec sections to me. But then we get into the old discussion about how much explanatory/non-normative text is helpful in a spec.","m.mentions":{},"msgtype":"m.text"},"ts":1724227883326,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$IME9hqycFuyxrJGiXCeZAQEyg-DfVO_dCc5ijDG0ZSM"},
{"content":{"body":"Yeah fair. I just think that if you need these sections to get something that's good security & privacy-wise, you've likely failed. But they can be useful to add some context, e.g., https://encoding.spec.whatwg.org/#security-background","m.mentions":{},"msgtype":"m.text"},"ts":1724229286587,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$-zkJX-O48Zl7uJJc6aqlorlcqAVImaEigT_XjGuoUkg"},
{"content":{"body":"freddy: see also the somewhat painful https://github.com/whatwg/dom/issues/776 and https://github.com/whatwg/dom/issues/777 which resulted in https://dom.spec.whatwg.org/#security-and-privacy. I could see it being helpful, but I can also see it leading to people not critically thinking about it for themselves.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@fbraun:mozilla.org\">freddy</a>: see also the somewhat painful https://github.com/whatwg/dom/issues/776 and https://github.com/whatwg/dom/issues/777 which resulted in https://dom.spec.whatwg.org/#security-and-privacy. I could see it being helpful, but I can also see it leading to people not critically thinking about it for themselves.","m.mentions":{"user_ids":["@fbraun:mozilla.org"]},"msgtype":"m.text"},"ts":1724241571895,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$f8MNX6wNAFftkKkYIOBEqmf40zMG9jrdrINpULdM_Jg"},
{"content":{"body":"Intentional or accidental that JSON modules integration ended up with a normative reference to IETF JSON instead of using the same specification mechanisms as Fetch?","m.mentions":{},"msgtype":"m.text"},"ts":1724243569516,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$xiscZHQD2dclpFBx8bYZY5kg2LbmU1h-NahimunrKVw"},
{"content":{"body":"hsivonen: oh wow, that seems bogus.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: oh wow, that seems bogus.","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"ts":1724243735208,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$mtQcYEBlXl1xrGhBkokPt2OGRFyocHMWJ_6aam3XPFM"},
{"content":{"body":"I wonder if people here have a term for \"hash including hash sign\" and \"search including question mark\", as an alternative way of solving https://github.com/whatwg/url/issues/779. We could do `hasSearch` that returns a boolean, but `searchWithSyntax` (if there's a better name) that returns `?test` instead of `test` might be more convenient.","format":"org.matrix.custom.html","formatted_body":"I wonder if people here have a term for \"hash including hash sign\" and \"search including question mark\", as an alternative way of solving https://github.com/whatwg/url/issues/779. We could do <code>hasSearch</code> that returns a boolean, but <code>searchWithSyntax</code> (if there's a better name) that returns <code>?test</code> instead of <code>test</code> might be more convenient.","m.mentions":{},"msgtype":"m.text"},"ts":1724243853031,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$Rs6i_hD2K3gpycDGh9TyzTmT9R41ngi1YmR_PI9EkdY"},
{"content":{"body":"hsivonen: oh actually, I think it might be a result of where the MIME type is defined","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: oh actually, I think it might be a result of where the MIME type is defined","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"ts":1724243943288,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$iYTzFB4t2zbRH9v9Aje79tBwX0XFO2ojm1M12N_qlsI"},
{"content":{"body":"I'm trying to figure out if HTML ends up allowing non-UTF-8 encodings for JSON modules...","m.mentions":{},"msgtype":"m.text"},"ts":1724244013370,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$Hsg6GK0j_SIseQr_OgaddGJqfUswtlGX5f8QplcVnHM"},
{"content":{"body":"hsivonen: because for parsing we do end up calling the same %JSON.parse% operation as far as I can tell","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: because for parsing we do end up calling the same %JSON.parse% operation as far as I can tell","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"ts":1724244030517,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$_5-vMx1Eho5HFo2CmiyOqVHVlEHBNjKXi6QkpbXXLrs"},
{"content":{"body":"hsivonen: we don't, see the logic in https://html.spec.whatwg.org/#fetch-a-single-module-script","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: we don't, see the logic in https://html.spec.whatwg.org/#fetch-a-single-module-script","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"ts":1724244059373,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$1Wu9f49TLhtt8tJeG-eOREiarGMvIHkeu8nEX1vQ4zQ"},
{"content":{"body":"hsivonen: in particular 13.2 and then 13.9","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: in particular 13.2 and then 13.9","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"ts":1724244095912,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$zhuoZVHlVDZvWs_19zhzR0fbhOPu5mUcgod-rCLAoCQ"},
{"content":{"body":"> <@annevk:matrix.org> hsivonen: in particular 13.2 and then 13.9\n\nThanks.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$zhuoZVHlVDZvWs_19zhzR0fbhOPu5mUcgod-rCLAoCQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:matrix.org\">@annevk:matrix.org</a><br><a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: in particular 13.2 and then 13.9</blockquote></mx-reply>Thanks.","m.mentions":{"user_ids":["@annevk:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zhuoZVHlVDZvWs_19zhzR0fbhOPu5mUcgod-rCLAoCQ"}},"msgtype":"m.text"},"ts":1724244132345,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$eykhzcA4h0bp2aP3rQvL7rcSP_iJo0AExWTI1uE0WpE"},
{"content":{"body":"> <@annevk:matrix.org> hsivonen: oh actually, I think it might be a result of where the MIME type is defined\n\nIt appears in HTML as a conformance requirement beyond the MIME type.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$iYTzFB4t2zbRH9v9Aje79tBwX0XFO2ojm1M12N_qlsI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:matrix.org\">@annevk:matrix.org</a><br><a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: oh actually, I think it might be a result of where the MIME type is defined</blockquote></mx-reply>It appears in HTML as a conformance requirement beyond the MIME type.","m.mentions":{"user_ids":["@annevk:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$iYTzFB4t2zbRH9v9Aje79tBwX0XFO2ojm1M12N_qlsI"}},"msgtype":"m.text"},"ts":1724244160369,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$GMm5Fe9OlVTM_X9RzG1HyHI_DNwIUz8yrsXyowAOafk"},
{"content":{"body":"Yeah, there might also be some [JSON] copypasta. Seems reasonable to file an issue to address at one point.","m.mentions":{},"msgtype":"m.text"},"ts":1724244214752,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$HzVh5aC3IVixeBwu3R-doSVRoAlgJz81kA8jxqNidtY"},
{"content":{"body":"Oh, the encoding requirements of this version of IETF JSON are more reasonable than past IETF JSON.","m.mentions":{},"msgtype":"m.text"},"ts":1724245832630,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$9msknZD4u-pXEDIL3CjC-3M7tFyAsj2FLMkiIg2gkm4"},
{"content":{"body":"hsivonen: I think at some point I pushed them pretty hard with the XMLHttpRequest \"precedent\" and that we were not going to change our ways","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: I think at some point I pushed them pretty hard with the XMLHttpRequest \"precedent\" and that we were not going to change our ways","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"ts":1724246607800,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$pOpCI8H8QGIibnjMdQUC_d6McI1ZqmrVSutOs35Lmb4"},
{"content":{"body":"It's funny that RFC8259 requires both encoding as utf-8 and escapes as utf-16","msgtype":"m.text"},"ts":1724247242407,"senderName":"easrng","senderId":"@easrng:yuri.im","id":"$Jh9n5Cu7YS6VnGY7BaubVBBVCvftWYTIYPsGkWs9bCw"},
{"content":{"body":"Yeah, JavaScript was developed in the 16-bits are enough for all characters in the world days. And I guess since JSON is frozen-in-time and happened before the 21-bit escapes were added to JavaScript everyone will have to learn about that legacy anew.","m.mentions":{},"msgtype":"m.text"},"ts":1724247460786,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$ghJx9dvGhZ0fF0kfMEWWVMEx18XlInp3L-fRC56gvFw"},
{"content":{"body":"Hi All!\nI need some help on how to handle backpressure for the ReadableSide of a Transform stream.\n\nFor example I am trying to implement a replace text functionality, where I replace a string of text coming from a ReadableStream with text coming from a second Readable stream, so far I couldn't find any example for this using whatwg streams.\n\nThis is pseudo code, so for simplicity I'm pretending like the text to replace won't span chunk boundaries\n\n```javascript\nclass Transformer {\n  async transform(chunk, controller) {\n    const foundTextIndex = chunk.indexOf('text to replace');\n    \n    if (foundTextIndex === -1) {\n      controller.enqueue(chunk);\n      return;\n    }\n\n    // Enqueue text before the part that needs to be replaced\n    controller.enqueue(chunk.slice(0, foundTextIndex));\n    \n    // This is where we do the replacement, we enqueue the text from the second source \n    // this is the part I'm not sure on how to handle, like for example what if we are adding\n    // chunks to the readable sides, but it's internal queue is full full\n    for await (const chunk of streamForReplacement) {\n     controller.enqueue(chunk.slice(0, foundTextIndex));\n     console.log(chunk);\n   }\n   \n    // Enqueue text after replacement\n    controller.enqueue(chunk.slice(foundTextIndex + 'text to replace'.length));\n  }\n}\n```\n\nOne thing I saw thanks to good old `chatGTP` was to use `Promise.resolve()` to wait for the next event loop tick in case the `desiredSize` was negative.\n\nFor example\n```javascript\nclass Transformer {\n  async transform(chunk, controller) {\n    const foundTextIndex = chunk.indexOf('text to replace');\n    \n    if (foundTextIndex === -1) {\n      controller.enqueue(chunk);\n      return;\n    }\n\n    // Enqueue text before the part that needs to be replaced\n    controller.enqueue(chunk.slice(0, foundTextIndex));\n    \n    // Enqueue the text from the second source with backpressure support (maybe)\n    for await (const chunk of streamForReplacement) {\n     while (controller.desiredSize <= 0) {\n       await Promise.resolve(); // wait for next tick to check if we can enqueue more chunks\n     }\n     controller.enqueue(chunk.slice(0, foundTextIndex));\n   }\n   \n    // Enqueue text after replacement\n    controller.enqueue(chunk.slice(foundTextIndex));\n  }\n}\n```\n\nI'm not sure if doing `Promise.resolve();` is valid, as I couldn't find any example dealing with this problem, and I want to know if there are better alternatives? I would really appreciate if someone could help with this and point me in the right direction","format":"org.matrix.custom.html","formatted_body":"<p>Hi All!<br>I need some help on how to handle backpressure for the ReadableSide of a Transform stream.</p>\n<p>For example I am trying to implement a replace text functionality, where I replace a string of text coming from a ReadableStream with text coming from a second Readable stream, so far I couldn't find any example for this using whatwg streams.</p>\n<p>This is pseudo code, so for simplicity I'm pretending like the text to replace won't span chunk boundaries</p>\n<pre><code class=\"language-javascript\">class Transformer {\n  async transform(chunk, controller) {\n    const foundTextIndex = chunk.indexOf('text to replace');\n    \n    if (foundTextIndex === -1) {\n      controller.enqueue(chunk);\n      return;\n    }\n\n    // Enqueue text before the part that needs to be replaced\n    controller.enqueue(chunk.slice(0, foundTextIndex));\n    \n    // This is where we do the replacement, we enqueue the text from the second source \n    // this is the part I'm not sure on how to handle, like for example what if we are adding\n    // chunks to the readable sides, but it's internal queue is full full\n    for await (const chunk of streamForReplacement) {\n     controller.enqueue(chunk.slice(0, foundTextIndex));\n     console.log(chunk);\n   }\n   \n    // Enqueue text after replacement\n    controller.enqueue(chunk.slice(foundTextIndex + 'text to replace'.length));\n  }\n}\n</code></pre>\n<p>One thing I saw thanks to good old <code>chatGTP</code> was to use <code>Promise.resolve()</code> to wait for the next event loop tick in case the <code>desiredSize</code> was negative.</p>\n<p>For example</p>\n<pre><code class=\"language-javascript\">class Transformer {\n  async transform(chunk, controller) {\n    const foundTextIndex = chunk.indexOf('text to replace');\n    \n    if (foundTextIndex === -1) {\n      controller.enqueue(chunk);\n      return;\n    }\n\n    // Enqueue text before the part that needs to be replaced\n    controller.enqueue(chunk.slice(0, foundTextIndex));\n    \n    // Enqueue the text from the second source with backpressure support (maybe)\n    for await (const chunk of streamForReplacement) {\n     while (controller.desiredSize &lt;= 0) {\n       await Promise.resolve(); // wait for next tick to check if we can enqueue more chunks\n     }\n     controller.enqueue(chunk.slice(0, foundTextIndex));\n   }\n   \n    // Enqueue text after replacement\n    controller.enqueue(chunk.slice(foundTextIndex));\n  }\n}\n</code></pre>\n<p>I'm not sure if doing <code>Promise.resolve();</code> is valid, as I couldn't find any example dealing with this problem, and I want to know if there are better alternatives? I would really appreciate if someone could help with this and point me in the right direction</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1724260064890,"senderName":"Vuk Stefanovic","senderId":"@vuk97:matrix.org","id":"$cbI-G-6UJqwQqzYn2DOdjT8YFCunQ-307k4dl_KOMGY"},
{"content":{"body":"Can’t help with the spec side of things, but await Promise.resolve() is only going to be a microtask, so as I understand it there won’t be time for other tasks (like IO, browser events) to take place","msgtype":"m.text"},"ts":1724261648416,"senderName":"Colin Alworth","senderId":"@niloc132:delightfullyoffto.pics","id":"$063gIDNYaXu6MWtH8kuvy5LzObX5kwsKO8oOdwWg8PM"},
{"content":{"body":"> <@niloc132:delightfullyoffto.pics> Can’t help with the spec side of things, but await Promise.resolve() is only going to be a microtask, so as I understand it there won’t be time for other tasks (like IO, browser events) to take place\n\nThis will actually be running in a Node env, not browser, it's going to be running in an edge function, where I get HTLM as streams and I need to combine main page with some other fragments and return that in the response","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$063gIDNYaXu6MWtH8kuvy5LzObX5kwsKO8oOdwWg8PM?via=matrix.org&via=yuri.im&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@niloc132:delightfullyoffto.pics\">@niloc132:delightfullyoffto.pics</a><br>Can’t help with the spec side of things, but await Promise.resolve() is only going to be a microtask, so as I understand it there won’t be time for other tasks (like IO, browser events) to take place</blockquote></mx-reply>This will actually be running in a Node env, not browser, it's going to be running in an edge function, where I get HTLM as streams and I need to combine main page with some other fragments and return that in the response","m.mentions":{"user_ids":["@niloc132:delightfullyoffto.pics"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$063gIDNYaXu6MWtH8kuvy5LzObX5kwsKO8oOdwWg8PM"}},"msgtype":"m.text"},"ts":1724263883943,"senderName":"Vuk Stefanovic","senderId":"@vuk97:matrix.org","id":"$6UXD5pmvrFV5_P16AgUgYhCQFhA4KsUYtWQq2f6kOwc"},
{"content":{"body":"so starving the macrotask queue is not really a concern","m.mentions":{},"msgtype":"m.text"},"ts":1724263922680,"senderName":"Vuk Stefanovic","senderId":"@vuk97:matrix.org","id":"$A0cAU1tDs7Zql_Z-eFUtazqToM_RXg_2crd1ujjqD2k"}
]