[
{"content":{"body":"Sigh, GitHub moderation is the worst. When you get spam on a PR you cannot delete the comment. If you block the person before editing the comment to remove the spam, you cannot edit the comment until you first unblock the person. And reporting the comment still takes you through a needlessly long software wizard I'm no longer interested in using.","msgtype":"m.text","org.matrix.msc1767.text":"Sigh, GitHub moderation is the worst. When you get spam on a PR you cannot delete the comment. If you block the person before editing the comment to remove the spam, you cannot edit the comment until you first unblock the person. And reporting the comment still takes you through a needlessly long software wizard I'm no longer interested in using."},"ts":1646997319692,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$NygW0MFnQL-gL5ExC6IdTG-9BOCjbI5ZU4OpQ5Ad7iA"},
{"content":{"body":"I wish there was a feature like in Discord, where when you block someone it asks you if the all comments that person posted in the last 1hr/24hrs/7d should be deleted/hidden. That'd be really useful","msgtype":"m.text","org.matrix.msc1767.text":"I wish there was a feature like in Discord, where when you block someone it asks you if the all comments that person posted in the last 1hr/24hrs/7d should be deleted/hidden. That'd be really useful"},"ts":1646997673905,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$rpfbSUSp5UDK4tbhlqBgcxAjKIva8J41BDwWntckf4s"},
{"content":{"body":"Matrix/Element does that too","msgtype":"m.text","org.matrix.msc1767.text":"Matrix/Element does that too"},"ts":1646998820623,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$lcRz0XWKolXE-b36XuLXEpsNkWiNZ9YvLBvMI5EdY80"},
{"content":{"body":"> <@domenicdenicola:matrix.org> We are reasonably confident in the \"reference implementation\" in jsdom/whatwg-url, which says that such URLs are parsed like browsers do. https://jsdom.github.io/whatwg-url/#url=aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BlY2lhbDpCbGFua3BhZ2U/ZnJvbT1lbiZ0bz1lcyZjYW1wYWlnbj1hcnRpY2xlLXJlY29tbWVuZGF0aW9uJnBhZ2U9QXBvbGxvJTk2U295dXpfVGVzdF9Qcm9qZWN0&base=YWJvdXQ6Ymxhbms=\n\nThanks, that helps. With this, I traced it down to https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/urlencoded.js#L10-L33 and https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/percent-encoding.js#L20 which indeed is doing the critically important thing of ignoring things outside the known valid range and leaving them in-tact, whereas EcmaScript's decodeURIComponent throws an error for anything unexpected after a % sign.\n\nI did actually (briefly) consider using jsdom originaly, but found that it (understandably) kind of makes maximum use of other internals. It seems it goes down to the level of code points and then brings all of TextEncoder into it all as well, and UintArray, etc. I struggled to find a minimal way to port that over.\n\nI managed to make currently-failing test cases pass by replacing the blanket decodeURIComponent call with a loop over the string and then if the two chars after % are in-range, call decodeURIComponent on just But then found that this doesn't work for multi-byte characters, e.g. decoding `%7F%C3%BF` is only accepted when done at once, not when done chunk by chunk. The URL spec doesn't say that, but then again, the URL spec doesnt say to use decodeURI of course anyway, it says to work on bytes and code points and not return to UTF-8 strings until all the way done, which I can't do within ES5 I think, or at least not without a ton of other emulation code.\n\nI did try forcing it by using String.fromCharCode(parseInt(chunk.slice(1), 16));`, but that just produced garbage.\n\nI hate myself for this, but I managed to get all tests passing both old and new cases, by using a regex. That seemed simpler than trying to eagerly buffer up multiple %- chunks or re-implemenitng lower level code point mapping for multi-bytes.\n\nThe regex looks only for valid in-range percent encoded chunks and eagerly repeats this so that we always pass decodeURI as many at once as possible.\n\n```\n\tfunction percent_decode(bytes) {\n\t\t\treturn bytes.replace(/((%[0-9A-Fa-f]{2})*)/g, function(m, p1) {\n\t\t\t\treturn decodeURIComponent(p1);\n\t\t\t});\n\t\n\t}\n```\n\nI feel dirty now, but it seems to hold up in my testing so far. Curious if anyone here knows of a better minimal way to get the multi-byte code points to work in ES5 without \"a lot of code\" and/or can poke holes in the above, preferably holes that didn't already exist in the previous version of the FT polyfill (which simply calls decodeURIComponent on the whole thing).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$l1Fz8TyjJZslo0g_zm1nLxU9dKzurb0MIVq83be8DyE?via=mozilla.org&via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">@domenicdenicola:matrix.org</a><br>We are reasonably confident in the \"reference implementation\" in jsdom/whatwg-url, which says that such URLs are parsed like browsers do. https://jsdom.github.io/whatwg-url/#url=aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BlY2lhbDpCbGFua3BhZ2U/ZnJvbT1lbiZ0bz1lcyZjYW1wYWlnbj1hcnRpY2xlLXJlY29tbWVuZGF0aW9uJnBhZ2U9QXBvbGxvJTk2U295dXpfVGVzdF9Qcm9qZWN0&amp;base=YWJvdXQ6Ymxhbms=</blockquote></mx-reply><p>Thanks, that helps. With this, I traced it down to https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/urlencoded.js#L10-L33 and https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/percent-encoding.js#L20 which indeed is doing the critically important thing of ignoring things outside the known valid range and leaving them in-tact, whereas EcmaScript's decodeURIComponent throws an error for anything unexpected after a % sign.</p>\n<p>I did actually (briefly) consider using jsdom originaly, but found that it (understandably) kind of makes maximum use of other internals. It seems it goes down to the level of code points and then brings all of TextEncoder into it all as well, and UintArray, etc. I struggled to find a minimal way to port that over.</p>\n<p>I managed to make currently-failing test cases pass by replacing the blanket decodeURIComponent call with a loop over the string and then if the two chars after % are in-range, call decodeURIComponent on just But then found that this doesn't work for multi-byte characters, e.g. decoding <code>%7F%C3%BF</code> is only accepted when done at once, not when done chunk by chunk. The URL spec doesn't say that, but then again, the URL spec doesnt say to use decodeURI of course anyway, it says to work on bytes and code points and not return to UTF-8 strings until all the way done, which I can't do within ES5 I think, or at least not without a ton of other emulation code.</p>\n<p>I did try forcing it by using String.fromCharCode(parseInt(chunk.slice(1), 16));`, but that just produced garbage.</p>\n<p>I hate myself for this, but I managed to get all tests passing both old and new cases, by using a regex. That seemed simpler than trying to eagerly buffer up multiple %- chunks or re-implemenitng lower level code point mapping for multi-bytes.</p>\n<p>The regex looks only for valid in-range percent encoded chunks and eagerly repeats this so that we always pass decodeURI as many at once as possible.</p>\n<pre><code>\tfunction percent_decode(bytes) {\n\t\t\treturn bytes.replace(/((%[0-9A-Fa-f]{2})*)/g, function(m, p1) {\n\t\t\t\treturn decodeURIComponent(p1);\n\t\t\t});\n\t\n\t}\n</code></pre>\n<p>I feel dirty now, but it seems to hold up in my testing so far. Curious if anyone here knows of a better minimal way to get the multi-byte code points to work in ES5 without &quot;a lot of code&quot; and/or can poke holes in the above, preferably holes that didn't already exist in the previous version of the FT polyfill (which simply calls decodeURIComponent on the whole thing).</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$l1Fz8TyjJZslo0g_zm1nLxU9dKzurb0MIVq83be8DyE"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@domenicdenicola:matrix.org> We are reasonably confident in the \"reference implementation\" in jsdom/whatwg-url, which says that such URLs are parsed like browsers do. https://jsdom.github.io/whatwg-url/#url=aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BlY2lhbDpCbGFua3BhZ2U/ZnJvbT1lbiZ0bz1lcyZjYW1wYWlnbj1hcnRpY2xlLXJlY29tbWVuZGF0aW9uJnBhZ2U9QXBvbGxvJTk2U295dXpfVGVzdF9Qcm9qZWN0&base=YWJvdXQ6Ymxhbms=\n\nThanks, that helps. With this, I traced it down to https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/urlencoded.js#L10-L33 and https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/percent-encoding.js#L20 which indeed is doing the critically important thing of ignoring things outside the known valid range and leaving them in-tact, whereas EcmaScript's decodeURIComponent throws an error for anything unexpected after a % sign.\n\nI did actually (briefly) consider using jsdom originaly, but found that it (understandably) kind of makes maximum use of other internals. It seems it goes down to the level of code points and then brings all of TextEncoder into it all as well, and UintArray, etc. I struggled to find a minimal way to port that over.\n\nI managed to make currently-failing test cases pass by replacing the blanket decodeURIComponent call with a loop over the string and then if the two chars after % are in-range, call decodeURIComponent on just But then found that this doesn't work for multi-byte characters, e.g. decoding `%7F%C3%BF` is only accepted when done at once, not when done chunk by chunk. The URL spec doesn't say that, but then again, the URL spec doesnt say to use decodeURI of course anyway, it says to work on bytes and code points and not return to UTF-8 strings until all the way done, which I can't do within ES5 I think, or at least not without a ton of other emulation code.\n\nI did try forcing it by using String.fromCharCode(parseInt(chunk.slice(1), 16));`, but that just produced garbage.\n\nI hate myself for this, but I managed to get all tests passing both old and new cases, by using a regex. That seemed simpler than trying to eagerly buffer up multiple %- chunks or re-implemenitng lower level code point mapping for multi-bytes.\n\nThe regex looks only for valid in-range percent encoded chunks and eagerly repeats this so that we always pass decodeURI as many at once as possible.\n\n```\n\tfunction percent_decode(bytes) {\n\t\t\treturn bytes.replace(/((%[0-9A-Fa-f]{2})*)/g, function(m, p1) {\n\t\t\t\treturn decodeURIComponent(p1);\n\t\t\t});\n\t\n\t}\n```\n\nI feel dirty now, but it seems to hold up in my testing so far. Curious if anyone here knows of a better minimal way to get the multi-byte code points to work in ES5 without \"a lot of code\" and/or can poke holes in the above, preferably holes that didn't already exist in the previous version of the FT polyfill (which simply calls decodeURIComponent on the whole thing).","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$l1Fz8TyjJZslo0g_zm1nLxU9dKzurb0MIVq83be8DyE?via=mozilla.org&via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">@domenicdenicola:matrix.org</a><br>We are reasonably confident in the \"reference implementation\" in jsdom/whatwg-url, which says that such URLs are parsed like browsers do. https://jsdom.github.io/whatwg-url/#url=aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BlY2lhbDpCbGFua3BhZ2U/ZnJvbT1lbiZ0bz1lcyZjYW1wYWlnbj1hcnRpY2xlLXJlY29tbWVuZGF0aW9uJnBhZ2U9QXBvbGxvJTk2U295dXpfVGVzdF9Qcm9qZWN0&amp;base=YWJvdXQ6Ymxhbms=</blockquote></mx-reply><p>Thanks, that helps. With this, I traced it down to https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/urlencoded.js#L10-L33 and https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/percent-encoding.js#L20 which indeed is doing the critically important thing of ignoring things outside the known valid range and leaving them in-tact, whereas EcmaScript's decodeURIComponent throws an error for anything unexpected after a % sign.</p>\n<p>I did actually (briefly) consider using jsdom originaly, but found that it (understandably) kind of makes maximum use of other internals. It seems it goes down to the level of code points and then brings all of TextEncoder into it all as well, and UintArray, etc. I struggled to find a minimal way to port that over.</p>\n<p>I managed to make currently-failing test cases pass by replacing the blanket decodeURIComponent call with a loop over the string and then if the two chars after % are in-range, call decodeURIComponent on just But then found that this doesn't work for multi-byte characters, e.g. decoding <code>%7F%C3%BF</code> is only accepted when done at once, not when done chunk by chunk. The URL spec doesn't say that, but then again, the URL spec doesnt say to use decodeURI of course anyway, it says to work on bytes and code points and not return to UTF-8 strings until all the way done, which I can't do within ES5 I think, or at least not without a ton of other emulation code.</p>\n<p>I did try forcing it by using String.fromCharCode(parseInt(chunk.slice(1), 16));`, but that just produced garbage.</p>\n<p>I hate myself for this, but I managed to get all tests passing both old and new cases, by using a regex. That seemed simpler than trying to eagerly buffer up multiple %- chunks or re-implemenitng lower level code point mapping for multi-bytes.</p>\n<p>The regex looks only for valid in-range percent encoded chunks and eagerly repeats this so that we always pass decodeURI as many at once as possible.</p>\n<pre><code>\tfunction percent_decode(bytes) {\n\t\t\treturn bytes.replace(/((%[0-9A-Fa-f]{2})*)/g, function(m, p1) {\n\t\t\t\treturn decodeURIComponent(p1);\n\t\t\t});\n\t\n\t}\n</code></pre>\n<p>I feel dirty now, but it seems to hold up in my testing so far. Curious if anyone here knows of a better minimal way to get the multi-byte code points to work in ES5 without &quot;a lot of code&quot; and/or can poke holes in the above, preferably holes that didn't already exist in the previous version of the FT polyfill (which simply calls decodeURIComponent on the whole thing).</p>\n","mimetype":"text/html"}]},"ts":1647008370681,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$UrWKBh_8_pqfZL0LBz4UwYOErUIOcsSf6Y1h0cvvjnc"},
{"content":{"body":"Ms2ger 游눌游눌: why is it synthetic settings objects/realms and not shadow settings objects/realms?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@ms2ger:igalia.com\">Ms2ger 游눌游눌</a>: why is it synthetic settings objects/realms and not shadow settings objects/realms?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Ms2ger 游눌游눌: why is it synthetic settings objects/realms and not shadow settings objects/realms?","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@ms2ger:igalia.com\">Ms2ger 游눌游눌</a>: why is it synthetic settings objects/realms and not shadow settings objects/realms?","mimetype":"text/html"}]},"ts":1647017851597,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$Ldgsk6gNOUT7wes6v90-U0fvQY6WV6vEy939zYk8vSc"}
]