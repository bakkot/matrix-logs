[
{"content":{"body":"Sigh, GitHub moderation is the worst. When you get spam on a PR you cannot delete the comment. If you block the person before editing the comment to remove the spam, you cannot edit the comment until you first unblock the person. And reporting the comment still takes you through a needlessly long software wizard I'm no longer interested in using.","msgtype":"m.text","org.matrix.msc1767.text":"Sigh, GitHub moderation is the worst. When you get spam on a PR you cannot delete the comment. If you block the person before editing the comment to remove the spam, you cannot edit the comment until you first unblock the person. And reporting the comment still takes you through a needlessly long software wizard I'm no longer interested in using."},"ts":1646997319692,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$NygW0MFnQL-gL5ExC6IdTG-9BOCjbI5ZU4OpQ5Ad7iA"},
{"content":{"body":"I wish there was a feature like in Discord, where when you block someone it asks you if the all comments that person posted in the last 1hr/24hrs/7d should be deleted/hidden. That'd be really useful","msgtype":"m.text","org.matrix.msc1767.text":"I wish there was a feature like in Discord, where when you block someone it asks you if the all comments that person posted in the last 1hr/24hrs/7d should be deleted/hidden. That'd be really useful"},"ts":1646997673905,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$rpfbSUSp5UDK4tbhlqBgcxAjKIva8J41BDwWntckf4s"},
{"content":{"body":"Matrix/Element does that too","msgtype":"m.text","org.matrix.msc1767.text":"Matrix/Element does that too"},"ts":1646998820623,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$lcRz0XWKolXE-b36XuLXEpsNkWiNZ9YvLBvMI5EdY80"},
{"content":{"body":"> <@domenicdenicola:matrix.org> We are reasonably confident in the \"reference implementation\" in jsdom/whatwg-url, which says that such URLs are parsed like browsers do. https://jsdom.github.io/whatwg-url/#url=aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BlY2lhbDpCbGFua3BhZ2U/ZnJvbT1lbiZ0bz1lcyZjYW1wYWlnbj1hcnRpY2xlLXJlY29tbWVuZGF0aW9uJnBhZ2U9QXBvbGxvJTk2U295dXpfVGVzdF9Qcm9qZWN0&base=YWJvdXQ6Ymxhbms=\n\nThanks, that helps. With this, I traced it down to https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/urlencoded.js#L10-L33 and https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/percent-encoding.js#L20 which indeed is doing the critically important thing of ignoring things outside the known valid range and leaving them in-tact, whereas EcmaScript's decodeURIComponent throws an error for anything unexpected after a % sign.\n\nI did actually (briefly) consider using jsdom originaly, but found that it (understandably) kind of makes maximum use of other internals. It seems it goes down to the level of code points and then brings all of TextEncoder into it all as well, and UintArray, etc. I struggled to find a minimal way to port that over.\n\nI managed to make currently-failing test cases pass by replacing the blanket decodeURIComponent call with a loop over the string and then if the two chars after % are in-range, call decodeURIComponent on just But then found that this doesn't work for multi-byte characters, e.g. decoding `%7F%C3%BF` is only accepted when done at once, not when done chunk by chunk. The URL spec doesn't say that, but then again, the URL spec doesnt say to use decodeURI of course anyway, it says to work on bytes and code points and not return to UTF-8 strings until all the way done, which I can't do within ES5 I think, or at least not without a ton of other emulation code.\n\nI did try forcing it by using String.fromCharCode(parseInt(chunk.slice(1), 16));`, but that just produced garbage.\n\nI hate myself for this, but I managed to get all tests passing both old and new cases, by using a regex. That seemed simpler than trying to eagerly buffer up multiple %- chunks or re-implemenitng lower level code point mapping for multi-bytes.\n\nThe regex looks only for valid in-range percent encoded chunks and eagerly repeats this so that we always pass decodeURI as many at once as possible.\n\n```\n\tfunction percent_decode(bytes) {\n\t\t\treturn bytes.replace(/((%[0-9A-Fa-f]{2})*)/g, function(m, p1) {\n\t\t\t\treturn decodeURIComponent(p1);\n\t\t\t});\n\t\n\t}\n```\n\nI feel dirty now, but it seems to hold up in my testing so far. Curious if anyone here knows of a better minimal way to get the multi-byte code points to work in ES5 without \"a lot of code\" and/or can poke holes in the above, preferably holes that didn't already exist in the previous version of the FT polyfill (which simply calls decodeURIComponent on the whole thing).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$l1Fz8TyjJZslo0g_zm1nLxU9dKzurb0MIVq83be8DyE?via=mozilla.org&via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">@domenicdenicola:matrix.org</a><br>We are reasonably confident in the \"reference implementation\" in jsdom/whatwg-url, which says that such URLs are parsed like browsers do. https://jsdom.github.io/whatwg-url/#url=aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BlY2lhbDpCbGFua3BhZ2U/ZnJvbT1lbiZ0bz1lcyZjYW1wYWlnbj1hcnRpY2xlLXJlY29tbWVuZGF0aW9uJnBhZ2U9QXBvbGxvJTk2U295dXpfVGVzdF9Qcm9qZWN0&amp;base=YWJvdXQ6Ymxhbms=</blockquote></mx-reply><p>Thanks, that helps. With this, I traced it down to https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/urlencoded.js#L10-L33 and https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/percent-encoding.js#L20 which indeed is doing the critically important thing of ignoring things outside the known valid range and leaving them in-tact, whereas EcmaScript's decodeURIComponent throws an error for anything unexpected after a % sign.</p>\n<p>I did actually (briefly) consider using jsdom originaly, but found that it (understandably) kind of makes maximum use of other internals. It seems it goes down to the level of code points and then brings all of TextEncoder into it all as well, and UintArray, etc. I struggled to find a minimal way to port that over.</p>\n<p>I managed to make currently-failing test cases pass by replacing the blanket decodeURIComponent call with a loop over the string and then if the two chars after % are in-range, call decodeURIComponent on just But then found that this doesn't work for multi-byte characters, e.g. decoding <code>%7F%C3%BF</code> is only accepted when done at once, not when done chunk by chunk. The URL spec doesn't say that, but then again, the URL spec doesnt say to use decodeURI of course anyway, it says to work on bytes and code points and not return to UTF-8 strings until all the way done, which I can't do within ES5 I think, or at least not without a ton of other emulation code.</p>\n<p>I did try forcing it by using String.fromCharCode(parseInt(chunk.slice(1), 16));`, but that just produced garbage.</p>\n<p>I hate myself for this, but I managed to get all tests passing both old and new cases, by using a regex. That seemed simpler than trying to eagerly buffer up multiple %- chunks or re-implemenitng lower level code point mapping for multi-bytes.</p>\n<p>The regex looks only for valid in-range percent encoded chunks and eagerly repeats this so that we always pass decodeURI as many at once as possible.</p>\n<pre><code>\tfunction percent_decode(bytes) {\n\t\t\treturn bytes.replace(/((%[0-9A-Fa-f]{2})*)/g, function(m, p1) {\n\t\t\t\treturn decodeURIComponent(p1);\n\t\t\t});\n\t\n\t}\n</code></pre>\n<p>I feel dirty now, but it seems to hold up in my testing so far. Curious if anyone here knows of a better minimal way to get the multi-byte code points to work in ES5 without &quot;a lot of code&quot; and/or can poke holes in the above, preferably holes that didn't already exist in the previous version of the FT polyfill (which simply calls decodeURIComponent on the whole thing).</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$l1Fz8TyjJZslo0g_zm1nLxU9dKzurb0MIVq83be8DyE"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@domenicdenicola:matrix.org> We are reasonably confident in the \"reference implementation\" in jsdom/whatwg-url, which says that such URLs are parsed like browsers do. https://jsdom.github.io/whatwg-url/#url=aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BlY2lhbDpCbGFua3BhZ2U/ZnJvbT1lbiZ0bz1lcyZjYW1wYWlnbj1hcnRpY2xlLXJlY29tbWVuZGF0aW9uJnBhZ2U9QXBvbGxvJTk2U295dXpfVGVzdF9Qcm9qZWN0&base=YWJvdXQ6Ymxhbms=\n\nThanks, that helps. With this, I traced it down to https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/urlencoded.js#L10-L33 and https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/percent-encoding.js#L20 which indeed is doing the critically important thing of ignoring things outside the known valid range and leaving them in-tact, whereas EcmaScript's decodeURIComponent throws an error for anything unexpected after a % sign.\n\nI did actually (briefly) consider using jsdom originaly, but found that it (understandably) kind of makes maximum use of other internals. It seems it goes down to the level of code points and then brings all of TextEncoder into it all as well, and UintArray, etc. I struggled to find a minimal way to port that over.\n\nI managed to make currently-failing test cases pass by replacing the blanket decodeURIComponent call with a loop over the string and then if the two chars after % are in-range, call decodeURIComponent on just But then found that this doesn't work for multi-byte characters, e.g. decoding `%7F%C3%BF` is only accepted when done at once, not when done chunk by chunk. The URL spec doesn't say that, but then again, the URL spec doesnt say to use decodeURI of course anyway, it says to work on bytes and code points and not return to UTF-8 strings until all the way done, which I can't do within ES5 I think, or at least not without a ton of other emulation code.\n\nI did try forcing it by using String.fromCharCode(parseInt(chunk.slice(1), 16));`, but that just produced garbage.\n\nI hate myself for this, but I managed to get all tests passing both old and new cases, by using a regex. That seemed simpler than trying to eagerly buffer up multiple %- chunks or re-implemenitng lower level code point mapping for multi-bytes.\n\nThe regex looks only for valid in-range percent encoded chunks and eagerly repeats this so that we always pass decodeURI as many at once as possible.\n\n```\n\tfunction percent_decode(bytes) {\n\t\t\treturn bytes.replace(/((%[0-9A-Fa-f]{2})*)/g, function(m, p1) {\n\t\t\t\treturn decodeURIComponent(p1);\n\t\t\t});\n\t\n\t}\n```\n\nI feel dirty now, but it seems to hold up in my testing so far. Curious if anyone here knows of a better minimal way to get the multi-byte code points to work in ES5 without \"a lot of code\" and/or can poke holes in the above, preferably holes that didn't already exist in the previous version of the FT polyfill (which simply calls decodeURIComponent on the whole thing).","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$l1Fz8TyjJZslo0g_zm1nLxU9dKzurb0MIVq83be8DyE?via=mozilla.org&via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">@domenicdenicola:matrix.org</a><br>We are reasonably confident in the \"reference implementation\" in jsdom/whatwg-url, which says that such URLs are parsed like browsers do. https://jsdom.github.io/whatwg-url/#url=aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BlY2lhbDpCbGFua3BhZ2U/ZnJvbT1lbiZ0bz1lcyZjYW1wYWlnbj1hcnRpY2xlLXJlY29tbWVuZGF0aW9uJnBhZ2U9QXBvbGxvJTk2U295dXpfVGVzdF9Qcm9qZWN0&amp;base=YWJvdXQ6Ymxhbms=</blockquote></mx-reply><p>Thanks, that helps. With this, I traced it down to https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/urlencoded.js#L10-L33 and https://github.com/jsdom/whatwg-url/blob/a4cb13309246ca9ecf03404fdbf0d23ecaf114dd/lib/percent-encoding.js#L20 which indeed is doing the critically important thing of ignoring things outside the known valid range and leaving them in-tact, whereas EcmaScript's decodeURIComponent throws an error for anything unexpected after a % sign.</p>\n<p>I did actually (briefly) consider using jsdom originaly, but found that it (understandably) kind of makes maximum use of other internals. It seems it goes down to the level of code points and then brings all of TextEncoder into it all as well, and UintArray, etc. I struggled to find a minimal way to port that over.</p>\n<p>I managed to make currently-failing test cases pass by replacing the blanket decodeURIComponent call with a loop over the string and then if the two chars after % are in-range, call decodeURIComponent on just But then found that this doesn't work for multi-byte characters, e.g. decoding <code>%7F%C3%BF</code> is only accepted when done at once, not when done chunk by chunk. The URL spec doesn't say that, but then again, the URL spec doesnt say to use decodeURI of course anyway, it says to work on bytes and code points and not return to UTF-8 strings until all the way done, which I can't do within ES5 I think, or at least not without a ton of other emulation code.</p>\n<p>I did try forcing it by using String.fromCharCode(parseInt(chunk.slice(1), 16));`, but that just produced garbage.</p>\n<p>I hate myself for this, but I managed to get all tests passing both old and new cases, by using a regex. That seemed simpler than trying to eagerly buffer up multiple %- chunks or re-implemenitng lower level code point mapping for multi-bytes.</p>\n<p>The regex looks only for valid in-range percent encoded chunks and eagerly repeats this so that we always pass decodeURI as many at once as possible.</p>\n<pre><code>\tfunction percent_decode(bytes) {\n\t\t\treturn bytes.replace(/((%[0-9A-Fa-f]{2})*)/g, function(m, p1) {\n\t\t\t\treturn decodeURIComponent(p1);\n\t\t\t});\n\t\n\t}\n</code></pre>\n<p>I feel dirty now, but it seems to hold up in my testing so far. Curious if anyone here knows of a better minimal way to get the multi-byte code points to work in ES5 without &quot;a lot of code&quot; and/or can poke holes in the above, preferably holes that didn't already exist in the previous version of the FT polyfill (which simply calls decodeURIComponent on the whole thing).</p>\n","mimetype":"text/html"}]},"ts":1647008370681,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$UrWKBh_8_pqfZL0LBz4UwYOErUIOcsSf6Y1h0cvvjnc"},
{"content":{"body":"Ms2ger 游눌游눌: why is it synthetic settings objects/realms and not shadow settings objects/realms?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@ms2ger:igalia.com\">Ms2ger 游눌游눌</a>: why is it synthetic settings objects/realms and not shadow settings objects/realms?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Ms2ger 游눌游눌: why is it synthetic settings objects/realms and not shadow settings objects/realms?","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@ms2ger:igalia.com\">Ms2ger 游눌游눌</a>: why is it synthetic settings objects/realms and not shadow settings objects/realms?","mimetype":"text/html"}]},"ts":1647017851597,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$Ldgsk6gNOUT7wes6v90-U0fvQY6WV6vEy939zYk8vSc"},
{"content":{"body":"Ms2ger 游눌游눌: I'd also still like some kind of answer to the question I raised in my overall review comment","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@ms2ger:igalia.com\">Ms2ger 游눌游눌</a>: I'd also still like some kind of answer to the question I raised in my overall review comment","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Ms2ger 游눌游눌: I'd also still like some kind of answer to the question I raised in my overall review comment","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@ms2ger:igalia.com\">Ms2ger 游눌游눌</a>: I'd also still like some kind of answer to the question I raised in my overall review comment","mimetype":"text/html"}]},"ts":1647018088364,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$EyVb4UOyM0kvJsVsUxF-0q1__99YdjFGyAMCamVsg1A"},
{"content":{"body":"I'll leave these questions on the PR.","msgtype":"m.text","org.matrix.msc1767.text":"I'll leave these questions on the PR."},"ts":1647018196957,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$7yA5XVJrcg2zAaSiaoEEopA_WQJjMWLJIUo4U8a1zxc"},
{"content":{"body":"Timo Tijhof: that was a fun read. I'm bad at reading regexp, maybe add a comment, but that looks reasonable. It does look like it will fall over if folks are not using UTF-8 bytes, which is allowed. But perhaps that's acceptable in your case. Might also want to denote that.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: that was a fun read. I'm bad at reading regexp, maybe add a comment, but that looks reasonable. It does look like it will fall over if folks are not using UTF-8 bytes, which is allowed. But perhaps that's acceptable in your case. Might also want to denote that.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Timo Tijhof: that was a fun read. I'm bad at reading regexp, maybe add a comment, but that looks reasonable. It does look like it will fall over if folks are not using UTF-8 bytes, which is allowed. But perhaps that's acceptable in your case. Might also want to denote that.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: that was a fun read. I'm bad at reading regexp, maybe add a comment, but that looks reasonable. It does look like it will fall over if folks are not using UTF-8 bytes, which is allowed. But perhaps that's acceptable in your case. Might also want to denote that.","mimetype":"text/html"}]},"ts":1647019858143,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$wH4S1nf0IWM-AT6K3SMAH5fVrrMetsyhlxOCW_xrjRg"},
{"content":{"body":"Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.\n\nWikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D\n\nFor example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project\n\nWhile we don't have any need to read the \"correct\" value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having `new mw.Uri` (our in-house library) or `new URL` (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read `searchParams.get('title')` correctly, so long as we can still do other things with it.\n\nOur downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244\n\nMy PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.\n\nI'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any \"valid\" URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.","format":"org.matrix.custom.html","formatted_body":"<p>Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.</p>\n<p>Wikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D</p>\n<p>For example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project</p>\n<p>While we don't have any need to read the &quot;correct&quot; value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having <code>new mw.Uri</code> (our in-house library) or <code>new URL</code> (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read <code>searchParams.get('title')</code> correctly, so long as we can still do other things with it.</p>\n<p>Our downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244</p>\n<p>My PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.</p>\n<p>I'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any &quot;valid&quot; URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.\n\nWikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D\n\nFor example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project\n\nWhile we don't have any need to read the \"correct\" value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having `new mw.Uri` (our in-house library) or `new URL` (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read `searchParams.get('title')` correctly, so long as we can still do other things with it.\n\nOur downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244\n\nMy PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.\n\nI'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any \"valid\" URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.","mimetype":"text/plain"},{"body":"<p>Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.</p>\n<p>Wikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D</p>\n<p>For example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project</p>\n<p>While we don't have any need to read the &quot;correct&quot; value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having <code>new mw.Uri</code> (our in-house library) or <code>new URL</code> (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read <code>searchParams.get('title')</code> correctly, so long as we can still do other things with it.</p>\n<p>Our downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244</p>\n<p>My PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.</p>\n<p>I'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any &quot;valid&quot; URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.</p>\n","mimetype":"text/html"}],"m.relates_to":{"m.in_reply_to":{"event_id":"$wH4S1nf0IWM-AT6K3SMAH5fVrrMetsyhlxOCW_xrjRg"}}},"ts":1647021105268,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$SldQgglMviOBlJhLBnsCe3FBGRY57nwVO_PdDBM-Giw"},
{"content":{"body":"> <@annevk:mozilla.org> Timo Tijhof: that was a fun read. I'm bad at reading regexp, maybe add a comment, but that looks reasonable. It does look like it will fall over if folks are not using UTF-8 bytes, which is allowed. But perhaps that's acceptable in your case. Might also want to denote that.\n\n * Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.\n\nWikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D\n\nFor example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project\n\nWhile we don't have any need to read the \"correct\" value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having `new mw.Uri` (our in-house library) or `new URL` (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read `searchParams.get('title')` correctly, so long as we can still do other things with it.\n\nOur downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244\n\nMy PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.\n\nI'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any \"valid\" URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$wH4S1nf0IWM-AT6K3SMAH5fVrrMetsyhlxOCW_xrjRg?via=mozilla.org&amp;via=matrix.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:mozilla.org\">@annevk:mozilla.org</a><br><a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: that was a fun read. I'm bad at reading regexp, maybe add a comment, but that looks reasonable. It does look like it will fall over if folks are not using UTF-8 bytes, which is allowed. But perhaps that's acceptable in your case. Might also want to denote that.</blockquote></mx-reply> * <p>Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.</p>\n<p>Wikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D</p>\n<p>For example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project</p>\n<p>While we don't have any need to read the &quot;correct&quot; value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having <code>new mw.Uri</code> (our in-house library) or <code>new URL</code> (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read <code>searchParams.get('title')</code> correctly, so long as we can still do other things with it.</p>\n<p>Our downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244</p>\n<p>My PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.</p>\n<p>I'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any &quot;valid&quot; URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.</p>\n","m.new_content":{"body":"Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.\n\nWikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D\n\nFor example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project\n\nWhile we don't have any need to read the \"correct\" value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having `new mw.Uri` (our in-house library) or `new URL` (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read `searchParams.get('title')` correctly, so long as we can still do other things with it.\n\nOur downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244\n\nMy PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.\n\nI'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any \"valid\" URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.","format":"org.matrix.custom.html","formatted_body":"<p>Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.</p>\n<p>Wikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D</p>\n<p>For example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project</p>\n<p>While we don't have any need to read the &quot;correct&quot; value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having <code>new mw.Uri</code> (our in-house library) or <code>new URL</code> (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read <code>searchParams.get('title')</code> correctly, so long as we can still do other things with it.</p>\n<p>Our downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244</p>\n<p>My PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.</p>\n<p>I'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any &quot;valid&quot; URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.\n\nWikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D\n\nFor example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project\n\nWhile we don't have any need to read the \"correct\" value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having `new mw.Uri` (our in-house library) or `new URL` (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read `searchParams.get('title')` correctly, so long as we can still do other things with it.\n\nOur downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244\n\nMy PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.\n\nI'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any \"valid\" URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.","mimetype":"text/plain"},{"body":"<p>Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.</p>\n<p>Wikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D</p>\n<p>For example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project</p>\n<p>While we don't have any need to read the &quot;correct&quot; value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having <code>new mw.Uri</code> (our in-house library) or <code>new URL</code> (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read <code>searchParams.get('title')</code> correctly, so long as we can still do other things with it.</p>\n<p>Our downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244</p>\n<p>My PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.</p>\n<p>I'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any &quot;valid&quot; URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$SldQgglMviOBlJhLBnsCe3FBGRY57nwVO_PdDBM-Giw","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@annevk:mozilla.org> Timo Tijhof: that was a fun read. I'm bad at reading regexp, maybe add a comment, but that looks reasonable. It does look like it will fall over if folks are not using UTF-8 bytes, which is allowed. But perhaps that's acceptable in your case. Might also want to denote that.\n\n * Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.\n\nWikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D\n\nFor example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project\n\nWhile we don't have any need to read the \"correct\" value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having `new mw.Uri` (our in-house library) or `new URL` (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read `searchParams.get('title')` correctly, so long as we can still do other things with it.\n\nOur downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244\n\nMy PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.\n\nI'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any \"valid\" URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$wH4S1nf0IWM-AT6K3SMAH5fVrrMetsyhlxOCW_xrjRg?via=mozilla.org&amp;via=matrix.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:mozilla.org\">@annevk:mozilla.org</a><br><a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: that was a fun read. I'm bad at reading regexp, maybe add a comment, but that looks reasonable. It does look like it will fall over if folks are not using UTF-8 bytes, which is allowed. But perhaps that's acceptable in your case. Might also want to denote that.</blockquote></mx-reply> * <p>Thanks, that gives me a bit more confidence. The use case that led me to discover this bug in the FT polyfill is actually very much related to bytes that are not UTF-8 bytes.</p>\n<p>Wikipedia uses UTF-8 for canonical URLs everywhere now and has for almost two decades now. But some of the earliest language editions (Specifically en.wikipedia, pl.wikipedia, and zh.wikipedia) used to use a different encoding, which our backend web server (MediaWiki PHP) continues to support to ensure URLs don't break. If the decoded string isn't valid UTF-8, it will on those wikis fallback to a legacy encoding. For en.wikipedia that is windows-1252, for pl.wikipedia iso-8859-2 and for zh.wikipeida/zh-hans windows-936 and zh/zh-hant windows-950.  As per https://codesearch.wmcloud.org/core/?q=fallback8bitEncoding%20%3D</p>\n<p>For example, this URL is still supported: https://en.wikipedia.org/w/index.php?title=Apollo%96Soyuz_Test_Project</p>\n<p>While we don't have any need to read the &quot;correct&quot; value of the title parameter in JavaScript, we do have many other query params we sometimes read client-side, and so having <code>new mw.Uri</code> (our in-house library) or <code>new URL</code> (polyfiled) throw unconditionally on those pages is a problem. It's fine if we can't read <code>searchParams.get('title')</code> correctly, so long as we can still do other things with it.</p>\n<p>Our downstream task (which was meant to be closed by using the URL API) - https://phabricator.wikimedia.org/T106244</p>\n<p>My PR (with docs now): https://github.com/Financial-Times/polyfill-library/pull/1173.</p>\n<p>I'm still looking into improving the handling of incomplete multi-byte. We are unlikely to encounter those for any &quot;valid&quot; URLs, not even legacy ones, but it still seems better not to crash on those but do a replacement indeed like the standard does.</p>\n","mimetype":"text/html"}]},"ts":1647021236444,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$CVLYPmNkIigo_FUuM3k5pwf3WwjZ7F9EDHQm5BfGHbA"},
{"content":{"body":"Timo Tijhof: so shouldn't you handle failure in that case and just return the input?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: so shouldn't you handle failure in that case and just return the input?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Timo Tijhof: so shouldn't you handle failure in that case and just return the input?","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: so shouldn't you handle failure in that case and just return the input?","mimetype":"text/html"}]},"ts":1647021245364,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$WuBRzohelSyMPf9zVp-eEgRsyRXb4K4fJAuqXvCXAxc"},
{"content":{"body":"Timo Tijhof: and maybe rename to utf8_percent_decode","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: and maybe rename to utf8_percent_decode","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Timo Tijhof: and maybe rename to utf8_percent_decode","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: and maybe rename to utf8_percent_decode","mimetype":"text/html"}]},"ts":1647021277616,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$dFeFwNdU9c8w1dcR4wDggGbYKhksEd2WCpWJH9Qaf_4"},
{"content":{"body":"> <@annevk:mozilla.org> Timo Tijhof: and maybe rename to utf8_percent_decode\n\nAck, yeah, I'm aware calling these bytes is wrong.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$dFeFwNdU9c8w1dcR4wDggGbYKhksEd2WCpWJH9Qaf_4?via=mozilla.org&via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:mozilla.org\">@annevk:mozilla.org</a><br><a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: and maybe rename to utf8_percent_decode</blockquote></mx-reply>Ack, yeah, I'm aware calling these bytes is wrong.","m.relates_to":{"m.in_reply_to":{"event_id":"$dFeFwNdU9c8w1dcR4wDggGbYKhksEd2WCpWJH9Qaf_4"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@annevk:mozilla.org> Timo Tijhof: and maybe rename to utf8_percent_decode\n\nAck, yeah, I'm aware calling these bytes is wrong.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$dFeFwNdU9c8w1dcR4wDggGbYKhksEd2WCpWJH9Qaf_4?via=mozilla.org&via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:mozilla.org\">@annevk:mozilla.org</a><br><a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: and maybe rename to utf8_percent_decode</blockquote></mx-reply>Ack, yeah, I'm aware calling these bytes is wrong.","mimetype":"text/html"}]},"ts":1647021299011,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$cvLjIlonZCvbgW7yrph1jXe77DyDKb5BSmqJ5M1xxg0"},
{"content":{"body":"Timo Tijhof: e.g., consider %FF which can never decode as UTF-8","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: e.g., consider %FF which can never decode as UTF-8","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Timo Tijhof: e.g., consider %FF which can never decode as UTF-8","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: e.g., consider %FF which can never decode as UTF-8","mimetype":"text/html"}]},"ts":1647021305451,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$2hrxSXUEi8QMFtm_MI_9NVw0QHDkXYlfz5iBX0nNjes"},
{"content":{"body":"> <@annevk:mozilla.org> Timo Tijhof: and maybe rename to utf8_percent_decode\n\n * Ack, yeah, I'm aware calling these bytes is wrong (though pre-existing name in the code).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$dFeFwNdU9c8w1dcR4wDggGbYKhksEd2WCpWJH9Qaf_4?via=mozilla.org&amp;via=matrix.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:mozilla.org\">@annevk:mozilla.org</a><br><a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: and maybe rename to utf8_percent_decode</blockquote></mx-reply> * Ack, yeah, I'm aware calling these bytes is wrong (though pre-existing name in the code).","m.new_content":{"body":"Ack, yeah, I'm aware calling these bytes is wrong (though pre-existing name in the code).","format":"org.matrix.custom.html","formatted_body":"Ack, yeah, I'm aware calling these bytes is wrong (though pre-existing name in the code).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Ack, yeah, I'm aware calling these bytes is wrong (though pre-existing name in the code).","mimetype":"text/plain"},{"body":"Ack, yeah, I'm aware calling these bytes is wrong (though pre-existing name in the code).","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$cvLjIlonZCvbgW7yrph1jXe77DyDKb5BSmqJ5M1xxg0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@annevk:mozilla.org> Timo Tijhof: and maybe rename to utf8_percent_decode\n\n * Ack, yeah, I'm aware calling these bytes is wrong (though pre-existing name in the code).","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$dFeFwNdU9c8w1dcR4wDggGbYKhksEd2WCpWJH9Qaf_4?via=mozilla.org&amp;via=matrix.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:mozilla.org\">@annevk:mozilla.org</a><br><a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: and maybe rename to utf8_percent_decode</blockquote></mx-reply> * Ack, yeah, I'm aware calling these bytes is wrong (though pre-existing name in the code).","mimetype":"text/html"}]},"ts":1647021338170,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$O1tsmJwz6DXVUUmcU3yFENBJuqGQrDrmG-7719qsuZk"},
{"content":{"body":"> <@annevk:mozilla.org> Timo Tijhof: and maybe rename to utf8_percent_decode\n\nHm.. so the issue there is that if you have %FF%20, my eager regex will feed them all (as it should for multibyte) and then fail in its entirely still. Returning that as literal or as replacement character would both be different from the spec. But I don't mind a bit of difference with the spec. This is meant to be a relatively loose polyfill I think, and not a full virtual machine :)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$dFeFwNdU9c8w1dcR4wDggGbYKhksEd2WCpWJH9Qaf_4?via=mozilla.org&via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:mozilla.org\">@annevk:mozilla.org</a><br><a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: and maybe rename to utf8_percent_decode</blockquote></mx-reply>Hm.. so the issue there is that if you have %FF%20, my eager regex will feed them all (as it should for multibyte) and then fail in its entirely still. Returning that as literal or as replacement character would both be different from the spec. But I don't mind a bit of difference with the spec. This is meant to be a relatively loose polyfill I think, and not a full virtual machine :)","m.relates_to":{"m.in_reply_to":{"event_id":"$dFeFwNdU9c8w1dcR4wDggGbYKhksEd2WCpWJH9Qaf_4"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@annevk:mozilla.org> Timo Tijhof: and maybe rename to utf8_percent_decode\n\nHm.. so the issue there is that if you have %FF%20, my eager regex will feed them all (as it should for multibyte) and then fail in its entirely still. Returning that as literal or as replacement character would both be different from the spec. But I don't mind a bit of difference with the spec. This is meant to be a relatively loose polyfill I think, and not a full virtual machine :)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$dFeFwNdU9c8w1dcR4wDggGbYKhksEd2WCpWJH9Qaf_4?via=mozilla.org&via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@annevk:mozilla.org\">@annevk:mozilla.org</a><br><a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: and maybe rename to utf8_percent_decode</blockquote></mx-reply>Hm.. so the issue there is that if you have %FF%20, my eager regex will feed them all (as it should for multibyte) and then fail in its entirely still. Returning that as literal or as replacement character would both be different from the spec. But I don't mind a bit of difference with the spec. This is meant to be a relatively loose polyfill I think, and not a full virtual machine :)","mimetype":"text/html"}]},"ts":1647021436540,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$FCHIACX9o9rGJqph1ptZ11DxQxl6P9ypMTPOjIyzXMo"},
{"content":{"body":"Yeah I mainly meant that you don't seem to handle failure at all at the moment. Other than rethrowing. You're right that sequences such as that make it trickier.","msgtype":"m.text","org.matrix.msc1767.text":"Yeah I mainly meant that you don't seem to handle failure at all at the moment. Other than rethrowing. You're right that sequences such as that make it trickier."},"ts":1647021579543,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$CDMhOIv7WkVHJgX0yTRIOvk1DOnujbkbLaqmi1XRDN0"},
{"content":{"body":"Ack yeah, I'll add a localised try-catch if nothing else. Good point. ","msgtype":"m.text","org.matrix.msc1767.text":"Ack yeah, I'll add a localised try-catch if nothing else. Good point. "},"ts":1647021600134,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$bw5jIE07qkTpkTMLRK7F-YmQ8y_1-oXEpXFcTBrt7PE"}
]