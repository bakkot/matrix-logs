[
{"content":{"body":"Hello, does anyone know about the \"willful violation of RFC 5322\" note in section 4.10.5.1.5 Email state of the whatwg HTML spec? The comment raises some concern for me, since RFC-5322 is not the appropriate standard to find the syntax of email addresses as used on the public Internet today to route email. The correct standard is RFC-5321, which defines the SMTP protocol and includes a grammar for Mailbox which is what most people think of as an email address. This is what people sometimes call the \"envelope\" address.\n\nThe RFC-5322 document specifies the format of the email message content, not the protocol used to transport mail.\n\nSo, yeah: you should not follow RFC-5322, but you should follow RFC-5321.\n","m.mentions":{},"msgtype":"m.text"},"ts":1710041317598,"senderName":"dean.highpower","senderId":"@dean.highpower:matrix.org","id":"$0Q66H6h7YzkyPOkIMUN04wjxqMBfcjB_W5JUgfJYa0k"},
{"content":{"body":"dean.highpower: there's a long discussion in https://github.com/whatwg/html/issues/4562 without much progress, though someone from the i18n WG might make another attempt this year.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@dean.highpower:matrix.org\">dean.highpower</a>: there's a long discussion in https://github.com/whatwg/html/issues/4562 without much progress, though someone from the i18n WG might make another attempt this year.","m.mentions":{"user_ids":["@dean.highpower:matrix.org"]},"msgtype":"m.text"},"ts":1710056455276,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$837kiHuvdITI_8xmWtbK5Ot9yXxtcY_VD9UqKgE88jk"},
{"content":{"body":"Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):\n```js\n(async () => {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index < jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n```\nthis code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, `.slice` with `.subarray`, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with `.subarray` violates the specification. \n\nFor what is worth, turning `.json()` to `.text()` confirms that in the `.subarray` case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for `.json()`.\n\nMy question, to make it clear, is: is the current code with `.slice` already violating a point of the specification; and is the version with `.subarray` violates it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now","format":"org.matrix.custom.html","formatted_body":"<p>Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index &lt; jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n</code></pre>\n<p>this code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, <code>.slice</code> with <code>.subarray</code>, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with <code>.subarray</code> violates the specification.</p>\n<p>For what is worth, turning <code>.json()</code> to <code>.text()</code> confirms that in the <code>.subarray</code> case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for <code>.json()</code>.</p>\n<p>My question, to make it clear, is: is the current code with <code>.slice</code> already violating a point of the specification; and is the version with <code>.subarray</code> violates it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1710070038288,"senderName":"judekeyser","senderId":"@judekeyser:matrix.org","id":"$7LZAinWZGJEHlI_yUNTF0e2wE_7ECTbbC069mIEUkmA"},
{"content":{"body":" * Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):\n\n```js\n(async () => {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index < jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n```\n\nthis code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, `.slice` with `.subarray`, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with `.subarray` violates the specification.\n\nFor what is worth, turning `.json()` to `.text()` confirms that in the `.subarray` case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for `.json()`.\n\nMy question, to make it clear, is: is the current code with `.slice` already violating a point of the specification; and is the version with `.subarray` violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now","format":"org.matrix.custom.html","formatted_body":" * <p>Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index &lt; jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n</code></pre>\n<p>this code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, <code>.slice</code> with <code>.subarray</code>, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with <code>.subarray</code> violates the specification.</p>\n<p>For what is worth, turning <code>.json()</code> to <code>.text()</code> confirms that in the <code>.subarray</code> case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for <code>.json()</code>.</p>\n<p>My question, to make it clear, is: is the current code with <code>.slice</code> already violating a point of the specification; and is the version with <code>.subarray</code> violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now</p>\n","m.mentions":{},"m.new_content":{"body":"Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):\n\n```js\n(async () => {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index < jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n```\n\nthis code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, `.slice` with `.subarray`, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with `.subarray` violates the specification.\n\nFor what is worth, turning `.json()` to `.text()` confirms that in the `.subarray` case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for `.json()`.\n\nMy question, to make it clear, is: is the current code with `.slice` already violating a point of the specification; and is the version with `.subarray` violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now","format":"org.matrix.custom.html","formatted_body":"<p>Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index &lt; jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n</code></pre>\n<p>this code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, <code>.slice</code> with <code>.subarray</code>, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with <code>.subarray</code> violates the specification.</p>\n<p>For what is worth, turning <code>.json()</code> to <code>.text()</code> confirms that in the <code>.subarray</code> case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for <code>.json()</code>.</p>\n<p>My question, to make it clear, is: is the current code with <code>.slice</code> already violating a point of the specification; and is the version with <code>.subarray</code> violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$7LZAinWZGJEHlI_yUNTF0e2wE_7ECTbbC069mIEUkmA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710071766470,"senderName":"judekeyser","senderId":"@judekeyser:matrix.org","id":"$lrCa4ldFwOSOK-uS1WeQMeQznq-8iraTTe6LGdKA7Ag"},
{"content":{"body":"> <@zcorpan:mozilla.org> But in the end the message should probably suggest reasonable options\n\nDo you mean \"reasonable options\" for fixing the CORS error? I'm not sure I can think of more than what I've already suggested, tbh. One difficulty is that browsers are often left with insufficient contextual information about a preflight failure to produce a helpful error message. For a typical example, see https://jub0bs.com/posts/2023-02-08-fearless-cors/#9-ease-troubleshooting-by-eschewing-shortcuts-during-preflight","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$7MOzqR-ZiTkcamFDMwP-9vo3gpmz0uw966TOAcgJQLA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@zcorpan:mozilla.org\">@zcorpan:mozilla.org</a><br>But in the end the message should probably suggest reasonable options</blockquote></mx-reply>Do you mean \"reasonable options\" for fixing the CORS error? I'm not sure I can think of more than what I've already suggested, tbh. One difficulty is that browsers are often left with insufficient contextual information about a preflight failure to produce a helpful error message. For a typical example, see https://jub0bs.com/posts/2023-02-08-fearless-cors/#9-ease-troubleshooting-by-eschewing-shortcuts-during-preflight","m.mentions":{"user_ids":["@zcorpan:mozilla.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$7MOzqR-ZiTkcamFDMwP-9vo3gpmz0uw966TOAcgJQLA"}},"msgtype":"m.text"},"ts":1710079652548,"senderName":"jub0bs","senderId":"@jub0bs:matrix.org","id":"$xybZ7D8B7RsFJmCB_JEfK4XmVm_mvRrTyBpWTji9Np8"},
{"content":{"body":"> <@zcorpan:mozilla.org> But in the end the message should probably suggest reasonable options\n\n * Do you mean \"reasonable options\" for fixing the CORS error? I'm not sure I can think of more than what I've already suggested, tbh. One difficulty is that browsers are often left with insufficient contextual information about a preflight failure to produce a helpful CORS error message. For a typical example, see https://jub0bs.com/posts/2023-02-08-fearless-cors/#9-ease-troubleshooting-by-eschewing-shortcuts-during-preflight","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$7MOzqR-ZiTkcamFDMwP-9vo3gpmz0uw966TOAcgJQLA?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@zcorpan:mozilla.org\">@zcorpan:mozilla.org</a><br>But in the end the message should probably suggest reasonable options</blockquote></mx-reply> * Do you mean \"reasonable options\" for fixing the CORS error? I'm not sure I can think of more than what I've already suggested, tbh. One difficulty is that browsers are often left with insufficient contextual information about a preflight failure to produce a helpful CORS error message. For a typical example, see https://jub0bs.com/posts/2023-02-08-fearless-cors/#9-ease-troubleshooting-by-eschewing-shortcuts-during-preflight","m.mentions":{},"m.new_content":{"body":"Do you mean \"reasonable options\" for fixing the CORS error? I'm not sure I can think of more than what I've already suggested, tbh. One difficulty is that browsers are often left with insufficient contextual information about a preflight failure to produce a helpful CORS error message. For a typical example, see https://jub0bs.com/posts/2023-02-08-fearless-cors/#9-ease-troubleshooting-by-eschewing-shortcuts-during-preflight","format":"org.matrix.custom.html","formatted_body":"Do you mean \"reasonable options\" for fixing the CORS error? I'm not sure I can think of more than what I've already suggested, tbh. One difficulty is that browsers are often left with insufficient contextual information about a preflight failure to produce a helpful CORS error message. For a typical example, see https://jub0bs.com/posts/2023-02-08-fearless-cors/#9-ease-troubleshooting-by-eschewing-shortcuts-during-preflight","m.mentions":{"user_ids":["@zcorpan:mozilla.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$xybZ7D8B7RsFJmCB_JEfK4XmVm_mvRrTyBpWTji9Np8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710079747425,"senderName":"jub0bs","senderId":"@jub0bs:matrix.org","id":"$2yc9u73R0a9sbDKAyK9lBGbMapP5u7P6uvX5j7q89iY"},
{"content":{"body":"> <@judekeyser:matrix.org> Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):\n> \n> ```js\n> (async () => {\n>     const stream = (function* chunks(json) {\n>         const jsonString = JSON.stringify(json);\n>         const jsonBytes = new TextEncoder().encode(jsonString);\n>     \n>         let index = 0;\n>         while(index < jsonBytes.length) {\n>             const i = index;\n>             const j = Math.min(jsonBytes.length, i + 10);\n>     \n>             const slice = jsonBytes.slice(i, j);    // LINE (A)\n>             index = j;\n>             yield slice;\n>         }\n>     })({\"Hello!\": [2023, 2024 ]});\n>     \n>     const jsonBack = await new Response(new ReadableStream({\n>         type: \"bytes\",\n>         start: function(controller) {\n>             for(const chunk of stream) {\n>                 controller.enqueue(chunk);\n>             }\n>             controller.close();\n>         }\n>     })).json();\n>     \n>     console.log(jsonBack);\n> })()\n> ```\n> \n> this code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, `.slice` with `.subarray`, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with `.subarray` violates the specification.\n> \n> For what is worth, turning `.json()` to `.text()` confirms that in the `.subarray` case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for `.json()`.\n> \n> My question, to make it clear, is: is the current code with `.slice` already violating a point of the specification; and is the version with `.subarray` violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now\n\nokay for what's worth, I understood what happened here. When enqueuing, the buffer is detached. This forces the length to go down to 0, which abruptly terminates my emission loop and I never emit more than 1 chunk, which is the cause of all issues. That's why I don't have the expected TypeError, since actually I never pass a detached buffer, as the loop terminates after.\n\nI must say debugging this was kind of an adventure! Not sure if it's all clear for everyone that enqueue detaches the buffer, while reading the documentation. but I eventually found it, collecting all the pieces together","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$7LZAinWZGJEHlI_yUNTF0e2wE_7ECTbbC069mIEUkmA?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@judekeyser:matrix.org\">@judekeyser:matrix.org</a><br><p>Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index &lt; jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n</code></pre>\n<p>this code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, <code>.slice</code> with <code>.subarray</code>, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with <code>.subarray</code> violates the specification.</p>\n<p>For what is worth, turning <code>.json()</code> to <code>.text()</code> confirms that in the <code>.subarray</code> case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for <code>.json()</code>.</p>\n<p>My question, to make it clear, is: is the current code with <code>.slice</code> already violating a point of the specification; and is the version with <code>.subarray</code> violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now</p>\n</blockquote></mx-reply><p>okay for what's worth, I understood what happened here. When enqueuing, the buffer is detached. This forces the length to go down to 0, which abruptly terminates my emission loop and I never emit more than 1 chunk, which is the cause of all issues. That's why I don't have the expected TypeError, since actually I never pass a detached buffer, as the loop terminates after.</p>\n<p>I must say debugging this was kind of an adventure! Not sure if it's all clear for everyone that enqueue detaches the buffer, while reading the documentation. but I eventually found it, collecting all the pieces together</p>\n","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$7LZAinWZGJEHlI_yUNTF0e2wE_7ECTbbC069mIEUkmA"}},"msgtype":"m.text"},"ts":1710083475991,"senderName":"judekeyser","senderId":"@judekeyser:matrix.org","id":"$CTVSFP2P5vAkmAb3MOGKT4hIQiSWNI4sbE0MFyZguUA"}
]