[
{"content":{"body":"Hello, does anyone know about the \"willful violation of RFC 5322\" note in section 4.10.5.1.5 Email state of the whatwg HTML spec? The comment raises some concern for me, since RFC-5322 is not the appropriate standard to find the syntax of email addresses as used on the public Internet today to route email. The correct standard is RFC-5321, which defines the SMTP protocol and includes a grammar for Mailbox which is what most people think of as an email address. This is what people sometimes call the \"envelope\" address.\n\nThe RFC-5322 document specifies the format of the email message content, not the protocol used to transport mail.\n\nSo, yeah: you should not follow RFC-5322, but you should follow RFC-5321.\n","m.mentions":{},"msgtype":"m.text"},"ts":1710041317598,"senderName":"dean.highpower","senderId":"@dean.highpower:matrix.org","id":"$0Q66H6h7YzkyPOkIMUN04wjxqMBfcjB_W5JUgfJYa0k"},
{"content":{"body":"dean.highpower: there's a long discussion in https://github.com/whatwg/html/issues/4562 without much progress, though someone from the i18n WG might make another attempt this year.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@dean.highpower:matrix.org\">dean.highpower</a>: there's a long discussion in https://github.com/whatwg/html/issues/4562 without much progress, though someone from the i18n WG might make another attempt this year.","m.mentions":{"user_ids":["@dean.highpower:matrix.org"]},"msgtype":"m.text"},"ts":1710056455276,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$837kiHuvdITI_8xmWtbK5Ot9yXxtcY_VD9UqKgE88jk"},
{"content":{"body":"Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):\n```js\n(async () => {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index < jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n```\nthis code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, `.slice` with `.subarray`, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with `.subarray` violates the specification. \n\nFor what is worth, turning `.json()` to `.text()` confirms that in the `.subarray` case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for `.json()`.\n\nMy question, to make it clear, is: is the current code with `.slice` already violating a point of the specification; and is the version with `.subarray` violates it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now","format":"org.matrix.custom.html","formatted_body":"<p>Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index &lt; jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n</code></pre>\n<p>this code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, <code>.slice</code> with <code>.subarray</code>, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with <code>.subarray</code> violates the specification.</p>\n<p>For what is worth, turning <code>.json()</code> to <code>.text()</code> confirms that in the <code>.subarray</code> case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for <code>.json()</code>.</p>\n<p>My question, to make it clear, is: is the current code with <code>.slice</code> already violating a point of the specification; and is the version with <code>.subarray</code> violates it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1710070038288,"senderName":"judekeyser","senderId":"@judekeyser:matrix.org","id":"$7LZAinWZGJEHlI_yUNTF0e2wE_7ECTbbC069mIEUkmA"},
{"content":{"body":" * Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):\n\n```js\n(async () => {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index < jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n```\n\nthis code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, `.slice` with `.subarray`, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with `.subarray` violates the specification.\n\nFor what is worth, turning `.json()` to `.text()` confirms that in the `.subarray` case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for `.json()`.\n\nMy question, to make it clear, is: is the current code with `.slice` already violating a point of the specification; and is the version with `.subarray` violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now","format":"org.matrix.custom.html","formatted_body":" * <p>Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index &lt; jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n</code></pre>\n<p>this code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, <code>.slice</code> with <code>.subarray</code>, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with <code>.subarray</code> violates the specification.</p>\n<p>For what is worth, turning <code>.json()</code> to <code>.text()</code> confirms that in the <code>.subarray</code> case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for <code>.json()</code>.</p>\n<p>My question, to make it clear, is: is the current code with <code>.slice</code> already violating a point of the specification; and is the version with <code>.subarray</code> violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now</p>\n","m.mentions":{},"m.new_content":{"body":"Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):\n\n```js\n(async () => {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index < jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n```\n\nthis code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, `.slice` with `.subarray`, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with `.subarray` violates the specification.\n\nFor what is worth, turning `.json()` to `.text()` confirms that in the `.subarray` case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for `.json()`.\n\nMy question, to make it clear, is: is the current code with `.slice` already violating a point of the specification; and is the version with `.subarray` violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now","format":"org.matrix.custom.html","formatted_body":"<p>Hello, I badly apologize if the question does not fit this room, but I'm having trouble understanding a piece of JavaScript code and no one could help me in regular javascript servers. The code I'm concerned with is the following (ready to use):</p>\n<pre><code class=\"language-js\">(async () =&gt; {\n    const stream = (function* chunks(json) {\n        const jsonString = JSON.stringify(json);\n        const jsonBytes = new TextEncoder().encode(jsonString);\n    \n        let index = 0;\n        while(index &lt; jsonBytes.length) {\n            const i = index;\n            const j = Math.min(jsonBytes.length, i + 10);\n    \n            const slice = jsonBytes.slice(i, j);    // LINE (A)\n            index = j;\n            yield slice;\n        }\n    })({\"Hello!\": [2023, 2024 ]});\n    \n    const jsonBack = await new Response(new ReadableStream({\n        type: \"bytes\",\n        start: function(controller) {\n            for(const chunk of stream) {\n                controller.enqueue(chunk);\n            }\n            controller.close();\n        }\n    })).json();\n    \n    console.log(jsonBack);\n})()\n</code></pre>\n<p>this code works as expected (google chrome, firefox; latest versions). However, when I replace in line A, <code>.slice</code> with <code>.subarray</code>, I get different kind of issues, telling me the JSON ends abnormally (in both browsers). I've crawled the official specification of the different API's, and I couldn't find a single clue about whether or not the version with <code>.subarray</code> violates the specification.</p>\n<p>For what is worth, turning <code>.json()</code> to <code>.text()</code> confirms that in the <code>.subarray</code> case, only the first chunk seems to be taken into account. I assume (but not sure about it) the same happens for <code>.json()</code>.</p>\n<p>My question, to make it clear, is: is the current code with <code>.slice</code> already violating a point of the specification; and is the version with <code>.subarray</code> violating it and how? Could it be a browser bug, common to both Firefox and Google Chrome? Many thanks in advance! This issue puzzles me a lot for some days now</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$7LZAinWZGJEHlI_yUNTF0e2wE_7ECTbbC069mIEUkmA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1710071766470,"senderName":"judekeyser","senderId":"@judekeyser:matrix.org","id":"$lrCa4ldFwOSOK-uS1WeQMeQznq-8iraTTe6LGdKA7Ag"}
]