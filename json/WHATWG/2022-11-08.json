[
{"content":{"body":"So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.\n\nThe BiDi model is basically that you get the following events: `beforeRequest`, `responseStarted`, `responseCompleted`, `fetchError`. The invariants are that every request (including redirects etc.) gets a `beforeRequest` event and either `responseStarted`/`responseCompleted` or `fetchError` (and maybe `responseStarted` if the error happens after the response headers are received).\n\nI _think_ the end-of-lifecycle events can be handled in the \"fetch response handover\"? But what I'm less sure about is guaranteeing that there's always a matching `beforeRequest` event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in \"fetch response handover\" without having emitted a `beforeRequest` event. But there can also be an error which occurs after it's sent, so we can end up there when we _have_ already emitted that event.\n\nIs there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.","format":"org.matrix.custom.html","formatted_body":"<p>So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.</p>\n<p>The BiDi model is basically that you get the following events: <code>beforeRequest</code>, <code>responseStarted</code>, <code>responseCompleted</code>, <code>fetchError</code>. The invariants are that every request (including redirects etc.) gets a <code>beforeRequest</code> event and either <code>responseStarted</code>/<code>responseCompleted</code> or <code>fetchError</code> (and maybe <code>responseStarted</code> if the error happens after the response headers are received).</p>\n<p>I <em>think</em> the end-of-lifecycle events can be handled in the &quot;fetch response handover&quot;? But what I'm less sure about is guaranteeing that there's always a matching <code>beforeRequest</code> event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in &quot;fetch response handover&quot; without having emitted a <code>beforeRequest</code> event. But there can also be an error which occurs after it's sent, so we can end up there when we <em>have</em> already emitted that event.</p>\n<p>Is there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.\n\nThe BiDi model is basically that you get the following events: `beforeRequest`, `responseStarted`, `responseCompleted`, `fetchError`. The invariants are that every request (including redirects etc.) gets a `beforeRequest` event and either `responseStarted`/`responseCompleted` or `fetchError` (and maybe `responseStarted` if the error happens after the response headers are received).\n\nI _think_ the end-of-lifecycle events can be handled in the \"fetch response handover\"? But what I'm less sure about is guaranteeing that there's always a matching `beforeRequest` event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in \"fetch response handover\" without having emitted a `beforeRequest` event. But there can also be an error which occurs after it's sent, so we can end up there when we _have_ already emitted that event.\n\nIs there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.","mimetype":"text/plain"},{"body":"<p>So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.</p>\n<p>The BiDi model is basically that you get the following events: <code>beforeRequest</code>, <code>responseStarted</code>, <code>responseCompleted</code>, <code>fetchError</code>. The invariants are that every request (including redirects etc.) gets a <code>beforeRequest</code> event and either <code>responseStarted</code>/<code>responseCompleted</code> or <code>fetchError</code> (and maybe <code>responseStarted</code> if the error happens after the response headers are received).</p>\n<p>I <em>think</em> the end-of-lifecycle events can be handled in the &quot;fetch response handover&quot;? But what I'm less sure about is guaranteeing that there's always a matching <code>beforeRequest</code> event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in &quot;fetch response handover&quot; without having emitted a <code>beforeRequest</code> event. But there can also be an error which occurs after it's sent, so we can end up there when we <em>have</em> already emitted that event.</p>\n<p>Is there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.</p>\n","mimetype":"text/html"}]},"ts":1667909314441,"senderName":"jgraham","senderId":"@jgraham_:matrix.org","id":"$DgxVtoif24S5vqPAljwi8Oml1dk2SlkcV7FBxs_okQM"},
{"content":{"body":" * So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.\n\nThe BiDi model is basically that you get the following events: `beforeRequest`, `responseStarted`, `responseCompleted`, `fetchError`. The invariants are that every request (including redirects etc.) gets a `beforeRequest` event and either `responseStarted`/`responseCompleted` or `fetchError` (and maybe `responseStarted` if the error happens after the response headers are received).\n\nI _think_ the end-of-lifecycle events can be handled in the \"fetch response handover\"? But what I'm less sure about is guaranteeing that there's always a matching `beforeRequest` event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in \"fetch response handover\" without having emitted a `beforeRequest` event. But there can also be an error which occurs after it's sent, so we can end up there when we _have_ already emitted that event.\n\nIs there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.","format":"org.matrix.custom.html","formatted_body":" * <p>So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.</p>\n<p>The BiDi model is basically that you get the following events: <code>beforeRequest</code>, <code>responseStarted</code>, <code>responseCompleted</code>, <code>fetchError</code>. The invariants are that every request (including redirects etc.) gets a <code>beforeRequest</code> event and either <code>responseStarted</code>/<code>responseCompleted</code> or <code>fetchError</code> (and maybe <code>responseStarted</code> if the error happens after the response headers are received).</p>\n<p>I <em>think</em> the end-of-lifecycle events can be handled in the &quot;fetch response handover&quot;? But what I'm less sure about is guaranteeing that there's always a matching <code>beforeRequest</code> event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in &quot;fetch response handover&quot; without having emitted a <code>beforeRequest</code> event. But there can also be an error which occurs after it's sent, so we can end up there when we <em>have</em> already emitted that event.</p>\n<p>Is there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.</p>\n","m.new_content":{"body":"So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.\n\nThe BiDi model is basically that you get the following events: `beforeRequest`, `responseStarted`, `responseCompleted`, `fetchError`. The invariants are that every request (including redirects etc.) gets a `beforeRequest` event and either `responseStarted`/`responseCompleted` or `fetchError` (and maybe `responseStarted` if the error happens after the response headers are received).\n\nI _think_ the end-of-lifecycle events can be handled in the \"fetch response handover\"? But what I'm less sure about is guaranteeing that there's always a matching `beforeRequest` event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in \"fetch response handover\" without having emitted a `beforeRequest` event. But there can also be an error which occurs after it's sent, so we can end up there when we _have_ already emitted that event.\n\nIs there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.","format":"org.matrix.custom.html","formatted_body":"<p>So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.</p>\n<p>The BiDi model is basically that you get the following events: <code>beforeRequest</code>, <code>responseStarted</code>, <code>responseCompleted</code>, <code>fetchError</code>. The invariants are that every request (including redirects etc.) gets a <code>beforeRequest</code> event and either <code>responseStarted</code>/<code>responseCompleted</code> or <code>fetchError</code> (and maybe <code>responseStarted</code> if the error happens after the response headers are received).</p>\n<p>I <em>think</em> the end-of-lifecycle events can be handled in the &quot;fetch response handover&quot;? But what I'm less sure about is guaranteeing that there's always a matching <code>beforeRequest</code> event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in &quot;fetch response handover&quot; without having emitted a <code>beforeRequest</code> event. But there can also be an error which occurs after it's sent, so we can end up there when we <em>have</em> already emitted that event.</p>\n<p>Is there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.\n\nThe BiDi model is basically that you get the following events: `beforeRequest`, `responseStarted`, `responseCompleted`, `fetchError`. The invariants are that every request (including redirects etc.) gets a `beforeRequest` event and either `responseStarted`/`responseCompleted` or `fetchError` (and maybe `responseStarted` if the error happens after the response headers are received).\n\nI _think_ the end-of-lifecycle events can be handled in the \"fetch response handover\"? But what I'm less sure about is guaranteeing that there's always a matching `beforeRequest` event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in \"fetch response handover\" without having emitted a `beforeRequest` event. But there can also be an error which occurs after it's sent, so we can end up there when we _have_ already emitted that event.\n\nIs there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.","mimetype":"text/plain"},{"body":"<p>So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.</p>\n<p>The BiDi model is basically that you get the following events: <code>beforeRequest</code>, <code>responseStarted</code>, <code>responseCompleted</code>, <code>fetchError</code>. The invariants are that every request (including redirects etc.) gets a <code>beforeRequest</code> event and either <code>responseStarted</code>/<code>responseCompleted</code> or <code>fetchError</code> (and maybe <code>responseStarted</code> if the error happens after the response headers are received).</p>\n<p>I <em>think</em> the end-of-lifecycle events can be handled in the &quot;fetch response handover&quot;? But what I'm less sure about is guaranteeing that there's always a matching <code>beforeRequest</code> event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in &quot;fetch response handover&quot; without having emitted a <code>beforeRequest</code> event. But there can also be an error which occurs after it's sent, so we can end up there when we <em>have</em> already emitted that event.</p>\n<p>Is there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$DgxVtoif24S5vqPAljwi8Oml1dk2SlkcV7FBxs_okQM","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.\n\nThe BiDi model is basically that you get the following events: `beforeRequest`, `responseStarted`, `responseCompleted`, `fetchError`. The invariants are that every request (including redirects etc.) gets a `beforeRequest` event and either `responseStarted`/`responseCompleted` or `fetchError` (and maybe `responseStarted` if the error happens after the response headers are received).\n\nI _think_ the end-of-lifecycle events can be handled in the \"fetch response handover\"? But what I'm less sure about is guaranteeing that there's always a matching `beforeRequest` event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in \"fetch response handover\" without having emitted a `beforeRequest` event. But there can also be an error which occurs after it's sent, so we can end up there when we _have_ already emitted that event.\n\nIs there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.","mimetype":"text/plain"},{"body":" * <p>So I'm trying to integrate WebDriver BiDi network events into fetch, and I'm struggling to work out where to call the various lifecycle update algorithms.</p>\n<p>The BiDi model is basically that you get the following events: <code>beforeRequest</code>, <code>responseStarted</code>, <code>responseCompleted</code>, <code>fetchError</code>. The invariants are that every request (including redirects etc.) gets a <code>beforeRequest</code> event and either <code>responseStarted</code>/<code>responseCompleted</code> or <code>fetchError</code> (and maybe <code>responseStarted</code> if the error happens after the response headers are received).</p>\n<p>I <em>think</em> the end-of-lifecycle events can be handled in the &quot;fetch response handover&quot;? But what I'm less sure about is guaranteeing that there's always a matching <code>beforeRequest</code> event with the headers as-sent (or as seen by whatever prevents the request going over the wire e.g. serviceworker or cache). I think the headers requirement means that in the case where the request isn't blocked we need to emit it right before sending. But because the request may be blocked at various points before that, we can end up in &quot;fetch response handover&quot; without having emitted a <code>beforeRequest</code> event. But there can also be an error which occurs after it's sent, so we can end up there when we <em>have</em> already emitted that event.</p>\n<p>Is there something simpler to do here than add extra state to the request, indicating whether we already emitted such an event? Obviously I'd prefer not to add more state if possible because state is complexity, but I'm not seeing an obvious alternative.</p>\n","mimetype":"text/html"}]},"ts":1667909398281,"senderName":"jgraham","senderId":"@jgraham_:matrix.org","id":"$wUOOk52gqW03A1ZKXLCN_ys-8z8zN1hBT9i4FLXMDb0"},
{"content":{"body":"Domenic is so optimistic with https://github.com/whatwg/html/pull/6315#pullrequestreview-1158013824 ðŸ™‚  no regressions with session history stuff?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a> is so optimistic with https://github.com/whatwg/html/pull/6315#pullrequestreview-1158013824 ðŸ™‚  no regressions with session history stuff?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Domenic is so optimistic with https://github.com/whatwg/html/pull/6315#pullrequestreview-1158013824 ðŸ™‚  no regressions with session history stuff?","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a> is so optimistic with https://github.com/whatwg/html/pull/6315#pullrequestreview-1158013824 ðŸ™‚  no regressions with session history stuff?","mimetype":"text/html"}]},"ts":1667911445351,"senderName":"smaug","senderId":"@smaug:mozilla.org","id":"$yyVaxXAn2oCQN3XS2lDk6swoP0dGRicjZfWqSL3wygQ"},
{"content":{"body":"Session history is the one component where regressions are pretty much guaranteed whenever anything changes.","msgtype":"m.text","org.matrix.msc1767.text":"Session history is the one component where regressions are pretty much guaranteed whenever anything changes."},"ts":1667911478489,"senderName":"smaug","senderId":"@smaug:mozilla.org","id":"$j1K1OzYde_jfB6CA_tu8O13ot-wt-n-glONPyXtIqvY"},
{"content":{"body":"just fixed yet another issue he caused 2 years ago. Some site did effectively: location.reload(); location.href = \"newpage\"; and that right after there were something like 5 http redirects ","msgtype":"m.emote","org.matrix.msc1767.text":"just fixed yet another issue he caused 2 years ago. Some site did effectively: location.reload(); location.href = \"newpage\"; and that right after there were something like 5 http redirects "},"ts":1667911635794,"senderName":"smaug","senderId":"@smaug:mozilla.org","id":"$wCwdFXnr1sEGIS8mm5lC_8aXr03K7zf_h8hUxi7R6_4"},
{"content":{"body":" * just fixed yet another issue he caused 2 years ago. Some site did effectively: location.reload(); location.href = \"newpage\"; and that right after there were something like 5 http redirects ","m.new_content":{"body":"just fixed yet another issue he caused 2 years ago. Some site did effectively: location.reload(); location.href = \"newpage\"; and that right after there were something like 5 http redirects ","msgtype":"m.emote","org.matrix.msc1767.text":"just fixed yet another issue he caused 2 years ago. Some site did effectively: location.reload(); location.href = \"newpage\"; and that right after there were something like 5 http redirects "},"m.relates_to":{"event_id":"$wCwdFXnr1sEGIS8mm5lC_8aXr03K7zf_h8hUxi7R6_4","rel_type":"m.replace"},"msgtype":"m.emote","org.matrix.msc1767.text":" * just fixed yet another issue he caused 2 years ago. Some site did effectively: location.reload(); location.href = \"newpage\"; and that right after there were something like 5 http redirects "},"ts":1667911668201,"senderName":"smaug","senderId":"@smaug:mozilla.org","id":"$zW63adnuFaQmp_RvEDXUA1QGuQ5hClWP_gU1LjNZ3j4"}
]