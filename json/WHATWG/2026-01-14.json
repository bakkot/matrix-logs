[
{"content":{"body":"I remember we had a discussion about \"then\" following \"Otherwise\". I vaguely recall we wanted to change towards including it. Does anyone else have a recollection of this and maybe a pointer? jmdyck?","format":"org.matrix.custom.html","formatted_body":"I remember we had a discussion about \"then\" following \"Otherwise\". I vaguely recall we wanted to change towards including it. Does anyone else have a recollection of this and maybe a pointer? <a href=\"https://matrix.to/#/@jmdyck:matrix.org\">jmdyck</a>?","m.mentions":{"user_ids":["@jmdyck:matrix.org"]},"msgtype":"m.text"},"ts":1768383424594,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$8CUnnXj7Rd7uleg4aWtOLnl-yCaDJNtklrdMOGr8PE4"},
{"content":{"body":"sideshowbarker: I don't see anything about `selectedcontent` handling in the Tree Construction part of the spec. Is there an in-flight spec PR that I should be looking at, or have the cloning effects of parsing been specced in a way that's not visible in the parsing spec?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sideshowbarker:matrix.org\">sideshowbarker</a>: I don't see anything about <code>selectedcontent</code> handling in the Tree Construction part of the spec. Is there an in-flight spec PR that I should be looking at, or have the cloning effects of parsing been specced in a way that's not visible in the parsing spec?","m.mentions":{"user_ids":["@sideshowbarker:matrix.org"]},"msgtype":"m.text"},"ts":1768390975287,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$DtLdF78YEEam87UUn6TtD5qQEYVt3dSQ08ujcoPFabc"},
{"content":{"body":"See the hook to the _“maybe clone an option into selectedcontent”_ algorithm here: https://html.spec.whatwg.org/multipage/form-elements.html#the-option-element:maybe-clone-an-option-into-selectedcontent\n\nAnd see the _“maybe clone an option into selectedcontent”_ algorithm itself here: https://html.spec.whatwg.org/multipage/form-elements.html#maybe-clone-an-option-into-selectedcontent","format":"org.matrix.custom.html","formatted_body":"<p>See the hook to the <em>“maybe clone an option into selectedcontent”</em> algorithm here: https://html.spec.whatwg.org/multipage/form-elements.html#the-option-element:maybe-clone-an-option-into-selectedcontent</p>\n<p>And see the <em>“maybe clone an option into selectedcontent”</em> algorithm itself here: https://html.spec.whatwg.org/multipage/form-elements.html#maybe-clone-an-option-into-selectedcontent</p>\n","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$DtLdF78YEEam87UUn6TtD5qQEYVt3dSQ08ujcoPFabc"}},"msgtype":"m.text"},"ts":1768391665523,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$SEVYYIEPYki6_sSiYtTLw3MoD5XIutaNbYEcyjrVUEo"},
{"content":{"body":"sideshowbarker: Thanks. I can see why the text would end up there in order to cover XML, but it's not good that the HTML parsing algorithm is silent about this.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sideshowbarker:matrix.org\">sideshowbarker</a>: Thanks. I can see why the text would end up there in order to cover XML, but it's not good that the HTML parsing algorithm is silent about this.","m.mentions":{"user_ids":["@sideshowbarker:matrix.org"]},"msgtype":"m.text"},"ts":1768391825989,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$3ogMmfMpTuETU-8-l9X-RjRTlhzihcHRntkT0UbfODQ"},
{"content":{"body":"Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$3ogMmfMpTuETU-8-l9X-RjRTlhzihcHRntkT0UbfODQ"}},"msgtype":"m.text"},"ts":1768392059408,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$rT187WdrDyyaaekFYUt1orfoLnleiCSTBMZTBq6sesY"},
{"content":{"body":"sideshowbarker: It seems to me that the spec expects cloning to happen on what's in the DOM at cloning time and not on what the parser has seen. Am I missing something?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sideshowbarker:matrix.org\">sideshowbarker</a>: It seems to me that the spec expects cloning to happen on what's in the DOM at cloning time and not on what the parser has seen. Am I missing something?","m.mentions":{"user_ids":["@sideshowbarker:matrix.org"]},"msgtype":"m.text"},"ts":1768392285792,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$YA0C2DiaTbfFcuLH2j1AUcetob4mYaoAHwUwTBrnuMs"},
{"content":{"body":"hsivonen:  And also on that subject, I have some reservations about what implementing the _“Out of order HTML streaming (\"patching\")”_ is going to be like, and I guess I should probably speak up about those. But I hope to god I don’t end up needing to try to implement that one. It’d be much better if you did — or at least somebody else with more chops than me.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>:  And also on that subject, I have some reservations about what implementing the <em>“Out of order HTML streaming (\"patching\")”</em> is going to be like, and I guess I should probably speak up about those. But I hope to god I don’t end up needing to try to implement that one. It’d be much better if you did&nbsp;— or at least somebody else with more chops than me.","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"ts":1768392292586,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$nW8nyoTcGYDlij9aqNmjEoGIpoaoaUfc98ksc3MWZJQ"},
{"content":{"body":"* hsivonen:  And also on that subject, I have some reservations about what implementing the whole _“Out of order HTML streaming (\"patching\")”_ thing is going to be like, and I guess I should probably speak up about those. But I hope to god I don’t end up needing to try to implement that one. It’d be much better if you did — or at least somebody else with more chops than me.","format":"org.matrix.custom.html","formatted_body":"* <a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>:  And also on that subject, I have some reservations about what implementing the whole <em>“Out of order HTML streaming (\"patching\")”</em> thing is going to be like, and I guess I should probably speak up about those. But I hope to god I don’t end up needing to try to implement that one. It’d be much better if you did&nbsp;— or at least somebody else with more chops than me.","m.mentions":{},"m.new_content":{"body":"hsivonen:  And also on that subject, I have some reservations about what implementing the whole _“Out of order HTML streaming (\"patching\")”_ thing is going to be like, and I guess I should probably speak up about those. But I hope to god I don’t end up needing to try to implement that one. It’d be much better if you did — or at least somebody else with more chops than me.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>:  And also on that subject, I have some reservations about what implementing the whole <em>“Out of order HTML streaming (\"patching\")”</em> thing is going to be like, and I guess I should probably speak up about those. But I hope to god I don’t end up needing to try to implement that one. It’d be much better if you did&nbsp;— or at least somebody else with more chops than me.","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$nW8nyoTcGYDlij9aqNmjEoGIpoaoaUfc98ksc3MWZJQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1768392329969,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$aZzoULUIfxTEoVyvrFnWgekzfylOhwyWcbiilxVldB8"},
{"content":{"body":"(not that it’s even been written up yet — I’m just anticipating the shape)","m.mentions":{},"msgtype":"m.text"},"ts":1768392389162,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$-h3yFzcuWmqioRU__t09shQTUzcTIjYRGxxwzD20Ueg"},
{"content":{"body":"* Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But at that point, I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854","m.mentions":{},"m.new_content":{"body":"Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But at that point, I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rT187WdrDyyaaekFYUt1orfoLnleiCSTBMZTBq6sesY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1768392463553,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$yYZBLT8V7vj7__gjyAEOWuRwPrXOWZsImEmtdo5xSok"},
{"content":{"body":"* Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But at that point, I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it in part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854","m.mentions":{},"m.new_content":{"body":"Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But at that point, I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it in part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rT187WdrDyyaaekFYUt1orfoLnleiCSTBMZTBq6sesY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1768392476306,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$NMTX8VoDenZqGtNtS0MrHvUKkkespDIs3dhr23Z9w-E"},
{"content":{"body":"I think you’re not missing something. I’d need to go back and look. But I will confess that in part what I did there was, implement against the tests. And I think I did get all the WPT tests for this fully passing.\n\nIn other words, I did the bad thing of not raising some spec issues that I probably should have when I was implementing — I mean, about possible gaps in the spec relative to getting what the expected results for the tests seemed to require.","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$YA0C2DiaTbfFcuLH2j1AUcetob4mYaoAHwUwTBrnuMs"}},"msgtype":"m.text"},"ts":1768392698570,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$Nq5Jf60qM5bjE5jGf7gQ32Fb063qpZZ5r34_w4zuKPM"},
{"content":{"body":"sideshowbarker: The difference would be visible only with a network stall and setTimeout, right?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sideshowbarker:matrix.org\">sideshowbarker</a>: The difference would be visible only with a network stall and setTimeout, right?","m.mentions":{"user_ids":["@sideshowbarker:matrix.org"]},"msgtype":"m.text"},"ts":1768392755518,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$tPc0d7w5IyaiHYhMYYo6uv2nUrxXZ-YlqKJfE7wVzw8"},
{"content":{"body":"Yeah, I reckon so. And so we should rightly have a WPT test for that — for the setTimeout case at least.","m.mentions":{},"msgtype":"m.text"},"ts":1768392850957,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$yPJAMYd_NhLQuAZtuVD9L1WCOnbQAi3t5kwuvu15Jsc"},
{"content":{"body":"I will also confess that I didn’t not try to audit the tests for coverage against the spec requirements.","m.mentions":{},"msgtype":"m.text"},"ts":1768392881840,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$JUKVGfU2oxQtdvynFy1nkXOiOjXBylZnKldPyKkn1qs"},
{"content":{"body":"* I will also confess that I didn’t try to audit the tests for coverage against the spec requirements.","m.mentions":{},"m.new_content":{"body":"I will also confess that I didn’t try to audit the tests for coverage against the spec requirements.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$JUKVGfU2oxQtdvynFy1nkXOiOjXBylZnKldPyKkn1qs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1768392889980,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$idHlsizGNiYAEk9rWuA7zjJr5Uvok6xsjgXAwWPfwNI"},
{"content":{"body":"hsivonen: there's quite a few unresolved issues with `selectedcontent` still: https://github.com/whatwg/html/issues?q=state%3Aopen%20selectedcontent","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: there's quite a few unresolved issues with <code>selectedcontent</code> still: https://github.com/whatwg/html/issues?q=state%3Aopen%20selectedcontent","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"ts":1768394683967,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$WMkQfQCuHct82UD1ypP-rJyYCkAtaCCGrR9TICZYBPA"},
{"content":{"body":"Not really sure why the parser should say something about it though. I kinda like that it's all handled at the node tree layer.","m.mentions":{},"msgtype":"m.text"},"ts":1768394717896,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$yVhNexS1pIJ2B-sQkQCnMnevnmG9yeMXqVeqXIacQOM"},
{"content":{"body":"annevk: It's pretty unfriendly to have an action triggered when a node is popped off the parser's stack without any hint in the parsing algorithm that popping `option` off the stack is connected to further action.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@annevk:matrix.org\">annevk</a>: It's pretty unfriendly to have an action triggered when a node is popped off the parser's stack without any hint in the parsing algorithm that popping <code>option</code> off the stack is connected to further action.","m.mentions":{"user_ids":["@annevk:matrix.org"]},"msgtype":"m.text"},"ts":1768394802742,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$w8wM87P2noZ0lPWf7CskUOxO7t_2pWk86Gmc3HLA1Bk"},
{"content":{"body":"hsivonen: oh that bit. That's a pre-existing issue. I agree we should refactor that. https://github.com/whatwg/html/issues/11781 tracks that.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@hsivonen:mozilla.org\">hsivonen</a>: oh that bit. That's a pre-existing issue. I agree we should refactor that. https://github.com/whatwg/html/issues/11781 tracks that.","m.mentions":{"user_ids":["@hsivonen:mozilla.org"]},"msgtype":"m.text"},"ts":1768394992758,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$F5PBrKemhLJR7rP6zaYD1BtlOTbGrHTpL-QpeX9tI5U"},
{"content":{"body":"annevk: Thanks","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@annevk:matrix.org\">annevk</a>: Thanks","m.mentions":{"user_ids":["@annevk:matrix.org"]},"msgtype":"m.text"},"ts":1768395144402,"senderName":"hsivonen","senderId":"@hsivonen:mozilla.org","id":"$NA5dzbasUC-P9CLH8LmaObQkWhbhuOZkmlU_CQWyBFE"},
{"content":{"body":"You mean following *immediately*, like \"If [condition], then [do thing 1], otherwise then [do thing 2].\" ?","format":"org.matrix.custom.html","formatted_body":"You mean following <em>immediately</em>, like \"If [condition], then [do thing 1], otherwise then [do thing 2].\" ?","m.mentions":{"user_ids":["@annevk:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$8CUnnXj7Rd7uleg4aWtOLnl-yCaDJNtklrdMOGr8PE4"}},"msgtype":"m.text"},"ts":1768395223471,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$JBwIuTD_iYrXYF2L8mdniXUjyvaSmRAIeGKlfKGNIzc"},
{"content":{"body":"jmdyck: 1. If X, then Y. \\n 2. Otherwise, then Z.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jmdyck:matrix.org\">jmdyck</a>: 1. If X, then Y. \\n 2. Otherwise, then Z.","m.mentions":{"user_ids":["@jmdyck:matrix.org"]},"msgtype":"m.text"},"ts":1768395511319,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$iOvvlgR6107dVMuaAtvx2S5y7maNnH0h9JydggAiDow"},
{"content":{"body":"Hm, you might be thinking of https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$Uyrjmx4h9XHM_gqQug19615xegSjjwzkaBN5-NLoeY0 almost a year ago.","m.mentions":{},"msgtype":"m.text"},"ts":1768396866681,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$qy2eZ4gABzAKjsmXreqBvPCFvrkmlcCM7th1O_AaGJw"},
{"content":{"body":"To me, \"otherwise, then\" sounds ungrammatical.","m.mentions":{},"msgtype":"m.text"},"ts":1768396891637,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$oW0fBSthAGF0Zb4QJ6T9vmJcC6D5P76PT3ztD10n-XA"},
{"content":{"body":"I don't think that's it, but maybe it's just \"Otherwise, if X,\" where we considered using \"then\" as well. I agree that for a lone \"Otherwise\" it looks weird.","m.mentions":{},"msgtype":"m.text"},"ts":1768398774426,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$xmiW5PZinjiYVKON9DyWUn-5yiBKxPnOEISl7sHfb2M"},
{"content":{"body":"https://html.spec.whatwg.org/multipage/links.html#dom-hyperlink-href\n\nFor something like step 4 here I think putting a then before \"return this's href\"... is fine. Not sure it's needed. But yeah just \"otherwise, then\" seems wrong to me.","m.mentions":{},"msgtype":"m.text"},"ts":1768399775441,"senderName":"Luke Warlow","senderId":"@lwarlow:igalia.com","id":"$kLTmh6ht0telRTEC3TVa2b8mbCR96E4DL9QxacLvHbo"},
{"content":{"body":"So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.\n\nSo API-wise the way this will work is that some operation that exposes a stream will return an object with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.\n\nMy question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:\n```\n1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>\"\"</code> and the <code>done</code> field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n```\nAnd then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps. \n\nThis is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects. ","format":"org.matrix.custom.html","formatted_body":"<p>So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.</p>\n<p>So API-wise the way this will work is that some operation that exposes a stream will return an object with a UUID to that stream and you'll get protocol operations like <code>io.readStream({stream: &lt;id&gt;})</code> and <code>io.closeStream({stream: id})</code>.</p>\n<p>My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for <code>readStream</code> we could pretty much call <code>[=read request=]</code> with something like:</p>\n<pre><code>1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to [=serialize protocol bytes=] given |chunk| and the &lt;code&gt;done&lt;/code&gt; field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to &lt;code&gt;\"\"&lt;/code&gt; and the &lt;code&gt;done&lt;/code&gt; field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n</code></pre>\n<p>And then it needs the equivalent of <code>ReadableStreamDefaultReaderRead</code> to eventually call <code>stream.[[controller]].[[PullSteps]](readRequest)</code> and actually invoke the steps.</p>\n<p>This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual <code>ReadableStreamDefaultReader</code> object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1768400764054,"senderName":"jgraham","senderId":"@jgraham_:matrix.org","id":"$8yVNdUlscym2kdTH_UNO7FJzRe14fnFHV9fJ0g8SGuA"},
{"content":{"body":"* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.\n\nSo API-wise the way this will work is that some operation that exposes a stream will return a WebDriver protocol message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.\n\nMy question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:\n\n```\n1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>\"\"</code> and the <code>done</code> field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n```\n\nAnd then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.\n\nThis is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.","format":"org.matrix.custom.html","formatted_body":"* <p>So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.</p>\n<p>So API-wise the way this will work is that some operation that exposes a stream will return a WebDriver protocol message with a UUID to that stream and you'll get protocol operations like <code>io.readStream({stream: &lt;id&gt;})</code> and <code>io.closeStream({stream: id})</code>.</p>\n<p>My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for <code>readStream</code> we could pretty much call <code>[=read request=]</code> with something like:</p>\n<pre><code>1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to [=serialize protocol bytes=] given |chunk| and the &lt;code&gt;done&lt;/code&gt; field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to &lt;code&gt;\"\"&lt;/code&gt; and the &lt;code&gt;done&lt;/code&gt; field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n</code></pre>\n<p>And then it needs the equivalent of <code>ReadableStreamDefaultReaderRead</code> to eventually call <code>stream.[[controller]].[[PullSteps]](readRequest)</code> and actually invoke the steps.</p>\n<p>This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual <code>ReadableStreamDefaultReader</code> object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.</p>\n","m.mentions":{},"m.new_content":{"body":"So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.\n\nSo API-wise the way this will work is that some operation that exposes a stream will return a WebDriver protocol message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.\n\nMy question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:\n\n```\n1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>\"\"</code> and the <code>done</code> field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n```\n\nAnd then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.\n\nThis is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.","format":"org.matrix.custom.html","formatted_body":"<p>So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.</p>\n<p>So API-wise the way this will work is that some operation that exposes a stream will return a WebDriver protocol message with a UUID to that stream and you'll get protocol operations like <code>io.readStream({stream: &lt;id&gt;})</code> and <code>io.closeStream({stream: id})</code>.</p>\n<p>My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for <code>readStream</code> we could pretty much call <code>[=read request=]</code> with something like:</p>\n<pre><code>1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to [=serialize protocol bytes=] given |chunk| and the &lt;code&gt;done&lt;/code&gt; field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to &lt;code&gt;\"\"&lt;/code&gt; and the &lt;code&gt;done&lt;/code&gt; field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n</code></pre>\n<p>And then it needs the equivalent of <code>ReadableStreamDefaultReaderRead</code> to eventually call <code>stream.[[controller]].[[PullSteps]](readRequest)</code> and actually invoke the steps.</p>\n<p>This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual <code>ReadableStreamDefaultReader</code> object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$8yVNdUlscym2kdTH_UNO7FJzRe14fnFHV9fJ0g8SGuA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1768400960084,"senderName":"jgraham","senderId":"@jgraham_:matrix.org","id":"$7PnBQ_1RKax7_CO3k-HdYHJZNwaPwfZcDCDicBQyGvU"},
{"content":{"body":"* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.\n\nSo API-wise the way this will work is that some WebDriver operation that exposes a stream will return a message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.\n\nMy question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:\n\n```\n1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>\"\"</code> and the <code>done</code> field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n```\n\nAnd then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.\n\nThis is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.","format":"org.matrix.custom.html","formatted_body":"* <p>So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.</p>\n<p>So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a message with a UUID to that stream and you'll get protocol operations like <code>io.readStream({stream: &lt;id&gt;})</code> and <code>io.closeStream({stream: id})</code>.</p>\n<p>My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for <code>readStream</code> we could pretty much call <code>[=read request=]</code> with something like:</p>\n<pre><code>1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to [=serialize protocol bytes=] given |chunk| and the &lt;code&gt;done&lt;/code&gt; field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to &lt;code&gt;\"\"&lt;/code&gt; and the &lt;code&gt;done&lt;/code&gt; field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n</code></pre>\n<p>And then it needs the equivalent of <code>ReadableStreamDefaultReaderRead</code> to eventually call <code>stream.[[controller]].[[PullSteps]](readRequest)</code> and actually invoke the steps.</p>\n<p>This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual <code>ReadableStreamDefaultReader</code> object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.</p>\n","m.mentions":{},"m.new_content":{"body":"So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.\n\nSo API-wise the way this will work is that some WebDriver operation that exposes a stream will return a message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.\n\nMy question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:\n\n```\n1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>\"\"</code> and the <code>done</code> field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n```\n\nAnd then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.\n\nThis is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.","format":"org.matrix.custom.html","formatted_body":"<p>So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.</p>\n<p>So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a message with a UUID to that stream and you'll get protocol operations like <code>io.readStream({stream: &lt;id&gt;})</code> and <code>io.closeStream({stream: id})</code>.</p>\n<p>My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for <code>readStream</code> we could pretty much call <code>[=read request=]</code> with something like:</p>\n<pre><code>1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to [=serialize protocol bytes=] given |chunk| and the &lt;code&gt;done&lt;/code&gt; field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to &lt;code&gt;\"\"&lt;/code&gt; and the &lt;code&gt;done&lt;/code&gt; field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n</code></pre>\n<p>And then it needs the equivalent of <code>ReadableStreamDefaultReaderRead</code> to eventually call <code>stream.[[controller]].[[PullSteps]](readRequest)</code> and actually invoke the steps.</p>\n<p>This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual <code>ReadableStreamDefaultReader</code> object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$8yVNdUlscym2kdTH_UNO7FJzRe14fnFHV9fJ0g8SGuA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1768400999171,"senderName":"jgraham","senderId":"@jgraham_:matrix.org","id":"$yZMIMMzAOzjzJIcQbpK8d1Bp8_Mt0PPnlSO7IbjvkzU"},
{"content":{"body":"* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.\n\nSo API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.\n\nMy question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:\n\n```\n1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>\"\"</code> and the <code>done</code> field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n```\n\nAnd then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.\n\nThis is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.","format":"org.matrix.custom.html","formatted_body":"* <p>So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.</p>\n<p>So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like <code>io.readStream({stream: &lt;id&gt;})</code> and <code>io.closeStream({stream: id})</code>.</p>\n<p>My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for <code>readStream</code> we could pretty much call <code>[=read request=]</code> with something like:</p>\n<pre><code>1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to [=serialize protocol bytes=] given |chunk| and the &lt;code&gt;done&lt;/code&gt; field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to &lt;code&gt;\"\"&lt;/code&gt; and the &lt;code&gt;done&lt;/code&gt; field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n</code></pre>\n<p>And then it needs the equivalent of <code>ReadableStreamDefaultReaderRead</code> to eventually call <code>stream.[[controller]].[[PullSteps]](readRequest)</code> and actually invoke the steps.</p>\n<p>This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual <code>ReadableStreamDefaultReader</code> object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.</p>\n","m.mentions":{},"m.new_content":{"body":"So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.\n\nSo API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.\n\nMy question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:\n\n```\n1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>\"\"</code> and the <code>done</code> field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n```\n\nAnd then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.\n\nThis is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.","format":"org.matrix.custom.html","formatted_body":"<p>So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.</p>\n<p>So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like <code>io.readStream({stream: &lt;id&gt;})</code> and <code>io.closeStream({stream: id})</code>.</p>\n<p>My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for <code>readStream</code> we could pretty much call <code>[=read request=]</code> with something like:</p>\n<pre><code>1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to [=serialize protocol bytes=] given |chunk| and the &lt;code&gt;done&lt;/code&gt; field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to &lt;code&gt;\"\"&lt;/code&gt; and the &lt;code&gt;done&lt;/code&gt; field set to true.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n</code></pre>\n<p>And then it needs the equivalent of <code>ReadableStreamDefaultReaderRead</code> to eventually call <code>stream.[[controller]].[[PullSteps]](readRequest)</code> and actually invoke the steps.</p>\n<p>This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual <code>ReadableStreamDefaultReader</code> object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$8yVNdUlscym2kdTH_UNO7FJzRe14fnFHV9fJ0g8SGuA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1768401027566,"senderName":"jgraham","senderId":"@jgraham_:matrix.org","id":"$Vq0kgoABStE_mr0fd2yFwfUm9vWc-Dw5Q70aNKJbqKc"},
{"content":{"body":"* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.\n\nSo API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.\n\nMy question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:\n\n```\n1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>\"\"</code> and the <code>done</code> field set to true.\n    1. Return [=success=] with data |response|.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n```\n\nAnd then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.\n\nThis is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.","format":"org.matrix.custom.html","formatted_body":"* <p>So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.</p>\n<p>So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like <code>io.readStream({stream: &lt;id&gt;})</code> and <code>io.closeStream({stream: id})</code>.</p>\n<p>My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for <code>readStream</code> we could pretty much call <code>[=read request=]</code> with something like:</p>\n<pre><code>1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to [=serialize protocol bytes=] given |chunk| and the &lt;code&gt;done&lt;/code&gt; field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to &lt;code&gt;\"\"&lt;/code&gt; and the &lt;code&gt;done&lt;/code&gt; field set to true.\n    1. Return [=success=] with data |response|.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n</code></pre>\n<p>And then it needs the equivalent of <code>ReadableStreamDefaultReaderRead</code> to eventually call <code>stream.[[controller]].[[PullSteps]](readRequest)</code> and actually invoke the steps.</p>\n<p>This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual <code>ReadableStreamDefaultReader</code> object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.</p>\n","m.mentions":{},"m.new_content":{"body":"So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.\n\nSo API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.\n\nMy question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:\n\n```\n1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>\"\"</code> and the <code>done</code> field set to true.\n    1. Return [=success=] with data |response|.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n```\n\nAnd then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.\n\nThis is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.","format":"org.matrix.custom.html","formatted_body":"<p>So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.</p>\n<p>So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like <code>io.readStream({stream: &lt;id&gt;})</code> and <code>io.closeStream({stream: id})</code>.</p>\n<p>My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for <code>readStream</code> we could pretty much call <code>[=read request=]</code> with something like:</p>\n<pre><code>1. Let readRequest be a new read request with the following items:\n  1. [=chunk steps=] given |chunk|:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to [=serialize protocol bytes=] given |chunk| and the &lt;code&gt;done&lt;/code&gt; field set to false.\n    1. Return [=success=] with data |response|.\n\n  1. [=close steps=]:\n    1. Let |response| be a new `io.ReadResult` with the &lt;code&gt;value&lt;/code&gt; field set to &lt;code&gt;\"\"&lt;/code&gt; and the &lt;code&gt;done&lt;/code&gt; field set to true.\n    1. Return [=success=] with data |response|.\n\n 1. [=error steps=] given |e|:\n    1. Return [=error=] with [=error code=] [=stream read error=].\n</code></pre>\n<p>And then it needs the equivalent of <code>ReadableStreamDefaultReaderRead</code> to eventually call <code>stream.[[controller]].[[PullSteps]](readRequest)</code> and actually invoke the steps.</p>\n<p>This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual <code>ReadableStreamDefaultReader</code> object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$8yVNdUlscym2kdTH_UNO7FJzRe14fnFHV9fJ0g8SGuA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1768401100182,"senderName":"jgraham","senderId":"@jgraham_:matrix.org","id":"$QlVWlDsVk6gT25Fmq5piGGKrvT-9bGNarJKMVw7tqQM"}
]