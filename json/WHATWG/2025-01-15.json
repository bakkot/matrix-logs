[
{"content":{"body":"> <@kaiido:matrix.org> Noam Rosenthal: I'm quite confused by this message about `nextEvent`. If you init your event as `cancelable` then you can very well call `preventDefault()` on it, it even sets the return value of `dispatchEvent()`. Also I'm not sure how `stop[Immediate]Propagation` would be an issue for a `nextEvent()`, which I assume would be a kind of \"after non-capture\" phase, and would thus possibly only prevent other `nextEvent()` listeners. Or did you envision a second round of the whole dispatching with all 3 phases?  \n> The issue I see would actually be with the return value of `dispatchEvent()`, and maybe it's what you were hinting at? Dispatchers could wait for one more microtask before checking the event's `defaultPrevented` but that seems indeed problematic that listeners don't know if the dispatcher will receive the info in time.\n\nI haven't thought of all the details here, just that something that turns \"once\" events into promises could be useful in some scenarios ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!AGetWbsMpFPdSgUrbs%3Amatrix.org/%24tIgFrP08TU0QmbGQnPGtFFfguBjuDZcofy0PvgbRK6k\">In reply to</a> <a href=\"https://matrix.to/#/@kaiido:matrix.org\">@kaiido:matrix.org</a><br><a href=\"https://matrix.to/#/@noamr:matrix.org\">Noam Rosenthal</a>: I'm quite confused by this message about <code>nextEvent</code>. If you init your event as <code>cancelable</code> then you can very well call <code>preventDefault()</code> on it, it even sets the return value of <code>dispatchEvent()</code>. Also I'm not sure how <code>stop[Immediate]Propagation</code> would be an issue for a <code>nextEvent()</code>, which I assume would be a kind of \"after non-capture\" phase, and would thus possibly only prevent other <code>nextEvent()</code> listeners. Or did you envision a second round of the whole dispatching with all 3 phases?<br>\nThe issue I see would actually be with the return value of <code>dispatchEvent()</code>, and maybe it's what you were hinting at? Dispatchers could wait for one more microtask before checking the event's <code>defaultPrevented</code> but that seems indeed problematic that listeners don't know if the dispatcher will receive the info in time.</blockquote></mx-reply>I haven't thought of all the details here, just that something that turns &quot;once&quot; events into promises could be useful in some scenarios","m.relates_to":{"m.in_reply_to":{"event_id":"$tIgFrP08TU0QmbGQnPGtFFfguBjuDZcofy0PvgbRK6k"}},"msgtype":"m.text"},"ts":1736923572933,"senderName":"Noam Rosenthal","senderId":"@noamr:matrix.org","id":"$lE18ULFol5tLi5DK2fbizC4zgeVps1skMwKGThjgaMk"},
{"content":{"body":"Yes, I completely agree, but I didn't understand the concerns you expressed.","m.mentions":{},"msgtype":"m.text"},"ts":1736924353997,"senderName":"Kaiido","senderId":"@kaiido:matrix.org","id":"$n-GyvqWZNtpptcGHeFWSjXc-lVvSFrgv6Ur4Swjguvs"},
{"content":{"body":"Kaiido: I was referring to the fact that calling something like `const event = await nextEvent(\"my-event\"); event.stopPropagation()` wouldn't work because the event would already have been propagated at that point","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@kaiido:matrix.org\">Kaiido</a>: I was referring to the fact that calling something like <code>const event = await nextEvent(\"my-event\"); event.stopPropagation()</code> wouldn't work because the event would already have been propagated at that point","m.mentions":{"user_ids":["@kaiido:matrix.org"]},"msgtype":"m.text"},"ts":1736926848488,"senderName":"Noam Rosenthal","senderId":"@noamr:matrix.org","id":"$vfMYuusyVNmGWtumPwyw4YkqhVtmd8d6T_tOI21v3Zg"},
{"content":{"body":"Thinking that `nextEvent` could return something `PromiseLike` instead of a `Promise`, with both `then` and e.g. `preprocess`\nSo\n\nor something where the `then` is synchronous, e.g. `const event = await nextEvent(\"name\").then({ e => e.stopPropagation(); return e; });`, and `await nextEvent(\"name\")` would just work. Though we can probably come up with better ergonomics","format":"org.matrix.custom.html","formatted_body":"<p>Thinking that <code>nextEvent</code> could return something <code>PromiseLike</code> instead of a <code>Promise</code>, with both <code>then</code> and e.g. <code>preprocess</code><br>So</p>\n<p>or something where the <code>then</code> is synchronous, e.g. <code>const event = await nextEvent(\"name\").then({ e =&gt; e.stopPropagation(); return e; });</code>, and <code>await nextEvent(\"name\")</code> would just work. Though we can probably come up with better ergonomics</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1736927049877,"senderName":"Noam Rosenthal","senderId":"@noamr:matrix.org","id":"$BckwB0sBo3wDuBeg-A8jB5TrzbNUEj7Ma1IarkCd2N8"}
]