[
{"content":{"body":"sideshowbarker: there are some existing CSP + CSS issues, not sure if they cover this","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sideshowbarker:mozilla.org\">sideshowbarker</a>: there are some existing CSP + CSS issues, not sure if they cover this","msgtype":"m.text"},"ts":1641400846490,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$y0EVt52psVaPaVXaHqJGah7vFDR0Vnk_Frqrwg_8WdM"},
{"content":{"body":"Oh right, the spec even links https://github.com/w3c/webappsec-csp/issues/212","msgtype":"m.text"},"ts":1641400925697,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$ynbPGEycww7mQqAqMpuy6qnidXDXyfwQDCedI2z9kio"},
{"content":{"body":"annevk: thanks","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@annevk:mozilla.org\">annevk</a>: thanks","msgtype":"m.text"},"ts":1641409594650,"senderName":"sideshowbarker","senderId":"@sideshowbarker:mozilla.org","id":"$wW0wjZawwOknav7XB82OgKOF9t6sHfsnpcVWsDea1FA"},
{"content":{"body":"I've just learned that `postMessage` is async, such that if you do `worker.postMessage(); while (true) {}` the message will never actually fire. Is there a reason for this? If no, could it be changed, possibly as an opt-in option? This comes up in the context of emscripten.","format":"org.matrix.custom.html","formatted_body":"I've just learned that <code>postMessage</code> is async, such that if you do <code>worker.postMessage(); while (true) {}</code> the message will never actually fire. Is there a reason for this? If no, could it be changed, possibly as an opt-in option? This comes up in the context of emscripten.","msgtype":"m.text"},"ts":1641413042755,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Z4CitGYg9e2l0VjCa19xtx0Mq3JL-qoGS5JAo-epmQo"},
{"content":{"body":"I don't think that's true per the spec","msgtype":"m.text"},"ts":1641413369250,"senderName":"Andreu Botella (he/they)","senderId":"@andreubotella:mozilla.org","id":"$E-faZ9coToQ0FxRakBlxRZ8C2dl7AJCyyt0FxbyOId8"},
{"content":{"body":"https://html.spec.whatwg.org/multipage/workers.html#dom-worker-postmessage","msgtype":"m.text"},"ts":1641413370043,"senderName":"Andreu Botella (he/they)","senderId":"@andreubotella:mozilla.org","id":"$9f4CLnwu6q7wFfPxVS9VDWPoXncyZ-QIKfhGv57NMEo"},
{"content":{"body":"The only task or microtask queued in that algorithm is the one that is actually queued on the worker's event loop","msgtype":"m.text"},"ts":1641413425841,"senderName":"Andreu Botella (he/they)","senderId":"@andreubotella:mozilla.org","id":"$cHgt-q2uMa3AhyLGUaxmWEHyi6ZpNnZ4rHvKRU6Z154"},
{"content":{"body":"But I guess it comes down to the notion of observability, since you can't observe the result of a task in a worker thread if the main thread is stuck in a loop","msgtype":"m.text"},"ts":1641413534827,"senderName":"Andreu Botella (he/they)","senderId":"@andreubotella:mozilla.org","id":"$lak9U3zu1nyGgSP79PFiW4xJ5WS-pAwJEozNYDK1LI0"},
{"content":{"body":"you can with a SAB","msgtype":"m.text"},"ts":1641413614204,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ZGUc3UqnV_FAkxy_rFeUPy-x11BADAAgmmLPPv1d8N0"},
{"content":{"body":"True. Then this is a bug","msgtype":"m.text"},"ts":1641413626792,"senderName":"Andreu Botella (he/they)","senderId":"@andreubotella:mozilla.org","id":"$tXFBDXPndAI_y9HfEU0C5yFObD5YZ5hgFdRnCMFNkng"},
{"content":{"body":"MDN has it documented:\n\n> After postMessage() is called, the MessageEvent will be dispatched only after all pending execution contexts have finished. For example, if postMessage() is invoked in an event handler, that event handler will run to completion, as will any remaining handlers for that same event, before the MessageEvent is dispatched.","format":"org.matrix.custom.html","formatted_body":"<p>MDN has it documented:</p>\n<blockquote>\n<p>After postMessage() is called, the MessageEvent will be dispatched only after all pending execution contexts have finished. For example, if postMessage() is invoked in an event handler, that event handler will run to completion, as will any remaining handlers for that same event, before the MessageEvent is dispatched.</p>\n</blockquote>\n","msgtype":"m.text"},"ts":1641414356599,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$9n8exPdC90xkOaj1RPUAxvupaJgdv2PRiROpw2nxU90"},
{"content":{"body":"I can't actually tell from reading the spec if the \"add a task\" implies adding it on the current thread or the worker's, but I'll take your word for it.","msgtype":"m.text"},"ts":1641414482789,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$vaT16Ev9844DKwnSt3Z7oBBfCpcp5wBN_hC1isvSTTc"},
{"content":{"body":"That task fires the `message` event, and event firing is synchronous, so it must be on the worker's thread","format":"org.matrix.custom.html","formatted_body":"That task fires the <code>message</code> event, and event firing is synchronous, so it must be on the worker's thread","msgtype":"m.text"},"ts":1641414632783,"senderName":"Andreu Botella (he/they)","senderId":"@andreubotella:mozilla.org","id":"$wJtD3OAmyeuUK2V3HWwnz5hqIiIRJJQtsj4rVHk1ALU"},
{"content":{"body":"I think this is related to https://github.com/whatwg/html/issues/3691 . Basically, postMessage() infrastructure assumes the target could be cross-process. Although this is not true for dedicated workers it could be for iframes or shared/service workers. The spec as-written doesn't really acknowledge this so it acts as if you can get synchronous access to the target's message queue. But, in general, you cannot; if your process is busy-looping you're gonna have a hard time pushing messages across process boundaries, I believe.","msgtype":"m.text"},"ts":1641415653759,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$JLuBRaPBUVmcSQBUJBB_P8GP02IuR380zVgVgk0NYBM"},
{"content":{"body":"So in theory implementations could maybe special-case dedicatedWorker.postMessage() to make that work even in the presence of busy loops. In practice that'd probably be quite involved as they'd essentially have to create a parallel message-queuing infrastructure for dedicated workers only.","msgtype":"m.text"},"ts":1641415701468,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$LZqvcUD62uWM1j7EaycDANzajCghy82tXdKvTdV8Jlc"},
{"content":{"body":"huh, ok, it looks like I was actually wrong (I wrote a test case but it was bugged) and the MDN page is are also wrong","msgtype":"m.text"},"ts":1641416046434,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$QlfI3-ixrVRWkUl4iWuxekaqOmPERWnt44oPThHdxos"},
{"content":{"body":"here's my test case (now that I've fixed it)\n\n```\nlet workerSrc = `\nlet arr;\nself.addEventListener('message', e => {\n  switch (e.data.message) {\n    case 'init': {\n      console.log('worker: got init');\n      arr = new Int32Array(e.data.buf);\n      Atomics.notify(arr, 0);\n      break;\n    }\n    case 'next': {\n      console.log('worker: got next');\n      arr[1] = 1;\n      break;\n    }\n  }\n});\n`;\nlet blob = new Blob([workerSrc], {type: 'application/javascript'});\nlet worker = new Worker(URL.createObjectURL(blob));\n\n(async () => {\n  let buf = new SharedArrayBuffer(16);\n  let arr = new Int32Array(buf);\n  worker.postMessage({ message: 'init', buf });\n\n  if (typeof Atomics.waitAsync === 'function') {\n    await Atomics.waitAsync(arr, 0, 0).value;\n  } else {\n    // give the worker time to start\n    await new Promise(res => setTimeout(res, 1000));\n  }\n\n  console.log('init');\n  worker.postMessage({ message: 'next' });\n\n  console.log('now we busy-wait, with arr[1] initially =', arr[1]);\n  for (let i = 0; i < 1e8; ++i) {\n    if (arr[1] === 1) {\n      console.log('done! took until i =', i);\n      return;\n    }\n  }\n  console.log('never initialized');\n})().catch(e => console.error('error', e));\n```","format":"org.matrix.custom.html","formatted_body":"<p>here's my test case (now that I've fixed it)</p>\n<pre><code>let workerSrc = `\nlet arr;\nself.addEventListener('message', e =&gt; {\n  switch (e.data.message) {\n    case 'init': {\n      console.log('worker: got init');\n      arr = new Int32Array(e.data.buf);\n      Atomics.notify(arr, 0);\n      break;\n    }\n    case 'next': {\n      console.log('worker: got next');\n      arr[1] = 1;\n      break;\n    }\n  }\n});\n`;\nlet blob = new Blob([workerSrc], {type: 'application/javascript'});\nlet worker = new Worker(URL.createObjectURL(blob));\n\n(async () =&gt; {\n  let buf = new SharedArrayBuffer(16);\n  let arr = new Int32Array(buf);\n  worker.postMessage({ message: 'init', buf });\n\n  if (typeof Atomics.waitAsync === 'function') {\n    await Atomics.waitAsync(arr, 0, 0).value;\n  } else {\n    // give the worker time to start\n    await new Promise(res =&gt; setTimeout(res, 1000));\n  }\n\n  console.log('init');\n  worker.postMessage({ message: 'next' });\n\n  console.log('now we busy-wait, with arr[1] initially =', arr[1]);\n  for (let i = 0; i &lt; 1e8; ++i) {\n    if (arr[1] === 1) {\n      console.log('done! took until i =', i);\n      return;\n    }\n  }\n  console.log('never initialized');\n})().catch(e =&gt; console.error('error', e));\n</code></pre>\n","msgtype":"m.text"},"ts":1641416061188,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$v7EgkYDFENjdU8caBxSpVwn_r2IX74bjo1T9Xjje-NE"},
{"content":{"body":"in chrome and FF this does actually finish; FF seems to take literally no iterations of the loop, where chrome takes a couple hundred","msgtype":"m.text"},"ts":1641416087964,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$CdkXNaKHJgIECBDe8VsxXW8k7GsigfNkz8cnKUKiAek"},
{"content":{"body":"apologies for the confusion","msgtype":"m.text"},"ts":1641416096127,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Lr8Ehrl7RgqIhGFvN_sCjajD1omoycb_LcAZLJpvlCE"},
{"content":{"body":" * huh, ok, it looks like I was actually wrong (I wrote a test case but it was bugged) and the MDN page is also wrong","m.new_content":{"body":"huh, ok, it looks like I was actually wrong (I wrote a test case but it was bugged) and the MDN page is also wrong","msgtype":"m.text"},"m.relates_to":{"event_id":"$QlfI3-ixrVRWkUl4iWuxekaqOmPERWnt44oPThHdxos","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641416242464,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$dYKUHr1wJsQ5Puig8ViCWylwMEc7JnCDzP7bdttMRpQ"},
{"content":{"body":"Hi, could someone explain main what is the purpose of this line? https://github.com/html5lib/html5lib-python/blob/master/html5lib/_inputstream.py#L141","msgtype":"m.text"},"ts":1641418729121,"senderName":"aliray","senderId":"@aliray:matrix.org","id":"$nnzDUDoh0MrEHzgWVD6C6kJL2XTvtXnEQtNcH8vPyo8"}
]