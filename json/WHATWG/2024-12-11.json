[
{"content":{"body":"annevk: https://github.com/whatwg/html/pull/9546/files#r1879416670","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@annevk:matrix.org\">annevk</a>: https://github.com/whatwg/html/pull/9546/files#r1879416670","m.mentions":{"user_ids":["@annevk:matrix.org"]},"msgtype":"m.text"},"ts":1733898297349,"senderName":"sideshowbarker","senderId":"@sideshowbarker:matrix.org","id":"$73nzpisaCnVIptCvT-gXr6qJmAIOPLdO2QHWfLqbUhk"},
{"content":{"body":"Dominic Farolino: there's also pre-removing steps. Should that be pre-remove steps then?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@domfarolino:matrix.org\">Dominic Farolino</a>: there's also pre-removing steps. Should that be pre-remove steps then?","m.mentions":{"user_ids":["@domfarolino:matrix.org"]},"msgtype":"m.text"},"ts":1733903758963,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$NPmkkq8cOYcBYgwrXZOvMd2T6emIYKFEYeknFq1Ma84"},
{"content":{"body":"sideshowbarker: there's an open issue on standardizing [Reflect] and I think we're pretty close after the refactoring I did on reflection a while back, but not quite there yet","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sideshowbarker:matrix.org\">sideshowbarker</a>: there's an open issue on standardizing [Reflect] and I think we're pretty close after the refactoring I did on reflection a while back, but not quite there yet","m.mentions":{"user_ids":["@sideshowbarker:matrix.org"]},"msgtype":"m.text"},"ts":1733903836449,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$_UCa7luBk56SQ7-yzdGCRtehL-hGvEIvkbKqSDXi0B0"},
{"content":{"body":"annevk Domenic: Atomics & SAB let you 'sleep' workers waiting _something_, but that requires an isolated origin, and it's not trivial to pack data into an SAB. Could message ports have a `postMessage` type thing that synchronously waits for a response from the other side? Like atomics, the sleeping side must be a worker.\n\nAPI sketch:\n\nIn a worker:\n\n```js\nconsole.log(\n  self.postSyncCall({ action: 'sum', numbers: [2, 2] })\n);\n```\n\nIn a page:\n\n```js\nworker.addEventListener('synccall', (event) => {\n  if (event.data.action === 'sum') {\n    event.respondWith(async () => {\n      const result = await someAsyncMathsSupercomputer.sum(event.data.numbers);\n      return result;\n    });\n  }\n});\n```\n\nIs this is stupid idea?","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@annevk:matrix.org\">annevk</a> <a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: Atomics &amp; SAB let you 'sleep' workers waiting <em>something</em>, but that requires an isolated origin, and it's not trivial to pack data into an SAB. Could message ports have a <code>postMessage</code> type thing that synchronously waits for a response from the other side? Like atomics, the sleeping side must be a worker.</p>\n<p>API sketch:</p>\n<p>In a worker:</p>\n<pre><code class=\"language-js\">console.log(\n  self.postSyncCall({ action: 'sum', numbers: [2, 2] })\n);\n</code></pre>\n<p>In a page:</p>\n<pre><code class=\"language-js\">worker.addEventListener('synccall', (event) =&gt; {\n  if (event.data.action === 'sum') {\n    event.respondWith(async () =&gt; {\n      const result = await someAsyncMathsSupercomputer.sum(event.data.numbers);\n      return result;\n    });\n  }\n});\n</code></pre>\n<p>Is this is stupid idea?</p>\n","m.mentions":{"user_ids":["@annevk:matrix.org","@domenicdenicola:matrix.org"]},"msgtype":"m.text"},"ts":1733911688811,"senderName":"Jake Archibald","senderId":"@jakea:matrix.org","id":"$fVK7KQiD-OkBS2FN9873C-3mG5Syvij6BM1ZN1K2Zdw"},
{"content":{"body":"Our usecase is a DOM polyfill in a worker, and in some cases we want getters to get their result from some other thread","m.mentions":{},"msgtype":"m.text"},"ts":1733911730004,"senderName":"Jake Archibald","senderId":"@jakea:matrix.org","id":"$toPJu4Xrye1Xp4YRT82FIPQRmAv4fTDwA7Ssdc58EEs"}
]