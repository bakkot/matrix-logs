[
{"content":{"body":"> <@usharma:igalia.com> just because the arcs are more or less shaped into a cone I think it's easier to see that it's a signal\n\nYe, actual radio signals are shaped like a rope with adhd","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!JoBeERPRsfNmTzghhy:matrix.org/$Z84puPcLM0w-T0s3aNriiAUHD3zquMD879lRGR7Oc3s?via=matrix.org&via=serenityos.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@usharma:igalia.com\">@usharma:igalia.com</a><br />just because the arcs are more or less shaped into a cone I think it's easier to see that it's a signal</blockquote></mx-reply>Ye, actual radio signals are shaped like a rope with adhd","m.relates_to":{"m.in_reply_to":{"event_id":"$Z84puPcLM0w-T0s3aNriiAUHD3zquMD879lRGR7Oc3s"}},"msgtype":"m.text"},"ts":1713226866304,"senderName":"nullvoxpopuli","senderId":"@nullvoxpopuli:matrix.org","id":"$ScDr81tpObNRtvvkAhMXvdj6RnCJ_i9WbcoGdoweuQA"},
{"content":{"body":"Hello ðŸ‘‹ Just stumbled upon [this issue](https://github.com/tc39/proposal-signals/issues/96) and thought about reaching out. For VS Code, we have an internal [implementation of observables](https://github.com/microsoft/vscode/blob/5ccc2db0a2ed24e8c0dc3ecd7d515e4f76c87e69/src/vs/base/common/observableInternal/base.ts#L22-L88). You can find some demo usage ([here](https://github.com/microsoft/vscode/blob/5ccc2db0a2ed24e8c0dc3ecd7d515e4f76c87e69/src/vs/base/test/common/observable.test.ts#L18)).\nWhile our implementation/API is heavily inspired by MobX, it tries to include some of our learnings of using MobX in other projects, mostly by making many things less magic and more debuggable. Since most of VS Code uses plain simple fields and change-events, we wanted to make it very clear what is observable and what not and when a derived/autorun subscribes to something observable. Observable usage is not yet very widespread in the VS Code source and it is mostly driven by me, but it is already used in core components, such as some editor contributions and the diff editor and so far the very explicit API style paid off.\n\nHowever, I also understand the advantages of transparent observables as presented by this proposal and don't necessarily see a need of this proposal to support use-cases such as ours, where we wanted a more explicit API. There are some things though where we also could use some browser support, mostly around inferring the name of an observable from its variable name/field.","format":"org.matrix.custom.html","formatted_body":"<p>Hello ðŸ‘‹ Just stumbled upon <a href=\"https://github.com/tc39/proposal-signals/issues/96\">this issue</a> and thought about reaching out. For VS Code, we have an internal <a href=\"https://github.com/microsoft/vscode/blob/5ccc2db0a2ed24e8c0dc3ecd7d515e4f76c87e69/src/vs/base/common/observableInternal/base.ts#L22-L88\">implementation of observables</a>. You can find some demo usage (<a href=\"https://github.com/microsoft/vscode/blob/5ccc2db0a2ed24e8c0dc3ecd7d515e4f76c87e69/src/vs/base/test/common/observable.test.ts#L18\">here</a>).<br>While our implementation/API is heavily inspired by MobX, it tries to include some of our learnings of using MobX in other projects, mostly by making many things less magic and more debuggable. Since most of VS Code uses plain simple fields and change-events, we wanted to make it very clear what is observable and what not and when a derived/autorun subscribes to something observable. Observable usage is not yet very widespread in the VS Code source and it is mostly driven by me, but it is already used in core components, such as some editor contributions and the diff editor and so far the very explicit API style paid off.</p>\n<p>However, I also understand the advantages of transparent observables as presented by this proposal and don't necessarily see a need of this proposal to support use-cases such as ours, where we wanted a more explicit API. There are some things though where we also could use some browser support, mostly around inferring the name of an observable from its variable name/field.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1713264495500,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns"},
{"content":{"body":"Something novel (to my knowledge) of our observable implementation is the concept of delta information, which can be used to inform observers how or why a value changed. We call observables that don't have a state and just delta information a \"signal\", which, alone, basically just represents an event with event args. However, observables and signals can be updated/triggered in the same transaction and also be handled at once in the same derived/autorun, which enables some new use cases of observables. This is quite useful when it matters how a certain state was reached, and not just what the state is.","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713266853558,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$GkjyPft4dzF7AKph_M5VsoZSEgSOXqdcbinGxVtRPs0"},
{"content":{"body":"* Something novel (to my knowledge) of our observable implementation is the concept of delta information, which can be used to inform observers how or why a value changed. We call observables that don't have a state and just delta information a \"signal\", which, alone, basically just represents an event with event args. However, observables and signals can be updated/triggered in the same transaction and also be handled at once in the same derived/autorun, which enables some new use cases of observables. This is quite useful when it matters how a certain state was reached, and not just what the state is. I think this \"signal\" part can be used to bring some rxjs ideas to observables. ","m.new_content":{"body":"Something novel (to my knowledge) of our observable implementation is the concept of delta information, which can be used to inform observers how or why a value changed. We call observables that don't have a state and just delta information a \"signal\", which, alone, basically just represents an event with event args. However, observables and signals can be updated/triggered in the same transaction and also be handled at once in the same derived/autorun, which enables some new use cases of observables. This is quite useful when it matters how a certain state was reached, and not just what the state is. I think this \"signal\" part can be used to bring some rxjs ideas to observables. ","msgtype":"m.text"},"m.relates_to":{"event_id":"$GkjyPft4dzF7AKph_M5VsoZSEgSOXqdcbinGxVtRPs0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1713267026199,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$2Y6GhRBwngqIIvNgz0txMmhcNVZ61bhQn0AO7pzeVNs"},
{"content":{"body":"ah, interesting! there seems to be a significant group of existing implementations that use \"reader capabilities\" of some sort. I'd been wondering if we should provide a facility to move between explicit and implicit readers, something like\n`trackImplicitly: <R>(read: Reader, f: () => R) => R`\n`trackExplicitly: <R>(f: (read: Reader) => R) => R`\nwith `get` taking an optional Reader.\n\n... though this does have the unfortunate implication that library code would end up encouraged to use the explicit plumbing version universally (`undefined` plumbs through just fine if the caller wants to be implicit). might be too much bifurcation, and we didn't have many examples/participants using it at scale, which is why we left it out of this first iteration.\n\nare you using the readers for async tracking/lexical capture of the tracking environment, or just for the sake of explicitness?","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$2Y6GhRBwngqIIvNgz0txMmhcNVZ61bhQn0AO7pzeVNs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713275958891,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$eJk5gs9hV7qTyjA_ulltPT_9bQcfwI0WiSG5s5Kw0OM"},
{"content":{"body":">  though this does have the unfortunate implication that library code would end up encouraged to use the explicit plumbing version universally\n\nI agree that mixing explicit and implicit implementations might be tricky and potentially confusing.\n\n> are you using the readers for async tracking/lexical capture of the tracking environment, or just for the sake of explicitness?\n\nFor now, just for the sake of explicitness, as we didn't need tracking after an await yet.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>though this does have the unfortunate implication that library code would end up encouraged to use the explicit plumbing version universally</p>\n</blockquote>\n<p>I agree that mixing explicit and implicit implementations might be tricky and potentially confusing.</p>\n<blockquote>\n<p>are you using the readers for async tracking/lexical capture of the tracking environment, or just for the sake of explicitness?</p>\n</blockquote>\n<p>For now, just for the sake of explicitness, as we didn't need tracking after an await yet.</p>\n","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$eJk5gs9hV7qTyjA_ulltPT_9bQcfwI0WiSG5s5Kw0OM"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713276669646,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$Td35Sbu3G5Qj-J9LI2_ApDcmplaFNHnVlux00VwrIGI"},
{"content":{"body":"> <@hediet:matrix.org> Something novel (to my knowledge) of our observable implementation is the concept of delta information, which can be used to inform observers how or why a value changed. We call observables that don't have a state and just delta information a \"signal\", which, alone, basically just represents an event with event args. However, observables and signals can be updated/triggered in the same transaction and also be handled at once in the same derived/autorun, which enables some new use cases of observables. This is quite useful when it matters how a certain state was reached, and not just what the state is. I think this \"signal\" part can be used to bring some rxjs ideas to observables. \n\nI've been looking into a couple of very different delta-based systems (https://signia.tldraw.dev/, and separately differential dataflow which if you squint is very related) and might have to go chew on yours for a bit to tell where it places","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!JoBeERPRsfNmTzghhy:matrix.org/$GkjyPft4dzF7AKph_M5VsoZSEgSOXqdcbinGxVtRPs0?via=matrix.org&via=serenityos.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@hediet:matrix.org\">@hediet:matrix.org</a><br />Something novel (to my knowledge) of our observable implementation is the concept of delta information, which can be used to inform observers how or why a value changed. We call observables that don't have a state and just delta information a &quot;signal&quot;, which, alone, basically just represents an event with event args. However, observables and signals can be updated/triggered in the same transaction and also be handled at once in the same derived/autorun, which enables some new use cases of observables. This is quite useful when it matters how a certain state was reached, and not just what the state is. I think this &quot;signal&quot; part can be used to bring some rxjs ideas to observables.</blockquote></mx-reply>I've been looking into a couple of very different delta-based systems (https://signia.tldraw.dev/, and separately differential dataflow which if you squint is very related) and might have to go chew on yours for a bit to tell where it places","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":false,"m.in_reply_to":{"event_id":"$GkjyPft4dzF7AKph_M5VsoZSEgSOXqdcbinGxVtRPs0"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713276731750,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$--N_xh1ECVnMOZMn0LOJYmqWVXQHtNjqsAOK8e-7UFg"},
{"content":{"body":"[Here is an example of how emitting and handling deltas works.](https://github.com/microsoft/vscode/blob/5ccc2db0a2ed24e8c0dc3ecd7d515e4f76c87e69/src/vs/base/test/common/observable.test.ts#L304-L345)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://github.com/microsoft/vscode/blob/5ccc2db0a2ed24e8c0dc3ecd7d515e4f76c87e69/src/vs/base/test/common/observable.test.ts#L304-L345\">Here is an example of how emitting and handling deltas works.</a>","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$--N_xh1ECVnMOZMn0LOJYmqWVXQHtNjqsAOK8e-7UFg"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713276899064,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$0WsTS82GYHCdlqe7q_4CuzBGLwLMr3Esxua-OEhCtRQ"},
{"content":{"body":"ah, are your deltas and deriveds both eager? signia's thing is making them lazy (so deltas are lossy -- if you don't read them they'll be discarded instead of piling up), so seems pretty different","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$0WsTS82GYHCdlqe7q_4CuzBGLwLMr3Esxua-OEhCtRQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277182667,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$3OD72IUOZESjZvgQZQI4TEWPNlEWK5t9m1FVS2u9sHM"},
{"content":{"body":"the deltas are not lazy per se, but of cause they could be backed by an lazy implementation","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$3OD72IUOZESjZvgQZQI4TEWPNlEWK5t9m1FVS2u9sHM"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277234597,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$eqypr_MvuQfNkQ_qwnDglg7M5H9l68VTzWHQlq5gvVw"},
{"content":{"body":"signias approach is also very interesting!","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$eqypr_MvuQfNkQ_qwnDglg7M5H9l68VTzWHQlq5gvVw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277254159,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$u-fipvus4PKt4w08Jn8mZwI1VXxczCGSBwN3Dsb3Slk"},
{"content":{"body":"the deriveds in our implementation are as lazy as possible","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$u-fipvus4PKt4w08Jn8mZwI1VXxczCGSBwN3Dsb3Slk"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277270566,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$uySNVLADCYG--WskMW46Jekku5F-M8vMLnZhSA7Wuts"},
{"content":{"body":" * the deriveds in our implementation are as lazy as possible, but at the moment they cannot produce deltas","format":"org.matrix.custom.html","formatted_body":" * the deriveds in our implementation are as lazy as possible, but at the moment they cannot produce deltas","m.mentions":{},"m.new_content":{"body":"the deriveds in our implementation are as lazy as possible, but at the moment they cannot produce deltas","format":"org.matrix.custom.html","formatted_body":"the deriveds in our implementation are as lazy as possible, but at the moment they cannot produce deltas","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$uySNVLADCYG--WskMW46Jekku5F-M8vMLnZhSA7Wuts","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1713277286742,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$ICy7SFNMoj8oJbgqVvATxFyEve23YujRm2YmF_OcTWc"},
{"content":{"body":"can they consume them?","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$ICy7SFNMoj8oJbgqVvATxFyEve23YujRm2YmF_OcTWc"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277333449,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$ByLPhnf8eNiMz0hJybawD8KDvLn4uhUxIZnuuOIa2qc"},
{"content":{"body":" * the deriveds in our implementation are as lazy as possible, but at the moment they cannot produce deltas (so currently only observable values and signals, i.e. atoms, can produce deltas, which can be handled in deriveds or autoruns, but there is no derived implementation that can produce them yet)","format":"org.matrix.custom.html","formatted_body":" * the deriveds in our implementation are as lazy as possible, but at the moment they cannot produce deltas (so currently only observable values and signals, i.e. atoms, can produce deltas, which can be handled in deriveds or autoruns, but there is no derived implementation that can produce them yet)","m.mentions":{},"m.new_content":{"body":"the deriveds in our implementation are as lazy as possible, but at the moment they cannot produce deltas (so currently only observable values and signals, i.e. atoms, can produce deltas, which can be handled in deriveds or autoruns, but there is no derived implementation that can produce them yet)","format":"org.matrix.custom.html","formatted_body":"the deriveds in our implementation are as lazy as possible, but at the moment they cannot produce deltas (so currently only observable values and signals, i.e. atoms, can produce deltas, which can be handled in deriveds or autoruns, but there is no derived implementation that can produce them yet)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$uySNVLADCYG--WskMW46Jekku5F-M8vMLnZhSA7Wuts","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1713277346022,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$cs3s-suS5OayNo5trKpIJiqfC4oKM7LhIEUVKWMpF34"},
{"content":{"body":"yes, they can consume them - the derived example would be analog to the autorun one","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$ByLPhnf8eNiMz0hJybawD8KDvLn4uhUxIZnuuOIa2qc"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277360848,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$V384VbduPR535QQWptXRPt_aYZwIVh40XyOmbF2Aw5E"},
{"content":{"body":"deltas can be consumed lazily or eagerly, that depends on the implementation (see autorunHandleChanges, the user can either push all the deltas into an array or combine them using a different method).","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$V384VbduPR535QQWptXRPt_aYZwIVh40XyOmbF2Aw5E"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277423740,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$vUnGO5giq29qS_MmX2ib8CZC6gJJRpxEcv4M27fa9Yw"},
{"content":{"body":"ahh, so the consumer sort of \"receives them\" eagerly but separately from their reactive body rerunning, so they get to choose whether to buffer or process the information online?","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$vUnGO5giq29qS_MmX2ib8CZC6gJJRpxEcv4M27fa9Yw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277500077,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$PssOaJRlqiDNEWuGHg09OTJNFas7BegODhZPH9puUhc"},
{"content":{"body":"exactly. They are also not allowed to call into other code when they receive them","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$PssOaJRlqiDNEWuGHg09OTJNFas7BegODhZPH9puUhc"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277572741,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$0F7QElpVBq_dTvvQqcqcBAimLBONlzLW_Kyk0PkASb4"},
{"content":{"body":" * exactly. They are also not allowed to call into other code when they receive them, because other observables might not have received the event at this point yet","format":"org.matrix.custom.html","formatted_body":" * exactly. They are also not allowed to call into other code when they receive them, because other observables might not have received the event at this point yet","m.mentions":{"user_ids":["@shaylew:matrix.org"]},"m.new_content":{"body":"exactly. They are also not allowed to call into other code when they receive them, because other observables might not have received the event at this point yet","format":"org.matrix.custom.html","formatted_body":"exactly. They are also not allowed to call into other code when they receive them, because other observables might not have received the event at this point yet","m.mentions":{"user_ids":["@shaylew:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$0F7QElpVBq_dTvvQqcqcBAimLBONlzLW_Kyk0PkASb4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1713277594777,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$de9XDxR9mfJbeJrgsv-nCDcYlms_nCqJN48FnEbOL6w"},
{"content":{"body":" * exactly. They are also not allowed to call into other code when they receive the deltas, because other observables might not have received the event at this point yet","format":"org.matrix.custom.html","formatted_body":" * exactly. They are also not allowed to call into other code when they receive the deltas, because other observables might not have received the event at this point yet","m.mentions":{},"m.new_content":{"body":"exactly. They are also not allowed to call into other code when they receive the deltas, because other observables might not have received the event at this point yet","format":"org.matrix.custom.html","formatted_body":"exactly. They are also not allowed to call into other code when they receive the deltas, because other observables might not have received the event at this point yet","m.mentions":{"user_ids":["@shaylew:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$0F7QElpVBq_dTvvQqcqcBAimLBONlzLW_Kyk0PkASb4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1713277602701,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$UhOmEc8WWfzkRgK2bha7RUp189YfWCH7JSzBlb6nVYg"},
{"content":{"body":"\"delta stuff\" in some sense or another seems necessary to get an efficient way to (eg) \"count how many of these input signals are `true`\", so I'm definitely interested in figuring out what minimal-but-sufficient support they'd need from the implementation","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$UhOmEc8WWfzkRgK2bha7RUp189YfWCH7JSzBlb6nVYg"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277675764,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$hjx8HUirgNsyQTB4fLzgNiAKW8jvUJlRjrxEpoUJ0po"},
{"content":{"body":"(ideally minimal, sufficient, and not too opinionated -- not guaranteed to be a bar that's clearable...)","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$hjx8HUirgNsyQTB4fLzgNiAKW8jvUJlRjrxEpoUJ0po"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277699544,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$IjxGgkSscxSnFKFz2NfU_s1XXwTa0OSmu0OpKEIh7vw"},
{"content":{"body":"[Here is a production example](https://github.com/microsoft/vscode/blob/0a141d23179c76c5771df25a43546d9d9b6ed71c/src/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.ts#L93) (and yes, this derived has some \"ugly\" side effects and is basically an autorun, but that way callers can wait on the fetch promise)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://github.com/microsoft/vscode/blob/0a141d23179c76c5771df25a43546d9d9b6ed71c/src/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.ts#L93\">Here is a production example</a> (and yes, this derived has some \"ugly\" side effects and is basically an autorun, but that way callers can wait on the fetch promise)","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$IjxGgkSscxSnFKFz2NfU_s1XXwTa0OSmu0OpKEIh7vw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277730400,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$-DXUQ5B4RaMAuo5C0wjCTPoVgTOCajcABbnBvH5Yrbs"},
{"content":{"body":"do you guarantee some particular order in the changes each thing gets to fold over?","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$-DXUQ5B4RaMAuo5C0wjCTPoVgTOCajcABbnBvH5Yrbs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713277953088,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$BH-L89HAVsj9Wi-XxQisKY64DufsXNbZmoonq__1Dsg"},
{"content":{"body":"(I'm squinting at this (on a phone) and realizing it could be cousin to Jane Street `incremental`'s `unorderedFold` nodes)","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$BH-L89HAVsj9Wi-XxQisKY64DufsXNbZmoonq__1Dsg"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713278025475,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$32zN4SvC1Unyxuwo_-9U6SkpmLte2ke4eM9BSznTmAI"},
{"content":{"body":"what do you mean with \"gets to fold over\"? The only guarantee is that an observer receives all deltas from an observable in the same order.\nHowever, if an observable has multiple observers, it is not specified which observer gets the change first. But this does not matter, because the observer is not allowed to interact with other observers at this point.","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$32zN4SvC1Unyxuwo_-9U6SkpmLte2ke4eM9BSznTmAI"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713278132410,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$a2WH6igaHAI0gAvSHFkWm6BnkmP0Zo18oQ2H0OQNxjo"},
{"content":{"body":"btw, a `countTrues(o: IObservable<boolean>[]): IObservable<number>` can also be efficiently implemented using an `autorun` for each item in `o`. However, transactions cannot see through such side-effect autoruns anymore","format":"org.matrix.custom.html","formatted_body":"btw, a <code>countTrues(o: IObservable&lt;boolean&gt;[]): IObservable&lt;number&gt;</code> can also be efficiently implemented using an <code>autorun</code> for each item in <code>o</code>. However, transactions cannot see through such side-effect autoruns anymore","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$a2WH6igaHAI0gAvSHFkWm6BnkmP0Zo18oQ2H0OQNxjo"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713278211564,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$totJ8z6kx-ssflmRQYjytG7kl7wlNyzR2o0zbLZCMoI"},
{"content":{"body":"the view from a single observer that observes multiple observables, I meant -- maybe fold isn't the intended way to think about it, I just saw an \"initial summary\" and a \"summarize previous summary + incoming context into new summary\" and jumped to the \"ah, folding over a stream\" framing","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$totJ8z6kx-ssflmRQYjytG7kl7wlNyzR2o0zbLZCMoI"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713278384679,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$AdPAf7doij6APJZdYRu38-StGH0zyA-Bey7Dn3XrAQA"},
{"content":{"body":"> <@hediet:matrix.org> btw, a `countTrues(o: IObservable<boolean>[]): IObservable<number>` can also be efficiently implemented using an `autorun` for each item in `o`. However, transactions cannot see through such side-effect autoruns anymore\n\n... however that might be circumvented by having a derived for each item in `o` that has a side effect which increments/decrements some shared count variable. Then you can create one derived that reads all these deriveds and returns the count field - I think this should give you an optimal solution without deltas.\n","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!JoBeERPRsfNmTzghhy:matrix.org/$totJ8z6kx-ssflmRQYjytG7kl7wlNyzR2o0zbLZCMoI?via=matrix.org&via=igalia.com&via=serenityos.org\">In reply to</a> <a href=\"https://matrix.to/#/@hediet:matrix.org\">@hediet:matrix.org</a><br>btw, a <code>countTrues(o: IObservable&lt;boolean&gt;[]): IObservable&lt;number&gt;</code> can also be efficiently implemented using an <code>autorun</code> for each item in <code>o</code>. However, transactions cannot see through such side-effect autoruns anymore</blockquote></mx-reply>... however that might be circumvented by having a derived for each item in <code>o</code> that has a side effect which increments/decrements some shared count variable. Then you can create one derived that reads all these deriveds and returns the count field - I think this should give you an optimal solution without deltas.","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":false,"m.in_reply_to":{"event_id":"$totJ8z6kx-ssflmRQYjytG7kl7wlNyzR2o0zbLZCMoI"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713278430213,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$vbc9r6L6LkcRZiDAEQvy1a1LiwYCglETkrtsS2jmVbs"},
{"content":{"body":"don't you lose if you ever have to rerun that one derived that reads all the others, or if you ever have to traverse each edge back towards the N deriveds it reads? but yeah that's sort of what you want -- you lose the topology/scheduling constraint if you just use an autorun, and the derived version tries to recover that","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$vbc9r6L6LkcRZiDAEQvy1a1LiwYCglETkrtsS2jmVbs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713278728349,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$gP3zOQSAmJ5dg33K6tOyHnL8BJL-opN9sUkk8D5peUI"},
{"content":{"body":"> don't you lose if you ever have to rerun that one derived that reads all the others\n\nRight, this would require a derived that does not need to resubscribe to all observables when it reruns.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>don't you lose if you ever have to rerun that one derived that reads all the others</p>\n</blockquote>\n<p>Right, this would require a derived that does not need to resubscribe to all observables when it reruns.</p>\n","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$gP3zOQSAmJ5dg33K6tOyHnL8BJL-opN9sUkk8D5peUI"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713279125398,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$xfv3-HlIxhPeKvHJLALW4P2X02Q3ycptn7NUQvJIyZY"},
{"content":{"body":"Btw. our implementation has a different problem (which I guess mobx also has):\nWhen a source observable is changed, where n deriveds depend on it transitively, then updating that source observable is O(n), even if the change stops after the first derived.","m.mentions":{},"m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$xfv3-HlIxhPeKvHJLALW4P2X02Q3ycptn7NUQvJIyZY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713279457574,"senderName":"Henning","senderId":"@hediet:matrix.org","id":"$12C3mFHjvTxrVY0SW-53-3-JO2RtZ7jtc-SI9mArP3E"},
{"content":{"body":"y eah that's a thing; it seems pretty inescapable in lazy-deriveds systems. even when you rerun the minimal set of deriveds, you sometimes do more traversal/bookkeeping than would be ideal","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$12C3mFHjvTxrVY0SW-53-3-JO2RtZ7jtc-SI9mArP3E"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713280284897,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$iQeu_emuDPHGVcnT7RLyvtvJraTm4vO2uyB2ful5E9A"},
{"content":{"body":"\"deep graph\" \"high fanout\" \"high fan-in\" are the stress tests... along with maybe \"toggling which nodes are observed\" for systems that have that concept","m.relates_to":{"event_id":"$g-jXdqlPbJpMJUG0SUTjfl4hA4wo57mk_e_88BXf6ns","is_falling_back":true,"m.in_reply_to":{"event_id":"$iQeu_emuDPHGVcnT7RLyvtvJraTm4vO2uyB2ful5E9A"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1713280372934,"senderName":"shaylew","senderId":"@shaylew:matrix.org","id":"$PLfNLAf9Fek8NDMt8w-yimRXb1NWUxUn8gO3_vihn5g"}
]