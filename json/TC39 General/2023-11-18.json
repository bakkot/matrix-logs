[
{"content":{"body":"Jack Works: When you introduce CoverXandY, you need to use it (instead of X or Y) in those contexts where the conflict/ambiguity exists. So if you're introducing CoverExpressionStatementAndWhatever, you'd have to change the Statement production to use that instead of ExpressionStatement. I think.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jackworks:matrix.org\">Jack Works</a>: When you introduce CoverXandY, you need to use it (instead of X or Y) in those contexts where the conflict/ambiguity exists. So if you're introducing CoverExpressionStatementAndWhatever, you'd have to change the Statement production to use that instead of ExpressionStatement. I think.","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"msgtype":"m.text"},"ts":1700326167205,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$zgmepQxSwlx1HVu09YgLPpCegUJ8aPdLAV2In5mfYo8"},
{"content":{"body":"Mind you, I'm not sure you should be covering ExpressionStatement.","m.mentions":{},"msgtype":"m.text"},"ts":1700326182047,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$lFj3XUNebHvCVMwUccxuRxaC7I_xDPc8EhgJ5sZEcdk"},
{"content":{"body":"Seems like the conflict is with a CallExpression, so you need to bolt something onto CoverCallExpressionAndAsyncArrowHead.","m.mentions":{},"msgtype":"m.text"},"ts":1700326313987,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$1D6ZBQ0cikIcJ4TlWy5KvM4Rfb9OzMbr9-smkv02VgA"},
{"content":{"body":"but when it goes into the CallExpression, it is already inside an ExpressionStatement. can I go back and choose a different production (MatchStatement)?","msgtype":"m.text"},"ts":1700326499205,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$y8iTqU4eYM9Z-u9z0AjmxcBSErpyHbT1kZlKEWXwOZk"},
{"content":{"body":"* but when it goes into the CallExpression, it is already chosen to use ExpressionStatement. can I go back and choose a different production (MatchStatement)?","m.new_content":{"body":"but when it goes into the CallExpression, it is already chosen to use ExpressionStatement. can I go back and choose a different production (MatchStatement)?","msgtype":"m.text"},"m.relates_to":{"event_id":"$y8iTqU4eYM9Z-u9z0AjmxcBSErpyHbT1kZlKEWXwOZk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1700326532399,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$4Mm3JjdZdI8lR8w5sjMmqf6K6yer2cvFvxyExmMWsTU"},
{"content":{"body":"Sorry, I didn't mean a conflict with the whole of CallExpression, but rather with the part of CallExpression that CoverCallExpressionEtc deals with.","m.mentions":{},"msgtype":"m.text"},"ts":1700326692124,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$RjMoKjIIhKHxhDXkwi-rsspk4W81VzUYcgDxLUTubkI"},
{"content":{"body":"wait, no, you asked a different question.","m.mentions":{},"msgtype":"m.text"},"ts":1700326734977,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$7Ezyu-jA4AtlPMucSfKA4KNZXKrvFRg2DSrOCoACRy0"},
{"content":{"body":"You should look at how CoverCallExpressionEtc is used in the grammar. There's a use from CallExpression and one from AsyncArrowFunction.","m.mentions":{},"msgtype":"m.text"},"ts":1700326862494,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$ZwzLxCA-FlZacVhUzihzBrpivJD5Twlu7KGkWLGzLpQ"},
{"content":{"body":"Here is the full problem:\nFor code: match (expr)\n\nif the following token is a {, then\n    if this is parsing a statement (like \"; match (expr) {\"), then continue with the Match Statement\n    otherwise continue with Match Expression (like \"f(match (expr) {\")\nif it's something else, continue with CallExpression","msgtype":"m.text"},"ts":1700326879698,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$9CqF7pQXJLW5PLBT6LY_CrJB0MTCFFOPf4SuGrNBMMA"},
{"content":{"body":"I cannot add lookahead != `match` to Expression Statement so it's also a syntax ambiguity between match expression and statement ","msgtype":"m.text"},"ts":1700327016458,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Jb5G4_2B7KhPkpfj-pNsj-EqtfdlQUvtcO26gOP969A"},
{"content":{"body":"Technically, I think it's a conflict, not an ambiguity. ","m.mentions":{},"msgtype":"m.text"},"ts":1700327093479,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$x_JuRpArfIve0u29-3_cRUwZemG4oPlCpuk8ph9L6t0"},
{"content":{"body":"In an ambiguity, there would be 2 different ways to parse a whole text.","m.mentions":{},"msgtype":"m.text"},"ts":1700327118175,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$YTpMzIQZ73kH0_r0O6-CQWVhoAv8lZSni7E5A-q6cuA"},
{"content":{"body":"oh that's correct ","msgtype":"m.text"},"ts":1700327145520,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$WvbKMbZyXrH8KVcjXomlazvisVWc5jnAlNcL8QbLrsU"},
{"content":{"body":"but it's true that you can't add [lookahead != 'match'] to ExprStmt","m.mentions":{},"msgtype":"m.text"},"ts":1700327214582,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$TOUUobznNfFC1bXVF9s8MPt0QrPiW4ijK82nCkPmCw8"},
{"content":{"body":"because there is a lookahead!=async function in ExprStmt so AsyncFnExpr won't conflict with AsyncFnDecl, in my case I cannot do this...","msgtype":"m.text"},"ts":1700327216312,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$D_W5WZr4aWky8xk44LuXwqsmBNDIUv46HEiVIQXCdDs"},
{"content":{"body":"hmm maybe I can use the syntax parameter to do it?","msgtype":"m.text"},"ts":1700327257351,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$4XizlNLpGarjezjp0MMHH_FHa4kkQMMNdFx7lhUOvmc"},
{"content":{"body":"ExprStmt uses ~MatchExpr, and all other references to Expr/AssignmentExpr uses +MatchExpr","msgtype":"m.text"},"ts":1700327293770,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$weB9f0-LG4M7-Jpy3xvJsgMV_Un9hpJkd355DJmUOnY"},
{"content":{"body":"then I can resolve the conflict between Match Stmt and Expr","msgtype":"m.text"},"ts":1700327321596,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$iqB8zCqph4OXcqeP-gepiaoMA1rWX0298XSMe5hBVDI"},
{"content":{"body":"but Stmt with Call is still a problem ","msgtype":"m.text"},"ts":1700327374026,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$lzlwfcGZpQbm76qR4h2gM89zyFSFKgaNoV6xkb1o5xM"},
{"content":{"body":"hm, you need both MatchStatement and MatchExpr?","m.mentions":{},"msgtype":"m.text"},"ts":1700327390410,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$TGPgUaq16w-5_kK5kQW3Te_i3TQjHRXJPhsQ8wpCeqM"},
{"content":{"body":"yes, at least I hope. Stmt version can contain statements, where the expression version don't.","msgtype":"m.text"},"ts":1700327431064,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$TEQLMnTqa4mwycX4S4F_RQC89cks3zESm5OiZvj4UiM"},
{"content":{"body":"if we have do expression, I can remove Stmt version ","msgtype":"m.text"},"ts":1700327447458,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Pyksg-W-80IWLGre9rSelqv4NagTMic4GZmnqIByE5c"},
{"content":{"body":"That complicates things, I think.","m.mentions":{},"msgtype":"m.text"},"ts":1700327499467,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$IkyQlCrTiDW9vr0QCpRIm22mSYeeR2q0P2-iaC3QgN4"},
{"content":{"body":"ðŸ¤”","msgtype":"m.text"},"ts":1700327593119,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$DJNhietmQWMXIh08Jp7gtGSAMvA_HqTYMnaAoaFjW5k"},
{"content":{"body":"Isn't there an actual ambiguity between MatchStmt and MatchExpr?","m.mentions":{},"msgtype":"m.text"},"ts":1700327759642,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$HCGNEZXamKnGviYSB1jI3I3HRjPrFbKRMFdq1RnXPTE"},
{"content":{"body":"hmm yes. ","msgtype":"m.text"},"ts":1700327803911,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$9apNzG6p85VuXEg1zj3CeeVX_pjRTBk6r0flhlpnhPA"},
{"content":{"body":"like if you wrote a MatchStmt but all its statements happened to be ExprStmts, wouldn't it also look like a MatchExpr?","m.mentions":{},"msgtype":"m.text"},"ts":1700327810409,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$bZKTAUGl9PqLrUNceKCmWtJ29la1b6UNsa83BtcUSec"},
{"content":{"body":"but Stmt can only appear at a Stmt position, is that really a problem?","msgtype":"m.text"},"ts":1700327831223,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$EF0csyVJ_H1hKlH3Hkdjm8p93AZP5C9nC90o0PuB4yk"},
{"content":{"body":"I think I'd have to look at the syntax for MatchStmt and MatchExpr","m.mentions":{},"msgtype":"m.text"},"ts":1700327896654,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$Us5QPiu89id3PCBqx3d8S1vtiR9PhgtRY1aY746msuE"},
{"content":{"body":"I hope I can prevent ExprStmt parse Expression that Expression is a sole match expr, so there is no ambiguity in that position ","msgtype":"m.text"},"ts":1700327909393,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$oUBjJBokezWG4942HzrQHDkUzZi1r21VGVd2OV7FzHY"},
{"content":{"body":"for this code:\nmatch (expr) { default: { x }}\n\nit's ambiguity, a block with ident ref \"x\" in Stmt version and an object literal in expr version ","msgtype":"m.text"},"ts":1700327971117,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$1uCeA7gyytOE5TDTRO3sh-3ovNCsRGc9QSj8QmmC7Jc"}
]