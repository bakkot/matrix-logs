[
{"content":{"body":"Was thinking more about async stuff. https://pastebin.com/mtMypZC9 I've never needed async getter/setters, but introducing a ~= operator could make the setter part feasible for equality and destructuring potentially.","msgtype":"m.text","org.matrix.msc1767.text":"Was thinking more about async stuff. https://pastebin.com/mtMypZC9 I've never needed async getter/setters, but introducing a ~= operator could make the setter part feasible for equality and destructuring potentially."},"ts":1674614343599,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$59nMJ3O1hTM_MX7FTVbC2lIhdVCaExbgTlll4XX0lp8"},
{"content":{"body":"bakkot: Is there an issue or chat for parallel async iterators?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: Is there an issue or chat for parallel async iterators?","msgtype":"m.text"},"ts":1674686251093,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$0YoULlFqeoWvqg7SG8rhaSX6-3elHkSdB0_uDirRhK4"},
{"content":{"body":"We've had similar discussion before: https://matrixlogs.bakkot.com/TC39_General/2022-04-19#L47-L71","msgtype":"m.text"},"ts":1674686686637,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Ym1WLDamC4p1dlLdKJZ55z91iNbe8kDaqdq-AueioqU"},
{"content":{"body":"I guess it'd be ok if the iterator allowed parallel computation, as long as it wasn't exposed to the consumer doing `for await (const item of it)`","format":"org.matrix.custom.html","formatted_body":"I guess it'd be ok if the iterator allowed parallel computation, as long as it wasn't exposed to the consumer doing <code>for await (const item of it)</code>","msgtype":"m.text"},"ts":1674686737878,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$_4Kl-dszq61wqFAFbGLbWImWojhk7TOnr8OHXUO3of8"},
{"content":{"body":"But, it's not really going to help much, because your \"parallel\" 2nd call is going to be gated on whether your source can be iterated in parallel","msgtype":"m.text"},"ts":1674686786791,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$-NK-mW5DKzM8RgttHWuHOrbvjOAPPHM15nVVvqjG_l8"},
{"content":{"body":"And if your source is a `async function* foo(){}`, the second `.next()` call won't do anything until the first `.next()` call has settled","format":"org.matrix.custom.html","formatted_body":"And if your source is a <code>async function* foo(){}</code>, the second <code>.next()</code> call won't do anything until the first <code>.next()</code> call has settled","msgtype":"m.text"},"ts":1674686820793,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$HsuVepGjibGypyZCu3zUEGxjyaPSUBGAZqGyEiv7vZk"},
{"content":{"body":" * But, it's not really going to help much, because your \"parallel\" 2nd call is going to be gated on whether your source can be iterated in parallel","m.new_content":{"body":"But, it's not really going to help much, because your \"parallel\" 2nd call is going to be gated on whether your source can be iterated in parallel","msgtype":"m.text"},"m.relates_to":{"event_id":"$-NK-mW5DKzM8RgttHWuHOrbvjOAPPHM15nVVvqjG_l8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674686855818,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$TVlL-hFhOhxGW6PQ55mgs0Q1hV_Vl1C1HqIn52V08V8"},
{"content":{"body":"So only sync iterable sources (and handwritten async iterable sources) would the `map` iterator to parallelize","format":"org.matrix.custom.html","formatted_body":"So only sync iterable sources (and handwritten async iterable sources) would the <code>map</code> iterator to parallelize","msgtype":"m.text"},"ts":1674686929319,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Gk0508jJOU8ESWfVBYBELkyfY_SrHXvVFf8xJKIjhqA"},
{"content":{"body":" * So only sync iterable sources (and handwritten async iterable sources) would get the `map` iterator to parallelize","format":"org.matrix.custom.html","formatted_body":" * So only sync iterable sources (and handwritten async iterable sources) would get the <code>map</code> iterator to parallelize","m.new_content":{"body":"So only sync iterable sources (and handwritten async iterable sources) would get the `map` iterator to parallelize","format":"org.matrix.custom.html","formatted_body":"So only sync iterable sources (and handwritten async iterable sources) would get the <code>map</code> iterator to parallelize","msgtype":"m.text"},"m.relates_to":{"event_id":"$Gk0508jJOU8ESWfVBYBELkyfY_SrHXvVFf8xJKIjhqA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674687512149,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$dg-1PEq7cPHPijHRZYHhZjH3bxlx7zz0lCdidlpOWM0"},
{"content":{"body":"Justin Ridgewell: no issue for it, this is very last-minute","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a>: no issue for it, this is very last-minute","msgtype":"m.text"},"ts":1674689890893,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$8yD3XeCCk4EurmLYXxa2usliva3dHZ0gMT12wCHzE6g"},
{"content":{"body":"but: it is true that you can't pump a generator multiple times; nevertheless the change I propose is enough to get parallelism in _iterator helpers_ ","format":"org.matrix.custom.html","formatted_body":"but: it is true that you can't pump a generator multiple times; nevertheless the change I propose is enough to get parallelism in <em>iterator helpers</em>","msgtype":"m.text"},"ts":1674689976826,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$RHH0uXO5wpfi8J42HDprsfIwxE6BoohIIIjew8lctcs"},
{"content":{"body":"i.e.: with the change I propose, if you have\n\n```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\nit.next()\n```\nthen the `sleep(1000)` will run in parallel to first call to `fetch`, and if the `sleep` finishes before that `fetch` does, then both `fetch`s can happen in parallel","format":"org.matrix.custom.html","formatted_body":"<p>i.e.: with the change I propose, if you have</p>\n<pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\nit.next()\n</code></pre>\n<p>then the <code>sleep(1000)</code> will run in parallel to first call to <code>fetch</code>, and if the <code>sleep</code> finishes before that <code>fetch</code> does, then both <code>fetch</code>s can happen in parallel</p>\n","msgtype":"m.text"},"ts":1674690117395,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$_7tJDKf8eIMLk0Rgda7rnWb8zmwpbwobpYvR2RBNlEo"},
{"content":{"body":"unless I'm missing something, anyway. so I do not agree with the \"only sync iterable sources (and handwritten async iterable sources) would get the `map` iterator to parallelize\" claim","format":"org.matrix.custom.html","formatted_body":"unless I'm missing something, anyway. so I do not agree with the &quot;only sync iterable sources (and handwritten async iterable sources) would get the <code>map</code> iterator to parallelize&quot; claim","msgtype":"m.text"},"ts":1674690184371,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ELdxBUzbxG6RB1_wLX9AiqxepPNPqQfFSvpVfnGw47A"}
]