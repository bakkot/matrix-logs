[
{"content":{"body":"When writing a lexer for ECMAScript how do you decide when to change between the goal symbols? https://tc39.es/ecma262/#sec-ecmascript-language-lexical-grammar I naively converted them to regex to toy with an idea. https://gist.github.com/sirisian/5c3402ca51a2440f0bc4e5d297269195 (Ignore any mistakes, I plan to redo it). Like I get that you'd start with InputElementHashbangOrRegExp https://regex101.com/r/YYgu1i/1 So the lexer would take tokens until it ran into a TemplateMiddle or TemplateTail. So in that example it takes the \"a\" then can't consume the \"}\". Where does one get the context, whether a RegularExpressionLiteral or TemplateMiddle/Tail is permitted? Is this based on the previous tokens? Do you have to like parse as you run the lexer so you'd potentially parse TemplateSpans -> TemplateMiddleList -> TemplateMiddle and this that would mean that's permitted. (And then you'd do the same to see if RegularExpressionLiteral is permitted)?","m.mentions":{},"msgtype":"m.text"},"ts":1717131222479,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$idvKGi0P3uJP-Ju8NWxNmEk7_CbTGNVsjkbg_1Yr5IY"},
{"content":{"body":"yes, you have to parse as you run the lexer","m.mentions":{},"msgtype":"m.text"},"ts":1717134560446,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$_oYMq-fBSqW1ZUxb_o7DEcej-AW9t8MBMS-FcGErsDM"},
{"content":{"body":"or at least, this is how everyone does it afaik","m.mentions":{},"msgtype":"m.text"},"ts":1717134571006,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$e8h7HpuraiNqOs6hvLU3IG3TTZYrSprtEjXw3uwqzH8"},
{"content":{"body":"that is what this sentence is getting at:\n\n> There are several situations where the identification of lexical input elements is sensitive to the syntactic grammar context that is consuming the input elements.","format":"org.matrix.custom.html","formatted_body":"<p>that is what this sentence is getting at:</p>\n<blockquote>\n<p>There are several situations where the identification of lexical input elements is sensitive to the syntactic grammar context that is consuming the input elements.</p>\n</blockquote>\n","m.mentions":{},"msgtype":"m.text"},"ts":1717134594918,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$huQdmWxroY3S246FJ7E2sxKZpQTotXW-WH0VGZLmGQ4"},
{"content":{"body":"i.e., you can't know how to tokenize (the lexical grammar) without knowing the context from the higher-level parse (the syntactic grammar)","m.mentions":{},"msgtype":"m.text"},"ts":1717134630798,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$q5-eOk66tIHws73iYpCBo8dnRYq_LTgq1vMtaKXFiC4"},
{"content":{"body":"my understanding is basically that you start with lexical goal symbol **|InputElementHashbangOrRegExp|** and syntactic goal symbol being either |Script| or |Module|. Production of an input element from application of that |InputElementHashbangOrRegExp| goal will then limit possibilities in the syntactic grammar to the point where the new lexical goal symbol is determined. For example: if the first input element is a |TemplateHead| ``` `prefix${ ``` then the syntactic grammar has committed to an |ExpressionStatement| and its contained |Expression| starts with a |SubstitutionTemplate| whose aforementioned |TemplateHead| must be followed by an |Expression|. |Expression| can expand to |RegularExpressionLiteral| but not to |TemplateMiddle|, so the new lexical goal symbol is **|InputElementRegExp|**. If that produces input element |StringLiteral| `\"foo\"`, then the syntactic grammar has committed the inner |Expression| to a |MemberExpression| starting with that literal as the |PrimaryExpression|, which can be followed by something that extends the |MemberExpression| (i.e., `[` or `.` for member access or ``` ` ``` for a tagged template or a noncommittal |WhiteSpace| or |LineTerminator| or |Comment|), or otherwise by something that extends a containing production (e.g., `(` for a call or `?.` for an optional chain or `/` for a division or `}` to continue the outer template). So that means the next input element can be a |TemplateMiddle| or |TemplateTail| but not a |RegularExpressionLiteral|, and the new lexical goal symbol is **|InputElementTemplateTail|**. Continue ad nauseam.","format":"org.matrix.custom.html","formatted_body":"my understanding is basically that you start with lexical goal symbol <strong>|InputElementHashbangOrRegExp|</strong> and syntactic goal symbol being either |Script| or |Module|. Production of an input element from application of that |InputElementHashbangOrRegExp| goal will then limit possibilities in the syntactic grammar to the point where the new lexical goal symbol is determined. For example: if the first input element is a |TemplateHead| <code>`prefix${</code> then the syntactic grammar has committed to an |ExpressionStatement| and its contained |Expression| starts with a |SubstitutionTemplate| whose aforementioned |TemplateHead| must be followed by an |Expression|. |Expression| can expand to |RegularExpressionLiteral| but not to |TemplateMiddle|, so the new lexical goal symbol is <strong>|InputElementRegExp|</strong>. If that produces input element |StringLiteral| <code>\"foo\"</code>, then the syntactic grammar has committed the inner |Expression| to a |MemberExpression| starting with that literal as the |PrimaryExpression|, which can be followed by something that extends the |MemberExpression| (i.e., <code>[</code> or <code>.</code> for member access or <code>`</code> for a tagged template or a noncommittal |WhiteSpace| or |LineTerminator| or |Comment|), or otherwise by something that extends a containing production (e.g., <code>(</code> for a call or <code>?.</code> for an optional chain or <code>/</code> for a division or <code>}</code> to continue the outer template). So that means the next input element can be a |TemplateMiddle| or |TemplateTail| but not a |RegularExpressionLiteral|, and the new lexical goal symbol is <strong>|InputElementTemplateTail|</strong>. Continue ad nauseam.","m.mentions":{},"msgtype":"m.text"},"ts":1717137056295,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$PKuAvrsFa7l80px3VyM0GOBT1KEdSljZv3A3J2SOTZE"},
{"content":{"body":"> <@bakkot:matrix.org> yeah, it's not the NaN per se (which does indeed get treated as 0). it's the fact that you have three elements `a`, `b`, `c` such that`a = b` and `b = c` but not `a = c` when `b` is the value without an index (because in that case the comparison function will return `NaN` when comparing `b` to either `a` or `c`). this makes it not a consistent comparator and the spec doesn't mandate any particular order here.\n\nTimo Tijhof: you can get consistent sorting like `newPages.sort( ( a, b ) => (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) )`, but I don't think there's any way to avoid some kind of surrogate value","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$KuT90PQaWgC31dqoXZQg18i6dalL5mDnq38-lUf95bY?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>yeah, it's not the NaN per se (which does indeed get treated as 0). it's the fact that you have three elements <code>a</code>, <code>b</code>, <code>c</code> such that<code>a = b</code> and <code>b = c</code> but not <code>a = c</code> when <code>b</code> is the value without an index (because in that case the comparison function will return <code>NaN</code> when comparing <code>b</code> to either <code>a</code> or <code>c</code>). this makes it not a consistent comparator and the spec doesn't mandate any particular order here.</blockquote></mx-reply><a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: you can get consistent sorting like <code>newPages.sort( ( a, b ) =&gt; (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) )</code>, but I don't think there's any way to avoid some kind of surrogate value","m.mentions":{"user_ids":["@bakkot:matrix.org","@timotijhof:matrix.org","@ljharb:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$KuT90PQaWgC31dqoXZQg18i6dalL5mDnq38-lUf95bY"}},"msgtype":"m.text"},"ts":1717138139326,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$oOM8aZZATkGRuYJ1QzLp2veLMwV3yXlD1275Z1d6nBs"},
{"content":{"body":"> <@bakkot:matrix.org> yeah, it's not the NaN per se (which does indeed get treated as 0). it's the fact that you have three elements `a`, `b`, `c` such that`a = b` and `b = c` but not `a = c` when `b` is the value without an index (because in that case the comparison function will return `NaN` when comparing `b` to either `a` or `c`). this makes it not a consistent comparator and the spec doesn't mandate any particular order here.\n\n * Timo Tijhof: you can get consistent sorting like `newPages.sort( ( a, b ) => (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) ) || 0`, but I don't think there's any way to avoid some kind of surrogate value","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$KuT90PQaWgC31dqoXZQg18i6dalL5mDnq38-lUf95bY?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>yeah, it's not the NaN per se (which does indeed get treated as 0). it's the fact that you have three elements <code>a</code>, <code>b</code>, <code>c</code> such that<code>a = b</code> and <code>b = c</code> but not <code>a = c</code> when <code>b</code> is the value without an index (because in that case the comparison function will return <code>NaN</code> when comparing <code>b</code> to either <code>a</code> or <code>c</code>). this makes it not a consistent comparator and the spec doesn't mandate any particular order here.</blockquote></mx-reply> * <a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: you can get consistent sorting like <code>newPages.sort( ( a, b ) =&gt; (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) ) || 0</code>, but I don't think there's any way to avoid some kind of surrogate value","m.mentions":{},"m.new_content":{"body":"Timo Tijhof: you can get consistent sorting like `newPages.sort( ( a, b ) => (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) ) || 0`, but I don't think there's any way to avoid some kind of surrogate value","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: you can get consistent sorting like <code>newPages.sort( ( a, b ) =&gt; (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) ) || 0</code>, but I don't think there's any way to avoid some kind of surrogate value","m.mentions":{"user_ids":["@bakkot:matrix.org","@timotijhof:matrix.org","@ljharb:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$oOM8aZZATkGRuYJ1QzLp2veLMwV3yXlD1275Z1d6nBs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717188553566,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$8Mp82fsklujVxB6uNnLVv5BT403i3d4c02Z4y7TSk8s"},
{"content":{"body":" * Timo Tijhof: you can get consistent sorting like `newPages.sort( ( a, b ) => (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) || 0 )`, but I don't think there's any way to avoid some kind of surrogate value","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: you can get consistent sorting like <code>newPages.sort( ( a, b ) =&gt; (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) || 0 )</code>, but I don't think there's any way to avoid some kind of surrogate value","m.mentions":{},"m.new_content":{"body":"Timo Tijhof: you can get consistent sorting like `newPages.sort( ( a, b ) => (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) || 0 )`, but I don't think there's any way to avoid some kind of surrogate value","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: you can get consistent sorting like <code>newPages.sort( ( a, b ) =&gt; (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) || 0 )</code>, but I don't think there's any way to avoid some kind of surrogate value","m.mentions":{"user_ids":["@bakkot:matrix.org","@timotijhof:matrix.org","@ljharb:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$oOM8aZZATkGRuYJ1QzLp2veLMwV3yXlD1275Z1d6nBs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717188574800,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$mG0T6br5fddDSVeCt-nnU4jUAauHp8IuE3X67MUm8B0"}
]