[
{"content":{"body":"Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","mimetype":"text/plain"},{"body":"<p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1650328565937,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$wVthMf4uW79m-AG1e5Epu0CNgtX3njecWFVQVAmo_cE"},
{"content":{"body":" * Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","m.new_content":{"body":"Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","mimetype":"text/plain"},{"body":"<p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$wVthMf4uW79m-AG1e5Epu0CNgtX3njecWFVQVAmo_cE","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","mimetype":"text/plain"},{"body":" * <p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nfunction* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1650328796191,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$CUqV141Mq69M62ffOEt8Ggj0iNABWnVxu16rO7Sn1Pk"},
{"content":{"body":" * Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nasync function* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nasync function* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","m.new_content":{"body":"Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nasync function* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nasync function* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nasync function* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","mimetype":"text/plain"},{"body":"<p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nasync function* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$wVthMf4uW79m-AG1e5Epu0CNgtX3njecWFVQVAmo_cE","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nasync function* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","mimetype":"text/plain"},{"body":" * <p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 500ms\nasync function* gen() {\n  yield* [[500, 500, 500, 'a'], [500, 500, 500, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1650328829323,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$D6FxPsW8WiFBFgquf9baWSs8OLtFZNRQLaR0uzWwoiE"},
{"content":{"body":" * Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 100ms\nasync function* gen() {\n  yield* [[100, 100, 100, 'a'], [100, 100, 100, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 100ms\nasync function* gen() {\n  yield* [[100, 100, 100, 'a'], [100, 100, 100, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","m.new_content":{"body":"Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 100ms\nasync function* gen() {\n  yield* [[100, 100, 100, 'a'], [100, 100, 100, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 100ms\nasync function* gen() {\n  yield* [[100, 100, 100, 'a'], [100, 100, 100, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 100ms\nasync function* gen() {\n  yield* [[100, 100, 100, 'a'], [100, 100, 100, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","mimetype":"text/plain"},{"body":"<p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 100ms\nasync function* gen() {\n  yield* [[100, 100, 100, 'a'], [100, 100, 100, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$wVthMf4uW79m-AG1e5Epu0CNgtX3njecWFVQVAmo_cE","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Here's an example:\n```\n// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 100ms\nasync function* gen() {\n  yield* [[100, 100, 100, 'a'], [100, 100, 100, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item => {\n\tawait new Promise(resolve => setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n```","mimetype":"text/plain"},{"body":" * <p>Here's an example:</p>\n<pre><code>// Each item has a few pipelined actions that take time indicated by the number. So the first item does 3 operations each taking 100ms\nasync function* gen() {\n  yield* [[100, 100, 100, 'a'], [100, 100, 100, 'b'], [10, 10, 10, 'c'], [10, 10, 10, 'd'], [10, 10, 10, 'e'], [10, 10, 10, 'f']];\n}\nfor await (const i of gen.map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n}).map(async item =&gt; {\n\tawait new Promise(resolve =&gt; setTimeout(resolve, item.shift()));\n  return item;\n})) {\n  // This will after summation of all the times in each array.\n  console.log(item.shift());\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1650329296683,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$xvOC4Sazwd5YcCufu61Reo7vxtZc6eMR_1TwVzIjTmc"},
{"content":{"body":"Handled in-order one must wait 300ms to see the first result. All the operations are handled sequentially taking a total 300 * 2 + 30 * 4 = 720ms. An out of order first come with a task limit of 5 for each step (assume these are network or single worker thread delays) would take 300ms. Even a task limit of 3 would take 300ms. in that example.","msgtype":"m.text","org.matrix.msc1767.text":"Handled in-order one must wait 300ms to see the first result. All the operations are handled sequentially taking a total 300 * 2 + 30 * 4 = 720ms. An out of order first come with a task limit of 5 for each step (assume these are network or single worker thread delays) would take 300ms. Even a task limit of 3 would take 300ms. in that example."},"ts":1650329507988,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$DrNcaxHVcnhSpTjcNUa3-Ryon2zmfrBqBZ5JBKKfOTQ"},
{"content":{"body":" * Handled in-order one must wait 300ms to see the first result. All the operations are handled sequentially taking a total 300 * 2 + 30 * 4 = 720ms. An out of order first come with a task limit of 5 for each step (assume these are network or single worker thread delays) would take 300ms. Even a task limit of 3 would take 300ms. in that example.","m.new_content":{"body":"Handled in-order one must wait 300ms to see the first result. All the operations are handled sequentially taking a total 300 * 2 + 30 * 4 = 720ms. An out of order first come with a task limit of 5 for each step (assume these are network or single worker thread delays) would take 300ms. Even a task limit of 3 would take 300ms. in that example.","msgtype":"m.text","org.matrix.msc1767.text":"Handled in-order one must wait 300ms to see the first result. All the operations are handled sequentially taking a total 300 * 2 + 30 * 4 = 720ms. An out of order first come with a task limit of 5 for each step (assume these are network or single worker thread delays) would take 300ms. Even a task limit of 3 would take 300ms. in that example."},"m.relates_to":{"event_id":"$DrNcaxHVcnhSpTjcNUa3-Ryon2zmfrBqBZ5JBKKfOTQ","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * Handled in-order one must wait 300ms to see the first result. All the operations are handled sequentially taking a total 300 * 2 + 30 * 4 = 720ms. An out of order first come with a task limit of 5 for each step (assume these are network or single worker thread delays) would take 300ms. Even a task limit of 3 would take 300ms. in that example."},"ts":1650329597476,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$Qv50709L6oNe_TDlppaAw9sPeOjiZKBtAmj4cTY3ul8"},
{"content":{"body":"sirisian: yeah it looks like you're trying to do things with sync iterables of promises, which isn't a concept the language ever really works with, right now. except in like `Promise.all` I guess.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: yeah it looks like you're trying to do things with sync iterables of promises, which isn't a concept the language ever really works with, right now. except in like <code>Promise.all</code> I guess.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"sirisian: yeah it looks like you're trying to do things with sync iterables of promises, which isn't a concept the language ever really works with, right now. except in like `Promise.all` I guess.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: yeah it looks like you're trying to do things with sync iterables of promises, which isn't a concept the language ever really works with, right now. except in like <code>Promise.all</code> I guess.","mimetype":"text/html"}]},"ts":1650334491935,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$E-Pv9SLXR1ssyyU5eEwUjdWIdWkea8Y6e1uVYNS6q9A"},
{"content":{"body":"bakkot: https://jsfiddle.net/9xsyev61/ This isn't cursed at all.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: https://jsfiddle.net/9xsyev61/ This isn't cursed at all.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: https://jsfiddle.net/9xsyev61/ This isn't cursed at all.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: https://jsfiddle.net/9xsyev61/ This isn't cursed at all.","mimetype":"text/html"}]},"ts":1650336326633,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$xqUsmfgNDDdtCDVLYDFfa9tvlVbU9Cv38kTdR50nFcU"},
{"content":{"body":"sirisian: lol","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: lol","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"sirisian: lol","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: lol","mimetype":"text/html"}]},"ts":1650336497398,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ytYpDr4Fp0PkecA-gIXTrdDle1sdG9Ms0T623VXyt8E"},
{"content":{"body":"looks like it dropped some though? I only see a single `1` in the console","format":"org.matrix.custom.html","formatted_body":"looks like it dropped some though? I only see a single <code>1</code> in the console","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"looks like it dropped some though? I only see a single `1` in the console","mimetype":"text/plain"},{"body":"looks like it dropped some though? I only see a single <code>1</code> in the console","mimetype":"text/html"}]},"ts":1650336512482,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$oVBhqBGHEbUebzK2fFgIawJl6bcDhE5wWhrpVHBK23g"},
{"content":{"body":"oh, wait, that's just the wrapping, sigh","msgtype":"m.text","org.matrix.msc1767.text":"oh, wait, that's just the wrapping, sigh"},"ts":1650336522288,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$PApcTzOTlwvSrT14bVH4GmWY8NfAQR1tmzgyo_ZAOqo"},
{"content":{"body":"that still only works with finite iterators though","msgtype":"m.text","org.matrix.msc1767.text":"that still only works with finite iterators though"},"ts":1650336564453,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$fkb7REukaHUAJZWA-t2yVbhoQ-VEOX8oNBPmy0F0sZE"},
{"content":{"body":"finite underlying iterators, that is","msgtype":"m.text","org.matrix.msc1767.text":"finite underlying iterators, that is"},"ts":1650336570128,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$F54qiOlJK8SfIB9_gLbvZkTyQikYxWdASkBxBjbCWlU"},
{"content":{"body":"well... maybe it could be made to work with infinite ones, hmm","msgtype":"m.text","org.matrix.msc1767.text":"well... maybe it could be made to work with infinite ones, hmm"},"ts":1650336588943,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$omkcN5KUQuzzOabzvt2UkWWDm_yIH32kw1ETy6dhs_8"},
{"content":{"body":"yes it should be able to. Just pass in the iterator.","msgtype":"m.text","org.matrix.msc1767.text":"yes it should be able to. Just pass in the iterator."},"ts":1650336604017,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$Rq7rMCEnnZI5P0O1H_fBbM9eK538ztBBOdDP2YcnB98"},
{"content":{"body":"take(5) kind of thing then next to get the next work.","msgtype":"m.text","org.matrix.msc1767.text":"take(5) kind of thing then next to get the next work."},"ts":1650336621012,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$aBx4hcohLODW6Tuupfele4me6J4hRI3rq9Zo8avmVUE"},
{"content":{"body":"oh, but it doesn't compose, because it produces an async iterator rather than a sync iterator of promises","msgtype":"m.text","org.matrix.msc1767.text":"oh, but it doesn't compose, because it produces an async iterator rather than a sync iterator of promises"},"ts":1650336857920,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$rGI50r9-RduohMhgjZcq8te5y1cL3bOx0kSCvgi8J-4"},
{"content":{"body":"so you can't do it twice with different mapping functions","msgtype":"m.text","org.matrix.msc1767.text":"so you can't do it twice with different mapping functions"},"ts":1650336870117,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$GN4mgThMk9oF2sIRFaNycCON4sHD2yK60GC6WFGUDgU"},
{"content":{"body":"bakkot: https://jsfiddle.net/xs1brkL8/ Wait, I don't use these much. Can you detect the break in code like that to print \"map done\"?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: https://jsfiddle.net/xs1brkL8/ Wait, I don't use these much. Can you detect the break in code like that to print &quot;map done&quot;?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: https://jsfiddle.net/xs1brkL8/ Wait, I don't use these much. Can you detect the break in code like that to print \"map done\"?","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: https://jsfiddle.net/xs1brkL8/ Wait, I don't use these much. Can you detect the break in code like that to print &quot;map done&quot;?","mimetype":"text/html"}]},"ts":1650338803079,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$kRuK9Z2TbT1IaVf-nTnmJKG0KUz1WHRHHfw92bvvJsg"},
{"content":{"body":"sirisian: i don't understand the question","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: i don't understand the question","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"sirisian: i don't understand the question","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: i don't understand the question","mimetype":"text/html"}]},"ts":1650338857620,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$odLABBlQre7TljgAEXh2CJ2QC4lzMTf5oi0s4yNFycs"},
{"content":{"body":"oh, do you mean, the `break` in the bottom loop? yes: it will cause the `yield` to be a `return`, and you can use a try/finally to do cleanup ","format":"org.matrix.custom.html","formatted_body":"oh, do you mean, the <code>break</code> in the bottom loop? yes: it will cause the <code>yield</code> to be a <code>return</code>, and you can use a try/finally to do cleanup","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"oh, do you mean, the `break` in the bottom loop? yes: it will cause the `yield` to be a `return`, and you can use a try/finally to do cleanup ","mimetype":"text/plain"},{"body":"oh, do you mean, the <code>break</code> in the bottom loop? yes: it will cause the <code>yield</code> to be a <code>return</code>, and you can use a try/finally to do cleanup","mimetype":"text/html"}]},"ts":1650339121814,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$4KiNHWkIKhA93ISl289pXE9igSkEOXEQOs0ItiGjpZU"},
{"content":{"body":"oh it throws. I see.","msgtype":"m.text","org.matrix.msc1767.text":"oh it throws. I see."},"ts":1650339132243,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$zObZCF4roGLvxvv4KHaUTuJmV5wVdLYr4HKI-rTY_ag"},
{"content":{"body":"it doesn't throw","msgtype":"m.text","org.matrix.msc1767.text":"it doesn't throw"},"ts":1650339155648,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$X4EGgcNWgNVILwtbJqTBuHAX9i2FT7slJ6S8QrbHn50"},
{"content":{"body":"it puts a `return`","format":"org.matrix.custom.html","formatted_body":"it puts a <code>return</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"it puts a `return`","mimetype":"text/plain"},{"body":"it puts a <code>return</code>","mimetype":"text/html"}]},"ts":1650339160165,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$CL4_zPcAexgccQTN0IvnoS7PCv9inhnor7eLm0V3g9c"},
{"content":{"body":"a `finally` will trigger, but not a `catch`","format":"org.matrix.custom.html","formatted_body":"a <code>finally</code> will trigger, but not a <code>catch</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"a `finally` will trigger, but not a `catch`","mimetype":"text/plain"},{"body":"a <code>finally</code> will trigger, but not a <code>catch</code>","mimetype":"text/html"}]},"ts":1650339175645,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Jr6Scq2grg2eKv71x7QjvJLtj0Lq5iVIIVBEr8-7d8g"},
{"content":{"body":"```\nasync function* map(tasks, n) {\n  try {\n    // Start n work\n    const parallel = new Set();\n    for (let i = 0; !tasks.done && i < n; ++i) {\n      parallel.add(makeWork((await tasks.next()).value));\n    }\n    // Process the work yielding the first one done in the set of n work\n    while (parallel.length != 0 && !tasks.done) {\n      const task = await Promise.race([...parallel].map(t => t.promise));\n      parallel.delete(task);\n      yield task;\n      // Add 1 more work\n      parallel.add(makeWork((await tasks.next()).value));\n    }\n  } finally {\n    console.log('map done');\n    tasks?.return();\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* map(tasks, n) {\n  try {\n    // Start n work\n    const parallel = new Set();\n    for (let i = 0; !tasks.done &amp;&amp; i &lt; n; ++i) {\n      parallel.add(makeWork((await tasks.next()).value));\n    }\n    // Process the work yielding the first one done in the set of n work\n    while (parallel.length != 0 &amp;&amp; !tasks.done) {\n      const task = await Promise.race([...parallel].map(t =&gt; t.promise));\n      parallel.delete(task);\n      yield task;\n      // Add 1 more work\n      parallel.add(makeWork((await tasks.next()).value));\n    }\n  } finally {\n    console.log('map done');\n    tasks?.return();\n  }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"```\nasync function* map(tasks, n) {\n  try {\n    // Start n work\n    const parallel = new Set();\n    for (let i = 0; !tasks.done && i < n; ++i) {\n      parallel.add(makeWork((await tasks.next()).value));\n    }\n    // Process the work yielding the first one done in the set of n work\n    while (parallel.length != 0 && !tasks.done) {\n      const task = await Promise.race([...parallel].map(t => t.promise));\n      parallel.delete(task);\n      yield task;\n      // Add 1 more work\n      parallel.add(makeWork((await tasks.next()).value));\n    }\n  } finally {\n    console.log('map done');\n    tasks?.return();\n  }\n}\n```","mimetype":"text/plain"},{"body":"<pre><code>async function* map(tasks, n) {\n  try {\n    // Start n work\n    const parallel = new Set();\n    for (let i = 0; !tasks.done &amp;&amp; i &lt; n; ++i) {\n      parallel.add(makeWork((await tasks.next()).value));\n    }\n    // Process the work yielding the first one done in the set of n work\n    while (parallel.length != 0 &amp;&amp; !tasks.done) {\n      const task = await Promise.race([...parallel].map(t =&gt; t.promise));\n      parallel.delete(task);\n      yield task;\n      // Add 1 more work\n      parallel.add(makeWork((await tasks.next()).value));\n    }\n  } finally {\n    console.log('map done');\n    tasks?.return();\n  }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1650339181004,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$0RkC9XOShP6vban31nsHlLp5vomsEeM-A8QK1FxYzps"},
{"content":{"body":" * it doesn't throw","m.new_content":{"body":"it doesn't throw","msgtype":"m.text","org.matrix.msc1767.text":"it doesn't throw"},"m.relates_to":{"event_id":"$X4EGgcNWgNVILwtbJqTBuHAX9i2FT7slJ6S8QrbHn50","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * it doesn't throw"},"ts":1650339189269,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$_0ODrPRSOdK2zqroeARs-IxU_pyY9mbJsMvz_pvHyKk"},
{"content":{"body":"https://jsfiddle.net/xs1brkL8/1/ neat, is this composable?","msgtype":"m.text","org.matrix.msc1767.text":"https://jsfiddle.net/xs1brkL8/1/ neat, is this composable?"},"ts":1650339280951,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$oH1viNog8KrGIMsSeQmFCy9YEoYAoMXgsycHk6ZXs9E"},
{"content":{"body":"In the actual helper setup it would need to be on the iterator, but that should be fine. I could rewrite it do that I think.","msgtype":"m.text","org.matrix.msc1767.text":"In the actual helper setup it would need to be on the iterator, but that should be fine. I could rewrite it do that I think."},"ts":1650339359871,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$O7uehUpiCgB3uhbVWuKloUZFXJj8T45aaGlfeoks4ck"},
{"content":{"body":"Oh wait, can you modify all iterators to add functions to them. (I know this would be bad).","msgtype":"m.text","org.matrix.msc1767.text":"Oh wait, can you modify all iterators to add functions to them. (I know this would be bad)."},"ts":1650339462881,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$en1fSuD1W-HnFwDTBIu4CIOYTHolRn2SyiBX1BHAma8"},
{"content":{"body":"that's what the iterator helpers proposal is","msgtype":"m.text","org.matrix.msc1767.text":"that's what the iterator helpers proposal is"},"ts":1650339483832,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$amduxCrWtUVrYHQ-WDRpcOaWwkMbVPsvTd41NJty2SQ"},
{"content":{"body":"i.e. adding functions to all iterators (all iterators which inherit from iterator.prototype, anyway)","msgtype":"m.text","org.matrix.msc1767.text":"i.e. adding functions to all iterators (all iterators which inherit from iterator.prototype, anyway)"},"ts":1650339515528,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$eoxhYOxTfyRNtm-g0lTihfvqeN9a1N63L1pco11cJXQ"},
{"content":{"body":"I can't quite tell if your thing actually composes properly just from staring at it","msgtype":"m.text","org.matrix.msc1767.text":"I can't quite tell if your thing actually composes properly just from staring at it"},"ts":1650339540566,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$wKRtrzj3enimYjDxdmXmH_9cPIub5v7f5eJBapvqvJY"},
{"content":{"body":"oh, `!tasks.done` isn't a thing, though","format":"org.matrix.custom.html","formatted_body":"oh, <code>!tasks.done</code> isn't a thing, though","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"oh, `!tasks.done` isn't a thing, though","mimetype":"text/plain"},{"body":"oh, <code>!tasks.done</code> isn't a thing, though","mimetype":"text/html"}]},"ts":1650339636623,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$wLLlG-joA-zzOcmqdSkSV5X1dQAP5sg-jeo2_vumy9Y"},
{"content":{"body":"whoops forgot that one. https://jsfiddle.net/xs1brkL8/2/","msgtype":"m.text","org.matrix.msc1767.text":"whoops forgot that one. https://jsfiddle.net/xs1brkL8/2/"},"ts":1650339661335,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$diSiqHVclyNzqBvKUJ-DRm9pYjoETHQKfirPdETEv8A"},
{"content":{"body":" * whoops forgot that one. https://jsfiddle.net/xs1brkL8/2/","m.new_content":{"body":"whoops forgot that one. https://jsfiddle.net/xs1brkL8/2/","msgtype":"m.text","org.matrix.msc1767.text":"whoops forgot that one. https://jsfiddle.net/xs1brkL8/2/"},"m.relates_to":{"event_id":"$diSiqHVclyNzqBvKUJ-DRm9pYjoETHQKfirPdETEv8A","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * whoops forgot that one. https://jsfiddle.net/xs1brkL8/2/"},"ts":1650339683081,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$FDQ4wJl69UdvPE57alFXs64WKw-G3qvXgjxM0qNsSFM"},
{"content":{"body":"I mean can you edit the iterator prototype right now for testing polyfills?","msgtype":"m.text","org.matrix.msc1767.text":"I mean can you edit the iterator prototype right now for testing polyfills?"},"ts":1650339713274,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$UvjVy3iamQCg9hxrnMeH3XtvKEGCpDnlyD1uv17tAnc"},
{"content":{"body":"yes","msgtype":"m.text","org.matrix.msc1767.text":"yes"},"ts":1650339719238,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$uM_v4mgtKEttr3n_hfLaDoUrYYes2k6-c8kIYdx-tAE"},
{"content":{"body":"re^, you have to check the `done` property of the result every time you call `.next()`","format":"org.matrix.custom.html","formatted_body":"re^, you have to check the <code>done</code> property of the result every time you call <code>.next()</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"re^, you have to check the `done` property of the result every time you call `.next()`","mimetype":"text/plain"},{"body":"re^, you have to check the <code>done</code> property of the result every time you call <code>.next()</code>","mimetype":"text/html"}]},"ts":1650339741921,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$8lzXoOdFKTLWqJlgnjudVq6Lt0s29nAwA-OqSBSZUhM"},
{"content":{"body":"you have to check `done` before reading `value` ","format":"org.matrix.custom.html","formatted_body":"you have to check <code>done</code> before reading <code>value</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"you have to check `done` before reading `value` ","mimetype":"text/plain"},{"body":"you have to check <code>done</code> before reading <code>value</code>","mimetype":"text/html"}]},"ts":1650339758857,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$6jDnEdt4GjgukFTWGNWsAxFiK3H-65GlCRaozooytkA"},
{"content":{"body":"(to obey the iterator contract, anyway; you don't _have_ to but it's going to behave weirdly if you don't)","format":"org.matrix.custom.html","formatted_body":"(to obey the iterator contract, anyway; you don't <em>have</em> to but it's going to behave weirdly if you don't)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"(to obey the iterator contract, anyway; you don't _have_ to but it's going to behave weirdly if you don't)","mimetype":"text/plain"},{"body":"(to obey the iterator contract, anyway; you don't <em>have</em> to but it's going to behave weirdly if you don't)","mimetype":"text/html"}]},"ts":1650339781615,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$goP1CfTA_9U4twVK-sDOW6VxUE2eLRk86Yu1awna0Vs"}
]