[
{"content":{"body":"Does anyone know if the iterator helper proposal has ever discussed parallel/batch features for v1? A lot of my use cases for lazy iterators involve async operations that benefit from parallel requests. Maybe I'm thinking of this wrong, but like for (const item of webpages.map(async url => return await op(url), { batch: 5 })){} where 5 are executed in parallel and are handled out of order first come. (In theory if a break is called then the other 4 pending would be cancelled by the generator's return). The big picture is handling tasks that might look like [500ms, 10ms, 10ms, 10ms, 10ms...] where a random long task blocks the whole pipeline. With more complex pipelines this snowballs into large delays.","msgtype":"m.text","org.matrix.msc1767.text":"Does anyone know if the iterator helper proposal has ever discussed parallel/batch features for v1? A lot of my use cases for lazy iterators involve async operations that benefit from parallel requests. Maybe I'm thinking of this wrong, but like for (const item of webpages.map(async url => return await op(url), { batch: 5 })){} where 5 are executed in parallel and are handled out of order first come. (In theory if a break is called then the other 4 pending would be cancelled by the generator's return). The big picture is handling tasks that might look like [500ms, 10ms, 10ms, 10ms, 10ms...] where a random long task blocks the whole pipeline. With more complex pipelines this snowballs into large delays."},"ts":1650313585197,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$ceL6Rhnm_akh3oCAEzslSR_pfSzw8lx8s0mkLUk5Pxs"},
{"content":{"body":"sirisian: not for v1, no. I would also like to see such a thing at some point but it doesn't really fit with the simpler v1 helpers; it would be its own thing","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: not for v1, no. I would also like to see such a thing at some point but it doesn't really fit with the simpler v1 helpers; it would be its own thing","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"sirisian: not for v1, no. I would also like to see such a thing at some point but it doesn't really fit with the simpler v1 helpers; it would be its own thing","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: not for v1, no. I would also like to see such a thing at some point but it doesn't really fit with the simpler v1 helpers; it would be its own thing","mimetype":"text/html"}]},"ts":1650314902103,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Q4AfznkIfuNkILCKrXYE3IeczKkGaKEzznKjIlry03o"},
{"content":{"body":"As long as it's possible later, that's all that matters.","msgtype":"m.text","org.matrix.msc1767.text":"As long as it's possible later, that's all that matters."},"ts":1650314938600,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$cJsuXhYq0-l3IHSDJ53_stt4Qz1BOKzoNYRvPHVmFM4"},
{"content":{"body":"I haven't thought about it really hard but I expect it should be. and at the very least nothing in this proposal is likely to make it harder.","msgtype":"m.text","org.matrix.msc1767.text":"I haven't thought about it really hard but I expect it should be. and at the very least nothing in this proposal is likely to make it harder."},"ts":1650314990531,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$mXNoIMQdX9A1NXhwfSCTqE8Ra5DAL35Le3Ol8jwFvok"},
{"content":{"body":"Ixjs has this with a `concurrent` param for `flatMap` https://github.com/ReactiveX/IxJS/blob/master/src/asynciterable/operators/flatmap.ts","format":"org.matrix.custom.html","formatted_body":"Ixjs has this with a <code>concurrent</code> param for <code>flatMap</code> https://github.com/ReactiveX/IxJS/blob/master/src/asynciterable/operators/flatmap.ts","msgtype":"m.text"},"ts":1650315054884,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$ONi_Id1W0GzBqKembDcdyPLCG_SxuykxlBcQp_fh1vc"},
{"content":{"body":"for the particular example you give I think the thing you actually want is a helper to bound how many invocations of an async function can be running simultaneously","msgtype":"m.text","org.matrix.msc1767.text":"for the particular example you give I think the thing you actually want is a helper to bound how many invocations of an async function can be running simultaneously"},"ts":1650315768183,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$jvIefOtqX4RuR91LAS53-cXPvez1Je8HDoV3P5ipRQA"},
{"content":{"body":"```\nfunction boundAsyncFunctionConcurrency(f, N) {\n  let waiting = [];\n  let available = N;\n  function lock() {\n    if (available > 0) {\n      --available;\n      return;\n    }\n    return new Promise(res => {\n      waiting.push(res);\n    });\n  }\n  function unlock() {\n    if (waiting.length > 0) {\n      waiting.shift()();\n    } else {\n      ++available;\n    }\n  }\n\n  return async function(...args) {\n    try {\n      await lock();\n      return await f.apply(this, args);\n    } finally {\n      unlock();\n    }\n  };\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<pre><code>function boundAsyncFunctionConcurrency(f, N) {\n  let waiting = [];\n  let available = N;\n  function lock() {\n    if (available &gt; 0) {\n      --available;\n      return;\n    }\n    return new Promise(res =&gt; {\n      waiting.push(res);\n    });\n  }\n  function unlock() {\n    if (waiting.length &gt; 0) {\n      waiting.shift()();\n    } else {\n      ++available;\n    }\n  }\n\n  return async function(...args) {\n    try {\n      await lock();\n      return await f.apply(this, args);\n    } finally {\n      unlock();\n    }\n  };\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"```\nfunction boundAsyncFunctionConcurrency(f, N) {\n  let waiting = [];\n  let available = N;\n  function lock() {\n    if (available > 0) {\n      --available;\n      return;\n    }\n    return new Promise(res => {\n      waiting.push(res);\n    });\n  }\n  function unlock() {\n    if (waiting.length > 0) {\n      waiting.shift()();\n    } else {\n      ++available;\n    }\n  }\n\n  return async function(...args) {\n    try {\n      await lock();\n      return await f.apply(this, args);\n    } finally {\n      unlock();\n    }\n  };\n}\n```\n","mimetype":"text/plain"},{"body":"<pre><code>function boundAsyncFunctionConcurrency(f, N) {\n  let waiting = [];\n  let available = N;\n  function lock() {\n    if (available &gt; 0) {\n      --available;\n      return;\n    }\n    return new Promise(res =&gt; {\n      waiting.push(res);\n    });\n  }\n  function unlock() {\n    if (waiting.length &gt; 0) {\n      waiting.shift()();\n    } else {\n      ++available;\n    }\n  }\n\n  return async function(...args) {\n    try {\n      await lock();\n      return await f.apply(this, args);\n    } finally {\n      unlock();\n    }\n  };\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1650316045823,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$hi9OJWO2pCgpHJ0KKs8QG1qvO2xcUG5o0O2EhhD5eXM"},
{"content":{"body":"or something to that effect","msgtype":"m.text","org.matrix.msc1767.text":"or something to that effect"},"ts":1650316049425,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$lPkknv31z5TQmbGfJ6CW4LMsZCxE2r6-y2ksL6fy37k"},
{"content":{"body":"so you can do `.map(boundAsyncFunctionConcurrency(async url => await op(url), 5))`","format":"org.matrix.custom.html","formatted_body":"so you can do <code>.map(boundAsyncFunctionConcurrency(async url =&gt; await op(url), 5))</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"so you can do `.map(boundAsyncFunctionConcurrency(async url => await op(url), 5))`","mimetype":"text/plain"},{"body":"so you can do <code>.map(boundAsyncFunctionConcurrency(async url =&gt; await op(url), 5))</code>","mimetype":"text/html"}]},"ts":1650316078564,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$8aNFnf1obs8Pzaq0HypxjBmE55FtsMdTz8uQ394Nk0c"},
{"content":{"body":"rather than getting the iterator helpers involved directly","msgtype":"m.text","org.matrix.msc1767.text":"rather than getting the iterator helpers involved directly"},"ts":1650316091084,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$pZCOw2vo_dvIZss5Pk6j8eRV7uIZpDcAscdpto6iVlI"},
{"content":{"body":"but there are probably other cases where you'd want the iterator helpers to be involved","msgtype":"m.text","org.matrix.msc1767.text":"but there are probably other cases where you'd want the iterator helpers to be involved"},"ts":1650316107078,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$EG9nhCmBneJ24edHUkRwBU2IxLqFZs42DhEq0nqSamQ"},
{"content":{"body":"I've used https://www.npmjs.com/package/throat in the past","msgtype":"m.text","org.matrix.msc1767.text":"I've used https://www.npmjs.com/package/throat in the past"},"ts":1650318922747,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$0AGWqx0rhUGB0KwKjBuias90mbFrkstUCiaSiKQJ0Wg"},
{"content":{"body":"bakkot: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","mimetype":"text/html"}]},"ts":1650322671586,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$1gqRQ8IlcPVKsgseiqj1slrQAvwTT3neNKyVTZda8NM"},
{"content":{"body":" * bakkot: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","m.new_content":{"body":"bakkot: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$1gqRQ8IlcPVKsgseiqj1slrQAvwTT3neNKyVTZda8NM","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * bakkot: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","mimetype":"text/plain"},{"body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: Wouldn't your implementation instantly create N promises consuming the whole input generator? Ideally a lazy iterator implementation wouldn't do that. The map would only call next 5 times to start then again when the first promise returns. Ideally a generator could have infinite items and everything would just work.","mimetype":"text/html"}]},"ts":1650322702851,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$IJek6U8FpysWMCHpsjPFCd9SoJ6eGQsPs0MbBUt1J60"},
{"content":{"body":"sirisian: no, it will not consume the whole input","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: no, it will not consume the whole input","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"sirisian: no, it will not consume the whole input","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: no, it will not consume the whole input","mimetype":"text/html"}]},"ts":1650324866363,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ZpvWVO5O20dH0g_pJNJuRRNMJzIG3XZ3dUSmw4zLQ0U"},
{"content":{"body":"not unless you `toArray` it or something, anyway","format":"org.matrix.custom.html","formatted_body":"not unless you <code>toArray</code> it or something, anyway","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"not unless you `toArray` it or something, anyway","mimetype":"text/plain"},{"body":"not unless you <code>toArray</code> it or something, anyway","mimetype":"text/html"}]},"ts":1650324884727,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$9KjI-_P2s4mxRehuaM_pw7wYbnaLRh05AGmn5wZT5ws"},
{"content":{"body":"iterator helpers are lazy","msgtype":"m.text","org.matrix.msc1767.text":"iterator helpers are lazy"},"ts":1650324990982,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$3T3fw-NEGMeuRhPbLcll187EaPrEepifnP01kr-ywSA"},
{"content":{"body":"which, it occurs to me, probably means they're not a good fit for what you're trying to do anyway","msgtype":"m.text","org.matrix.msc1767.text":"which, it occurs to me, probably means they're not a good fit for what you're trying to do anyway"},"ts":1650325000471,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$JNEpfNmg54wHzm8LlriXg4OWRUjddBl8dowxMp0GD80"},
{"content":{"body":"you can't really have all three of \"works with infinite generators\", \"provides results in order\", and \"does not block on inputs which are slow\"","msgtype":"m.text","org.matrix.msc1767.text":"you can't really have all three of \"works with infinite generators\", \"provides results in order\", and \"does not block on inputs which are slow\""},"ts":1650325135542,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$LeN803FjzjctS_kuVkQLdbstxSAK09a_s6XeF-89RKo"},
{"content":{"body":"because if you _don't_ block on slow inputs, but you still want to get results in order, that means it has to eagerly start doing work for results past the next one, which means it's not going to work for infinite iterators.","format":"org.matrix.custom.html","formatted_body":"because if you <em>don't</em> block on slow inputs, but you still want to get results in order, that means it has to eagerly start doing work for results past the next one, which means it's not going to work for infinite iterators.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"because if you _don't_ block on slow inputs, but you still want to get results in order, that means it has to eagerly start doing work for results past the next one, which means it's not going to work for infinite iterators.","mimetype":"text/plain"},{"body":"because if you <em>don't</em> block on slow inputs, but you still want to get results in order, that means it has to eagerly start doing work for results past the next one, which means it's not going to work for infinite iterators.","mimetype":"text/html"}]},"ts":1650325271930,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$DXcn2onhGYLM0Xk2sK2i-2oyx--U9NpgnPWYj3Y6iNY"},
{"content":{"body":"Well I said out of order.","msgtype":"m.text","org.matrix.msc1767.text":"Well I said out of order."},"ts":1650325274233,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$k5lQ0nWqZ-Xv3dqafcRvJCeX32CNnaRaec1z3LPl-mg"},
{"content":{"body":"ohh, missed that","msgtype":"m.text","org.matrix.msc1767.text":"ohh, missed that"},"ts":1650325283342,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$v6eBiBr17nKU3V4McXXaU4e0D82KOxH3H-k1Ph4l2FI"},
{"content":{"body":"I don't think we want iterators to ever provide results out of order, so that would just be a different proposal for a different mechanism entirely","msgtype":"m.text","org.matrix.msc1767.text":"I don't think we want iterators to ever provide results out of order, so that would just be a different proposal for a different mechanism entirely"},"ts":1650325310510,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$hi-JXT-a1qyvC-cobYvRkckKgvT8oR5RFdX4NRGz5is"},
{"content":{"body":"I do see what you mean though. In applications where order matters batch means something very different than what I intended in my ad-hoc example.","msgtype":"m.text","org.matrix.msc1767.text":"I do see what you mean though. In applications where order matters batch means something very different than what I intended in my ad-hoc example."},"ts":1650325394609,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$xDnK3_Cizmwv0AxlkXNWDfHnBbDWTrqPxD4JhiI11bQ"},
{"content":{"body":" * I do see what you mean though. In applications where order matters batch means something very different than what I intended in my ad-hoc example.","m.new_content":{"body":"I do see what you mean though. In applications where order matters batch means something very different than what I intended in my ad-hoc example.","msgtype":"m.text","org.matrix.msc1767.text":"I do see what you mean though. In applications where order matters batch means something very different than what I intended in my ad-hoc example."},"m.relates_to":{"event_id":"$xDnK3_Cizmwv0AxlkXNWDfHnBbDWTrqPxD4JhiI11bQ","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * I do see what you mean though. In applications where order matters batch means something very different than what I intended in my ad-hoc example."},"ts":1650325402401,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$EUB80NQ3kcEPSZO0f5ekIFCPkOjsO2aolP6zrlkgNHc"},
{"content":{"body":"I think the thing you want is something which works with sync iterators which yield promises? Let me see...","msgtype":"m.text","org.matrix.msc1767.text":"I think the thing you want is something which works with sync iterators which yield promises? Let me see..."},"ts":1650325480413,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$6rhDuIR34j5Oi7VLa1OTzPIfgW5ykcloE6Y1joUe918"}
]