[
{"content":{"body":"I noticed an interoperability issue between Firefox and Chrome when it comes to Array sort(), in particular, the presence of an undefined/NaN can not only affect the positin of the NaN but the order of all other items which seems problematic?\n\nMinimal example at https://phabricator.wikimedia.org/P63711","m.mentions":{},"msgtype":"m.text"},"ts":1717083308179,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$O-BEuRKq1-Fsu_r_xcwWdpyqJwXMkhsBY4kj25id2s4"},
{"content":{"body":" * I noticed an interoperability issue between Firefox and Chrome when it comes to Array sort(), in particular, the presence of an undefined/NaN can not only affect the position of the NaN but the order of all other items which seems problematic?\n\nMinimal example at https://phabricator.wikimedia.org/P63711","m.mentions":{},"m.new_content":{"body":"I noticed an interoperability issue between Firefox and Chrome when it comes to Array sort(), in particular, the presence of an undefined/NaN can not only affect the position of the NaN but the order of all other items which seems problematic?\n\nMinimal example at https://phabricator.wikimedia.org/P63711","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$O-BEuRKq1-Fsu_r_xcwWdpyqJwXMkhsBY4kj25id2s4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717083325164,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$sYDBxZLINi8pVzHK0EBgv-BWDh3XynoSCp_FepxNW2w"},
{"content":{"body":"Firefox: `0, 1, undefined, -10, -9`\nChrome: `-10, -9, 0, 1, undefined`","format":"org.matrix.custom.html","formatted_body":"Firefox: <code>0, 1, undefined, -10, -9</code><br>Chrome: <code>-10, -9, 0, 1, undefined</code>","m.mentions":{},"msgtype":"m.text"},"ts":1717083364929,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$R9YRaxBMpzPqDOv91urK8zGw-BudB-5V8hMkShUz0tM"},
{"content":{"body":"Timo Tijhof: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#sorting_with_non-well-formed_comparator","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@timotijhof:matrix.org\">Timo Tijhof</a>: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#sorting_with_non-well-formed_comparator","m.mentions":{"user_ids":["@timotijhof:matrix.org"]},"msgtype":"m.text"},"ts":1717084156940,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$NskwI6qdITttGseGy2fQP8vb3-6jGPUBHwasmZZU6fM"},
{"content":{"body":"eemeli: Is there no apetite for tightening the spec around this? I get the argument for purity and stability, but I don't see the benefit in allowing it to remain as unspecified/undefined behaviour. We've already crossed the bridge of stable sorting for identical values based on input. Standardising behaviour around NaN seems like a natural next step.\n\n","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@eemeli:mozilla.org\">eemeli</a>: Is there no apetite for tightening the spec around this? I get the argument for purity and stability, but I don't see the benefit in allowing it to remain as unspecified/undefined behaviour. We've already crossed the bridge of stable sorting for identical values based on input. Standardising behaviour around NaN seems like a natural next step.","m.mentions":{"user_ids":["@eemeli:mozilla.org"]},"msgtype":"m.text"},"ts":1717084342023,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$Qu8wy1Nqb1kCQB556A-D67Ek_BYk6xQRfMPaLRVvpi8"},
{"content":{"body":" * eemeli: Is there no apetite for tightening the spec around this? I get the argument for mathematical purity, but I don't see the benefit in allowing it to remain as unspecified/undefined behaviour. We've already crossed the bridge of stable sorting for identical values based on input. Standardising behaviour around NaN seems like a natural next step.","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@eemeli:mozilla.org\">eemeli</a>: Is there no apetite for tightening the spec around this? I get the argument for mathematical purity, but I don't see the benefit in allowing it to remain as unspecified/undefined behaviour. We've already crossed the bridge of stable sorting for identical values based on input. Standardising behaviour around NaN seems like a natural next step.","m.mentions":{},"m.new_content":{"body":"eemeli: Is there no apetite for tightening the spec around this? I get the argument for mathematical purity, but I don't see the benefit in allowing it to remain as unspecified/undefined behaviour. We've already crossed the bridge of stable sorting for identical values based on input. Standardising behaviour around NaN seems like a natural next step.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@eemeli:mozilla.org\">eemeli</a>: Is there no apetite for tightening the spec around this? I get the argument for mathematical purity, but I don't see the benefit in allowing it to remain as unspecified/undefined behaviour. We've already crossed the bridge of stable sorting for identical values based on input. Standardising behaviour around NaN seems like a natural next step.","m.mentions":{"user_ids":["@eemeli:mozilla.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Qu8wy1Nqb1kCQB556A-D67Ek_BYk6xQRfMPaLRVvpi8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717084354441,"senderName":"Timo Tijhof","senderId":"@timotijhof:matrix.org","id":"$0mCdtFS0UVwuFMgu9StKrIz6FxA1mJGilH_swGgCsLQ"},
{"content":{"body":"It's not the behavior around NaN, it's the behavior around inconsistent comparators","m.mentions":{},"msgtype":"m.text"},"ts":1717084814340,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$FKdSqRrUeiQcs5cdTf_JXOe4WqMXMk3pA_s-cUDv-Hk"},
{"content":{"body":"My guess would be that it would be difficult to define the sorting behaviour more strictly without introducing performance penalties for some implementations.","m.mentions":{},"msgtype":"m.text"},"ts":1717084832287,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$qk2HYRHjcFbt-gBnhjXhGz4h_Yp-SLwUch6aPKORkJs"},
{"content":{"body":"there might someday be appetite to fully specify behavior even in the presence of inconsistent comparators, but that would require a particular sorting algorithm (or at least more specific than currently), which would prevent implementations with experimenting with alternative sorting algorithms, which is a very nice thing for them to be able to do","m.mentions":{},"msgtype":"m.text"},"ts":1717084907461,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$xbU_DThqWo70peZch-eSJyxPdxIV8KuHoJxiHC_cOeg"},
{"content":{"body":"Is there anything we can do to make it easier to write compliant comparators for the more frequent and trivial cases, such as the example above?","m.mentions":{},"msgtype":"m.text"},"ts":1717085600611,"senderName":"whosy","senderId":"@whosy:matrix.org","id":"$IoJmdpJx4a8jK3C_pgCVDHABQzMF7CG_kop64HXBHZo"},
{"content":{"body":"we could provide a `sortBy` method that takes a function from list members to numbers and then sorts according to the result, and if we specified where `NaN` goes in such a list (or that getting `NaN` throws, my preference) that would address this case","format":"org.matrix.custom.html","formatted_body":"we could provide a <code>sortBy</code> method that takes a function from list members to numbers and then sorts according to the result, and if we specified where <code>NaN</code> goes in such a list (or that getting <code>NaN</code> throws, my preference) that would address this case","m.mentions":{},"msgtype":"m.text"},"ts":1717086133637,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$G8T5He_HYgsodFEDp0bTJZeaPn0K4uURBpebgt4Oy78"},
{"content":{"body":"I have wanted this for a while but not had time to pursue it","m.mentions":{},"msgtype":"m.text"},"ts":1717086146446,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$aPwsFqmQR0jSdx8KNXSIuqvioklVb2shLF87I-al6Tw"},
{"content":{"body":"also we could provide a built-in comparator for the common case of sorting a list of numbers, though it wouldn't help in the given example","m.mentions":{},"msgtype":"m.text"},"ts":1717086154402,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$6U9VGBxbXhtqEQwgI5cOnb77OcKZuvMueKJYTB9TfQk"},
{"content":{"body":"`(a, b) => (a.index - b.index) || 0` seems like it'd make it consistent?","format":"org.matrix.custom.html","formatted_body":"<code>(a, b) =&gt; (a.index - b.index) || 0</code> seems like it'd make it consistent?","m.mentions":{},"msgtype":"m.text"},"ts":1717086312729,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$065fWh2_ado9LsYIw1dRjfFqYwsUjeDWrlkS6UblQU0"},
{"content":{"body":"If I might ask a question to such experienced people, as someone working on their first proposal:\n\nHow opinionated should a proposal be at stage 0? Should it try to be loose and open for many ideas and suggestions from others, or should it try to be more rigorous and concrete already at this stage?\n\nOr am I thinking too much of the solution when I should really focus more effort on the initial problem at this point?","m.mentions":{},"msgtype":"m.text"},"ts":1717100785521,"senderName":"whosy","senderId":"@whosy:matrix.org","id":"$EhVA8-0Bt5dNr8IEZfr1B2c4CnZca1uUerErirR48sg"}
]