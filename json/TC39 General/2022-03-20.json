[
{"content":{"body":"> <@devsnek:matrix.org> i will be very sad if we put type syntax in the language and it doesn't have some sort of reflection capability like python\n\nhave been thinking about this some: I think it would make more sense as a build step.\n\ne.g., you could, I think, write a babel plugin that transformed `type(x)` into a representation of the type of the expression `x` at build time.\n\nthat is probably better than building it in to the language, in a couple ways: 1) it lets you get a rich representation, instead of just a string, and do name resolution etc, 2) it means there is no risk to stripping types in prod, which is important lest we bloat every shipped file forever","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$7z9JZ7NS540rCM8DRpsOLNyYiflJrT7JBrVC48uYSwM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@devsnek:matrix.org\">@devsnek:matrix.org</a><br>i will be very sad if we put type syntax in the language and it doesn&#39;t have some sort of reflection capability like python</blockquote></mx-reply><p>have been thinking about this some: I think it would make more sense as a build step.</p>\n<p>e.g., you could, I think, write a babel plugin that transformed <code>type(x)</code> into a representation of the type of the expression <code>x</code> at build time.</p>\n<p>that is probably better than building it in to the language, in a couple ways: 1) it lets you get a rich representation, instead of just a string, and do name resolution etc, 2) it means there is no risk to stripping types in prod, which is important lest we bloat every shipped file forever</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$7z9JZ7NS540rCM8DRpsOLNyYiflJrT7JBrVC48uYSwM"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@devsnek:matrix.org> i will be very sad if we put type syntax in the language and it doesn't have some sort of reflection capability like python\n\nhave been thinking about this some: I think it would make more sense as a build step.\n\ne.g., you could, I think, write a babel plugin that transformed `type(x)` into a representation of the type of the expression `x` at build time.\n\nthat is probably better than building it in to the language, in a couple ways: 1) it lets you get a rich representation, instead of just a string, and do name resolution etc, 2) it means there is no risk to stripping types in prod, which is important lest we bloat every shipped file forever","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$7z9JZ7NS540rCM8DRpsOLNyYiflJrT7JBrVC48uYSwM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@devsnek:matrix.org\">@devsnek:matrix.org</a><br>i will be very sad if we put type syntax in the language and it doesn&#39;t have some sort of reflection capability like python</blockquote></mx-reply><p>have been thinking about this some: I think it would make more sense as a build step.</p>\n<p>e.g., you could, I think, write a babel plugin that transformed <code>type(x)</code> into a representation of the type of the expression <code>x</code> at build time.</p>\n<p>that is probably better than building it in to the language, in a couple ways: 1) it lets you get a rich representation, instead of just a string, and do name resolution etc, 2) it means there is no risk to stripping types in prod, which is important lest we bloat every shipped file forever</p>\n","mimetype":"text/html"}]},"ts":1647735672115,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$KMUIMICxI9pwRFQDRis4crI4pIsQMxTOQkxmV_Zx_GM"},
{"content":{"body":"that is certainly something that could happen","msgtype":"m.text"},"ts":1647735810337,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$UlVnXCltVHzBzh1dL9PYbIilGCSuIkbN2MnQGy9VQvc"},
{"content":{"body":"I'd still be sad though ðŸ¤·","msgtype":"m.text"},"ts":1647735837014,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$oLPqX1302korzfEdvbu_5CO5S4-v-O5FmKt3YiD2hXc"},
{"content":{"body":"> have been thinking about this some: I think it would make more sense as a build step.\n\nI worked on a project 2 years ago where I wanted reflection to power validation that proved at runtime that an object had the shape that TS claimed it did at development time. FWIW, I came to the same conclusion that bakkot did, that the most natural way to do what I wanted was via babel (or perhaps a plugin to the TS compiler itself).\n\nSpecifically, the babel part I wanted would turn TS types into plain schema-describing objects that could be accessed at runtime. Building these objects manually at development time was tedious, non-DRY, and error-prone.  I ended up using [runtypes](https://github.com/pelotom/runtypes#readme) which solves the DRY problem via uses ingenious hacks that build TS types based on validation code, but I really wanted to go in the other direction: start with TS code and get easy runtime-visible, validation-ready schema objects from it. Here's an overview of various ways people have tried to solve this problem: https://learning-notes.mistermicheels.com/javascript/typescript/runtime-type-checking/\n\nWhat makes validation an interesting case is that type validation is necessary but not sufficient. For example, for `type Foo = { someInt: number; }` you want to validate that the `someInt` property is a `Number`, but you might also want to validate that it's an integer. Other languages (I'm thinking of C#) enable this case via static typing + decorators + validation libraries so you can colocate validation requirements with your type declarations.\n\nThe problem with putting type syntax & reflection into the JS language is that you'd end up with a similar kind of bifurcated solution where reflecting on the newest TS (and Flow and...) versions would require a polyfill or would require TS/Flow/etc to stop innovating with the types that were available. At that point, you've got a build step anyways so it's not clear that enough value is being added in exchange for making the language much more complicated, and for the inevitable language bugs that would be challenging to fix without breaking the web.\n","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>have been thinking about this some: I think it would make more sense as a build step.</p>\n</blockquote>\n<p>I worked on a project 2 years ago where I wanted reflection to power validation that proved at runtime that an object had the shape that TS claimed it did at development time. FWIW, I came to the same conclusion that <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a> did, that the most natural way to do what I wanted was via babel (or perhaps a plugin to the TS compiler itself).</p>\n<p>Specifically, the babel part I wanted would turn TS types into plain schema-describing objects that could be accessed at runtime. Building these objects manually at development time was tedious, non-DRY, and error-prone.  I ended up using <a href=\"https://github.com/pelotom/runtypes#readme\">runtypes</a> which solves the DRY problem via uses ingenious hacks that build TS types based on validation code, but I really wanted to go in the other direction: start with TS code and get easy runtime-visible, validation-ready schema objects from it. Here's an overview of various ways people have tried to solve this problem: https://learning-notes.mistermicheels.com/javascript/typescript/runtime-type-checking/</p>\n<p>What makes validation an interesting case is that type validation is necessary but not sufficient. For example, for <code>type Foo = { someInt: number; }</code> you want to validate that the <code>someInt</code> property is a <code>Number</code>, but you might also want to validate that it's an integer. Other languages (I'm thinking of C#) enable this case via static typing + decorators + validation libraries so you can colocate validation requirements with your type declarations.</p>\n<p>The problem with putting type syntax &amp; reflection into the JS language is that you'd end up with a similar kind of bifurcated solution where reflecting on the newest TS (and Flow and...) versions would require a polyfill or would require TS/Flow/etc to stop innovating with the types that were available. At that point, you've got a build step anyways so it's not clear that enough value is being added in exchange for making the language much more complicated, and for the inevitable language bugs that would be challenging to fix without breaking the web.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> have been thinking about this some: I think it would make more sense as a build step.\n\nI worked on a project 2 years ago where I wanted reflection to power validation that proved at runtime that an object had the shape that TS claimed it did at development time. FWIW, I came to the same conclusion that bakkot did, that the most natural way to do what I wanted was via babel (or perhaps a plugin to the TS compiler itself).\n\nSpecifically, the babel part I wanted would turn TS types into plain schema-describing objects that could be accessed at runtime. Building these objects manually at development time was tedious, non-DRY, and error-prone.  I ended up using [runtypes](https://github.com/pelotom/runtypes#readme) which solves the DRY problem via uses ingenious hacks that build TS types based on validation code, but I really wanted to go in the other direction: start with TS code and get easy runtime-visible, validation-ready schema objects from it. Here's an overview of various ways people have tried to solve this problem: https://learning-notes.mistermicheels.com/javascript/typescript/runtime-type-checking/\n\nWhat makes validation an interesting case is that type validation is necessary but not sufficient. For example, for `type Foo = { someInt: number; }` you want to validate that the `someInt` property is a `Number`, but you might also want to validate that it's an integer. Other languages (I'm thinking of C#) enable this case via static typing + decorators + validation libraries so you can colocate validation requirements with your type declarations.\n\nThe problem with putting type syntax & reflection into the JS language is that you'd end up with a similar kind of bifurcated solution where reflecting on the newest TS (and Flow and...) versions would require a polyfill or would require TS/Flow/etc to stop innovating with the types that were available. At that point, you've got a build step anyways so it's not clear that enough value is being added in exchange for making the language much more complicated, and for the inevitable language bugs that would be challenging to fix without breaking the web.\n","mimetype":"text/plain"},{"body":"<blockquote>\n<p>have been thinking about this some: I think it would make more sense as a build step.</p>\n</blockquote>\n<p>I worked on a project 2 years ago where I wanted reflection to power validation that proved at runtime that an object had the shape that TS claimed it did at development time. FWIW, I came to the same conclusion that <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a> did, that the most natural way to do what I wanted was via babel (or perhaps a plugin to the TS compiler itself).</p>\n<p>Specifically, the babel part I wanted would turn TS types into plain schema-describing objects that could be accessed at runtime. Building these objects manually at development time was tedious, non-DRY, and error-prone.  I ended up using <a href=\"https://github.com/pelotom/runtypes#readme\">runtypes</a> which solves the DRY problem via uses ingenious hacks that build TS types based on validation code, but I really wanted to go in the other direction: start with TS code and get easy runtime-visible, validation-ready schema objects from it. Here's an overview of various ways people have tried to solve this problem: https://learning-notes.mistermicheels.com/javascript/typescript/runtime-type-checking/</p>\n<p>What makes validation an interesting case is that type validation is necessary but not sufficient. For example, for <code>type Foo = { someInt: number; }</code> you want to validate that the <code>someInt</code> property is a <code>Number</code>, but you might also want to validate that it's an integer. Other languages (I'm thinking of C#) enable this case via static typing + decorators + validation libraries so you can colocate validation requirements with your type declarations.</p>\n<p>The problem with putting type syntax &amp; reflection into the JS language is that you'd end up with a similar kind of bifurcated solution where reflecting on the newest TS (and Flow and...) versions would require a polyfill or would require TS/Flow/etc to stop innovating with the types that were available. At that point, you've got a build step anyways so it's not clear that enough value is being added in exchange for making the language much more complicated, and for the inevitable language bugs that would be challenging to fix without breaking the web.</p>\n","mimetype":"text/html"}]},"ts":1647750174176,"senderName":"justingrant","senderId":"@justingrant:matrix.org","id":"$eBbZqSq0x05mudTUngF89L9JHQ0jOX03pVvtfKo9bJY"},
{"content":{"body":"the main issue with a build step is that it's somewhat internal to each project","msgtype":"m.text"},"ts":1647792676256,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$tbOL7OttcRpf6xVeXQjDPaDpGv288Tni9uqnSVoou3o"},
{"content":{"body":"perhaps if ts had a standardized mode for emitting the info it would be better ","msgtype":"m.text"},"ts":1647792696927,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$G_aW-Pd6BHl58D4D_NoqZWyQUjhaEwe9nkgLTXVG7VA"},
{"content":{"body":"but that still seems unfortunate cuz I don't like using ts","msgtype":"m.text"},"ts":1647792710854,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$EIXtpOsED2UKZeS7pecZvq8GO0e_V96Ci8spbjsrH0k"}
]