[
{"content":{"body":"ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n```\nconst enqueueTask = callback => {\n  const id = setImmediate(callback);\n  return () => clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const p = whenCollected(target, data);\n  let retained = true;\n  p.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { whenCollected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code>const enqueueTask = callback =&gt; {\n  const id = setImmediate(callback);\n  return () =&gt; clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const p = whenCollected(target, data);\n  let retained = true;\n  p.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { whenCollected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"msgtype":"m.text"},"ts":1737679725463,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$LSjwIPu4c4DzODqe0bJiQnYcAAV3dplf9jp33ffSBmw"},
{"content":{"body":"* ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setImmediate(callback);\n  return () => clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const p = whenCollected(target, data);\n  let retained = true;\n  p.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { whenCollected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"* <p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setImmediate(callback);\n  return () =&gt; clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const p = whenCollected(target, data);\n  let retained = true;\n  p.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { whenCollected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setImmediate(callback);\n  return () => clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const p = whenCollected(target, data);\n  let retained = true;\n  p.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { whenCollected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setImmediate(callback);\n  return () =&gt; clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const p = whenCollected(target, data);\n  let retained = true;\n  p.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { whenCollected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$LSjwIPu4c4DzODqe0bJiQnYcAAV3dplf9jp33ffSBmw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1737680070183,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$AvYSskdTVrCgS6Vc02ZQk3sCP0LqymZB3G3PJYZRTJs"},
{"content":{"body":"* ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setImmediate(callback);\n  return () => clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"* <p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setImmediate(callback);\n  return () =&gt; clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setImmediate(callback);\n  return () => clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setImmediate(callback);\n  return () =&gt; clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$LSjwIPu4c4DzODqe0bJiQnYcAAV3dplf9jp33ffSBmw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1737680288475,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$y3Zg1lh-oXb39Pd5wwCFBFKkZAPUrGBu_ZqB8CE8XhI"},
{"content":{"body":"* ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setImmediate(callback);\n  return () => clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"* <p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setImmediate(callback);\n  return () =&gt; clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setImmediate(callback);\n  return () => clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setImmediate(callback);\n  return () =&gt; clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$LSjwIPu4c4DzODqe0bJiQnYcAAV3dplf9jp33ffSBmw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1737681139239,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$pvj1A3a8KFOQHGza0NZqc2GYyw8_wN45jnyvIogFIck"},
{"content":{"body":"Bikeshedding help requested for an error type that includes properties with how much X is available, versus how much X you requested: https://github.com/whatwg/webidl/issues/1463","m.mentions":{},"msgtype":"m.text"},"ts":1737687958770,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$kWa6E-PdhJuNyKgDbKGhkarnYhSDX7U1HZYYj9kj5fU"},
{"content":{"body":"* ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setTimeout(callback);\n  return () => clearTimeout(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"* <p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setTimeout(callback);\n  return () =&gt; clearTimeout(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setTimeout(callback);\n  return () => clearTimeout(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setTimeout(callback);\n  return () =&gt; clearTimeout(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$LSjwIPu4c4DzODqe0bJiQnYcAAV3dplf9jp33ffSBmw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1737732727997,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$Hy72ArI74KTDcf6ogesLg62i8lXkAUWc5W6AmTfHB3M"},
{"content":{"body":"* ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setTimeout(callback);\n  return () => clearTimeout(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} attempts`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"* <p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setTimeout(callback);\n  return () =&gt; clearTimeout(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} attempts`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n\n```js\nconst enqueueTask = callback => {\n  const id = setTimeout(callback);\n  return () => clearTimeout(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} attempts`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code class=\"language-js\">const enqueueTask = callback =&gt; {\n  const id = setTimeout(callback);\n  return () =&gt; clearTimeout(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const collected = whenCollected(target, data);\n  let retained = true;\n  collected.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { collected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} attempts`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  if (await fastKeyRetainedP) throw Error('fast-gc key was not collected!');\n  if (!(await slowKeyRetainedP)) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  if (await slowKeyStillRetainedP) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$LSjwIPu4c4DzODqe0bJiQnYcAAV3dplf9jp33ffSBmw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1737736749671,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$Z0kSZumMk_tsPxLf-rjj4gAMdmTyCXKZUsEiVM27RoI"},
{"content":{"body":"Hi all!","m.mentions":{},"msgtype":"m.text"},"ts":1737750593492,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$PAAFpb6VaYa-XUut_-MSEThZ93wVU2-y9YRduS4LxqY"},
{"content":{"body":"How would one submit a proposal to TC39?","m.mentions":{},"msgtype":"m.text"},"ts":1737750600541,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$NbN7VJGd2oe7ISqZTA6epYN50XO3kDWXtC-TkVtQlyM"},
{"content":{"body":"https://github.com/tc39/ecma262/blob/main/CONTRIBUTING.md","msgtype":"m.text"},"ts":1737750652349,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$mMzK3K89M4vugZc-VoFODNVsk0vDdbKS0vUmOW0uCRU"},
{"content":{"body":"🤔 I've been going through that, and I see that proposals are separate repos... but... you can't make a PR to submit a whole repo, can you? ","m.mentions":{},"msgtype":"m.text"},"ts":1737750733839,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$p27gWmDCq4qKuzLvjbSNT6XF25hhfs-oZhG4_8uInr4"},
{"content":{"body":"It's related to: https://github.com/matthew-dean/proposal-hash-comments","m.mentions":{},"msgtype":"m.text"},"ts":1737750750189,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$8aVxzzkWer6hNECNIZRVkr2kAmwFq9Q-EqULmdZXnlo"},
{"content":{"body":"yes, proposals are self-contained repos","msgtype":"m.text"},"ts":1737750768158,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$fVK7oiQj0lrR8-p-EBrvFPmL5WPA4IAC8hbcKT5EllA"},
{"content":{"body":"they don't become PRs until much later in the process","msgtype":"m.text"},"ts":1737750775487,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$xc-wqIzWCaLi2QZjryPU53ee5c-swk12iKWvZwnLCFE"},
{"content":{"body":"How would I move this under tc39 tho?","m.mentions":{},"msgtype":"m.text"},"ts":1737750787479,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$nQcZKSrzcvIfmP35x9Gmz7TivR3LFeSxQmqVdApwveo"},
{"content":{"body":"* How would I move this under tc39 though?","m.mentions":{},"m.new_content":{"body":"How would I move this under tc39 though?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$nQcZKSrzcvIfmP35x9Gmz7TivR3LFeSxQmqVdApwveo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1737750800883,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$aJUnKIEUbcdxUF23ZOG6Mot86VhQ7EVIHSjompm9nrs"},
{"content":{"body":"from the CONTRIBUTING.md document,\n\n> If you have a new proposal you want to get into the language, you first need a TC39 \"champion\": a member of the committee who will make the case for the proposal at in-person TC39 meetings and help it move through the process. If you are a TC39 member, you can be a champion; otherwise, find a TC39 member to work with for this (e.g., through the TC39 discussion group or the Matrix chat room). Proposals may have multiple champions (a \"champion group\").","format":"org.matrix.custom.html","formatted_body":"from the CONTRIBUTING.md document,<br/><br/><blockquote data-md=\">\">If you have a new proposal you want to get into the language, you first need a TC39 &quot;champion&quot;: a member of the committee who will make the case for the proposal at in-person TC39 meetings and help it move through the process. If you are a TC39 member, you can be a champion; otherwise, find a TC39 member to work with for this (e.g., through the TC39 discussion group or the Matrix chat room). Proposals may have multiple champions (a &quot;champion group&quot;).<br/></blockquote>","msgtype":"m.text"},"ts":1737750848439,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$06XrIG3vq_QnK_Efad8s94n8L3h53JPhjcmboQdBj0s"},
{"content":{"body":"ah ok","m.mentions":{},"msgtype":"m.text"},"ts":1737750873246,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$7VX36l5WNTe0uNEYOHE-Hp6kDrfk39tRK-VnY_d7Qig"},
{"content":{"body":"So I have to find my champion a la Game of Thrones-style?","m.mentions":{},"msgtype":"m.text"},"ts":1737750883538,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$gKgzqu_KN2inQx9LDvjx8UtXaXlmSBBD4ZI3IZ5gvYg"},
{"content":{"body":"so you'll need to convince at least one delegate that it's worthwhile, and once it has been presented, it will be moved within the TC39 org","msgtype":"m.text"},"ts":1737750902904,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$6rh7VrNdzFzA70LeFgfMLhaeEhvBjBfdVhS-2OiFwSI"},
{"content":{"body":"got it","m.mentions":{},"msgtype":"m.text"},"ts":1737750909676,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$Z93bpDShESWcRcXNDb9twg8dZMg1-UwQrODa9TElJgA"},
{"content":{"body":"not familiar with the GoT process, but you can find champions both on here or on Discourse","msgtype":"m.text"},"ts":1737750925903,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$p6La-AcaXKujE1HPfiLEd23vjnFRHwBNTYe72yL57iA"},
{"content":{"body":"Discourse is probably better since it's less synchronous and less ephemeral","msgtype":"m.text"},"ts":1737750978453,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$0pnBLuySK-7C_tNxCGYWaObbv1A9Cxco5-4E9iyw-zY"},
{"content":{"body":"The Game of Thrones was a dumb joke reference to an episode","m.mentions":{},"msgtype":"m.text"},"ts":1737750982113,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$-CiR81kMtijzJMDwg2_dKn7shXZSA9gzAyo5hQwjoVw"},
{"content":{"body":"But anyway, thanks for the help!","m.mentions":{},"msgtype":"m.text"},"ts":1737751137792,"senderName":"Matthew Dean","senderId":"@matthewdean:matrix.org","id":"$d-fikypzjabPNop4xfUbsmD8jT9sOllhu-WpmozEaY0"},
{"content":{"body":"no problem","msgtype":"m.text"},"ts":1737751422545,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$ZB1qKjJoMgkh_DHFdZ1Y3zEVr0L8IJNN6LeoZRsWuxg"}
]