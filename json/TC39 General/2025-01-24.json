[
{"content":{"body":"ljharb: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:\n```\nconst enqueueTask = callback => {\n  const id = setImmediate(callback);\n  return () => clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) => void callback(data));\nconst whenCollected = (target, data = undefined) =>\n  new Promise(resolve => gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) => {\n  const p = whenCollected(target, data);\n  let retained = true;\n  p.then(() => { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () => whenCollected({}).then().then(() => retained);\n  return { whenCollected, isRetained };\n};\nconst forceCollectionP = (async () => {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () => void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) => {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) => { reject = resolvers[1]; });\n    void pressureP.catch(() => {});\n    let jobCount = 0;\n    let abortNextJob = () => {};\n    const abort = () => {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount < patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount > 1 && garbageScale > 0 && garbageScale < 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() => {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n```","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: I have a not-yet-committed version of what you're looking for; the ultimate fallback really is memory allocations. Simplified version:</p>\n<pre><code>const enqueueTask = callback =&gt; {\n  const id = setImmediate(callback);\n  return () =&gt; clearImmediate(id);\n};\nconst gcWatches = new FinalizationRegistry(([callback, data]) =&gt; void callback(data));\nconst whenCollected = (target, data = undefined) =&gt;\n  new Promise(resolve =&gt; gcWatches.register(target, [resolve, data]));\nconst watchGC = (target, data = undefined) =&gt; {\n  const p = whenCollected(target, data);\n  let retained = true;\n  p.then(() =&gt; { retained = false; });\n  // Return a new promise that waits for GC plus a turn (in case the GC promise\n  // of the new sentinel object fulfills before that of the target) and then\n  // fulfills with the then-current retention status of the target.\n  const isRetained = () =&gt; whenCollected({}).then().then(() =&gt; retained);\n  return { whenCollected, isRetained };\n};\nconst forceCollectionP = (async () =&gt; {\n  let garbageScale = 2 ** 16;\n  const tryTriggerGC = () =&gt; void new Uint8Array(garbageScale);\n  const forceGC = async (patience = 1000) =&gt; {\n    const sentinelCollectedP = whenCollected({});\n\n    // Wait a turn to clear the stack, then add pressure in a sequence of prompt jobs.\n    await null;\n    let reject;\n    const pressureP = new Promise((...resolvers) =&gt; { reject = resolvers[1]; });\n    void pressureP.catch(() =&gt; {});\n    let jobCount = 0;\n    let abortNextJob = () =&gt; {};\n    const abort = () =&gt; {\n      abortNextJob();\n      reject();\n      patience = 0;\n    };\n    (function startNextJob() {\n      if (!(jobCount &lt; patience)) return reject(Error(`failed to GC after ${jobCount} jobs`));\n      tryTriggerGC();\n      jobCount++;\n      abortNextJob = enqueueTask(startNextJob);\n    })();\n    await Promise.race([sentinelCollectedP, pressureP]);\n    abort();\n\n    // Try to tune garbageScale for forcing GC in one job.\n    if (jobCount &gt; 1 &amp;&amp; garbageScale &gt; 0 &amp;&amp; garbageScale &lt; 2 ** 28) garbageScale *= 2;\n\n    return { jobCount };\n  };\n\n  // Run sanity checks before releasing the function.\n  await forceGC();\n  const weakmap = new WeakMap();\n  let { fastKeyWatch, slowKeyWatch, slowKey } = (() =&gt; {\n    const fastKey = {};\n    const slowKey = {};\n    weakmap.set(fastKey, 'fast-gc sanity check');\n    weakmap.set(slowKey, 'slow-gc sanity check');\n    const fastKeyWatch = watchGC(fastKey);\n    const slowKeyWatch = watchGC(slowKey);\n    return { fastKeyWatch, slowKeyWatch, slowKey };\n  })();\n  const fastKeyRetainedP = fastKeyWatch.isRetained();\n  const slowKeyRetainedP = slowKeyWatch.isRetained();\n  await forceGC();\n  const fastKeyRetained = await fastKeyRetainedP;\n  if (fastKeyRetained) throw Error('fast-gc key was not collected!');\n  const slowKeyRetained = await slowKeyRetainedP;\n  if (!slowKeyRetained) throw Error('slow-gc key was collected early!');\n  const slowKeyStillRetainedP = slowKeyWatch.isRetained();\n  slowKey = null;\n  await forceGC();\n  const slowKeyStillRetained = await slowKeyStillRetainedP;\n  if (slowKeyStillRetained) throw Error('slow-gc key was not collected!');\n\n  return forceGC;\n})();\n\nconst forceGC = await forceCollectionP;\n</code></pre>\n","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"msgtype":"m.text"},"ts":1737679725463,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$LSjwIPu4c4DzODqe0bJiQnYcAAV3dplf9jp33ffSBmw"}
]