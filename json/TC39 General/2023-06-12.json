[
{"content":{"body":"I lost so much time today due to an unhandled rejection from a `promise.finally()` call","format":"org.matrix.custom.html","formatted_body":"I lost so much time today due to an unhandled rejection from a <code>promise.finally()</code> call","msgtype":"m.text"},"ts":1686603406412,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$vfN9nplWxXGYqaZkHDlXZuDTrbI1rKhcaY7TPk4QHp0"},
{"content":{"body":"The `promise` itself was handled, but the new one doesn't inherit that state.","format":"org.matrix.custom.html","formatted_body":"The <code>promise</code> itself was handled, but the new one doesn't inherit that state.","msgtype":"m.text"},"ts":1686603426080,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$W7RY8dBQWozek0-TjdFjBsgjvly26xduiqMWYbSeJ_M"},
{"content":{"body":"Is this an isolated example of the problem you observed? `Promise.reject(new Error('Bad from the start')).finally(() => Promise.reject(new Error('Got worse')))`, where the unhandled rejection is `Got worse`?","format":"org.matrix.custom.html","formatted_body":"Is this an isolated example of the problem you observed? <code>Promise.reject(new Error('Bad from the start')).finally(() =&gt; Promise.reject(new Error('Got worse')))</code>, where the unhandled rejection is <code>Got worse</code>?","msgtype":"m.text"},"ts":1686603693008,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$u4Puwy_IXQ0X48FosR_A4k197dt_Qx5LugchVtLSQDc"},
{"content":{"body":"And you lost time, I presume, because `Bad from the start` was the problem hiding behind the error?","format":"org.matrix.custom.html","formatted_body":"And you lost time, I presume, because <code>Bad from the start</code> was the problem hiding behind the error?","msgtype":"m.text"},"ts":1686603762679,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$ul-7SYiNcWxiMwLswFwGiiWD8E2_vHYzUxrnhQ5KC1I"},
{"content":{"body":"If thatâ€™s the case, perhaps the mitigation is for `finally` to produce an `AggregateError`.","format":"org.matrix.custom.html","formatted_body":"If thatâ€™s the case, perhaps the mitigation is for <code>finally</code> to produce an <code>AggregateError</code>.","msgtype":"m.text"},"ts":1686603842497,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$DL52YAd_5_D4WhE-3ncB5oZJyyA_jswsrW63UcVx_VE"},
{"content":{"body":"Would be great if that was web compat","msgtype":"m.text"},"ts":1686604927890,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$q6JbDX6sB1yDp0zLOdlKROhrXxyvZZVMca0o5E5iCnY"},
{"content":{"body":"Maybe there is a way to thread that finally rejection to the unhandled exception handler, while preserving the current finally semantics of .then ","format":"org.matrix.custom.html","formatted_body":"Maybe there is a way to thread that finally rejection to the unhandled exception handler, while preserving the current finally semantics of .then","msgtype":"m.text"},"ts":1686605024070,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$YA3n72upeH4XPUU3al4ZVkL63WuzXNzFx2FQLiMxZlw"},
{"content":{"body":"If want to be more compat ","format":"org.matrix.custom.html","formatted_body":"If want to be more compat","msgtype":"m.text"},"ts":1686605034663,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$WLi-DLaq232OHxuU6frHtH8Yh2o500aD70P_fV8SbFE"},
{"content":{"body":"Orâ€¦drumrollâ€¦ `promise.finalÃ©()`","format":"org.matrix.custom.html","formatted_body":"Orâ€¦drumrollâ€¦ <code>promise.finalÃ©()</code>","msgtype":"m.text"},"ts":1686605046598,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$8U3jXfCrfmBCUNps7RM2-Vi2t4H62s_e_79wO5qiCXk"},
{"content":{"body":"or just `.fin` ðŸŽ¥ ","format":"org.matrix.custom.html","formatted_body":"or just <code>.fin</code> ðŸŽ¥","msgtype":"m.text"},"ts":1686605079580,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$0WMyWip-wEiZKUDNo-z-qm5z9mwsyiGuNwviOeLhhjs"},
{"content":{"body":"Hah. Q predated Dougâ€™s initiative to make keywords valid property names, so I did call it `fin` in the earliest versions, and itâ€™s still there for back-compat.","format":"org.matrix.custom.html","formatted_body":"Hah. Q predated Dougâ€™s initiative to make keywords valid property names, so I did call it <code>fin</code> in the earliest versions, and itâ€™s still there for back-compat.","msgtype":"m.text"},"ts":1686605137936,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$iFttzun4LjOgq_E1SVYFCu1HsgXWUG2oNVJPX2tq-QI"},
{"content":{"body":"Shunting the antecedent error out to unhandled rejection handler is a bandaid I can support, but that effectively means deprecating `finally`, since breaking the causal chain is bad in general.","format":"org.matrix.custom.html","formatted_body":"Shunting the antecedent error out to unhandled rejection handler is a bandaid I can support, but that effectively means deprecating <code>finally</code>, since breaking the causal chain is bad in general.","msgtype":"m.text"},"ts":1686605278601,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$wIpws0kXsaTTlMRCpa5L5_NFmiq_guqDCDJQKc96RPk"},
{"content":{"body":"There really needs to be a way for both errors to flow through the output promise.","msgtype":"m.text"},"ts":1686605302377,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$4U_mQPJO74CyfoP-kqkixjhIl36xDWrI0383tYJFNIU"},
{"content":{"body":"And as long as weâ€™re talking history, if Iâ€™d made Q _after_ Doug won keywordly-named properties, I would have been tempted to name `resolve` and `reject` as `return` and `throw`.","format":"org.matrix.custom.html","formatted_body":"And as long as weâ€™re talking history, if Iâ€™d made Q <em>after</em> Doug won keywordly-named properties, I would have been tempted to name <code>resolve</code> and <code>reject</code> as <code>return</code> and <code>throw</code>.","msgtype":"m.text"},"ts":1686605391431,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$tkQs_DlZ5pSZLmRA8YzJjBlLQsykBPnLtiBQ4slbFIg"},
{"content":{"body":"wait Justin Ridgewell was the problem that `finally` swallowed the error from the original `promise`, or that you had an error thrown in your `finally` handler and you didn't handle that error, only errors on the original `promise`?","format":"org.matrix.custom.html","formatted_body":"wait <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> was the problem that <code>finally</code> swallowed the error from the original <code>promise</code>, or that you had an error thrown in your <code>finally</code> handler and you didn't handle that error, only errors on the original <code>promise</code>?","msgtype":"m.text"},"ts":1686605402184,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Op1qIqXWFr26vZ2APaixJAgAbjbfXzwUwepu-eiihDs"},
{"content":{"body":"And then weâ€™d be living in a world where itâ€™s obvious that Promises are just a degenerate AsyncIterators.","msgtype":"m.text"},"ts":1686605428158,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$e5ONLG40AAkQt-HFWYaG74U1r-F3XANHjPNRoCmy0vs"},
{"content":{"body":"```\nconst promise = Promise.reject();\npromise.catch(() => { /* handled */ });\npromise.finally(() => {}) // new promise is unhandled\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>const promise = Promise.reject();\npromise.catch(() =&gt; { /* handled */ });\npromise.finally(() =&gt; {}) // new promise is unhandled\n</code></pre>\n","msgtype":"m.text"},"ts":1686605485872,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Vyz3TUtpc7yNOVzAEq5d6xTKG7mJYAgi2BX7gega6f0"},
{"content":{"body":"ah yeah","msgtype":"m.text"},"ts":1686605511892,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$R4k4-hzyLnMNUauJU_sAg5chG1lpVYfWGGLdVZV-hBE"},
{"content":{"body":"that one is tricky","msgtype":"m.text"},"ts":1686605514966,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$XTwdn9cCDqcDNzCyDG8mbEAscsFkIFHnWTBoEubQPEU"},
{"content":{"body":"It's _not_ equivalent to\n```\ntry {\n  try { await promise }\n  catch { /* handled */ } \n} finally {\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>It's <em>not</em> equivalent to</p>\n<pre><code>try {\n  try { await promise }\n  catch { /* handled */ } \n} finally {\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1686605578491,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$9dvwzniiwMRs33hR02dch2bsOs3CM8juf6x4prwjLwI"},
{"content":{"body":"Which is the behavior I wanted","msgtype":"m.text"},"ts":1686605595555,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$lbMeY7TqxyxjZC7k-vd68eSztNoDc5wVD7X3V0vQn1g"},
{"content":{"body":"So, `promise.catch().finally()` would have done the job.","format":"org.matrix.custom.html","formatted_body":"So, <code>promise.catch().finally()</code> would have done the job.","msgtype":"m.text"},"ts":1686605630080,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$8vYXOdU_H-HEYllt_VQqMXjgrF3Cvvv8EcuSyfsZ5fQ"},
{"content":{"body":"Yup, but my catch and finally aren't in the same file","msgtype":"m.text"},"ts":1686605653382,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$XTmUOEI5RLvf9igPK0Ke9GzGKdyLjmPQi8yRuO4bn7g"},
{"content":{"body":"This is I think a case where promises are working as designed, but we need to promote a culture of not dropping promises, and linting for dropped promises. Thatâ€™s a bit of a tall order at the moment, since you need something like the TypeScript compiler to find them.","msgtype":"m.text"},"ts":1686605752785,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$O5CZPnt08QYuaLxJ1PLYIACGoicRJdUvbMyxHitATmQ"},
{"content":{"body":"Weâ€™ve used an eslint rule for this at Agoric, but because itâ€™s driven by eslint and not tsc, thereâ€™s a great deal of duplicative effort in return type inference, so itâ€™s way too slow.","msgtype":"m.text"},"ts":1686605847238,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$tJJoBN0dEVhH-CCwD8mdf9_CsGb7Wfm4-GthlFviAAQ"},
{"content":{"body":"TS doesn't currently have a \"must use\" annotation","msgtype":"m.text"},"ts":1686606284305,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ajoLoGpURxHIYkzvJDeGdVmuRhwlMOZ-PXiCLVNru2c"},
{"content":{"body":"so even TS is not sufficient on its own","msgtype":"m.text"},"ts":1686606293313,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$fuU1SF3rH_PvSw3aod7_qqMjXpd627tiVsgB4RjNrFw"},
{"content":{"body":"also there's a fundamental problem where any promise handler can throw, and then you have to handle that also","msgtype":"m.text"},"ts":1686606311715,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$DCw4R4aWNIPA6DRDzulb_GMFCoq9oGgOHfs39NVN4xk"},
{"content":{"body":"like just `asyncFn()` is a bug because you don't handle exceptions, but `asyncFn().catch()` might also be a bug because you don't handle exceptions in the `catch` handler, and so on unto infinity","format":"org.matrix.custom.html","formatted_body":"like just <code>asyncFn()</code> is a bug because you don't handle exceptions, but <code>asyncFn().catch()</code> might also be a bug because you don't handle exceptions in the <code>catch</code> handler, and so on unto infinity","msgtype":"m.text"},"ts":1686606351026,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$exwY69xiD40HNf4Pz0QtiHxgQtKXRykRhPNTe42SEz4"},
{"content":{"body":"TypeScript at least knows that `() => {}` will not throw.","format":"org.matrix.custom.html","formatted_body":"TypeScript at least knows that <code>() =&gt; {}</code> will not throw.","msgtype":"m.text"},"ts":1686606412585,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$OMnKx3Udn37dryGYb4PuSSjmFCsoK2fIRcKkzT0VSsw"},
{"content":{"body":"But yes, no amount of rigor will eliminate the need for UnhandledRejection reports.","msgtype":"m.text"},"ts":1686606458538,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$H2V4xj67SZOsaqEilpVLcpyDzz_9fiRQx8u5Ed8Kjm8"},
{"content":{"body":"And even TypeScript canâ€™t help you if your handler throws a `RangeError`.","format":"org.matrix.custom.html","formatted_body":"And even TypeScript canâ€™t help you if your handler throws a <code>RangeError</code>.","msgtype":"m.text"},"ts":1686606494420,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$RcgrkOefwKN15ZeZpiTlH8twY_mtTN_8QsSXyL3Wg1g"},
{"content":{"body":"> <@bakkot:matrix.org> TS doesn't currently have a \"must use\" annotation\n\nTo be clear, TypeScript + ESlint are able to check for dropped promises, but in this form, itâ€™s just too slow. https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-floating-promises.md","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$ajoLoGpURxHIYkzvJDeGdVmuRhwlMOZ-PXiCLVNru2c?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>TS doesn&#39;t currently have a &quot;must use&quot; annotation</blockquote></mx-reply>To be clear, TypeScript + ESlint are able to check for dropped promises, but in this form, itâ€™s just too slow. https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-floating-promises.md","m.relates_to":{"m.in_reply_to":{"event_id":"$ajoLoGpURxHIYkzvJDeGdVmuRhwlMOZ-PXiCLVNru2c"}},"msgtype":"m.text"},"ts":1686606640116,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$vh-5EvZX9pKN0Ryx1G9Lp7UHwNcs_ZmFQL6Gg-2jzkU"},
{"content":{"body":"And that is quite good at halting at a handler that has done everything in its power to ensure no exceptions go unhandled.","msgtype":"m.text"},"ts":1686606732615,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$EOaxQJ9hr9UIcuO6f4kxVynXDmwONRh-TvQRFhX506U"}
]