[
{"content":{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","mimetype":"text/html"}]},"ts":1670457609002,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$qobKeze0Vd2WINKLh3zhIAKxnFHOGpZvO0QTcsOzvO0"},
{"content":{"body":" * bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","m.new_content":{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$qobKeze0Vd2WINKLh3zhIAKxnFHOGpZvO0QTcsOzvO0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","mimetype":"text/plain"},{"body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","mimetype":"text/html"}]},"ts":1670457637868,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$Wld9gVI4XYBXyl83q9JL55dIfICzpVQKjXVSvOmwjdg"},
{"content":{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","format":"org.matrix.custom.html","formatted_body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/plain"},{"body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/html"}]},"ts":1670457802442,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$rXwu7rrVyhHxsmPqqEcmnqEojmtezhDsH6aUqgR3-w8"},
{"content":{"body":" * @tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","format":"org.matrix.custom.html","formatted_body":" * @tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","m.new_content":{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","format":"org.matrix.custom.html","formatted_body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/plain"},{"body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$rXwu7rrVyhHxsmPqqEcmnqEojmtezhDsH6aUqgR3-w8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * @tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/plain"},{"body":" * @tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/html"}]},"ts":1670457841370,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$8bBVBh7VeOKwh6gzoln5L-i8rnOfsbbKghXjflOZ-qA"},
{"content":{"body":"See also https://github.com/tc39/ecma262/issues/1540 and the https://github.com/tc39/how-we-work/pull/64 that it links to.","msgtype":"m.text","org.matrix.msc1767.text":"See also https://github.com/tc39/ecma262/issues/1540 and the https://github.com/tc39/how-we-work/pull/64 that it links to."},"ts":1670458039738,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$aW3GuSUgbFgKF6ybmuMo106FK2143oCyGGo8hc-WCuo"},
{"content":{"body":"sirisian: a number of programming languages use the type of the position to determine the type of literals in that position, yes","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: a number of programming languages use the type of the position to determine the type of literals in that position, yes","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"sirisian: a number of programming languages use the type of the position to determine the type of literals in that position, yes","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: a number of programming languages use the type of the position to determine the type of literals in that position, yes","mimetype":"text/html"}]},"ts":1670458127334,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$54oZk5wLN04Ab0EuK3L0hmTwuUAWMQT5eF6wzyvRYwo"},
{"content":{"body":"Which languages?","msgtype":"m.text","org.matrix.msc1767.text":"Which languages?"},"ts":1670458160625,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$nI_lyoJYHZajhPssbW-hkbg0pl5ejw0Z3Ke8KcTQlVc"},
{"content":{"body":"offhand, C++?","msgtype":"m.text","org.matrix.msc1767.text":"offhand, C++?"},"ts":1670458266007,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$plM9iVDujQRTLkGzP-vmtDM-xZBMcq8kzU_0ZPJhssk"},
{"content":{"body":"tolmasky: Also https://github.com/tc39/ecma262/issues/2608","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@tolmasky:matrix.org\">tolmasky</a>: Also https://github.com/tc39/ecma262/issues/2608","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"tolmasky: Also https://github.com/tc39/ecma262/issues/2608","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@tolmasky:matrix.org\">tolmasky</a>: Also https://github.com/tc39/ecma262/issues/2608","mimetype":"text/html"}]},"ts":1670458266928,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$hX18Q3WAcfUiQBYA34fEdJ79t39pIGgBFqeTfm6Vibk"},
{"content":{"body":"though I guess that's not _quite_ how it works in C++","format":"org.matrix.custom.html","formatted_body":"though I guess that's not <em>quite</em> how it works in C++","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"though I guess that's not _quite_ how it works in C++","mimetype":"text/plain"},{"body":"though I guess that's not <em>quite</em> how it works in C++","mimetype":"text/html"}]},"ts":1670458272742,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BonTxJ0Mgj0XcNJu8o5pj8BI5PeA1fhnvdn1y80JES8"},
{"content":{"body":"it just has implicit conversions","msgtype":"m.text","org.matrix.msc1767.text":"it just has implicit conversions"},"ts":1670458289918,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$bAQ0ZYoBqMeQsK7b1ICUYnW-aYwu5FNCJfDbV_lpqZ4"},
{"content":{"body":"but it amounts to much the same thing","msgtype":"m.text","org.matrix.msc1767.text":"but it amounts to much the same thing"},"ts":1670458296415,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$-IYD2l_t4JkUjCKC9irJnNW-aZVQMo0OyoLlIzyvG5A"},
{"content":{"body":"Rust, also","msgtype":"m.text","org.matrix.msc1767.text":"Rust, also"},"ts":1670458363243,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$l_UDW6j12VjXsnXG8FyhdEDIXEA9koK4uH4Qa0tebbQ"},
{"content":{"body":"https://doc.rust-lang.org/reference/expressions/literal-expr.html#integer-literal-expressions","msgtype":"m.text","org.matrix.msc1767.text":"https://doc.rust-lang.org/reference/expressions/literal-expr.html#integer-literal-expressions"},"ts":1670458415903,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cqJIux5BnHCgwJMT7tZChoy4clX3H6BzUtPwSfPOdEg"},
{"content":{"body":"> If the token has no suffix, the expression's type is determined by type inference:\n> If an integer type can be uniquely determined from the surrounding program context, the expression has that type","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>If the token has no suffix, the expression's type is determined by type inference:<br>If an integer type can be uniquely determined from the surrounding program context, the expression has that type</p>\n</blockquote>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> If the token has no suffix, the expression's type is determined by type inference:\n> If an integer type can be uniquely determined from the surrounding program context, the expression has that type","mimetype":"text/plain"},{"body":"<blockquote>\n<p>If the token has no suffix, the expression's type is determined by type inference:<br>If an integer type can be uniquely determined from the surrounding program context, the expression has that type</p>\n</blockquote>\n","mimetype":"text/html"}]},"ts":1670458429124,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$OD7K2VFAEi7xgBAn7FdTBHW1T0hd23XYhL4vBTSeDuw"},
{"content":{"body":"Yeah, but you can't type a 100 digit number. The maximum literal it has is i128 and u128 suffixes?","msgtype":"m.text","org.matrix.msc1767.text":"Yeah, but you can't type a 100 digit number. The maximum literal it has is i128 and u128 suffixes?"},"ts":1670458477259,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$y0DQs0PUU6eg8AtOa7AVfjqFQOGune8PeyBvQZ4SUuA"},
{"content":{"body":"It is true that Rust's integer types are bounded; I don't understand what relevance that has to anything?","msgtype":"m.text","org.matrix.msc1767.text":"It is true that Rust's integer types are bounded; I don't understand what relevance that has to anything?"},"ts":1670458522666,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$G0FZYeki5L2eT3D5hySseGt6ETstCoyHhYACRV1NnRM"},
{"content":{"body":"The example you gave also had a bounded integer type","msgtype":"m.text","org.matrix.msc1767.text":"The example you gave also had a bounded integer type"},"ts":1670458540431,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Ff7kcQu6boTWikVYJiUAk80JMlwKQwMu41xjgKHSj_k"},
{"content":{"body":"yes, for the basic one. Inside of the issue I wanted this to work seamlessly for BigInt as well.","msgtype":"m.text","org.matrix.msc1767.text":"yes, for the basic one. Inside of the issue I wanted this to work seamlessly for BigInt as well."},"ts":1670458611944,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$l_ufw126-yWjmoFZRTe2gnn68tG_crWDKK2OHL83pCQ"},
{"content":{"body":"Essentially a system where suffixes are never necessary. (Though some might find them simpler than casting?)","msgtype":"m.text","org.matrix.msc1767.text":"Essentially a system where suffixes are never necessary. (Though some might find them simpler than casting?)"},"ts":1670458650053,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$Sgt4_fBYyrxWrOfln4mkS5VrHm0CJt3T-vUc9I3162k"},
{"content":{"body":"I'm still not clear on what the relevance of integer types in Rust being bounded is.","msgtype":"m.text","org.matrix.msc1767.text":"I'm still not clear on what the relevance of integer types in Rust being bounded is."},"ts":1670458692227,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$vCQmF0TD8y6_Ou7DYlK6Ft6tMes-hFJNrS7Kjxfl-zM"},
{"content":{"body":"As it says, \"If an integer type can be uniquely determined from the surrounding program context, the expression has that type\"","msgtype":"m.text","org.matrix.msc1767.text":"As it says, \"If an integer type can be uniquely determined from the surrounding program context, the expression has that type\""},"ts":1670458701129,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$NNkflid0FvfwZhPO9HP2A8DrOKZjmjvVTm97GXnfWX8"},
{"content":{"body":"it's not based on how long the integer literal is, it's based on _the surrounding program context_","format":"org.matrix.custom.html","formatted_body":"it's not based on how long the integer literal is, it's based on <em>the surrounding program context</em>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"it's not based on how long the integer literal is, it's based on _the surrounding program context_","mimetype":"text/plain"},{"body":"it's not based on how long the integer literal is, it's based on <em>the surrounding program context</em>","mimetype":"text/html"}]},"ts":1670458720085,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$c1BPZOorVeZCekwLa6VnlpYkujP-yvXt1IDtL5w6Bn4"},
{"content":{"body":"so in principle they could have a BigInt type, and if you wrote `let x: BigInt = 0`, then that `0` would unambiguously be a bigint 0, so that's how it would be intepreted","format":"org.matrix.custom.html","formatted_body":"so in principle they could have a BigInt type, and if you wrote <code>let x: BigInt = 0</code>, then that <code>0</code> would unambiguously be a bigint 0, so that's how it would be intepreted","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"so in principle they could have a BigInt type, and if you wrote `let x: BigInt = 0`, then that `0` would unambiguously be a bigint 0, so that's how it would be intepreted","mimetype":"text/plain"},{"body":"so in principle they could have a BigInt type, and if you wrote <code>let x: BigInt = 0</code>, then that <code>0</code> would unambiguously be a bigint 0, so that's how it would be intepreted","mimetype":"text/html"}]},"ts":1670458749960,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$roOiZmvgg1wuksaLQ_L5vVNYP_J6ZC47tsu5wE1gbzA"},
{"content":{"body":"bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/html"}]},"ts":1670459300742,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$tgUvs9VMUdmTBIrO-89xGoRhxRXEIDMDmAUw1eI39CA"},
{"content":{"body":" * bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","m.new_content":{"body":"bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$tgUvs9VMUdmTBIrO-89xGoRhxRXEIDMDmAUw1eI39CA","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/plain"},{"body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/html"}]},"ts":1670459363224,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$8lWiVSzQMW9IbYo88pmRmMAztlwVxqjDGT_ScXkhxlY"},
{"content":{"body":"Yeah, ChatGPT uses parse_bytes to write this. It can code Rust better than me already.","msgtype":"m.text","org.matrix.msc1767.text":"Yeah, ChatGPT uses parse_bytes to write this. It can code Rust better than me already."},"ts":1670459461964,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$IptqXk0kbl2IRShSaLh8y2uPMZV9p9L-FhD5aoO2Owg"},
{"content":{"body":"Yeah that's not a fundamental limitation, that's just because rust does not have BigInts built in","msgtype":"m.text","org.matrix.msc1767.text":"Yeah that's not a fundamental limitation, that's just because rust does not have BigInts built in"},"ts":1670459553220,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$KrcLl8PqBMKjK_-ydog9RqHDpDzPzYMtfQLXt0LyPtw"},
{"content":{"body":"they could have if they wanted to, it's not a fundamental limitation","msgtype":"m.text","org.matrix.msc1767.text":"they could have if they wanted to, it's not a fundamental limitation"},"ts":1670459565792,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Oc0ryHCmkuhjF6zReD7_IstFMmmivVpEiiEQIv5t5Nc"},
{"content":{"body":"There is nothing that makes `let x: u64 = 0` any easier to infer than `let x: BigInt = 0` would be","format":"org.matrix.custom.html","formatted_body":"There is nothing that makes <code>let x: u64 = 0</code> any easier to infer than <code>let x: BigInt = 0</code> would be","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"There is nothing that makes `let x: u64 = 0` any easier to infer than `let x: BigInt = 0` would be","mimetype":"text/plain"},{"body":"There is nothing that makes <code>let x: u64 = 0</code> any easier to infer than <code>let x: BigInt = 0</code> would be","mimetype":"text/html"}]},"ts":1670459616404,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$87DHPf--4JBdcm02dQz5cHbssOOc-j8ROdzhybU_Czs"},
{"content":{"body":"Gotcha. Okay that's promising then. Thank you. This is really easy btw if I'm not the one implementing anything.","msgtype":"m.text","org.matrix.msc1767.text":"Gotcha. Okay that's promising then. Thank you. This is really easy btw if I'm not the one implementing anything."},"ts":1670459661039,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$n4zC8T7M8N6r6PH36hsDX1aC1yyvQbbKyQx8HUzjv0A"},
{"content":{"body":"to be clear I should emphasize that engines are almost certainly not going to have built-in type checking, ever","msgtype":"m.text","org.matrix.msc1767.text":"to be clear I should emphasize that engines are almost certainly not going to have built-in type checking, ever"},"ts":1670459704003,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$1P9H1mYRO6AEcZ9cdGtiUuQh5r9en8mDra6BpTXA4cU"},
{"content":{"body":"yeah, this has turned into more a thought experiment for me to unwind lately while watching TV.","msgtype":"m.text","org.matrix.msc1767.text":"yeah, this has turned into more a thought experiment for me to unwind lately while watching TV."},"ts":1670459754851,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$DSyvHlnvPOywjJyL1SjTXwmmUdvuqPUQbNYYYIprpiQ"},
{"content":{"body":"gotcha","msgtype":"m.text","org.matrix.msc1767.text":"gotcha"},"ts":1670459759705,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ueGgG1WIJo612e2Ql0KRah6C_a46OixKqkA3etUv72o"},
{"content":{"body":"yeah looking at how other languages do type inference will probably be interesting to you then","msgtype":"m.text","org.matrix.msc1767.text":"yeah looking at how other languages do type inference will probably be interesting to you then"},"ts":1670459782360,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$SJS8HxpT90_cOgaEwAWcbTSqKpj78AZqvOv40dzQIi4"},
{"content":{"body":"Yeah, was researching other languages the other day and found out Swift has return type overloads. Was thinking it would be too difficult or weird for a language to have those. https://github.com/sirisian/ecmascript-types/issues/78","msgtype":"m.text","org.matrix.msc1767.text":"Yeah, was researching other languages the other day and found out Swift has return type overloads. Was thinking it would be too difficult or weird for a language to have those. https://github.com/sirisian/ecmascript-types/issues/78"},"ts":1670459867507,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$37cFKej8bwhJQnGvkKzN8l-u4GP6q2LuwWRO5-FqZoA"},
{"content":{"body":"(Though you can do something similar in a weird way in C++ that I never thought of)","msgtype":"m.text","org.matrix.msc1767.text":"(Though you can do something similar in a weird way in C++ that I never thought of)"},"ts":1670459963855,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$VcmXyiY1nAdOA6eAaajY1nUcVQHIlyImHNNbgn8cZlU"},
{"content":{"body":"Richard Gibson: hm we should've put https://github.com/tc39/proposal-json-parse-with-source/issues/39 and https://github.com/tc39/proposal-json-parse-with-source/issues/35 on the agenda. the current draft spec can't be implemented","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@gibson042:matrix.org\">Richard Gibson</a>: hm we should've put https://github.com/tc39/proposal-json-parse-with-source/issues/39 and https://github.com/tc39/proposal-json-parse-with-source/issues/35 on the agenda. the current draft spec can't be implemented","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Richard Gibson: hm we should've put https://github.com/tc39/proposal-json-parse-with-source/issues/39 and https://github.com/tc39/proposal-json-parse-with-source/issues/35 on the agenda. the current draft spec can't be implemented","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@gibson042:matrix.org\">Richard Gibson</a>: hm we should've put https://github.com/tc39/proposal-json-parse-with-source/issues/39 and https://github.com/tc39/proposal-json-parse-with-source/issues/35 on the agenda. the current draft spec can't be implemented","mimetype":"text/html"}]},"ts":1670461681600,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$RixykE2yjvqHseEjH1_pE6TDdNXQWp_4XxA5irs_RkU"},
{"content":{"body":"yep, I'm commenting now","msgtype":"m.text","org.matrix.msc1767.text":"yep, I'm commenting now"},"ts":1670461699142,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$elfOs5xunhfxHJfnGYN8livKctZWR5QRigF_QgKQ_Q0"},
{"content":{"body":"and will have a normative fix for discussion in January","msgtype":"m.text","org.matrix.msc1767.text":"and will have a normative fix for discussion in January"},"ts":1670461715912,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$M8w_KKE7Lea-ognRgvbktrGRFcRr0KtdoNRoxJtMrm8"},
{"content":{"body":" * and will have a normative fix for discussion in January","m.new_content":{"body":"and will have a normative fix for discussion in January","msgtype":"m.text","org.matrix.msc1767.text":"and will have a normative fix for discussion in January"},"m.relates_to":{"event_id":"$M8w_KKE7Lea-ognRgvbktrGRFcRr0KtdoNRoxJtMrm8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * and will have a normative fix for discussion in January"},"ts":1670461723456,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$-FXCpjwVjP7YKp66MwQzYDnY-Kas3DbY-tMZDBlROlU"},
{"content":{"body":"excellent, thank you","msgtype":"m.text","org.matrix.msc1767.text":"excellent, thank you"},"ts":1670461753704,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Us39bxlEydfvwNNy7VsVKxtHjDj3Vt6hq1_uruU-Wc8"},
{"content":{"body":"> <@kriskowal:matrix.org> MarkM begs a distinction between intrinsics and his own invention of “primordial” that I cannot explain, but the distinction might be germane here.\n\nKris Kowal tolmasky: https://github.com/tc39/how-we-work/blob/main/terminology.md#primordial","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$QqY3KVBizfxulat2t2xOj4GBBYHBkvkvan7WvJeY4z0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>MarkM begs a distinction between intrinsics and his own invention of “primordial” that I cannot explain, but the distinction might be germane here.</blockquote></mx-reply><a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a> <a href=\"https://matrix.to/#/@tolmasky:matrix.org\">tolmasky</a>: https://github.com/tc39/how-we-work/blob/main/terminology.md#primordial","m.relates_to":{"m.in_reply_to":{"event_id":"$QqY3KVBizfxulat2t2xOj4GBBYHBkvkvan7WvJeY4z0"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> MarkM begs a distinction between intrinsics and his own invention of “primordial” that I cannot explain, but the distinction might be germane here.\n\nKris Kowal tolmasky: https://github.com/tc39/how-we-work/blob/main/terminology.md#primordial","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$QqY3KVBizfxulat2t2xOj4GBBYHBkvkvan7WvJeY4z0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>MarkM begs a distinction between intrinsics and his own invention of “primordial” that I cannot explain, but the distinction might be germane here.</blockquote></mx-reply><a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a> <a href=\"https://matrix.to/#/@tolmasky:matrix.org\">tolmasky</a>: https://github.com/tc39/how-we-work/blob/main/terminology.md#primordial","mimetype":"text/html"}]},"ts":1670461828843,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$-_5DO0wCc0nyrN8wBkv8nYeGZpwYE4O3srqpGY8qzfA"},
{"content":{"body":"It's somewhat strange, because that definition refers to intrinsics as *values*, whereas above it was stated that Number.MAX_SAFE_INTEGER was an intrinsic, implying that there is kind of a dual definition, where it kind of also refers to *keypaths*. That is to say, clearly the %Array% function itself is a intrinsic, like if I were making a Map of intrinsics to their \"names\", but it would be weird to say the number 4 is also an intrinsic, just because %Uint32Array.prototype.BYTES_PER_ELEMENT% holds a 4.","format":"org.matrix.custom.html","formatted_body":"It's somewhat strange, because that definition refers to intrinsics as <em>values</em>, whereas above it was stated that Number.MAX_SAFE_INTEGER was an intrinsic, implying that there is kind of a dual definition, where it kind of also refers to <em>keypaths</em>. That is to say, clearly the %Array% function itself is a intrinsic, like if I were making a Map of intrinsics to their &quot;names&quot;, but it would be weird to say the number 4 is also an intrinsic, just because %Uint32Array.prototype.BYTES_PER_ELEMENT% holds a 4.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"It's somewhat strange, because that definition refers to intrinsics as *values*, whereas above it was stated that Number.MAX_SAFE_INTEGER was an intrinsic, implying that there is kind of a dual definition, where it kind of also refers to *keypaths*. That is to say, clearly the %Array% function itself is a intrinsic, like if I were making a Map of intrinsics to their \"names\", but it would be weird to say the number 4 is also an intrinsic, just because %Uint32Array.prototype.BYTES_PER_ELEMENT% holds a 4.","mimetype":"text/plain"},{"body":"It's somewhat strange, because that definition refers to intrinsics as <em>values</em>, whereas above it was stated that Number.MAX_SAFE_INTEGER was an intrinsic, implying that there is kind of a dual definition, where it kind of also refers to <em>keypaths</em>. That is to say, clearly the %Array% function itself is a intrinsic, like if I were making a Map of intrinsics to their &quot;names&quot;, but it would be weird to say the number 4 is also an intrinsic, just because %Uint32Array.prototype.BYTES_PER_ELEMENT% holds a 4.","mimetype":"text/html"}]},"ts":1670505128061,"senderName":"tolmasky","senderId":"@tolmasky:matrix.org","id":"$Q2gsVBksO-LaDGigEcDroAXAKgIIehzJtop_WY0rF0g"},
{"content":{"body":"that's an interesting distinction, but I think the claim that Number.MAX_SAFE_INTEGER is an intrinsic is just technically inaccurate. _%Number%_ is an intrinsic object, and its primordial state includes a property named \"MAX_SAFE_INTEGER\" (that cannot be altered or removed, unlike e.g. its property named \"parseInt\").","format":"org.matrix.custom.html","formatted_body":"that's an interesting distinction, but I think the claim that Number.MAX_SAFE_INTEGER is an intrinsic is just technically inaccurate. <em>%Number%</em> is an intrinsic object, and its primordial state includes a property named &quot;MAX_SAFE_INTEGER&quot; (that cannot be altered or removed, unlike e.g. its property named &quot;parseInt&quot;).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"that's an interesting distinction, but I think the claim that Number.MAX_SAFE_INTEGER is an intrinsic is just technically inaccurate. _%Number%_ is an intrinsic object, and its primordial state includes a property named \"MAX_SAFE_INTEGER\" (that cannot be altered or removed, unlike e.g. its property named \"parseInt\").","mimetype":"text/plain"},{"body":"that's an interesting distinction, but I think the claim that Number.MAX_SAFE_INTEGER is an intrinsic is just technically inaccurate. <em>%Number%</em> is an intrinsic object, and its primordial state includes a property named &quot;MAX_SAFE_INTEGER&quot; (that cannot be altered or removed, unlike e.g. its property named &quot;parseInt&quot;).","mimetype":"text/html"}]},"ts":1670505955580,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$26TxrRIHC4H6e7D8ycDYJjYm4CYZ2dCU2Rd6rMwd6wk"},
{"content":{"body":"Right, so under that model, the *value* contained by both Array and Array.prototype.constructor, is the same intrinsic object, and the \"Array\" property contained by the global object, and the property key path \"prototype.constructor\" are primordial states of the global object and the Array intrinsic respectively","format":"org.matrix.custom.html","formatted_body":"Right, so under that model, the <em>value</em> contained by both Array and Array.prototype.constructor, is the same intrinsic object, and the &quot;Array&quot; property contained by the global object, and the property key path &quot;prototype.constructor&quot; are primordial states of the global object and the Array intrinsic respectively","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Right, so under that model, the *value* contained by both Array and Array.prototype.constructor, is the same intrinsic object, and the \"Array\" property contained by the global object, and the property key path \"prototype.constructor\" are primordial states of the global object and the Array intrinsic respectively","mimetype":"text/plain"},{"body":"Right, so under that model, the <em>value</em> contained by both Array and Array.prototype.constructor, is the same intrinsic object, and the &quot;Array&quot; property contained by the global object, and the property key path &quot;prototype.constructor&quot; are primordial states of the global object and the Array intrinsic respectively","mimetype":"text/html"}]},"ts":1670506301953,"senderName":"tolmasky","senderId":"@tolmasky:matrix.org","id":"$ODvYToZoLhD5rCphZ1H0OmiA4O7UQbczWbnHbdpy_SY"},
{"content":{"body":"and there is no like specific terminology to refer to such a state (to clarify the reason for these question, i would just like to label things in an object viewer, so if it is \"unaltered original and/or built-in thing, it might be highlighted blue for example)","msgtype":"m.text","org.matrix.msc1767.text":"and there is no like specific terminology to refer to such a state (to clarify the reason for these question, i would just like to label things in an object viewer, so if it is \"unaltered original and/or built-in thing, it might be highlighted blue for example)"},"ts":1670506365987,"senderName":"tolmasky","senderId":"@tolmasky:matrix.org","id":"$mTvA3AM15aU9c3dxM_Oi0AuELd0WLxV5cvERmVIIE2I"},
{"content":{"body":"isn't \"primordial\" that term?","msgtype":"m.text","org.matrix.msc1767.text":"isn't \"primordial\" that term?"},"ts":1670506617483,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$4Dm3brFGud2bwHW7-8lZeYry3ta1oNxUNLLxWDMIJew"},
{"content":{"body":"%Array% and %Array.prototype.constructor% are the same, but Array and Array.prototype.constructor aren't necessarily the same, because the latter is Writable.","msgtype":"m.text","org.matrix.msc1767.text":"%Array% and %Array.prototype.constructor% are the same, but Array and Array.prototype.constructor aren't necessarily the same, because the latter is Writable."},"ts":1670506628708,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$j5GVmsbJts-uMHecmMdsjOWa4b_SDV2FXoRUImpXtNA"},
{"content":{"body":"(as an adjective)","msgtype":"m.text","org.matrix.msc1767.text":"(as an adjective)"},"ts":1670506651820,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$zj7EvykKpqGw3jsonLgRcxEXX_OsnAoZAbRFLL-khqw"},
{"content":{"body":"generalizing the \"required to exist before any ECMAScript code runs\" detail into a description of not just values, but also the state of their properties","msgtype":"m.text","org.matrix.msc1767.text":"generalizing the \"required to exist before any ECMAScript code runs\" detail into a description of not just values, but also the state of their properties"},"ts":1670506754018,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$iIGSc_ai8y97alSv_nnP3Nygm7iZ5xVeIjMZwpWYoE4"},
{"content":{"body":"The spec doesn't define/use \"primordial\", and terminology.md only defines it as a noun. You could use it as an adjective with the meaning that tolmasky is asking about, and people might get the right idea, but you'd want to define it to be sure.","msgtype":"m.text","org.matrix.msc1767.text":"The spec doesn't define/use \"primordial\", and terminology.md only defines it as a noun. You could use it as an adjective with the meaning that tolmasky is asking about, and people might get the right idea, but you'd want to define it to be sure."},"ts":1670507104680,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$noUItV7Hg-MbfP92oUF-Ulrv7Pe2G02Dls2nNru8jYA"},
{"content":{"body":"agreed. But informally, we definitely reference \"primordial state\".","msgtype":"m.text","org.matrix.msc1767.text":"agreed. But informally, we definitely reference \"primordial state\"."},"ts":1670507153755,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$rXvJOk_xcMylLvgxJOvkUcr0RXvNvitR4prBK5xXi-g"},
{"content":{"body":"Yup, but note then that \"primordial object\" would mean something different from how terminology.md defines \"primordial\" (noun).","msgtype":"m.text","org.matrix.msc1767.text":"Yup, but note then that \"primordial object\" would mean something different from how terminology.md defines \"primordial\" (noun)."},"ts":1670507364062,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$IfrZw_UnvBJQ2VMf5IX3CDPEMtZOBfwILva9IqOVJnw"}
]