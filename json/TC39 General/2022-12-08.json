[
{"content":{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","mimetype":"text/html"}]},"ts":1670457609002,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$qobKeze0Vd2WINKLh3zhIAKxnFHOGpZvO0QTcsOzvO0"},
{"content":{"body":" * bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","m.new_content":{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$qobKeze0Vd2WINKLh3zhIAKxnFHOGpZvO0QTcsOzvO0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","mimetype":"text/plain"},{"body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","mimetype":"text/html"}]},"ts":1670457637868,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$Wld9gVI4XYBXyl83q9JL55dIfICzpVQKjXVSvOmwjdg"},
{"content":{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","format":"org.matrix.custom.html","formatted_body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/plain"},{"body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/html"}]},"ts":1670457802442,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$rXwu7rrVyhHxsmPqqEcmnqEojmtezhDsH6aUqgR3-w8"},
{"content":{"body":" * @tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","format":"org.matrix.custom.html","formatted_body":" * @tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","m.new_content":{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","format":"org.matrix.custom.html","formatted_body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/plain"},{"body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$rXwu7rrVyhHxsmPqqEcmnqEojmtezhDsH6aUqgR3-w8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * @tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/plain"},{"body":" * @tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/html"}]},"ts":1670457841370,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$8bBVBh7VeOKwh6gzoln5L-i8rnOfsbbKghXjflOZ-qA"},
{"content":{"body":"See also https://github.com/tc39/ecma262/issues/1540 and the https://github.com/tc39/how-we-work/pull/64 that it links to.","msgtype":"m.text","org.matrix.msc1767.text":"See also https://github.com/tc39/ecma262/issues/1540 and the https://github.com/tc39/how-we-work/pull/64 that it links to."},"ts":1670458039738,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$aW3GuSUgbFgKF6ybmuMo106FK2143oCyGGo8hc-WCuo"},
{"content":{"body":"sirisian: a number of programming languages use the type of the position to determine the type of literals in that position, yes","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: a number of programming languages use the type of the position to determine the type of literals in that position, yes","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"sirisian: a number of programming languages use the type of the position to determine the type of literals in that position, yes","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: a number of programming languages use the type of the position to determine the type of literals in that position, yes","mimetype":"text/html"}]},"ts":1670458127334,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$54oZk5wLN04Ab0EuK3L0hmTwuUAWMQT5eF6wzyvRYwo"},
{"content":{"body":"Which languages?","msgtype":"m.text","org.matrix.msc1767.text":"Which languages?"},"ts":1670458160625,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$nI_lyoJYHZajhPssbW-hkbg0pl5ejw0Z3Ke8KcTQlVc"},
{"content":{"body":"offhand, C++?","msgtype":"m.text","org.matrix.msc1767.text":"offhand, C++?"},"ts":1670458266007,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$plM9iVDujQRTLkGzP-vmtDM-xZBMcq8kzU_0ZPJhssk"},
{"content":{"body":"tolmasky: Also https://github.com/tc39/ecma262/issues/2608","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@tolmasky:matrix.org\">tolmasky</a>: Also https://github.com/tc39/ecma262/issues/2608","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"tolmasky: Also https://github.com/tc39/ecma262/issues/2608","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@tolmasky:matrix.org\">tolmasky</a>: Also https://github.com/tc39/ecma262/issues/2608","mimetype":"text/html"}]},"ts":1670458266928,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$hX18Q3WAcfUiQBYA34fEdJ79t39pIGgBFqeTfm6Vibk"},
{"content":{"body":"though I guess that's not _quite_ how it works in C++","format":"org.matrix.custom.html","formatted_body":"though I guess that's not <em>quite</em> how it works in C++","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"though I guess that's not _quite_ how it works in C++","mimetype":"text/plain"},{"body":"though I guess that's not <em>quite</em> how it works in C++","mimetype":"text/html"}]},"ts":1670458272742,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BonTxJ0Mgj0XcNJu8o5pj8BI5PeA1fhnvdn1y80JES8"},
{"content":{"body":"it just has implicit conversions","msgtype":"m.text","org.matrix.msc1767.text":"it just has implicit conversions"},"ts":1670458289918,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$bAQ0ZYoBqMeQsK7b1ICUYnW-aYwu5FNCJfDbV_lpqZ4"},
{"content":{"body":"but it amounts to much the same thing","msgtype":"m.text","org.matrix.msc1767.text":"but it amounts to much the same thing"},"ts":1670458296415,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$-IYD2l_t4JkUjCKC9irJnNW-aZVQMo0OyoLlIzyvG5A"},
{"content":{"body":"Rust, also","msgtype":"m.text","org.matrix.msc1767.text":"Rust, also"},"ts":1670458363243,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$l_UDW6j12VjXsnXG8FyhdEDIXEA9koK4uH4Qa0tebbQ"},
{"content":{"body":"https://doc.rust-lang.org/reference/expressions/literal-expr.html#integer-literal-expressions","msgtype":"m.text","org.matrix.msc1767.text":"https://doc.rust-lang.org/reference/expressions/literal-expr.html#integer-literal-expressions"},"ts":1670458415903,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cqJIux5BnHCgwJMT7tZChoy4clX3H6BzUtPwSfPOdEg"},
{"content":{"body":"> If the token has no suffix, the expression's type is determined by type inference:\n> If an integer type can be uniquely determined from the surrounding program context, the expression has that type","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>If the token has no suffix, the expression's type is determined by type inference:<br>If an integer type can be uniquely determined from the surrounding program context, the expression has that type</p>\n</blockquote>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> If the token has no suffix, the expression's type is determined by type inference:\n> If an integer type can be uniquely determined from the surrounding program context, the expression has that type","mimetype":"text/plain"},{"body":"<blockquote>\n<p>If the token has no suffix, the expression's type is determined by type inference:<br>If an integer type can be uniquely determined from the surrounding program context, the expression has that type</p>\n</blockquote>\n","mimetype":"text/html"}]},"ts":1670458429124,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$OD7K2VFAEi7xgBAn7FdTBHW1T0hd23XYhL4vBTSeDuw"},
{"content":{"body":"Yeah, but you can't type a 100 digit number. The maximum literal it has is i128 and u128 suffixes?","msgtype":"m.text","org.matrix.msc1767.text":"Yeah, but you can't type a 100 digit number. The maximum literal it has is i128 and u128 suffixes?"},"ts":1670458477259,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$y0DQs0PUU6eg8AtOa7AVfjqFQOGune8PeyBvQZ4SUuA"},
{"content":{"body":"It is true that Rust's integer types are bounded; I don't understand what relevance that has to anything?","msgtype":"m.text","org.matrix.msc1767.text":"It is true that Rust's integer types are bounded; I don't understand what relevance that has to anything?"},"ts":1670458522666,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$G0FZYeki5L2eT3D5hySseGt6ETstCoyHhYACRV1NnRM"},
{"content":{"body":"The example you gave also had a bounded integer type","msgtype":"m.text","org.matrix.msc1767.text":"The example you gave also had a bounded integer type"},"ts":1670458540431,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Ff7kcQu6boTWikVYJiUAk80JMlwKQwMu41xjgKHSj_k"},
{"content":{"body":"yes, for the basic one. Inside of the issue I wanted this to work seamlessly for BigInt as well.","msgtype":"m.text","org.matrix.msc1767.text":"yes, for the basic one. Inside of the issue I wanted this to work seamlessly for BigInt as well."},"ts":1670458611944,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$l_ufw126-yWjmoFZRTe2gnn68tG_crWDKK2OHL83pCQ"},
{"content":{"body":"Essentially a system where suffixes are never necessary. (Though some might find them simpler than casting?)","msgtype":"m.text","org.matrix.msc1767.text":"Essentially a system where suffixes are never necessary. (Though some might find them simpler than casting?)"},"ts":1670458650053,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$Sgt4_fBYyrxWrOfln4mkS5VrHm0CJt3T-vUc9I3162k"},
{"content":{"body":"I'm still not clear on what the relevance of integer types in Rust being bounded is.","msgtype":"m.text","org.matrix.msc1767.text":"I'm still not clear on what the relevance of integer types in Rust being bounded is."},"ts":1670458692227,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$vCQmF0TD8y6_Ou7DYlK6Ft6tMes-hFJNrS7Kjxfl-zM"},
{"content":{"body":"As it says, \"If an integer type can be uniquely determined from the surrounding program context, the expression has that type\"","msgtype":"m.text","org.matrix.msc1767.text":"As it says, \"If an integer type can be uniquely determined from the surrounding program context, the expression has that type\""},"ts":1670458701129,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$NNkflid0FvfwZhPO9HP2A8DrOKZjmjvVTm97GXnfWX8"},
{"content":{"body":"it's not based on how long the integer literal is, it's based on _the surrounding program context_","format":"org.matrix.custom.html","formatted_body":"it's not based on how long the integer literal is, it's based on <em>the surrounding program context</em>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"it's not based on how long the integer literal is, it's based on _the surrounding program context_","mimetype":"text/plain"},{"body":"it's not based on how long the integer literal is, it's based on <em>the surrounding program context</em>","mimetype":"text/html"}]},"ts":1670458720085,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$c1BPZOorVeZCekwLa6VnlpYkujP-yvXt1IDtL5w6Bn4"},
{"content":{"body":"so in principle they could have a BigInt type, and if you wrote `let x: BigInt = 0`, then that `0` would unambiguously be a bigint 0, so that's how it would be intepreted","format":"org.matrix.custom.html","formatted_body":"so in principle they could have a BigInt type, and if you wrote <code>let x: BigInt = 0</code>, then that <code>0</code> would unambiguously be a bigint 0, so that's how it would be intepreted","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"so in principle they could have a BigInt type, and if you wrote `let x: BigInt = 0`, then that `0` would unambiguously be a bigint 0, so that's how it would be intepreted","mimetype":"text/plain"},{"body":"so in principle they could have a BigInt type, and if you wrote <code>let x: BigInt = 0</code>, then that <code>0</code> would unambiguously be a bigint 0, so that's how it would be intepreted","mimetype":"text/html"}]},"ts":1670458749960,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$roOiZmvgg1wuksaLQ_L5vVNYP_J6ZC47tsu5wE1gbzA"},
{"content":{"body":"bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/html"}]},"ts":1670459300742,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$tgUvs9VMUdmTBIrO-89xGoRhxRXEIDMDmAUw1eI39CA"},
{"content":{"body":" * bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","m.new_content":{"body":"bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$tgUvs9VMUdmTBIrO-89xGoRhxRXEIDMDmAUw1eI39CA","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * bakkot: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=43ea23caef0c68e25e5d7dbc23c07953 It says \"integer literal is too large\". In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/plain"},{"body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: I just meant Rust doesn't have a bigint literal format: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43ea23caef0c68e25e5d7dbc23c07953 It says &quot;integer literal is too large&quot;. In my proposal I'd want it to just work. (also I've never used rust, so ignore the other error)","mimetype":"text/html"}]},"ts":1670459363224,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$8lWiVSzQMW9IbYo88pmRmMAztlwVxqjDGT_ScXkhxlY"}
]