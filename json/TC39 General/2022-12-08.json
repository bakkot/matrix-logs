[
{"content":{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","mimetype":"text/html"}]},"ts":1670457609002,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$qobKeze0Vd2WINKLh3zhIAKxnFHOGpZvO0QTcsOzvO0"},
{"content":{"body":" * bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","m.new_content":{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$qobKeze0Vd2WINKLh3zhIAKxnFHOGpZvO0QTcsOzvO0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * bakkot: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2\\*\\*63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)\\*\\*uint64(63)).","mimetype":"text/plain"},{"body":" * <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: , Grammar/engine question on an idea I've had in my issues for ages. Related to this issue: https://github.com/sirisian/ecmascript-types/issues/79 Basically say an engine is aware of types, could it handle transferring the type to argument expressions. f(a:uint64){} and you called f(2**63); The engine when parsing would choose the overload (in this case there's only one function) and propagate the type, so it's like f(uint64(2)**uint64(63)).","mimetype":"text/html"}]},"ts":1670457637868,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$Wld9gVI4XYBXyl83q9JL55dIfICzpVQKjXVSvOmwjdg"},
{"content":{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","format":"org.matrix.custom.html","formatted_body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/plain"},{"body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/html"}]},"ts":1670457802442,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$rXwu7rrVyhHxsmPqqEcmnqEojmtezhDsH6aUqgR3-w8"},
{"content":{"body":" * @tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","format":"org.matrix.custom.html","formatted_body":" * @tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","m.new_content":{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","format":"org.matrix.custom.html","formatted_body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"@tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/plain"},{"body":"@tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$rXwu7rrVyhHxsmPqqEcmnqEojmtezhDsH6aUqgR3-w8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * @tolmasky: I don't think the spec really says whether or not your `global.Francisco = { }` qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/plain"},{"body":" * @tolmasky: I don't think the spec really says whether or not your <code>global.Francisco = { }</code> qualifies as an intrinsic. Personally, I'd call it one, I think.","mimetype":"text/html"}]},"ts":1670457841370,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$8bBVBh7VeOKwh6gzoln5L-i8rnOfsbbKghXjflOZ-qA"},
{"content":{"body":"See also https://github.com/tc39/ecma262/issues/1540 and the https://github.com/tc39/how-we-work/pull/64 that it links to.","msgtype":"m.text","org.matrix.msc1767.text":"See also https://github.com/tc39/ecma262/issues/1540 and the https://github.com/tc39/how-we-work/pull/64 that it links to."},"ts":1670458039738,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$aW3GuSUgbFgKF6ybmuMo106FK2143oCyGGo8hc-WCuo"},
{"content":{"body":"sirisian: a number of programming languages use the type of the position to determine the type of literals in that position, yes","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: a number of programming languages use the type of the position to determine the type of literals in that position, yes","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"sirisian: a number of programming languages use the type of the position to determine the type of literals in that position, yes","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@sirisian:matrix.org\">sirisian</a>: a number of programming languages use the type of the position to determine the type of literals in that position, yes","mimetype":"text/html"}]},"ts":1670458127334,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$54oZk5wLN04Ab0EuK3L0hmTwuUAWMQT5eF6wzyvRYwo"},
{"content":{"body":"Which languages?","msgtype":"m.text","org.matrix.msc1767.text":"Which languages?"},"ts":1670458160625,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$nI_lyoJYHZajhPssbW-hkbg0pl5ejw0Z3Ke8KcTQlVc"},
{"content":{"body":"offhand, C++?","msgtype":"m.text","org.matrix.msc1767.text":"offhand, C++?"},"ts":1670458266007,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$plM9iVDujQRTLkGzP-vmtDM-xZBMcq8kzU_0ZPJhssk"},
{"content":{"body":"tolmasky: Also https://github.com/tc39/ecma262/issues/2608","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@tolmasky:matrix.org\">tolmasky</a>: Also https://github.com/tc39/ecma262/issues/2608","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"tolmasky: Also https://github.com/tc39/ecma262/issues/2608","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@tolmasky:matrix.org\">tolmasky</a>: Also https://github.com/tc39/ecma262/issues/2608","mimetype":"text/html"}]},"ts":1670458266928,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$hX18Q3WAcfUiQBYA34fEdJ79t39pIGgBFqeTfm6Vibk"},
{"content":{"body":"though I guess that's not _quite_ how it works in C++","format":"org.matrix.custom.html","formatted_body":"though I guess that's not <em>quite</em> how it works in C++","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"though I guess that's not _quite_ how it works in C++","mimetype":"text/plain"},{"body":"though I guess that's not <em>quite</em> how it works in C++","mimetype":"text/html"}]},"ts":1670458272742,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BonTxJ0Mgj0XcNJu8o5pj8BI5PeA1fhnvdn1y80JES8"},
{"content":{"body":"it just has implicit conversions","msgtype":"m.text","org.matrix.msc1767.text":"it just has implicit conversions"},"ts":1670458289918,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$bAQ0ZYoBqMeQsK7b1ICUYnW-aYwu5FNCJfDbV_lpqZ4"},
{"content":{"body":"but it amounts to much the same thing","msgtype":"m.text","org.matrix.msc1767.text":"but it amounts to much the same thing"},"ts":1670458296415,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$-IYD2l_t4JkUjCKC9irJnNW-aZVQMo0OyoLlIzyvG5A"},
{"content":{"body":"Rust, also","msgtype":"m.text","org.matrix.msc1767.text":"Rust, also"},"ts":1670458363243,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$l_UDW6j12VjXsnXG8FyhdEDIXEA9koK4uH4Qa0tebbQ"},
{"content":{"body":"https://doc.rust-lang.org/reference/expressions/literal-expr.html#integer-literal-expressions","msgtype":"m.text","org.matrix.msc1767.text":"https://doc.rust-lang.org/reference/expressions/literal-expr.html#integer-literal-expressions"},"ts":1670458415903,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cqJIux5BnHCgwJMT7tZChoy4clX3H6BzUtPwSfPOdEg"},
{"content":{"body":"> If the token has no suffix, the expression's type is determined by type inference:\n> If an integer type can be uniquely determined from the surrounding program context, the expression has that type","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>If the token has no suffix, the expression's type is determined by type inference:<br>If an integer type can be uniquely determined from the surrounding program context, the expression has that type</p>\n</blockquote>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> If the token has no suffix, the expression's type is determined by type inference:\n> If an integer type can be uniquely determined from the surrounding program context, the expression has that type","mimetype":"text/plain"},{"body":"<blockquote>\n<p>If the token has no suffix, the expression's type is determined by type inference:<br>If an integer type can be uniquely determined from the surrounding program context, the expression has that type</p>\n</blockquote>\n","mimetype":"text/html"}]},"ts":1670458429124,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$OD7K2VFAEi7xgBAn7FdTBHW1T0hd23XYhL4vBTSeDuw"},
{"content":{"body":"Yeah, but you can't type a 100 digit number. The maximum literal it has is i128 and u128 suffixes?","msgtype":"m.text","org.matrix.msc1767.text":"Yeah, but you can't type a 100 digit number. The maximum literal it has is i128 and u128 suffixes?"},"ts":1670458477259,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$y0DQs0PUU6eg8AtOa7AVfjqFQOGune8PeyBvQZ4SUuA"}
]