[
{"content":{"body":"yes, this would definitely be good to do, IMO","m.mentions":{"user_ids":["@akaster:serenityos.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$FUe1HS7ivsa_XUXcC4p35yIJ3pfL2N7DVJI9n4AOUPg"}},"msgtype":"m.text"},"ts":1743992939065,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$UkXaG-2uFLNLJIN8w8hxpHTBqObvpRsVXIOxB6HJAsE"},
{"content":{"body":"I noticed a probably-known implementation inconsistency with Float64Array sorting regarding NaNs: According to spec, any call to Float64Array should canonicalise all NaNs in the TA's viewed buffer since it copies data from the buffer into a list of Values (canonicalising all NaNs here), performs sorting on that list and then writes the sorted items back into the buffer.\n\nOn FF, a sort without a comparator seems to sort NaNs according to \"absolute value\" (uint64) while on Chrome they are left where they were. With a comparator (returning -1 or 1 randomly), on FF they NaNs become canonicalised while on Chrome they get sorted according to the comparator's wishes without canonicalisation.\n\nThe spec seems fairly clear to me on this whole issue; canonicalisation happens on every sort call, but the lived reality is different. Should this be accepted, or is this something to file a bug to implementors about (if not already existent)? Or should this be a case where the spec is loosened to allow for implementation defined behaviour?","m.mentions":{},"msgtype":"m.text"},"ts":1744006100533,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$KMCjRFbbaaKv4k2WARMkhWFvJg9d2gDJ-2Si5PG9bTE"},
{"content":{"body":"Aapo Alasuutari: Seems like you should file issues against the implementations. Have you checked the JSC behaviour?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@aapo.alasuutari:matrix.org\">@aapo.alasuutari:matrix.org</a>: Seems like you should file issues against the implementations. Have you checked the JSC behaviour?","msgtype":"m.text"},"ts":1744024408937,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$J6GzvMG3ROGX5Sl65qz3Ta3q5vjUVXOm7JP3EIDyr9Q"},
{"content":{"body":"Nope, I don't happen to have JSC at my fingertips quite the same as I have FF and Chrome.","m.mentions":{},"msgtype":"m.text"},"ts":1744024443830,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$vuoG8uUOs8yx9Xh9plRa5gSWenTrZKDW5SkGwG4ZuGY"},
{"content":{"body":"Okay, non-buggy test code:\n```js\nb = BigUint64Array.of(9221120237041091055n, 9221120237041090774n);\nconsole.log(b[0], b[1]);\na = new Float64Array(b.buffer);\na.sort();\nconsole.log(b[0], b[1]);\na.sort(() => Math.random() ? -1 : 1);\nconsole.log(b[0], b[1]);\n```","format":"org.matrix.custom.html","formatted_body":"<p>Okay, non-buggy test code:</p>\n<pre><code class=\"language-js\">b = BigUint64Array.of(9221120237041091055n, 9221120237041090774n);\nconsole.log(b[0], b[1]);\na = new Float64Array(b.buffer);\na.sort();\nconsole.log(b[0], b[1]);\na.sort(() =&gt; Math.random() ? -1 : 1);\nconsole.log(b[0], b[1]);\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1744024825694,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$xSKc6ZvOvSTuzendB8h4ubmgpKFKdBArc8pSqQZHkdg"},
{"content":{"body":"(I was wrong about FF ordering by \"absolute value\", that doesn't seem to happen. I must've accidentally sorted the BigUint64Array in one of my tests. Otherwise it all goes as I wrote.)","m.mentions":{},"msgtype":"m.text"},"ts":1744025125050,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$0j_4skLtTVksop1yBTRZttolWAzwT9iOJCBGbczSPM8"},
{"content":{"body":"in JSC it logs\n```\n9221120237041091055n 9221120237041090774n\n9221120237041090560n 9221120237041090560n\n9221120237041090560n 9221120237041090560n\n```","format":"org.matrix.custom.html","formatted_body":"<p>in JSC it logs</p>\n<pre><code>9221120237041091055n 9221120237041090774n\n9221120237041090560n 9221120237041090560n\n9221120237041090560n 9221120237041090560n\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1744025161808,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$mNFvMMGKWUl_j_lizKjGxm-Y3MG7A7Nb_7aaEJ0-WVQ"},
{"content":{"body":"Which from your message above seems to be the spec-compliant behavior","m.mentions":{},"msgtype":"m.text"},"ts":1744025257141,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$IsYKv2xXqfccRSIIJky1Y1_Mh1PsyjYTbQZOcw4IUmk"},
{"content":{"body":"Yup, that's seems compliant. Ladybird also complies, according to a response I got in their Discord.","m.mentions":{},"msgtype":"m.text"},"ts":1744025288213,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$PLkueZF3tjYy_c09RODRKq1myPiVoHByMg6r2CxVbH4"},
{"content":{"body":"* Yup, that's seems compliant. Ladybird also complies, based on a response I got in their Discord.","m.mentions":{},"m.new_content":{"body":"Yup, that's seems compliant. Ladybird also complies, based on a response I got in their Discord.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$PLkueZF3tjYy_c09RODRKq1myPiVoHByMg6r2CxVbH4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1744025299086,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$7N_xaBZehmFb1AIiy2nMLtYGJFWXTIgGX0_nlLHBeOA"},
{"content":{"body":"https://issues.chromium.org/issues/408932085","m.mentions":{},"msgtype":"m.text"},"ts":1744026032066,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$pkyGkf_ESKO1qzVkjNGyqqBfD9W-8kzURtFcXNxbiu8"},
{"content":{"body":"https://bugzilla.mozilla.org/show_bug.cgi?id=1958820","m.mentions":{},"msgtype":"m.text"},"ts":1744026518378,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$UqkhZ-10CYKYMA45YZqIQeh4lxp_C12eg9FHHXnPqYg"},
{"content":{"body":"where's the step that canonicalizes NaNs in sort?","m.mentions":{},"msgtype":"m.text"},"ts":1744038393842,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9UqipcWXIJhYFVGKbVSsHuzp_v1hLN-otBAEeJUSfFQ"},
{"content":{"body":"is it your reading that [[Get]] returns the ES NaN, then [[Set]] of that NaN should always produce the same bit pattern in typed arrays?","m.mentions":{},"msgtype":"m.text"},"ts":1744038503856,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$i7M4FI0jyGtA8zPZHcdOBRN9HcaUN0axBS_U4fDKgsU"},
{"content":{"body":"anyway i think we should fix the spec to reflect reality, and clear up ambiguities in the reading","m.mentions":{},"msgtype":"m.text"},"ts":1744038744671,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$U8_v-dQzbRkNRsfrLPhBqCjeJFCVfZDWl1mZIfFWt2o"},
{"content":{"body":"i don't see a realistic path to get interoperable NaN canonicalization across engines, nor the benefits of doing so","m.mentions":{},"msgtype":"m.text"},"ts":1744038780480,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xFvNc1oZlD5Y3FWO__yRoD8LWjwepsBEAlmWVlVVWKA"},
{"content":{"body":"we had a whole day of discussion in 2015 about NaN canonicalization. my recollection was that the only time NaNs are canonicalized is when you see one *in JS* - not when a spec-internal operation gets or copies one","format":"org.matrix.custom.html","formatted_body":"we had a whole day of discussion in 2015 about NaN canonicalization. my recollection was that the only time NaNs are canonicalized is when you see one <em>in JS</em> - not when a spec-internal operation gets or copies one","m.mentions":{},"msgtype":"m.text"},"ts":1744046943409,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$NXOIHftr3FmBjpUxyTMyB-n6WWGLPQphX85TgF3k-Fk"},
{"content":{"body":"yeah not requiring canonicalization was a pretty explicit decision; I don't understand why we think this doesn't apply to sort","m.mentions":{},"msgtype":"m.text"},"ts":1744047003675,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hc8ABQZwu3fh6ER6W6MNOhv0ZfP8V5_EZsoaFyFR458"},
{"content":{"body":"Not sure if this is what Aapo meant, but when I looked at https://tc39.es/ecma262/#sec-rawbytestonumeric earlier I could interpret that as normalizing NaN values. It checks if value is NaN and then it doesn't return value, but it returns (a canonical?) NaN.","m.mentions":{},"msgtype":"m.text"},"ts":1744047931261,"senderName":"annevk","senderId":"@annevk:matrix.org","id":"$if0oYkk5FbovEXZ43LpY8qmmrkcPuDgApHCh65-cwZo"},
{"content":{"body":"The current text does imply certain guarantees that aren't actually met in all browsers: \"An implementation must always choose the same encoding for each implementation distinguishable NaN value.\" I would prefer that we adopt Waldemar's proposed alternative semantics, that every time you write a float into a TypedArray, it may have arbitrary undefined NaN bits (which is the previous sentence: \"If value is NaN, rawBytes may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. \") https://tc39.es/ecma262/#sec-numerictorawbytes","m.mentions":{},"msgtype":"m.text"},"ts":1744048236540,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$8SjEr6tEthHgcQxwLoFnnXn-MzfAyOEYnMmH7HMMqNg"},
{"content":{"body":"the committee was just a little over-optimistic that such regularity would fall out in engines like V8, but it doesn't","m.mentions":{},"msgtype":"m.text"},"ts":1744048294872,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$rPjZ_acUbSXLv9J8Rih2tK5YBOnxTwNxjMs48ruhbzc"},
{"content":{"body":"anyway I imagine sort hits this spec path, so it doesn't guarantee canonicalization","m.mentions":{},"msgtype":"m.text"},"ts":1744048318840,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$WvZU38SnAlAnE6e4ZWazST36DuLnOKFeSYa4G_r5ojE"},
{"content":{"body":"* When you write the JS NaN to a TypedArray, its byte pattern may be arbitrary: which is the previous sentence: \"If value is NaN, rawBytes may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. \" https://tc39.es/ecma262/#sec-numerictorawbytes\n\nActually, the text gives some guarantees that aren't actually met in all browsers: \"An implementation must always choose the same encoding for each implementation distinguishable NaN value.\" I would prefer that we adopt Waldemar's proposed alternative, that we just delete that second sentence.","m.mentions":{},"m.new_content":{"body":"When you write the JS NaN to a TypedArray, its byte pattern may be arbitrary: which is the previous sentence: \"If value is NaN, rawBytes may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. \" https://tc39.es/ecma262/#sec-numerictorawbytes\n\nActually, the text gives some guarantees that aren't actually met in all browsers: \"An implementation must always choose the same encoding for each implementation distinguishable NaN value.\" I would prefer that we adopt Waldemar's proposed alternative, that we just delete that second sentence.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$8SjEr6tEthHgcQxwLoFnnXn-MzfAyOEYnMmH7HMMqNg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1744048425506,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$78vHatThUh184iAinkM6Svr78jJ7TJdYOkWhla_G_B0"},
{"content":{"body":"* When you write the JS NaN to a TypedArray, its byte pattern may be arbitrary: \"If value is NaN, rawBytes may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. \" https://tc39.es/ecma262/#sec-numerictorawbytes\n\nActually, the text gives some guarantees that aren't actually met in all browsers: \"An implementation must always choose the same encoding for each implementation distinguishable NaN value.\" I would prefer that we adopt Waldemar's proposed alternative, that we just delete that second sentence.","m.mentions":{},"m.new_content":{"body":"When you write the JS NaN to a TypedArray, its byte pattern may be arbitrary: \"If value is NaN, rawBytes may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. \" https://tc39.es/ecma262/#sec-numerictorawbytes\n\nActually, the text gives some guarantees that aren't actually met in all browsers: \"An implementation must always choose the same encoding for each implementation distinguishable NaN value.\" I would prefer that we adopt Waldemar's proposed alternative, that we just delete that second sentence.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$8SjEr6tEthHgcQxwLoFnnXn-MzfAyOEYnMmH7HMMqNg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1744048444265,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$jKirg4EizikE_jczLUhfWhZbCPnyVDR-HG38fK4S1ZU"},
{"content":{"body":"Yeah, I was thinking of [[Get]] and a misread of \"The Number Type\":\n> NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.\nI had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D","format":"org.matrix.custom.html","formatted_body":"<p>Yeah, I was thinking of [[Get]] and a misread of \"The Number Type\":</p>\n<blockquote>\n<p>NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.<br>I had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D</p>\n</blockquote>\n","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$i7M4FI0jyGtA8zPZHcdOBRN9HcaUN0axBS_U4fDKgsU"}},"msgtype":"m.text"},"ts":1744057462214,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$2Niaj6tVk6tNHo-R9KgXW_tLHRVpQQKh9PavTCLuwvA"},
{"content":{"body":"* Yeah, I was thinking of \\[\\[Get\\]\\] and a misread of \"The Number Type\":\n\n> NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.\n\nI had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D","format":"org.matrix.custom.html","formatted_body":"* <p>Yeah, I was thinking of [[Get]] and a misread of \"The Number Type\":</p>\n<blockquote>\n<p>NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.</p>\n</blockquote>\n<p>I had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D</p>\n","m.mentions":{},"m.new_content":{"body":"Yeah, I was thinking of \\[\\[Get\\]\\] and a misread of \"The Number Type\":\n\n> NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.\n\nI had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D","format":"org.matrix.custom.html","formatted_body":"<p>Yeah, I was thinking of [[Get]] and a misread of \"The Number Type\":</p>\n<blockquote>\n<p>NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.</p>\n</blockquote>\n<p>I had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D</p>\n","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$2Niaj6tVk6tNHo-R9KgXW_tLHRVpQQKh9PavTCLuwvA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1744057469171,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$fclWhBIuXQzeqKxTWnmPxI8JmIoobHp13TLeKtxZdHE"},
{"content":{"body":"* Yeah, I was thinking of \\[\\[Get\\]\\] / RawBytesToNumeric and a misread of \"The Number Type\":\n\n> NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.\n\nI had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D","format":"org.matrix.custom.html","formatted_body":"* <p>Yeah, I was thinking of [[Get]] / RawBytesToNumeric and a misread of \"The Number Type\":</p>\n<blockquote>\n<p>NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.</p>\n</blockquote>\n<p>I had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D</p>\n","m.mentions":{},"m.new_content":{"body":"Yeah, I was thinking of \\[\\[Get\\]\\] / RawBytesToNumeric and a misread of \"The Number Type\":\n\n> NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.\n\nI had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D","format":"org.matrix.custom.html","formatted_body":"<p>Yeah, I was thinking of [[Get]] / RawBytesToNumeric and a misread of \"The Number Type\":</p>\n<blockquote>\n<p>NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.</p>\n</blockquote>\n<p>I had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D</p>\n","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$2Niaj6tVk6tNHo-R9KgXW_tLHRVpQQKh9PavTCLuwvA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1744057527527,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$UR8fVs5Z0qUSr8EADgUWjqbtmOfal1dIjvmqYAQvRgw"},
{"content":{"body":"Since spec-wise, sort always performs a fully copy of the buffer data into a list of Values and back after sorting, it'll indeed always pass each entry in the TA through NumericToRawBytes.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$WvZU38SnAlAnE6e4ZWazST36DuLnOKFeSYa4G_r5ojE"}},"msgtype":"m.text"},"ts":1744057819829,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$Q1-BK8tFyX6OBnBMmyod7oIweKRzQ-WfbJArTtkpQ34"},
{"content":{"body":"* Since spec-wise, sort always performs a fully copy of the buffer data into a list of Values and back after sorting, it'll indeed always pass each entry in the TA through RawBytesToNumeric and NumericToRawBytes.","m.mentions":{},"m.new_content":{"body":"Since spec-wise, sort always performs a fully copy of the buffer data into a list of Values and back after sorting, it'll indeed always pass each entry in the TA through RawBytesToNumeric and NumericToRawBytes.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Q1-BK8tFyX6OBnBMmyod7oIweKRzQ-WfbJArTtkpQ34","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1744057842493,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$iczpAkuZGizcG7DeP4cGLAxfIV2ysdBR0FY7_EH8OvY"}
]