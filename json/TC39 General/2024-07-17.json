[
{"content":{"body":"that aspect may not have been made clear to those objectors tho; asynccontext is a tough proposal to grok imo","m.mentions":{},"msgtype":"m.text"},"ts":1721186197286,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$5LIJMwV2T26T0-tmusLpmLuY25DCVwXQt0U1L6xwwGs"},
{"content":{"body":"> <@shuyuguo:matrix.org> since then, i suppose those objectors have gotten over the philosophical objection that it was tantamount to unacceptabel dynamic scope, given the enthusiasm about AsyncContext\n\nMark did a rather rigorous analysis of AsyncContext last year to settle those objections preemptively. I was taking a walk with my neighbor Malte Ubl who mentioned Vercel had hired Justin and that he was excited to push AsyncContext. My first thought was that our friendship might not endure that tension, but I arranged for Mark and Justin to talk thru how the design addresses OCap concerns over four or so meetings and we’re good now. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq%3Amatrix.org/%24fdgb3nMBuOmD9ATx99rPvM3S8nWUJDhp31uK07EgymA\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>since then, i suppose those objectors have gotten over the philosophical objection that it was tantamount to unacceptabel dynamic scope, given the enthusiasm about AsyncContext</blockquote></mx-reply>Mark did a rather rigorous analysis of AsyncContext last year to settle those objections preemptively. I was taking a walk with my neighbor Malte Ubl who mentioned Vercel had hired Justin and that he was excited to push AsyncContext. My first thought was that our friendship might not endure that tension, but I arranged for Mark and Justin to talk thru how the design addresses OCap concerns over four or so meetings and we’re good now.","m.relates_to":{"m.in_reply_to":{"event_id":"$fdgb3nMBuOmD9ATx99rPvM3S8nWUJDhp31uK07EgymA"}},"msgtype":"m.text"},"ts":1721188856000,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$UsRi3q_fWA49j-_4rLzR-McFsO7Rh_3mTI5_7bsmJw0"},
{"content":{"body":"Enthusiastic even, since we need such a thing for causal tracing. ","format":"org.matrix.custom.html","formatted_body":"Enthusiastic even, since we need such a thing for causal tracing.","msgtype":"m.text"},"ts":1721188920989,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$v0J81OuRUQDGzK4fc92ylpLVBFTz0uPPHouL1A_LDHk"},
{"content":{"body":"> <@abotella:igalia.com> the other half of what they do seems to be making it so the dynamic import in ``Promise.resolve('import(`./example.mjs`)').then(eval);`` resolves relative to the script active when the promise job is enqueued\n\nI believe the dynamic import *should* be resolved in the context of the script associated with the environment record internal slot on the globalThis.eval in the lexical scope. Else, bug.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$mPnz6DNjyowmCUEw5qHP1e8kOQBS6jVaHsUaOrBwAag?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>the other half of what they do seems to be making it so the dynamic import in <code>Promise.resolve('import(`./example.mjs`)').then(eval);</code> resolves relative to the script active when the promise job is enqueued</blockquote></mx-reply>I believe the dynamic import <em>should</em> be resolved in the context of the script associated with the environment record internal slot on the globalThis.eval in the lexical scope. Else, bug.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$mPnz6DNjyowmCUEw5qHP1e8kOQBS6jVaHsUaOrBwAag"}},"msgtype":"m.text"},"ts":1721189504491,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$4ctb16I8aLhDzjVIbcxQu44IHxBnFI9w4-rWPto07uI"},
{"content":{"body":"Also https://github.com/tc39/ecma262/issues/3160","m.mentions":{},"msgtype":"m.text"},"ts":1721189525019,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$2De1GGMdiYv7ov2u5v4B3wFzAKNXQ-TUg0ZbVkloymo"},
{"content":{"body":"> <@shuyuguo:matrix.org> since then, i suppose those objectors have gotten over the philosophical objection that it was tantamount to unacceptabel dynamic scope, given the enthusiasm about AsyncContext\n\nI'd like to clarify that exposing AsyncContext as a feature is not the same as allowing a host or the 262 spec itself to use the AsyncContext mechanism to create a variable and make the state of that variable observable in any way. That is still completely unacceptable from an Ocap and dynamic scoping pov.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$fdgb3nMBuOmD9ATx99rPvM3S8nWUJDhp31uK07EgymA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br />since then, i suppose those objectors have gotten over the philosophical objection that it was tantamount to unacceptabel dynamic scope, given the enthusiasm about AsyncContext</blockquote></mx-reply>I'd like to clarify that exposing AsyncContext as a feature is not the same as allowing a host or the 262 spec itself to use the AsyncContext mechanism to create a variable and make the state of that variable observable in any way. That is still completely unacceptable from an Ocap and dynamic scoping pov.","m.relates_to":{"m.in_reply_to":{"event_id":"$fdgb3nMBuOmD9ATx99rPvM3S8nWUJDhp31uK07EgymA"}},"msgtype":"m.text"},"ts":1721196021966,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$3d1OOiNLo1_NPmi9cy7wSuK5PTU9MCzuZzgDTilYwAw"},
{"content":{"body":"That is the same kind of concern I raised with the Signals proposal as currently designed.","msgtype":"m.text"},"ts":1721196208517,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$cczbKB9Fa63rE7RXmHA5WLzOd1C1eJvVjkok13r7czc"},
{"content":{"body":"> <@mhofman:matrix.org> I'd like to clarify that exposing AsyncContext as a feature is not the same as allowing a host or the 262 spec itself to use the AsyncContext mechanism to create a variable and make the state of that variable observable in any way. That is still completely unacceptable from an Ocap and dynamic scoping pov.\n\nI don't fully understand the whole incumbent realms thing, but from what I've looked at, it doesn't seem like that would be any different from having a userland library and scheduler that uses AsyncContext variables under the hood to know whether to expose something or other","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$3d1OOiNLo1_NPmi9cy7wSuK5PTU9MCzuZzgDTilYwAw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I'd like to clarify that exposing AsyncContext as a feature is not the same as allowing a host or the 262 spec itself to use the AsyncContext mechanism to create a variable and make the state of that variable observable in any way. That is still completely unacceptable from an Ocap and dynamic scoping pov.</blockquote></mx-reply>I don't fully understand the whole incumbent realms thing, but from what I've looked at, it doesn't seem like that would be any different from having a userland library and scheduler that uses AsyncContext variables under the hood to know whether to expose something or other","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$3d1OOiNLo1_NPmi9cy7wSuK5PTU9MCzuZzgDTilYwAw"}},"msgtype":"m.text"},"ts":1721209196976,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$VWBkaNtET8o05-M7AiHmvgGVcS8nGD0h1k89Rj0iL84"},
{"content":{"body":"> <@kriskowal:aelf.land> I believe the dynamic import *should* be resolved in the context of the script associated with the environment record internal slot on the globalThis.eval in the lexical scope. Else, bug.\n\nSeems like we are all in agreement, great to have an idea about how this relates to evaluators, which I hadn’t thought through","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq%3Amatrix.org/%244ctb16I8aLhDzjVIbcxQu44IHxBnFI9w4-rWPto07uI\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:aelf.land\">@kriskowal:aelf.land</a><br>I believe the dynamic import <em>should</em> be resolved in the context of the script associated with the environment record internal slot on the globalThis.eval in the lexical scope. Else, bug.</blockquote></mx-reply>Seems like we are all in agreement, great to have an idea about how this relates to evaluators, which I hadn’t thought through","m.relates_to":{"m.in_reply_to":{"event_id":"$4ctb16I8aLhDzjVIbcxQu44IHxBnFI9w4-rWPto07uI"}},"msgtype":"m.text"},"ts":1721215708089,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Bk6xus0_A51ZnyB_EKGBaVugbBti4TYtkY04qIqevm4"},
{"content":{"body":"> <@mhofman:matrix.org> That is the same kind of concern I raised with the Signals proposal as currently designed.\n\nOh I thought the signals concern was about certain leaks that were fixable, not the general mechanism ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq%3Amatrix.org/%24cczbKB9Fa63rE7RXmHA5WLzOd1C1eJvVjkok13r7czc\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>That is the same kind of concern I raised with the Signals proposal as currently designed.</blockquote></mx-reply>Oh I thought the signals concern was about certain leaks that were fixable, not the general mechanism","m.relates_to":{"m.in_reply_to":{"event_id":"$cczbKB9Fa63rE7RXmHA5WLzOd1C1eJvVjkok13r7czc"}},"msgtype":"m.text"},"ts":1721215754757,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$1DGjx80ridu3vlN4C3lDWdHHy-cXdFi1sidmSYAx2WQ"},
{"content":{"body":"> <@mhofman:matrix.org> I'd like to clarify that exposing AsyncContext as a feature is not the same as allowing a host or the 262 spec itself to use the AsyncContext mechanism to create a variable and make the state of that variable observable in any way. That is still completely unacceptable from an Ocap and dynamic scoping pov.\n\nCan you say why?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq%3Amatrix.org/%243d1OOiNLo1_NPmi9cy7wSuK5PTU9MCzuZzgDTilYwAw\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I'd like to clarify that exposing AsyncContext as a feature is not the same as allowing a host or the 262 spec itself to use the AsyncContext mechanism to create a variable and make the state of that variable observable in any way. That is still completely unacceptable from an Ocap and dynamic scoping pov.</blockquote></mx-reply>Can you say why?","m.relates_to":{"m.in_reply_to":{"event_id":"$3d1OOiNLo1_NPmi9cy7wSuK5PTU9MCzuZzgDTilYwAw"}},"msgtype":"m.text"},"ts":1721215761811,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$8miw-GruisfQY1uCAIec43dXU0Q1fTEQjl2PH8BlLQI"},
{"content":{"body":"And if this is terrible for JS to do, is it terrible for the web to do?","msgtype":"m.text"},"ts":1721215871213,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$GZvw35Rq6ve0Em0oYeNjYfXluTF--WfQ5awOC_VNPGA"},
{"content":{"body":"> <@abotella:igalia.com> I don't fully understand the whole incumbent realms thing, but from what I've looked at, it doesn't seem like that would be any different from having a userland library and scheduler that uses AsyncContext variables under the hood to know whether to expose something or other\n\nAnd that is the problem. A library or user code can use AsyncContext all it wants. The spec could use an AsyncContext variable as long as it doesn't make it observable, which is roughly the same as saying it cannot. It's the same as saying user code can freely create global mutable variables, but the spec only can if it doesn't make them observable.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$VWBkaNtET8o05-M7AiHmvgGVcS8nGD0h1k89Rj0iL84?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br />I don't fully understand the whole incumbent realms thing, but from what I've looked at, it doesn't seem like that would be any different from having a userland library and scheduler that uses AsyncContext variables under the hood to know whether to expose something or other</blockquote></mx-reply>And that is the problem. A library or user code can use AsyncContext all it wants. The spec could use an AsyncContext variable as long as it doesn't make it observable, which is roughly the same as saying it cannot. It's the same as saying user code can freely create global mutable variables, but the spec only can if it doesn't make them observable.","m.relates_to":{"m.in_reply_to":{"event_id":"$VWBkaNtET8o05-M7AiHmvgGVcS8nGD0h1k89Rj0iL84"}},"msgtype":"m.text"},"ts":1721223985008,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$b47mAK_odEi9ID2fDChFH0rhTD2Tv_n0nNkPZRCb8Sg"},
{"content":{"body":"> <@littledan:matrix.org> Can you say why?\n\nBecause observable global mutable state is bad? More specifically it enables 2 parties that have not been explicitly introduced to communicate using ambient powers.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$8miw-GruisfQY1uCAIec43dXU0Q1fTEQjl2PH8BlLQI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />Can you say why?</blockquote></mx-reply>Because observable global mutable state is bad? More specifically it enables 2 parties that have not been explicitly introduced to communicate using ambient powers.","m.relates_to":{"m.in_reply_to":{"event_id":"$8miw-GruisfQY1uCAIec43dXU0Q1fTEQjl2PH8BlLQI"}},"msgtype":"m.text"},"ts":1721224244862,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$t22GKelusKn1x1r0Da1fZ5mekSEmRCk-8sD-LtG8Jfg"},
{"content":{"body":"So, are you upset about scheduler.yield(), which does this?","msgtype":"m.text"},"ts":1721224401128,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$TwA6_-OsQq1RSkBPH_-rjNEWfcQ5-cgGwH5C6gJ_B50"},
{"content":{"body":"> <@littledan:matrix.org> Oh I thought the signals concern was about certain leaks that were fixable, not the general mechanism \n\nMy concern with Signals are about leaks of global mutable state. Whether they're fixable or not, I still don't know, but you and the champions did seem optimistic. Maybe there was a misunderstanding in the nature of the leak?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$1DGjx80ridu3vlN4C3lDWdHHy-cXdFi1sidmSYAx2WQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />Oh I thought the signals concern was about certain leaks that were fixable, not the general mechanism</blockquote></mx-reply>My concern with Signals are about leaks of global mutable state. Whether they're fixable or not, I still don't know, but you and the champions did seem optimistic. Maybe there was a misunderstanding in the nature of the leak?","m.relates_to":{"m.in_reply_to":{"event_id":"$1DGjx80ridu3vlN4C3lDWdHHy-cXdFi1sidmSYAx2WQ"}},"msgtype":"m.text"},"ts":1721224405228,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$OoJNLGoGCc60pjkE9fRZhMw5Z8LqxB6weCih1-l63e0"},
{"content":{"body":"> <@mhofman:matrix.org> My concern with Signals are about leaks of global mutable state. Whether they're fixable or not, I still don't know, but you and the champions did seem optimistic. Maybe there was a misunderstanding in the nature of the leak?\n\nYeah in particular I am wondering if there are any leaks without the subtle APIs, so without currentComputed or introspection ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq%3Amatrix.org/%24OoJNLGoGCc60pjkE9fRZhMw5Z8LqxB6weCih1-l63e0\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>My concern with Signals are about leaks of global mutable state. Whether they're fixable or not, I still don't know, but you and the champions did seem optimistic. Maybe there was a misunderstanding in the nature of the leak?</blockquote></mx-reply>Yeah in particular I am wondering if there are any leaks without the subtle APIs, so without currentComputed or introspection","m.relates_to":{"m.in_reply_to":{"event_id":"$OoJNLGoGCc60pjkE9fRZhMw5Z8LqxB6weCih1-l63e0"}},"msgtype":"m.text"},"ts":1721224461013,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$vmIurpEWJVpyGRXhnZYx3G98ZdhWVhx9ry49F0N7dH0"},
{"content":{"body":"> <@littledan:matrix.org> So, are you upset about scheduler.yield(), which does this?\n\nI wasn't aware of this API but in general the web has a lot of APIs that are not Ocap friendly and ambiently expose I/O or mutable state. That's the prerogative of the host, as long as it doesn't affect 262 behavior. One problem with the above is that it affects module resolution. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$TwA6_-OsQq1RSkBPH_-rjNEWfcQ5-cgGwH5C6gJ_B50?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />So, are you upset about scheduler.yield(), which does this?</blockquote></mx-reply>I wasn't aware of this API but in general the web has a lot of APIs that are not Ocap friendly and ambiently expose I/O or mutable state. That's the prerogative of the host, as long as it doesn't affect 262 behavior. One problem with the above is that it affects module resolution.","m.relates_to":{"m.in_reply_to":{"event_id":"$TwA6_-OsQq1RSkBPH_-rjNEWfcQ5-cgGwH5C6gJ_B50"}},"msgtype":"m.text"},"ts":1721224737540,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$NjtgEXKUvmvpd_i2qX1Y-ajhO9Eil2fPe1Pm1SSqqzE"},
{"content":{"body":"As far as I can tell, incumbent realms are observable, but they shouldn't allow communication between any two parties","m.mentions":{},"msgtype":"m.text"},"ts":1721225333756,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$N7Re8e7ICqBEJ4nYQG0zu7vFyHwNGt-SYHxteZLsXXg"},
{"content":{"body":"there is only some difference to observe if the two parties run in different realms, and it seems like when an ECMAScript function (that is, not a built-in) is called, that is the incumbent realm for that function and any built-in or host function it might call","m.mentions":{},"msgtype":"m.text"},"ts":1721225464089,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Qhd-aicPwPHQMfyXRbPkqw9qLHVaZl5kd6ksNfV1k6Q"},
{"content":{"body":" * there is only some difference to observe if the two parties run in different realms, and it seems like when an ECMAScript function (that is, not a built-in) is called, its realm is the incumbent realm for that function and any built-in or host function it might call","m.mentions":{},"m.new_content":{"body":"there is only some difference to observe if the two parties run in different realms, and it seems like when an ECMAScript function (that is, not a built-in) is called, its realm is the incumbent realm for that function and any built-in or host function it might call","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Qhd-aicPwPHQMfyXRbPkqw9qLHVaZl5kd6ksNfV1k6Q","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721225473953,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$JQGtcXbjzWJGlgrYUv9xWD04tscOZ8m01o-8kCjTSks"},
{"content":{"body":"but I'm no expert on this","m.mentions":{},"msgtype":"m.text"},"ts":1721225533196,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$fXSgwHqKLyCifpljDZZyuWzM_kChLCf6_8GuO0C5L4M"},
{"content":{"body":"oh wait, maybe if some script in realm A causes a script execution in realm B, realm A might be observable","m.mentions":{},"msgtype":"m.text"},"ts":1721225731796,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$OQpQwoLoeqDOOiTTE7Odoymi6CkkgMr9QNL9ptW1cVw"},
{"content":{"body":"> <@littledan:matrix.org> So, are you upset about scheduler.yield(), which does this?\n\nLooking at this API a little more, this seems fine? Is there any global mutable state that's ambiently observable through this?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$TwA6_-OsQq1RSkBPH_-rjNEWfcQ5-cgGwH5C6gJ_B50?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />So, are you upset about scheduler.yield(), which does this?</blockquote></mx-reply>Looking at this API a little more, this seems fine? Is there any global mutable state that's ambiently observable through this?","m.relates_to":{"m.in_reply_to":{"event_id":"$TwA6_-OsQq1RSkBPH_-rjNEWfcQ5-cgGwH5C6gJ_B50"}},"msgtype":"m.text"},"ts":1721226176838,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$GDIvn4XTQslmoZnBUZ54yrwNx9h32IZPKaRyvfhk6GI"},
{"content":{"body":"> <@mhofman:matrix.org> Looking at this API a little more, this seems fine? Is there any global mutable state that's ambiently observable through this?\n\nif you don't pass the `priority` or `signal` options in the option bag, they'll be preserved across the await","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$GDIvn4XTQslmoZnBUZ54yrwNx9h32IZPKaRyvfhk6GI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Looking at this API a little more, this seems fine? Is there any global mutable state that's ambiently observable through this?</blockquote></mx-reply>if you don't pass the <code>priority</code> or <code>signal</code> options in the option bag, they'll be preserved across the await","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$GDIvn4XTQslmoZnBUZ54yrwNx9h32IZPKaRyvfhk6GI"}},"msgtype":"m.text"},"ts":1721226305387,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$5lgudUNf_2noO8kNYY0OR46QsL8XQDIR78zEY_X7mEU"},
{"content":{"body":"> <@mhofman:matrix.org> Looking at this API a little more, this seems fine? Is there any global mutable state that's ambiently observable through this?\n\n * if you don't pass the `priority` or `signal` options in the option bag, they'll be preserved from the previous call to `scheduler.yield` in the same task, even through awaits","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$GDIvn4XTQslmoZnBUZ54yrwNx9h32IZPKaRyvfhk6GI?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Looking at this API a little more, this seems fine? Is there any global mutable state that's ambiently observable through this?</blockquote></mx-reply> * if you don't pass the <code>priority</code> or <code>signal</code> options in the option bag, they'll be preserved from the previous call to <code>scheduler.yield</code> in the same task, even through awaits","m.mentions":{},"m.new_content":{"body":"if you don't pass the `priority` or `signal` options in the option bag, they'll be preserved from the previous call to `scheduler.yield` in the same task, even through awaits","format":"org.matrix.custom.html","formatted_body":"if you don't pass the <code>priority</code> or <code>signal</code> options in the option bag, they'll be preserved from the previous call to <code>scheduler.yield</code> in the same task, even through awaits","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$5lgudUNf_2noO8kNYY0OR46QsL8XQDIR78zEY_X7mEU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721226325060,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$hwEDlxBzTDQ9e3JUJAXXtbd42RD5eOPHjvhSq4JeElg"},
{"content":{"body":"So it carries some internal state, but it still doesn't make it observable, right?","msgtype":"m.text"},"ts":1721226384594,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$yeqwZDouKH7LN4-pg_l1ZUVte2ODq4tqsFdE1-hUvvw"},
{"content":{"body":"I think the \"current\" value of those properties are not exposed, but you can use `signal` to abort a yield and not continue the task","format":"org.matrix.custom.html","formatted_body":"I think the \"current\" value of those properties are not exposed, but you can use <code>signal</code> to abort a yield and not continue the task","m.mentions":{},"msgtype":"m.text"},"ts":1721226428891,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$zalF7conzRVNqM8qSq3uAwMdRnHptw2ks6LsHL3ZqTc"},
{"content":{"body":"I guess that wouldn't count as communication between parties though","m.mentions":{},"msgtype":"m.text"},"ts":1721226490459,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$cKZkvskHBk89dw48-SoTFO6O-aSY7mif8MFFHHp75QE"},
{"content":{"body":"actually, the promise would reject if the signal is aborted, so I guess that *is* communication","format":"org.matrix.custom.html","formatted_body":"actually, the promise would reject if the signal is aborted, so I guess that <em>is</em> communication","m.mentions":{},"msgtype":"m.text"},"ts":1721226584342,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$UcqWRa9WQpiRf149F1kbLICSku4o8r_siTKxnXEAW-8"},
{"content":{"body":"Yeah I just saw that. That is indeed a way for the caller to ambiently communicate with the logic it spawned. I'm a little surprised they didn't go with an explicit context since retrofitting this ambient state to existing APIs like fetch seems inappropriate.","msgtype":"m.text"},"ts":1721228268759,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ZqaoORiz82Ivfpw_nMP3Vi2SpdEceZDqNpFXNv4pDEc"},
{"content":{"body":"Aka as a developer I could be surprised by either the abort signal of my task not being respected by fetch called within my task's execution, or by an existing fetch all the sudden aborting not realizing it became part of a posted task.","msgtype":"m.text"},"ts":1721228441419,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$huNfwvd-sqCLNDbv1KoCYzAAr-pJFl-XtCl23YV535I"},
{"content":{"body":"* Aka as a developer I could be surprised by either the abort signal of my task not being respected by fetch called within my task's execution, or by an existing fetch all the sudden aborting not realizing it became part of a posted continued task.","m.new_content":{"body":"Aka as a developer I could be surprised by either the abort signal of my task not being respected by fetch called within my task's execution, or by an existing fetch all the sudden aborting not realizing it became part of a posted continued task.","msgtype":"m.text"},"m.relates_to":{"event_id":"$huNfwvd-sqCLNDbv1KoCYzAAr-pJFl-XtCl23YV535I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721228458453,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$02jwZfo21FyiHR8qLhmWSdG4lBLF1b2KB7X1N8vKjws"},
{"content":{"body":"I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" `scheduler.yield()` calls – implicit signal propagation is not in scope for that proposal\\","format":"org.matrix.custom.html","formatted_body":"I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" <code>scheduler.yield()</code> calls – implicit signal propagation is not in scope for that proposal\\","m.mentions":{},"msgtype":"m.text"},"ts":1721229884815,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$HddX2P_5aAgkzfpY4kIY2GlxYvGvAXfheJoFnDKnsvQ"},
{"content":{"body":" * I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" `scheduler.yield()` calls – implicit signal propagation is not in scope for that proposal","format":"org.matrix.custom.html","formatted_body":" * I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" <code>scheduler.yield()</code> calls – implicit signal propagation is not in scope for that proposal","m.mentions":{},"m.new_content":{"body":"I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" `scheduler.yield()` calls – implicit signal propagation is not in scope for that proposal","format":"org.matrix.custom.html","formatted_body":"I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" <code>scheduler.yield()</code> calls – implicit signal propagation is not in scope for that proposal","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$HddX2P_5aAgkzfpY4kIY2GlxYvGvAXfheJoFnDKnsvQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721229891184,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$p3g1HYeGTt7shthXmfYCtMMaDFzovO7gM-RESBO_ecU"},
{"content":{"body":" * I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" `scheduler.yield()` calls – implicit signal propagation for e.g. fetch is not in scope for that proposal","format":"org.matrix.custom.html","formatted_body":" * I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" <code>scheduler.yield()</code> calls – implicit signal propagation for e.g. fetch is not in scope for that proposal","m.mentions":{},"m.new_content":{"body":"I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" `scheduler.yield()` calls – implicit signal propagation for e.g. fetch is not in scope for that proposal","format":"org.matrix.custom.html","formatted_body":"I haven't looked enough at the details, but I think aborting the signal would only implicitly abort any \"inherited\" <code>scheduler.yield()</code> calls – implicit signal propagation for e.g. fetch is not in scope for that proposal","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$HddX2P_5aAgkzfpY4kIY2GlxYvGvAXfheJoFnDKnsvQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721229913638,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$kJZOC5Vz__tSkxAfl64kdsGpeZxVfY2K8D_bQOG0sE0"},
{"content":{"body":"It is limited in scope but still observable. But this is \"deniable\" by blocking APIs which do this sharing (just like all the other DOM APIs that deal with the document)","m.mentions":{},"msgtype":"m.text"},"ts":1721233180181,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$civf9wqq-kkJzyBHKGFt-JNwbN1sm3qFMmFlu4iHheQ"},
{"content":{"body":"> <@abotella:igalia.com> if you don't pass the `priority` or `signal` options in the option bag, they'll be preserved from the previous call to `scheduler.yield` in the same task, even through awaits\n\nsidebar, this behavior is very strange and I hate it for reasons having nothing to do with communications channels","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$5lgudUNf_2noO8kNYY0OR46QsL8XQDIR78zEY_X7mEU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>if you don't pass the <code>priority</code> or <code>signal</code> options in the option bag, they'll be preserved from the previous call to <code>scheduler.yield</code> in the same task, even through awaits</blockquote></mx-reply>sidebar, this behavior is very strange and I hate it for reasons having nothing to do with communications channels","m.mentions":{"user_ids":["@abotella:igalia.com","@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$5lgudUNf_2noO8kNYY0OR46QsL8XQDIR78zEY_X7mEU"}},"msgtype":"m.text"},"ts":1721236884825,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$SYBH6aISjGVac88PIafrcojJvg-Q_tnb3ki9jKwgaS0"},
{"content":{"body":"it just makes programs harder to reason about","m.mentions":{},"msgtype":"m.text"},"ts":1721236889418,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$v6jmuCig8Itr0dKk4ZSd_6xuLNae9qTxEcq9l7Tr9nA"},
{"content":{"body":"much harder","m.mentions":{},"msgtype":"m.text"},"ts":1721236891246,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cm9ApFWxvR5nTgIEy575r3DbRzhM6fyRtTZsPGft3gw"},
{"content":{"body":"love2global","m.mentions":{},"msgtype":"m.text"},"ts":1721236911018,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$FYEGAH1mTd2zTulRSP9k-QG3I8KJ5fbQwZLTd9ueP8w"},
{"content":{"body":"I don't know how it is that we have managed to get so many people doing API design who do not instinctively recoil from adding new global state","m.mentions":{},"msgtype":"m.text"},"ts":1721237008189,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$AT8Op2x8R2L5szlQRLH7c89qTtlwjFJaRNoZRu2BgCs"},
{"content":{"body":"the developer funnel will always be largest at the top","msgtype":"m.text"},"ts":1721237077434,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$C_dujmYM7WL_u5FphTL_plXG9JUbCpRAnqc3n5VJ8dI"},
{"content":{"body":"why can't a developer love global state earnestly","m.mentions":{},"msgtype":"m.text"},"ts":1721237137123,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$seFLYY8JgEL0-8_pAHfV6O7jzu8ybuatE-1LASJK2sg"},
{"content":{"body":"random developers can do whatever they want, it's only the platform designers whose bad opinions the rest of us have to live with","m.mentions":{},"msgtype":"m.text"},"ts":1721237280392,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$X52NscdNmQwEdJxgYGLM7tmFjaZk5zxU876Nx2-5VMQ"},
{"content":{"body":"speaking as a platform designer","m.mentions":{},"msgtype":"m.text"},"ts":1721237283275,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$MW3PCDA-GO_xTIetgflwhg2ks5eZcMq_sAI-GpxeLzM"},
{"content":{"body":"we used to, but then someone mutated it and now we don't","m.mentions":{},"msgtype":"m.text"},"ts":1721237288333,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$dzhVS54TkvPjLHT_HlFXQqAp6gH0zsG-LiYvb1AA8n4"},
{"content":{"body":" * we used to love it, but then someone mutated it and now we don't","m.mentions":{},"m.new_content":{"body":"we used to love it, but then someone mutated it and now we don't","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$dzhVS54TkvPjLHT_HlFXQqAp6gH0zsG-LiYvb1AA8n4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721237298323,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$3sQi41u91qTCsE0Ibc4tQUWiXvWncU_1fjmY2edgk0o"},
{"content":{"body":"TIL that ClassHeritage has access to the inner immutable class name binding but not private names","msgtype":"m.text"},"ts":1721237312206,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$glYI6BgvluttcjW1oQXCIUPGJxYuAfIHU_T9drG0fd8"},
{"content":{"body":"that is *so weird*","format":"org.matrix.custom.html","formatted_body":"that is <i data-md=\"*\">so weird</i>","msgtype":"m.text"},"ts":1721237315846,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$wRlS3UYMp4EUT5N8iDJtrFN-PZ8eQ-W0XfElStmpw5I"},
{"content":{"body":"yeah i'm a class hater now","m.mentions":{},"msgtype":"m.text"},"ts":1721237345661,"senderName":"global_lover","senderId":"@shuyuguo:matrix.org","id":"$SXOxVKlGIFfJESmvNYFa9It4gPwVF142m5sc7gPp4xE"},
{"content":{"body":"class name is outer to the `{` and so is ClassHeritage whil private names are inner to the `{`","format":"org.matrix.custom.html","formatted_body":"class name is outer to the <code>{</code> and so is ClassHeritage whil private names are inner to the <code>{</code>","m.mentions":{},"msgtype":"m.text"},"ts":1721237394349,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$kCgyksm1Mab9bithC345AWtoax3zDzwz9oXpx3yLO0w"},
{"content":{"body":" * class name is outer to the `{` and so is ClassHeritage while private names are inner to the `{`","format":"org.matrix.custom.html","formatted_body":" * class name is outer to the <code>{</code> and so is ClassHeritage while private names are inner to the <code>{</code>","m.mentions":{},"m.new_content":{"body":"class name is outer to the `{` and so is ClassHeritage while private names are inner to the `{`","format":"org.matrix.custom.html","formatted_body":"class name is outer to the <code>{</code> and so is ClassHeritage while private names are inner to the <code>{</code>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$kCgyksm1Mab9bithC345AWtoax3zDzwz9oXpx3yLO0w","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721237401328,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$-rWZnAfCFx-UMVAlm9On-QIoo6WaYmbnhC0-bY7OiFY"},
{"content":{"body":"@bakkot:matrix.org *inner* class name binding","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/%40bakkot%3Amatrix.org\">@bakkot</a> <i data-md=\"*\">inner</i> class name binding","msgtype":"m.text"},"ts":1721237409078,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$mDauC4Ww5_Nbnu1GHyi_uycu8Q3IYe3_RModoF87YDM"},
{"content":{"body":"the immutable one","msgtype":"m.text"},"ts":1721237413801,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$M4USsf0cspuZsEPqYNgA-9OO8aeiFFVb2KEEnAtbokE"},
{"content":{"body":"I mean that the name occurs syntactically outside of the `{`","format":"org.matrix.custom.html","formatted_body":"I mean that the name occurs syntactically outside of the <code>{</code>","m.mentions":{},"msgtype":"m.text"},"ts":1721237433067,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$5twK4ydbGj4nSUD5Y2DKYq4gC8k6xSqFQpsZ7VS126c"},
{"content":{"body":"so it makes sense that the binding lives outside of it also","m.mentions":{},"msgtype":"m.text"},"ts":1721237438169,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$uQOXS9lQsyWqGfH5AXfWr4RAPESKWVkXV_oP4xz7BKU"},
{"content":{"body":"remember that classes create 2 bindings: an outer mutable one and an inner immutable one","msgtype":"m.text"},"ts":1721237439104,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$AnQNotTA-N4_2q3vowTz_J0dl4zqC21Tysw4Eo3n_0Y"},
{"content":{"body":"yes I know","m.mentions":{},"msgtype":"m.text"},"ts":1721237443834,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$3uKP_CWqet143GvBDIMWQFqIBwB47_AA54Om1d0tjrc"},
{"content":{"body":"that does not contradiction what I just aid","m.mentions":{},"msgtype":"m.text"},"ts":1721237450462,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$vigPNiFRmF4CjevsibE6j-jMiO-SCSvSe8g14asyXkI"},
{"content":{"body":"syntactically both bindings are created by a single identifier, and that identifier is outside of the `{`","format":"org.matrix.custom.html","formatted_body":"syntactically both bindings are created by a single identifier, and that identifier is outside of the <code>{</code>","m.mentions":{},"msgtype":"m.text"},"ts":1721237473569,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$QRJVZJaUm3-75uEDuHqBKLL3Mrq_TrcbaDlEm4hMx8I"},
{"content":{"body":" * that does not contradict what I just aid","m.mentions":{},"m.new_content":{"body":"that does not contradict what I just aid","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$vigPNiFRmF4CjevsibE6j-jMiO-SCSvSe8g14asyXkI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721237485467,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Uvqf6ta-hz8GakAqwuqm7fE22LVu2enQesvtgBDfNx0"},
{"content":{"body":"> <@bakkot:matrix.org> I don't know how it is that we have managed to get so many people doing API design who do not instinctively recoil from adding new global state\n\nThe whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does. We just know, empirically, that if you ask everyone to put in the right priority, they will just forget a lot of the time. Just like if we asked them to explicitly pass around the Otel spanid/traceid.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$AT8Op2x8R2L5szlQRLH7c89qTtlwjFJaRNoZRu2BgCs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>I don&#39;t know how it is that we have managed to get so many people doing API design who do not instinctively recoil from adding new global state</blockquote></mx-reply>The whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does. We just know, empirically, that if you ask everyone to put in the right priority, they will just forget a lot of the time. Just like if we asked them to explicitly pass around the Otel spanid/traceid.","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$AT8Op2x8R2L5szlQRLH7c89qTtlwjFJaRNoZRu2BgCs"}},"msgtype":"m.text"},"ts":1721237497712,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$TpWpF5jFxYxjfSInUIsQQiyh8ocbBFZ78RNoZ3lvWgI"},
{"content":{"body":"I think the inner one should only be available inside the `{`","format":"org.matrix.custom.html","formatted_body":"I think the inner one should only be available inside the <code data-md=\"`\">{</code>","msgtype":"m.text"},"ts":1721237508045,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$KVOB1-gGQ5TA5ymGI4BYj9tjwaocueq4wLdXzapsge4"},
{"content":{"body":"> <@littledan:matrix.org> The whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does. We just know, empirically, that if you ask everyone to put in the right priority, they will just forget a lot of the time. Just like if we asked them to explicitly pass around the Otel spanid/traceid.\n\nIIUC, with AsyncContext you have to have a reference to the context in order to see or affect the state. it's not going to be affected by calling into random libraries. whereas with `scheduler.yield`, if I am doing some random stuff, and then I do `library.doWork()`, and the library does `scheduler.yield({ its own config })`, now _my_ future calls to `scheduler.yield` don't work how I expected. that's crazy.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$TpWpF5jFxYxjfSInUIsQQiyh8ocbBFZ78RNoZ3lvWgI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>The whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does. We just know, empirically, that if you ask everyone to put in the right priority, they will just forget a lot of the time. Just like if we asked them to explicitly pass around the Otel spanid/traceid.</blockquote></mx-reply>IIUC, with AsyncContext you have to have a reference to the context in order to see or affect the state. it's not going to be affected by calling into random libraries. whereas with <code>scheduler.yield</code>, if I am doing some random stuff, and then I do <code>library.doWork()</code>, and the library does <code>scheduler.yield({ its own config })</code>, now <em>my</em> future calls to <code>scheduler.yield</code> don't work how I expected. that's crazy.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$TpWpF5jFxYxjfSInUIsQQiyh8ocbBFZ78RNoZ3lvWgI"}},"msgtype":"m.text"},"ts":1721237600610,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ifMMNYLY3KBYrlcf1pABDqVcgGkBne7ORfYCcBALLt0"},
{"content":{"body":"if I gave the library the context object then it is perfectly reasonable for it to see/affect it","m.mentions":{},"msgtype":"m.text"},"ts":1721237617822,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$TrldVMH2qA_duiYfEDFp1DzOl5gNtSy0w1YfKRPwDeo"},
{"content":{"body":"but for it to be global, that's very strange","m.mentions":{},"msgtype":"m.text"},"ts":1721237621624,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$T5QOg_VAIkbKw2fHT9dAL1Dq7Qg7MmoSCqGv2YIHpgU"},
{"content":{"body":"> <@michaelficarra:matrix.org> remember that classes create 2 bindings: an outer mutable one and an inner immutable one\n\noh no I know this first time","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$AnQNotTA-N4_2q3vowTz_J0dl4zqC21Tysw4Eo3n_0Y\">In reply to</a> <a href=\"https://matrix.to/#/@michaelficarra:matrix.org\">@michaelficarra:matrix.org</a><br>remember that classes create 2 bindings: an outer mutable one and an inner immutable one</blockquote></mx-reply>oh no I know this first time","m.relates_to":{"m.in_reply_to":{"event_id":"$AnQNotTA-N4_2q3vowTz_J0dl4zqC21Tysw4Eo3n_0Y"}},"msgtype":"m.text"},"ts":1721237745581,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$mk991HQjk9Lcj6tKHXWXXptewwOi0n2JcyhBYxS1owc"},
{"content":{"body":"if you wanted to avoid the problem where people forget to pass the right priority for `scheduler`, the obvious fix is to require you to construct a `scheduler` object and pass it around, instead of there being a global one","format":"org.matrix.custom.html","formatted_body":"if you wanted to avoid the problem where people forget to pass the right priority for <code>scheduler</code>, the obvious fix is to require you to construct a <code>scheduler</code> object and pass it around, instead of there being a global one","m.mentions":{},"msgtype":"m.text"},"ts":1721237747650,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$av8L3oBQqjjABGU7r2WJGgCopUtM0Ea08OtO7BDkiAU"},
{"content":{"body":"and to avoid the problem of requiring other libraries to thread it around, that's what AsyncContext is for","m.mentions":{},"msgtype":"m.text"},"ts":1721237769868,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BzWmh1RNGtR8E9KwocbXRtPdAOov9J8BIEMs07Jwo5E"},
{"content":{"body":"look, even the functional people reconstructed implicit globals with monads to mimic their power","m.mentions":{},"msgtype":"m.text"},"ts":1721237852685,"senderName":"global_lover","senderId":"@shuyuguo:matrix.org","id":"$8fvVucRuMY53nE5FgCPbDv_J-joT26kR8vt8luh3Bnk"},
{"content":{"body":" * if you wanted to avoid the problem where people forget to pass the right priority for `scheduler`, the obvious fix is to require you to construct a `scheduler` object (and explicitly specify the priority) and pass it around, instead of there being a global one","format":"org.matrix.custom.html","formatted_body":" * if you wanted to avoid the problem where people forget to pass the right priority for <code>scheduler</code>, the obvious fix is to require you to construct a <code>scheduler</code> object (and explicitly specify the priority) and pass it around, instead of there being a global one","m.mentions":{},"m.new_content":{"body":"if you wanted to avoid the problem where people forget to pass the right priority for `scheduler`, the obvious fix is to require you to construct a `scheduler` object (and explicitly specify the priority) and pass it around, instead of there being a global one","format":"org.matrix.custom.html","formatted_body":"if you wanted to avoid the problem where people forget to pass the right priority for <code>scheduler</code>, the obvious fix is to require you to construct a <code>scheduler</code> object (and explicitly specify the priority) and pass it around, instead of there being a global one","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$av8L3oBQqjjABGU7r2WJGgCopUtM0Ea08OtO7BDkiAU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721237914487,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$V_zG6piKMSqfsamoXYsxL_sAlwBEOZ-AsEuDWEdDXMw"},
{"content":{"body":"> <@bakkot:matrix.org> IIUC, with AsyncContext you have to have a reference to the context in order to see or affect the state. it's not going to be affected by calling into random libraries. whereas with `scheduler.yield`, if I am doing some random stuff, and then I do `library.doWork()`, and the library does `scheduler.yield({ its own config })`, now _my_ future calls to `scheduler.yield` don't work how I expected. that's crazy.\n\nI don't think it works like that","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$ifMMNYLY3KBYrlcf1pABDqVcgGkBne7ORfYCcBALLt0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>IIUC, with AsyncContext you have to have a reference to the context in order to see or affect the state. it's not going to be affected by calling into random libraries. whereas with <code>scheduler.yield</code>, if I am doing some random stuff, and then I do <code>library.doWork()</code>, and the library does <code>scheduler.yield({ its own config })</code>, now <em>my</em> future calls to <code>scheduler.yield</code> don't work how I expected. that's crazy.</blockquote></mx-reply>I don't think it works like that","m.mentions":{"user_ids":["@bakkot:matrix.org","@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ifMMNYLY3KBYrlcf1pABDqVcgGkBne7ORfYCcBALLt0"}},"msgtype":"m.text"},"ts":1721237933547,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$f_IE6qMoa8gpYwiZzf67L81dG5nt7pnvGmLi9EZ3m4Y"},
{"content":{"body":"but maybe my understanding is wrong, because based on my understanding I don't understand how scheduler.yield would be implemented based on CPED","m.mentions":{},"msgtype":"m.text"},"ts":1721237989538,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$KhaKxk42eCDSGLigzEBbaGNHPS6NGkhQ5_8OeuZjdfk"},
{"content":{"body":" * but maybe my understanding is wrong, because while I was trying to explain how it worked, I realized that according to my understanding scheduler.yield shouldn't be implementable based on CPED","m.mentions":{},"m.new_content":{"body":"but maybe my understanding is wrong, because while I was trying to explain how it worked, I realized that according to my understanding scheduler.yield shouldn't be implementable based on CPED","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$KhaKxk42eCDSGLigzEBbaGNHPS6NGkhQ5_8OeuZjdfk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721238031029,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$8W1JNGTW-aa8h68mx5cfJf5f8IslTjIvYA8ZGILKrAs"},
{"content":{"body":"but of course it is implemented that way","m.mentions":{},"msgtype":"m.text"},"ts":1721238036415,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$vSyMk8sQ9mmRLg5R5sIZ5x0xQIsaaEGA-CbtfMQ3YcM"},
{"content":{"body":"For context: https://github.com/WICG/scheduling-apis/blob/main/explainers/yield-and-continuation.md","m.mentions":{},"msgtype":"m.text"},"ts":1721238050633,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$xFJQ4ZlzSNP7D4NH7HgX421FJ7Cag-IxyoJxwj9fnwE"},
{"content":{"body":"that lists as an open question:\n\n> Does `yield({priority})` set the priority to be inherited in future calls, or is the original signal used?\n\nif I understand what this is saying correctly, using the original priority would be fine by me - it's only the \"calling a library function can change the priority used by the rest of my code\" part I'm objecting to here","format":"org.matrix.custom.html","formatted_body":"<p>that lists as an open question:</p>\n<blockquote>\n<p>Does <code>yield({priority})</code> set the priority to be inherited in future calls, or is the original signal used?</p>\n</blockquote>\n<p>if I understand what this is saying correctly, using the original priority would be fine by me - it's only the \"calling a library function can change the priority used by the rest of my code\" part I'm objecting to here</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1721238556353,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$J9jCsFi6bkmRoJAwHQ1w_YZ4opAi3KtodeM-dDbnqQk"},
{"content":{"body":"> The whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does\nIs it? AsyncContext allows you to propagate some data related to a reference you own. The web instead creates an internal reference, and exposes way to access information related to that reference to anyone. scheduler.yield is effectively equivalent to a `myInternalAsyncContextVar.get()` ","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>The whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does<br>Is it? AsyncContext allows you to propagate some data related to a reference you own. The web instead creates an internal reference, and exposes way to access information related to that reference to anyone. scheduler.yield is effectively equivalent to a <code>myInternalAsyncContextVar.get()</code></p>\n</blockquote>\n","m.mentions":{},"msgtype":"m.text"},"ts":1721238588586,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$vkMQw_SdmoWihXFmzZ19GVlyJce3zs-dQDJsl8oyoYA"},
{"content":{"body":" * > The whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does\n\nIs it? AsyncContext allows you to propagate some data related to a reference you own. The web instead creates an internal reference, and exposes way to access information related to that reference to anyone. scheduler.yield is effectively equivalent to a `myInternalAsyncContextVar.get()`","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>The whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does</p>\n</blockquote>\n<p>Is it? AsyncContext allows you to propagate some data related to a reference you own. The web instead creates an internal reference, and exposes way to access information related to that reference to anyone. scheduler.yield is effectively equivalent to a <code>myInternalAsyncContextVar.get()</code></p>\n","m.mentions":{},"m.new_content":{"body":"> The whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does\n\nIs it? AsyncContext allows you to propagate some data related to a reference you own. The web instead creates an internal reference, and exposes way to access information related to that reference to anyone. scheduler.yield is effectively equivalent to a `myInternalAsyncContextVar.get()`","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>The whole point of AsyncContext is that it's not global, but rather scoped in the appropriate way. And that's what scheduler.yield does</p>\n</blockquote>\n<p>Is it? AsyncContext allows you to propagate some data related to a reference you own. The web instead creates an internal reference, and exposes way to access information related to that reference to anyone. scheduler.yield is effectively equivalent to a <code>myInternalAsyncContextVar.get()</code></p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$vkMQw_SdmoWihXFmzZ19GVlyJce3zs-dQDJsl8oyoYA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721238599858,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$4o6JX_xDYByl-StmZqN7db_nhRWiLiK04G1SYVF1_bA"},
{"content":{"body":"> <@bakkot:matrix.org> IIUC, with AsyncContext you have to have a reference to the context in order to see or affect the state. it's not going to be affected by calling into random libraries. whereas with `scheduler.yield`, if I am doing some random stuff, and then I do `library.doWork()`, and the library does `scheduler.yield({ its own config })`, now _my_ future calls to `scheduler.yield` don't work how I expected. that's crazy.\n\nThat is the outcome of having the equivalent of a single global asynccontext variable","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$ifMMNYLY3KBYrlcf1pABDqVcgGkBne7ORfYCcBALLt0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>IIUC, with AsyncContext you have to have a reference to the context in order to see or affect the state. it's not going to be affected by calling into random libraries. whereas with <code>scheduler.yield</code>, if I am doing some random stuff, and then I do <code>library.doWork()</code>, and the library does <code>scheduler.yield({ its own config })</code>, now <em>my</em> future calls to <code>scheduler.yield</code> don't work how I expected. that's crazy.</blockquote></mx-reply>That is the outcome of having the equivalent of a single global asynccontext variable","m.mentions":{"user_ids":["@bakkot:matrix.org","@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ifMMNYLY3KBYrlcf1pABDqVcgGkBne7ORfYCcBALLt0"}},"msgtype":"m.text"},"ts":1721238699331,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Ji56RRGXSiIk6GTTH0yhYIunl_OZxuQ4yFUZcIU3niI"},
{"content":{"body":"> <@bakkot:matrix.org> that lists as an open question:\n> \n> > Does `yield({priority})` set the priority to be inherited in future calls, or is the original signal used?\n> \n> if I understand what this is saying correctly, using the original priority would be fine by me - it's only the \"calling a library function can change the priority used by the rest of my code\" part I'm objecting to here\n\nI think it would only set the priority to be inherited in promise reactions that flow from the returned promise","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$J9jCsFi6bkmRoJAwHQ1w_YZ4opAi3KtodeM-dDbnqQk?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br><p>that lists as an open question:</p>\n<blockquote>\n<p>Does <code>yield({priority})</code> set the priority to be inherited in future calls, or is the original signal used?</p>\n</blockquote>\n<p>if I understand what this is saying correctly, using the original priority would be fine by me - it's only the \"calling a library function can change the priority used by the rest of my code\" part I'm objecting to here</p>\n</blockquote></mx-reply>I think it would only set the priority to be inherited in promise reactions that flow from the returned promise","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$J9jCsFi6bkmRoJAwHQ1w_YZ4opAi3KtodeM-dDbnqQk"}},"msgtype":"m.text"},"ts":1721238810140,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$B6yJtjYCjSSaxlrGDPuY945VpAxIw55PSCoZiuPXyUc"},
{"content":{"body":"so in an async function, only for the remainder of the function","m.mentions":{},"msgtype":"m.text"},"ts":1721238828004,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$w84L5J4TN_GJYamdkjsGMwfv6b7Z9Ni3Cdu0VOy-lu0"},
{"content":{"body":"it wouldn't affect an outer function","m.mentions":{},"msgtype":"m.text"},"ts":1721238848075,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$EZH-Hu_wF2HD6zdxH7-z-MSIca9jLnzJz9MZAOiHeU0"},
{"content":{"body":"I don't think","m.mentions":{},"msgtype":"m.text"},"ts":1721238850079,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$GRHTMuwphML83WEwoSsYCYZC_vFCp7EH6ZCbHzqZ_-M"},
{"content":{"body":" * it wouldn't affect an outer async function","m.mentions":{},"m.new_content":{"body":"it wouldn't affect an outer async function","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$EZH-Hu_wF2HD6zdxH7-z-MSIca9jLnzJz9MZAOiHeU0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721238889726,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$prbDoADQHVqg8IKYDAYyafoTby_QMhMBuQ6wIlqsTZs"},
{"content":{"body":"seems like yield does the equivalent of enterWith, which AsyncContext currently omits","m.mentions":{},"msgtype":"m.text"},"ts":1721238896909,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$StXH0vtdGqynxTheHXPom6rtLmc16jOgBLRAlVLfd64"},
{"content":{"body":" * seems like scheduler.yield does the equivalent of enterWith, which AsyncContext currently omits","m.mentions":{},"m.new_content":{"body":"seems like scheduler.yield does the equivalent of enterWith, which AsyncContext currently omits","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$StXH0vtdGqynxTheHXPom6rtLmc16jOgBLRAlVLfd64","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721238906302,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$cuWFUU8CyAiPHwRamrckZiv8fRmd-KvHQdvCBeJ7ZOA"},
{"content":{"body":"> <@abotella:igalia.com> it wouldn't affect an outer async function\n\nah, that would be fine too then, though I'm not sure how that follows from \"only reactions that flow from the returned promise\" - the remainder of an outer async function would still ultimately flow from that reaction","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$EZH-Hu_wF2HD6zdxH7-z-MSIca9jLnzJz9MZAOiHeU0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>it wouldn&#39;t affect an outer async function</blockquote></mx-reply>ah, that would be fine too then, though I'm not sure how that follows from \"only reactions that flow from the returned promise\" - the remainder of an outer async function would still ultimately flow from that reaction","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$EZH-Hu_wF2HD6zdxH7-z-MSIca9jLnzJz9MZAOiHeU0"}},"msgtype":"m.text"},"ts":1721238963500,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$vf1D5fTynZCxlxIoIg_p3aA8ulXZl776fY01BdModdQ"},
{"content":{"body":"it's weird though - we don't normally treat function boundaries as special at all, except for like `using`","format":"org.matrix.custom.html","formatted_body":"it's weird though - we don't normally treat function boundaries as special at all, except for like <code>using</code>","m.mentions":{},"msgtype":"m.text"},"ts":1721238991492,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$RZMV6zBdHDCs_whP_E-ZHiYYFbcgRMV44IPFtNIZ_r4"},
{"content":{"body":" * it's weird in other ways though - we don't normally treat function boundaries as special at all, except for like `using`","format":"org.matrix.custom.html","formatted_body":" * it's weird in other ways though - we don't normally treat function boundaries as special at all, except for like <code>using</code>","m.mentions":{},"m.new_content":{"body":"it's weird in other ways though - we don't normally treat function boundaries as special at all, except for like `using`","format":"org.matrix.custom.html","formatted_body":"it's weird in other ways though - we don't normally treat function boundaries as special at all, except for like <code>using</code>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$RZMV6zBdHDCs_whP_E-ZHiYYFbcgRMV44IPFtNIZ_r4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721238998425,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$k7GJ6luNFYRLmULImX-GyvlgQJDwDMc5-6hNUdjLjvc"},
{"content":{"body":"it's not the function boundary that is special, it's the promise jobs that are","m.mentions":{},"msgtype":"m.text"},"ts":1721239282357,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$o3172FjtzPpKgtSOrqcvaig0rBnI0pykhWRkIt7UmYI"},
{"content":{"body":"is it treating function boundaries as special or treating promises as special, and async functions use promises","m.mentions":{},"msgtype":"m.text"},"ts":1721239310263,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$WRNquuk8G8xRiP-128ArJgX-Es4t-UbBNRirKazxNPM"},
{"content":{"body":"oh lol","m.mentions":{},"msgtype":"m.text"},"ts":1721239315263,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$6WqfVAzNR58X6hXhUD905WZ1z2ocpHZBY1VuRKG6vMo"},
{"content":{"body":"when you return from an async function, its reaction will run in a different promise job","m.mentions":{},"msgtype":"m.text"},"ts":1721239333018,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$rSYe3vdIN-dswspejgDQQprwOHyYuk8xL_0pufJdxP8"},
{"content":{"body":"the `.then()` was called before it, and since AsyncContext preserves the context when `.then()` was called, the context inside the async function can't flow back to its caller","format":"org.matrix.custom.html","formatted_body":"the <code>.then()</code> was called before it, and since AsyncContext preserves the context when <code>.then()</code> was called, the context inside the async function can't flow back to its caller","m.mentions":{},"msgtype":"m.text"},"ts":1721239376574,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$AEXTEwqfocsM9EGUYGyQNfaoSEKyMwfBGdMBUy4d_yM"},
{"content":{"body":"ah, makes sense","m.mentions":{},"msgtype":"m.text"},"ts":1721239447003,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ZvK8QDU1sJflEDFV9dGNi0xMgkhVY4cDv5LFYVq-5KA"},
{"content":{"body":"so the only boundary here is AsyncContext.Variable.prototype.run(callback) -- that's when something changes. Everything else is just propagating the map (as AsyncContext.Snapshot.prototype.run does)","m.mentions":{},"msgtype":"m.text"},"ts":1721239898225,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$qm7QCwVs66YI4tTZuW43TrPZmkiQ9f4z04THlq2J-oU"},
{"content":{"body":"both work by callbacks, not treating function boundaries or Promises special","m.mentions":{},"msgtype":"m.text"},"ts":1721239912874,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$JSNL6443h8oHHd1nWzWpI33Fe0nxc6JWQdIsYg8UDR4"},
{"content":{"body":"Promises are just one of the cases where the snapshot is propagated (as a constant, not a subtask or something)","m.mentions":{},"msgtype":"m.text"},"ts":1721239928421,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kHQZSp1vTaPES8S8E8GVL514QgsWnfUMiu1LMx2X2To"},
{"content":{"body":"there's no way to mutate any variable in place, only to \"fork\" with variable.run","m.mentions":{},"msgtype":"m.text"},"ts":1721239949503,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$P3kUhj4ru5DOilYDZpMtXd_24nGvEj7SzoBYZKKGrp4"},
{"content":{"body":"this all was pretty core to the SES analysis that AsyncContext was kosher","m.mentions":{},"msgtype":"m.text"},"ts":1721239964185,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$cp0M71jKQGckwZTsQEFEgxiGY655iBowuPXumy9lsgk"},
{"content":{"body":"some people are coming into the AsyncContext group and proposing other semantics which would permit more like this yield pattern. I've generally been pushing back on it.","m.mentions":{},"msgtype":"m.text"},"ts":1721239998732,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uQSw-V8SMOpU0BVIoGyhCiI9eMt-op9xpJczrnwFJjc"},
{"content":{"body":"as mentioned in the other channel you can still put a mutable thing into an async variable","m.mentions":{},"msgtype":"m.text"},"ts":1721240005946,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$9pkrjt3c42gSskQdWNimGzf1s-5buO-CVnHNmZKu9mo"}
]