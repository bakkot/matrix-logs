[
{"content":{"body":"bakkot i think u got a good solution to my question","msgtype":"m.text"},"ts":1631326727044,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$Z8EJXxeb3yjqZuk8K8OUFigDL-Vqm7NpBnO3Xzt3nmI"},
{"content":{"body":"zip shortest + make everything except the first one infinite","msgtype":"m.text"},"ts":1631326735925,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$YQY_YjXlxrXcVx0T7wsrr7pEQRL4u85T6hNublCmN3o"},
{"content":{"body":"`zip-longest` is actually the interesting one; my thing does not give you that unless you know up front which the longest one is","format":"org.matrix.custom.html","formatted_body":"<code>zip-longest</code> is actually the interesting one; my thing does not give you that unless you know up front which the longest one is","msgtype":"m.text"},"ts":1631328255729,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$WfsGYbq2vTT5wIpDM14ZDs40u5rWiT8N_TrZhmyrSfY"},
{"content":{"body":"shortest I can come up with in ten minutes is\n\n```\ndef zip_longest(*parts, fillvalue=None):\n  sigil = {}\n  return map(\n    lambda p: tuple(map(lambda x: x if x is not sigil else fillvalue, p)),\n    takewhile(\n      lambda p: not (all(map(lambda x: x is sigil, p))),\n      zip(*(chain(x, repeat(sigil)) for x in parts))\n    )\n  )\n```\nwhich... I guess it's straightforward enough, but I get why python decided that was worth putting in the standard library","format":"org.matrix.custom.html","formatted_body":"<p>shortest I can come up with in ten minutes is</p>\n<pre><code>def zip_longest(*parts, fillvalue=None):\n  sigil = {}\n  return map(\n    lambda p: tuple(map(lambda x: x if x is not sigil else fillvalue, p)),\n    takewhile(\n      lambda p: not (all(map(lambda x: x is sigil, p))),\n      zip(*(chain(x, repeat(sigil)) for x in parts))\n    )\n  )\n</code></pre>\n<p>which... I guess it's straightforward enough, but I get why python decided that was worth putting in the standard library</p>\n","msgtype":"m.text"},"ts":1631329024574,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$D_JG00SvRP1QaoGEFbSOFfapSLfoKNQ28WAk_7plYHw"},
{"content":{"body":"itertools docs has examples for how to implement the functions https://docs.python.org/3/library/itertools.html#itertools.zip_longest","msgtype":"m.text"},"ts":1631372437791,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$vqgABWqEoh0TsIywbhNA7dzP9vk78nPyR3_ZYKMg-e8"},
{"content":{"body":"yeah but their implementation is an explicit loop, which is gross","msgtype":"m.text"},"ts":1631375138614,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$jD6sMXqx3r_wAO5eUsT6XsFHMtIy8yaQUTe8-_kXAB0"},
{"content":{"body":"Has anyone thought about proposing a logical-xor operator `^^`?","format":"org.matrix.custom.html","formatted_body":"Has anyone thought about proposing a logical-xor operator <code>^^</code>?","msgtype":"m.text"},"ts":1631381008624,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$8q-rM_zj_MCWJWlOmkeFDT4eInjKEFp2Tw9N2ueHQLc"}
]