[
{"content":{"body":"Hi folks! Great seeing TC39 being an open and collaborative space!\nI joined here to express the problems and possible solutions over JSON serialization when it comes to `BigInt` type.\n\nI originally come from Web3 where we are dealing with `uint256` – 32byte unsigned integer values and folks from Web3 space used to align on third party libraries to support numbers that big (https://github.com/GoogleChromeLabs/jsbi) until the official support for `BigInt`s came live in 2020!\nThere have been many editions of ECMA-262 published since 1999, and to my belief it needs an upgrade to handle `BigInt` types.\n\nI will be honest I did not spend that much time to research the efforts of handling such but I've seen many discussions evolving around somehow \"smartly\" detecting wether a number value should be parsed as a `BigInt` or `Number`. I don't believe that those are correct nor backwards compatible.\n\nWhat if JSON as a whole could retrieve an upgrade to support BigInt literals ending with \"n\", as it does now in JS?\n\n```json\n{\n  \"value\": 1337n\n}\n```\n\nI'd like to hear your thoughts wether you think if this possible and if so, what kind of backwards incompatibility issues this might have!\nRegarding the latter I don't think this will introduce any issues as this addition doesn't change the serialization behavior of fields of other types – but instead introduces a new one.\nI understand that making an addition like this is gonna introduce chain of changes of parsing JSON in different programming languages, but I believe this needs a review.\n\n","format":"org.matrix.custom.html","formatted_body":"<p>Hi folks! Great seeing TC39 being an open and collaborative space!<br>I joined here to express the problems and possible solutions over JSON serialization when it comes to <code>BigInt</code> type.</p>\n<p>I originally come from Web3 where we are dealing with <code>uint256</code> – 32byte unsigned integer values and folks from Web3 space used to align on third party libraries to support numbers that big (https://github.com/GoogleChromeLabs/jsbi) until the official support for <code>BigInt</code>s came live in 2020!<br>There have been many editions of ECMA-262 published since 1999, and to my belief it needs an upgrade to handle <code>BigInt</code> types.</p>\n<p>I will be honest I did not spend that much time to research the efforts of handling such but I've seen many discussions evolving around somehow \"smartly\" detecting wether a number value should be parsed as a <code>BigInt</code> or <code>Number</code>. I don't believe that those are correct nor backwards compatible.</p>\n<p>What if JSON as a whole could retrieve an upgrade to support BigInt literals ending with \"n\", as it does now in JS?</p>\n<pre><code class=\"language-json\">{\n  \"value\": 1337n\n}\n</code></pre>\n<p>I'd like to hear your thoughts wether you think if this possible and if so, what kind of backwards incompatibility issues this might have!<br>Regarding the latter I don't think this will introduce any issues as this addition doesn't change the serialization behavior of fields of other types – but instead introduces a new one.<br>I understand that making an addition like this is gonna introduce chain of changes of parsing JSON in different programming languages, but I believe this needs a review.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719497317596,"senderName":"Vladyslav Dalechyn","senderId":"@dalechyn:matrix.org","id":"$vk4AHzbPY1BSDke1baj05Nlllom9yNAWiRw8TyEX_X0"},
{"content":{"body":"> <@dalechyn:matrix.org> Hi folks! Great seeing TC39 being an open and collaborative space!\n> I joined here to express the problems and possible solutions over JSON serialization when it comes to `BigInt` type.\n> \n> I originally come from Web3 where we are dealing with `uint256` – 32byte unsigned integer values and folks from Web3 space used to align on third party libraries to support numbers that big (https://github.com/GoogleChromeLabs/jsbi) until the official support for `BigInt`s came live in 2020!\n> There have been many editions of ECMA-262 published since 1999, and to my belief it needs an upgrade to handle `BigInt` types.\n> \n> I will be honest I did not spend that much time to research the efforts of handling such but I've seen many discussions evolving around somehow \"smartly\" detecting wether a number value should be parsed as a `BigInt` or `Number`. I don't believe that those are correct nor backwards compatible.\n> \n> What if JSON as a whole could retrieve an upgrade to support BigInt literals ending with \"n\", as it does now in JS?\n> \n> ```json\n> {\n>   \"value\": 1337n\n> }\n> ```\n> \n> I'd like to hear your thoughts wether you think if this possible and if so, what kind of backwards incompatibility issues this might have!\n> Regarding the latter I don't think this will introduce any issues as this addition doesn't change the serialization behavior of fields of other types – but instead introduces a new one.\n> I understand that making an addition like this is gonna introduce chain of changes of parsing JSON in different programming languages, but I believe this needs a review.\n> \n> \n\nhttps://github.com/tc39/faq#can-we-change-json","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$vk4AHzbPY1BSDke1baj05Nlllom9yNAWiRw8TyEX_X0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@dalechyn:matrix.org\">@dalechyn:matrix.org</a><br /><p>Hi folks! Great seeing TC39 being an open and collaborative space!<br>I joined here to express the problems and possible solutions over JSON serialization when it comes to <code>BigInt</code> type.</p>\n<p>I originally come from Web3 where we are dealing with <code>uint256</code> – 32byte unsigned integer values and folks from Web3 space used to align on third party libraries to support numbers that big (https://github.com/GoogleChromeLabs/jsbi) until the official support for <code>BigInt</code>s came live in 2020!<br>There have been many editions of ECMA-262 published since 1999, and to my belief it needs an upgrade to handle <code>BigInt</code> types.</p>\n<p>I will be honest I did not spend that much time to research the efforts of handling such but I've seen many discussions evolving around somehow \"smartly\" detecting wether a number value should be parsed as a <code>BigInt</code> or <code>Number</code>. I don't believe that those are correct nor backwards compatible.</p>\n<p>What if JSON as a whole could retrieve an upgrade to support BigInt literals ending with \"n\", as it does now in JS?</p>\n<pre><code class=\"language-json\">{\n  \"value\": 1337n\n}\n</code></pre>\n<p>I'd like to hear your thoughts wether you think if this possible and if so, what kind of backwards incompatibility issues this might have!<br>Regarding the latter I don't think this will introduce any issues as this addition doesn't change the serialization behavior of fields of other types – but instead introduces a new one.<br>I understand that making an addition like this is gonna introduce chain of changes of parsing JSON in different programming languages, but I believe this needs a review.</p>\n</blockquote></mx-reply>https://github.com/tc39/faq#can-we-change-json","m.relates_to":{"m.in_reply_to":{"event_id":"$vk4AHzbPY1BSDke1baj05Nlllom9yNAWiRw8TyEX_X0"}},"msgtype":"m.text"},"ts":1719497495610,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$oSQDXBWjoEikB714SV4rQtMHbapXaSmK9i96LxW7qOM"},
{"content":{"body":"> <@michaelficarra:matrix.org> https://github.com/tc39/faq#can-we-change-json\n\nHi! Thank you for referencing this FAQ.\n\nCan you please explain how adding a fully backwards-compatible feature that adds a new JSON field type can break computing environments?\nCan other environments just follow up and add support for BigInts (or similar) too?\nI can feel this can become a \"temporary\" blocker for some environments. – consider C++ environment exchanging JSONs with Rust environment where one supports bigints and the other doesn't. However if the other one controls the process of building such JSONs, it most likely won't send unsupported bigint fields.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$oSQDXBWjoEikB714SV4rQtMHbapXaSmK9i96LxW7qOM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@michaelficarra:matrix.org\">@michaelficarra:matrix.org</a><br>https://github.com/tc39/faq#can-we-change-json</blockquote></mx-reply><p>Hi! Thank you for referencing this FAQ.</p>\n<p>Can you please explain how adding a fully backwards-compatible feature that adds a new JSON field type can break computing environments?<br>Can other environments just follow up and add support for BigInts (or similar) too?<br>I can feel this can become a \"temporary\" blocker for some environments. – consider C++ environment exchanging JSONs with Rust environment where one supports bigints and the other doesn't. However if the other one controls the process of building such JSONs, it most likely won't send unsupported bigint fields.</p>\n","m.mentions":{"user_ids":["@michaelficarra:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$oSQDXBWjoEikB714SV4rQtMHbapXaSmK9i96LxW7qOM"}},"msgtype":"m.text"},"ts":1719498452853,"senderName":"Vladyslav Dalechyn","senderId":"@dalechyn:matrix.org","id":"$L1WtVzHG9nF3HwgZXUkvjOVMT-cZygUBEjeZZHuYQiM"},
{"content":{"body":"Honestly we should expand on this FAQ a bit. It reads a bit flippant right now. And I hear this is coming up in an IETF RFC.","msgtype":"m.text"},"ts":1719499117179,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$qDQmruTlmXXLRH3qJAiiHuNVjyspRdDrjnhz_Ny8oX4"},
{"content":{"body":"> <@dalechyn:matrix.org> Hi! Thank you for referencing this FAQ.\n> \n> Can you please explain how adding a fully backwards-compatible feature that adds a new JSON field type can break computing environments?\n> Can other environments just follow up and add support for BigInts (or similar) too?\n> I can feel this can become a \"temporary\" blocker for some environments. – consider C++ environment exchanging JSONs with Rust environment where one supports bigints and the other doesn't. However if the other one controls the process of building such JSONs, it most likely won't send unsupported bigint fields.\n\nwhat you described is not backward compatible","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$L1WtVzHG9nF3HwgZXUkvjOVMT-cZygUBEjeZZHuYQiM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@dalechyn:matrix.org\">@dalechyn:matrix.org</a><br><p>Hi! Thank you for referencing this FAQ.</p>\n<p>Can you please explain how adding a fully backwards-compatible feature that adds a new JSON field type can break computing environments?<br />Can other environments just follow up and add support for BigInts (or similar) too?<br />I can feel this can become a \"temporary\" blocker for some environments. – consider C++ environment exchanging JSONs with Rust environment where one supports bigints and the other doesn't. However if the other one controls the process of building such JSONs, it most likely won't send unsupported bigint fields.</p>\n</blockquote></mx-reply>what you described is not backward compatible","m.mentions":{"user_ids":["@dalechyn:matrix.org","@michaelficarra:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$L1WtVzHG9nF3HwgZXUkvjOVMT-cZygUBEjeZZHuYQiM"}},"msgtype":"m.text"},"ts":1719499644274,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$7hUXPXheNLQxL908YJ8_erZoUD_Q_htOvTWvPMTjr24"},
{"content":{"body":"You'd need to know what JSON version your \"opponent\" supports, and to know that you'd either need to control both sides or you'd need a version decision negotiation.","msgtype":"m.text"},"ts":1719501804909,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$RtbEHYPP3pvRGkJ4Z6_lvEbk7IU44pVKAck1HeMb_vU"},
{"content":{"body":"differences between different JSON implementations cause enough pain in the world already, and that's just with only a single nominal version of JSON https://seriot.ch/projects/parsing_json.html","m.mentions":{},"msgtype":"m.text"},"ts":1719502004319,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$wfsMp_eN1ZFigpgyUI0BD5qj4kSgd3yTyiea8SrsvVk"},
{"content":{"body":"introducing new features only supported by some implementations would make that 100 times worse","m.mentions":{},"msgtype":"m.text"},"ts":1719502034738,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$CtgGwMsDryvtLDlwY4WXXDIYHUMxoFMqMsqSlgTnRIk"},
{"content":{"body":"the only reasonable route here is to make a different thing, and not call it JSON, and give it whatever new features you want","m.mentions":{},"msgtype":"m.text"},"ts":1719502070806,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$yBEnnlUzIJ9WlMDzSjlt_0TfttROS5iVVJOvOATmJlA"},
{"content":{"body":"littledan: That IETF RTC sounds very interesting. Got any link or more info in general?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a>: That IETF RTC sounds very interesting. Got any link or more info in general?","msgtype":"m.text"},"ts":1719502323084,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$CDvjeC0s12MnWHlf14OOklsBh-R6Yk8jEmMyxeJf94M"},
{"content":{"body":"Hmm, maybe this: https://datatracker.ietf.org/doc/html/rfc8785#name-dealing-with-big-numbers ?","msgtype":"m.text"},"ts":1719504840886,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$D1-yuoXe_wGNTIvOKpEzXFknTWozv7u5Xtg2LYtUCdI"},
{"content":{"body":"it just doesn't seem to be a huge change at all from the lexical standpoint.\n\nAapo Alasuutari, I totally get the concern of version decision negotiation dillema.\n\nAt the same time, the way BigInt's are handled now is via specific serializers other than native JSON (`superjson` i.e.).\n\nSaying if you have a backend and you provide API services to your clients, supporting an \"updated\" JSON would most likely be served via different endpoint.\n\nI agree with the clause that updating JSON is not the best choice to do.","format":"org.matrix.custom.html","formatted_body":"<p>it just doesn't seem to be a huge change at all from the lexical standpoint.</p>\n<p><a href=\"https://matrix.to/#/@aapo.alasuutari:matrix.org\">Aapo Alasuutari</a>, I totally get the concern of version decision negotiation dillema.</p>\n<p>At the same time, the way BigInt's are handled now is via specific serializers other than native JSON (<code>superjson</code> i.e.).</p>\n<p>Saying if you have a backend and you provide API services to your clients, supporting an \"updated\" JSON would most likely be served via different endpoint.</p>\n<p>I agree with the clause that updating JSON is not the best choice to do.</p>\n","m.mentions":{"user_ids":["@aapo.alasuutari:matrix.org"]},"m.relates_to":{"event_id":"$_8dMc2eEi1SsL2xB2xLbLgClF6qaI-WIKyntSUXo1W0","is_falling_back":true,"m.in_reply_to":{"event_id":"$_8dMc2eEi1SsL2xB2xLbLgClF6qaI-WIKyntSUXo1W0"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1719506992174,"senderName":"Vladyslav Dalechyn","senderId":"@dalechyn:matrix.org","id":"$8IjKzAeaWEG5o306dOSOCYVE9mSeroVgtOItHKOquMg"},
{"content":{"body":"How we can make this better?\nwhat do you think of introducing JSON/2 with support of bigints and other \"major\" differences?\n\nHTTP went over it with HTTP/2 HTTP/3, I believe there is a solution for the future of JSONs too.","m.mentions":{},"m.relates_to":{"event_id":"$_8dMc2eEi1SsL2xB2xLbLgClF6qaI-WIKyntSUXo1W0","is_falling_back":true,"m.in_reply_to":{"event_id":"$8IjKzAeaWEG5o306dOSOCYVE9mSeroVgtOItHKOquMg"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1719507079685,"senderName":"Vladyslav Dalechyn","senderId":"@dalechyn:matrix.org","id":"$zoMyz3mInuzxeeyXdui3MorqypKywCfpgA-rfi16FJk"}
]