[
{"content":{"body":"> <@jasnell:matrix.org> Hello all. I've got a proposal that I'd like to surface for consideration. I put this together after speaking a bit with Matteo Collina and @ljharb... The fundamental idea is to introduce a mechanism for zero-copy concatenation of `ArrayBuffer` in a way that allows the result to still be an `ArrayBuffer` that can be wrapped with a `TypedArray`. The explainer is here: https://github.com/jasnell/proposal-zero-copy-arraybuffer-list/blob/main/README.md\n> \n> For a quick example:\n> \n> const ab1 = new ArrayBuffer(10);\n> const ab2 = new ArrayBuffer(20);\n> const combined = ArrayBuffer.of(ab1, ab2);\n> const u8 = new Uint8Array(combined);\n> \n> Here, `combined` is effectively a list of the component `ArrayBuffer` instances that is itself an `ArrayBuffer`.\n> \n> The idea here is adapted from the very popular npm module `bl` which implements a similar idea around Node.js `Buffer` interface but in a way that still has a number of warts.\n> \n> There is a more detailed example in the explainer. @littledan and ljharb have already graciously provided some extremely helpful feedback.\n\nOh I've been wanting this for years. I think I wrote an issue somewhere!","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$1Dx-2MQ7WnU6VEVQsFP2BnftgnyTx2Sl9HVj4rwPBpU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jasnell:matrix.org\">@jasnell:matrix.org</a><br><p>Hello all. I've got a proposal that I'd like to surface for consideration. I put this together after speaking a bit with Matteo Collina and @ljharb... The fundamental idea is to introduce a mechanism for zero-copy concatenation of <code>ArrayBuffer</code> in a way that allows the result to still be an <code>ArrayBuffer</code> that can be wrapped with a <code>TypedArray</code>. The explainer is here: https://github.com/jasnell/proposal-zero-copy-arraybuffer-list/blob/main/README.md</p>\n<p>For a quick example:</p>\n<p>const ab1 = new ArrayBuffer(10);<br />const ab2 = new ArrayBuffer(20);<br />const combined = ArrayBuffer.of(ab1, ab2);<br />const u8 = new Uint8Array(combined);</p>\n<p>Here, <code>combined</code> is effectively a list of the component <code>ArrayBuffer</code> instances that is itself an <code>ArrayBuffer</code>.</p>\n<p>The idea here is adapted from the very popular npm module <code>bl</code> which implements a similar idea around Node.js <code>Buffer</code> interface but in a way that still has a number of warts.</p>\n<p>There is a more detailed example in the explainer. @littledan and <a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a> have already graciously provided some extremely helpful feedback.</p>\n</blockquote></mx-reply>Oh I've been wanting this for years. I think I wrote an issue somewhere!","m.mentions":{"user_ids":["@jasnell:matrix.org","@ljharb:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$1Dx-2MQ7WnU6VEVQsFP2BnftgnyTx2Sl9HVj4rwPBpU"}},"msgtype":"m.text"},"ts":1696466620009,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$suY338Be9z3OdXKJMOjfaXwM8OB7XoCsFp4Q6020PK8"},
{"content":{"body":"I also still really want CoW ArrayBuffer slices. I still do not understand how it would introduce much more complexity than the existing detached checks already required.","m.mentions":{},"msgtype":"m.text"},"ts":1696467046701,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$4mdUiUROXlSvnmuI9NCaLX2WBuwZGfz-8IO0gARGFt0"},
{"content":{"body":"Basically I want to be able to do \n```js\nconst chunks = [];\nchunks.push(chunk1.slice(10));\nchunks.push(chunk2);\nchunks.push(chunk3.slice(0, 5));\nreturn ArrayBuffer.of(...chunks);\n```\nObviously each chunk is received in separate events / iterator yields","format":"org.matrix.custom.html","formatted_body":"<p>Basically I want to be able to do</p>\n<pre><code class=\"language-js\">const chunks = [];\nchunks.push(chunk1.slice(10));\nchunks.push(chunk2);\nchunks.push(chunk3.slice(0, 5));\nreturn ArrayBuffer.of(...chunks);\n</code></pre>\n<p>Obviously each chunk is received in separate events / iterator yields</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1696467784312,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$2be-QXp36It13uwpHQaizoOdRDbc1WuTA1irW3_j_7o"},
{"content":{"body":"That said I do expect the new combined buffer to itself be a CoW","m.mentions":{},"msgtype":"m.text"},"ts":1696467842004,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Zqgd8eugCKlHnOpnCZjdppQqke0TAiCxLubCfAQDGbU"},
{"content":{"body":"And not a passthrough to the underlying buffer","m.mentions":{},"msgtype":"m.text"},"ts":1696467854841,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$4xt5W0lR-98QQvQ0UfKLre5EaGlUu8yHR-7NZyqqet8"},
{"content":{"body":"The proposal currently does not include CoW but I can't see a reason why it couldn't be. Will give that some thought","m.mentions":{},"msgtype":"m.text"},"ts":1696467967397,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$NGVRvHtiM1flcTgXc1v2CSOsj3RD_k-aQq7hGfv77os"},
{"content":{"body":"Btw, in that case it really become a `concat` and the fact that the buffer is in fact a list of smaller buffers is just an unobservable implementation detail","format":"org.matrix.custom.html","formatted_body":"Btw, in that case it really become a <code>concat</code> and the fact that the buffer is in fact a list of smaller buffers is just an unobservable implementation detail","m.mentions":{},"msgtype":"m.text"},"ts":1696468144054,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$tm_nNoqr9Raj8E6BPRgVo1yfH1ow9I4FKV8ecDuUtlg"},
{"content":{"body":"as long as we're able to preserve the zero-copy concat and zero-copy subarray, then I'm fine with that","m.mentions":{},"msgtype":"m.text"},"ts":1696468231138,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$9BW1-eqCaoQDD38PEt7TkV1J04f52iKKmOlUAFXSCLM"},
{"content":{"body":"Basically I'm really concerned about having multiple ArrayBuffer instances backed by the same underlying data. That's more in the realm of SharedArrayBuffer semantics","m.mentions":{},"msgtype":"m.text"},"ts":1696468246769,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$e7m7VMcNCRZvObopqrpsDnX8ePd1y5TBoP0MQX4u2jg"},
{"content":{"body":"True, but to be fair host implementations already give us that ability","m.mentions":{},"msgtype":"m.text"},"ts":1696468374619,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$q_8SM09J3R6er5zSc_tIU8XqEh06-3zgaCAgNtpAxrw"},
{"content":{"body":"(obviously that doesn't mean we should make it easier :-) ...)","m.mentions":{},"msgtype":"m.text"},"ts":1696468392805,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$NJw4QkYUgAm6UCxKh01W8MwDylPEGF5gzeHlpLD7E0Y"},
{"content":{"body":"I don't believe any host APIs currently expose that ability, right? I know that JS APIs don't","m.mentions":{},"msgtype":"m.text"},"ts":1696468605651,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ShwNJnnlCmMGsODerIKQXyCl_98-Lm_U8ErRa9qP8Rg"},
{"content":{"body":"Anyway, my motivation for CoW is that I believe it would increase the performance of a ton of existing applications without requiring any code changes","m.mentions":{},"msgtype":"m.text"},"ts":1696468700942,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$r-Z5sOEr48mxkgDUOaO9aoZWmxVaXRuL3a6U4mklmsg"},
{"content":{"body":" * Anyway, my motivation for CoW is that I believe it would increase the performance of a ton of existing applications without requiring any code changes on their end","m.mentions":{},"m.new_content":{"body":"Anyway, my motivation for CoW is that I believe it would increase the performance of a ton of existing applications without requiring any code changes on their end","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$r-Z5sOEr48mxkgDUOaO9aoZWmxVaXRuL3a6U4mklmsg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1696468719329,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$GoCd9Jbqk58MuJgzs3QF0MaMX9R0ub2eLKIK8u72pn8"},
{"content":{"body":"I think Luca Casonato shares that belief","format":"org.matrix.custom.html","formatted_body":"I think <a href=\"https://matrix.to/#/@lucacasonato:matrix.org\">Luca Casonato</a> shares that belief","m.mentions":{"user_ids":["@lucacasonato:matrix.org"]},"msgtype":"m.text"},"ts":1696468742950,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$vCTAxxSqV-g-a7ABCnwYHj0YqaTDcO6TVtW8xIIuxJU"},
{"content":{"body":"With v8, it's fairly trivial to extract a `std::shared_ptr<v8::BackingStore>` and have it shared by multiple `v8::ArrayBuffer` instances","format":"org.matrix.custom.html","formatted_body":"With v8, it's fairly trivial to extract a <code>std::shared_ptr&lt;v8::BackingStore&gt;</code> and have it shared by multiple <code>v8::ArrayBuffer</code> instances","m.mentions":{},"msgtype":"m.text"},"ts":1696468784721,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$orRhm2PpeHKDnWVlvz4BAt9jhZ_9t_FQjHh4aGJu3mU"},
{"content":{"body":"Not ideal, but trivial :-)","m.mentions":{},"msgtype":"m.text"},"ts":1696468796503,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$Qtw_aY_bdLV-J8DB9UeIoseNaEKE3gEc7CLM-N3PCjE"},
{"content":{"body":"> <@mhofman:matrix.org> I think Luca Casonato shares that belief\n\nYes, a general purpose CoW optimization for AB.slice would enable many host APIs to become significantly faster","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq%3Amatrix.org/%24vCTAxxSqV-g-a7ABCnwYHj0YqaTDcO6TVtW8xIIuxJU\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I think <a href=\"https://matrix.to/#/@lucacasonato:matrix.org\">Luca Casonato</a> shares that belief</blockquote></mx-reply>Yes, a general purpose CoW optimization for AB.slice would enable many host APIs to become significantly faster","m.relates_to":{"m.in_reply_to":{"event_id":"$vCTAxxSqV-g-a7ABCnwYHj0YqaTDcO6TVtW8xIIuxJU"}},"msgtype":"m.text"},"ts":1696469125067,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$f3B0V8iCK6xqxlx8XsctJEmvupgPVOtfWZ-_xfYNqyI"},
{"content":{"body":"I don’t think we necessarily need a new API here (I view concat as a related, but separate API - it can make sense with or without the CoW optimization)","msgtype":"m.text"},"ts":1696469234938,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$OteGx80ulTTEfo6-VhPWZLLj_HK4ErwaXnwIEuUIf7k"},
{"content":{"body":"The nice thing about CoW is that it’s completely unobservable","msgtype":"m.text"},"ts":1696469272129,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$WmfcdCLYb_BIynfxppl8nf_SWRVA8SiHlb1OfR_HkoU"},
{"content":{"body":"Yeah, I'd view the proposal for `ArrayBuffer.of(...)` and CoW as orthogonal. Both nice to have but distinct","format":"org.matrix.custom.html","formatted_body":"Yeah, I'd view the proposal for <code>ArrayBuffer.of(...)</code> and CoW as orthogonal. Both nice to have but distinct","m.mentions":{},"msgtype":"m.text"},"ts":1696469303829,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$aIw43k86SDP_ZJVgaZQRXJ37UMsIHyJVvfnblKIkVNc"},
{"content":{"body":"If we could get CoW slice, however, there would be no need at all for the `ArrayBuffer.prototype.subarray(...)` that I suggest in the proposal","format":"org.matrix.custom.html","formatted_body":"If we could get CoW slice, however, there would be no need at all for the <code>ArrayBuffer.prototype.subarray(...)</code> that I suggest in the proposal","m.mentions":{},"msgtype":"m.text"},"ts":1696469373041,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$9kWmUYve9SPc6POxVaYaoXdJJ3j8UjZLkK9_orhFW7M"},
{"content":{"body":"Also if we had CoW, an argument could be absolutely made also that `ArrayBuffer.of(...)` should automatically slice(0, len) to ensure that the new `ArrayBuffer` is composed entirely of CoW slices","format":"org.matrix.custom.html","formatted_body":"Also if we had CoW, an argument could be absolutely made also that <code>ArrayBuffer.of(...)</code> should automatically slice(0, len) to ensure that the new <code>ArrayBuffer</code> is composed entirely of CoW slices","m.mentions":{},"msgtype":"m.text"},"ts":1696469481945,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$ZUjZYngQ1PVk90eAITswrFt8W3vVMbnr2E41oZak_u4"},
{"content":{"body":"I share Mathieu Hofman’s view that we probably should not support having two AB objects backed by the same (or a sub array of the same) backing store ","format":"org.matrix.custom.html","formatted_body":"I share <a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>’s view that we probably should not support having two AB objects backed by the same (or a sub array of the same) backing store","msgtype":"m.text"},"ts":1696470069750,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$Zdnju-DMew9Sb6YN46uYswVzMIJBzqc5x-64CfcfPF4"},
{"content":{"body":"if it’s unobservable it doesn’t need to be in the spec tho, and arguably couldn’t be","msgtype":"m.text"},"ts":1696470129639,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$BJmcJcIS1iJ0Bu4hJBc_v4QhsZfBnXt1f5Aw2zuW_ao"},
{"content":{"body":"impls can just do it","msgtype":"m.text"},"ts":1696470135729,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$E3HbeKgL2qCVnWTaUgMO3xLUCKW6WH4jsdK6jmsIbIg"},
{"content":{"body":"I she","msgtype":"m.text"},"ts":1696471330117,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$d1QqacZJZErXMcDH-3wlt4k1IVV-aRHo9YxFC0eyXGw"},
{"content":{"body":"* I agree","m.new_content":{"body":"I agree","msgtype":"m.text"},"m.relates_to":{"event_id":"$d1QqacZJZErXMcDH-3wlt4k1IVV-aRHo9YxFC0eyXGw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1696471336939,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$WxRkleN6QclgSTA2egBLmjuvqZ_AJ_LnWO48Ef1BUnQ"},
{"content":{"body":"Yes that's the difficulty I've been having with this. CoW is technically an unobservable optimizing engines could make today.  But we'll only get it if there is sufficient feedback from the community it's needed. Proposals like this IMO show the need.","msgtype":"m.text"},"ts":1696475716607,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ITC9NJjC5ZlBQh9zQeUG6iaew7as04jyQJvZbV0padg"},
{"content":{"body":"In that world , a concat feature is orthogonal. But it mostly makes sense if implemented as a list of CoW buffers because otherwise it's equivalent to creating a new contiguous buffer and copying into it.","msgtype":"m.text"},"ts":1696475859888,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$DExZ6CbcI8KDunJ_NEGy5qJUrFlK2jFEldt1JiGGX54"},
{"content":{"body":"* In that world , a concat feature is orthogonal. But it mostly makes sense if implemented as a list of CoW buffers because otherwise it's equivalent to the program creating a new contiguous buffer and copying into it.","m.new_content":{"body":"In that world , a concat feature is orthogonal. But it mostly makes sense if implemented as a list of CoW buffers because otherwise it's equivalent to the program creating a new contiguous buffer and copying into it.","msgtype":"m.text"},"m.relates_to":{"event_id":"$DExZ6CbcI8KDunJ_NEGy5qJUrFlK2jFEldt1JiGGX54","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1696475889296,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$snd2n5V_eARraV7c2ERAy6OhC8Ym-LKGEj8haNX_GY8"},
{"content":{"body":"sooo it sounds like this proposal might have a beneficial side effect of nudging engines towards Just Doing CoW, and nothing further need be done?","m.mentions":{},"msgtype":"m.text"},"ts":1696499351682,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$SqxyL0GA0ebl_ihuo0hukRvW9GEpl-ZrGsrbQ4HO92Q"},
{"content":{"body":"need a shu deck titled Have a CoW Man","msgtype":"m.text"},"ts":1696504716008,"senderName":"rkirsling","senderId":"@rkirsling:matrix.org","id":"$hZgkyVOQcn_NxR-5TxL65NPYAOWg7DAJ7Yq69gc4BZ8"},
{"content":{"body":"Well, having the CoW bit would be great but I don't want to lose track of the zero-copy concat use case, which is what motivated the proposal","msgtype":"m.text"},"ts":1696510493624,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$1FhxpIa9rEDlp_tuMc3ZkTsTqIR67JK6AA-nTxkaySU"},
{"content":{"body":"I understand the performance motivation, but is there any reason zero copy should be something observable directly by the program?","msgtype":"m.text"},"ts":1696513568010,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$mj3QefQI6rF2zfcq-Y3OfB_XteX2e7gnNuL696ORKws"},
{"content":{"body":"it'd be observable if you mutated one and wanted to see the result in the other, which seems like kind of the main purpose of wanting zero-copy?","m.mentions":{},"msgtype":"m.text"},"ts":1696513755560,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$RQyRj4NFfR2HFcqJxu-zFa5Ge7Z_Y7-rEImbWVNSp_M"},
{"content":{"body":" * it'd be observable if you mutated one and wanted to see the result in the other, which seems like kind of the main purpose of wanting zero-copy? (other than perf)","m.mentions":{},"m.new_content":{"body":"it'd be observable if you mutated one and wanted to see the result in the other, which seems like kind of the main purpose of wanting zero-copy? (other than perf)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$RQyRj4NFfR2HFcqJxu-zFa5Ge7Z_Y7-rEImbWVNSp_M","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1696513813556,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$3ODS7x3PmTJJOg6_rik2AB8_aX-HkJM7D_6lcXWJnvo"},
{"content":{"body":"Well, the vast majority of my zero-copy use cases are for read. Specifically, around things like optimizing Stream API implementations due to the fact that WHATWG streams have no concept of writev the way Node.js streams do","m.mentions":{},"msgtype":"m.text"},"ts":1696513833102,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$dknh7cA-Qi3wAsz86tOEInj26DwuWzALrFAoONb6sTM"},
{"content":{"body":"For instance, I just had a case where a streams impl was resulting in many small writes that needed to be aggregated into larger buffers before being passed down a transform pipeline... unfortunately it's currently not possible to do without copying or modifying the various stream impls down the pipeline which is... difficult","m.mentions":{},"msgtype":"m.text"},"ts":1696513934482,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$pCLIWWwvxYvG4vK460mxiKQ29iJRIry_6HcO8YUfxm0"},
{"content":{"body":"in the implementation here I would likely be calling `transfer()` anyway so I don't really care so much about mutations being visible as allowing zero-copy concat for reading","format":"org.matrix.custom.html","formatted_body":"in the implementation here I would likely be calling <code>transfer()</code> anyway so I don't really care so much about mutations being visible as allowing zero-copy concat for reading","m.mentions":{},"msgtype":"m.text"},"ts":1696514045091,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$-PEkesXibFtvI4Itw8mzF-Ea00FZlGauhkgvhXKpx-Y"}
]