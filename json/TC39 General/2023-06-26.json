[
{"content":{"body":"Why is it that async constructors are not valid syntax sugar, even though you can manually implement them without any issues? ","msgtype":"m.text"},"ts":1687771541199,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$utcLVYhEf9n0v3Yw_UTfFAOLJndjIA-h8wqRyVdcrXE"},
{"content":{"body":"Why was it decided that we should have to write:\n```js\nclass Foo {\n    constructor() {\n        return new Promise(async (resolve, reject) => {\n            this.sync = 123;\n            this.async = await someAsyncCall();\n            resolve(this);\n        });\n    }\n}\n```\ninstead of just\n```js\nclass Foo {\n    async constructor() {\n        this.sync = 123;\n        this.async = await someAsyncCall();\n    }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Why was it decided that we should have to write:</p>\n<pre><code class=\"language-js\">class Foo {\n    constructor() {\n        return new Promise(async (resolve, reject) =&gt; {\n            this.sync = 123;\n            this.async = await someAsyncCall();\n            resolve(this);\n        });\n    }\n}\n</code></pre>\n<p>instead of just</p>\n<pre><code class=\"language-js\">class Foo {\n    async constructor() {\n        this.sync = 123;\n        this.async = await someAsyncCall();\n    }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1687771608384,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$mRrEG8H-yqTiyoxH7Ngi6-EyIo5NUUnCXLek_kGRK30"},
{"content":{"body":"`await new Foo()` with the 1st codeblock works perfectly fine","format":"org.matrix.custom.html","formatted_body":"<code>await new Foo()</code> with the 1st codeblock works perfectly fine","msgtype":"m.text"},"ts":1687771644448,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$rMbUObAirG1t6isXr4or-eDjd38xkzj--5uG9ia7DZE"},
{"content":{"body":"even the syntax itself is already in place for other methods of classes, `async methodName() { ... }`","format":"org.matrix.custom.html","formatted_body":"even the syntax itself is already in place for other methods of classes, <code>async methodName() { ... }</code>","msgtype":"m.text"},"ts":1687771690254,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$tpvCIMk7ywEr8FyJJ55sTg3F8dkI2pd-kEQzcq2Atj8"},
{"content":{"body":"why was it decided to go out of our way to specifically block the syntax when methodName === constructor","msgtype":"m.text"},"ts":1687771722163,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$sqdb1oYcJ2P9S1r84w56HreX37vr9MUaajPTwjlFiJc"},
{"content":{"body":"It's not without issues -- it does not work with subclasses","msgtype":"m.text"},"ts":1687771855623,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$uzwi5by88f4noIgiO6zUqFzo2HYCLbA27wclqYmpBio"},
{"content":{"body":"works for me, just needs to be a little different from sync subclassing, which a dedicated syntax sugar could do\n```js\nclass Bar extends Foo {\n    constructor() {\n        return new Promise(async (resolve, reject) => {\n            const base = await super();\n            base.barSync = 123;\n            base.barAsync = await someAsyncCall();\n            resolve(base);\n        });\n    }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>works for me, just needs to be a little different from sync subclassing, which a dedicated syntax sugar could do</p>\n<pre><code class=\"language-js\">class Bar extends Foo {\n    constructor() {\n        return new Promise(async (resolve, reject) =&gt; {\n            const base = await super();\n            base.barSync = 123;\n            base.barAsync = await someAsyncCall();\n            resolve(base);\n        });\n    }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1687772161903,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$nrhCoRlZM2Qjn8d2Dox_w3JQ_nIGh3WJyyna-rSH5gs"},
{"content":{"body":"But now you cannot define private fields/methods in Bar","msgtype":"m.text"},"ts":1687772187485,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$UvU9oLDxkRWBSAzJIRJoLNRkJ780XNK1ejggkP6LsV4"},
{"content":{"body":"A new \"async constructor\" syntax would solve this, but it's not just syntax sugar on top of what we can already do","msgtype":"m.text"},"ts":1687772229127,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Jaz_V66EVK9orwL-W_4q0Pzw0nNtFMOn0bf2qKYI4hI"},
{"content":{"body":"hmm I see, you're right on those","msgtype":"m.text"},"ts":1687772395002,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$Z9wyBoa-7UiFrZQlr02jXkfDQ8zBi6mvRBcCKGsIJQU"},
{"content":{"body":"so the problem seems to be super() attaches the caller's private properties on its own return value before I get the chance to `await` the Promise, so I get a promise with private methods... rather cursed to see","format":"org.matrix.custom.html","formatted_body":"so the problem seems to be super() attaches the caller's private properties on its own return value before I get the chance to <code>await</code> the Promise, so I get a promise with private methods... rather cursed to see","msgtype":"m.text"},"ts":1687773279024,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$Up8pinzd6jFGVXlo1_MKiR7a62aqg4wBIdTb-tBzlbA"},
{"content":{"body":"is there a reason for this behavior of applying privates at a different step than normal properties?","msgtype":"m.text"},"ts":1687773318091,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$kVtLeDUS-iuIIDOdcUlrzFAaw_FuGgu12ddxeukNrMk"},
{"content":{"body":"huh... this leads to some interesting things being possible...","msgtype":"m.text"},"ts":1687773808596,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$MtINgkTjQ2ClLcNngYE8vsmcEsEYp96cX8HB3r9gEYw"}
]