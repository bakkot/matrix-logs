[
{"content":{"body":"Why is it that async constructors are not valid syntax sugar, even though you can manually implement them without any issues? ","msgtype":"m.text"},"ts":1687771541199,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$utcLVYhEf9n0v3Yw_UTfFAOLJndjIA-h8wqRyVdcrXE"},
{"content":{"body":"Why was it decided that we should have to write:\n```js\nclass Foo {\n    constructor() {\n        return new Promise(async (resolve, reject) => {\n            this.sync = 123;\n            this.async = await someAsyncCall();\n            resolve(this);\n        });\n    }\n}\n```\ninstead of just\n```js\nclass Foo {\n    async constructor() {\n        this.sync = 123;\n        this.async = await someAsyncCall();\n    }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Why was it decided that we should have to write:</p>\n<pre><code class=\"language-js\">class Foo {\n    constructor() {\n        return new Promise(async (resolve, reject) =&gt; {\n            this.sync = 123;\n            this.async = await someAsyncCall();\n            resolve(this);\n        });\n    }\n}\n</code></pre>\n<p>instead of just</p>\n<pre><code class=\"language-js\">class Foo {\n    async constructor() {\n        this.sync = 123;\n        this.async = await someAsyncCall();\n    }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1687771608384,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$mRrEG8H-yqTiyoxH7Ngi6-EyIo5NUUnCXLek_kGRK30"},
{"content":{"body":"`await new Foo()` with the 1st codeblock works perfectly fine","format":"org.matrix.custom.html","formatted_body":"<code>await new Foo()</code> with the 1st codeblock works perfectly fine","msgtype":"m.text"},"ts":1687771644448,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$rMbUObAirG1t6isXr4or-eDjd38xkzj--5uG9ia7DZE"},
{"content":{"body":"even the syntax itself is already in place for other methods of classes, `async methodName() { ... }`","format":"org.matrix.custom.html","formatted_body":"even the syntax itself is already in place for other methods of classes, <code>async methodName() { ... }</code>","msgtype":"m.text"},"ts":1687771690254,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$tpvCIMk7ywEr8FyJJ55sTg3F8dkI2pd-kEQzcq2Atj8"},
{"content":{"body":"why was it decided to go out of our way to specifically block the syntax when methodName === constructor","msgtype":"m.text"},"ts":1687771722163,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$sqdb1oYcJ2P9S1r84w56HreX37vr9MUaajPTwjlFiJc"},
{"content":{"body":"It's not without issues -- it does not work with subclasses","msgtype":"m.text"},"ts":1687771855623,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$uzwi5by88f4noIgiO6zUqFzo2HYCLbA27wclqYmpBio"},
{"content":{"body":"works for me, just needs to be a little different from sync subclassing, which a dedicated syntax sugar could do\n```js\nclass Bar extends Foo {\n    constructor() {\n        return new Promise(async (resolve, reject) => {\n            const base = await super();\n            base.barSync = 123;\n            base.barAsync = await someAsyncCall();\n            resolve(base);\n        });\n    }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>works for me, just needs to be a little different from sync subclassing, which a dedicated syntax sugar could do</p>\n<pre><code class=\"language-js\">class Bar extends Foo {\n    constructor() {\n        return new Promise(async (resolve, reject) =&gt; {\n            const base = await super();\n            base.barSync = 123;\n            base.barAsync = await someAsyncCall();\n            resolve(base);\n        });\n    }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1687772161903,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$nrhCoRlZM2Qjn8d2Dox_w3JQ_nIGh3WJyyna-rSH5gs"},
{"content":{"body":"But now you cannot define private fields/methods in Bar","msgtype":"m.text"},"ts":1687772187485,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$UvU9oLDxkRWBSAzJIRJoLNRkJ780XNK1ejggkP6LsV4"},
{"content":{"body":"A new \"async constructor\" syntax would solve this, but it's not just syntax sugar on top of what we can already do","msgtype":"m.text"},"ts":1687772229127,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Jaz_V66EVK9orwL-W_4q0Pzw0nNtFMOn0bf2qKYI4hI"},
{"content":{"body":"hmm I see, you're right on those","msgtype":"m.text"},"ts":1687772395002,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$Z9wyBoa-7UiFrZQlr02jXkfDQ8zBi6mvRBcCKGsIJQU"},
{"content":{"body":"so the problem seems to be super() attaches the caller's private properties on its own return value before I get the chance to `await` the Promise, so I get a promise with private methods... rather cursed to see","format":"org.matrix.custom.html","formatted_body":"so the problem seems to be super() attaches the caller's private properties on its own return value before I get the chance to <code>await</code> the Promise, so I get a promise with private methods... rather cursed to see","msgtype":"m.text"},"ts":1687773279024,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$Up8pinzd6jFGVXlo1_MKiR7a62aqg4wBIdTb-tBzlbA"},
{"content":{"body":"is there a reason for this behavior of applying privates at a different step than normal properties?","msgtype":"m.text"},"ts":1687773318091,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$kVtLeDUS-iuIIDOdcUlrzFAaw_FuGgu12ddxeukNrMk"},
{"content":{"body":"huh... this leads to some interesting things being possible...","msgtype":"m.text"},"ts":1687773808596,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$MtINgkTjQ2ClLcNngYE8vsmcEsEYp96cX8HB3r9gEYw"},
{"content":{"body":"It's the same for normal properties:\n```\nclass Bar extends Foo {\n    prop = 2;\n    constructor() {\n        return new Promise(async (resolve, reject) => {\n            const p = super();\n            console.log(p.prop); // 2\n            const base = await p;\n            resolve(base);\n        });\n    }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>It's the same for normal properties:</p>\n<pre><code>class Bar extends Foo {\n    prop = 2;\n    constructor() {\n        return new Promise(async (resolve, reject) =&gt; {\n            const p = super();\n            console.log(p.prop); // 2\n            const base = await p;\n            resolve(base);\n        });\n    }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1687774148146,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$7WdQbXuYk-mAG6i23Sc2vVrq05YqKOiDZE4olTrQveY"},
{"content":{"body":"well this is weird, since when does Chrome console allow you to directly access private members of classes externally","msgtype":"m.text"},"ts":1687774358511,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$7H3cWCIG8JtsK5PiazCHDJzD4ThY5wyJEnaOuZu5FyY"},
{"content":{"body":"Oh nice, I didn't know about that","msgtype":"m.text"},"ts":1687774561737,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$btqx9W9uofZ_VKciqQD9cbQqWXE2bXvCVTzzVGyBM3Y"},
{"content":{"body":"That's useful","msgtype":"m.text"},"ts":1687774567116,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$zubp5G42g5pB_YVClFKfi3R37a_hgYCpnSIwhaTtK8s"},
{"content":{"body":"> <@nicolo-ribaudo:matrix.org> It's the same for normal properties:\n> ```\n> class Bar extends Foo {\n>     prop = 2;\n>     constructor() {\n>         return new Promise(async (resolve, reject) => {\n>             const p = super();\n>             console.log(p.prop); // 2\n>             const base = await p;\n>             resolve(base);\n>         });\n>     }\n> }\n> ```\n\nOh I see, my \"normal\" property was actually a getter, and those end up in the promise result for some reason","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$7WdQbXuYk-mAG6i23Sc2vVrq05YqKOiDZE4olTrQveY?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">@nicolo-ribaudo:matrix.org</a><br><p>It's the same for normal properties:</p>\n<pre><code>class Bar extends Foo {\n    prop = 2;\n    constructor() {\n        return new Promise(async (resolve, reject) =&gt; {\n            const p = super();\n            console.log(p.prop); // 2\n            const base = await p;\n            resolve(base);\n        });\n    }\n}\n</code></pre>\n</blockquote></mx-reply>Oh I see, my \"normal\" property was actually a getter, and those end up in the promise result for some reason","m.relates_to":{"m.in_reply_to":{"event_id":"$7WdQbXuYk-mAG6i23Sc2vVrq05YqKOiDZE4olTrQveY"}},"msgtype":"m.text"},"ts":1687774589887,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$a_FcmWNwBVSi8-Mn2VWO3-72G9gGQVqkIboHYarhDbg"},
{"content":{"body":"like `get prop() { return 2 };`","format":"org.matrix.custom.html","formatted_body":"like <code>get prop() { return 2 };</code>","msgtype":"m.text"},"ts":1687774598219,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$1SVbmt5DwiaxqmWTTfO0Cg0nLV1grwBCHzB5SRKbJ4M"},
{"content":{"body":"Because it's on the prototype, so it's installed long before creating `this`","format":"org.matrix.custom.html","formatted_body":"Because it's on the prototype, so it's installed long before creating <code>this</code>","msgtype":"m.text"},"ts":1687774624933,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$YgE-0g_c2KfpUJzdsKgY41ECWNv1OnPZMjA1pbXPbU0"},
{"content":{"body":"oh right that's why it shows shadowed... I don't use Chrome console much I usually test this stuff on Node REPL so I got confused there (like with the .#prop thing above) ðŸ˜…","msgtype":"m.text"},"ts":1687774715138,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$137eYCsrk7NfqB8SGJsrXw0fSA45x32PeY4b165Xh2c"},
{"content":{"body":"on Node it just wouldn't show on the same level if its on prototype","msgtype":"m.text"},"ts":1687774753534,"senderName":"voidhedron","senderId":"@voidhedron:matrix.org","id":"$VaTEYQZhX1EPnWCYYW5M9t_gJRziFnERqZACC8hswq8"}
]