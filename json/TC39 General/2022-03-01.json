[
{"content":{"body":"danielrosenwasser / rbuckton: The new What's Changed Since RC/Beta in the TS release notes are üëç","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@danielrosenwasser:matrix.org\">danielrosenwasser</a> / <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: The new What's Changed Since RC/Beta in the TS release notes are üëç","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"danielrosenwasser / rbuckton: The new What's Changed Since RC/Beta in the TS release notes are üëç","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@danielrosenwasser:matrix.org\">danielrosenwasser</a> / <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: The new What's Changed Since RC/Beta in the TS release notes are üëç","mimetype":"text/html"}]},"ts":1646096147607,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$WFDpgyFgJAlJ-Gw27OfkqLKO5wOtv47NxKIIB5Y94TU"},
{"content":{"body":"Question. Possibly I'm not searching the right terms, but when async/await was added to ECMAScript, why was threading never pulled into the core language away from Web Workers? (As others I've done the blob thing for years with workers when doing heavily threaded things). I kind of expected that one would be able to just call an async function and have it execute on another thread by now with intuitive shared state, but that was never proposed. Why not?","msgtype":"m.text","org.matrix.msc1767.text":"Question. Possibly I'm not searching the right terms, but when async/await was added to ECMAScript, why was threading never pulled into the core language away from Web Workers? (As others I've done the blob thing for years with workers when doing heavily threaded things). I kind of expected that one would be able to just call an async function and have it execute on another thread by now with intuitive shared state, but that was never proposed. Why not?"},"ts":1646099265044,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$19H9I6AwTYr-pJkIRFzfYhDeL6FC7jeR8DYqZRu8NE4"},
{"content":{"body":"\"intuitive shared state\" is a contradiction in terms","msgtype":"m.text","org.matrix.msc1767.text":"\"intuitive shared state\" is a contradiction in terms"},"ts":1646099708758,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$s-3R3LfGBpPS02Ks8btuGTKRWHMHqOYhSNnlu4gOVz0"},
{"content":{"body":"the thing you're proposing would be incredibly complicated to specify or implement, and we're just now getting to the point where we're fleshing out the building blocks which might let us get there someday","msgtype":"m.text","org.matrix.msc1767.text":"the thing you're proposing would be incredibly complicated to specify or implement, and we're just now getting to the point where we're fleshing out the building blocks which might let us get there someday"},"ts":1646099751018,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$EeV0VBN1e-p8fmWcrnHrgEQiCqi-1vUtW2EGC66ZcsY"},
{"content":{"body":"or, well, not there precisely, but somewhere like it","msgtype":"m.text","org.matrix.msc1767.text":"or, well, not there precisely, but somewhere like it"},"ts":1646099763616,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$U4dP3gDEYO83hpHZUg2x5eGXzVM6ImXXPkHiZqgT8S8"},
{"content":{"body":"> <@sirisian:matrix.org> Question. Possibly I'm not searching the right terms, but when async/await was added to ECMAScript, why was threading never pulled into the core language away from Web Workers? (As others I've done the blob thing for years with workers when doing heavily threaded things). I kind of expected that one would be able to just call an async function and have it execute on another thread by now with intuitive shared state, but that was never proposed. Why not?\n\nwe're on the route of that. ü§î\nsearch for those proposals:\n- struct (shared struct section)\n- module block","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$19H9I6AwTYr-pJkIRFzfYhDeL6FC7jeR8DYqZRu8NE4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@sirisian:matrix.org\">@sirisian:matrix.org</a><br>Question. Possibly I&#39;m not searching the right terms, but when async/await was added to ECMAScript, why was threading never pulled into the core language away from Web Workers? (As others I&#39;ve done the blob thing for years with workers when doing heavily threaded things). I kind of expected that one would be able to just call an async function and have it execute on another thread by now with intuitive shared state, but that was never proposed. Why not?</blockquote></mx-reply><p>we're on the route of that. ü§î<br>search for those proposals:</p>\n<ul>\n<li>struct (shared struct section)</li>\n<li>module block</li>\n</ul>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$19H9I6AwTYr-pJkIRFzfYhDeL6FC7jeR8DYqZRu8NE4"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@sirisian:matrix.org> Question. Possibly I'm not searching the right terms, but when async/await was added to ECMAScript, why was threading never pulled into the core language away from Web Workers? (As others I've done the blob thing for years with workers when doing heavily threaded things). I kind of expected that one would be able to just call an async function and have it execute on another thread by now with intuitive shared state, but that was never proposed. Why not?\n\nwe're on the route of that. ü§î\nsearch for those proposals:\n- struct (shared struct section)\n- module block","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$19H9I6AwTYr-pJkIRFzfYhDeL6FC7jeR8DYqZRu8NE4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@sirisian:matrix.org\">@sirisian:matrix.org</a><br>Question. Possibly I&#39;m not searching the right terms, but when async/await was added to ECMAScript, why was threading never pulled into the core language away from Web Workers? (As others I&#39;ve done the blob thing for years with workers when doing heavily threaded things). I kind of expected that one would be able to just call an async function and have it execute on another thread by now with intuitive shared state, but that was never proposed. Why not?</blockquote></mx-reply><p>we're on the route of that. ü§î<br>search for those proposals:</p>\n<ul>\n<li>struct (shared struct section)</li>\n<li>module block</li>\n</ul>\n","mimetype":"text/html"}]},"ts":1646101163514,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$9lHmQ4eLAGSWYvI1C7NRKQXPx5_37F_jzyiTmmdbEYQ"},
{"content":{"body":"> <@gibson042:matrix.org> can someone verify my assessment that https://github.com/mishoo/UglifyJS/issues/5370 represents a deviation of V8 from other major implementations in FunctionDeclarationInstantiation with respect to non-simple parameter lists when VarDeclaredNames includes \"arguments\"?\n> ```\n> $ eshost -se '[].concat(...[\"function arguments(){}\", \"var arguments\"].map(occluding => [\"()\", \"(..._)\", \"(_=0)\"].map(params => { const r=\"return typeof arguments; \", f=Function(params.slice(1,-1), r+occluding); return `${f().padEnd(9)} // function${params}{${r+occluding}}`; }))).join(\"\\n\")'\n> #### ChakraCore, engine262, JavaScriptCore, Moddable XS, SpiderMonkey\n> function  // function(){return typeof arguments; function arguments(){}}\n> function  // function(..._){return typeof arguments; function arguments(){}}\n> function  // function(_=0){return typeof arguments; function arguments(){}}\n> object    // function(){return typeof arguments; var arguments}\n> object    // function(..._){return typeof arguments; var arguments}\n> object    // function(_=0){return typeof arguments; var arguments}\n> \n> #### V8\n> function  // function(){return typeof arguments; function arguments(){}}\n> function  // function(..._){return typeof arguments; function arguments(){}}\n> function  // function(_=0){return typeof arguments; function arguments(){}}\n> object    // function(){return typeof arguments; var arguments}\n> undefined // function(..._){return typeof arguments; var arguments}\n> undefined // function(_=0){return typeof arguments; var arguments}\n> ```\n\nTracing through the full machinery would take me a while, but I can at least confirm that there should not be a difference between simple and non-simple arguments lists in this case, so V8 is definitely wrong _somewhere_, and it seems quite likely to be wrong in the cases where it differs from other implementations","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$UoMfJyqjHWTLn805JYO7qj_JZxFqTbDKvQvXl7yd9FI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@gibson042:matrix.org\">@gibson042:matrix.org</a><br><p>can someone verify my assessment that https://github.com/mishoo/UglifyJS/issues/5370 represents a deviation of V8 from other major implementations in FunctionDeclarationInstantiation with respect to non-simple parameter lists when VarDeclaredNames includes \"arguments\"?</p>\n<pre><code>$ eshost -se '[].concat(...[\"function arguments(){}\", \"var arguments\"].map(occluding =&gt; [\"()\", \"(..._)\", \"(_=0)\"].map(params =&gt; { const r=\"return typeof arguments; \", f=Function(params.slice(1,-1), r+occluding); return `${f().padEnd(9)} // function${params}{${r+occluding}}`; }))).join(\"\\n\")'\n#### ChakraCore, engine262, JavaScriptCore, Moddable XS, SpiderMonkey\nfunction  // function(){return typeof arguments; function arguments(){}}\nfunction  // function(..._){return typeof arguments; function arguments(){}}\nfunction  // function(_=0){return typeof arguments; function arguments(){}}\nobject    // function(){return typeof arguments; var arguments}\nobject    // function(..._){return typeof arguments; var arguments}\nobject    // function(_=0){return typeof arguments; var arguments}\n\n#### V8\nfunction  // function(){return typeof arguments; function arguments(){}}\nfunction  // function(..._){return typeof arguments; function arguments(){}}\nfunction  // function(_=0){return typeof arguments; function arguments(){}}\nobject    // function(){return typeof arguments; var arguments}\nundefined // function(..._){return typeof arguments; var arguments}\nundefined // function(_=0){return typeof arguments; var arguments}\n</code></pre>\n</blockquote></mx-reply>Tracing through the full machinery would take me a while, but I can at least confirm that there should not be a difference between simple and non-simple arguments lists in this case, so V8 is definitely wrong <em>somewhere</em>, and it seems quite likely to be wrong in the cases where it differs from other implementations","m.relates_to":{"m.in_reply_to":{"event_id":"$UoMfJyqjHWTLn805JYO7qj_JZxFqTbDKvQvXl7yd9FI"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@gibson042:matrix.org> can someone verify my assessment that https://github.com/mishoo/UglifyJS/issues/5370 represents a deviation of V8 from other major implementations in FunctionDeclarationInstantiation with respect to non-simple parameter lists when VarDeclaredNames includes \"arguments\"?\n> ```\n> $ eshost -se '[].concat(...[\"function arguments(){}\", \"var arguments\"].map(occluding => [\"()\", \"(..._)\", \"(_=0)\"].map(params => { const r=\"return typeof arguments; \", f=Function(params.slice(1,-1), r+occluding); return `${f().padEnd(9)} // function${params}{${r+occluding}}`; }))).join(\"\\n\")'\n> #### ChakraCore, engine262, JavaScriptCore, Moddable XS, SpiderMonkey\n> function  // function(){return typeof arguments; function arguments(){}}\n> function  // function(..._){return typeof arguments; function arguments(){}}\n> function  // function(_=0){return typeof arguments; function arguments(){}}\n> object    // function(){return typeof arguments; var arguments}\n> object    // function(..._){return typeof arguments; var arguments}\n> object    // function(_=0){return typeof arguments; var arguments}\n> \n> #### V8\n> function  // function(){return typeof arguments; function arguments(){}}\n> function  // function(..._){return typeof arguments; function arguments(){}}\n> function  // function(_=0){return typeof arguments; function arguments(){}}\n> object    // function(){return typeof arguments; var arguments}\n> undefined // function(..._){return typeof arguments; var arguments}\n> undefined // function(_=0){return typeof arguments; var arguments}\n> ```\n\nTracing through the full machinery would take me a while, but I can at least confirm that there should not be a difference between simple and non-simple arguments lists in this case, so V8 is definitely wrong _somewhere_, and it seems quite likely to be wrong in the cases where it differs from other implementations","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$UoMfJyqjHWTLn805JYO7qj_JZxFqTbDKvQvXl7yd9FI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@gibson042:matrix.org\">@gibson042:matrix.org</a><br><p>can someone verify my assessment that https://github.com/mishoo/UglifyJS/issues/5370 represents a deviation of V8 from other major implementations in FunctionDeclarationInstantiation with respect to non-simple parameter lists when VarDeclaredNames includes \"arguments\"?</p>\n<pre><code>$ eshost -se '[].concat(...[\"function arguments(){}\", \"var arguments\"].map(occluding =&gt; [\"()\", \"(..._)\", \"(_=0)\"].map(params =&gt; { const r=\"return typeof arguments; \", f=Function(params.slice(1,-1), r+occluding); return `${f().padEnd(9)} // function${params}{${r+occluding}}`; }))).join(\"\\n\")'\n#### ChakraCore, engine262, JavaScriptCore, Moddable XS, SpiderMonkey\nfunction  // function(){return typeof arguments; function arguments(){}}\nfunction  // function(..._){return typeof arguments; function arguments(){}}\nfunction  // function(_=0){return typeof arguments; function arguments(){}}\nobject    // function(){return typeof arguments; var arguments}\nobject    // function(..._){return typeof arguments; var arguments}\nobject    // function(_=0){return typeof arguments; var arguments}\n\n#### V8\nfunction  // function(){return typeof arguments; function arguments(){}}\nfunction  // function(..._){return typeof arguments; function arguments(){}}\nfunction  // function(_=0){return typeof arguments; function arguments(){}}\nobject    // function(){return typeof arguments; var arguments}\nundefined // function(..._){return typeof arguments; var arguments}\nundefined // function(_=0){return typeof arguments; var arguments}\n</code></pre>\n</blockquote></mx-reply>Tracing through the full machinery would take me a while, but I can at least confirm that there should not be a difference between simple and non-simple arguments lists in this case, so V8 is definitely wrong <em>somewhere</em>, and it seems quite likely to be wrong in the cases where it differs from other implementations","mimetype":"text/html"}]},"ts":1646102516618,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$bjSbF-2vIGESyGns1Bw8NvuOr1DGNPtYI5-HcaGDNVg"},
{"content":{"body":"Well intuitive as in all closed over variables and they automatically behave like SharedArrayBuffer items without the bloat. (And in scope functions can just be called without any module syntax). Creating a variable and using an atomic to increment it or other operation would just \"work\" without stuff like shared structs or shuffling stuff into TypedArrays like it's some separate API.","msgtype":"m.text","org.matrix.msc1767.text":"Well intuitive as in all closed over variables and they automatically behave like SharedArrayBuffer items without the bloat. (And in scope functions can just be called without any module syntax). Creating a variable and using an atomic to increment it or other operation would just \"work\" without stuff like shared structs or shuffling stuff into TypedArrays like it's some separate API."},"ts":1646102551371,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$Ie8KzfiMda_raF0XpaLzmncUfb2cpIZJHU42TKqfMwY"},
{"content":{"body":"SABs are the single most \"handle with care\" part of the entire language, especially when used without atomics; making it so that every single thing in the language behaved like that would be... not an idea I'd endorse, to put it lightly, and I imagine that's a common sentiment among the committee","msgtype":"m.text","org.matrix.msc1767.text":"SABs are the single most \"handle with care\" part of the entire language, especially when used without atomics; making it so that every single thing in the language behaved like that would be... not an idea I'd endorse, to put it lightly, and I imagine that's a common sentiment among the committee"},"ts":1646102712310,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$xD9XQSpyI0wNXXHMfPoFZeOn4uM0zaVA7cg5oJRYrGg"},
{"content":{"body":"Like, just getting the memory model right for SABs was incredibly complicated, and not without bugs; see e.g. https://github.com/tc39/ecma262/issues/1680 https://github.com/tc39/ecma262/issues/2231 https://github.com/tc39/ecma262/pull/1511","msgtype":"m.text","org.matrix.msc1767.text":"Like, just getting the memory model right for SABs was incredibly complicated, and not without bugs; see e.g. https://github.com/tc39/ecma262/issues/1680 https://github.com/tc39/ecma262/issues/2231 https://github.com/tc39/ecma262/pull/1511"},"ts":1646102792295,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$9GFXW5ZJGtmGtER83-l4lmQJzlsfKMDi_ZhPsTWItTs"},
{"content":{"body":"and that's the _simple_ case, where you're just dealing with raw bytes; it gets more complicated when you get more complicated data structures involved","format":"org.matrix.custom.html","formatted_body":"and that's the <em>simple</em> case, where you're just dealing with raw bytes; it gets more complicated when you get more complicated data structures involved","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"and that's the _simple_ case, where you're just dealing with raw bytes; it gets more complicated when you get more complicated data structures involved","mimetype":"text/plain"},{"body":"and that's the <em>simple</em> case, where you're just dealing with raw bytes; it gets more complicated when you get more complicated data structures involved","mimetype":"text/html"}]},"ts":1646102812305,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$tdyBKkmgB6gpRSvtO1-jKGa885ummZ3OIompB4un5-g"},
{"content":{"body":"(also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense at least not on the main thread)","msgtype":"m.text","org.matrix.msc1767.text":"(also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense at least not on the main thread)"},"ts":1646102983636,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$zooKGJapnkIHRwmDn_uB2aWUpTIMlWVFk8anL22WR9s"},
{"content":{"body":" * (also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense at least not on the main thread)","m.new_content":{"body":"(also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense at least not on the main thread)","msgtype":"m.text","org.matrix.msc1767.text":"(also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense at least not on the main thread)"},"m.relates_to":{"event_id":"$zooKGJapnkIHRwmDn_uB2aWUpTIMlWVFk8anL22WR9s","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * (also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense at least not on the main thread)"},"ts":1646102998546,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$x_RJCKhsnYwzBVuXU6t1pSTvFYqlHJt_rk2YyD2E4N8"},
{"content":{"body":" * (also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense, at least not on the main thread)","m.new_content":{"body":"(also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense, at least not on the main thread)","msgtype":"m.text","org.matrix.msc1767.text":"(also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense, at least not on the main thread)"},"m.relates_to":{"event_id":"$zooKGJapnkIHRwmDn_uB2aWUpTIMlWVFk8anL22WR9s","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * (also blocking atomics don't work on the main thread, so the \"using an atomic to increment it\" thing doesn't really make sense, at least not on the main thread)"},"ts":1646103007307,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Us760k75tOENxC1hNAfqoJXbVi-Gcbsynf_a6mwrDBg"}
]