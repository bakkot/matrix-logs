[
{"content":{"body":"Unfortunately that doesn't work, async generator functions will not reenter until all previous next calls settle","msgtype":"m.text"},"ts":1674691303471,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$A4arr1CWXLkluHrLRlPNr2mqyxkYnU8xl3Fs6D_AoI0"},
{"content":{"body":"```\nasync function* foo() {\n    yield new Promise(r => setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo() {\n    yield new Promise(r =&gt; setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n</code></pre>\n","msgtype":"m.text"},"ts":1674691484502,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$3kBzkL4ueXA78bdWCbdL9iPnJv8nbxaIw3XI22w59dM"},
{"content":{"body":"the previous call settles in my example","msgtype":"m.text"},"ts":1674691503789,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$iEoDGY1F6odBkj1RItXwwPq92moUah-BF-Xrt_JI_oA"},
{"content":{"body":"The `reenter` won't log until the 1000ms is up","format":"org.matrix.custom.html","formatted_body":"The <code>reenter</code> won't log until the 1000ms is up","msgtype":"m.text"},"ts":1674691509382,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$dqHfVRhQxw0lp8KpNxo2ul2P2oTfyyY0kHiyfnYBcl4"},
{"content":{"body":"yes but it doesn't need to","msgtype":"m.text"},"ts":1674691515751,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$mILfoDp7XPLE1guHT7-5JOfsTf3A5L4W3H6p5NJhCmE"},
{"content":{"body":"my example still works","msgtype":"m.text"},"ts":1674691517245,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$OvRIbhmk58CVRO4IZTIcBZGtYD2k_pegNeahVZGJpVc"},
{"content":{"body":"```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","msgtype":"m.text"},"ts":1674691567096,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cU0qjlMUdi2PGGFeG8gMm_1SR9OIJrabX2ReejzO4Hw"},
{"content":{"body":" * ```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":" * <pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","m.new_content":{"body":"```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$cU0qjlMUdi2PGGFeG8gMm_1SR9OIJrabX2ReejzO4Hw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674691596282,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BQJPkZZqxkxL-JAIvEQh6RmBV9aVbpnR6hUJ7V9Epdc"},
{"content":{"body":"```\nasync function* foo(){\n    yield 0;\n    console.log('reenter');\n    await sleep(1000);\n    yield 1;\n}\nlet it = foo();\nit.next();\nit.next();\nconsole.log('end');\n```\nLogs `end` then `reenter`, the first yield doesn't settle the iterator until after a tick","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){\n    yield 0;\n    console.log('reenter');\n    await sleep(1000);\n    yield 1;\n}\nlet it = foo();\nit.next();\nit.next();\nconsole.log('end');\n</code></pre>\n<p>Logs <code>end</code> then <code>reenter</code>, the first yield doesn't settle the iterator until after a tick</p>\n","msgtype":"m.text"},"ts":1674691737731,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$oV3V5N9UReXjWvCFDaep2GXvxec3HaiXPPFNEcrjQcE"},
{"content":{"body":"I think you're incorrect, and even if you're correct, you're example will start to fail again as soon as you chain your iterators with async functionality","msgtype":"m.text"},"ts":1674691750644,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$N7_rkNp3B5upiyKickJziBjCuNpL1DSxosUn1s7Lg-A"},
{"content":{"body":"```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","msgtype":"m.text"},"ts":1674691790751,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5VUt2EWmI3-JEthgqzK1S15gtCGCwU78j0q3myea6kc"},
{"content":{"body":" * ```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":" * <pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","m.new_content":{"body":"```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$5VUt2EWmI3-JEthgqzK1S15gtCGCwU78j0q3myea6kc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674691796548,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$wh-ksmd6U5jFS0jlMdKJ7MoGPVrv21WZe_35kRwObwE"},
{"content":{"body":"not with the definition of `map` in the slides","format":"org.matrix.custom.html","formatted_body":"not with the definition of <code>map</code> in the slides","msgtype":"m.text"},"ts":1674691800077,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$HDY--qTDmPLpHoQ05A9eGIPng6zqx7dondy9nG9DVDs"}
]