[
{"content":{"body":"Unfortunately that doesn't work, async generator functions will not reenter until all previous next calls settle","msgtype":"m.text"},"ts":1674691303471,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$A4arr1CWXLkluHrLRlPNr2mqyxkYnU8xl3Fs6D_AoI0"},
{"content":{"body":"```\nasync function* foo() {\n    yield new Promise(r => setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo() {\n    yield new Promise(r =&gt; setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n</code></pre>\n","msgtype":"m.text"},"ts":1674691484502,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$3kBzkL4ueXA78bdWCbdL9iPnJv8nbxaIw3XI22w59dM"},
{"content":{"body":"the previous call settles in my example","msgtype":"m.text"},"ts":1674691503789,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$iEoDGY1F6odBkj1RItXwwPq92moUah-BF-Xrt_JI_oA"},
{"content":{"body":"The `reenter` won't log until the 1000ms is up","format":"org.matrix.custom.html","formatted_body":"The <code>reenter</code> won't log until the 1000ms is up","msgtype":"m.text"},"ts":1674691509382,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$dqHfVRhQxw0lp8KpNxo2ul2P2oTfyyY0kHiyfnYBcl4"},
{"content":{"body":"yes but it doesn't need to","msgtype":"m.text"},"ts":1674691515751,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$mILfoDp7XPLE1guHT7-5JOfsTf3A5L4W3H6p5NJhCmE"},
{"content":{"body":"my example still works","msgtype":"m.text"},"ts":1674691517245,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$OvRIbhmk58CVRO4IZTIcBZGtYD2k_pegNeahVZGJpVc"},
{"content":{"body":"```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","msgtype":"m.text"},"ts":1674691567096,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cU0qjlMUdi2PGGFeG8gMm_1SR9OIJrabX2ReejzO4Hw"},
{"content":{"body":" * ```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":" * <pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","m.new_content":{"body":"```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$cU0qjlMUdi2PGGFeG8gMm_1SR9OIJrabX2ReejzO4Hw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674691596282,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BQJPkZZqxkxL-JAIvEQh6RmBV9aVbpnR6hUJ7V9Epdc"},
{"content":{"body":"```\nasync function* foo(){\n    yield 0;\n    console.log('reenter');\n    await sleep(1000);\n    yield 1;\n}\nlet it = foo();\nit.next();\nit.next();\nconsole.log('end');\n```\nLogs `end` then `reenter`, the first yield doesn't settle the iterator until after a tick","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){\n    yield 0;\n    console.log('reenter');\n    await sleep(1000);\n    yield 1;\n}\nlet it = foo();\nit.next();\nit.next();\nconsole.log('end');\n</code></pre>\n<p>Logs <code>end</code> then <code>reenter</code>, the first yield doesn't settle the iterator until after a tick</p>\n","msgtype":"m.text"},"ts":1674691737731,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$oV3V5N9UReXjWvCFDaep2GXvxec3HaiXPPFNEcrjQcE"},
{"content":{"body":"I think you're incorrect, and even if you're correct, you're example will start to fail again as soon as you chain your iterators with async functionality","msgtype":"m.text"},"ts":1674691750644,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$N7_rkNp3B5upiyKickJziBjCuNpL1DSxosUn1s7Lg-A"},
{"content":{"body":"```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","msgtype":"m.text"},"ts":1674691790751,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5VUt2EWmI3-JEthgqzK1S15gtCGCwU78j0q3myea6kc"},
{"content":{"body":" * ```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":" * <pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","m.new_content":{"body":"```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$5VUt2EWmI3-JEthgqzK1S15gtCGCwU78j0q3myea6kc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674691796548,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$wh-ksmd6U5jFS0jlMdKJ7MoGPVrv21WZe_35kRwObwE"},
{"content":{"body":"not with the definition of `map` in the slides","format":"org.matrix.custom.html","formatted_body":"not with the definition of <code>map</code> in the slides","msgtype":"m.text"},"ts":1674691800077,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$HDY--qTDmPLpHoQ05A9eGIPng6zqx7dondy9nG9DVDs"},
{"content":{"body":"I am pretty sure","msgtype":"m.text"},"ts":1674691811953,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$znQ6fURgJoVzO3SefHD8gyF93jgLZR3JDoiFFWQW4SY"},
{"content":{"body":"but I will check after work and get back to you","msgtype":"m.text"},"ts":1674691817475,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$AI5fjgL-jPMbrYNCqGIma_80n55fKfrWQOTa9BOmz2U"},
{"content":{"body":"(couple hours probably)","msgtype":"m.text"},"ts":1674691822712,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$P9_UxKM1gVmq60Udqfi-ymE3aBUH1vwFwVeoqS3h1ik"},
{"content":{"body":"It depends on how the source iterator performs parallelization","msgtype":"m.text"},"ts":1674691942837,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$O_R2trB2r0z-Pjj7ehYEepQK9nrtrPAqRGm3CR_ooVk"},
{"content":{"body":"pretty sure it does not","msgtype":"m.text"},"ts":1674692059640,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ISrcvWBmtPSNPQqlno3VGYypPg-2XfXjYZRNt1YBaG8"},
{"content":{"body":"Oh you're right, the second `.map` will work in parallel with the first `.map`","format":"org.matrix.custom.html","formatted_body":"Oh you're right, the second <code>.map</code> will work in parallel with the first <code>.map</code>","msgtype":"m.text"},"ts":1674692133748,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$jHeBq2CLg3LBuBl7o412GiA9ehlV_wDNO3d5-G4Q9J8"},
{"content":{"body":"I'm recalling when I was writing `map` as an async-gen function itself, which means I was still hitting backpressure","format":"org.matrix.custom.html","formatted_body":"I'm recalling when I was writing <code>map</code> as an async-gen function itself, which means I was still hitting backpressure","msgtype":"m.text"},"ts":1674692163380,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$JqG5Qh24pBdG60c5LFffd7JmvfrrdncbdPKcigvdUno"},
{"content":{"body":"So only the first iterator chained off a back-pressure iterator will be serial","msgtype":"m.text"},"ts":1674692187843,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Q6USiX0anInzOTVv8WSLTl14S6xI988glZe2AThxxNo"},
{"content":{"body":"We still hit the reentrancy issue with an async-gen function, which would be neat to ~solve~change","msgtype":"m.text"},"ts":1674692229533,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$2tn2D7oHLiUEzKkfhIZdcHIYBEpI9PqEDhm-H9MSgdI"},
{"content":{"body":" * We still hit the reentrancy issue with an async-gen function, which would be neat to ~solve~change","m.new_content":{"body":"We still hit the reentrancy issue with an async-gen function, which would be neat to ~solve~change","msgtype":"m.text"},"m.relates_to":{"event_id":"$2tn2D7oHLiUEzKkfhIZdcHIYBEpI9PqEDhm-H9MSgdI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674692242816,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$OhUxtlK6s1bOFDZSown3kE3s7jnnBJCdfkD65d1xxcc"},
{"content":{"body":"Justin Ridgewell: yeah, and that's the problem with the current spec too: the async iterator helpers are implemented as async generators","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a>: yeah, and that's the problem with the current spec too: the async iterator helpers are implemented as async generators","msgtype":"m.text"},"ts":1674702261186,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$JLUIIfB_BiY9uzG7Spk5Aq69P-VXXr9SYCpimWxzW1E"},
{"content":{"body":"here's code you can run today which demonstrates that the mapper from the slides can be parallel, both from with itself and with the underlying generator https://gist.github.com/bakkot/a338838aee667517adb03edfa83aaed1","msgtype":"m.text"},"ts":1674702293904,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$a_GkbfHkvW2xI7VNWDx7niIPvmvCHiJp4hJNOvviq0U"}
]