[
{"content":{"body":"Unfortunately that doesn't work, async generator functions will not reenter until all previous next calls settle","msgtype":"m.text"},"ts":1674691303471,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$A4arr1CWXLkluHrLRlPNr2mqyxkYnU8xl3Fs6D_AoI0"},
{"content":{"body":"```\nasync function* foo() {\n    yield new Promise(r => setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo() {\n    yield new Promise(r =&gt; setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n</code></pre>\n","msgtype":"m.text"},"ts":1674691484502,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$3kBzkL4ueXA78bdWCbdL9iPnJv8nbxaIw3XI22w59dM"},
{"content":{"body":"the previous call settles in my example","msgtype":"m.text"},"ts":1674691503789,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$iEoDGY1F6odBkj1RItXwwPq92moUah-BF-Xrt_JI_oA"},
{"content":{"body":"The `reenter` won't log until the 1000ms is up","format":"org.matrix.custom.html","formatted_body":"The <code>reenter</code> won't log until the 1000ms is up","msgtype":"m.text"},"ts":1674691509382,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$dqHfVRhQxw0lp8KpNxo2ul2P2oTfyyY0kHiyfnYBcl4"},
{"content":{"body":"yes but it doesn't need to","msgtype":"m.text"},"ts":1674691515751,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$mILfoDp7XPLE1guHT7-5JOfsTf3A5L4W3H6p5NJhCmE"},
{"content":{"body":"my example still works","msgtype":"m.text"},"ts":1674691517245,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$OvRIbhmk58CVRO4IZTIcBZGtYD2k_pegNeahVZGJpVc"},
{"content":{"body":"```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","msgtype":"m.text"},"ts":1674691567096,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cU0qjlMUdi2PGGFeG8gMm_1SR9OIJrabX2ReejzO4Hw"},
{"content":{"body":" * ```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":" * <pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","m.new_content":{"body":"```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$cU0qjlMUdi2PGGFeG8gMm_1SR9OIJrabX2ReejzO4Hw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674691596282,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BQJPkZZqxkxL-JAIvEQh6RmBV9aVbpnR6hUJ7V9Epdc"},
{"content":{"body":"```\nasync function* foo(){\n    yield 0;\n    console.log('reenter');\n    await sleep(1000);\n    yield 1;\n}\nlet it = foo();\nit.next();\nit.next();\nconsole.log('end');\n```\nLogs `end` then `reenter`, the first yield doesn't settle the iterator until after a tick","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){\n    yield 0;\n    console.log('reenter');\n    await sleep(1000);\n    yield 1;\n}\nlet it = foo();\nit.next();\nit.next();\nconsole.log('end');\n</code></pre>\n<p>Logs <code>end</code> then <code>reenter</code>, the first yield doesn't settle the iterator until after a tick</p>\n","msgtype":"m.text"},"ts":1674691737731,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$oV3V5N9UReXjWvCFDaep2GXvxec3HaiXPPFNEcrjQcE"},
{"content":{"body":"I think you're incorrect, and even if you're correct, you're example will start to fail again as soon as you chain your iterators with async functionality","msgtype":"m.text"},"ts":1674691750644,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$N7_rkNp3B5upiyKickJziBjCuNpL1DSxosUn1s7Lg-A"},
{"content":{"body":"```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","msgtype":"m.text"},"ts":1674691790751,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5VUt2EWmI3-JEthgqzK1S15gtCGCwU78j0q3myea6kc"},
{"content":{"body":" * ```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":" * <pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","m.new_content":{"body":"```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$5VUt2EWmI3-JEthgqzK1S15gtCGCwU78j0q3myea6kc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674691796548,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$wh-ksmd6U5jFS0jlMdKJ7MoGPVrv21WZe_35kRwObwE"},
{"content":{"body":"not with the definition of `map` in the slides","format":"org.matrix.custom.html","formatted_body":"not with the definition of <code>map</code> in the slides","msgtype":"m.text"},"ts":1674691800077,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$HDY--qTDmPLpHoQ05A9eGIPng6zqx7dondy9nG9DVDs"},
{"content":{"body":"I am pretty sure","msgtype":"m.text"},"ts":1674691811953,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$znQ6fURgJoVzO3SefHD8gyF93jgLZR3JDoiFFWQW4SY"},
{"content":{"body":"but I will check after work and get back to you","msgtype":"m.text"},"ts":1674691817475,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$AI5fjgL-jPMbrYNCqGIma_80n55fKfrWQOTa9BOmz2U"},
{"content":{"body":"(couple hours probably)","msgtype":"m.text"},"ts":1674691822712,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$P9_UxKM1gVmq60Udqfi-ymE3aBUH1vwFwVeoqS3h1ik"},
{"content":{"body":"It depends on how the source iterator performs parallelization","msgtype":"m.text"},"ts":1674691942837,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$O_R2trB2r0z-Pjj7ehYEepQK9nrtrPAqRGm3CR_ooVk"},
{"content":{"body":"pretty sure it does not","msgtype":"m.text"},"ts":1674692059640,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ISrcvWBmtPSNPQqlno3VGYypPg-2XfXjYZRNt1YBaG8"},
{"content":{"body":"Oh you're right, the second `.map` will work in parallel with the first `.map`","format":"org.matrix.custom.html","formatted_body":"Oh you're right, the second <code>.map</code> will work in parallel with the first <code>.map</code>","msgtype":"m.text"},"ts":1674692133748,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$jHeBq2CLg3LBuBl7o412GiA9ehlV_wDNO3d5-G4Q9J8"},
{"content":{"body":"I'm recalling when I was writing `map` as an async-gen function itself, which means I was still hitting backpressure","format":"org.matrix.custom.html","formatted_body":"I'm recalling when I was writing <code>map</code> as an async-gen function itself, which means I was still hitting backpressure","msgtype":"m.text"},"ts":1674692163380,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$JqG5Qh24pBdG60c5LFffd7JmvfrrdncbdPKcigvdUno"},
{"content":{"body":"So only the first iterator chained off a back-pressure iterator will be serial","msgtype":"m.text"},"ts":1674692187843,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Q6USiX0anInzOTVv8WSLTl14S6xI988glZe2AThxxNo"},
{"content":{"body":"We still hit the reentrancy issue with an async-gen function, which would be neat to ~solve~change","msgtype":"m.text"},"ts":1674692229533,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$2tn2D7oHLiUEzKkfhIZdcHIYBEpI9PqEDhm-H9MSgdI"},
{"content":{"body":" * We still hit the reentrancy issue with an async-gen function, which would be neat to ~solve~change","m.new_content":{"body":"We still hit the reentrancy issue with an async-gen function, which would be neat to ~solve~change","msgtype":"m.text"},"m.relates_to":{"event_id":"$2tn2D7oHLiUEzKkfhIZdcHIYBEpI9PqEDhm-H9MSgdI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674692242816,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$OhUxtlK6s1bOFDZSown3kE3s7jnnBJCdfkD65d1xxcc"},
{"content":{"body":"Justin Ridgewell: yeah, and that's the problem with the current spec too: the async iterator helpers are implemented as async generators","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a>: yeah, and that's the problem with the current spec too: the async iterator helpers are implemented as async generators","msgtype":"m.text"},"ts":1674702261186,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$JLUIIfB_BiY9uzG7Spk5Aq69P-VXXr9SYCpimWxzW1E"},
{"content":{"body":"here's code you can run today which demonstrates that the mapper from the slides can be parallel, both from with itself and with the underlying generator https://gist.github.com/bakkot/a338838aee667517adb03edfa83aaed1","msgtype":"m.text"},"ts":1674702293904,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$a_GkbfHkvW2xI7VNWDx7niIPvmvCHiJp4hJNOvviq0U"},
{"content":{"body":"and indeed the original generator can't be parallel with itself. I don't think there's anything we can do about that, though - the whole point of generators is that they're written as straight-line code, and you can't start executing the next line until the previous one finishes","msgtype":"m.text"},"ts":1674702419767,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$s__nz81SENhRZSfwGsrzj6AR-f6WLQIRjPD8ZTq647Y"},
{"content":{"body":" * here's code you can run today which demonstrates that the mapper from the slides can be parallel, both with itself and with the underlying generator https://gist.github.com/bakkot/a338838aee667517adb03edfa83aaed1","m.new_content":{"body":"here's code you can run today which demonstrates that the mapper from the slides can be parallel, both with itself and with the underlying generator https://gist.github.com/bakkot/a338838aee667517adb03edfa83aaed1","msgtype":"m.text"},"m.relates_to":{"event_id":"$a_GkbfHkvW2xI7VNWDx7niIPvmvCHiJp4hJNOvviq0U","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674702429144,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$nRvo1MM0R65vuyhtXtTqakgNzlpV45q-coxNDhqyc1g"},
{"content":{"body":"I think interleaving of async map iterators is expected behavior.","msgtype":"m.text"},"ts":1674702554701,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$4exb4DMcRA0WFBWfTMmJ94YvrE05UcTwgxhI0ofGFbU"},
{"content":{"body":"Kris Kowal: what do you mean by interleaving?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a>: what do you mean by interleaving?","msgtype":"m.text"},"ts":1674702584965,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$kuSPpOpDuhDW4C1l97Ne6HbgF4OcTFWE8fXHKG5LJJA"},
{"content":{"body":"just that you can be executing the mapper function in parallel with itself?","msgtype":"m.text"},"ts":1674702604714,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$PxLa03_VSEzkc1pyjSENRMvCVoXDy4CMw_irqefEpek"},
{"content":{"body":"(assuming the resulting mapped thing is pumped multiple times)","msgtype":"m.text"},"ts":1674702620871,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$eKHE5VyjmHNuyYrsXZnwu-_OWGXnK6IUsFMdGaLdI58"},
{"content":{"body":"That effect for one, yes.","msgtype":"m.text"},"ts":1674702648456,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$zD2Rdoc9Yz3yv6Kb7SG4pwBfyT3FxtzpVsFewXcqQ3w"},
{"content":{"body":"> <@bakkot:matrix.org> and indeed the original generator can't be parallel with itself. I don't think there's anything we can do about that, though - the whole point of generators is that they're written as straight-line code, and you can't start executing the next line until the previous one finishes\n\nIt's not just the running of the generators code, but the settlement of the `next()` promise external from the genrator that blocks","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$s__nz81SENhRZSfwGsrzj6AR-f6WLQIRjPD8ZTq647Y?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>and indeed the original generator can&#39;t be parallel with itself. I don&#39;t think there&#39;s anything we can do about that, though - the whole point of generators is that they&#39;re written as straight-line code, and you can&#39;t start executing the next line until the previous one finishes</blockquote></mx-reply>It's not just the running of the generators code, but the settlement of the <code>next()</code> promise external from the genrator that blocks","m.relates_to":{"m.in_reply_to":{"event_id":"$s__nz81SENhRZSfwGsrzj6AR-f6WLQIRjPD8ZTq647Y"}},"msgtype":"m.text"},"ts":1674702705720,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$4wVHyh7uA3dEcCReAej_jitjjprSYVh_HUKSCOgqJGA"},
{"content":{"body":"But also map(xf).map(yf) would interleave turns of xf and yf.","msgtype":"m.text"},"ts":1674702713181,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$InTaox0U-Lsn5irK4JcbDreeqidDgUku8aPI0oCbMr4"},
{"content":{"body":"Eg, I want to be able to return a `yield fetch()` and reenter without that fetch having settled","format":"org.matrix.custom.html","formatted_body":"Eg, I want to be able to return a <code>yield fetch()</code> and reenter without that fetch having settled","msgtype":"m.text"},"ts":1674702730343,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$f6nLzGPhFP4HX64b9xHGZZ6heXtNpsj3FnEPDC5GDms"},
{"content":{"body":"> <@jridgewell:matrix.org> It's not just the running of the generators code, but the settlement of the `next()` promise external from the genrator that blocks\n\nIn the case that you specifically yield a promise, do you mean, or is there another case I'm not thinking of?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$4wVHyh7uA3dEcCReAej_jitjjprSYVh_HUKSCOgqJGA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>It's not just the running of the generators code, but the settlement of the <code>next()</code> promise external from the genrator that blocks</blockquote></mx-reply>In the case that you specifically yield a promise, do you mean, or is there another case I'm not thinking of?","m.relates_to":{"m.in_reply_to":{"event_id":"$4wVHyh7uA3dEcCReAej_jitjjprSYVh_HUKSCOgqJGA"}},"msgtype":"m.text"},"ts":1674702738984,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$CiDw7BofSnA778P0Go802vTp22PAhiioVFrDjm1h96w"},
{"content":{"body":"ah yeah","msgtype":"m.text"},"ts":1674702740040,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$qv8Y9q0a5Y6G7t9EmkltZHbpP_WiMf6is6Zv8CzF46o"},
{"content":{"body":"with this helper, you could do `yield { v: fetch() }` in your async generator and then `.map(box => box.v)` to get parallelism in the resulting thing (or rather the ability to be parallel assuming someone calls `.next` eagerly)","format":"org.matrix.custom.html","formatted_body":"with this helper, you could do <code>yield { v: fetch() }</code> in your async generator and then <code>.map(box =&gt; box.v)</code> to get parallelism in the resulting thing (or rather the ability to be parallel assuming someone calls <code>.next</code> eagerly)","msgtype":"m.text"},"ts":1674702762329,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$p5GSh8cqP2AgM_dMkK-grd_IuXhu-sneK5vtkX-99ro"},
{"content":{"body":"a little silly but works fine","msgtype":"m.text"},"ts":1674702775076,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$4wGOv2nu_3PsQDNwH99UBx0tVmU-Rb9WDKmahrbFwKY"},
{"content":{"body":"... I think","msgtype":"m.text"},"ts":1674702776665,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$uHt_5BFgNh7ipdjOhZQnimMk4eJtZzlcELF4I95spNo"},
{"content":{"body":"> <@kriskowal:matrix.org> But also map(xf).map(yf) would interleave turns of xf and yf.\n\nRight, yeah. You get that with my proposed tweak also (again assuming someone calls `.next()` eagerly)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$InTaox0U-Lsn5irK4JcbDreeqidDgUku8aPI0oCbMr4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>But also map(xf).map(yf) would interleave turns of xf and yf.</blockquote></mx-reply>Right, yeah. You get that with my proposed tweak also (again assuming someone calls <code>.next()</code> eagerly)","m.relates_to":{"m.in_reply_to":{"event_id":"$InTaox0U-Lsn5irK4JcbDreeqidDgUku8aPI0oCbMr4"}},"msgtype":"m.text"},"ts":1674702835379,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$twPq3tMXk4hKzVKIqgJzvIj2cq8aKt-CZUsOcAf1kKI"},
{"content":{"body":"> <@jridgewell:matrix.org> Eg, I want to be able to return a `yield fetch()` and reenter without that fetch having settled\n\nI don‚Äôt have spare attention to dig, but I would find it very surprising if `yield fetch()` were equivalent to `yield await fetch()`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$f6nLzGPhFP4HX64b9xHGZZ6heXtNpsj3FnEPDC5GDms?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Eg, I want to be able to return a <code>yield fetch()</code> and reenter without that fetch having settled</blockquote></mx-reply>I don‚Äôt have spare attention to dig, but I would find it very surprising if <code>yield fetch()</code> were equivalent to <code>yield await fetch()</code>.","m.relates_to":{"m.in_reply_to":{"event_id":"$f6nLzGPhFP4HX64b9xHGZZ6heXtNpsj3FnEPDC5GDms"}},"msgtype":"m.text"},"ts":1674702849163,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$QQUbSQ-PxGjotkLj4JxYl9qhNkAccwOck6XrqjVmUCM"},
{"content":{"body":"They are, unfortunately","msgtype":"m.text"},"ts":1674702954671,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$oxH70IrA_mOLgUWjtkGICRdiCG7hG02crVVndppheaI"},
{"content":{"body":"> ```\n> async function* foo() {\n>     yield new Promise(r => setTimeout(r, 1000));\n>     console.log('reenter');\n> }\n> const it = foo();\n> it.next();\n> it.next();\n> ```\n\n","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<pre><code>async function* foo() {\n    yield new Promise(r =&gt; setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n</code></pre>\n</blockquote>\n","msgtype":"m.text"},"ts":1674702965390,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$9xRIUVpF8QahQJTrfovDx697lPp3rfKrvNcMpgb0UTU"},
{"content":{"body":"^ That waits a full second before logging `reenter`","format":"org.matrix.custom.html","formatted_body":"^ That waits a full second before logging <code>reenter</code>","msgtype":"m.text"},"ts":1674702982021,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$mLAX-7xZCFBPU557HBkbgNJ8tHHlVvs_mYVJgRJEQKw"},
{"content":{"body":"My original map helper was something like `for await (const x of source) yield mapper(x)`, and if `mapper` has any async waiting, it blocks.","format":"org.matrix.custom.html","formatted_body":"My original map helper was something like <code>for await (const x of source) yield mapper(x)</code>, and if <code>mapper</code> has any async waiting, it blocks.","msgtype":"m.text"},"ts":1674703078898,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$0hP-XRE6cgXXbY0lEfz4u9isLzcCktCJxYc1IJXQxZo"},
{"content":{"body":"here's the slides where we decided that `yield` is `yield await` https://docs.google.com/presentation/d/1U6PivKbFO0YgoFlrYB82MtXf1ofCp1xSVOODOvranBM/edit#slide=id.g223fba4116_0_196","format":"org.matrix.custom.html","formatted_body":"here's the slides where we decided that <code>yield</code> is <code>yield await</code> https://docs.google.com/presentation/d/1U6PivKbFO0YgoFlrYB82MtXf1ofCp1xSVOODOvranBM/edit#slide=id.g223fba4116_0_196","msgtype":"m.text"},"ts":1674703093173,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$eakQm0oKmul30T6ktW2ItI-w6R1S4DI-vNEDuFTTazk"},
{"content":{"body":"and notes https://github.com/tc39/notes/blob/55af84ac0ed7a250206849dddd628b2c1db2c9b1/meetings/2017-05/may-25.md#15iva-revisiting-async-generator-yield-behavior","msgtype":"m.text"},"ts":1674703140793,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$FI03dpeM0Cu5VFvzZ6F51aVV3M7KFBhaEISgcsL1AJg"},
{"content":{"body":"üò¶ Before my time","msgtype":"m.text"},"ts":1674703170027,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Y9LF6f_wXpih0ScePtGuRI6resd9GYQxQYox2q2WpkE"},
{"content":{"body":"Ah, surprising but maybe for the best. In any case, ‚Äúoverdriving‚Äù (drawing concurrent promises from next()) a pipeline of async maps to get parallelism is useful, so glad that‚Äôll work regardless.","msgtype":"m.text"},"ts":1674707946481,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$B4LsP1mtg-RYhRWpkXnIxU3CSQ1gmV5iVAwdphC0lak"},
{"content":{"body":"In fact, the implicit `await` is doing me a big favor in:\n```\nfunction parallel(limit, process) {\n  function *workers() {\n    for (const worker of count(limit)) {\n      yield process(worker);\n    }\n  }\n  return Promise.all(workers());\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>In fact, the implicit <code>await</code> is doing me a big favor in:</p>\n<pre><code>function parallel(limit, process) {\n  function *workers() {\n    for (const worker of count(limit)) {\n      yield process(worker);\n    }\n  }\n  return Promise.all(workers());\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1674708022465,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$tg0kHPSEAX5_0wDB33ecOtV7Ya3_Xv6LNbmX11hK5wI"},
{"content":{"body":"Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nAsyncIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":"<p>Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>AsyncIterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","msgtype":"m.text"},"ts":1674708267270,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$-RalYnmbKTFUKx2cRYrvCOLbbCaH4T-yT91I9MI88oc"},
{"content":{"body":" * Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>Iterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","m.new_content":{"body":"Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":"<p>Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>Iterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$-RalYnmbKTFUKx2cRYrvCOLbbCaH4T-yT91I9MI88oc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674708284216,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$_Dmw8AUATQIHI4CTBSJa0akos5J3RJ98Dx7osY5u9R8"},
{"content":{"body":" * Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nAsyncIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>AsyncIterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","m.new_content":{"body":"Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nAsyncIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":"<p>Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>AsyncIterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$-RalYnmbKTFUKx2cRYrvCOLbbCaH4T-yT91I9MI88oc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674708296858,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$FSenBI3goCj2oulWwp2CwH_vkLlLvUcU_9ek4B4QRn0"},
{"content":{"body":"> <@kriskowal:matrix.org> In fact, the implicit `await` is doing me a big favor in:\n> ```\n> function parallel(limit, process) {\n>   function *workers() {\n>     for (const worker of count(limit)) {\n>       yield process(worker);\n>     }\n>   }\n>   return Promise.all(workers());\n> }\n> ```\n\nThere's no async iterator there and so no implicit `await`; did you mean a different thing?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$tg0kHPSEAX5_0wDB33ecOtV7Ya3_Xv6LNbmX11hK5wI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br><p>In fact, the implicit <code>await</code> is doing me a big favor in:</p>\n<pre><code>function parallel(limit, process) {\n  function *workers() {\n    for (const worker of count(limit)) {\n      yield process(worker);\n    }\n  }\n  return Promise.all(workers());\n}\n</code></pre>\n</blockquote></mx-reply>There's no async iterator there and so no implicit <code>await</code>; did you mean a different thing?","m.relates_to":{"m.in_reply_to":{"event_id":"$tg0kHPSEAX5_0wDB33ecOtV7Ya3_Xv6LNbmX11hK5wI"}},"msgtype":"m.text"},"ts":1674710061771,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$qMZjknE2YlzHZjhzlFYhqjeLoZjiQdGpWtFFi1pCX_Q"},
{"content":{"body":"> <@kriskowal:matrix.org> Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n> \n> ```\n> AsyncIterator.prototype.parallelForEach = async (limit, values, process) =>\n>   parallel(limit, () => AsyncIterator.from(values).forEach(process));\n> ```\n\n`AsyncIterator.from` works and does the thing you want, yup, though your specification of `parallelForEach` is possibly confused - prototype-placed methods generally want to refer to `this`","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$-RalYnmbKTFUKx2cRYrvCOLbbCaH4T-yT91I9MI88oc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br><p>Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>AsyncIterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n</blockquote></mx-reply><code>AsyncIterator.from</code> works and does the thing you want, yup, though your specification of <code>parallelForEach</code> is possibly confused - prototype-placed methods generally want to refer to <code>this</code>","m.relates_to":{"m.in_reply_to":{"event_id":"$-RalYnmbKTFUKx2cRYrvCOLbbCaH4T-yT91I9MI88oc"}},"msgtype":"m.text"},"ts":1674710090512,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$1yNgHAL5x6oMSQFF0Tye1h67_A5zYiYHta7XTLkVbzc"},
{"content":{"body":"> <@bakkot:matrix.org> `AsyncIterator.from` works and does the thing you want, yup, though your specification of `parallelForEach` is possibly confused - prototype-placed methods generally want to refer to `this`\n\nIndeed, lost in translation. Local copy wasn‚Äôt framed as a prototype method.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$1yNgHAL5x6oMSQFF0Tye1h67_A5zYiYHta7XTLkVbzc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br><code>AsyncIterator.from</code> works and does the thing you want, yup, though your specification of <code>parallelForEach</code> is possibly confused - prototype-placed methods generally want to refer to <code>this</code></blockquote></mx-reply>Indeed, lost in translation. Local copy wasn‚Äôt framed as a prototype method.","m.relates_to":{"m.in_reply_to":{"event_id":"$1yNgHAL5x6oMSQFF0Tye1h67_A5zYiYHta7XTLkVbzc"}},"msgtype":"m.text"},"ts":1674710151897,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$YkVJnOge4XT0bRIOpJODPMlKZ8PyGkAuZrmuFnQ1p_Q"},
{"content":{"body":"> <@bakkot:matrix.org> There's no async iterator there and so no implicit `await`; did you mean a different thing?\n\nOh, indeed.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$qMZjknE2YlzHZjhzlFYhqjeLoZjiQdGpWtFFi1pCX_Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>There's no async iterator there and so no implicit <code>await</code>; did you mean a different thing?</blockquote></mx-reply>Oh, indeed.","m.relates_to":{"m.in_reply_to":{"event_id":"$qMZjknE2YlzHZjhzlFYhqjeLoZjiQdGpWtFFi1pCX_Q"}},"msgtype":"m.text"},"ts":1674710185919,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$8lMX0vIsIcaBybEzcCx8dbws3Gs7grvZyf0cLsmJTQs"},
{"content":{"body":" * Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nconst parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>const parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","m.new_content":{"body":"Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nconst parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":"<p>Out of which you can build bounded concurrency pretty easily (I‚Äôm taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>const parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$-RalYnmbKTFUKx2cRYrvCOLbbCaH4T-yT91I9MI88oc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674710276740,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Ivenl4ekms9FB8d6Z2dP0HKjhMscH3Hp97iI1Dfpd84"},
{"content":{"body":"> If you want the flexibility of not blocking on the async operation before continuing the async generator body, then just don't yield the value yet.\n\nü§î That doesn't really make sense.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>If you want the flexibility of not blocking on the async operation before continuing the async generator body, then just don't yield the value yet.</p>\n</blockquote>\n<p>ü§î That doesn't really make sense.</p>\n","msgtype":"m.text"},"ts":1674711537150,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$xD35IiQRuK53vxPy2qDkGcsaVIAm9_qz3hdYb_7-qH8"},
{"content":{"body":" * > If you want the flexibility of not blocking on the async operation before continuing the async generator body, then just don't yield the value yet.\n\nü§î That doesn't really make sense.","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>If you want the flexibility of not blocking on the async operation before continuing the async generator body, then just don't yield the value yet.</p>\n</blockquote>\n<p>ü§î That doesn't really make sense.</p>\n","m.new_content":{"body":"> If you want the flexibility of not blocking on the async operation before continuing the async generator body, then just don't yield the value yet.\n\nü§î That doesn't really make sense.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>If you want the flexibility of not blocking on the async operation before continuing the async generator body, then just don't yield the value yet.</p>\n</blockquote>\n<p>ü§î That doesn't really make sense.</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$xD35IiQRuK53vxPy2qDkGcsaVIAm9_qz3hdYb_7-qH8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674711542637,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$fUrJLoGYraqiudOAEAbXIN9eumvPkgs_gOU-ex22HpU"},
{"content":{"body":"I wonder how difficult it would be to change to Option 2, which would allow easy parallel processing","msgtype":"m.text"},"ts":1674712516189,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$sWEdidVm0qqKEqnsGk_cWQiC_Nt7O3LuF33-indcUl0"},
{"content":{"body":"The only way to consume async iterables:\n- Callers of `.next()` will await (they already had to, we're returning promises)\n- for-await-of can be updated to await the inner value\n  - Also call `.return()` if rejection happens","format":"org.matrix.custom.html","formatted_body":"<p>The only way to consume async iterables:</p>\n<ul>\n<li>Callers of <code>.next()</code> will await (they already had to, we're returning promises)</li>\n<li>for-await-of can be updated to await the inner value\n<ul>\n<li>Also call <code>.return()</code> if rejection happens</li>\n</ul>\n</li>\n</ul>\n","msgtype":"m.text"},"ts":1674712720704,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$SUx87YwF9uLdcaijSo8KopKUJ4eAuASdRX4gaccgXTw"},
{"content":{"body":"Surprisingly, I don't think there'll be a web-compat risk.","msgtype":"m.text"},"ts":1674712754886,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$GekvcvKxLDGuKUutvoaXvo6Qfely2uSNj5ZtdxRaCqE"},
{"content":{"body":"The ways to consume an async iterator:\n- manual `.next()`\n- `yield*` (which only works inside another async iterable)\n- `for-await-of`","format":"org.matrix.custom.html","formatted_body":"<p>The ways to consume an async iterator:</p>\n<ul>\n<li>manual <code>.next()</code></li>\n<li><code>yield*</code> (which only works inside another async iterable)</li>\n<li><code>for-await-of</code></li>\n</ul>\n","msgtype":"m.text"},"ts":1674712925519,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ujOF7__VJY7h6YBKOb4f6zuYEZtb5gDqCG8WB2_iH-U"},
{"content":{"body":"I don't imagine manual `.next()` iteration is super common?","format":"org.matrix.custom.html","formatted_body":"I don't imagine manual <code>.next()</code> iteration is super common?","msgtype":"m.text"},"ts":1674712955389,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$xmpU2AAicF1Zn4oZSNDtBuxsMYVU3O2dib7nTuxhayc"},
{"content":{"body":"So the main way to consume an async iterable is to use `for-await-of`, which we can update to await the inner promise (and cleanup the iterator on rejections)","format":"org.matrix.custom.html","formatted_body":"So the main way to consume an async iterable is to use <code>for-await-of</code>, which we can update to await the inner promise (and cleanup the iterator on rejections)","msgtype":"m.text"},"ts":1674712991407,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$-Lj-o4K3ieZgteuh7JJuzZofpww2fpyG3cnL40H3yhI"},
{"content":{"body":"We can ignore `yield*`, because it's only available in other async iterators, because we still have an async iterator and that still needs to be consumed with `for-await-of`.","format":"org.matrix.custom.html","formatted_body":"We can ignore <code>yield*</code>, because it's only available in other async iterators, because we still have an async iterator and that still needs to be consumed with <code>for-await-of</code>.","msgtype":"m.text"},"ts":1674713047816,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$rbAeQARggyqxuIMG4AkbFyS1EVo4jflo1hyU86SG0-Q"},
{"content":{"body":"`.next()` iteration could be updated to await the inner value, but not block on that settlement","format":"org.matrix.custom.html","formatted_body":"<code>.next()</code> iteration could be updated to await the inner value, but not block on that settlement","msgtype":"m.text"},"ts":1674713219663,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$gpczNXn2onfbIJJgHy110vuVn7bFsJHWo1HRa6VJnoE"},
{"content":{"body":"Or maybe we need a `.nextRaw()` which won't unwrap the inner","format":"org.matrix.custom.html","formatted_body":"Or maybe we need a <code>.nextRaw()</code> which won't unwrap the inner","msgtype":"m.text"},"ts":1674713284401,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$jpgoCXECMOPFXoz6bnUuvkUypviUvOBClJSdXuhLZ_Q"},
{"content":{"body":"the main web-compat risk is that `(async function*(){ try { yield Promise.reject(1) } catch (e) { console.log('caught'); } })().next()` prints `caught`","format":"org.matrix.custom.html","formatted_body":"the main web-compat risk is that <code>(async function*(){ try { yield Promise.reject(1) } catch (e) { console.log('caught'); } })().next()</code> prints <code>caught</code>","msgtype":"m.text"},"ts":1674713357196,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$PBsyt3hpseM1oXqhZDWEfq4Z_kGjGwZQfyYgBdZEgY8"},
{"content":{"body":"i.e. yielding a rejected promise triggers `catch` handlers around the yield","format":"org.matrix.custom.html","formatted_body":"i.e. yielding a rejected promise triggers <code>catch</code> handlers around the yield","msgtype":"m.text"},"ts":1674713369466,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$PkCo4Tsue5zqbq3oT0qkTzt0FEhWkbYryAf5CqmwztY"},
{"content":{"body":"changing that would be fraught at this point","msgtype":"m.text"},"ts":1674713376243,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$SRZ_BLz08tq2BI9WDROrBmC6BwKdNn8Cybg6bKAMeRk"},
{"content":{"body":"A `.nextRaw()` then","format":"org.matrix.custom.html","formatted_body":"A <code>.nextRaw()</code> then","msgtype":"m.text"},"ts":1674713422345,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$duoY7N-FAv7N3yROKEd3ws38ZEElkcphjoWFhdHvKE4"},
{"content":{"body":"> <@bakkot:matrix.org> the main web-compat risk is that `(async function*(){ try { yield Promise.reject(1) } catch (e) { console.log('caught'); } })().next()` prints `caught`\n\nActually, how common is manual iteration?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq%3Amatrix.org/%24PBsyt3hpseM1oXqhZDWEfq4Z_kGjGwZQfyYgBdZEgY8\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>the main web-compat risk is that <code>(async function*(){ try { yield Promise.reject(1) } catch (e) { console.log('caught'); } })().next()</code> prints <code>caught</code></blockquote></mx-reply>Actually, how common is manual iteration?","m.relates_to":{"m.in_reply_to":{"event_id":"$PBsyt3hpseM1oXqhZDWEfq4Z_kGjGwZQfyYgBdZEgY8"}},"msgtype":"m.text"},"ts":1674713514527,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$6CCSMC8XmoBMymFyGVSgyh5Q1ZxKbSpE058QJy_8i38"},
{"content":{"body":"sorry, it's not the `.next` that's relevant here","format":"org.matrix.custom.html","formatted_body":"sorry, it's not the <code>.next</code> that's relevant here","msgtype":"m.text"},"ts":1674713607897,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$DWCbH0r_uxhfpPMFWUSiDLLW8NB2Xb0GQbsa_U-TtSg"},
{"content":{"body":"you'd get the same `caught` in a `for-await-of`","format":"org.matrix.custom.html","formatted_body":"you'd get the same <code>caught</code> in a <code>for-await-of</code>","msgtype":"m.text"},"ts":1674713615723,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$kdw2AqZE3msCSck-ijVm6HcBsRIXSV-hSOuqrSzlrsQ"},
{"content":{"body":"the relevant bit is that the catch handler _inside the async generator_ gets triggered","format":"org.matrix.custom.html","formatted_body":"the relevant bit is that the catch handler <em>inside the async generator</em> gets triggered","msgtype":"m.text"},"ts":1674713629236,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$1YEfsughRzm3QLFo0EiB-s-sZeYvLdqlXqVtPQF4L_w"},
{"content":{"body":"no idea how common manual iteration is though. my guess would be not especially but there's definitely times you want it, e.g. for queues and stuff","msgtype":"m.text"},"ts":1674713679675,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$hZjbOl0ggXBKI1X-xF3qL73_FaWTRxgLkigDZk9jsx0"},
{"content":{"body":"> you'd get the same caught in a for-await-of\n> the relevant bit is that the catch handler inside the async generator gets triggered\n\nI would phrase this as \"`.next()` will call `.error()` if promise rejects\"","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>you'd get the same caught in a for-await-of<br>the relevant bit is that the catch handler inside the async generator gets triggered</p>\n</blockquote>\n<p>I would phrase this as &quot;<code>.next()</code> will call <code>.error()</code> if promise rejects&quot;</p>\n","msgtype":"m.text"},"ts":1674715042883,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$AuZdnCgNExdOgvIv0e_-bAqEtpSy_9QgvUaKdE2bygc"},
{"content":{"body":" * > you'd get the same caught in a for-await-of\n> the relevant bit is that the catch handler inside the async generator gets triggered\n\nI would phrase this as \"`.next()` will call `.error()` if promise rejects\"","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>you'd get the same caught in a for-await-of<br>the relevant bit is that the catch handler inside the async generator gets triggered</p>\n</blockquote>\n<p>I would phrase this as &quot;<code>.next()</code> will call <code>.error()</code> if promise rejects&quot;</p>\n","m.new_content":{"body":"> you'd get the same caught in a for-await-of\n> the relevant bit is that the catch handler inside the async generator gets triggered\n\nI would phrase this as \"`.next()` will call `.error()` if promise rejects\"","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>you'd get the same caught in a for-await-of<br>the relevant bit is that the catch handler inside the async generator gets triggered</p>\n</blockquote>\n<p>I would phrase this as &quot;<code>.next()</code> will call <code>.error()</code> if promise rejects&quot;</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$AuZdnCgNExdOgvIv0e_-bAqEtpSy_9QgvUaKdE2bygc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674715050801,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$exJYg2DIVTJHR11DX7GeHB4diitt1N9hg3uKOwNmLPw"},
{"content":{"body":"Eg, the slides say:\n\n```javascript\n// Given:\nAsyncIterator.prototype = {\n  async next(v) {\n    return { value: await resumeWithValue(v), done }\n  }\n\n  async error(e) {\n    return { value: await resumeWithError(e), done }\n  }\n}\n\n// Input\nasync function* foo() {\n    try {\n        yield Promise.reject(1);\n    } finally {\n        console.log(2);\n    }\n}\n\n// Output\nasync function* foo() {\n    try {\n        yield await Promise.reject(1);\n    } finally {\n        console.log(2);\n    }\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>Eg, the slides say:</p>\n<pre><code class=\"language-javascript\">// Given:\nAsyncIterator.prototype = {\n  async next(v) {\n    return { value: await resumeWithValue(v), done }\n  }\n\n  async error(e) {\n    return { value: await resumeWithError(e), done }\n  }\n}\n\n// Input\nasync function* foo() {\n    try {\n        yield Promise.reject(1);\n    } finally {\n        console.log(2);\n    }\n}\n\n// Output\nasync function* foo() {\n    try {\n        yield await Promise.reject(1);\n    } finally {\n        console.log(2);\n    }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1674715229586,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$-Egvl6J4FepqJTPD1NmxkWBZIfRSFHbvRkjpRhz3teA"},
{"content":{"body":"I think we could unobservably change that to:","msgtype":"m.text"},"ts":1674715267876,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$kenmoon-om4M2PDUchA8CpVgE2SMFGTGEPLt38DP4zY"},
{"content":{"body":"```javascript\n// Given:\nAsyncIterator.prototype = {\n  async next(v) {\n    try {\n      return { value: await resumeWithValue(v), done }\n    } catch (e) {\n      return { value: await resumeWithError(e), done }\n    }\n  }\n\n  async error(e) {\n    return { value: await resumeWithError(e), done }\n  }\n}\n\n// Input\nasync function* foo() {\n    try {\n        yield Promise.reject(1);\n    } finally {\n        console.log(2);\n    }\n}\n\n// Output has no change\n```\n","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-javascript\">// Given:\nAsyncIterator.prototype = {\n  async next(v) {\n    try {\n      return { value: await resumeWithValue(v), done }\n    } catch (e) {\n      return { value: await resumeWithError(e), done }\n    }\n  }\n\n  async error(e) {\n    return { value: await resumeWithError(e), done }\n  }\n}\n\n// Input\nasync function* foo() {\n    try {\n        yield Promise.reject(1);\n    } finally {\n        console.log(2);\n    }\n}\n\n// Output has no change\n</code></pre>\n","msgtype":"m.text"},"ts":1674715332572,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$E5YDHfdkbwNxwvhehkkXhhuJw8raux3ZPMNqHcaqznM"},
{"content":{"body":"And if we can do that, why can't we do:\n```javascript\n// Given:\nAsyncIterator.prototype = {\n  async next(v) {\n    try {\n      return { value: await this.nextRaw(v).value, done }\n    } catch (e) {\n      return { value: await resumeWithError(e), done }\n    }\n  }\n\n  async nextRaw(v) {\n    return { value: resumeWithValue(v), done }\n  }\n\n  async error(e) {\n    return { value: await resumeWithError(e), done }\n  }\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>And if we can do that, why can't we do:</p>\n<pre><code class=\"language-javascript\">// Given:\nAsyncIterator.prototype = {\n  async next(v) {\n    try {\n      return { value: await this.nextRaw(v).value, done }\n    } catch (e) {\n      return { value: await resumeWithError(e), done }\n    }\n  }\n\n  async nextRaw(v) {\n    return { value: resumeWithValue(v), done }\n  }\n\n  async error(e) {\n    return { value: await resumeWithError(e), done }\n  }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1674715437657,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$M3jG8sYKhV8-sNwbyBQFwyDJFW4NGNG1I3ShHWaXl7g"}
]