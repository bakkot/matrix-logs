[
{"content":{"body":"Unfortunately that doesn't work, async generator functions will not reenter until all previous next calls settle","msgtype":"m.text"},"ts":1674691303471,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$A4arr1CWXLkluHrLRlPNr2mqyxkYnU8xl3Fs6D_AoI0"},
{"content":{"body":"```\nasync function* foo() {\n    yield new Promise(r => setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo() {\n    yield new Promise(r =&gt; setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n</code></pre>\n","msgtype":"m.text"},"ts":1674691484502,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$3kBzkL4ueXA78bdWCbdL9iPnJv8nbxaIw3XI22w59dM"},
{"content":{"body":"the previous call settles in my example","msgtype":"m.text"},"ts":1674691503789,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$iEoDGY1F6odBkj1RItXwwPq92moUah-BF-Xrt_JI_oA"},
{"content":{"body":"The `reenter` won't log until the 1000ms is up","format":"org.matrix.custom.html","formatted_body":"The <code>reenter</code> won't log until the 1000ms is up","msgtype":"m.text"},"ts":1674691509382,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$dqHfVRhQxw0lp8KpNxo2ul2P2oTfyyY0kHiyfnYBcl4"},
{"content":{"body":"yes but it doesn't need to","msgtype":"m.text"},"ts":1674691515751,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$mILfoDp7XPLE1guHT7-5JOfsTf3A5L4W3H6p5NJhCmE"},
{"content":{"body":"my example still works","msgtype":"m.text"},"ts":1674691517245,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$OvRIbhmk58CVRO4IZTIcBZGtYD2k_pegNeahVZGJpVc"},
{"content":{"body":"```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","msgtype":"m.text"},"ts":1674691567096,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cU0qjlMUdi2PGGFeG8gMm_1SR9OIJrabX2ReejzO4Hw"},
{"content":{"body":" * ```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":" * <pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","m.new_content":{"body":"```\nasync function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x => fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){ yield 0; await sleep(1000); yield 1; }\nlet it = foo().map(x =&gt; fetch(x));\nit.next();\n// almost immediately after this point, the promise returned from the first call to the underlying foo()'s `.next` settles\n// then the first call to `fetch` starts\nit.next() // so this can almost immediately kick off another call to the underlying foo()'s `next`, and have that actually hit the `sleep`\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$cU0qjlMUdi2PGGFeG8gMm_1SR9OIJrabX2ReejzO4Hw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674691596282,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BQJPkZZqxkxL-JAIvEQh6RmBV9aVbpnR6hUJ7V9Epdc"},
{"content":{"body":"```\nasync function* foo(){\n    yield 0;\n    console.log('reenter');\n    await sleep(1000);\n    yield 1;\n}\nlet it = foo();\nit.next();\nit.next();\nconsole.log('end');\n```\nLogs `end` then `reenter`, the first yield doesn't settle the iterator until after a tick","format":"org.matrix.custom.html","formatted_body":"<pre><code>async function* foo(){\n    yield 0;\n    console.log('reenter');\n    await sleep(1000);\n    yield 1;\n}\nlet it = foo();\nit.next();\nit.next();\nconsole.log('end');\n</code></pre>\n<p>Logs <code>end</code> then <code>reenter</code>, the first yield doesn't settle the iterator until after a tick</p>\n","msgtype":"m.text"},"ts":1674691737731,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$oV3V5N9UReXjWvCFDaep2GXvxec3HaiXPPFNEcrjQcE"},
{"content":{"body":"I think you're incorrect, and even if you're correct, you're example will start to fail again as soon as you chain your iterators with async functionality","msgtype":"m.text"},"ts":1674691750644,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$N7_rkNp3B5upiyKickJziBjCuNpL1DSxosUn1s7Lg-A"},
{"content":{"body":"```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","msgtype":"m.text"},"ts":1674691790751,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5VUt2EWmI3-JEthgqzK1S15gtCGCwU78j0q3myea6kc"},
{"content":{"body":" * ```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":" * <pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","m.new_content":{"body":"```\nlet it = foo()\n  .map(x => fetch(x))\n  .map(r => r.json());\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>let it = foo()\n  .map(x =&gt; fetch(x))\n  .map(r =&gt; r.json());\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$5VUt2EWmI3-JEthgqzK1S15gtCGCwU78j0q3myea6kc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674691796548,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$wh-ksmd6U5jFS0jlMdKJ7MoGPVrv21WZe_35kRwObwE"},
{"content":{"body":"not with the definition of `map` in the slides","format":"org.matrix.custom.html","formatted_body":"not with the definition of <code>map</code> in the slides","msgtype":"m.text"},"ts":1674691800077,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$HDY--qTDmPLpHoQ05A9eGIPng6zqx7dondy9nG9DVDs"},
{"content":{"body":"I am pretty sure","msgtype":"m.text"},"ts":1674691811953,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$znQ6fURgJoVzO3SefHD8gyF93jgLZR3JDoiFFWQW4SY"},
{"content":{"body":"but I will check after work and get back to you","msgtype":"m.text"},"ts":1674691817475,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$AI5fjgL-jPMbrYNCqGIma_80n55fKfrWQOTa9BOmz2U"},
{"content":{"body":"(couple hours probably)","msgtype":"m.text"},"ts":1674691822712,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$P9_UxKM1gVmq60Udqfi-ymE3aBUH1vwFwVeoqS3h1ik"},
{"content":{"body":"It depends on how the source iterator performs parallelization","msgtype":"m.text"},"ts":1674691942837,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$O_R2trB2r0z-Pjj7ehYEepQK9nrtrPAqRGm3CR_ooVk"},
{"content":{"body":"pretty sure it does not","msgtype":"m.text"},"ts":1674692059640,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ISrcvWBmtPSNPQqlno3VGYypPg-2XfXjYZRNt1YBaG8"},
{"content":{"body":"Oh you're right, the second `.map` will work in parallel with the first `.map`","format":"org.matrix.custom.html","formatted_body":"Oh you're right, the second <code>.map</code> will work in parallel with the first <code>.map</code>","msgtype":"m.text"},"ts":1674692133748,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$jHeBq2CLg3LBuBl7o412GiA9ehlV_wDNO3d5-G4Q9J8"},
{"content":{"body":"I'm recalling when I was writing `map` as an async-gen function itself, which means I was still hitting backpressure","format":"org.matrix.custom.html","formatted_body":"I'm recalling when I was writing <code>map</code> as an async-gen function itself, which means I was still hitting backpressure","msgtype":"m.text"},"ts":1674692163380,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$JqG5Qh24pBdG60c5LFffd7JmvfrrdncbdPKcigvdUno"},
{"content":{"body":"So only the first iterator chained off a back-pressure iterator will be serial","msgtype":"m.text"},"ts":1674692187843,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Q6USiX0anInzOTVv8WSLTl14S6xI988glZe2AThxxNo"},
{"content":{"body":"We still hit the reentrancy issue with an async-gen function, which would be neat to ~solve~change","msgtype":"m.text"},"ts":1674692229533,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$2tn2D7oHLiUEzKkfhIZdcHIYBEpI9PqEDhm-H9MSgdI"},
{"content":{"body":" * We still hit the reentrancy issue with an async-gen function, which would be neat to ~solve~change","m.new_content":{"body":"We still hit the reentrancy issue with an async-gen function, which would be neat to ~solve~change","msgtype":"m.text"},"m.relates_to":{"event_id":"$2tn2D7oHLiUEzKkfhIZdcHIYBEpI9PqEDhm-H9MSgdI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674692242816,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$OhUxtlK6s1bOFDZSown3kE3s7jnnBJCdfkD65d1xxcc"},
{"content":{"body":"Justin Ridgewell: yeah, and that's the problem with the current spec too: the async iterator helpers are implemented as async generators","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a>: yeah, and that's the problem with the current spec too: the async iterator helpers are implemented as async generators","msgtype":"m.text"},"ts":1674702261186,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$JLUIIfB_BiY9uzG7Spk5Aq69P-VXXr9SYCpimWxzW1E"},
{"content":{"body":"here's code you can run today which demonstrates that the mapper from the slides can be parallel, both from with itself and with the underlying generator https://gist.github.com/bakkot/a338838aee667517adb03edfa83aaed1","msgtype":"m.text"},"ts":1674702293904,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$a_GkbfHkvW2xI7VNWDx7niIPvmvCHiJp4hJNOvviq0U"},
{"content":{"body":"and indeed the original generator can't be parallel with itself. I don't think there's anything we can do about that, though - the whole point of generators is that they're written as straight-line code, and you can't start executing the next line until the previous one finishes","msgtype":"m.text"},"ts":1674702419767,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$s__nz81SENhRZSfwGsrzj6AR-f6WLQIRjPD8ZTq647Y"},
{"content":{"body":" * here's code you can run today which demonstrates that the mapper from the slides can be parallel, both with itself and with the underlying generator https://gist.github.com/bakkot/a338838aee667517adb03edfa83aaed1","m.new_content":{"body":"here's code you can run today which demonstrates that the mapper from the slides can be parallel, both with itself and with the underlying generator https://gist.github.com/bakkot/a338838aee667517adb03edfa83aaed1","msgtype":"m.text"},"m.relates_to":{"event_id":"$a_GkbfHkvW2xI7VNWDx7niIPvmvCHiJp4hJNOvviq0U","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674702429144,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$nRvo1MM0R65vuyhtXtTqakgNzlpV45q-coxNDhqyc1g"},
{"content":{"body":"I think interleaving of async map iterators is expected behavior.","msgtype":"m.text"},"ts":1674702554701,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$4exb4DMcRA0WFBWfTMmJ94YvrE05UcTwgxhI0ofGFbU"},
{"content":{"body":"Kris Kowal: what do you mean by interleaving?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a>: what do you mean by interleaving?","msgtype":"m.text"},"ts":1674702584965,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$kuSPpOpDuhDW4C1l97Ne6HbgF4OcTFWE8fXHKG5LJJA"},
{"content":{"body":"just that you can be executing the mapper function in parallel with itself?","msgtype":"m.text"},"ts":1674702604714,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$PxLa03_VSEzkc1pyjSENRMvCVoXDy4CMw_irqefEpek"},
{"content":{"body":"(assuming the resulting mapped thing is pumped multiple times)","msgtype":"m.text"},"ts":1674702620871,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$eKHE5VyjmHNuyYrsXZnwu-_OWGXnK6IUsFMdGaLdI58"},
{"content":{"body":"That effect for one, yes.","msgtype":"m.text"},"ts":1674702648456,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$zD2Rdoc9Yz3yv6Kb7SG4pwBfyT3FxtzpVsFewXcqQ3w"},
{"content":{"body":"> <@bakkot:matrix.org> and indeed the original generator can't be parallel with itself. I don't think there's anything we can do about that, though - the whole point of generators is that they're written as straight-line code, and you can't start executing the next line until the previous one finishes\n\nIt's not just the running of the generators code, but the settlement of the `next()` promise external from the genrator that blocks","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$s__nz81SENhRZSfwGsrzj6AR-f6WLQIRjPD8ZTq647Y?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>and indeed the original generator can&#39;t be parallel with itself. I don&#39;t think there&#39;s anything we can do about that, though - the whole point of generators is that they&#39;re written as straight-line code, and you can&#39;t start executing the next line until the previous one finishes</blockquote></mx-reply>It's not just the running of the generators code, but the settlement of the <code>next()</code> promise external from the genrator that blocks","m.relates_to":{"m.in_reply_to":{"event_id":"$s__nz81SENhRZSfwGsrzj6AR-f6WLQIRjPD8ZTq647Y"}},"msgtype":"m.text"},"ts":1674702705720,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$4wVHyh7uA3dEcCReAej_jitjjprSYVh_HUKSCOgqJGA"},
{"content":{"body":"But also map(xf).map(yf) would interleave turns of xf and yf.","msgtype":"m.text"},"ts":1674702713181,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$InTaox0U-Lsn5irK4JcbDreeqidDgUku8aPI0oCbMr4"},
{"content":{"body":"Eg, I want to be able to return a `yield fetch()` and reenter without that fetch having settled","format":"org.matrix.custom.html","formatted_body":"Eg, I want to be able to return a <code>yield fetch()</code> and reenter without that fetch having settled","msgtype":"m.text"},"ts":1674702730343,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$f6nLzGPhFP4HX64b9xHGZZ6heXtNpsj3FnEPDC5GDms"},
{"content":{"body":"> <@jridgewell:matrix.org> It's not just the running of the generators code, but the settlement of the `next()` promise external from the genrator that blocks\n\nIn the case that you specifically yield a promise, do you mean, or is there another case I'm not thinking of?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$4wVHyh7uA3dEcCReAej_jitjjprSYVh_HUKSCOgqJGA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>It's not just the running of the generators code, but the settlement of the <code>next()</code> promise external from the genrator that blocks</blockquote></mx-reply>In the case that you specifically yield a promise, do you mean, or is there another case I'm not thinking of?","m.relates_to":{"m.in_reply_to":{"event_id":"$4wVHyh7uA3dEcCReAej_jitjjprSYVh_HUKSCOgqJGA"}},"msgtype":"m.text"},"ts":1674702738984,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$CiDw7BofSnA778P0Go802vTp22PAhiioVFrDjm1h96w"},
{"content":{"body":"ah yeah","msgtype":"m.text"},"ts":1674702740040,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$qv8Y9q0a5Y6G7t9EmkltZHbpP_WiMf6is6Zv8CzF46o"},
{"content":{"body":"with this helper, you could do `yield { v: fetch() }` in your async generator and then `.map(box => box.v)` to get parallelism in the resulting thing (or rather the ability to be parallel assuming someone calls `.next` eagerly)","format":"org.matrix.custom.html","formatted_body":"with this helper, you could do <code>yield { v: fetch() }</code> in your async generator and then <code>.map(box =&gt; box.v)</code> to get parallelism in the resulting thing (or rather the ability to be parallel assuming someone calls <code>.next</code> eagerly)","msgtype":"m.text"},"ts":1674702762329,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$p5GSh8cqP2AgM_dMkK-grd_IuXhu-sneK5vtkX-99ro"},
{"content":{"body":"a little silly but works fine","msgtype":"m.text"},"ts":1674702775076,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$4wGOv2nu_3PsQDNwH99UBx0tVmU-Rb9WDKmahrbFwKY"},
{"content":{"body":"... I think","msgtype":"m.text"},"ts":1674702776665,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$uHt_5BFgNh7ipdjOhZQnimMk4eJtZzlcELF4I95spNo"},
{"content":{"body":"> <@kriskowal:matrix.org> But also map(xf).map(yf) would interleave turns of xf and yf.\n\nRight, yeah. You get that with my proposed tweak also (again assuming someone calls `.next()` eagerly)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$InTaox0U-Lsn5irK4JcbDreeqidDgUku8aPI0oCbMr4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>But also map(xf).map(yf) would interleave turns of xf and yf.</blockquote></mx-reply>Right, yeah. You get that with my proposed tweak also (again assuming someone calls <code>.next()</code> eagerly)","m.relates_to":{"m.in_reply_to":{"event_id":"$InTaox0U-Lsn5irK4JcbDreeqidDgUku8aPI0oCbMr4"}},"msgtype":"m.text"},"ts":1674702835379,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$twPq3tMXk4hKzVKIqgJzvIj2cq8aKt-CZUsOcAf1kKI"},
{"content":{"body":"> <@jridgewell:matrix.org> Eg, I want to be able to return a `yield fetch()` and reenter without that fetch having settled\n\nI don’t have spare attention to dig, but I would find it very surprising if `yield fetch()` were equivalent to `yield await fetch()`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$f6nLzGPhFP4HX64b9xHGZZ6heXtNpsj3FnEPDC5GDms?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Eg, I want to be able to return a <code>yield fetch()</code> and reenter without that fetch having settled</blockquote></mx-reply>I don’t have spare attention to dig, but I would find it very surprising if <code>yield fetch()</code> were equivalent to <code>yield await fetch()</code>.","m.relates_to":{"m.in_reply_to":{"event_id":"$f6nLzGPhFP4HX64b9xHGZZ6heXtNpsj3FnEPDC5GDms"}},"msgtype":"m.text"},"ts":1674702849163,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$QQUbSQ-PxGjotkLj4JxYl9qhNkAccwOck6XrqjVmUCM"},
{"content":{"body":"They are, unfortunately","msgtype":"m.text"},"ts":1674702954671,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$oxH70IrA_mOLgUWjtkGICRdiCG7hG02crVVndppheaI"},
{"content":{"body":"> ```\n> async function* foo() {\n>     yield new Promise(r => setTimeout(r, 1000));\n>     console.log('reenter');\n> }\n> const it = foo();\n> it.next();\n> it.next();\n> ```\n\n","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<pre><code>async function* foo() {\n    yield new Promise(r =&gt; setTimeout(r, 1000));\n    console.log('reenter');\n}\nconst it = foo();\nit.next();\nit.next();\n</code></pre>\n</blockquote>\n","msgtype":"m.text"},"ts":1674702965390,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$9xRIUVpF8QahQJTrfovDx697lPp3rfKrvNcMpgb0UTU"},
{"content":{"body":"^ That waits a full second before logging `reenter`","format":"org.matrix.custom.html","formatted_body":"^ That waits a full second before logging <code>reenter</code>","msgtype":"m.text"},"ts":1674702982021,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$mLAX-7xZCFBPU557HBkbgNJ8tHHlVvs_mYVJgRJEQKw"},
{"content":{"body":"My original map helper was something like `for await (const x of source) yield mapper(x)`, and if `mapper` has any async waiting, it blocks.","format":"org.matrix.custom.html","formatted_body":"My original map helper was something like <code>for await (const x of source) yield mapper(x)</code>, and if <code>mapper</code> has any async waiting, it blocks.","msgtype":"m.text"},"ts":1674703078898,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$0hP-XRE6cgXXbY0lEfz4u9isLzcCktCJxYc1IJXQxZo"},
{"content":{"body":"here's the slides where we decided that `yield` is `yield await` https://docs.google.com/presentation/d/1U6PivKbFO0YgoFlrYB82MtXf1ofCp1xSVOODOvranBM/edit#slide=id.g223fba4116_0_196","format":"org.matrix.custom.html","formatted_body":"here's the slides where we decided that <code>yield</code> is <code>yield await</code> https://docs.google.com/presentation/d/1U6PivKbFO0YgoFlrYB82MtXf1ofCp1xSVOODOvranBM/edit#slide=id.g223fba4116_0_196","msgtype":"m.text"},"ts":1674703093173,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$eakQm0oKmul30T6ktW2ItI-w6R1S4DI-vNEDuFTTazk"},
{"content":{"body":"and notes https://github.com/tc39/notes/blob/55af84ac0ed7a250206849dddd628b2c1db2c9b1/meetings/2017-05/may-25.md#15iva-revisiting-async-generator-yield-behavior","msgtype":"m.text"},"ts":1674703140793,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$FI03dpeM0Cu5VFvzZ6F51aVV3M7KFBhaEISgcsL1AJg"},
{"content":{"body":"😦 Before my time","msgtype":"m.text"},"ts":1674703170027,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Y9LF6f_wXpih0ScePtGuRI6resd9GYQxQYox2q2WpkE"},
{"content":{"body":"Ah, surprising but maybe for the best. In any case, “overdriving” (drawing concurrent promises from next()) a pipeline of async maps to get parallelism is useful, so glad that’ll work regardless.","msgtype":"m.text"},"ts":1674707946481,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$B4LsP1mtg-RYhRWpkXnIxU3CSQ1gmV5iVAwdphC0lak"},
{"content":{"body":"In fact, the implicit `await` is doing me a big favor in:\n```\nfunction parallel(limit, process) {\n  function *workers() {\n    for (const worker of count(limit)) {\n      yield process(worker);\n    }\n  }\n  return Promise.all(workers());\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>In fact, the implicit <code>await</code> is doing me a big favor in:</p>\n<pre><code>function parallel(limit, process) {\n  function *workers() {\n    for (const worker of count(limit)) {\n      yield process(worker);\n    }\n  }\n  return Promise.all(workers());\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1674708022465,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$tg0kHPSEAX5_0wDB33ecOtV7Ya3_Xv6LNbmX11hK5wI"},
{"content":{"body":"Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nAsyncIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":"<p>Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>AsyncIterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","msgtype":"m.text"},"ts":1674708267270,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$-RalYnmbKTFUKx2cRYrvCOLbbCaH4T-yT91I9MI88oc"},
{"content":{"body":" * Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>Iterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","m.new_content":{"body":"Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":"<p>Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>Iterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$-RalYnmbKTFUKx2cRYrvCOLbbCaH4T-yT91I9MI88oc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674708284216,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$_Dmw8AUATQIHI4CTBSJa0akos5J3RJ98Dx7osY5u9R8"},
{"content":{"body":" * Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nAsyncIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>AsyncIterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","m.new_content":{"body":"Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)\n\n```\nAsyncIterator.prototype.parallelForEach = async (limit, values, process) =>\n  parallel(limit, () => AsyncIterator.from(values).forEach(process));\n```","format":"org.matrix.custom.html","formatted_body":"<p>Out of which you can build bounded concurrency pretty easily (I’m taking the liberty of assuming the existence of AsyncIterator.from having not followed along particularly closely)</p>\n<pre><code>AsyncIterator.prototype.parallelForEach = async (limit, values, process) =&gt;\n  parallel(limit, () =&gt; AsyncIterator.from(values).forEach(process));\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$-RalYnmbKTFUKx2cRYrvCOLbbCaH4T-yT91I9MI88oc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674708296858,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$FSenBI3goCj2oulWwp2CwH_vkLlLvUcU_9ek4B4QRn0"}
]