[
{"content":{"body":"Regarding this, I think I figured out another place where `%TypedArray%.prototype.sort` implicitly relies on canonicalisation: if I'm not badly mistaken, the CompareTypedArrayElements AO is designed to invoke the \"usual\" total ordering for floats (convert to uint64, compare by value), but with the assumption that all NaNs are the usual canonical positive NaNs. If the sentence about canonicalisation is dropped, then the sorting algorithm is no longer the usual total ordering but instead something more custom with presumably a branch for NaNs needed.","format":"org.matrix.custom.html","formatted_body":"Regarding this, I think I figured out another place where <code>%TypedArray%.prototype.sort</code> implicitly relies on canonicalisation: if I'm not badly mistaken, the CompareTypedArrayElements AO is designed to invoke the \"usual\" total ordering for floats (convert to uint64, compare by value), but with the assumption that all NaNs are the usual canonical positive NaNs. If the sentence about canonicalisation is dropped, then the sorting algorithm is no longer the usual total ordering but instead something more custom with presumably a branch for NaNs needed.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$8SjEr6tEthHgcQxwLoFnnXn-MzfAyOEYnMmH7HMMqNg"}},"msgtype":"m.text"},"ts":1744912514626,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$YBe_cqQlvEIDiHp2AgAazY5QuzNTR3Eu5jgE9Bx6q0E"},
{"content":{"body":"there's \"one\" NaN value at the JS level, but then when you write it to a TypedArray, it gets the chance to choose a new value. so the de-canonicalization is happening after the code you're talking about.","m.mentions":{},"msgtype":"m.text"},"ts":1744912765856,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$OITRxXJlLJaOiYjzHegrutEdHsTYY-1K2dlO7y2mHyo"},
{"content":{"body":"the spec is pretty editorially confusing, and we should make that point more clear","m.mentions":{},"msgtype":"m.text"},"ts":1744912799503,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$AhZFT6qNzTHbqH62aVYdPnW7dNar94koQWrhRJJgMKE"},
{"content":{"body":"```js\nconst b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\na[3] = 1;\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() => Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">const b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\na[3] = 1;\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() =&gt; Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1744912818278,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$UgF0uOUuPqzaCU0SOkw1e8_8znJEExU7K5Xs67bI324"},
{"content":{"body":"* ```js\nconst b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() => Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n```","format":"org.matrix.custom.html","formatted_body":"* <pre><code class=\"language-js\">const b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() =&gt; Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"```js\nconst b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() => Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">const b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() =&gt; Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$UgF0uOUuPqzaCU0SOkw1e8_8znJEExU7K5Xs67bI324","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1744912827535,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$S8hVfBa5PUwc-UksdGsAdmgFQwlU8hVipnh9fO0uIlk"},
{"content":{"body":"https://tc39.es/ecma262/#sec-comparetypedarrayelements has special casing for NaN, doesn't compare by bit pattern","m.mentions":{},"msgtype":"m.text"},"ts":1744912865037,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$pUI3CdzsnxMnfldMju8ogu7vCWx3zQtbsAuzYYOoffg"},
{"content":{"body":"would more NOTEs help here? i agree the raw bits <> number machinery for TAs can be confusing but i'm not sure how to improve on it atm","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$AhZFT6qNzTHbqH62aVYdPnW7dNar94koQWrhRJJgMKE"}},"msgtype":"m.text"},"ts":1744912935720,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$uer1MraNB49FB7ackDHESQ4RyIs5DfLPS6HR-SopJ8E"},
{"content":{"body":"If you create a Float64Array containing NaNs without ever assigning NaNs into it, you can get to a path where the `sort()` call would be the first place where the NaNs would actually be \"observed\", and it seems like the CompareTypedArrayElements is designed for engines to be able to use bit pattern comparison as an optimisation there. But that then falls apart if NaN canonicalisation isn't actually done/allowed by the spec.","format":"org.matrix.custom.html","formatted_body":"If you create a Float64Array containing NaNs without ever assigning NaNs into it, you can get to a path where the <code>sort()</code> call would be the first place where the NaNs would actually be \"observed\", and it seems like the CompareTypedArrayElements is designed for engines to be able to use bit pattern comparison as an optimisation there. But that then falls apart if NaN canonicalisation isn't actually done/allowed by the spec.","m.mentions":{},"msgtype":"m.text"},"ts":1744912955731,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$72IE8voQvIhAEDvYED6LWU-qGrm16x1dEytLQi1ZSnY"},
{"content":{"body":"Yeah, it only reads like it was written to be compare-by-bit-pattern-but-we-know-all-nans-are-positive.","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$pUI3CdzsnxMnfldMju8ogu7vCWx3zQtbsAuzYYOoffg"}},"msgtype":"m.text"},"ts":1744912991527,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$BaE0_lVGKj2bJ0JU9LS9yRUXDwQ1O-Zm6QdCwpliKXk"},
{"content":{"body":"\"it seems like the CompareTypedArrayElements is designed for engines to be able to use bit pattern comparison as an optimisation there\" where do you get that sense from?","m.mentions":{},"msgtype":"m.text"},"ts":1744913007613,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$_ZCvcjsDl5pJT6KFfB93-NQLS2ProToQWBCqF-abDE4"},
{"content":{"body":"From the fact that it is entirely equivalent (from my understanding and somewhat limited testing) to a comparison by bit pattern if one makes the assumption that all NaNs are canonicalised or at least positive.","m.mentions":{},"msgtype":"m.text"},"ts":1744913100350,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$GyzGR7TIJg9V6HXGmyCuMdVK2C0xRl0cbLCN_Qnd9Qw"},
{"content":{"body":"that last bit is pretty important though. you can't make that assumption","m.mentions":{},"msgtype":"m.text"},"ts":1744913117503,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$G-YkoQn51NmSK1PZo-8zNMX-f2-hxvhYbXmCO3LepmU"}
]