[
{"content":{"body":"Regarding this, I think I figured out another place where `%TypedArray%.prototype.sort` implicitly relies on canonicalisation: if I'm not badly mistaken, the CompareTypedArrayElements AO is designed to invoke the \"usual\" total ordering for floats (convert to uint64, compare by value), but with the assumption that all NaNs are the usual canonical positive NaNs. If the sentence about canonicalisation is dropped, then the sorting algorithm is no longer the usual total ordering but instead something more custom with presumably a branch for NaNs needed.","format":"org.matrix.custom.html","formatted_body":"Regarding this, I think I figured out another place where <code>%TypedArray%.prototype.sort</code> implicitly relies on canonicalisation: if I'm not badly mistaken, the CompareTypedArrayElements AO is designed to invoke the \"usual\" total ordering for floats (convert to uint64, compare by value), but with the assumption that all NaNs are the usual canonical positive NaNs. If the sentence about canonicalisation is dropped, then the sorting algorithm is no longer the usual total ordering but instead something more custom with presumably a branch for NaNs needed.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$8SjEr6tEthHgcQxwLoFnnXn-MzfAyOEYnMmH7HMMqNg"}},"msgtype":"m.text"},"ts":1744912514626,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$YBe_cqQlvEIDiHp2AgAazY5QuzNTR3Eu5jgE9Bx6q0E"},
{"content":{"body":"there's \"one\" NaN value at the JS level, but then when you write it to a TypedArray, it gets the chance to choose a new value. so the de-canonicalization is happening after the code you're talking about.","m.mentions":{},"msgtype":"m.text"},"ts":1744912765856,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$OITRxXJlLJaOiYjzHegrutEdHsTYY-1K2dlO7y2mHyo"},
{"content":{"body":"the spec is pretty editorially confusing, and we should make that point more clear","m.mentions":{},"msgtype":"m.text"},"ts":1744912799503,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$AhZFT6qNzTHbqH62aVYdPnW7dNar94koQWrhRJJgMKE"},
{"content":{"body":"```js\nconst b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\na[3] = 1;\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() => Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">const b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\na[3] = 1;\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() =&gt; Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1744912818278,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$UgF0uOUuPqzaCU0SOkw1e8_8znJEExU7K5Xs67bI324"},
{"content":{"body":"* ```js\nconst b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() => Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n```","format":"org.matrix.custom.html","formatted_body":"* <pre><code class=\"language-js\">const b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() =&gt; Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"```js\nconst b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() => Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">const b = BigInt64Array.of(-2251795519242240n, -4616189618054758400n, 0n, 4607182418800017408n, 9221120237041090774n);\nconst a = new Float64Array(b.buffer);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort();\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\na.sort(() =&gt; Math.random() ? -1 : 1);\nconsole.log(`${b[0]} ${b[1]} ${b[2]} ${b[3]} ${b[4]}`);\nconsole.log(`${a[0]} ${a[1]} ${a[2]} ${a[3]} ${a[4]}`);\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$UgF0uOUuPqzaCU0SOkw1e8_8znJEExU7K5Xs67bI324","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1744912827535,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$S8hVfBa5PUwc-UksdGsAdmgFQwlU8hVipnh9fO0uIlk"},
{"content":{"body":"https://tc39.es/ecma262/#sec-comparetypedarrayelements has special casing for NaN, doesn't compare by bit pattern","m.mentions":{},"msgtype":"m.text"},"ts":1744912865037,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$pUI3CdzsnxMnfldMju8ogu7vCWx3zQtbsAuzYYOoffg"},
{"content":{"body":"would more NOTEs help here? i agree the raw bits <> number machinery for TAs can be confusing but i'm not sure how to improve on it atm","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$AhZFT6qNzTHbqH62aVYdPnW7dNar94koQWrhRJJgMKE"}},"msgtype":"m.text"},"ts":1744912935720,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$uer1MraNB49FB7ackDHESQ4RyIs5DfLPS6HR-SopJ8E"},
{"content":{"body":"If you create a Float64Array containing NaNs without ever assigning NaNs into it, you can get to a path where the `sort()` call would be the first place where the NaNs would actually be \"observed\", and it seems like the CompareTypedArrayElements is designed for engines to be able to use bit pattern comparison as an optimisation there. But that then falls apart if NaN canonicalisation isn't actually done/allowed by the spec.","format":"org.matrix.custom.html","formatted_body":"If you create a Float64Array containing NaNs without ever assigning NaNs into it, you can get to a path where the <code>sort()</code> call would be the first place where the NaNs would actually be \"observed\", and it seems like the CompareTypedArrayElements is designed for engines to be able to use bit pattern comparison as an optimisation there. But that then falls apart if NaN canonicalisation isn't actually done/allowed by the spec.","m.mentions":{},"msgtype":"m.text"},"ts":1744912955731,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$72IE8voQvIhAEDvYED6LWU-qGrm16x1dEytLQi1ZSnY"},
{"content":{"body":"Yeah, it only reads like it was written to be compare-by-bit-pattern-but-we-know-all-nans-are-positive.","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$pUI3CdzsnxMnfldMju8ogu7vCWx3zQtbsAuzYYOoffg"}},"msgtype":"m.text"},"ts":1744912991527,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$BaE0_lVGKj2bJ0JU9LS9yRUXDwQ1O-Zm6QdCwpliKXk"},
{"content":{"body":"\"it seems like the CompareTypedArrayElements is designed for engines to be able to use bit pattern comparison as an optimisation there\" where do you get that sense from?","m.mentions":{},"msgtype":"m.text"},"ts":1744913007613,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$_ZCvcjsDl5pJT6KFfB93-NQLS2ProToQWBCqF-abDE4"},
{"content":{"body":"From the fact that it is entirely equivalent (from my understanding and somewhat limited testing) to a comparison by bit pattern if one makes the assumption that all NaNs are canonicalised or at least positive.","m.mentions":{},"msgtype":"m.text"},"ts":1744913100350,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$GyzGR7TIJg9V6HXGmyCuMdVK2C0xRl0cbLCN_Qnd9Qw"},
{"content":{"body":"that last bit is pretty important though. you can't make that assumption","m.mentions":{},"msgtype":"m.text"},"ts":1744913117503,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$G-YkoQn51NmSK1PZo-8zNMX-f2-hxvhYbXmCO3LepmU"},
{"content":{"body":"the spec was deliberately written to enable multiple implementation styles. So if you read it and think, \"it permits this\", you're not wrong, but that's different from requiring it","m.mentions":{},"msgtype":"m.text"},"ts":1744913139657,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5DuvoB4Yht_i3AY5edMNded1EaLWi3iQFO4vR08huiY"},
{"content":{"body":"Mm, roger. I keep falling into the mistake of thinking that NaN canonicalisation exists somewhere in the spec :)","m.mentions":{},"msgtype":"m.text"},"ts":1744913374540,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$uUbsAG5WK8lhZbYB_PiKbbV6FjwJZcwSFMk48NyPmtw"},
{"content":{"body":"Except of course for the `NumericToRawBytes` bit where implementations are required to always use the same pattern for NaN, and `sort()` using that AO later when it assigns stuff into the buffer... And since the order of these operations isn't observable, I guess an implementation could freely reorder them, first canonicalise to their chosen positive NaN bit pattern and then run a normal total order comparison.","format":"org.matrix.custom.html","formatted_body":"Except of course for the <code>NumericToRawBytes</code> bit where implementations are required to always use the same pattern for NaN, and <code>sort()</code> using that AO later when it assigns stuff into the buffer... And since the order of these operations isn't observable, I guess an implementation could freely reorder them, first canonicalise to their chosen positive NaN bit pattern and then run a normal total order comparison.","m.mentions":{},"msgtype":"m.text"},"ts":1744913806925,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$pUH06khRLqW66gl7sht3geNLVFjtqVKLidypDbUvt4s"},
{"content":{"body":"* Except of course for the `NumericToRawBytes` bit where implementations are (currently) required to always use the same pattern for NaN, and `sort()` using that AO later when it assigns stuff into the buffer... And since the order of these operations isn't observable, I guess an implementation could freely reorder them, first canonicalise to their chosen positive NaN bit pattern and then run a normal total order comparison.","format":"org.matrix.custom.html","formatted_body":"* Except of course for the <code>NumericToRawBytes</code> bit where implementations are (currently) required to always use the same pattern for NaN, and <code>sort()</code> using that AO later when it assigns stuff into the buffer... And since the order of these operations isn't observable, I guess an implementation could freely reorder them, first canonicalise to their chosen positive NaN bit pattern and then run a normal total order comparison.","m.mentions":{},"m.new_content":{"body":"Except of course for the `NumericToRawBytes` bit where implementations are (currently) required to always use the same pattern for NaN, and `sort()` using that AO later when it assigns stuff into the buffer... And since the order of these operations isn't observable, I guess an implementation could freely reorder them, first canonicalise to their chosen positive NaN bit pattern and then run a normal total order comparison.","format":"org.matrix.custom.html","formatted_body":"Except of course for the <code>NumericToRawBytes</code> bit where implementations are (currently) required to always use the same pattern for NaN, and <code>sort()</code> using that AO later when it assigns stuff into the buffer... And since the order of these operations isn't observable, I guess an implementation could freely reorder them, first canonicalise to their chosen positive NaN bit pattern and then run a normal total order comparison.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$pUH06khRLqW66gl7sht3geNLVFjtqVKLidypDbUvt4s","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1744913816302,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$3_4eIm_J1WMnbTSa4XaGGDA-0lC8XLUnjFBqldVv4yk"},
{"content":{"body":"yeah the thing about \"it must keep using the same pattern when serializing multiple times\" is spec fiction; we should remove it.","m.mentions":{},"msgtype":"m.text"},"ts":1744913826985,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$GW0sN-w5YwVFKDx0LezAnWoG6bihVeor5f9HdJVutpI"},
{"content":{"body":"could one of you file an editorial issue? :)","m.mentions":{},"msgtype":"m.text"},"ts":1744914173745,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$vCS-JkG1CeLxqRaD3l8ZsFKuEeIdj95g-Mcwrp8tv0w"},
{"content":{"body":"I at least commented on https://github.com/tc39/ecma262/issues/635 but if you want to, I can also open a new issue or a PR for the change, assuming there's no particular problem with non-delegates doing so.","m.mentions":{},"msgtype":"m.text"},"ts":1744914404799,"senderName":"Aapo Alasuutari","senderId":"@aapo.alasuutari:matrix.org","id":"$XpWam14s29VXWIV6gF7xVIktNjzeBMZiGd9MQsoMDFw"},
{"content":{"body":"i meant specifically about \"yeah the thing about \"it must keep using the same pattern when serializing multiple times\" is spec fiction; we should remove it.\"","m.mentions":{},"msgtype":"m.text"},"ts":1744914539635,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$MM-Uds7uQdneb3bXHIdTQJ556gpgVow8w19CIrU3HMs"}
]