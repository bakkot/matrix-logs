[
{"content":{"body":"A Coq Mechanization of JavaScript Regular Expression Semantics: https://dl.acm.org/doi/10.1145/3674666","msgtype":"m.text"},"ts":1725352317087,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$uv3znjSfIrpFrXr0WfCeVvdyBflx4CbcFNMeM78YHiY"},
{"content":{"body":"In 6.1, they acknowledge the distinction between main-body and annex B regexes, but don't explicitly say which they're mechanizing (as far as I could see). I'm pretty sure it's just main-body.","m.mentions":{},"msgtype":"m.text"},"ts":1725371928287,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$-5NQLStB05qHsis8ehaV26n9bMKuJjia7qLISCF5KGY"},
{"content":{"body":"Do the two modes have different _features_, or just different parsing rules?","format":"org.matrix.custom.html","formatted_body":"Do the two modes have different <em>features</em>, or just different parsing rules?","m.mentions":{},"msgtype":"m.text"},"ts":1725394229623,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$r1YHnnA0XnKNkGyU0oTFemsm0-mkG7Nx7RMvsWf-o70"},
{"content":{"body":"> These grammars do not agree on all inputs:\nfor instance, the standard grammar rejects ], whereas the legacy grammar allows it and treats it as\na valid regex matching the character ‘]’. Given this, we left parsing out of our mechanization.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>These grammars do not agree on all inputs:<br>for instance, the standard grammar rejects ], whereas the legacy grammar allows it and treats it as<br>a valid regex matching the character ‘]’. Given this, we left parsing out of our mechanization.</p>\n</blockquote>\n","m.mentions":{},"msgtype":"m.text"},"ts":1725394241004,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$21OmJyRyW2arv8gmGtoDhgxaPX4haQBBBqxmMNo-xrM"},
{"content":{"body":"It's mostly syntax, but it isn't *just* syntax, some of the pseudocode is different too, so it makes a difference (to the resulting mechanization) which you pick.","format":"org.matrix.custom.html","formatted_body":"It's mostly syntax, but it isn't <em>just</em> syntax, some of the pseudocode is different too, so it makes a difference (to the resulting mechanization) which you pick.","m.mentions":{},"msgtype":"m.text"},"ts":1725396122343,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$PnZCtcgT06gezr_5L5jtprFqJtgbZpuuPR6TjmE6fQU"},
{"content":{"body":"> <@nicolo-ribaudo:matrix.org> Do the two modes have different _features_, or just different parsing rules?\n\njust different parsing rules AFAICT, but the interpretation of various `\\c…` in various possible locations gets _really_ intricate","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$r1YHnnA0XnKNkGyU0oTFemsm0-mkG7Nx7RMvsWf-o70?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">@nicolo-ribaudo:matrix.org</a><br>Do the two modes have different <em>features</em>, or just different parsing rules?</blockquote></mx-reply>just different parsing rules AFAICT, but the interpretation of various <code>\\c…</code> in various possible locations gets <em>really</em> intricate","m.mentions":{"user_ids":["@nicolo-ribaudo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$r1YHnnA0XnKNkGyU0oTFemsm0-mkG7Nx7RMvsWf-o70"}},"msgtype":"m.text"},"ts":1725396195364,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$yRUG_TQYUvxblbNxujxagNgClq19tVCIImmf0cihtpw"},
{"content":{"body":"For research purposes, it makes sense for them to stick to the main-body, but I think it's at least worth saying so.","m.mentions":{},"msgtype":"m.text"},"ts":1725396242848,"senderName":"jmdyck","senderId":"@jmdyck:matrix.org","id":"$1je8fi7w8jwif19RujiSZi89V-CVSfY8aOZyJlB4NeE"},
{"content":{"body":"i experimented a bit with an nfa vm for engine262 for verifying optimizations, cool to see this approach as well","m.mentions":{},"msgtype":"m.text"},"ts":1725396688158,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$tS_dcJ0z0jAKfKaisqvELOCEqNbcz2Q225qBF55CXvU"},
{"content":{"body":"I kind of want to propose a `Math.argmax(it, fn)` which is like `(it, fn) => Iterator.from(it).reduce((a, b) => f(a) > f(b) ? a : b)`, but apparently Python's (rather numpy's) `argmax` gives you the index of the maximum item rather actually taking a function.","format":"org.matrix.custom.html","formatted_body":"I kind of want to propose a <code>Math.argmax(it, fn)</code> which is like <code>(it, fn) =&gt; Iterator.from(it).reduce((a, b) =&gt; f(a) &gt; f(b) ? a : b)</code>, but apparently Python's (rather numpy's) <code>argmax</code> gives you the index of the maximum item rather actually taking a function.","m.mentions":{},"msgtype":"m.text"},"ts":1725404312950,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$wtN54Y-dMAieHpprf7fWjnxECyHSNdvDddAMsFT1oZA"},
{"content":{"body":"possible alternatives:\n- the `fn` arg is optional, and it just gives you the index if omitted (which is useless if the argument isn't indexable, but whatever)\n- call it `maxBy`, which is a natural enough name (and also apparently already exists in lodash, neat)","format":"org.matrix.custom.html","formatted_body":"<p>possible alternatives:</p>\n<ul>\n<li>the <code>fn</code> arg is optional, and it just gives you the index if omitted (which is useless if the argument isn't indexable, but whatever)</li>\n<li>call it <code>maxBy</code>, which is a natural enough name (and also apparently already exists in lodash, neat)</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1725404366210,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$I5V90HYVNmE--YtkMXj49OogIDpOIxf5nkUG4gs-Sy4"}
]