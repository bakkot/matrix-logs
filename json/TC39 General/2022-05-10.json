[
{"content":{"body":"Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/html"}]},"ts":1652209518169,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cEdwGkOD-2NQQTcM3LscNvA1BbS1xD3FQ0zUpmjUXbE"},
{"content":{"body":"or bterlson or anyone else who was involved in the details of specifying async/await","format":"org.matrix.custom.html","formatted_body":"or <a href=\"https://matrix.to/#/@bterlson:matrix.org\">bterlson</a> or anyone else who was involved in the details of specifying async/await","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"or bterlson or anyone else who was involved in the details of specifying async/await","mimetype":"text/plain"},{"body":"or <a href=\"https://matrix.to/#/@bterlson:matrix.org\">bterlson</a> or anyone else who was involved in the details of specifying async/await","mimetype":"text/html"}]},"ts":1652209540239,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$T9kz5oaYxUB7sZ5C7oz-QP84_U5beEal_xlylBDfREE"},
{"content":{"body":"I don't recall sorry :(","msgtype":"m.text","org.matrix.msc1767.text":"I don't recall sorry :("},"ts":1652209572428,"senderName":"bterlson","senderId":"@bterlson:matrix.org","id":"$7jKibFznP_OR4WbfV3XY63CE_ZL-B8duOLuK2W4Bda0"},
{"content":{"body":" * Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","m.new_content":{"body":"Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$cEdwGkOD-2NQQTcM3LscNvA1BbS1xD3FQ0zUpmjUXbE","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/plain"},{"body":" * <a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/html"}]},"ts":1652209718731,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$2oaLZJ7-A5siZrUH0_yxdkmukywwMEDmjZXpuDKbBdk"},
{"content":{"body":"thenable delenda est :(","msgtype":"m.text","org.matrix.msc1767.text":"thenable delenda est :("},"ts":1652209982540,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$KeovazgQPlekQ-t4wP_WMkQLH7jSw8xAfEpw1Y1J2gU"},
{"content":{"body":"happens when `thenable` is a native promise too, to be clear","format":"org.matrix.custom.html","formatted_body":"happens when <code>thenable</code> is a native promise too, to be clear","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"happens when `thenable` is a native promise too, to be clear","mimetype":"text/plain"},{"body":"happens when <code>thenable</code> is a native promise too, to be clear","mimetype":"text/html"}]},"ts":1652210112251,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$NURkTpqAVk3WeEUbFnBUoTQIwWV-AqvJlcs2pjRuvyU"},
{"content":{"body":"I guess this actually dates back to promises in ES6, which I always forget predate async/await","msgtype":"m.text","org.matrix.msc1767.text":"I guess this actually dates back to promises in ES6, which I always forget predate async/await"},"ts":1652210523547,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ooENcf9XwsKDWMY0q9CuW11gcTcpwwsSsOO_fwlKXU4"},
{"content":{"body":"aha, finally dug up previous discussion: https://github.com/domenic/promises-unwrapping/issues/105","msgtype":"m.text","org.matrix.msc1767.text":"aha, finally dug up previous discussion: https://github.com/domenic/promises-unwrapping/issues/105"},"ts":1652211691847,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$W9TmqTqHK2gbTLjv7X75Zr6S96pbpwQkSBKVNRavpU4"},
{"content":{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"ts":1652212768757,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$0Zz1TwD_g4TvAbaPDB_j2AFZ9c3pc9d1xA6BNcBlk5M"},
{"content":{"body":" * So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)\\` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":" * So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)\\</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","m.new_content":{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)\\` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)\\</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)\\` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)\\</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$0Zz1TwD_g4TvAbaPDB_j2AFZ9c3pc9d1xA6BNcBlk5M","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)\\` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":" * So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)\\</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"ts":1652212786162,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$IT4VCHhymwQLNVgaM-fEMOzC1N7g5QgJ4jw_RxJNbIE"},
{"content":{"body":" * So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":" * So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","m.new_content":{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$0Zz1TwD_g4TvAbaPDB_j2AFZ9c3pc9d1xA6BNcBlk5M","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":" * So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"ts":1652212794584,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CKwJPcfs-09KZmm_p_20mxbKaTcimVdfX5oa--krHN4"},
{"content":{"body":"the actual issue Justin Ridgewell was worried about arises from the first case, though","format":"org.matrix.custom.html","formatted_body":"the actual issue <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> was worried about arises from the first case, though","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"the actual issue Justin Ridgewell was worried about arises from the first case, though","mimetype":"text/plain"},{"body":"the actual issue <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> was worried about arises from the first case, though","mimetype":"text/html"}]},"ts":1652212885272,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$-KiK-rpo0DvkB1KtpU02dfQvimqevkVEHqXwGhRzesE"},
{"content":{"body":"does it? My understanding was the adoption of a return promise","msgtype":"m.text","org.matrix.msc1767.text":"does it? My understanding was the adoption of a return promise"},"ts":1652212916809,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$x-ZNIaprPQ8pm2_sOw0Ff6CeT67kgbKclXA4AHM-MrU"},
{"content":{"body":"It falls out of the first case","msgtype":"m.text"},"ts":1652212963181,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$GDnGP75dAqtzXTwFKXbAb7r_vwCbaLqmK-pOukZF5Ec"},
{"content":{"body":"The async functions implicit promise wrapper calls resolve with the return value","msgtype":"m.text"},"ts":1652212997877,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$e8521n3HhqdGHJ25F7XX1HmSVbb7GpbMT-i9d8x1chI"},
{"content":{"body":"* The async functions implicit promise wrapper calls resolve with the return value","m.new_content":{"body":"The async functions implicit promise wrapper calls resolve with the return value","msgtype":"m.text"},"m.relates_to":{"event_id":"$e8521n3HhqdGHJ25F7XX1HmSVbb7GpbMT-i9d8x1chI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1652213031631,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$1_dZfqPpLhuv5noXdKe3ekCkuICdPUD8oNdFNdf1f1k"}
]