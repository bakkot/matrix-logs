[
{"content":{"body":"Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/html"}]},"ts":1652209518169,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cEdwGkOD-2NQQTcM3LscNvA1BbS1xD3FQ0zUpmjUXbE"},
{"content":{"body":"or bterlson or anyone else who was involved in the details of specifying async/await","format":"org.matrix.custom.html","formatted_body":"or <a href=\"https://matrix.to/#/@bterlson:matrix.org\">bterlson</a> or anyone else who was involved in the details of specifying async/await","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"or bterlson or anyone else who was involved in the details of specifying async/await","mimetype":"text/plain"},{"body":"or <a href=\"https://matrix.to/#/@bterlson:matrix.org\">bterlson</a> or anyone else who was involved in the details of specifying async/await","mimetype":"text/html"}]},"ts":1652209540239,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$T9kz5oaYxUB7sZ5C7oz-QP84_U5beEal_xlylBDfREE"},
{"content":{"body":"I don't recall sorry :(","msgtype":"m.text","org.matrix.msc1767.text":"I don't recall sorry :("},"ts":1652209572428,"senderName":"bterlson","senderId":"@bterlson:matrix.org","id":"$7jKibFznP_OR4WbfV3XY63CE_ZL-B8duOLuK2W4Bda0"},
{"content":{"body":" * Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","m.new_content":{"body":"Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$cEdwGkOD-2NQQTcM3LscNvA1BbS1xD3FQ0zUpmjUXbE","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Domenic: do you happen to remember why `new Promise(res => res(thenable))` calls `thenable.then()` on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/plain"},{"body":" * <a href=\"https://matrix.to/#/@domenicdenicola:matrix.org\">Domenic</a>: do you happen to remember why <code>new Promise(res =&gt; res(thenable))</code> calls <code>thenable.then()</code> on the next tick rather than synchronously, in defiance of the A+ spec? cf https://github.com/tc39/ecma262/issues/2770#issuecomment-1121612732","mimetype":"text/html"}]},"ts":1652209718731,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$2oaLZJ7-A5siZrUH0_yxdkmukywwMEDmjZXpuDKbBdk"},
{"content":{"body":"thenable delenda est :(","msgtype":"m.text","org.matrix.msc1767.text":"thenable delenda est :("},"ts":1652209982540,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$KeovazgQPlekQ-t4wP_WMkQLH7jSw8xAfEpw1Y1J2gU"},
{"content":{"body":"happens when `thenable` is a native promise too, to be clear","format":"org.matrix.custom.html","formatted_body":"happens when <code>thenable</code> is a native promise too, to be clear","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"happens when `thenable` is a native promise too, to be clear","mimetype":"text/plain"},{"body":"happens when <code>thenable</code> is a native promise too, to be clear","mimetype":"text/html"}]},"ts":1652210112251,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$NURkTpqAVk3WeEUbFnBUoTQIwWV-AqvJlcs2pjRuvyU"},
{"content":{"body":"I guess this actually dates back to promises in ES6, which I always forget predate async/await","msgtype":"m.text","org.matrix.msc1767.text":"I guess this actually dates back to promises in ES6, which I always forget predate async/await"},"ts":1652210523547,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ooENcf9XwsKDWMY0q9CuW11gcTcpwwsSsOO_fwlKXU4"},
{"content":{"body":"aha, finally dug up previous discussion: https://github.com/domenic/promises-unwrapping/issues/105","msgtype":"m.text","org.matrix.msc1767.text":"aha, finally dug up previous discussion: https://github.com/domenic/promises-unwrapping/issues/105"},"ts":1652211691847,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$W9TmqTqHK2gbTLjv7X75Zr6S96pbpwQkSBKVNRavpU4"},
{"content":{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"ts":1652212768757,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$0Zz1TwD_g4TvAbaPDB_j2AFZ9c3pc9d1xA6BNcBlk5M"},
{"content":{"body":" * So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)\\` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":" * So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)\\</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","m.new_content":{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)\\` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)\\</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)\\` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)\\</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$0Zz1TwD_g4TvAbaPDB_j2AFZ9c3pc9d1xA6BNcBlk5M","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)\\` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":" * So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)\\</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"ts":1652212786162,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$IT4VCHhymwQLNVgaM-fEMOzC1N7g5QgJ4jw_RxJNbIE"},
{"content":{"body":" * So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":" * So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","m.new_content":{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","format":"org.matrix.custom.html","formatted_body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":"So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$0Zz1TwD_g4TvAbaPDB_j2AFZ9c3pc9d1xA6BNcBlk5M","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * So basically the problem is that `new Promise(res => res(thenable))` is not a clean stack but`Promise.resolve().then(() => thenable)` is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/plain"},{"body":" * So basically the problem is that <code>new Promise(res =&gt; res(thenable))</code> is not a clean stack but<code>Promise.resolve().then(() =&gt; thenable)</code> is a clean stack. As I mentioned earlier, I do believe that there would be a lot less code that will break if only the second case is made synchronous, since it'd be after a return, and thus I believe unlikely that any code would be relying on a new tick","mimetype":"text/html"}]},"ts":1652212794584,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CKwJPcfs-09KZmm_p_20mxbKaTcimVdfX5oa--krHN4"},
{"content":{"body":"the actual issue Justin Ridgewell was worried about arises from the first case, though","format":"org.matrix.custom.html","formatted_body":"the actual issue <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> was worried about arises from the first case, though","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"the actual issue Justin Ridgewell was worried about arises from the first case, though","mimetype":"text/plain"},{"body":"the actual issue <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> was worried about arises from the first case, though","mimetype":"text/html"}]},"ts":1652212885272,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$-KiK-rpo0DvkB1KtpU02dfQvimqevkVEHqXwGhRzesE"},
{"content":{"body":"does it? My understanding was the adoption of a return promise","msgtype":"m.text","org.matrix.msc1767.text":"does it? My understanding was the adoption of a return promise"},"ts":1652212916809,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$x-ZNIaprPQ8pm2_sOw0Ff6CeT67kgbKclXA4AHM-MrU"},
{"content":{"body":"It falls out of the first case","msgtype":"m.text"},"ts":1652212963181,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$GDnGP75dAqtzXTwFKXbAb7r_vwCbaLqmK-pOukZF5Ec"},
{"content":{"body":"The async functions implicit promise wrapper calls resolve with the return value","msgtype":"m.text"},"ts":1652212997877,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$e8521n3HhqdGHJ25F7XX1HmSVbb7GpbMT-i9d8x1chI"},
{"content":{"body":"* The async functions implicit promise wrapper calls resolve with the return value","m.new_content":{"body":"The async functions implicit promise wrapper calls resolve with the return value","msgtype":"m.text"},"m.relates_to":{"event_id":"$e8521n3HhqdGHJ25F7XX1HmSVbb7GpbMT-i9d8x1chI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1652213031631,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$1_dZfqPpLhuv5noXdKe3ekCkuICdPUD8oNdFNdf1f1k"},
{"content":{"body":"when the function returns, `res(retv)` is called with the (raw, not boxed) return value of the function, and when `retv` is already a thenable, it waits a tick before invoking `retv.then`","format":"org.matrix.custom.html","formatted_body":"when the function returns, <code>res(retv)</code> is called with the (raw, not boxed) return value of the function, and when <code>retv</code> is already a thenable, it waits a tick before invoking <code>retv.then</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"when the function returns, `res(retv)` is called with the (raw, not boxed) return value of the function, and when `retv` is already a thenable, it waits a tick before invoking `retv.then`","mimetype":"text/plain"},{"body":"when the function returns, <code>res(retv)</code> is called with the (raw, not boxed) return value of the function, and when <code>retv</code> is already a thenable, it waits a tick before invoking <code>retv.then</code>","mimetype":"text/html"}]},"ts":1652213133653,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$_3qu35Y3cWAKuy6ZG3-EhqkKJZNk8i6AlOl2QqB3AuU"},
{"content":{"body":"we could just add a fast-path to `res` when the `then` from `thenable` is the actual `Promise.prototype.then`, I suppose","format":"org.matrix.custom.html","formatted_body":"we could just add a fast-path to <code>res</code> when the <code>then</code> from <code>thenable</code> is the actual <code>Promise.prototype.then</code>, I suppose","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"we could just add a fast-path to `res` when the `then` from `thenable` is the actual `Promise.prototype.then`, I suppose","mimetype":"text/plain"},{"body":"we could just add a fast-path to <code>res</code> when the <code>then</code> from <code>thenable</code> is the actual <code>Promise.prototype.then</code>, I suppose","mimetype":"text/html"}]},"ts":1652213164897,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$r12AlFgrH4Y0-mN31j5svWM7Id9zi-bNjMIdQQfw-xE"},
{"content":{"body":" * when the function returns, `res(retv)` is called with the (raw, not boxed) return value of the function, and when `retv` is already a thenable, it waits a tick before invoking `retv.then`","format":"org.matrix.custom.html","formatted_body":" * when the function returns, <code>res(retv)</code> is called with the (raw, not boxed) return value of the function, and when <code>retv</code> is already a thenable, it waits a tick before invoking <code>retv.then</code>","m.new_content":{"body":"when the function returns, `res(retv)` is called with the (raw, not boxed) return value of the function, and when `retv` is already a thenable, it waits a tick before invoking `retv.then`","format":"org.matrix.custom.html","formatted_body":"when the function returns, <code>res(retv)</code> is called with the (raw, not boxed) return value of the function, and when <code>retv</code> is already a thenable, it waits a tick before invoking <code>retv.then</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"when the function returns, `res(retv)` is called with the (raw, not boxed) return value of the function, and when `retv` is already a thenable, it waits a tick before invoking `retv.then`","mimetype":"text/plain"},{"body":"when the function returns, <code>res(retv)</code> is called with the (raw, not boxed) return value of the function, and when <code>retv</code> is already a thenable, it waits a tick before invoking <code>retv.then</code>","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$_3qu35Y3cWAKuy6ZG3-EhqkKJZNk8i6AlOl2QqB3AuU","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * when the function returns, `res(retv)` is called with the (raw, not boxed) return value of the function, and when `retv` is already a thenable, it waits a tick before invoking `retv.then`","mimetype":"text/plain"},{"body":" * when the function returns, <code>res(retv)</code> is called with the (raw, not boxed) return value of the function, and when <code>retv</code> is already a thenable, it waits a tick before invoking <code>retv.then</code>","mimetype":"text/html"}]},"ts":1652213192246,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$1S7Wh0bQ5hA5_chyB9m1DBN_sdgqpVQquPacUQqY-d8"},
{"content":{"body":"Oh yeah right, if we had `(async () => thenable)()` technically that would call the `.then` synchronously at that point, and not on a clean stack. Ugh","format":"org.matrix.custom.html","formatted_body":"Oh yeah right, if we had <code>(async () =&gt; thenable)()</code> technically that would call the <code>.then</code> synchronously at that point, and not on a clean stack. Ugh","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Oh yeah right, if we had `(async () => thenable)()` technically that would call the `.then` synchronously at that point, and not on a clean stack. Ugh","mimetype":"text/plain"},{"body":"Oh yeah right, if we had <code>(async () =&gt; thenable)()</code> technically that would call the <code>.then</code> synchronously at that point, and not on a clean stack. Ugh","mimetype":"text/html"}]},"ts":1652213346552,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$-5aTKTb0qLyVKVtB8KqVVY1m-_6Btxsdj-UTdj1ojH8"},
{"content":{"body":"> <@bakkot:matrix.org> we could just add a fast-path to `res` when the `then` from `thenable` is the actual `Promise.prototype.then`, I suppose\n\nNow we're getting into realms complexities.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$r12AlFgrH4Y0-mN31j5svWM7Id9zi-bNjMIdQQfw-xE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>we could just add a fast-path to <code>res</code> when the <code>then</code> from <code>thenable</code> is the actual <code>Promise.prototype.then</code>, I suppose</blockquote></mx-reply>Now we're getting into realms complexities.","m.relates_to":{"m.in_reply_to":{"event_id":"$r12AlFgrH4Y0-mN31j5svWM7Id9zi-bNjMIdQQfw-xE"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@bakkot:matrix.org> we could just add a fast-path to `res` when the `then` from `thenable` is the actual `Promise.prototype.then`, I suppose\n\nNow we're getting into realms complexities.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$r12AlFgrH4Y0-mN31j5svWM7Id9zi-bNjMIdQQfw-xE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>we could just add a fast-path to <code>res</code> when the <code>then</code> from <code>thenable</code> is the actual <code>Promise.prototype.then</code>, I suppose</blockquote></mx-reply>Now we're getting into realms complexities.","mimetype":"text/html"}]},"ts":1652213399447,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$gwmcPa4tDGspI6pVBhd58qM5uUQtb62RfWdYIHRkapI"},
{"content":{"body":"we already have those with the fast-path in Promise.resolve","msgtype":"m.text","org.matrix.msc1767.text":"we already have those with the fast-path in Promise.resolve"},"ts":1652213412974,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$2w5cJ4Ltme8Ur15Q5dWpC0Ch5gunhT9xU2kyd07Zmqs"},
{"content":{"body":"Should the spec be allowed to recognize `Promise.prototype.then` form other realms ?","format":"org.matrix.custom.html","formatted_body":"Should the spec be allowed to recognize <code>Promise.prototype.then</code> form other realms ?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Should the spec be allowed to recognize `Promise.prototype.then` form other realms ?","mimetype":"text/plain"},{"body":"Should the spec be allowed to recognize <code>Promise.prototype.then</code> form other realms ?","mimetype":"text/html"}]},"ts":1652213419218,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$e4knvgddONTT-GVu2PdrSr4sJc7UAg2daqvwGzjnKZI"},
{"content":{"body":"We have a similar  fast path for await","msgtype":"m.text"},"ts":1652213432517,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$FM97eJw67AczMDgr_Ki9zi-8wZEoJToyAuLRrzOOamg"},
{"content":{"body":"specifically PromiseResolve does SameValue, which fails cross-realm","msgtype":"m.text","org.matrix.msc1767.text":"specifically PromiseResolve does SameValue, which fails cross-realm"},"ts":1652213457907,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$xK9P5eMOuyoWYpMMsC3u3VH-lIj3pNsshGwQ-CTKcz0"},
{"content":{"body":"and it's fine","msgtype":"m.text","org.matrix.msc1767.text":"and it's fine"},"ts":1652213464244,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$khH_7DYRKY1KMAAeZ0Fr5nNhE7vdz_BowQZ6EKlknqk"},
{"content":{"body":"i can imagine that might be a problem for shadowrealms which have different Promise prototypes but the same microtask queue","msgtype":"m.text","org.matrix.msc1767.text":"i can imagine that might be a problem for shadowrealms which have different Promise prototypes but the same microtask queue"},"ts":1652219817256,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$dBdptj0Q9b1DD8Njyt36Qjntzbat5p7jQ0wMbHD8uXk"},
{"content":{"body":" * i can imagine that might be a problem for shadowrealms which have different Promise prototypes but the same microtask queue","m.new_content":{"body":"i can imagine that might be a problem for shadowrealms which have different Promise prototypes but the same microtask queue","msgtype":"m.text","org.matrix.msc1767.text":"i can imagine that might be a problem for shadowrealms which have different Promise prototypes but the same microtask queue"},"m.relates_to":{"event_id":"$dBdptj0Q9b1DD8Njyt36Qjntzbat5p7jQ0wMbHD8uXk","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * i can imagine that might be a problem for shadowrealms which have different Promise prototypes but the same microtask queue"},"ts":1652219821021,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$rEXHpidQd3BLHJ8EwO8wsfuqSNoU3hsD0UGlYHgQPLU"},
{"content":{"body":"i say this, i want to be very clear here, having zero concerns with having it just do `SameValue`","format":"org.matrix.custom.html","formatted_body":"i say this, i want to be very clear here, having zero concerns with having it just do <code>SameValue</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"i say this, i want to be very clear here, having zero concerns with having it just do `SameValue`","mimetype":"text/plain"},{"body":"i say this, i want to be very clear here, having zero concerns with having it just do <code>SameValue</code>","mimetype":"text/html"}]},"ts":1652219844032,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mCeZvRWDsU5_O7XJH_nUulaI5NcdV82qcq6uXa-KrFU"},
{"content":{"body":"you can't pass a promise across the shadowrealm boundary anyway","msgtype":"m.text","org.matrix.msc1767.text":"you can't pass a promise across the shadowrealm boundary anyway"},"ts":1652220892216,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$0JJbd18rAHmqyJzHXKqs5UyZ3Zuxnz_JNJ6ZuSwivJY"},
{"content":{"body":"The more you can simplify this mess the better","msgtype":"m.text","org.matrix.msc1767.text":"The more you can simplify this mess the better"},"ts":1652223064983,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$ZNBPOvqVzhqlfeUfae65-JPZHgUazAZpOxFtFwFX82E"},
{"content":{"body":"I'm not sure if adding a fast-path is really simplifying, but I guess it's making things faster, which is also good","msgtype":"m.text","org.matrix.msc1767.text":"I'm not sure if adding a fast-path is really simplifying, but I guess it's making things faster, which is also good"},"ts":1652223082660,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$3lPCF6dbku5Jug8yDOtUbxGY4xDHP2-5LEOfv-rrvdQ"},
{"content":{"body":"But if you can just get rid of all the extra microtasks and \"untrusted\" code guards and stuff... that was all really misguided.","msgtype":"m.text","org.matrix.msc1767.text":"But if you can just get rid of all the extra microtasks and \"untrusted\" code guards and stuff... that was all really misguided."},"ts":1652223120688,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$9vGNZ9vFNyoLOcibljDiHexzZ4o399651xQBv8Q4xvM"},
{"content":{"body":"Thenable support in general, was probably still important, but less important than I thought it would be, and we could have gotten away with something simpler I'm sure.","msgtype":"m.text","org.matrix.msc1767.text":"Thenable support in general, was probably still important, but less important than I thought it would be, and we could have gotten away with something simpler I'm sure."},"ts":1652223182418,"senderName":"Domenic","senderId":"@domenicdenicola:matrix.org","id":"$Zd2KAD3Hc6ufMfRAkeZcwuo4TOnUZJJizTg9svIs5pg"},
{"content":{"body":"Yeah, fast-path would be the \"we're adding a back-compat hack to make the common case less gross\" option: not an actual reduction in complexity when you understand the full machinery in detail but probably a reduction in complexity in practice because the common case ends up cleaner","msgtype":"m.text","org.matrix.msc1767.text":"Yeah, fast-path would be the \"we're adding a back-compat hack to make the common case less gross\" option: not an actual reduction in complexity when you understand the full machinery in detail but probably a reduction in complexity in practice because the common case ends up cleaner"},"ts":1652225470263,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Qtdx7BcqCOnqHsUa8KrPwLohMfIeDIXQ2YeiPH6lkRc"},
{"content":{"body":"Mathieu Hofman: this is off topic for the PR thread, but how would having a built-in `IsPromise` help your use case? `IsPromise` holds for instances of Promise subclasses, but those can have custom `then` which the spec will dutifully call (as long as the subclass instances don't reset their `.constructor` to the native Promise).","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>: this is off topic for the PR thread, but how would having a built-in <code>IsPromise</code> help your use case? <code>IsPromise</code> holds for instances of Promise subclasses, but those can have custom <code>then</code> which the spec will dutifully call (as long as the subclass instances don't reset their <code>.constructor</code> to the native Promise).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Mathieu Hofman: this is off topic for the PR thread, but how would having a built-in `IsPromise` help your use case? `IsPromise` holds for instances of Promise subclasses, but those can have custom `then` which the spec will dutifully call (as long as the subclass instances don't reset their `.constructor` to the native Promise).","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>: this is off topic for the PR thread, but how would having a built-in <code>IsPromise</code> help your use case? <code>IsPromise</code> holds for instances of Promise subclasses, but those can have custom <code>then</code> which the spec will dutifully call (as long as the subclass instances don't reset their <code>.constructor</code> to the native Promise).","mimetype":"text/html"}]},"ts":1652225525281,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$x8a8OkbpDCfuIZ7aD5WYceSEzY0jy0AAapflXIb_TOw"},
{"content":{"body":"`const isSafePromise = (p) => Promise.isPromise(p) && Reflect.getPrototypeOf(p) === Promise.prototype && !Reflect.getOwnPropertyDescriptor(p, 'then') && !Reflect.getOwnPropertyDescriptor(p, 'constructor')` (Given frozen instrinsics)","format":"org.matrix.custom.html","formatted_body":"<code>const isSafePromise = (p) =&gt; Promise.isPromise(p) &amp;&amp; Reflect.getPrototypeOf(p) === Promise.prototype &amp;&amp; !Reflect.getOwnPropertyDescriptor(p, 'then') &amp;&amp; !Reflect.getOwnPropertyDescriptor(p, 'constructor')</code> (Given frozen instrinsics)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`const isSafePromise = (p) => Promise.isPromise(p) && Reflect.getPrototypeOf(p) === Promise.prototype && !Reflect.getOwnPropertyDescriptor(p, 'then') && !Reflect.getOwnPropertyDescriptor(p, 'constructor')` (Given frozen instrinsics)","mimetype":"text/plain"},{"body":"<code>const isSafePromise = (p) =&gt; Promise.isPromise(p) &amp;&amp; Reflect.getPrototypeOf(p) === Promise.prototype &amp;&amp; !Reflect.getOwnPropertyDescriptor(p, 'then') &amp;&amp; !Reflect.getOwnPropertyDescriptor(p, 'constructor')</code> (Given frozen instrinsics)","mimetype":"text/html"}]},"ts":1652225820414,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$TnDkfrrkm0q3wG-rWQSGQlxL-_rlhczCYoaF6U12Xx8"},
{"content":{"body":"Or whatever Promise subclass the user chooses to trust","msgtype":"m.text","org.matrix.msc1767.text":"Or whatever Promise subclass the user chooses to trust"},"ts":1652225946816,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$1woCP1GqIh_qQ-0bbrmZpzrhRalJ9TQdpcw8MeizUc8"}
]