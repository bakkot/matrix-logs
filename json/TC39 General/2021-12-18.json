[
{"content":{"body":"There's resistance against adding syntax to ECMAScript and implicit tail-call elimination doesn't seem to be working out from engine implementers. Then how about explicit, magical `Function.prototype.callWithElimination(this, ...params)` that gives an error during AST generation if the call is not in correct place for eliminating the tail call?","format":"org.matrix.custom.html","formatted_body":"There's resistance against adding syntax to ECMAScript and implicit tail-call elimination doesn't seem to be working out from engine implementers. Then how about explicit, magical <code>Function.prototype.callWithElimination(this, ...params)</code> that gives an error during AST generation if the call is not in correct place for eliminating the tail call?","msgtype":"m.text"},"ts":1639798940130,"senderName":"pokute","senderId":"@pokute:matrix.org","id":"$scQf4W2eCqufuXDd0MKlkv2QjViG42PHkjE-xry9QDk"},
{"content":{"body":"what is \"AST generation\"? that's not a thing in the spec afaict","msgtype":"m.text"},"ts":1639811635005,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$K3NHcvrbGJvUD4fKNaYLHAZksiBhg1MR16-CguWNswY"},
{"content":{"body":" * what is \"AST generation\"? that's not a thing in the spec afaict","m.new_content":{"body":"what is \"AST generation\"? that's not a thing in the spec afaict","msgtype":"m.text"},"m.relates_to":{"event_id":"$K3NHcvrbGJvUD4fKNaYLHAZksiBhg1MR16-CguWNswY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639811647498,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$tlRZX48B2Bj6_zZ8QF4YlZB5diFV773D_Vl8801Cyl8"},
{"content":{"body":"> <@ljharb:matrix.org> what is \"AST generation\"? that's not a thing in the spec afaict\n\nThey mean \"while parsing\" ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$K3NHcvrbGJvUD4fKNaYLHAZksiBhg1MR16-CguWNswY?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br />what is \"AST generation\"? that's not a thing in the spec afaict</blockquote></mx-reply>They mean \"while parsing\" ","m.relates_to":{"m.in_reply_to":{"event_id":"$K3NHcvrbGJvUD4fKNaYLHAZksiBhg1MR16-CguWNswY"}},"msgtype":"m.text"},"ts":1639812037042,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$N7iCxhlM5gnIF0V6RDR7ewLruqv8jw6e2fYHNvRUosI"},
{"content":{"body":"But I don't think a function call should fail while parsing? ","msgtype":"m.text"},"ts":1639812054770,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$_8Xmhneun1SXqroyau9nYmRUz0OzG1Mdj76W27mjs0E"},
{"content":{"body":"sure, but how could you parse an API call like that?","msgtype":"m.text"},"ts":1639812054914,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$bJmgWbrejCxxx1NcCfXT6Ro4lPK0heGlmCh5RPHd95w"},
{"content":{"body":"Exactly","msgtype":"m.text"},"ts":1639812061967,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$T0l2SyLuAYzKO9DYgl5Gg68DE-lt7R6YHjCd36wSzZo"},
{"content":{"body":"`const x = Function.prototype.callWithElimination; return x.call(f);`","format":"org.matrix.custom.html","formatted_body":"<code>const x = Function.prototype.callWithElimination; return x.call(f);</code>","msgtype":"m.text"},"ts":1639812073936,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Ei81P2iHaWGFr_fT2_1bKLUCZK4z-5m4WBZ2pJXDM-0"},
{"content":{"body":"pretty sure it requires syntax to detect the position of something, eg tail call position","msgtype":"m.text"},"ts":1639812093009,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$u5IT7BFdVa0CWaB2fKyH9qT6kIcDyb_p_g23RxqUMz4"},
{"content":{"body":"I don't think this will work, it's valid syntax and shouldn't fail. ","format":"org.matrix.custom.html","formatted_body":"I don't think this will work, it's valid syntax and shouldn't fail.","msgtype":"m.text"},"ts":1639812095122,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$1nUyDIoX2W5lLhWDGPL5j6r1Sj-wBgeOdNDikQFF1gM"},
{"content":{"body":"> <@ljharb:matrix.org> pretty sure it requires syntax to detect the position of something, eg tail call position\n\nYou mean syntax around the expression inside the function? ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$u5IT7BFdVa0CWaB2fKyH9qT6kIcDyb_p_g23RxqUMz4?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br />pretty sure it requires syntax to detect the position of something, eg tail call position</blockquote></mx-reply>You mean syntax around the expression inside the function? ","m.relates_to":{"m.in_reply_to":{"event_id":"$u5IT7BFdVa0CWaB2fKyH9qT6kIcDyb_p_g23RxqUMz4"}},"msgtype":"m.text"},"ts":1639812195618,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$8SoHz6jOeQYkFUN6fq03-dtHLgxwENrryt_Eg8Gi1Lg"},
{"content":{"body":"The expression containing the tail call I mean. ","format":"org.matrix.custom.html","formatted_body":"The expression containing the tail call I mean.","msgtype":"m.text"},"ts":1639812223763,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$Rufob1LuYYL4D6Xywx4xQbgB09V2Y796XPBrGyRinLc"},
{"content":{"body":"Yeah I don't see how something that isn't syntax could cause a parsing time error. Now the premise about syntax is that it should pay for itself. If there is a way to add something without syntax, then there is little justification to add syntax. If the only option is syntax (like in this suggestion) then the question becomes, is it worth the cost? I'm not sure I know enough about tail call use cases to form a complete opinion, but the fact we've gotten away without it for so long is an indicator there are likely ways to avoid a tail call optimization requirements.","msgtype":"m.text"},"ts":1639812901564,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$jfnBn7lztF_xCbuqxWYyZA_O21aU3Hr9TrYSC69tDBE"},
{"content":{"body":"* Yeah I don't see how something that isn't syntax could cause a parsing time error. Now the premise about syntax is that it should pay for itself. If there is a way to add something without syntax, then there is little justification to add syntax. If the only option is syntax (like in this idea of explicit tail call) then the question becomes, is it worth the cost? I'm not sure I know enough about tail call use cases to form a complete opinion, but the fact we've gotten away without it for so long is an indicator there are likely ways to avoid a tail call optimization requirements.","m.new_content":{"body":"Yeah I don't see how something that isn't syntax could cause a parsing time error. Now the premise about syntax is that it should pay for itself. If there is a way to add something without syntax, then there is little justification to add syntax. If the only option is syntax (like in this idea of explicit tail call) then the question becomes, is it worth the cost? I'm not sure I know enough about tail call use cases to form a complete opinion, but the fact we've gotten away without it for so long is an indicator there are likely ways to avoid a tail call optimization requirements.","msgtype":"m.text"},"m.relates_to":{"event_id":"$jfnBn7lztF_xCbuqxWYyZA_O21aU3Hr9TrYSC69tDBE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639813262937,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$53YBJXYdlaAZMuIqyrLckCScQvBeoXOP8tdoFb7l3jU"},
{"content":{"body":"> <@ljharb:matrix.org> `const x = Function.prototype.callWithElimination; return x.call(f);`\n\nI was thinking of that, but it's difficult.  I was thinking of only recognising `return recursiveFunc.callWithElimination(undefined, accumulator, moreParams)` or something like that.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$Ei81P2iHaWGFr_fT2_1bKLUCZK4z-5m4WBZ2pJXDM-0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br><code>const x = Function.prototype.callWithElimination; return x.call(f);</code></blockquote></mx-reply>I was thinking of that, but it's difficult.  I was thinking of only recognising <code>return recursiveFunc.callWithElimination(undefined, accumulator, moreParams)</code> or something like that.","m.relates_to":{"m.in_reply_to":{"event_id":"$Ei81P2iHaWGFr_fT2_1bKLUCZK4z-5m4WBZ2pJXDM-0"}},"msgtype":"m.text"},"ts":1639833081480,"senderName":"pokute","senderId":"@pokute:matrix.org","id":"$qIwEPLrD_JCSxAzs6gFwr2Cg9Q2xEJL3LlZVBHuepb8"},
{"content":{"body":"> <@pokute:matrix.org> I was thinking of that, but it's difficult.  I was thinking of only recognising `return recursiveFunc.callWithElimination(undefined, accumulator, moreParams)` or something like that.\n\nthat do you mean \"only recognizing\"?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$qIwEPLrD_JCSxAzs6gFwr2Cg9Q2xEJL3LlZVBHuepb8?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@pokute:matrix.org\">@pokute:matrix.org</a><br>I was thinking of that, but it's difficult.  I was thinking of only recognising <code>return recursiveFunc.callWithElimination(undefined, accumulator, moreParams)</code> or something like that.</blockquote></mx-reply>that do you mean &quot;only recognizing&quot;?","m.relates_to":{"m.in_reply_to":{"event_id":"$qIwEPLrD_JCSxAzs6gFwr2Cg9Q2xEJL3LlZVBHuepb8"}},"msgtype":"m.text"},"ts":1639833149671,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$B9IUbCIptJrOzF99s2uqTUvAfzImrdPv8usApMiVLsg"},
{"content":{"body":"that it won't work if you assign it to another variable?","msgtype":"m.text"},"ts":1639833165034,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$kXSre4ikNtqwMnVcFj8CbNemhavIBJCXRcK3G3tNp4E"},
{"content":{"body":"that seems to go against pretty much every single rule of the language","msgtype":"m.text"},"ts":1639833178555,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$24SsQcd9NTjOKpCHcGD3IJl1V8sAmcMxkkHR-ImZbvw"},
{"content":{"body":"As the only valid position that doesn't give error during parsing. The error thing was that it should give an error before runtime so that it's impossible to have code that tries to call it in wrong position. And yeah, can't assign. :-) It's magical. **But** it's not unprecended! You can't have `const myImport = import`.","format":"org.matrix.custom.html","formatted_body":"As the only valid position that doesn't give error during parsing. The error thing was that it should give an error before runtime so that it's impossible to have code that tries to call it in wrong position. And yeah, can't assign. :-) It's magical. <strong>But</strong> it's not unprecended! You can't have <code>const myImport = import</code>.","msgtype":"m.text"},"ts":1639833260016,"senderName":"pokute","senderId":"@pokute:matrix.org","id":"$Y-YMKJG0QRx2_3byNgM_sfAy6kkjMXc6gFjCEmuhrGI"},
{"content":{"body":"`import` is a keyword","format":"org.matrix.custom.html","formatted_body":"<code>import</code> is a keyword","msgtype":"m.text"},"ts":1639833316694,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$cirjk7lXDgv27gLQjhJ3WRTkP-vy-he3zW6LxG_b9gQ"},
{"content":{"body":"this is a function on a prototype","msgtype":"m.text"},"ts":1639833332767,"senderName":"ryzokuken","senderId":"@usharma:igalia.com","id":"$50GSomenjcI9rDKzNsUiRrNWtPeaI8AisuX7Rpgw5O8"},
{"content":{"body":"Well, we could make it less conventional with `return recursiveFunc[Function.withCallEliminationSymbol]( ... )`.","format":"org.matrix.custom.html","formatted_body":"Well, we could make it less conventional with <code>return recursiveFunc[Function.withCallEliminationSymbol]( ... )</code>.","msgtype":"m.text"},"ts":1639833449378,"senderName":"pokute","senderId":"@pokute:matrix.org","id":"$JYy3CVG9qQ449yt7SQ7_GpGW-s3dsxKBYDfdNnrfC2A"}
]