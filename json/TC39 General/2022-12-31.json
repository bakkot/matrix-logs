[
{"content":{"body":"> <@tolmasky:matrix.org> What is necessary for \"compelling\"? We've been using a non-portable node C++ addon for 5 years because this doesn't exist, does that count as a compelling reason?\n\nYou need it so strongly and you need a hack in the engine to do that? That's a bit strange ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$l-nVMWdKfwKa0-F5ahjXueSKz6HxEegW_-RSlVg7DfI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tolmasky:matrix.org\">@tolmasky:matrix.org</a><br />What is necessary for &quot;compelling&quot;? We've been using a non-portable node C++ addon for 5 years because this doesn't exist, does that count as a compelling reason?</blockquote></mx-reply>You need it so strongly and you need a hack in the engine to do that? That's a bit strange","m.relates_to":{"m.in_reply_to":{"event_id":"$l-nVMWdKfwKa0-F5ahjXueSKz6HxEegW_-RSlVg7DfI"}},"msgtype":"m.text"},"ts":1672450753613,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$fkg2YX7qlCSamrUHymfHzb6aa5JcSFYpC6Fw0fumQEo"},
{"content":{"body":"> <@jackworks:matrix.org> You need it so strongly and you need a hack in the engine to do that? That's a bit strange\n\nTolmasky (and I) work on a product where one of the major features is showing users their output values in a nice inspectable way. Basically any native object type (RegExp, Error, Promise, BooleanObject, NumberObject, etc) created in a different realm would be hard to identify without asking V8. You can see the high level problem here: https://runkit.com/me1000/63af94f29458cb00082a18e8\n\nBrowsers don't have node's vm module of course, but realms exist in browsers too (iframes, windows, workers) and you can pass values between them, to say nothing of the ShadowRealm proposal. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$fkg2YX7qlCSamrUHymfHzb6aa5JcSFYpC6Fw0fumQEo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>You need it so strongly and you need a hack in the engine to do that? That's a bit strange</blockquote></mx-reply><p>Tolmasky (and I) work on a product where one of the major features is showing users their output values in a nice inspectable way. Basically any native object type (RegExp, Error, Promise, BooleanObject, NumberObject, etc) created in a different realm would be hard to identify without asking V8. You can see the high level problem here: https://runkit.com/me1000/63af94f29458cb00082a18e8</p>\n<p>Browsers don't have node's vm module of course, but realms exist in browsers too (iframes, windows, workers) and you can pass values between them, to say nothing of the ShadowRealm proposal.</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$fkg2YX7qlCSamrUHymfHzb6aa5JcSFYpC6Fw0fumQEo"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@jackworks:matrix.org> You need it so strongly and you need a hack in the engine to do that? That's a bit strange\n\nTolmasky (and I) work on a product where one of the major features is showing users their output values in a nice inspectable way. Basically any native object type (RegExp, Error, Promise, BooleanObject, NumberObject, etc) created in a different realm would be hard to identify without asking V8. You can see the high level problem here: https://runkit.com/me1000/63af94f29458cb00082a18e8\n\nBrowsers don't have node's vm module of course, but realms exist in browsers too (iframes, windows, workers) and you can pass values between them, to say nothing of the ShadowRealm proposal. ","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$fkg2YX7qlCSamrUHymfHzb6aa5JcSFYpC6Fw0fumQEo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>You need it so strongly and you need a hack in the engine to do that? That's a bit strange</blockquote></mx-reply><p>Tolmasky (and I) work on a product where one of the major features is showing users their output values in a nice inspectable way. Basically any native object type (RegExp, Error, Promise, BooleanObject, NumberObject, etc) created in a different realm would be hard to identify without asking V8. You can see the high level problem here: https://runkit.com/me1000/63af94f29458cb00082a18e8</p>\n<p>Browsers don't have node's vm module of course, but realms exist in browsers too (iframes, windows, workers) and you can pass values between them, to say nothing of the ShadowRealm proposal.</p>\n","mimetype":"text/html"}]},"ts":1672452682623,"senderName":"Randy Luecke","senderId":"@me1000:matrix.org","id":"$GtKcd6oaL8BAYArAzIbZlTE4AqQJQwNmfoPevGI6dMI"},
{"content":{"body":"It would be nice in general if a host program could inspect a guest program without effecting observable side-effects.","msgtype":"m.text","org.matrix.msc1767.text":"It would be nice in general if a host program could inspect a guest program without effecting observable side-effects."},"ts":1672452804275,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$KNfEAIt5k8AWKxTuew5KQvwDq3emMJzBSLi9jaJFsMk"},
{"content":{"body":"Jack Works: I also wouldn't call it a hack to use public APIs of the engine to get this information. It is of course less ideal than being able to do it in language, especially considering that it seems to be more an accident of history which native objects can and can't be identified, especially considering almost all *can* be, with only seeming exceptions being Promise and Errors. I'd consider it \"hackier\" that this information is \"leaked\" by the language spec through various techniques (such as calling Boolean.prototype.toString(object) and detecting whether that throws an error), vs. the underlying engine's simple isBooleanObject() method). The fact that Array.isArray had to be introduced points to general utility here.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jackworks:matrix.org\">Jack Works</a>: I also wouldn't call it a hack to use public APIs of the engine to get this information. It is of course less ideal than being able to do it in language, especially considering that it seems to be more an accident of history which native objects can and can't be identified, especially considering almost all <em>can</em> be, with only seeming exceptions being Promise and Errors. I'd consider it &quot;hackier&quot; that this information is &quot;leaked&quot; by the language spec through various techniques (such as calling Boolean.prototype.toString(object) and detecting whether that throws an error), vs. the underlying engine's simple isBooleanObject() method). The fact that Array.isArray had to be introduced points to general utility here.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Jack Works: I also wouldn't call it a hack to use public APIs of the engine to get this information. It is of course less ideal than being able to do it in language, especially considering that it seems to be more an accident of history which native objects can and can't be identified, especially considering almost all *can* be, with only seeming exceptions being Promise and Errors. I'd consider it \"hackier\" that this information is \"leaked\" by the language spec through various techniques (such as calling Boolean.prototype.toString(object) and detecting whether that throws an error), vs. the underlying engine's simple isBooleanObject() method). The fact that Array.isArray had to be introduced points to general utility here.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@jackworks:matrix.org\">Jack Works</a>: I also wouldn't call it a hack to use public APIs of the engine to get this information. It is of course less ideal than being able to do it in language, especially considering that it seems to be more an accident of history which native objects can and can't be identified, especially considering almost all <em>can</em> be, with only seeming exceptions being Promise and Errors. I'd consider it &quot;hackier&quot; that this information is &quot;leaked&quot; by the language spec through various techniques (such as calling Boolean.prototype.toString(object) and detecting whether that throws an error), vs. the underlying engine's simple isBooleanObject() method). The fact that Array.isArray had to be introduced points to general utility here.","mimetype":"text/html"}]},"ts":1672453607168,"senderName":"tolmasky","senderId":"@tolmasky:matrix.org","id":"$FbRx7Q5DuLl7XzHZISgsgfHeGtCMucnQYCbxb-xy56c"},
{"content":{"body":"And to Kris Kowal 's point, its actually the case that Error and Promise *can* be identified, just not without triggering side effects (as mentioned above Promise.prototype.then.apply(object) can almost be used, but it changes the isHandled state, and structuredClone(object) instanceof Error can also *almost* be used, except structuredClone calls getters of the object and can thus change various things in the process)","format":"org.matrix.custom.html","formatted_body":"And to <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a> 's point, its actually the case that Error and Promise <em>can</em> be identified, just not without triggering side effects (as mentioned above Promise.prototype.then.apply(object) can almost be used, but it changes the isHandled state, and structuredClone(object) instanceof Error can also <em>almost</em> be used, except structuredClone calls getters of the object and can thus change various things in the process)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"And to Kris Kowal 's point, its actually the case that Error and Promise *can* be identified, just not without triggering side effects (as mentioned above Promise.prototype.then.apply(object) can almost be used, but it changes the isHandled state, and structuredClone(object) instanceof Error can also *almost* be used, except structuredClone calls getters of the object and can thus change various things in the process)","mimetype":"text/plain"},{"body":"And to <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a> 's point, its actually the case that Error and Promise <em>can</em> be identified, just not without triggering side effects (as mentioned above Promise.prototype.then.apply(object) can almost be used, but it changes the isHandled state, and structuredClone(object) instanceof Error can also <em>almost</em> be used, except structuredClone calls getters of the object and can thus change various things in the process)","mimetype":"text/html"}]},"ts":1672453759797,"senderName":"tolmasky","senderId":"@tolmasky:matrix.org","id":"$IEFK3IF-MseOFgXgAIKKihvRXQXhk3p42lWMRSdzTzM"},
{"content":{"body":"I'd go so far as to argue that if you believe there is utility in \"instanceof BuiltInType\", then it should follow that a brand check is equally useful since \"instanceof BuiltInType\" immediately introduces the possibility of a bug if the object comes from another realm (a frequent occurrence in browsers where you have multiple window objects) -- this was the reason that Array.isArray was added in the first place, because \"instanceof Array\" would fail in those circumstances. Well... \"instanceof Error\", \"instanceof RegExp\", etc. etc. *still* fail under those circumstances. Not sure why individual cases need to be made for each of them. It is if nothing else very useful for making the simplest \"in language\" debug tools, like you find in code sandbox-type applications (of which there are many many, everything from the built-in consoles in browsers, to codesandbox.com, to runkit, etc. etc.), all of which regularly deal with the state of js objects in a separate frame (and thus realm).","format":"org.matrix.custom.html","formatted_body":"I'd go so far as to argue that if you believe there is utility in &quot;instanceof BuiltInType&quot;, then it should follow that a brand check is equally useful since &quot;instanceof BuiltInType&quot; immediately introduces the possibility of a bug if the object comes from another realm (a frequent occurrence in browsers where you have multiple window objects) -- this was the reason that Array.isArray was added in the first place, because &quot;instanceof Array&quot; would fail in those circumstances. Well... &quot;instanceof Error&quot;, &quot;instanceof RegExp&quot;, etc. etc. <em>still</em> fail under those circumstances. Not sure why individual cases need to be made for each of them. It is if nothing else very useful for making the simplest &quot;in language&quot; debug tools, like you find in code sandbox-type applications (of which there are many many, everything from the built-in consoles in browsers, to codesandbox.com, to runkit, etc. etc.), all of which regularly deal with the state of js objects in a separate frame (and thus realm).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I'd go so far as to argue that if you believe there is utility in \"instanceof BuiltInType\", then it should follow that a brand check is equally useful since \"instanceof BuiltInType\" immediately introduces the possibility of a bug if the object comes from another realm (a frequent occurrence in browsers where you have multiple window objects) -- this was the reason that Array.isArray was added in the first place, because \"instanceof Array\" would fail in those circumstances. Well... \"instanceof Error\", \"instanceof RegExp\", etc. etc. *still* fail under those circumstances. Not sure why individual cases need to be made for each of them. It is if nothing else very useful for making the simplest \"in language\" debug tools, like you find in code sandbox-type applications (of which there are many many, everything from the built-in consoles in browsers, to codesandbox.com, to runkit, etc. etc.), all of which regularly deal with the state of js objects in a separate frame (and thus realm).","mimetype":"text/plain"},{"body":"I'd go so far as to argue that if you believe there is utility in &quot;instanceof BuiltInType&quot;, then it should follow that a brand check is equally useful since &quot;instanceof BuiltInType&quot; immediately introduces the possibility of a bug if the object comes from another realm (a frequent occurrence in browsers where you have multiple window objects) -- this was the reason that Array.isArray was added in the first place, because &quot;instanceof Array&quot; would fail in those circumstances. Well... &quot;instanceof Error&quot;, &quot;instanceof RegExp&quot;, etc. etc. <em>still</em> fail under those circumstances. Not sure why individual cases need to be made for each of them. It is if nothing else very useful for making the simplest &quot;in language&quot; debug tools, like you find in code sandbox-type applications (of which there are many many, everything from the built-in consoles in browsers, to codesandbox.com, to runkit, etc. etc.), all of which regularly deal with the state of js objects in a separate frame (and thus realm).","mimetype":"text/html"}]},"ts":1672454496446,"senderName":"tolmasky","senderId":"@tolmasky:matrix.org","id":"$m8wU4T35IJ7ZEwQqRIazjz5Z9o5YEkfkytwICLX5eUQ"},
{"content":{"body":"btw can someone explain to me why `Object.assign(new Float32Array(1), [2147483647])[0]` produces `2147483648`? 2147483647 is a 31 bit number so it doesn't *seem* like it'd be an overflow thing. (i'm sure the answer is \"floating point\" but id love a better explanation)","format":"org.matrix.custom.html","formatted_body":"btw can someone explain to me why <code>Object.assign(new Float32Array(1), [2147483647])[0]</code> produces <code>2147483648</code>? 2147483647 is a 31 bit number so it doesn't <em>seem</em> like it'd be an overflow thing. (i'm sure the answer is &quot;floating point&quot; but id love a better explanation)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"btw can someone explain to me why `Object.assign(new Float32Array(1), [2147483647])[0]` produces `2147483648`? 2147483647 is a 31 bit number so it doesn't *seem* like it'd be an overflow thing. (i'm sure the answer is \"floating point\" but id love a better explanation)","mimetype":"text/plain"},{"body":"btw can someone explain to me why <code>Object.assign(new Float32Array(1), [2147483647])[0]</code> produces <code>2147483648</code>? 2147483647 is a 31 bit number so it doesn't <em>seem</em> like it'd be an overflow thing. (i'm sure the answer is &quot;floating point&quot; but id love a better explanation)","mimetype":"text/html"}]},"ts":1672469838078,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$aTbOXYFvWPnDF73Fe2RPZab_QRgATPFLA2UQtN1YFek"},
{"content":{"body":"just because an integer occupies n bits doesn't mean a float with that many bits can represent it","msgtype":"m.text"},"ts":1672469935425,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$prU7EfpqfZY7xjGnasKjW83u9J5dlGKzcdUqd9D-gn4"},
{"content":{"body":"for example, many integers greater than 2^53 in our float64s","msgtype":"m.text"},"ts":1672469973104,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$ZKKiCjJTmwNo5u8x-ifesDgXfNtHcLSXQccLPRFyerY"},
{"content":{"body":"ok, so it's not overflow exactly, it's just a gap that float32 can't represent?","msgtype":"m.text","org.matrix.msc1767.text":"ok, so it's not overflow exactly, it's just a gap that float32 can't represent?"},"ts":1672470053616,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$hfuazBEyswOSvrPNWn7W7XGHhCzieso1vUCTzdhODbY"},
{"content":{"body":" * ok, so it's not overflow exactly, it's just a gap that float64 can't represent?","m.new_content":{"body":"ok, so it's not overflow exactly, it's just a gap that float64 can't represent?","msgtype":"m.text","org.matrix.msc1767.text":"ok, so it's not overflow exactly, it's just a gap that float64 can't represent?"},"m.relates_to":{"event_id":"$hfuazBEyswOSvrPNWn7W7XGHhCzieso1vUCTzdhODbY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * ok, so it's not overflow exactly, it's just a gap that float64 can't represent?"},"ts":1672470066955,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$yGTDxi7C_UpXqdrR68o617ypkdKq8bIUJkUMu164Ue0"},
{"content":{"body":" * ok, so it's not overflow exactly, it's just a gap that float32 can't represent?","m.new_content":{"body":"ok, so it's not overflow exactly, it's just a gap that float32 can't represent?","msgtype":"m.text","org.matrix.msc1767.text":"ok, so it's not overflow exactly, it's just a gap that float32 can't represent?"},"m.relates_to":{"event_id":"$hfuazBEyswOSvrPNWn7W7XGHhCzieso1vUCTzdhODbY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * ok, so it's not overflow exactly, it's just a gap that float32 can't represent?"},"ts":1672470082806,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$c4IeLO9nmn-DcW0rNID0FOouq5ZHTvXPP1RIuDXkw3M"},
{"content":{"body":"I would assume, I don't have any intuition of what values are representable by 32 bit floats","msgtype":"m.text"},"ts":1672470086761,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$UIxQmjXeg5iCr2MPoLuPDrD1vjcIKhUzfJS6nlfhfis"},
{"content":{"body":"hmm, ok","msgtype":"m.text","org.matrix.msc1767.text":"hmm, ok"},"ts":1672470093766,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$lg1FhrDIS1OcnCJe6HTSerCD7UF7GCgkm_zFgXfY6iA"},
{"content":{"body":"there are ways to validate that. for example you could convert the underlying buffer to Uint32, and increment it by 1 at a time to see what values come out in the float32","msgtype":"m.text"},"ts":1672470164905,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$Et9_eo6BsYkA0cS2a6x91iS0o-7qdi10K82gNhf1RQQ"}
]