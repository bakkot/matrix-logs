[
{"content":{"body":"jschoi: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"jschoi: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","mimetype":"text/html"}]},"ts":1657238675935,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cvRianEx1feGhrplMNe3_MErR5pnXn9GWaVy2IZlgCc"},
{"content":{"body":"> <@jschoi:matrix.org> @sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and => from being operators.\n> I don’t know if there’s any rigorous-but-still-useful definition of “operator” that would exclude =, though. I think that you could rigorously define a JavaScript operator as a “syntactic token(s) that create an expression but which is not a literal”, where an “expression” is a “syntax phrase that evaluates into a value at runtime”. So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if it’s in the MDN table). And = and =>, I think, can reasonably be rigorously called operators, too. They’re certainly not literals or statements, heh.\n\ni'm confused; `=>` like in an arrow function? how is that an operator? what's the LHS operand in `(a, b) => {}`?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$dDW4gwLegOmx0qosGFVxcYQshYb-q-Dll1rYtW_l82Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jschoi:matrix.org\">@jschoi:matrix.org</a><br>@sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and =&gt; from being operators.<br />\nI don’t know if there’s any rigorous-but-still-useful definition of “operator” that would exclude =, though. I think that you could rigorously define a JavaScript operator as a “syntactic token(s) that create an expression but which is not a literal”, where an “expression” is a “syntax phrase that evaluates into a value at runtime”. So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if it’s in the MDN table). And = and =&gt;, I think, can reasonably be rigorously called operators, too. They’re certainly not literals or statements, heh.</blockquote></mx-reply>i'm confused; <code>=&gt;</code> like in an arrow function? how is that an operator? what's the LHS operand in <code>(a, b) =&gt; {}</code>?","m.relates_to":{"m.in_reply_to":{"event_id":"$dDW4gwLegOmx0qosGFVxcYQshYb-q-Dll1rYtW_l82Q"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@jschoi:matrix.org> @sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and => from being operators.\n> I don’t know if there’s any rigorous-but-still-useful definition of “operator” that would exclude =, though. I think that you could rigorously define a JavaScript operator as a “syntactic token(s) that create an expression but which is not a literal”, where an “expression” is a “syntax phrase that evaluates into a value at runtime”. So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if it’s in the MDN table). And = and =>, I think, can reasonably be rigorously called operators, too. They’re certainly not literals or statements, heh.\n\ni'm confused; `=>` like in an arrow function? how is that an operator? what's the LHS operand in `(a, b) => {}`?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$dDW4gwLegOmx0qosGFVxcYQshYb-q-Dll1rYtW_l82Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jschoi:matrix.org\">@jschoi:matrix.org</a><br>@sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and =&gt; from being operators.<br />\nI don’t know if there’s any rigorous-but-still-useful definition of “operator” that would exclude =, though. I think that you could rigorously define a JavaScript operator as a “syntactic token(s) that create an expression but which is not a literal”, where an “expression” is a “syntax phrase that evaluates into a value at runtime”. So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if it’s in the MDN table). And = and =&gt;, I think, can reasonably be rigorously called operators, too. They’re certainly not literals or statements, heh.</blockquote></mx-reply>i'm confused; <code>=&gt;</code> like in an arrow function? how is that an operator? what's the LHS operand in <code>(a, b) =&gt; {}</code>?","mimetype":"text/html"}]},"ts":1657248899499,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$_WXHqQGHjdSboAm0WAtIL9PHctO0f3pXSZ_un94iiGM"},
{"content":{"body":"Well, I’m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But you’re right in that `=>`’s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThere’s also the fact that the evaluation of RHS’s side is deferred. I think that’s a reasonable argument against `=>` as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then what about nullary operators like `yield` that do not involve any subexpressions? Or operators with special evaluation rules like short-circuiting operators?)\n\nI personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot `=>` in there. \n\nBut I now realize I’ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS…","format":"org.matrix.custom.html","formatted_body":"<p>Well, I’m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But you’re right in that <code>=&gt;</code>’s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>There’s also the fact that the evaluation of RHS’s side is deferred. I think that’s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then what about nullary operators like <code>yield</code> that do not involve any subexpressions? Or operators with special evaluation rules like short-circuiting operators?)</p>\n<p>I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize I’ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS…</p>","msgtype":"m.text"},"ts":1657257400574,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$BgcVUyScF87pAQQWQEWY3vdMsAFzS83_-AXPDdGV5ic"}
]