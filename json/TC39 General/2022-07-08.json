[
{"content":{"body":"jschoi: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"jschoi: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","mimetype":"text/html"}]},"ts":1657238675935,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cvRianEx1feGhrplMNe3_MErR5pnXn9GWaVy2IZlgCc"},
{"content":{"body":"> <@jschoi:matrix.org> @sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and => from being operators.\n> I don’t know if there’s any rigorous-but-still-useful definition of “operator” that would exclude =, though. I think that you could rigorously define a JavaScript operator as a “syntactic token(s) that create an expression but which is not a literal”, where an “expression” is a “syntax phrase that evaluates into a value at runtime”. So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if it’s in the MDN table). And = and =>, I think, can reasonably be rigorously called operators, too. They’re certainly not literals or statements, heh.\n\ni'm confused; `=>` like in an arrow function? how is that an operator? what's the LHS operand in `(a, b) => {}`?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$dDW4gwLegOmx0qosGFVxcYQshYb-q-Dll1rYtW_l82Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jschoi:matrix.org\">@jschoi:matrix.org</a><br>@sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and =&gt; from being operators.<br />\nI don’t know if there’s any rigorous-but-still-useful definition of “operator” that would exclude =, though. I think that you could rigorously define a JavaScript operator as a “syntactic token(s) that create an expression but which is not a literal”, where an “expression” is a “syntax phrase that evaluates into a value at runtime”. So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if it’s in the MDN table). And = and =&gt;, I think, can reasonably be rigorously called operators, too. They’re certainly not literals or statements, heh.</blockquote></mx-reply>i'm confused; <code>=&gt;</code> like in an arrow function? how is that an operator? what's the LHS operand in <code>(a, b) =&gt; {}</code>?","m.relates_to":{"m.in_reply_to":{"event_id":"$dDW4gwLegOmx0qosGFVxcYQshYb-q-Dll1rYtW_l82Q"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@jschoi:matrix.org> @sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and => from being operators.\n> I don’t know if there’s any rigorous-but-still-useful definition of “operator” that would exclude =, though. I think that you could rigorously define a JavaScript operator as a “syntactic token(s) that create an expression but which is not a literal”, where an “expression” is a “syntax phrase that evaluates into a value at runtime”. So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if it’s in the MDN table). And = and =>, I think, can reasonably be rigorously called operators, too. They’re certainly not literals or statements, heh.\n\ni'm confused; `=>` like in an arrow function? how is that an operator? what's the LHS operand in `(a, b) => {}`?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$dDW4gwLegOmx0qosGFVxcYQshYb-q-Dll1rYtW_l82Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jschoi:matrix.org\">@jschoi:matrix.org</a><br>@sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and =&gt; from being operators.<br />\nI don’t know if there’s any rigorous-but-still-useful definition of “operator” that would exclude =, though. I think that you could rigorously define a JavaScript operator as a “syntactic token(s) that create an expression but which is not a literal”, where an “expression” is a “syntax phrase that evaluates into a value at runtime”. So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if it’s in the MDN table). And = and =&gt;, I think, can reasonably be rigorously called operators, too. They’re certainly not literals or statements, heh.</blockquote></mx-reply>i'm confused; <code>=&gt;</code> like in an arrow function? how is that an operator? what's the LHS operand in <code>(a, b) =&gt; {}</code>?","mimetype":"text/html"}]},"ts":1657248899499,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$_WXHqQGHjdSboAm0WAtIL9PHctO0f3pXSZ_un94iiGM"},
{"content":{"body":"Well, I’m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But you’re right in that `=>`’s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThere’s also the fact that the evaluation of RHS’s side is deferred. I think that’s a reasonable argument against `=>` as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then what about nullary operators like `yield` that do not involve any subexpressions? Or operators with special evaluation rules like short-circuiting operators?)\n\nI personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot `=>` in there. \n\nBut I now realize I’ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS…","format":"org.matrix.custom.html","formatted_body":"<p>Well, I’m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But you’re right in that <code>=&gt;</code>’s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>There’s also the fact that the evaluation of RHS’s side is deferred. I think that’s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then what about nullary operators like <code>yield</code> that do not involve any subexpressions? Or operators with special evaluation rules like short-circuiting operators?)</p>\n<p>I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize I’ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS…</p>","msgtype":"m.text"},"ts":1657257400574,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$BgcVUyScF87pAQQWQEWY3vdMsAFzS83_-AXPDdGV5ic"},
{"content":{"body":" * Well, I’m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But you’re right in that `=>`’s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThere’s also the fact that the evaluation of `=>`’s RHS is deferred. I think that’s a reasonable argument against `=>` as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like `yield`, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)\n\nAnyways, I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot `=>` in there.\n\nBut I now realize I’ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS. It’s a good point—I don’t think it necessarily disqualifies `=>` from being an operator (i.e., the RHS of `x => {}` is a block, and that’s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.","format":"org.matrix.custom.html","formatted_body":" * <p>Well, I’m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But you’re right in that <code>=&gt;</code>’s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>There’s also the fact that the evaluation of <code>=&gt;</code>’s RHS is deferred. I think that’s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like <code>yield</code>, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)</p>\n<p>Anyways, I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize I’ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS. It’s a good point—I don’t think it necessarily disqualifies <code>=&gt;</code> from being an operator (i.e., the RHS of <code>x =&gt; {}</code> is a block, and that’s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.</p>\n","m.new_content":{"body":"Well, I’m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But you’re right in that `=>`’s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThere’s also the fact that the evaluation of `=>`’s RHS is deferred. I think that’s a reasonable argument against `=>` as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like `yield`, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)\n\nAnyways, I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot `=>` in there.\n\nBut I now realize I’ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS. It’s a good point—I don’t think it necessarily disqualifies `=>` from being an operator (i.e., the RHS of `x => {}` is a block, and that’s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.","format":"org.matrix.custom.html","formatted_body":"<p>Well, I’m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But you’re right in that <code>=&gt;</code>’s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>There’s also the fact that the evaluation of <code>=&gt;</code>’s RHS is deferred. I think that’s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like <code>yield</code>, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)</p>\n<p>Anyways, I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize I’ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS. It’s a good point—I don’t think it necessarily disqualifies <code>=&gt;</code> from being an operator (i.e., the RHS of <code>x =&gt; {}</code> is a block, and that’s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Well, I’m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But you’re right in that `=>`’s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThere’s also the fact that the evaluation of `=>`’s RHS is deferred. I think that’s a reasonable argument against `=>` as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like `yield`, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)\n\nAnyways, I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot `=>` in there.\n\nBut I now realize I’ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS. It’s a good point—I don’t think it necessarily disqualifies `=>` from being an operator (i.e., the RHS of `x => {}` is a block, and that’s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.","mimetype":"text/plain"},{"body":"<p>Well, I’m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But you’re right in that <code>=&gt;</code>’s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>There’s also the fact that the evaluation of <code>=&gt;</code>’s RHS is deferred. I think that’s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like <code>yield</code>, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)</p>\n<p>Anyways, I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize I’ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS. It’s a good point—I don’t think it necessarily disqualifies <code>=&gt;</code> from being an operator (i.e., the RHS of <code>x =&gt; {}</code> is a block, and that’s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$BgcVUyScF87pAQQWQEWY3vdMsAFzS83_-AXPDdGV5ic","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Well, I’m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But you’re right in that `=>`’s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThere’s also the fact that the evaluation of `=>`’s RHS is deferred. I think that’s a reasonable argument against `=>` as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like `yield`, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)\n\nAnyways, I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot `=>` in there.\n\nBut I now realize I’ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS. It’s a good point—I don’t think it necessarily disqualifies `=>` from being an operator (i.e., the RHS of `x => {}` is a block, and that’s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.","mimetype":"text/plain"},{"body":" * <p>Well, I’m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But you’re right in that <code>=&gt;</code>’s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If “operator” means “syntactic construct that creates an expression that evaluates to a value, unless it is a literal”, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a “literal” for functions…Now I’m wondering if there’s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>There’s also the fact that the evaluation of <code>=&gt;</code>’s RHS is deferred. I think that’s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expression…In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like <code>yield</code>, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)</p>\n<p>Anyways, I personally like the simplicity of “if it creates an expression, and it’s not a string/number/boolean literal, then it’s probably an operator”. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize I’ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS. It’s a good point—I don’t think it necessarily disqualifies <code>=&gt;</code> from being an operator (i.e., the RHS of <code>x =&gt; {}</code> is a block, and that’s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.</p>\n","mimetype":"text/html"}]},"ts":1657257633003,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$zMbjNRnACk8ynEOmq9k0FxG9iRUuJdhNyoC_khKmD_4"},
{"content":{"body":"`(a, b)` is an argument list, which isn't a thing. how can you operate on it?","format":"org.matrix.custom.html","formatted_body":"<code>(a, b)</code> is an argument list, which isn't a thing. how can you operate on it?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`(a, b)` is an argument list, which isn't a thing. how can you operate on it?","mimetype":"text/plain"},{"body":"<code>(a, b)</code> is an argument list, which isn't a thing. how can you operate on it?","mimetype":"text/html"}]},"ts":1657257847465,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$sdouiLPh1rpeg97Y2QBnoGdJJ5xkeAmdh5QMLSKuxxA"},
{"content":{"body":"Well, the `a` in `a = expr` isn’t an expression either, right? You could say that `=` is operating on `expr` but not `a` per se, since `a` is not an expression. That’s the strongest part of the analogy, I think: compare `([a, b]) => f()` and `[a, b] = f()`. In both cases, the LHS is not actually an expression.","format":"org.matrix.custom.html","formatted_body":"Well, the <code>a</code> in <code>a = expr</code> isn’t an expression either, right? You could say that <code>=</code> is operating on <code>expr</code> but not <code>a</code> per se, since <code>a</code> is not an expression. That’s the strongest part of the analogy, I think: compare <code>([a, b]) =&gt; f()</code> and <code>[a, b] = f()</code>. In both cases, the LHS is not actually an expression.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Well, the `a` in `a = expr` isn’t an expression either, right? You could say that `=` is operating on `expr` but not `a` per se, since `a` is not an expression. That’s the strongest part of the analogy, I think: compare `([a, b]) => f()` and `[a, b] = f()`. In both cases, the LHS is not actually an expression.","mimetype":"text/plain"},{"body":"Well, the <code>a</code> in <code>a = expr</code> isn’t an expression either, right? You could say that <code>=</code> is operating on <code>expr</code> but not <code>a</code> per se, since <code>a</code> is not an expression. That’s the strongest part of the analogy, I think: compare <code>([a, b]) =&gt; f()</code> and <code>[a, b] = f()</code>. In both cases, the LHS is not actually an expression.","mimetype":"text/html"}]},"ts":1657258075937,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$dbR5LEDsJiOiIAZWG-6m_HUUU3VoIbahaNSICysgbkY"},
{"content":{"body":"`=` “operates” on its RHS expression and not its LHS binding, and I suppose I would say that `=>` “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","format":"org.matrix.custom.html","formatted_body":"<code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`=` “operates” on its RHS expression and not its LHS binding, and I suppose I would say that `=>` “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/plain"},{"body":"<code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/html"}]},"ts":1657258137156,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo"},
{"content":{"body":" * `=` “operates” on its RHS expression and not its LHS binding, and I suppose I would say that `=>` “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","format":"org.matrix.custom.html","formatted_body":" * <code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","m.new_content":{"body":"`=` “operates” on its RHS expression and not its LHS binding, and I suppose I would say that `=>` “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","format":"org.matrix.custom.html","formatted_body":"<code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`=` “operates” on its RHS expression and not its LHS binding, and I suppose I would say that `=>` “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/plain"},{"body":"<code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * `=` “operates” on its RHS expression and not its LHS binding, and I suppose I would say that `=>` “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/plain"},{"body":" * <code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/html"}]},"ts":1657258163323,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$REVKYPdGEpU0pZq7ZzWflhetodRduWvAsARwdh0MH3Q"},
{"content":{"body":" * `=` “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` “operates” on its RHS expression and not its LHS arguments. \n(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple(r)”. 😅)","format":"org.matrix.custom.html","formatted_body":" * <code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple(r)”. 😅)","m.new_content":{"body":"`=` “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` “operates” on its RHS expression and not its LHS arguments. \n(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple(r)”. 😅)","format":"org.matrix.custom.html","formatted_body":"<code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple(r)”. 😅)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`=` “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` “operates” on its RHS expression and not its LHS arguments. \n(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple(r)”. 😅)","mimetype":"text/plain"},{"body":"<code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple(r)”. 😅)","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * `=` “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` “operates” on its RHS expression and not its LHS arguments. \n(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple(r)”. 😅)","mimetype":"text/plain"},{"body":" * <code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple(r)”. 😅)","mimetype":"text/html"}]},"ts":1657258264484,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$GEF04Orkpv0JMHRBm-nZszSB4uUpr9IsgQ0i356EheI"},
{"content":{"body":" * `=` “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` “operates” on its RHS expression and not its LHS arguments.\n(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple”. 😅)","format":"org.matrix.custom.html","formatted_body":" * <code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple”. 😅)","m.new_content":{"body":"`=` “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` “operates” on its RHS expression and not its LHS arguments.\n(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple”. 😅)","format":"org.matrix.custom.html","formatted_body":"<code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple”. 😅)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`=` “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` “operates” on its RHS expression and not its LHS arguments.\n(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple”. 😅)","mimetype":"text/plain"},{"body":"<code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple”. 😅)","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * `=` “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` “operates” on its RHS expression and not its LHS arguments.\n(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple”. 😅)","mimetype":"text/plain"},{"body":" * <code>=</code> “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> “operates” on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple”. 😅)","mimetype":"text/html"}]},"ts":1657258337497,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$UFA6z1k83MWJ4-Zzw2plpQOINUsnyp3zqD15sm7Baxs"},
{"content":{"body":"* = “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that => “operates” on its RHS expression and not its LHS arguments. In `[x] = f()`, `=` “operates” on `f()`, and, in `([x]) => f()`, `=>` “operates” on `f()`.  But I do feel less sure about when the RHS is a block. I guess that I would say that, in `([x]) => {}`, `=>` “operates” on the empty block. But…yeah. (Either way, I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple” and “consistent”. 😅)","format":"org.matrix.custom.html","formatted_body":"* = “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that =&gt; “operates” on its RHS expression and not its LHS arguments. In <code>[x] = f()</code>, <code>=</code> “operates” on <code>f()</code>, and, in <code>([x]) =&gt; f()</code>, <code>=&gt;</code> “operates” on <code>f()</code>.  But I do feel less sure about when the RHS is a block. I guess that I would say that, in <code>([x]) =&gt; {}</code>, <code>=&gt;</code> “operates” on the empty block. But…yeah. (Either way, I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple” and “consistent”. 😅)","m.new_content":{"body":"= “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that => “operates” on its RHS expression and not its LHS arguments. In `[x] = f()`, `=` “operates” on `f()`, and, in `([x]) => f()`, `=>` “operates” on `f()`.  But I do feel less sure about when the RHS is a block. I guess that I would say that, in `([x]) => {}`, `=>` “operates” on the empty block. But…yeah. (Either way, I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple” and “consistent”. 😅)","format":"org.matrix.custom.html","formatted_body":"= “operates” on its RHS expression and not its LHS binding, and I suppose I would also say that =&gt; “operates” on its RHS expression and not its LHS arguments. In <code>[x] = f()</code>, <code>=</code> “operates” on <code>f()</code>, and, in <code>([x]) =&gt; f()</code>, <code>=&gt;</code> “operates” on <code>f()</code>.  But I do feel less sure about when the RHS is a block. I guess that I would say that, in <code>([x]) =&gt; {}</code>, <code>=&gt;</code> “operates” on the empty block. But…yeah. (Either way, I don’t want to claim either that my personal mental model is the One True Way, of course, but at least it’s “simple” and “consistent”. 😅)","msgtype":"m.text"},"m.relates_to":{"event_id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1657259839879,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$_4kCKnEaE9q5cf2JK9D4I90bZh9qdwIMs_rcovWLS0k"},
{"content":{"body":"I guess there’s something different about JavaScript that makes the line between operators and non-operator things less clear?\n\nI mean in the case of C++ at least, I feel like the set of things that are actually operators is quite clear and I think I understand it pretty well — because it’s at least one part of the language that’s difficult for anybody to understand. But I could just be ignorant about some corner cases of C++ that I’m not familiar with","msgtype":"m.text","org.matrix.msc1767.text":"I guess there’s something different about JavaScript that makes the line between operators and non-operator things less clear?\n\nI mean in the case of C++ at least, I feel like the set of things that are actually operators is quite clear and I think I understand it pretty well — because it’s at least one part of the language that’s difficult for anybody to understand. But I could just be ignorant about some corner cases of C++ that I’m not familiar with"},"ts":1657260002320,"senderName":"sideshowbarker","senderId":"@sideshowbarker:mozilla.org","id":"$dnmTkc2wF_jYeDtzk0KPeJJidVfsxQk_hBPw9b4QHmY"}
]