[
{"content":{"body":"jschoi: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"jschoi: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: btw you can link to specific lines by clicking on the timestamp (and optionally shift-clicking on another timestamp to link to a range)","mimetype":"text/html"}]},"ts":1657238675935,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cvRianEx1feGhrplMNe3_MErR5pnXn9GWaVy2IZlgCc"},
{"content":{"body":"> <@jschoi:matrix.org> @sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and => from being operators.\n> I donâ€™t know if thereâ€™s any rigorous-but-still-useful definition of â€œoperatorâ€ that would exclude =, though. I think that you could rigorously define a JavaScript operator as a â€œsyntactic token(s) that create an expression but which is not a literalâ€, where an â€œexpressionâ€ is a â€œsyntax phrase that evaluates into a value at runtimeâ€.â€¨So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if itâ€™s in the MDN table). And = and =>, I think, can reasonably be rigorously called operators, too. Theyâ€™re certainly not literals or statements, heh.\n\ni'm confused; `=>` like in an arrow function? how is that an operator? what's the LHS operand in `(a, b) => {}`?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$dDW4gwLegOmx0qosGFVxcYQshYb-q-Dll1rYtW_l82Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jschoi:matrix.org\">@jschoi:matrix.org</a><br>@sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and =&gt; from being operators.<br />\nI donâ€™t know if thereâ€™s any rigorous-but-still-useful definition of â€œoperatorâ€ that would exclude =, though. I think that you could rigorously define a JavaScript operator as a â€œsyntactic token(s) that create an expression but which is not a literalâ€, where an â€œexpressionâ€ is a â€œsyntax phrase that evaluates into a value at runtimeâ€.â€¨So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if itâ€™s in the MDN table). And = and =&gt;, I think, can reasonably be rigorously called operators, too. Theyâ€™re certainly not literals or statements, heh.</blockquote></mx-reply>i'm confused; <code>=&gt;</code> like in an arrow function? how is that an operator? what's the LHS operand in <code>(a, b) =&gt; {}</code>?","m.relates_to":{"m.in_reply_to":{"event_id":"$dDW4gwLegOmx0qosGFVxcYQshYb-q-Dll1rYtW_l82Q"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@jschoi:matrix.org> @sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and => from being operators.\n> I donâ€™t know if thereâ€™s any rigorous-but-still-useful definition of â€œoperatorâ€ that would exclude =, though. I think that you could rigorously define a JavaScript operator as a â€œsyntactic token(s) that create an expression but which is not a literalâ€, where an â€œexpressionâ€ is a â€œsyntax phrase that evaluates into a value at runtimeâ€.â€¨So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if itâ€™s in the MDN table). And = and =>, I think, can reasonably be rigorously called operators, too. Theyâ€™re certainly not literals or statements, heh.\n\ni'm confused; `=>` like in an arrow function? how is that an operator? what's the LHS operand in `(a, b) => {}`?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$dDW4gwLegOmx0qosGFVxcYQshYb-q-Dll1rYtW_l82Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jschoi:matrix.org\">@jschoi:matrix.org</a><br>@sideshowbarker: Yeah, I can certainly sympathize with the desire for rigor on MDN. And it certainly would be consistent to exclude both = and =&gt; from being operators.<br />\nI donâ€™t know if thereâ€™s any rigorous-but-still-useful definition of â€œoperatorâ€ that would exclude =, though. I think that you could rigorously define a JavaScript operator as a â€œsyntactic token(s) that create an expression but which is not a literalâ€, where an â€œexpressionâ€ is a â€œsyntax phrase that evaluates into a value at runtimeâ€.â€¨So yield is a nullary-or-prefix operator (with side effects). + is a prefix-or-binary operator. import() probably should be called a circumflex operator (I forgot if itâ€™s in the MDN table). And = and =&gt;, I think, can reasonably be rigorously called operators, too. Theyâ€™re certainly not literals or statements, heh.</blockquote></mx-reply>i'm confused; <code>=&gt;</code> like in an arrow function? how is that an operator? what's the LHS operand in <code>(a, b) =&gt; {}</code>?","mimetype":"text/html"}]},"ts":1657248899499,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$_WXHqQGHjdSboAm0WAtIL9PHctO0f3pXSZ_un94iiGM"},
{"content":{"body":"Well, Iâ€™m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But youâ€™re right in that `=>`â€™s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThereâ€™s also the fact that the evaluation of RHSâ€™s side is deferred. I think thatâ€™s a reasonable argument against `=>` as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then what about nullary operators like `yield` that do not involve any subexpressions? Or operators with special evaluation rules like short-circuiting operators?)\n\nI personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot `=>` in there. \n\nBut I now realize Iâ€™ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHSâ€¦","format":"org.matrix.custom.html","formatted_body":"<p>Well, Iâ€™m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But youâ€™re right in that <code>=&gt;</code>â€™s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>Thereâ€™s also the fact that the evaluation of RHSâ€™s side is deferred. I think thatâ€™s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then what about nullary operators like <code>yield</code> that do not involve any subexpressions? Or operators with special evaluation rules like short-circuiting operators?)</p>\n<p>I personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize Iâ€™ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHSâ€¦</p>","msgtype":"m.text"},"ts":1657257400574,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$BgcVUyScF87pAQQWQEWY3vdMsAFzS83_-AXPDdGV5ic"},
{"content":{"body":" * Well, Iâ€™m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But youâ€™re right in that `=>`â€™s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThereâ€™s also the fact that the evaluation of `=>`â€™s RHS is deferred. I think thatâ€™s a reasonable argument against `=>` as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like `yield`, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)\n\nAnyways, I personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot `=>` in there.\n\nBut I now realize Iâ€™ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS. Itâ€™s a good pointâ€”I donâ€™t think it necessarily disqualifies `=>` from being an operator (i.e., the RHS of `x => {}` is a block, and thatâ€™s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.","format":"org.matrix.custom.html","formatted_body":" * <p>Well, Iâ€™m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But youâ€™re right in that <code>=&gt;</code>â€™s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>Thereâ€™s also the fact that the evaluation of <code>=&gt;</code>â€™s RHS is deferred. I think thatâ€™s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like <code>yield</code>, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)</p>\n<p>Anyways, I personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize Iâ€™ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS. Itâ€™s a good pointâ€”I donâ€™t think it necessarily disqualifies <code>=&gt;</code> from being an operator (i.e., the RHS of <code>x =&gt; {}</code> is a block, and thatâ€™s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.</p>\n","m.new_content":{"body":"Well, Iâ€™m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But youâ€™re right in that `=>`â€™s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThereâ€™s also the fact that the evaluation of `=>`â€™s RHS is deferred. I think thatâ€™s a reasonable argument against `=>` as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like `yield`, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)\n\nAnyways, I personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot `=>` in there.\n\nBut I now realize Iâ€™ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS. Itâ€™s a good pointâ€”I donâ€™t think it necessarily disqualifies `=>` from being an operator (i.e., the RHS of `x => {}` is a block, and thatâ€™s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.","format":"org.matrix.custom.html","formatted_body":"<p>Well, Iâ€™m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But youâ€™re right in that <code>=&gt;</code>â€™s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>Thereâ€™s also the fact that the evaluation of <code>=&gt;</code>â€™s RHS is deferred. I think thatâ€™s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like <code>yield</code>, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)</p>\n<p>Anyways, I personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize Iâ€™ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS. Itâ€™s a good pointâ€”I donâ€™t think it necessarily disqualifies <code>=&gt;</code> from being an operator (i.e., the RHS of <code>x =&gt; {}</code> is a block, and thatâ€™s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Well, Iâ€™m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But youâ€™re right in that `=>`â€™s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThereâ€™s also the fact that the evaluation of `=>`â€™s RHS is deferred. I think thatâ€™s a reasonable argument against `=>` as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like `yield`, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)\n\nAnyways, I personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot `=>` in there.\n\nBut I now realize Iâ€™ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS. Itâ€™s a good pointâ€”I donâ€™t think it necessarily disqualifies `=>` from being an operator (i.e., the RHS of `x => {}` is a block, and thatâ€™s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.","mimetype":"text/plain"},{"body":"<p>Well, Iâ€™m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But youâ€™re right in that <code>=&gt;</code>â€™s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>Thereâ€™s also the fact that the evaluation of <code>=&gt;</code>â€™s RHS is deferred. I think thatâ€™s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like <code>yield</code>, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)</p>\n<p>Anyways, I personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize Iâ€™ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS. Itâ€™s a good pointâ€”I donâ€™t think it necessarily disqualifies <code>=&gt;</code> from being an operator (i.e., the RHS of <code>x =&gt; {}</code> is a block, and thatâ€™s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$BgcVUyScF87pAQQWQEWY3vdMsAFzS83_-AXPDdGV5ic","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Well, Iâ€™m arguing that `=>` (at least when its RHS is an expression) is quite analogous to `=` in syntax. But youâ€™re right in that `=>`â€™s analogy to `=` if the RHS is a block instead of an expression. And of course evaluation is deferred and not.\n\nIf â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then `=>` definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should `[]` be considered an operator?)\n\nThereâ€™s also the fact that the evaluation of `=>`â€™s RHS is deferred. I think thatâ€™s a reasonable argument against `=>` as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like `yield`, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)\n\nAnyways, I personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot `=>` in there.\n\nBut I now realize Iâ€™ve overstated my case with regards to the `=` analogy, since `=>` can also have a block RHS. Itâ€™s a good pointâ€”I donâ€™t think it necessarily disqualifies `=>` from being an operator (i.e., the RHS of `x => {}` is a block, and thatâ€™s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.","mimetype":"text/plain"},{"body":" * <p>Well, Iâ€™m arguing that <code>=&gt;</code> (at least when its RHS is an expression) is quite analogous to <code>=</code> in syntax. But youâ€™re right in that <code>=&gt;</code>â€™s analogy to <code>=</code> if the RHS is a block instead of an expression. And of course evaluation is deferred and not.</p>\n<p>If â€œoperatorâ€ means â€œsyntactic construct that creates an expression that evaluates to a value, unless it is a literalâ€, then <code>=&gt;</code> definitely fulfills the former criterion. (I suppose one could argue that it may be considered a â€œliteralâ€ for functionsâ€¦Now Iâ€™m wondering if thereâ€™s any useful distinction between compound literals and operators. Should <code>[]</code> be considered an operator?)</p>\n<p>Thereâ€™s also the fact that the evaluation of <code>=&gt;</code>â€™s RHS is deferred. I think thatâ€™s a reasonable argument against <code>=&gt;</code> as operator, despite its creating an expressionâ€¦In other words, one might reasonably argue that an operator must combine subexpressions that are first evaluated in LTR order. (But then why are nullary operators like <code>yield</code>, which do not involve any subexpressions, not disqualified? Or what about operators with special evaluation rules like short-circuiting operators?)</p>\n<p>Anyways, I personally like the simplicity of â€œif it creates an expression, and itâ€™s not a string/number/boolean literal, then itâ€™s probably an operatorâ€. And I personally would slot <code>=&gt;</code> in there.</p>\n<p>But I now realize Iâ€™ve overstated my case with regards to the <code>=</code> analogy, since <code>=&gt;</code> can also have a block RHS. Itâ€™s a good pointâ€”I donâ€™t think it necessarily disqualifies <code>=&gt;</code> from being an operator (i.e., the RHS of <code>x =&gt; {}</code> is a block, and thatâ€™s okay, because the whole thing is an expression). But I do accept that it certainly weakens my position, heh.</p>\n","mimetype":"text/html"}]},"ts":1657257633003,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$zMbjNRnACk8ynEOmq9k0FxG9iRUuJdhNyoC_khKmD_4"},
{"content":{"body":"`(a, b)` is an argument list, which isn't a thing. how can you operate on it?","format":"org.matrix.custom.html","formatted_body":"<code>(a, b)</code> is an argument list, which isn't a thing. how can you operate on it?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`(a, b)` is an argument list, which isn't a thing. how can you operate on it?","mimetype":"text/plain"},{"body":"<code>(a, b)</code> is an argument list, which isn't a thing. how can you operate on it?","mimetype":"text/html"}]},"ts":1657257847465,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$sdouiLPh1rpeg97Y2QBnoGdJJ5xkeAmdh5QMLSKuxxA"},
{"content":{"body":"Well, the `a` in `a = expr` isnâ€™t an expression either, right? You could say that `=` is operating on `expr` but not `a` per se, since `a` is not an expression. Thatâ€™s the strongest part of the analogy, I think: compare `([a, b]) => f()` and `[a, b] = f()`. In both cases, the LHS is not actually an expression.","format":"org.matrix.custom.html","formatted_body":"Well, the <code>a</code> in <code>a = expr</code> isnâ€™t an expression either, right? You could say that <code>=</code> is operating on <code>expr</code> but not <code>a</code> per se, since <code>a</code> is not an expression. Thatâ€™s the strongest part of the analogy, I think: compare <code>([a, b]) =&gt; f()</code> and <code>[a, b] = f()</code>. In both cases, the LHS is not actually an expression.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Well, the `a` in `a = expr` isnâ€™t an expression either, right? You could say that `=` is operating on `expr` but not `a` per se, since `a` is not an expression. Thatâ€™s the strongest part of the analogy, I think: compare `([a, b]) => f()` and `[a, b] = f()`. In both cases, the LHS is not actually an expression.","mimetype":"text/plain"},{"body":"Well, the <code>a</code> in <code>a = expr</code> isnâ€™t an expression either, right? You could say that <code>=</code> is operating on <code>expr</code> but not <code>a</code> per se, since <code>a</code> is not an expression. Thatâ€™s the strongest part of the analogy, I think: compare <code>([a, b]) =&gt; f()</code> and <code>[a, b] = f()</code>. In both cases, the LHS is not actually an expression.","mimetype":"text/html"}]},"ts":1657258075937,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$dbR5LEDsJiOiIAZWG-6m_HUUU3VoIbahaNSICysgbkY"},
{"content":{"body":"`=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","format":"org.matrix.custom.html","formatted_body":"<code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/plain"},{"body":"<code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/html"}]},"ts":1657258137156,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo"},
{"content":{"body":" * `=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","format":"org.matrix.custom.html","formatted_body":" * <code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","m.new_content":{"body":"`=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","format":"org.matrix.custom.html","formatted_body":"<code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/plain"},{"body":"<code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * `=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/plain"},{"body":" * <code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments. But I feel less sure about when the RHS is a block.","mimetype":"text/html"}]},"ts":1657258163323,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$REVKYPdGEpU0pZq7ZzWflhetodRduWvAsARwdh0MH3Q"},
{"content":{"body":" * `=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. \n(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimple(r)â€. ğŸ˜…)","format":"org.matrix.custom.html","formatted_body":" * <code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimple(r)â€. ğŸ˜…)","m.new_content":{"body":"`=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. \n(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimple(r)â€. ğŸ˜…)","format":"org.matrix.custom.html","formatted_body":"<code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimple(r)â€. ğŸ˜…)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. \n(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimple(r)â€. ğŸ˜…)","mimetype":"text/plain"},{"body":"<code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimple(r)â€. ğŸ˜…)","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * `=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments. \n(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimple(r)â€. ğŸ˜…)","mimetype":"text/plain"},{"body":" * <code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimple(r)â€. ğŸ˜…)","mimetype":"text/html"}]},"ts":1657258264484,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$GEF04Orkpv0JMHRBm-nZszSB4uUpr9IsgQ0i356EheI"},
{"content":{"body":" * `=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments.\n(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€. ğŸ˜…)","format":"org.matrix.custom.html","formatted_body":" * <code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€. ğŸ˜…)","m.new_content":{"body":"`=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments.\n(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€. ğŸ˜…)","format":"org.matrix.custom.html","formatted_body":"<code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€. ğŸ˜…)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments.\n(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€. ğŸ˜…)","mimetype":"text/plain"},{"body":"<code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€. ğŸ˜…)","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * `=` â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that `=>` â€œoperatesâ€ on its RHS expression and not its LHS arguments.\n(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€. ğŸ˜…)","mimetype":"text/plain"},{"body":" * <code>=</code> â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that <code>=&gt;</code> â€œoperatesâ€ on its RHS expression and not its LHS arguments.<br>(But I do feel less sure about when the RHS is a block. And I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€. ğŸ˜…)","mimetype":"text/html"}]},"ts":1657258337497,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$UFA6z1k83MWJ4-Zzw2plpQOINUsnyp3zqD15sm7Baxs"},
{"content":{"body":"* = â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that => â€œoperatesâ€ on its RHS expression and not its LHS arguments. In `[x] = f()`, `=` â€œoperatesâ€ on `f()`, and, in `([x]) => f()`, `=>` â€œoperatesâ€ on `f()`. â€¨But I do feel less sure about when the RHS is a block. I guess that I would say that, in `([x]) => {}`, `=>` â€œoperatesâ€ on the empty block. Butâ€¦yeah. (Either way, I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€ and â€œconsistentâ€. ğŸ˜…)","format":"org.matrix.custom.html","formatted_body":"* = â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that =&gt; â€œoperatesâ€ on its RHS expression and not its LHS arguments. In <code>[x] = f()</code>, <code>=</code> â€œoperatesâ€ on <code>f()</code>, and, in <code>([x]) =&gt; f()</code>, <code>=&gt;</code> â€œoperatesâ€ on <code>f()</code>. â€¨But I do feel less sure about when the RHS is a block. I guess that I would say that, in <code>([x]) =&gt; {}</code>, <code>=&gt;</code> â€œoperatesâ€ on the empty block. Butâ€¦yeah. (Either way, I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€ and â€œconsistentâ€. ğŸ˜…)","m.new_content":{"body":"= â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that => â€œoperatesâ€ on its RHS expression and not its LHS arguments. In `[x] = f()`, `=` â€œoperatesâ€ on `f()`, and, in `([x]) => f()`, `=>` â€œoperatesâ€ on `f()`. â€¨But I do feel less sure about when the RHS is a block. I guess that I would say that, in `([x]) => {}`, `=>` â€œoperatesâ€ on the empty block. Butâ€¦yeah. (Either way, I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€ and â€œconsistentâ€. ğŸ˜…)","format":"org.matrix.custom.html","formatted_body":"= â€œoperatesâ€ on its RHS expression and not its LHS binding, and I suppose I would also say that =&gt; â€œoperatesâ€ on its RHS expression and not its LHS arguments. In <code>[x] = f()</code>, <code>=</code> â€œoperatesâ€ on <code>f()</code>, and, in <code>([x]) =&gt; f()</code>, <code>=&gt;</code> â€œoperatesâ€ on <code>f()</code>. â€¨But I do feel less sure about when the RHS is a block. I guess that I would say that, in <code>([x]) =&gt; {}</code>, <code>=&gt;</code> â€œoperatesâ€ on the empty block. Butâ€¦yeah. (Either way, I donâ€™t want to claim either that my personal mental model is the One True Way, of course, but at least itâ€™s â€œsimpleâ€ and â€œconsistentâ€. ğŸ˜…)","msgtype":"m.text"},"m.relates_to":{"event_id":"$tnBn2HiDs-tK1LlVuMDLI_n-qTI5Di_0vU9HThZqAHo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1657259839879,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$_4kCKnEaE9q5cf2JK9D4I90bZh9qdwIMs_rcovWLS0k"},
{"content":{"body":"I guess thereâ€™s something different about JavaScript that makes the line between operators and non-operator things less clear?\n\nI mean in the case of C++ at least, I feel like the set of things that are actually operators is quite clear and I think I understand it pretty well â€” because itâ€™s at least one part of the language thatâ€™s difficult for anybody to understand. But I could just be ignorant about some corner cases of C++ that Iâ€™m not familiar with","msgtype":"m.text","org.matrix.msc1767.text":"I guess thereâ€™s something different about JavaScript that makes the line between operators and non-operator things less clear?\n\nI mean in the case of C++ at least, I feel like the set of things that are actually operators is quite clear and I think I understand it pretty well â€” because itâ€™s at least one part of the language thatâ€™s difficult for anybody to understand. But I could just be ignorant about some corner cases of C++ that Iâ€™m not familiar with"},"ts":1657260002320,"senderName":"sideshowbarker","senderId":"@sideshowbarker:mozilla.org","id":"$dnmTkc2wF_jYeDtzk0KPeJJidVfsxQk_hBPw9b4QHmY"}
]