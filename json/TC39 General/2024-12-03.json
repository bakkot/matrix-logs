[
{"content":{"body":"Hi all, new guy here! \n\nI'm entertaining the idea of opening a proposal but wanted to get a feeling on how the community feels about the concept before I commit a weekend to writing it out - haha. \n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular \n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a feeling on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733202117924,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202156297,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$hB7QHZTHYrjJzhueaNe9NTtJ5CwgZTkWl0qOCxmzWkk"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `@jsx()` or anything, I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>@jsx()</code> or anything, I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `@jsx()` or anything, I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>@jsx()</code> or anything, I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202235863,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$wLm2Vf5MUd0mM8wPt-Arh2NPK7cosoxUlqv0AcU7rrE"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202302762,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ZRedKXhkwGPc9Z7Kiq_1UX-hrerGYcKwWRt3Aa1awww"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202425075,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$hbWTUAF_k5oRIdC_WWLir1aB9gx4uhGB7VoZsnunAyM"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202507765,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$R2egOMDaudRX7MQEZm5HI6b7gbkTIIpQMOVHjnCJEaA"},
{"content":{"body":"For the \"create a getter/setter\" example, that looks like it can be accomplished via a decorator https://github.com/tc39/proposal-decorators","format":"org.matrix.custom.html","formatted_body":"For the \"create a getter/setter\" example, that looks like it can be accomplished via a decorator https://github.com/tc39/proposal-decorators","msgtype":"m.text"},"ts":1733202732696,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$YS1oyU6-2eLnsz_o0yMq3suShUcJfURdsNTnjChAWX8"},
{"content":{"body":"Hi and welcome btw 👋🏻 ","format":"org.matrix.custom.html","formatted_body":"Hi and welcome btw 👋🏻 ","msgtype":"m.text"},"ts":1733203017299,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$-hsZG7LgHcWQ9x0gBQmRY0mix8BuV0lCzBfc4hYyFDU"},
{"content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733203363841,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203460592,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ki5TeYWhm3OoW9Zg04iKrf7N9fwD_z-BUalFS8yOrS4"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203548976,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$vf9voeEcvXEj6xgaVesIeRDTegyNQqKL_NUbyN26VSw"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203701106,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$OqhXdhw6cKq_KdZXbf57vaPBxYvfb-IeRkJtQ_b9718"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users, none defined in the language.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users, none defined in the language.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users, none defined in the language.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users, none defined in the language.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203750070,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$VBOftqiDPFb1rU9UFt04mBRe1cqa56Qi0xIe-WJnJJw"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203911416,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$QeW-U2LJm_SOzUjkg5Ld6DLxG8RqHtesAOzxjCQud6c"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733204056216,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$QT4wg76TvWGL3lZkGsuU_WogMkFnYfak63vQYKqAZMQ"}
]