[
{"content":{"body":"Hi all, new guy here! \n\nI'm entertaining the idea of opening a proposal but wanted to get a feeling on how the community feels about the concept before I commit a weekend to writing it out - haha. \n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular \n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a feeling on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733202117924,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202156297,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$hB7QHZTHYrjJzhueaNe9NTtJ5CwgZTkWl0qOCxmzWkk"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `@jsx()` or anything, I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>@jsx()</code> or anything, I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `@jsx()` or anything, I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>@jsx()</code> or anything, I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202235863,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$wLm2Vf5MUd0mM8wPt-Arh2NPK7cosoxUlqv0AcU7rrE"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202302762,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ZRedKXhkwGPc9Z7Kiq_1UX-hrerGYcKwWRt3Aa1awww"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202425075,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$hbWTUAF_k5oRIdC_WWLir1aB9gx4uhGB7VoZsnunAyM"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202507765,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$R2egOMDaudRX7MQEZm5HI6b7gbkTIIpQMOVHjnCJEaA"},
{"content":{"body":"For the \"create a getter/setter\" example, that looks like it can be accomplished via a decorator https://github.com/tc39/proposal-decorators","format":"org.matrix.custom.html","formatted_body":"For the \"create a getter/setter\" example, that looks like it can be accomplished via a decorator https://github.com/tc39/proposal-decorators","msgtype":"m.text"},"ts":1733202732696,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$YS1oyU6-2eLnsz_o0yMq3suShUcJfURdsNTnjChAWX8"},
{"content":{"body":"Hi and welcome btw 👋🏻 ","format":"org.matrix.custom.html","formatted_body":"Hi and welcome btw 👋🏻 ","msgtype":"m.text"},"ts":1733203017299,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$-hsZG7LgHcWQ9x0gBQmRY0mix8BuV0lCzBfc4hYyFDU"},
{"content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733203363841,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203460592,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ki5TeYWhm3OoW9Zg04iKrf7N9fwD_z-BUalFS8yOrS4"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203548976,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$vf9voeEcvXEj6xgaVesIeRDTegyNQqKL_NUbyN26VSw"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203701106,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$OqhXdhw6cKq_KdZXbf57vaPBxYvfb-IeRkJtQ_b9718"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users, none defined in the language.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users, none defined in the language.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users, none defined in the language.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users, none defined in the language.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203750070,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$VBOftqiDPFb1rU9UFt04mBRe1cqa56Qi0xIe-WJnJJw"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203911416,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$QeW-U2LJm_SOzUjkg5Ld6DLxG8RqHtesAOzxjCQud6c"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733204056216,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$QT4wg76TvWGL3lZkGsuU_WogMkFnYfak63vQYKqAZMQ"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733204183223,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ntYnX3jmArimyk-Qw9Xw9R4bvfGVOu-58sEeX-hBC08"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n- Web wasm frameworks [[1]](https://yew.rs/) [[2]](https://leptos.dev/)\n- Native desktop frameworks [[1]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [[2]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n- Web wasm frameworks [[1]](https://yew.rs/) [[2]](https://leptos.dev/)\n- Native desktop frameworks [[1]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [[2]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733204475645,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$HOohLyJ9uti76S6j-iSybbL2KeWX4VYyIyYIrlbjkoU"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n\n- Web wasm frameworks [\\[1\\]](https://yew.rs/) [\\[2\\]](https://leptos.dev/)\n- Native desktop frameworks [\\[1\\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\\[2\\]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n\n- Web wasm frameworks [\\[1\\]](https://yew.rs/) [\\[2\\]](https://leptos.dev/)\n- Native desktop frameworks [\\[1\\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\\[2\\]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733204539644,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$MN9nEHJnIsvEVKFPuAqDMuJvUUkDQxAee1SWh53QL38"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n\n- Web wasm frameworks [\\[1\\]](https://yew.rs/) [\\[2\\]](https://leptos.dev/)\n- Native desktop frameworks [\\[1\\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\\[2\\]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n\n- Web wasm frameworks [\\[1\\]](https://yew.rs/) [\\[2\\]](https://leptos.dev/)\n- Native desktop frameworks [\\[1\\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\\[2\\]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733205475701,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$aXxGHSrfPcQTffBJqYAn-jAnFuK-X5Qsg2YUVPFFBxk"},
{"content":{"body":"I am curious how things like auto-complete and refactoring work within Rust macros. These both sound easier for tooling to implement when the language extension is concrete, instead of being defined as a macro.","format":"org.matrix.custom.html","formatted_body":"I am curious how things like auto-complete and refactoring work within Rust macros. These both sound easier for tooling to implement when the language extension is concrete, instead of being defined as a macro.","msgtype":"m.text"},"ts":1733205531375,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$hBJRni6BXQXk1eDWBnpJY9oqmVLcCOp5Mh0zcKO57DU"},
{"content":{"body":"For autocomplete, the LSP expands the macro and uses the output\n```javascript\nconst foo = add!(1, 1)\n```\nWould expand into\n```javascript\nconst foo = 2\n```\nSo consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.\n\nAs for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax. \n\nThe editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.\n\nImplementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro","format":"org.matrix.custom.html","formatted_body":"<p>For autocomplete, the LSP expands the macro and uses the output</p>\n<pre><code class=\"language-javascript\">const foo = add!(1, 1)\n</code></pre>\n<p>Would expand into</p>\n<pre><code class=\"language-javascript\">const foo = 2\n</code></pre>\n<p>So consumers see it as a <code>number</code> rather than a macro. It simply replaces itself with the transformed result.</p>\n<p>As for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.</p>\n<p>The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.</p>\n<p>Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733206871512,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ylf2kKnfXA1CZreB2qzaNyvbvD73g5DZLBIrhdRdU24"},
{"content":{"body":" * For autocomplete, the LSP expands the macro and uses the output\n\n```javascript\nconst foo = add!(1, 1)\n```\n\nWould expand into\n\n```javascript\nconst foo = 2\n```\n\nSo consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.\n\nAs for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.\n\nThe editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.\n\nImplementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro","format":"org.matrix.custom.html","formatted_body":" * <p>For autocomplete, the LSP expands the macro and uses the output</p>\n<pre><code class=\"language-javascript\">const foo = add!(1, 1)\n</code></pre>\n<p>Would expand into</p>\n<pre><code class=\"language-javascript\">const foo = 2\n</code></pre>\n<p>So consumers see it as a <code>number</code> rather than a macro. It simply replaces itself with the transformed result.</p>\n<p>As for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.</p>\n<p>The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.</p>\n<p>Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro</p>\n","m.mentions":{},"m.new_content":{"body":"For autocomplete, the LSP expands the macro and uses the output\n\n```javascript\nconst foo = add!(1, 1)\n```\n\nWould expand into\n\n```javascript\nconst foo = 2\n```\n\nSo consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.\n\nAs for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.\n\nThe editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.\n\nImplementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro","format":"org.matrix.custom.html","formatted_body":"<p>For autocomplete, the LSP expands the macro and uses the output</p>\n<pre><code class=\"language-javascript\">const foo = add!(1, 1)\n</code></pre>\n<p>Would expand into</p>\n<pre><code class=\"language-javascript\">const foo = 2\n</code></pre>\n<p>So consumers see it as a <code>number</code> rather than a macro. It simply replaces itself with the transformed result.</p>\n<p>As for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.</p>\n<p>The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.</p>\n<p>Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$ylf2kKnfXA1CZreB2qzaNyvbvD73g5DZLBIrhdRdU24","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733206890686,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$nC6EO2UQFGZsfvr1Xk77Ssm8lb4SmK8QzEFsdLEGl-Y"},
{"content":{"body":"For auto-complete, when the macro is expanded, how is the IDE cursor position preserved?","format":"org.matrix.custom.html","formatted_body":"For auto-complete, when the macro is expanded, how is the IDE cursor position preserved?","msgtype":"m.text"},"ts":1733207510199,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$kGaP2Y2ztfYlvZQCSbGrHOxiq8hkSY__zCpXazjrh50"},
{"content":{"body":"the position could expand to a much larger block of code ","format":"org.matrix.custom.html","formatted_body":"the position could expand to a much larger block of code ","msgtype":"m.text"},"ts":1733207556884,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$5DBgGZOYIHyrHaYpMMoqxum7cX3gfTy8HihwbQLUvbo"},
{"content":{"body":"the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete ","format":"org.matrix.custom.html","formatted_body":"the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete ","msgtype":"m.text"},"ts":1733207669276,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$x7Od7Fg4jRisOKC4qz0ZhSTw8k7mpHZufGHT9QEraGM"},
{"content":{"body":"> These both sound easier for tooling to implement when the language extension is concrete\n\nMacros are more of a preprocessing step rather than dynamic functionality (like decorators) - but there's a chicken and egg problem. \n\nThe best supported illustration of macros in tooling is the built-in transformation of jsx in TypeScript. There are many GitHub issues requesting to expand this to offer custom programmatic macros however it's has been deemed out of scope.\n\nAttempts by other toolmakers to implement the functionality that macros offer have resulted in fragmented, brittle implementations (.vue files and .svelte files - custom tooling, editor plugins and poor support for test runners, linters, formatters, etc). \n\nDecorators also feel like an attempt at addressing the same problem albeit at runtime.\n\nAfter spending some time in the Rust world, I personally feel that there is evidence that ES world shows a need for this type of functionality","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>These both sound easier for tooling to implement when the language extension is concrete</p>\n</blockquote>\n<p>Macros are more of a preprocessing step rather than dynamic functionality (like decorators) - but there's a chicken and egg problem.</p>\n<p>The best supported illustration of macros in tooling is the built-in transformation of jsx in TypeScript. There are many GitHub issues requesting to expand this to offer custom programmatic macros however it's has been deemed out of scope.</p>\n<p>Attempts by other toolmakers to implement the functionality that macros offer have resulted in fragmented, brittle implementations (.vue files and .svelte files - custom tooling, editor plugins and poor support for test runners, linters, formatters, etc).</p>\n<p>Decorators also feel like an attempt at addressing the same problem albeit at runtime.</p>\n<p>After spending some time in the Rust world, I personally feel that there is evidence that ES world shows a need for this type of functionality</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733207886853,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$GjuWz88kEkG0Rq3LGKr9qxZRa7zoVe6qpDlCGydYuUg"},
{"content":{"body":"> the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete \n\nIt's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent ","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete</p>\n</blockquote>\n<p>It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733208037041,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$P7W_ayk6sGOmg99iVdsZS1q5YlsSjR_tVmrmpZp1evI"},
{"content":{"body":" * > the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete\n\nIt's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent\n\nThat said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete</p>\n</blockquote>\n<p>It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent</p>\n<p>That said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue</p>\n","m.mentions":{},"m.new_content":{"body":"> the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete\n\nIt's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent\n\nThat said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete</p>\n</blockquote>\n<p>It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent</p>\n<p>That said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$P7W_ayk6sGOmg99iVdsZS1q5YlsSjR_tVmrmpZp1evI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733208086548,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$1KVfZXg8pew4-NTNZyA0Ot1VLLo1ef9NliclChn0BWg"},
{"content":{"body":" * > the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete\n\nIt's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor, like they do with jsx), where the emitted runtime code would be the static JavaScript equivalent\n\nThat said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete</p>\n</blockquote>\n<p>It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor, like they do with jsx), where the emitted runtime code would be the static JavaScript equivalent</p>\n<p>That said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue</p>\n","m.mentions":{},"m.new_content":{"body":"> the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete\n\nIt's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor, like they do with jsx), where the emitted runtime code would be the static JavaScript equivalent\n\nThat said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete</p>\n</blockquote>\n<p>It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor, like they do with jsx), where the emitted runtime code would be the static JavaScript equivalent</p>\n<p>That said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$P7W_ayk6sGOmg99iVdsZS1q5YlsSjR_tVmrmpZp1evI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733208127899,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$impciccfvyhaewYOl8cUlSsSL5uy0T5yxgyoLzcrihg"},
{"content":{"body":"I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed","format":"org.matrix.custom.html","formatted_body":"I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed","msgtype":"m.text"},"ts":1733208138701,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$SShYypDw_lVXvMbjA9hJS-fJhjNh6DPUfebiobUsK_M"},
{"content":{"body":"Unlike with Rust macros where the compiler naturally understands how to execute Rust","format":"org.matrix.custom.html","formatted_body":"Unlike with Rust macros where the compiler naturally understands how to execute Rust","msgtype":"m.text"},"ts":1733208183864,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$USg4nO0-KP7FfV3PI4kf7pce2ncMP1OLrEPEjjykdUk"},
{"content":{"body":"> I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed\n\nHaha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like [QuickJS](https://bellard.org/quickjs/) and [llrt](https://github.com/awslabs/llrt) for macros that don't use nodejs functionality","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed</p>\n</blockquote>\n<p>Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like <a href=\"https://bellard.org/quickjs/\">QuickJS</a> and <a href=\"https://github.com/awslabs/llrt\">llrt</a> for macros that don't use nodejs functionality</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733208338773,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$w2JWUHhSW5-qBXQBr_b3aQtKREBqOkDfe_a3_RbIGDo"},
{"content":{"body":" * > I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed\n\nHaha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality ","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed</p>\n</blockquote>\n<p>Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like embedding Deno, <a href=\"https://bellard.org/quickjs/\">QuickJS</a> or <a href=\"https://github.com/awslabs/llrt\">llrt</a> for macros that don't use niche nodejs functionality</p>\n","m.mentions":{},"m.new_content":{"body":"> I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed\n\nHaha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality ","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed</p>\n</blockquote>\n<p>Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like embedding Deno, <a href=\"https://bellard.org/quickjs/\">QuickJS</a> or <a href=\"https://github.com/awslabs/llrt\">llrt</a> for macros that don't use niche nodejs functionality</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$w2JWUHhSW5-qBXQBr_b3aQtKREBqOkDfe_a3_RbIGDo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733208401025,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$YWDKwB5TGDoRRCVwjhxqTmngMH-VUr9tOLggGdLQVss"},
{"content":{"body":" * > I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed\n\nHaha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).\n \nThere are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed</p>\n</blockquote>\n<p>Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).</p>\n<p>There are also options like embedding Deno, <a href=\"https://bellard.org/quickjs/\">QuickJS</a> or <a href=\"https://github.com/awslabs/llrt\">llrt</a> for macros that don't use niche nodejs functionality</p>\n","m.mentions":{},"m.new_content":{"body":"> I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed\n\nHaha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).\n \nThere are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed</p>\n</blockquote>\n<p>Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).</p>\n<p>There are also options like embedding Deno, <a href=\"https://bellard.org/quickjs/\">QuickJS</a> or <a href=\"https://github.com/awslabs/llrt\">llrt</a> for macros that don't use niche nodejs functionality</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$w2JWUHhSW5-qBXQBr_b3aQtKREBqOkDfe_a3_RbIGDo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733208633217,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$DcBXSf5nbTlubAnPxHaTYrW80usB5I6bCGJWbMllqP0"},
{"content":{"body":"Also, I really appreciate you entertaining this idea and asking such great questions 🙂","m.mentions":{},"msgtype":"m.text"},"ts":1733208710383,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$eQwrJgQ21NLfx_Q0bLXc8CrBZhgECbVa6COEtPT2BTA"},
{"content":{"body":"> For auto-complete, when the macro is expanded, how is the IDE cursor position preserved?\n\nIf I get to the point where a proposal is actually on the cards, I will certainly dig deeper into how Rust does this to provide a clearer answer","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>For auto-complete, when the macro is expanded, how is the IDE cursor position preserved?</p>\n</blockquote>\n<p>If I get to the point where a proposal is actually on the cards, I will certainly dig deeper into how Rust does this to provide a clearer answer</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733208787967,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$TDy2izEKzBKGhoAC-CIQF_FfPZ8LsDrmPLVj0hv3xsU"},
{"content":{"body":" * > These both sound easier for tooling to implement when the language extension is concrete\n\nMacros are more of a preprocessing step rather than dynamic functionality (like decorators) - but there's a chicken and egg problem.\n\nThe best supported illustration of macros in tooling is the built-in transformation of jsx in TypeScript. There are many GitHub issues requesting to expand this to offer custom programmatic macros however it's has been deemed out of scope.\n\nAttempts by other toolmakers to implement the functionality that macros offer have resulted in fragmented, brittle implementations (.vue files and .svelte files - custom tooling, editor plugins and poor support for test runners, linters, formatters, etc).\n\nDecorators also feel like an attempt at addressing the same problem albeit at runtime.\n\nAfter spending some time in the Rust world, I personally feel that there is evidence that the ES world shows a need for this type of functionality","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>These both sound easier for tooling to implement when the language extension is concrete</p>\n</blockquote>\n<p>Macros are more of a preprocessing step rather than dynamic functionality (like decorators) - but there's a chicken and egg problem.</p>\n<p>The best supported illustration of macros in tooling is the built-in transformation of jsx in TypeScript. There are many GitHub issues requesting to expand this to offer custom programmatic macros however it's has been deemed out of scope.</p>\n<p>Attempts by other toolmakers to implement the functionality that macros offer have resulted in fragmented, brittle implementations (.vue files and .svelte files - custom tooling, editor plugins and poor support for test runners, linters, formatters, etc).</p>\n<p>Decorators also feel like an attempt at addressing the same problem albeit at runtime.</p>\n<p>After spending some time in the Rust world, I personally feel that there is evidence that the ES world shows a need for this type of functionality</p>\n","m.mentions":{},"m.new_content":{"body":"> These both sound easier for tooling to implement when the language extension is concrete\n\nMacros are more of a preprocessing step rather than dynamic functionality (like decorators) - but there's a chicken and egg problem.\n\nThe best supported illustration of macros in tooling is the built-in transformation of jsx in TypeScript. There are many GitHub issues requesting to expand this to offer custom programmatic macros however it's has been deemed out of scope.\n\nAttempts by other toolmakers to implement the functionality that macros offer have resulted in fragmented, brittle implementations (.vue files and .svelte files - custom tooling, editor plugins and poor support for test runners, linters, formatters, etc).\n\nDecorators also feel like an attempt at addressing the same problem albeit at runtime.\n\nAfter spending some time in the Rust world, I personally feel that there is evidence that the ES world shows a need for this type of functionality","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>These both sound easier for tooling to implement when the language extension is concrete</p>\n</blockquote>\n<p>Macros are more of a preprocessing step rather than dynamic functionality (like decorators) - but there's a chicken and egg problem.</p>\n<p>The best supported illustration of macros in tooling is the built-in transformation of jsx in TypeScript. There are many GitHub issues requesting to expand this to offer custom programmatic macros however it's has been deemed out of scope.</p>\n<p>Attempts by other toolmakers to implement the functionality that macros offer have resulted in fragmented, brittle implementations (.vue files and .svelte files - custom tooling, editor plugins and poor support for test runners, linters, formatters, etc).</p>\n<p>Decorators also feel like an attempt at addressing the same problem albeit at runtime.</p>\n<p>After spending some time in the Rust world, I personally feel that there is evidence that the ES world shows a need for this type of functionality</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$GjuWz88kEkG0Rq3LGKr9qxZRa7zoVe6qpDlCGydYuUg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733208923177,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$JrdcCnqDPydO1KP6UlDb8arZbSy1jIHP_llD3jjf-Ps"},
{"content":{"body":" * > I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed\n\nHaha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).\n\nThere are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality\n\nAlternatively, if macros are defined using a templating syntax (like callable macros in Rust) then an interpreter could be written (or taken directly from an existing JS engine) and run entirely in Rust [example](https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming)","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed</p>\n</blockquote>\n<p>Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).</p>\n<p>There are also options like embedding Deno, <a href=\"https://bellard.org/quickjs/\">QuickJS</a> or <a href=\"https://github.com/awslabs/llrt\">llrt</a> for macros that don't use niche nodejs functionality</p>\n<p>Alternatively, if macros are defined using a templating syntax (like callable macros in Rust) then an interpreter could be written (or taken directly from an existing JS engine) and run entirely in Rust <a href=\"https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming\">example</a></p>\n","m.mentions":{},"m.new_content":{"body":"> I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed\n\nHaha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).\n\nThere are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality\n\nAlternatively, if macros are defined using a templating syntax (like callable macros in Rust) then an interpreter could be written (or taken directly from an existing JS engine) and run entirely in Rust [example](https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming)","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed</p>\n</blockquote>\n<p>Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).</p>\n<p>There are also options like embedding Deno, <a href=\"https://bellard.org/quickjs/\">QuickJS</a> or <a href=\"https://github.com/awslabs/llrt\">llrt</a> for macros that don't use niche nodejs functionality</p>\n<p>Alternatively, if macros are defined using a templating syntax (like callable macros in Rust) then an interpreter could be written (or taken directly from an existing JS engine) and run entirely in Rust <a href=\"https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming\">example</a></p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$w2JWUHhSW5-qBXQBr_b3aQtKREBqOkDfe_a3_RbIGDo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733209597379,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$zGJ2x73xvwtxoKk5XiOdmtRo0hBVMpNqDx_r_aPOvBI"},
{"content":{"body":" * > I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed\n\nCalling into Nodejs is not as fast as running Rust native code directly and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (can do hundreds of millions of nodejs calls per second).\n\nThere are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality\n\nIf callable macros are defined using a templating syntax (like in Rust) then an interpreter could be written (or borrowed directly from an existing JS engine) and run entirely in Rust [example](https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming)","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed</p>\n</blockquote>\n<p>Calling into Nodejs is not as fast as running Rust native code directly and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (can do hundreds of millions of nodejs calls per second).</p>\n<p>There are also options like embedding Deno, <a href=\"https://bellard.org/quickjs/\">QuickJS</a> or <a href=\"https://github.com/awslabs/llrt\">llrt</a> for macros that don't use niche nodejs functionality</p>\n<p>If callable macros are defined using a templating syntax (like in Rust) then an interpreter could be written (or borrowed directly from an existing JS engine) and run entirely in Rust <a href=\"https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming\">example</a></p>\n","m.mentions":{},"m.new_content":{"body":"> I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed\n\nCalling into Nodejs is not as fast as running Rust native code directly and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (can do hundreds of millions of nodejs calls per second).\n\nThere are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality\n\nIf callable macros are defined using a templating syntax (like in Rust) then an interpreter could be written (or borrowed directly from an existing JS engine) and run entirely in Rust [example](https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming)","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed</p>\n</blockquote>\n<p>Calling into Nodejs is not as fast as running Rust native code directly and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (can do hundreds of millions of nodejs calls per second).</p>\n<p>There are also options like embedding Deno, <a href=\"https://bellard.org/quickjs/\">QuickJS</a> or <a href=\"https://github.com/awslabs/llrt\">llrt</a> for macros that don't use niche nodejs functionality</p>\n<p>If callable macros are defined using a templating syntax (like in Rust) then an interpreter could be written (or borrowed directly from an existing JS engine) and run entirely in Rust <a href=\"https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming\">example</a></p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$w2JWUHhSW5-qBXQBr_b3aQtKREBqOkDfe_a3_RbIGDo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733209732547,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$d01wwMGrRbUpksFcybk5pFsI5HATh9Aj0XyzE423ouE"},
{"content":{"body":"rust macros have some really unfortunate limitations tho - in particular, it seems they can't handle anywhere close to the level of expressiveness and dynamism i'd expect coming from JS","m.mentions":{},"msgtype":"m.text"},"ts":1733211126686,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$B2JBSa8G2voWPRANNET-CevWpPfgteobub0v525rDGw"},
{"content":{"body":"there are two kinds of rust macros; for the cases where the normal macros aren't expressive enough, you can write a procedural macro to literally bypass the parser and operate on a stream of tokens from the lexer","m.mentions":{},"msgtype":"m.text"},"ts":1733245108857,"senderName":"ptomato","senderId":"@pchimento:igalia.com","id":"$-6ym8XX5V3XcgcRHNAX6YqWGiGwgtYBPfsZZ1r6SBeQ"},
{"content":{"body":"(and the JS equivalent of _that_ starts to sound like https://github.com/tc39/proposal-binary-ast)","format":"org.matrix.custom.html","formatted_body":"(and the JS equivalent of <em>that</em> starts to sound like https://github.com/tc39/proposal-binary-ast)","m.mentions":{},"msgtype":"m.text"},"ts":1733245148856,"senderName":"ptomato","senderId":"@pchimento:igalia.com","id":"$_kjScVlQEEXT81f7IN0YP_fIU99rzaVOANzqOXRz7_4"},
{"content":{"body":"and even with that i still haven't been able to get what i want to do, done :-/ i'm sure it's a mix of lacking capability in both self and language","m.mentions":{},"msgtype":"m.text"},"ts":1733245349670,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$arjekTlrbctYR6qV7Pj0RDRtyBMzZVVOHkXkmXKj77o"},
{"content":{"body":"what haven't you been able to do with proc macros?","m.mentions":{},"msgtype":"m.text"},"ts":1733245402832,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$GHniF0zLuTSOezPRbqVdKueGIlE6LbbYZOfqf1y7JrU"},
{"content":{"body":"David Alsh: macros in the language mean moving complexity and build time from the developer's computer to the user's computer, which I think is very negative","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@alshdavid:matrix.org\">David Alsh</a>: macros in the language mean moving complexity and build time from the developer's computer to the user's computer, which I think is very negative","m.mentions":{"user_ids":["@alshdavid:matrix.org"]},"msgtype":"m.text"},"ts":1733245546664,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$QKjYwhDot2P5k9HU3SMd_1yaeanVEtlaKIpeEH7Q22A"},
{"content":{"body":"as a developer it's obviously appealing, but in terms of its effects on the world I think it would be very bad","m.mentions":{},"msgtype":"m.text"},"ts":1733245559577,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$vNedKE-SamgvtpGVpyoZIwlW52VmdwhYxT4KevPnprA"},
{"content":{"body":"Proc macros can generate arbitrary Rust code by executing arbitrary Rust code taking arbitrary lexer tokens as inputs. They are turing complete - there is nothing they can not do","format":"org.matrix.custom.html","formatted_body":"Proc macros can generate arbitrary Rust code by executing arbitrary Rust code taking arbitrary lexer tokens as inputs. They are turing complete - there is nothing they can not do","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$arjekTlrbctYR6qV7Pj0RDRtyBMzZVVOHkXkmXKj77o"}},"msgtype":"m.text"},"ts":1733245570720,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$BbA6X-qzyvLs1_MdrcFuN_9u-4R5n4PD3Arr6gImyi0"},
{"content":{"body":"they can't properly attribute error locations :P","m.mentions":{},"msgtype":"m.text"},"ts":1733245678443,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$arDnYYWus2g-1jjUvZjba1ALBZM76_rE_kEJiWL0oYA"},
{"content":{"body":"They can in nightly :D","m.mentions":{},"msgtype":"m.text"},"ts":1733245688623,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$iYZASp04iYnCH7mxgcJRNBFv7sSQQ3flyhI9Kf7NLgA"},
{"content":{"body":"> <@lucacasonato:matrix.org> Proc macros can generate arbitrary Rust code by executing arbitrary Rust code taking arbitrary lexer tokens as inputs. They are turing complete - there is nothing they can not do\n\nthere's a ton of things that Turing machines cannot do","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq%3Amatrix.org/%24BbA6X-qzyvLs1_MdrcFuN_9u-4R5n4PD3Arr6gImyi0\">In reply to</a><a href=\"https://matrix.to/#/%40lucacasonato%3Amatrix.org\">@lucacasonato:matrix.org</a><br />Proc macros can generate arbitrary Rust code by executing arbitrary Rust code taking arbitrary lexer tokens as inputs. They are turing complete - there is nothing they can not do</blockquote></mx-reply>there&#39;s a ton of things that Turing machines cannot do","m.relates_to":{"m.in_reply_to":{"event_id":"$BbA6X-qzyvLs1_MdrcFuN_9u-4R5n4PD3Arr6gImyi0"}},"msgtype":"m.text"},"ts":1733245700627,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$HodMjN61PXWOmgCEVC1vV00cnJGvd_dxwQcxA3dhx0c"},
{"content":{"body":"Sure. Then more accurately: they have all the same capabilities as any other Rust program (because they are a special kind of Rust program)","format":"org.matrix.custom.html","formatted_body":"Sure. Then more accurately: they have all the same capabilities as any other Rust program (because they are a special kind of Rust program)","m.mentions":{"user_ids":["@michaelficarra:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$HodMjN61PXWOmgCEVC1vV00cnJGvd_dxwQcxA3dhx0c"}},"msgtype":"m.text"},"ts":1733245752180,"senderName":"Luca Casonato","senderId":"@lucacasonato:matrix.org","id":"$YSzG0_lImVnqqrh3jzBVYCfIASB0fiCDHGqJ4N8hicE"},
{"content":{"body":"then that probably means that rust's type system can't do what i want 🙎‍♂️","format":"org.matrix.custom.html","formatted_body":"then that probably means that rust's type system can't do what i want 🙎‍♂️","m.mentions":{"user_ids":["@lucacasonato:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$BbA6X-qzyvLs1_MdrcFuN_9u-4R5n4PD3Arr6gImyi0"}},"msgtype":"m.text"},"ts":1733245796252,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$h3ghu8jKhDwpygfWmiO-dz9ewkjQRzWgSvzWf3vYhUw"},
{"content":{"body":" * then that probably means that rust's type system can't do what i want :-p","format":"org.matrix.custom.html","formatted_body":" * then that probably means that rust's type system can't do what i want :-p","m.mentions":{},"m.new_content":{"body":"then that probably means that rust's type system can't do what i want :-p","format":"org.matrix.custom.html","formatted_body":"then that probably means that rust's type system can't do what i want :-p","m.mentions":{"user_ids":["@lucacasonato:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$h3ghu8jKhDwpygfWmiO-dz9ewkjQRzWgSvzWf3vYhUw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733245807062,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$rX1N4YLoF6YfJ0f3SiaVWs8pY8bQUZ1HWYw7eBx6M6w"},
{"content":{"body":"I started looking at code generation (like C#) before to see how it could function in JS and it has similar issues as it moves what might be build-time to the user's computer which as mentioned is contentious.","m.mentions":{},"msgtype":"m.text"},"ts":1733248107292,"senderName":"sirisian","senderId":"@sirisian:matrix.org","id":"$noJPTRu4FkfY3icjjOsIbt_EHegcBUpMOVAQbx2XTXI"},
{"content":{"body":"Hey all, just doing some sketching out on a proposal for a `Promise.lazy(fn)` API (https://github.com/jasnell/proposal-promise-lazy) ... the idea is to simplify a pattern that is currently possible to do with custom thenables with a fair amount of boilerplate. This is very early and not yet ready for in committee discussion but I'd like to invite folks to take a look at provide early feedback. I'll likely raise it for in-committee discussion for the next scheduled plenary","format":"org.matrix.custom.html","formatted_body":"Hey all, just doing some sketching out on a proposal for a <code>Promise.lazy(fn)</code> API (https://github.com/jasnell/proposal-promise-lazy) ... the idea is to simplify a pattern that is currently possible to do with custom thenables with a fair amount of boilerplate. This is very early and not yet ready for in committee discussion but I'd like to invite folks to take a look at provide early feedback. I'll likely raise it for in-committee discussion for the next scheduled plenary","m.mentions":{},"msgtype":"m.text"},"ts":1733259663245,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$mu3LpbOSaOHnuYBm0gZjhQ-99E6g7MyTLBMQslPfrU0"},
{"content":{"body":"> <@jasnell:matrix.org> Hey all, just doing some sketching out on a proposal for a `Promise.lazy(fn)` API (https://github.com/jasnell/proposal-promise-lazy) ... the idea is to simplify a pattern that is currently possible to do with custom thenables with a fair amount of boilerplate. This is very early and not yet ready for in committee discussion but I'd like to invite folks to take a look at provide early feedback. I'll likely raise it for in-committee discussion for the next scheduled plenary\n\nneat","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$mu3LpbOSaOHnuYBm0gZjhQ-99E6g7MyTLBMQslPfrU0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jasnell:matrix.org\">@jasnell:matrix.org</a><br>Hey all, just doing some sketching out on a proposal for a <code>Promise.lazy(fn)</code> API (https://github.com/jasnell/proposal-promise-lazy) ... the idea is to simplify a pattern that is currently possible to do with custom thenables with a fair amount of boilerplate. This is very early and not yet ready for in committee discussion but I'd like to invite folks to take a look at provide early feedback. I'll likely raise it for in-committee discussion for the next scheduled plenary</blockquote></mx-reply>neat","m.mentions":{"user_ids":["@jasnell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$mu3LpbOSaOHnuYBm0gZjhQ-99E6g7MyTLBMQslPfrU0"}},"msgtype":"m.text"},"ts":1733260563140,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$iJVJ-R6qRpgdByk6nbqQjKwm65YRMoq49bdLFT3YFzg"},
{"content":{"body":"one thing to consider: `Promise.resolve` (which is also used in the `await` syntax) has a special case for \"real\" promises (which works by checking the `.constructor` property), and you'd need to consider whether this would count","format":"org.matrix.custom.html","formatted_body":"one thing to consider: <code>Promise.resolve</code> (which is also used in the <code>await</code> syntax) has a special case for \"real\" promises (which works by checking the <code>.constructor</code> property), and you'd need to consider whether this would count","m.mentions":{},"msgtype":"m.text"},"ts":1733260718300,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$3nxufqngPyHwNfamCDhZh2YepUVHfZsdCrb27jGR00E"},
{"content":{"body":"I am pretty sure this is a not going to be acceptable to some delegates, including us. Promises are one-way, and I don't want them to grow a back channel","m.mentions":{},"msgtype":"m.text"},"ts":1733260731942,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$G3Rg6EfzwAhY-fpRPAMCWBvN_7bOaTZq0VM_lcj7Fls"},
{"content":{"body":"> <@mhofman:matrix.org> I am pretty sure this is a not going to be acceptable to some delegates, including us. Promises are one-way, and I don't want them to grow a back channel\n\nit's not adding them to actual promises","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$G3Rg6EfzwAhY-fpRPAMCWBvN_7bOaTZq0VM_lcj7Fls?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I am pretty sure this is a not going to be acceptable to some delegates, including us. Promises are one-way, and I don&#39;t want them to grow a back channel</blockquote></mx-reply>it's not adding them to actual promises","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$G3Rg6EfzwAhY-fpRPAMCWBvN_7bOaTZq0VM_lcj7Fls"}},"msgtype":"m.text"},"ts":1733260763818,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$FgWu3T9-GliY3B9jyRXtlXPSiRIYnlMxfHk-I9YhPQ8"},
{"content":{"body":"it's making a new kind of thenable, which you could already do in userland","m.mentions":{},"msgtype":"m.text"},"ts":1733260769903,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$n9jz5QIZXDh8gIFnP4aspCNiHlgmbhqfuES9vubSQCA"},
{"content":{"body":"We actually go through a great extent to protect against promises with a custom then or then getter in our environment.","m.mentions":{},"msgtype":"m.text"},"ts":1733260794096,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$M5i4I2xH1wBnY3cRYHk42rgjoZx8xyXIYrVF4WwE9ZE"},
{"content":{"body":"Right, nothing prevents anyone from making a new thenable, but that's not a promise","m.mentions":{},"msgtype":"m.text"},"ts":1733260852003,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$iPwOg9ieWMOpZk86EchiD2-VkWYCCcWy3FXWUdU_4p0"},
{"content":{"body":"well, ok, call it LazyPromise and make it a subclass instead of `Promise.lazy` then","format":"org.matrix.custom.html","formatted_body":"well, ok, call it LazyPromise and make it a subclass instead of <code>Promise.lazy</code> then","m.mentions":{},"msgtype":"m.text"},"ts":1733260876270,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$tai1B5V3L3rNrbEvRZ8KdhF_GMA7GfUnGL9mzHEShiA"},
{"content":{"body":"that seems like a stage 2 concern","m.mentions":{},"msgtype":"m.text"},"ts":1733260882004,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$mffx6bE1l838GEtB9OBQz0BaeaVKSkmq4s7x9WhczWE"},
{"content":{"body":"`Promise.resolve()` which is extensively used to check if something is a promise would trigger the laziness","format":"org.matrix.custom.html","formatted_body":"<code>Promise.resolve()</code> which is extensively used to check if something is a promise would trigger the laziness","m.mentions":{},"msgtype":"m.text"},"ts":1733260898226,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CziH5GWyPG_dK0eqjyXYQP0yVFUhKlxBle5X3Grfwx0"},
{"content":{"body":"¯\\_(ツ)_/¯ seems fine","m.mentions":{},"msgtype":"m.text"},"ts":1733260957356,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BR7Jyyf3oQgTyRTjzJntaFcW1-6Y2-8DjwKKdePYwj8"},
{"content":{"body":"I very much contest \"extensively\" though","m.mentions":{},"msgtype":"m.text"},"ts":1733260974481,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cYVePYZeTg2460sfJBsKiP0Jg5eIXGPAkXATxo43HVY"},
{"content":{"body":"I would buy \"extensively in our extremely unusual codebase\"","m.mentions":{},"msgtype":"m.text"},"ts":1733260982573,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$WpLiX7P2EChFpJuAqzzJP93EpFMWaBCpa24SIBiFCfM"},
{"content":{"body":"Right I might have a miopic vision here.","m.mentions":{},"msgtype":"m.text"},"ts":1733261007374,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$nI_PLmOrNx4yijuvgKCNjHMtC_TdPmx7F44_pCeZYLM"},
{"content":{"body":"`await` does feel like the wrong place to start work","format":"org.matrix.custom.html","formatted_body":"<code>await</code> does feel like the wrong place to start work","m.mentions":{},"msgtype":"m.text"},"ts":1733261026872,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$1KD4mRjAbBHSL1d0FuV34j5LkFBOAgSf64tW9TxV3pc"},
{"content":{"body":"fwiw that's how it works in Rust and it's fine","m.mentions":{},"msgtype":"m.text"},"ts":1733261045164,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$FQQ6QusEIyC96x0RPXa8HaIQ4Sc1O9tD17O2VNX5Cos"},
{"content":{"body":"Well, to be clear, per the proposal, the work is not started on the `await` (or the .then call). The actual work is deferred as a microtask.","format":"org.matrix.custom.html","formatted_body":"Well, to be clear, per the proposal, the work is not started on the <code>await</code> (or the .then call). The actual work is deferred as a microtask.","m.mentions":{},"msgtype":"m.text"},"ts":1733261099783,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$1C4bHCzaOSoN0sX4QvSvVGOdY9B_eZxbpfRS9czDi20"},
{"content":{"body":"oh I jumped to the wrong assumption","m.mentions":{},"msgtype":"m.text"},"ts":1733261126640,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$e9mmsb0dCxaOK87wlsI1xc1q1b9bk8sRtvB2YF9ys6Q"},
{"content":{"body":"Mathieu Hofman: ... I get the objection... if these were brand-checkable would that make a difference to you? e.g. something like `const p = Promise.lazy(...); if (Promise.isLazy(p) { ... }` ","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>: ... I get the objection... if these were brand-checkable would that make a difference to you? e.g. something like <code>const p = Promise.lazy(...); if (Promise.isLazy(p) { ... }</code>","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"msgtype":"m.text"},"ts":1733261162369,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$jT-QUWz6ZHMpmKCGg2NQnvNQ8DYwYITMFbRPtSNW7jQ"},
{"content":{"body":"FYI that `class LazyPromise` example doesn't work correctly when `then` is called multiple times (which re-inforces that it's hard to actually get this right)","format":"org.matrix.custom.html","formatted_body":"FYI that <code>class LazyPromise</code> example doesn't work correctly when <code>then</code> is called multiple times (which re-inforces that it's hard to actually get this right)","m.mentions":{},"msgtype":"m.text"},"ts":1733261170723,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ZinEr4gj9pB9ybkrhm6RXfmZem_lxkdNbxPgq2tLets"},
{"content":{"body":"> <@mhofman:matrix.org> FYI that `class LazyPromise` example doesn't work correctly when `then` is called multiple times (which re-inforces that it's hard to actually get this right)\n\nyep, it was a quick example. didn't go through all the necessary boilerplate to make to complete","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$ZinEr4gj9pB9ybkrhm6RXfmZem_lxkdNbxPgq2tLets?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>FYI that <code>class LazyPromise</code> example doesn't work correctly when <code>then</code> is called multiple times (which re-inforces that it's hard to actually get this right)</blockquote></mx-reply>yep, it was a quick example. didn't go through all the necessary boilerplate to make to complete","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ZinEr4gj9pB9ybkrhm6RXfmZem_lxkdNbxPgq2tLets"}},"msgtype":"m.text"},"ts":1733261211745,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$QKszMUQmW90M9CvHENvxvsUErpzZd_CZtzmPV49_s7o"},
{"content":{"body":"deferred to a microtask after the await or then call, right ?","format":"org.matrix.custom.html","formatted_body":"deferred to a microtask after the await or then call, right ?","m.mentions":{"user_ids":["@jasnell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$1C4bHCzaOSoN0sX4QvSvVGOdY9B_eZxbpfRS9czDi20"}},"msgtype":"m.text"},"ts":1733261235970,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$5jYR632ddt_FZ_Spjh_o8opG9oD_oW2NVnyUaKmcTaU"},
{"content":{"body":"> <@mhofman:matrix.org> deferred to a microtask after the await or then call, right ?\n\nYes. When the reaction is added, the callback is deferred to the microtask at that point","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$5jYR632ddt_FZ_Spjh_o8opG9oD_oW2NVnyUaKmcTaU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>deferred to a microtask after the await or then call, right ?</blockquote></mx-reply>Yes. When the reaction is added, the callback is deferred to the microtask at that point","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$5jYR632ddt_FZ_Spjh_o8opG9oD_oW2NVnyUaKmcTaU"}},"msgtype":"m.text"},"ts":1733261278614,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$2FrWyq9NNedShZ4ygWQDGrgVdHzHPUUqXoK14UMFLMo"},
{"content":{"body":"do you have some example use cases for this?","m.mentions":{},"msgtype":"m.text"},"ts":1733261394232,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$eKOJT69BTq97J7xj6XnIzCkkSOjZasstoI2fF9dCVPg"},
{"content":{"body":"> <@devsnek:matrix.org> do you have some example use cases for this?\n\nI need to work up a few more of the examples but the use case that prompted this for me was a work queue built around custom thenables that ended up having a fair amount of boilerplate to get right (for instance, Mathieu Hofman's comment about about the LazyPromise example needing a lot more to be safe)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$eKOJT69BTq97J7xj6XnIzCkkSOjZasstoI2fF9dCVPg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@devsnek:matrix.org\">@devsnek:matrix.org</a><br>do you have some example use cases for this?</blockquote></mx-reply>I need to work up a few more of the examples but the use case that prompted this for me was a work queue built around custom thenables that ended up having a fair amount of boilerplate to get right (for instance, <a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>'s comment about about the LazyPromise example needing a lot more to be safe)","m.mentions":{"user_ids":["@devsnek:matrix.org","@mhofman:matrix.org"]},"m.relates_to":{"is_falling_back":false,"m.in_reply_to":{"event_id":"$eKOJT69BTq97J7xj6XnIzCkkSOjZasstoI2fF9dCVPg"}},"msgtype":"m.text"},"ts":1733261513089,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$m2qrscWAh1-VxqjXV1BnyqU5kPjp4bo6VcSkQbsF1O0"},
{"content":{"body":"> <@devsnek:matrix.org> do you have some example use cases for this?\n\n(there is one example at the bottom of the readme, in case you didn't see that it down there)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$eKOJT69BTq97J7xj6XnIzCkkSOjZasstoI2fF9dCVPg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@devsnek:matrix.org\">@devsnek:matrix.org</a><br>do you have some example use cases for this?</blockquote></mx-reply>(there is one example at the bottom of the readme, in case you didn't see that it down there)","m.mentions":{"user_ids":["@devsnek:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$eKOJT69BTq97J7xj6XnIzCkkSOjZasstoI2fF9dCVPg"}},"msgtype":"m.text"},"ts":1733261542374,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$tVhl2V_FFWCiaFUmkuDZhRVT_kBXY4f9BzK-4HdvxdA"},
{"content":{"body":"i feel like this example is a meta example","m.mentions":{},"msgtype":"m.text"},"ts":1733261599422,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$BkE5X2tRIW0jd3XieB-3JzgdPyvTlBEfG5mZ1FG7ZV8"},
{"content":{"body":"now i'm curious what you would put into this queue in practice","m.mentions":{},"msgtype":"m.text"},"ts":1733261618588,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$gIhuAStSTId0FIEsSDALcTzHhwNQb9J_w35K1-G-j04"},
{"content":{"body":"would a generator help there?","m.mentions":{},"msgtype":"m.text"},"ts":1733261619875,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$LmL-4I-Sbk4xbfRnPKcV8KGRbSr71MN694MOksHQeog"},
{"content":{"body":"yeah that example is lacking. One of my key tasks before bringing this officially to the committee is to expand the use cases and examples","m.mentions":{},"msgtype":"m.text"},"ts":1733261631799,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$LaSh58ZKEKReI8rcaP2MdGGujp5RBmPDRm4fy7OcRQw"},
{"content":{"body":"> <@jasnell:matrix.org> I need to work up a few more of the examples but the use case that prompted this for me was a work queue built around custom thenables that ended up having a fair amount of boilerplate to get right (for instance, Mathieu Hofman's comment about about the LazyPromise example needing a lot more to be safe)\n\nhow about we just provide a built-in work queue instead?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq%3Amatrix.org/%24m2qrscWAh1-VxqjXV1BnyqU5kPjp4bo6VcSkQbsF1O0\">In reply to</a><a href=\"https://matrix.to/#/%40jasnell%3Amatrix.org\">@jasnell:matrix.org</a><br />I need to work up a few more of the examples but the use case that prompted this for me was a work queue built around custom thenables that ended up having a fair amount of boilerplate to get right (for instance, <a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>'s comment about about the LazyPromise example needing a lot more to be safe)</blockquote></mx-reply>how about we just provide a built-in work queue instead?","m.relates_to":{"m.in_reply_to":{"event_id":"$m2qrscWAh1-VxqjXV1BnyqU5kPjp4bo6VcSkQbsF1O0"}},"msgtype":"m.text"},"ts":1733261646146,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$lNlkXWhf57q0aaWw7GRdpNImtBWK4JgRymMwZGH2b_w"},
{"content":{"body":"(I am already considering doing this btw)","msgtype":"m.text"},"ts":1733261674472,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$c8mOBt5ytanMdx7niENgdD9VazC36I5JZqzrUHanX4Y"},
{"content":{"body":"> <@aclaymore:matrix.org> would a generator help there?\n\nThis was about 8 months or so ago that I first started thinking about this and at the time we did end up moving the code to a generator to improve things but even then it was still a fair amount of boilerplate. It definitely helped that case tho","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$LmL-4I-Sbk4xbfRnPKcV8KGRbSr71MN694MOksHQeog?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br>would a generator help there?</blockquote></mx-reply>This was about 8 months or so ago that I first started thinking about this and at the time we did end up moving the code to a generator to improve things but even then it was still a fair amount of boilerplate. It definitely helped that case tho","m.mentions":{"user_ids":["@aclaymore:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$LmL-4I-Sbk4xbfRnPKcV8KGRbSr71MN694MOksHQeog"}},"msgtype":"m.text"},"ts":1733261701795,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$xvvJPIAT0o6MPaCiL2GGe2dHYGUc97HJF9uLWUbKI7Y"},
{"content":{"body":"i look forward to seeing some. i don't think i have ever (in js or rust) needed to take advantage of executor lazyness in a way that semantically matters.","m.mentions":{},"msgtype":"m.text"},"ts":1733261723537,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$zbIBx6_CvSFD2kVzn6nFfiX__8vCc2jC14O3oGahcGA"},
{"content":{"body":"> <@devsnek:matrix.org> i look forward to seeing some. i don't think i have ever (in js or rust) needed to take advantage of executor lazyness in a way that semantically matters.\n\nFair","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$zbIBx6_CvSFD2kVzn6nFfiX__8vCc2jC14O3oGahcGA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@devsnek:matrix.org\">@devsnek:matrix.org</a><br>i look forward to seeing some. i don&#39;t think i have ever (in js or rust) needed to take advantage of executor lazyness in a way that semantically matters.</blockquote></mx-reply>Fair","m.mentions":{"user_ids":["@devsnek:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zbIBx6_CvSFD2kVzn6nFfiX__8vCc2jC14O3oGahcGA"}},"msgtype":"m.text"},"ts":1733261740239,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$CQ83QsfevJOiSQXg6r1OL-wl8VjP_wpXKD284I6eyPo"},
{"content":{"body":"only for performance optimization","m.mentions":{},"msgtype":"m.text"},"ts":1733261740875,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$vTGbLX9hxVvotgEZApvsl0foBTlWVbJd4LoPMoM08Ss"},
{"content":{"body":"I'll have that (better documenting the use cases) at the top of the todo list then before moving this forward","m.mentions":{},"msgtype":"m.text"},"ts":1733261782596,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$J-Xd3zeRorHcRxBrCsn6oPOF9eJr-wXhk0cgl0fxGaQ"},
{"content":{"body":"they feel similar to a memo'ed lazy 0-arg async function. Where the trigger is an explicit call.\nThe lazy promise looks useful when the code needs to be general. Would be good to see an example where the code wouldn't have worked with a regular lazy function","m.mentions":{},"msgtype":"m.text"},"ts":1733261877225,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$ld8hwZO2Nb6cGqNcf_kD5V_KcLuvjNcjndGQWdNXHlY"},
{"content":{"body":" * they feel similar to a memo'ed lazy 0-arg async function. Where the trigger is an explicit call.\nThe lazy promise looks useful when the code needs to be generic. Would be good to see an example where the code wouldn't have worked with a regular lazy function","m.mentions":{},"m.new_content":{"body":"they feel similar to a memo'ed lazy 0-arg async function. Where the trigger is an explicit call.\nThe lazy promise looks useful when the code needs to be generic. Would be good to see an example where the code wouldn't have worked with a regular lazy function","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$ld8hwZO2Nb6cGqNcf_kD5V_KcLuvjNcjndGQWdNXHlY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733261905695,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$jFoDcSUKHnKzirmXJ8z8PLNvfyyjFVLKSImM59VufRE"},
{"content":{"body":"this sort of reminds me about the disagreement over iterator reuse, though maybe i'm over-generalizing. ","m.mentions":{},"msgtype":"m.text"},"ts":1733261929429,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$xi6pdVHQlkhrJHOZwmsLN8SFEFs8_iZiVY8DhbP9WJY"}
]