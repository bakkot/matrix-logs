[
{"content":{"body":"Hi all, new guy here! \n\nI'm entertaining the idea of opening a proposal but wanted to get a feeling on how the community feels about the concept before I commit a weekend to writing it out - haha. \n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular \n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a feeling on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733202117924,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202156297,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$hB7QHZTHYrjJzhueaNe9NTtJ5CwgZTkWl0qOCxmzWkk"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `@jsx()` or anything, I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>@jsx()</code> or anything, I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `@jsx()` or anything, I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>@jsx()</code> or anything, I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202235863,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$wLm2Vf5MUd0mM8wPt-Arh2NPK7cosoxUlqv0AcU7rrE"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe(push)]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202302762,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ZRedKXhkwGPc9Z7Kiq_1UX-hrerGYcKwWRt3Aa1awww"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202425075,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$hbWTUAF_k5oRIdC_WWLir1aB9gx4uhGB7VoZsnunAyM"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733202507765,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$R2egOMDaudRX7MQEZm5HI6b7gbkTIIpQMOVHjnCJEaA"},
{"content":{"body":"For the \"create a getter/setter\" example, that looks like it can be accomplished via a decorator https://github.com/tc39/proposal-decorators","format":"org.matrix.custom.html","formatted_body":"For the \"create a getter/setter\" example, that looks like it can be accomplished via a decorator https://github.com/tc39/proposal-decorators","msgtype":"m.text"},"ts":1733202732696,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$YS1oyU6-2eLnsz_o0yMq3suShUcJfURdsNTnjChAWX8"},
{"content":{"body":"Hi and welcome btw 👋🏻 ","format":"org.matrix.custom.html","formatted_body":"Hi and welcome btw 👋🏻 ","msgtype":"m.text"},"ts":1733203017299,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$-hsZG7LgHcWQ9x0gBQmRY0mix8BuV0lCzBfc4hYyFDU"},
{"content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733203363841,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203460592,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ki5TeYWhm3OoW9Zg04iKrf7N9fwD_z-BUalFS8yOrS4"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203548976,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$vf9voeEcvXEj6xgaVesIeRDTegyNQqKL_NUbyN26VSw"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users as functions that take tokens and return valid ECMAScript.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users as functions that take tokens and return valid ECMAScript.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203701106,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$OqhXdhw6cKq_KdZXbf57vaPBxYvfb-IeRkJtQ_b9718"},
{"content":{"body":" * Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users, none defined in the language.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":" * <p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users, none defined in the language.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"m.new_content":{"body":"Hi all, new guy here!\n\nI'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.\n\nGenerally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.\n\nAll macros would be defined by users, none defined in the language.\n\n```javascript\n// Parse tokens and generate React.createElement() calls\nconst Foo = () => jsx!(<div>Hello World</div>)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n```\n\nThe syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here\n\nWhile I know ECMAScript is not a compiled language, there are interesting use cases like;\n\n- Enabling support for jsx/other templating languages without an external preprocessor/eval\n- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular\n- A reduced need for custom compilers (ngc, .vue, .svelte)\n- More ergonomic usage for tools like protobuf\n- etc\n\nThis would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.\n\nAny thoughts on the concept?","format":"org.matrix.custom.html","formatted_body":"<p>Hi all, new guy here!</p>\n<p>I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.</p>\n<p>Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.</p>\n<p>All macros would be defined by users, none defined in the language.</p>\n<pre><code class=\"language-javascript\">// Parse tokens and generate React.createElement() calls\nconst Foo = () =&gt; jsx!(&lt;div&gt;Hello World&lt;/div&gt;)\n\n// Create a getter/setter for a property\nclass Bar {\n  #[observe]\n  baz = undefined\n}\n</code></pre>\n<p>The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like <code>jsx!()</code> could be <code>~jsx()</code> or anything (to avoid conflicts), I'm not opinionated here</p>\n<p>While I know ECMAScript is not a compiled language, there are interesting use cases like;</p>\n<ul>\n<li>Enabling support for jsx/other templating languages without an external preprocessor/eval</li>\n<li>Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular</li>\n<li>A reduced need for custom compilers (ngc, .vue, .svelte)</li>\n<li>More ergonomic usage for tools like protobuf</li>\n<li>etc</li>\n</ul>\n<p>This would also lead to support in preprocessors like TypeScript which <em>could</em> statically compile macros - offering an interesting/novel hybrid macro system.</p>\n<p>Any thoughts on the concept?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$J730gVuE_BRPnj85EphepZihi3-Gc4O-nxERc-LkiZc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203750070,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$VBOftqiDPFb1rU9UFt04mBRe1cqa56Qi0xIe-WJnJJw"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733203911416,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$QeW-U2LJm_SOzUjkg5Ld6DLxG8RqHtesAOzxjCQud6c"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {data.world}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {data.world}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733204056216,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$QT4wg76TvWGL3lZkGsuU_WogMkFnYfak63vQYKqAZMQ"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733204183223,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ntYnX3jmArimyk-Qw9Xw9R4bvfGVOu-58sEeX-hBC08"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n- Web wasm frameworks [[1]](https://yew.rs/) [[2]](https://leptos.dev/)\n- Native desktop frameworks [[1]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [[2]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n- Web wasm frameworks [[1]](https://yew.rs/) [[2]](https://leptos.dev/)\n- Native desktop frameworks [[1]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [[2]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733204475645,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$HOohLyJ9uti76S6j-iSybbL2KeWX4VYyIyYIrlbjkoU"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n\n- Web wasm frameworks [\\[1\\]](https://yew.rs/) [\\[2\\]](https://leptos.dev/)\n- Native desktop frameworks [\\[1\\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\\[2\\]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n\n- Web wasm frameworks [\\[1\\]](https://yew.rs/) [\\[2\\]](https://leptos.dev/)\n- Native desktop frameworks [\\[1\\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\\[2\\]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733204539644,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$MN9nEHJnIsvEVKFPuAqDMuJvUUkDQxAee1SWh53QL38"},
{"content":{"body":" * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n\n- Web wasm frameworks [\\[1\\]](https://yew.rs/) [\\[2\\]](https://leptos.dev/)\n- Native desktop frameworks [\\[1\\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\\[2\\]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":" * <p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;\n\n- Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime\n- Incorporating the annotatability of variable assignments as well as class properties\n- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc\n- Many more use cases\n\n```javascript\nconst vueComponent = {\n  template: vue!(<div>Hello {{data.world}}</div>),\n  data: () => ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n```\n\nLSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.\n\nIn the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:\n\n- Web wasm frameworks [\\[1\\]](https://yew.rs/) [\\[2\\]](https://leptos.dev/)\n- Native desktop frameworks [\\[1\\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\\[2\\]](https://iced.rs/)","format":"org.matrix.custom.html","formatted_body":"<p>Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;</p>\n<ul>\n<li>Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime</li>\n<li>Incorporating the annotatability of variable assignments as well as class properties</li>\n<li>Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc</li>\n<li>Many more use cases</li>\n</ul>\n<pre><code class=\"language-javascript\">const vueComponent = {\n  template: vue!(&lt;div&gt;Hello {{data.world}}&lt;/div&gt;),\n  data: () =&gt; ({ world: 'World' })\n}\n\nconst contents = yaml!(foo: 'bar')\n// Expands to\n// const contents = { foo: 'bar' }\n</code></pre>\n<p>LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.</p>\n<p>In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:</p>\n<ul>\n<li>Web wasm frameworks <a href=\"https://yew.rs/\">[1]</a> <a href=\"https://leptos.dev/\">[2]</a></li>\n<li>Native desktop frameworks <a href=\"https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app\">[1]</a> <a href=\"https://iced.rs/\">[2]</a></li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mxNjlGCEImTCdUK4H4-IU3q_GeIR4Mi6aoV9WeMPLjs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733205475701,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$aXxGHSrfPcQTffBJqYAn-jAnFuK-X5Qsg2YUVPFFBxk"},
{"content":{"body":"I am curious how things like auto-complete and refactoring work within Rust macros. These both sound easier for tooling to implement when the language extension is concrete, instead of being defined as a macro.","format":"org.matrix.custom.html","formatted_body":"I am curious how things like auto-complete and refactoring work within Rust macros. These both sound easier for tooling to implement when the language extension is concrete, instead of being defined as a macro.","msgtype":"m.text"},"ts":1733205531375,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$hBJRni6BXQXk1eDWBnpJY9oqmVLcCOp5Mh0zcKO57DU"},
{"content":{"body":"For autocomplete, the LSP expands the macro and uses the output\n```javascript\nconst foo = add!(1, 1)\n```\nWould expand into\n```javascript\nconst foo = 2\n```\nSo consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.\n\nAs for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax. \n\nThe editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.\n\nImplementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro","format":"org.matrix.custom.html","formatted_body":"<p>For autocomplete, the LSP expands the macro and uses the output</p>\n<pre><code class=\"language-javascript\">const foo = add!(1, 1)\n</code></pre>\n<p>Would expand into</p>\n<pre><code class=\"language-javascript\">const foo = 2\n</code></pre>\n<p>So consumers see it as a <code>number</code> rather than a macro. It simply replaces itself with the transformed result.</p>\n<p>As for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.</p>\n<p>The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.</p>\n<p>Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1733206871512,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$ylf2kKnfXA1CZreB2qzaNyvbvD73g5DZLBIrhdRdU24"},
{"content":{"body":" * For autocomplete, the LSP expands the macro and uses the output\n\n```javascript\nconst foo = add!(1, 1)\n```\n\nWould expand into\n\n```javascript\nconst foo = 2\n```\n\nSo consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.\n\nAs for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.\n\nThe editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.\n\nImplementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro","format":"org.matrix.custom.html","formatted_body":" * <p>For autocomplete, the LSP expands the macro and uses the output</p>\n<pre><code class=\"language-javascript\">const foo = add!(1, 1)\n</code></pre>\n<p>Would expand into</p>\n<pre><code class=\"language-javascript\">const foo = 2\n</code></pre>\n<p>So consumers see it as a <code>number</code> rather than a macro. It simply replaces itself with the transformed result.</p>\n<p>As for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.</p>\n<p>The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.</p>\n<p>Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro</p>\n","m.mentions":{},"m.new_content":{"body":"For autocomplete, the LSP expands the macro and uses the output\n\n```javascript\nconst foo = add!(1, 1)\n```\n\nWould expand into\n\n```javascript\nconst foo = 2\n```\n\nSo consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.\n\nAs for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.\n\nThe editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.\n\nImplementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro","format":"org.matrix.custom.html","formatted_body":"<p>For autocomplete, the LSP expands the macro and uses the output</p>\n<pre><code class=\"language-javascript\">const foo = add!(1, 1)\n</code></pre>\n<p>Would expand into</p>\n<pre><code class=\"language-javascript\">const foo = 2\n</code></pre>\n<p>So consumers see it as a <code>number</code> rather than a macro. It simply replaces itself with the transformed result.</p>\n<p>As for refactoring; when someone implements a macro, they parse \"tokens\" which they move around into the equivalent valid language syntax.</p>\n<p>The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.</p>\n<p>Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$ylf2kKnfXA1CZreB2qzaNyvbvD73g5DZLBIrhdRdU24","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1733206890686,"senderName":"David Alsh","senderId":"@alshdavid:matrix.org","id":"$nC6EO2UQFGZsfvr1Xk77Ssm8lb4SmK8QzEFsdLEGl-Y"}
]