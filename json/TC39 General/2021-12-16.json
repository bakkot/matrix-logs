[
{"content":{"body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`’s properties, when there are too many items, and when `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting <code>A</code>’s properties, when there are too many items, and when <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","msgtype":"m.text"},"ts":1639624674110,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$nTIJ5p2Ya8bSZu74_xRZM8KojLMRT4xpTy2t7i3OT28"},
{"content":{"body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its result’s properties, if there are too many items, or if `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its result’s properties, if there are too many items, or if <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","m.new_content":{"body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its result’s properties, if there are too many items, or if `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its result’s properties, if there are too many items, or if <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","msgtype":"m.text"},"m.relates_to":{"event_id":"$nTIJ5p2Ya8bSZu74_xRZM8KojLMRT4xpTy2t7i3OT28","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639624681409,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$HsOtsqULKm9vsQW6ZtHj2OqHbdo4Ht9F613q9j2I0Pw"},
{"content":{"body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`’s properties, when there are too many items, and when `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting <code>A</code>’s properties, when there are too many items, and when <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","m.new_content":{"body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`’s properties, when there are too many items, and when `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting <code>A</code>’s properties, when there are too many items, and when <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","msgtype":"m.text"},"m.relates_to":{"event_id":"$nTIJ5p2Ya8bSZu74_xRZM8KojLMRT4xpTy2t7i3OT28","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639624736521,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$dyUYXPc05AKKvhzKCGTHdvzdH1xks6ty4mwGWrCHhG0"},
{"content":{"body":"we don't close the iterator when an error occurs in the iterator itself, because the iterator is broken","msgtype":"m.text"},"ts":1639627962311,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$p-E0Ozibd0wJxDv5B3rtPv7PgcIfb5RxtcZc0260Pnk"},
{"content":{"body":"and we don't close iterators when they are depleted in general","msgtype":"m.text"},"ts":1639627972044,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$qbU3oFW3eX3RkYtDqCK7u4hclEdHs_gewxpthpQVYpM"},
{"content":{"body":"(the assumption is that it does its own cleanup before returning `{done: true}`)","format":"org.matrix.custom.html","formatted_body":"(the assumption is that it does its own cleanup before returning <code>{done: true}</code>)","msgtype":"m.text"},"ts":1639627994185,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$SAHHsQW_ihFhOc63qE1pmKnQoIiniXYHKJRWyCmzrmQ"},
{"content":{"body":"we only cause IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own","msgtype":"m.text"},"ts":1639628030399,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cK8VBbVzZKtsBXqDjzKDqwAkAaYC2NJr3P2Q3zJzHLE"},
{"content":{"body":" * we only call IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own","m.new_content":{"body":"we only call IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own","msgtype":"m.text"},"m.relates_to":{"event_id":"$cK8VBbVzZKtsBXqDjzKDqwAkAaYC2NJr3P2Q3zJzHLE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639628220109,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$xd_Qde2wlWHMjcWP6YK3NMfywfK1R8pMfulvyVETvxQ"},
{"content":{"body":"I see https://github.com/tc39/rationale/issues/2; thank you.","msgtype":"m.text"},"ts":1639631990394,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$GXfIuBWnDOWnQDa_vWVUHOgnsRcZYydDd1xikYgvg-o"},
{"content":{"body":" * I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2; thank you.","m.new_content":{"body":"I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2; thank you.","msgtype":"m.text"},"m.relates_to":{"event_id":"$GXfIuBWnDOWnQDa_vWVUHOgnsRcZYydDd1xikYgvg-o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639632137328,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$3dxtfWLTXhlvwq-Vju5UCGODvIjuqF59Z53sg9zeQWE"},
{"content":{"body":" * I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2. Thank you for both that and the explanation.","m.new_content":{"body":"I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2. Thank you for both that and the explanation.","msgtype":"m.text"},"m.relates_to":{"event_id":"$GXfIuBWnDOWnQDa_vWVUHOgnsRcZYydDd1xikYgvg-o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639632145543,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$IB4jLREzu5fObmr24P7C9660QkKYR7CS8yzRInT90Iw"},
{"content":{"body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541\nAs far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining `for await` semantics. This is correct, right?","format":"org.matrix.custom.html","formatted_body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541<br>As far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining <code>for await</code> semantics. This is correct, right?","msgtype":"m.text"},"ts":1639635217117,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$443EpyD059gU_OY5n2b44o87JkS0oQ2rfnSfxAnr0KU"},
{"content":{"body":" * https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541\nAs far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining `for await` semantics. This is correct, right?","format":"org.matrix.custom.html","formatted_body":" * https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541<br>As far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining <code>for await</code> semantics. This is correct, right?","m.new_content":{"body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541\nAs far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining `for await` semantics. This is correct, right?","format":"org.matrix.custom.html","formatted_body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541<br>As far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining <code>for await</code> semantics. This is correct, right?","msgtype":"m.text"},"m.relates_to":{"event_id":"$443EpyD059gU_OY5n2b44o87JkS0oQ2rfnSfxAnr0KU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639635252873,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$IaB3sFxWfB7dpoLSZwucWoAeHjdyjnOaND5Pto_umhU"},
{"content":{"body":"What does `for await (const foo of iterableYieldingPromises)` do in this case?","format":"org.matrix.custom.html","formatted_body":"What does <code>for await (const foo of iterableYieldingPromises)</code> do in this case?","msgtype":"m.text"},"ts":1639677247102,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YEYsgwfBMbz6H1aJd7T06arzMH7FbeKK3aWx0merCuc"},
{"content":{"body":"If I was to implement this in a polyfill, I'd setup a dummy `.catch()` on the next promise to avoid the unhandled error, but still yield the original promise later","format":"org.matrix.custom.html","formatted_body":"If I was to implement this in a polyfill, I'd setup a dummy <code>.catch()</code> on the next promise to avoid the unhandled error, but still yield the original promise later","msgtype":"m.text"},"ts":1639677354479,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$5pVmFTD85rv1xLsTF1dqnjmQimH4LhqHVtMOtQKJroQ"},
{"content":{"body":"It's a pretty common occurrence when parallelizing async operations","msgtype":"m.text"},"ts":1639677407847,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$sQYnzUxU6lTEiWvWsqM0BbZTIY9yGqnZ8-AbviWEJbk"},
{"content":{"body":"> <@mhofman:matrix.org> What does `for await (const foo of iterableYieldingPromises)` do in this case?\n\nMy bad I didn't read the OP. It goes unhandled! Wondering if it's something we should fix in the language. I suppose the problem is that if the loop body throws in an error during processing of the second element, then the IteratorClose has no way to report the error. Maybe recreating a promise resolved with the rejection to trigger a future unhandled error would work","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$YEYsgwfBMbz6H1aJd7T06arzMH7FbeKK3aWx0merCuc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>What does <code>for await (const foo of iterableYieldingPromises)</code> do in this case?</blockquote></mx-reply>My bad I didn't read the OP. It goes unhandled! Wondering if it's something we should fix in the language. I suppose the problem is that if the loop body throws in an error during processing of the second element, then the IteratorClose has no way to report the error. Maybe recreating a promise resolved with the rejection to trigger a future unhandled error would work","m.relates_to":{"m.in_reply_to":{"event_id":"$YEYsgwfBMbz6H1aJd7T06arzMH7FbeKK3aWx0merCuc"}},"msgtype":"m.text"},"ts":1639677622721,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$MCgKTOVQwZ_qrRI8C1_iCSo-MvzznsPZXDE3J3lEXiE"}
]