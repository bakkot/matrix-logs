[
{"content":{"body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`â€™s properties, when there are too many items, and when `mapfn` throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting <code>A</code>â€™s properties, when there are too many items, and when <code>mapfn</code> throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","msgtype":"m.text"},"ts":1639624674110,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$nTIJ5p2Ya8bSZu74_xRZM8KojLMRT4xpTy2t7i3OT28"},
{"content":{"body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its resultâ€™s properties, if there are too many items, or if `mapfn` throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its resultâ€™s properties, if there are too many items, or if <code>mapfn</code> throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","m.new_content":{"body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its resultâ€™s properties, if there are too many items, or if `mapfn` throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its resultâ€™s properties, if there are too many items, or if <code>mapfn</code> throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","msgtype":"m.text"},"m.relates_to":{"event_id":"$nTIJ5p2Ya8bSZu74_xRZM8KojLMRT4xpTy2t7i3OT28","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639624681409,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$HsOtsqULKm9vsQW6ZtHj2OqHbdo4Ht9F613q9j2I0Pw"},
{"content":{"body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`â€™s properties, when there are too many items, and when `mapfn` throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting <code>A</code>â€™s properties, when there are too many items, and when <code>mapfn</code> throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","m.new_content":{"body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`â€™s properties, when there are too many items, and when `mapfn` throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting <code>A</code>â€™s properties, when there are too many items, and when <code>mapfn</code> throws an errorâ€”but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","msgtype":"m.text"},"m.relates_to":{"event_id":"$nTIJ5p2Ya8bSZu74_xRZM8KojLMRT4xpTy2t7i3OT28","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639624736521,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$dyUYXPc05AKKvhzKCGTHdvzdH1xks6ty4mwGWrCHhG0"},
{"content":{"body":"we don't close the iterator when an error occurs in the iterator itself, because the iterator is broken","msgtype":"m.text"},"ts":1639627962311,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$p-E0Ozibd0wJxDv5B3rtPv7PgcIfb5RxtcZc0260Pnk"},
{"content":{"body":"and we don't close iterators when they are depleted in general","msgtype":"m.text"},"ts":1639627972044,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$qbU3oFW3eX3RkYtDqCK7u4hclEdHs_gewxpthpQVYpM"},
{"content":{"body":"(the assumption is that it does its own cleanup before returning `{done: true}`)","format":"org.matrix.custom.html","formatted_body":"(the assumption is that it does its own cleanup before returning <code>{done: true}</code>)","msgtype":"m.text"},"ts":1639627994185,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$SAHHsQW_ihFhOc63qE1pmKnQoIiniXYHKJRWyCmzrmQ"},
{"content":{"body":"we only cause IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own","msgtype":"m.text"},"ts":1639628030399,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cK8VBbVzZKtsBXqDjzKDqwAkAaYC2NJr3P2Q3zJzHLE"},
{"content":{"body":" * we only call IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own","m.new_content":{"body":"we only call IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own","msgtype":"m.text"},"m.relates_to":{"event_id":"$cK8VBbVzZKtsBXqDjzKDqwAkAaYC2NJr3P2Q3zJzHLE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639628220109,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$xd_Qde2wlWHMjcWP6YK3NMfywfK1R8pMfulvyVETvxQ"},
{"content":{"body":"I see https://github.com/tc39/rationale/issues/2; thank you.","msgtype":"m.text"},"ts":1639631990394,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$GXfIuBWnDOWnQDa_vWVUHOgnsRcZYydDd1xikYgvg-o"},
{"content":{"body":" * I see. I also see youâ€™ve posted https://github.com/tc39/rationale/issues/2; thank you.","m.new_content":{"body":"I see. I also see youâ€™ve posted https://github.com/tc39/rationale/issues/2; thank you.","msgtype":"m.text"},"m.relates_to":{"event_id":"$GXfIuBWnDOWnQDa_vWVUHOgnsRcZYydDd1xikYgvg-o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639632137328,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$3dxtfWLTXhlvwq-Vju5UCGODvIjuqF59Z53sg9zeQWE"},
{"content":{"body":" * I see. I also see youâ€™ve posted https://github.com/tc39/rationale/issues/2. Thank you for both that and the explanation.","m.new_content":{"body":"I see. I also see youâ€™ve posted https://github.com/tc39/rationale/issues/2. Thank you for both that and the explanation.","msgtype":"m.text"},"m.relates_to":{"event_id":"$GXfIuBWnDOWnQDa_vWVUHOgnsRcZYydDd1xikYgvg-o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639632145543,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$IB4jLREzu5fObmr24P7C9660QkKYR7CS8yzRInT90Iw"},
{"content":{"body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541\nAs far as I can tell, there is no way to capture all possible rejections from a sync iterableâ€™s yielded promises, while still maintaining `for await` semantics. This is correct, right?","format":"org.matrix.custom.html","formatted_body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541<br>As far as I can tell, there is no way to capture all possible rejections from a sync iterableâ€™s yielded promises, while still maintaining <code>for await</code> semantics. This is correct, right?","msgtype":"m.text"},"ts":1639635217117,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$443EpyD059gU_OY5n2b44o87JkS0oQ2rfnSfxAnr0KU"},
{"content":{"body":" * https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541\nAs far as I can tell, there is no way to capture all possible rejections from a sync iterableâ€™s yielded promises, while still maintaining `for await` semantics. This is correct, right?","format":"org.matrix.custom.html","formatted_body":" * https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541<br>As far as I can tell, there is no way to capture all possible rejections from a sync iterableâ€™s yielded promises, while still maintaining <code>for await</code> semantics. This is correct, right?","m.new_content":{"body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541\nAs far as I can tell, there is no way to capture all possible rejections from a sync iterableâ€™s yielded promises, while still maintaining `for await` semantics. This is correct, right?","format":"org.matrix.custom.html","formatted_body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541<br>As far as I can tell, there is no way to capture all possible rejections from a sync iterableâ€™s yielded promises, while still maintaining <code>for await</code> semantics. This is correct, right?","msgtype":"m.text"},"m.relates_to":{"event_id":"$443EpyD059gU_OY5n2b44o87JkS0oQ2rfnSfxAnr0KU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639635252873,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$IaB3sFxWfB7dpoLSZwucWoAeHjdyjnOaND5Pto_umhU"},
{"content":{"body":"What does `for await (const foo of iterableYieldingPromises)` do in this case?","format":"org.matrix.custom.html","formatted_body":"What does <code>for await (const foo of iterableYieldingPromises)</code> do in this case?","msgtype":"m.text"},"ts":1639677247102,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YEYsgwfBMbz6H1aJd7T06arzMH7FbeKK3aWx0merCuc"},
{"content":{"body":"If I was to implement this in a polyfill, I'd setup a dummy `.catch()` on the next promise to avoid the unhandled error, but still yield the original promise later","format":"org.matrix.custom.html","formatted_body":"If I was to implement this in a polyfill, I'd setup a dummy <code>.catch()</code> on the next promise to avoid the unhandled error, but still yield the original promise later","msgtype":"m.text"},"ts":1639677354479,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$5pVmFTD85rv1xLsTF1dqnjmQimH4LhqHVtMOtQKJroQ"},
{"content":{"body":"It's a pretty common occurrence when parallelizing async operations","msgtype":"m.text"},"ts":1639677407847,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$sQYnzUxU6lTEiWvWsqM0BbZTIY9yGqnZ8-AbviWEJbk"},
{"content":{"body":"> <@mhofman:matrix.org> What does `for await (const foo of iterableYieldingPromises)` do in this case?\n\nMy bad I didn't read the OP. It goes unhandled! Wondering if it's something we should fix in the language. I suppose the problem is that if the loop body throws in an error during processing of the second element, then the IteratorClose has no way to report the error. Maybe recreating a promise resolved with the rejection to trigger a future unhandled error would work","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$YEYsgwfBMbz6H1aJd7T06arzMH7FbeKK3aWx0merCuc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>What does <code>for await (const foo of iterableYieldingPromises)</code> do in this case?</blockquote></mx-reply>My bad I didn't read the OP. It goes unhandled! Wondering if it's something we should fix in the language. I suppose the problem is that if the loop body throws in an error during processing of the second element, then the IteratorClose has no way to report the error. Maybe recreating a promise resolved with the rejection to trigger a future unhandled error would work","m.relates_to":{"m.in_reply_to":{"event_id":"$YEYsgwfBMbz6H1aJd7T06arzMH7FbeKK3aWx0merCuc"}},"msgtype":"m.text"},"ts":1639677622721,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$MCgKTOVQwZ_qrRI8C1_iCSo-MvzznsPZXDE3J3lEXiE"},
{"content":{"body":"Ugh I wasn't awake, the OP example is flawed, and  Async-from-Sync Iterator objects behave correctly","msgtype":"m.text"},"ts":1639683581504,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CA_STQ1UrgaXzEAbGpIDGiI5N1TBNYTnVQi4xrXqvSU"},
{"content":{"body":"Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:\n\n```\nfunction * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n\n`for of` behaves as expected:\n```\nfor (const i of  gen()) {\n  console.log(await i);\n}\n// 1 \"iter cleanup\" (Uncaught 2)\n```\n\nfor await of however doesn't close the iterator\n```\nfor await (const i of  gen()) {\n  console.log(i);\n}\n// 1 (Uncaught 2)\n```","format":"org.matrix.custom.html","formatted_body":"<p>Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:</p>\n<pre><code>function * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n\n`for of` behaves as expected:\n</code></pre>\n<p>for (const i of  gen()) {<br>console.log(await i);<br>}<br>// 1 &quot;iter cleanup&quot; (Uncaught 2)</p>\n<pre><code>\nfor await of however doesn't close the iterator\n</code></pre>\n<p>for await (const i of  gen()) {<br>console.log(i);<br>}<br>// 1 (Uncaught 2)</p>\n<pre><code></code></pre>\n","msgtype":"m.text"},"ts":1639690200874,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$UxOPm463IPslTarLl0XJAzVWDFAZ_smSYjzyBwAdEck"},
{"content":{"body":" * Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:\n```\nfunction * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n```\n\n\n`for of` behaves as expected:\n```\n\nfor (const i of  gen()) {\nconsole.log(await i);\n}\n// 1 \"iter cleanup\" (Uncaught 2)\n```\n\nfor await of however doesn't close the iterator\n```\n\nfor await (const i of  gen()) {\nconsole.log(i);\n}\n// 1 (Uncaught 2)\n```\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:</p>\n<pre><code>function * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n</code></pre>\n<p><code>for of</code> behaves as expected:</p>\n<pre><code>\nfor (const i of  gen()) {\nconsole.log(await i);\n}\n// 1 &quot;iter cleanup&quot; (Uncaught 2)\n</code></pre>\n<p>for await of however doesn't close the iterator</p>\n<pre><code>\nfor await (const i of  gen()) {\nconsole.log(i);\n}\n// 1 (Uncaught 2)\n</code></pre>\n<pre><code></code></pre>\n","m.new_content":{"body":"Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:\n```\nfunction * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n```\n\n\n`for of` behaves as expected:\n```\n\nfor (const i of  gen()) {\nconsole.log(await i);\n}\n// 1 \"iter cleanup\" (Uncaught 2)\n```\n\nfor await of however doesn't close the iterator\n```\n\nfor await (const i of  gen()) {\nconsole.log(i);\n}\n// 1 (Uncaught 2)\n```\n```","format":"org.matrix.custom.html","formatted_body":"<p>Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:</p>\n<pre><code>function * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n</code></pre>\n<p><code>for of</code> behaves as expected:</p>\n<pre><code>\nfor (const i of  gen()) {\nconsole.log(await i);\n}\n// 1 &quot;iter cleanup&quot; (Uncaught 2)\n</code></pre>\n<p>for await of however doesn't close the iterator</p>\n<pre><code>\nfor await (const i of  gen()) {\nconsole.log(i);\n}\n// 1 (Uncaught 2)\n</code></pre>\n<pre><code></code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$UxOPm463IPslTarLl0XJAzVWDFAZ_smSYjzyBwAdEck","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639690220720,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$MXc2ywrKgGBKfH005tElRV8KIUYmoe3RSxFplYis9gA"},
{"content":{"body":" * Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:\n```\nfunction * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n```\n\n`for of` behaves as expected:\n```\n\nfor (const i of  gen()) {\nconsole.log(await i);\n}\n// 1 \"iter cleanup\" (Uncaught 2)\n```\n\nfor await of however doesn't close the iterator\n```\n\nfor await (const i of  gen()) {\nconsole.log(i);\n}\n// 1 (Uncaught 2)\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:</p>\n<pre><code>function * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n</code></pre>\n<p><code>for of</code> behaves as expected:</p>\n<pre><code>\nfor (const i of  gen()) {\nconsole.log(await i);\n}\n// 1 &quot;iter cleanup&quot; (Uncaught 2)\n</code></pre>\n<p>for await of however doesn't close the iterator</p>\n<pre><code>\nfor await (const i of  gen()) {\nconsole.log(i);\n}\n// 1 (Uncaught 2)\n</code></pre>\n","m.new_content":{"body":"Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:\n```\nfunction * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n```\n\n`for of` behaves as expected:\n```\n\nfor (const i of  gen()) {\nconsole.log(await i);\n}\n// 1 \"iter cleanup\" (Uncaught 2)\n```\n\nfor await of however doesn't close the iterator\n```\n\nfor await (const i of  gen()) {\nconsole.log(i);\n}\n// 1 (Uncaught 2)\n```","format":"org.matrix.custom.html","formatted_body":"<p>Actually follow up on  Async-from-Sync Iterator objects / for await of. The following IteratorClose behavior seem surprising to me:</p>\n<pre><code>function * gen() {\n  try {\n    yield Promise.resolve(1);\n    yield Promise.reject(2);\n  } finally {\n    console.log('iter cleanup');\n  }\n}\n</code></pre>\n<p><code>for of</code> behaves as expected:</p>\n<pre><code>\nfor (const i of  gen()) {\nconsole.log(await i);\n}\n// 1 &quot;iter cleanup&quot; (Uncaught 2)\n</code></pre>\n<p>for await of however doesn't close the iterator</p>\n<pre><code>\nfor await (const i of  gen()) {\nconsole.log(i);\n}\n// 1 (Uncaught 2)\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$UxOPm463IPslTarLl0XJAzVWDFAZ_smSYjzyBwAdEck","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639690233031,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$w0bcvgF_8x0EOEnVzP-UBgN755zmTvL1nAfUW-gQeT0"},
{"content":{"body":"At least the solution for this particular example is a one keyword change to `async function * gen() {`","format":"org.matrix.custom.html","formatted_body":"At least the solution for this particular example is a one keyword change to <code>async function * gen() {</code>","msgtype":"m.text"},"ts":1639691546875,"senderName":"Ashley Claymore ðŸ¤’","senderId":"@aclaymore:matrix.org","id":"$-_Lv-mPu9Tg-15CrW3cmtkb2MKIlIHO1OZsHNNEs0Bk"},
{"content":{"body":"though I was surprised there was a difference","msgtype":"m.text"},"ts":1639691569081,"senderName":"Ashley Claymore ðŸ¤’","senderId":"@aclaymore:matrix.org","id":"$ejnaobPzw5pHrRsIxf-fuDD3qXiWQmyc7ZnqBPyLkzE"},
{"content":{"body":" * though was surprised there was a difference","m.new_content":{"body":"though was surprised there was a difference","msgtype":"m.text"},"m.relates_to":{"event_id":"$ejnaobPzw5pHrRsIxf-fuDD3qXiWQmyc7ZnqBPyLkzE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639691573248,"senderName":"Ashley Claymore ðŸ¤’","senderId":"@aclaymore:matrix.org","id":"$iG9I3CBoXpj54IsoJiVDIVn-dXRCXzz7gL4gZ3QtPAU"},
{"content":{"body":" * though I was surprised there was a difference","m.new_content":{"body":"though I was surprised there was a difference","msgtype":"m.text"},"m.relates_to":{"event_id":"$ejnaobPzw5pHrRsIxf-fuDD3qXiWQmyc7ZnqBPyLkzE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639691578633,"senderName":"Ashley Claymore ðŸ¤’","senderId":"@aclaymore:matrix.org","id":"$U8NbqQKvYky_2b-6gLeIsDaR0s7fXDYH1Z3FrQ-SEuQ"},
{"content":{"body":"sure, but then that iterator is async and can no longer be used with sync iteration","msgtype":"m.text"},"ts":1639691607936,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$mtYdziFHuASH6E5wIfTk0dGT-8T1sxgcEsYd2vz-J_4"},
{"content":{"body":"good point :)","msgtype":"m.text"},"ts":1639691664107,"senderName":"Ashley Claymore ðŸ¤’","senderId":"@aclaymore:matrix.org","id":"$i_FhB6r4YH0OQbktoJx_IARGyJdTfd9xPcuEYFOQRFk"},
{"content":{"body":"Would it be possible to change this, or working-as-intended/too-late-to-change","msgtype":"m.text"},"ts":1639691757819,"senderName":"Ashley Claymore ðŸ¤’","senderId":"@aclaymore:matrix.org","id":"$jFFdZ66Yjm21hjqEAKD6Fr7HP5oqs0zDhtIekDL87fk"},
{"content":{"body":"I'm not sure, there is other behavior with IteratorClose I find strange, like the swallowing of errors in `return` if the iterator was closed by a `for-of` loop that threw, which is kinda the opposite of `finally` errors shadowing `try` errors","format":"org.matrix.custom.html","formatted_body":"I'm not sure, there is other behavior with IteratorClose I find strange, like the swallowing of errors in <code>return</code> if the iterator was closed by a <code>for-of</code> loop that threw, which is kinda the opposite of <code>finally</code> errors shadowing <code>try</code> errors","msgtype":"m.text"},"ts":1639691920599,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$lKxUVAs4cZ5tUMLmQoLZdkZxhFp3yzAtsQJmGWiOlVg"}
]