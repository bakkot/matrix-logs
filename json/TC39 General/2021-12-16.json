[
{"content":{"body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`’s properties, when there are too many items, and when `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting <code>A</code>’s properties, when there are too many items, and when <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","msgtype":"m.text"},"ts":1639624674110,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$nTIJ5p2Ya8bSZu74_xRZM8KojLMRT4xpTy2t7i3OT28"},
{"content":{"body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its result’s properties, if there are too many items, or if `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its result’s properties, if there are too many items, or if <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","m.new_content":{"body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its result’s properties, if there are too many items, or if `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its result’s properties, if there are too many items, or if <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","msgtype":"m.text"},"m.relates_to":{"event_id":"$nTIJ5p2Ya8bSZu74_xRZM8KojLMRT4xpTy2t7i3OT28","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639624681409,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$HsOtsqULKm9vsQW6ZtHj2OqHbdo4Ht9F613q9j2I0Pw"},
{"content":{"body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`’s properties, when there are too many items, and when `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":" * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting <code>A</code>’s properties, when there are too many items, and when <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","m.new_content":{"body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`’s properties, when there are too many items, and when `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","format":"org.matrix.custom.html","formatted_body":"Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting <code>A</code>’s properties, when there are too many items, and when <code>mapfn</code> throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?","msgtype":"m.text"},"m.relates_to":{"event_id":"$nTIJ5p2Ya8bSZu74_xRZM8KojLMRT4xpTy2t7i3OT28","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639624736521,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$dyUYXPc05AKKvhzKCGTHdvzdH1xks6ty4mwGWrCHhG0"},
{"content":{"body":"we don't close the iterator when an error occurs in the iterator itself, because the iterator is broken","msgtype":"m.text"},"ts":1639627962311,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$p-E0Ozibd0wJxDv5B3rtPv7PgcIfb5RxtcZc0260Pnk"},
{"content":{"body":"and we don't close iterators when they are depleted in general","msgtype":"m.text"},"ts":1639627972044,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$qbU3oFW3eX3RkYtDqCK7u4hclEdHs_gewxpthpQVYpM"},
{"content":{"body":"(the assumption is that it does its own cleanup before returning `{done: true}`)","format":"org.matrix.custom.html","formatted_body":"(the assumption is that it does its own cleanup before returning <code>{done: true}</code>)","msgtype":"m.text"},"ts":1639627994185,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$SAHHsQW_ihFhOc63qE1pmKnQoIiniXYHKJRWyCmzrmQ"},
{"content":{"body":"we only cause IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own","msgtype":"m.text"},"ts":1639628030399,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cK8VBbVzZKtsBXqDjzKDqwAkAaYC2NJr3P2Q3zJzHLE"},
{"content":{"body":" * we only call IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own","m.new_content":{"body":"we only call IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own","msgtype":"m.text"},"m.relates_to":{"event_id":"$cK8VBbVzZKtsBXqDjzKDqwAkAaYC2NJr3P2Q3zJzHLE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639628220109,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$xd_Qde2wlWHMjcWP6YK3NMfywfK1R8pMfulvyVETvxQ"},
{"content":{"body":"I see https://github.com/tc39/rationale/issues/2; thank you.","msgtype":"m.text"},"ts":1639631990394,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$GXfIuBWnDOWnQDa_vWVUHOgnsRcZYydDd1xikYgvg-o"},
{"content":{"body":" * I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2; thank you.","m.new_content":{"body":"I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2; thank you.","msgtype":"m.text"},"m.relates_to":{"event_id":"$GXfIuBWnDOWnQDa_vWVUHOgnsRcZYydDd1xikYgvg-o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639632137328,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$3dxtfWLTXhlvwq-Vju5UCGODvIjuqF59Z53sg9zeQWE"},
{"content":{"body":" * I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2. Thank you for both that and the explanation.","m.new_content":{"body":"I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2. Thank you for both that and the explanation.","msgtype":"m.text"},"m.relates_to":{"event_id":"$GXfIuBWnDOWnQDa_vWVUHOgnsRcZYydDd1xikYgvg-o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639632145543,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$IB4jLREzu5fObmr24P7C9660QkKYR7CS8yzRInT90Iw"},
{"content":{"body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541\nAs far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining `for await` semantics. This is correct, right?","format":"org.matrix.custom.html","formatted_body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541<br>As far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining <code>for await</code> semantics. This is correct, right?","msgtype":"m.text"},"ts":1639635217117,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$443EpyD059gU_OY5n2b44o87JkS0oQ2rfnSfxAnr0KU"},
{"content":{"body":" * https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541\nAs far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining `for await` semantics. This is correct, right?","format":"org.matrix.custom.html","formatted_body":" * https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541<br>As far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining <code>for await</code> semantics. This is correct, right?","m.new_content":{"body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541\nAs far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining `for await` semantics. This is correct, right?","format":"org.matrix.custom.html","formatted_body":"https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541<br>As far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining <code>for await</code> semantics. This is correct, right?","msgtype":"m.text"},"m.relates_to":{"event_id":"$443EpyD059gU_OY5n2b44o87JkS0oQ2rfnSfxAnr0KU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639635252873,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$IaB3sFxWfB7dpoLSZwucWoAeHjdyjnOaND5Pto_umhU"},
{"content":{"body":"What does `for await (const foo of iterableYieldingPromises)` do in this case?","format":"org.matrix.custom.html","formatted_body":"What does <code>for await (const foo of iterableYieldingPromises)</code> do in this case?","msgtype":"m.text"},"ts":1639677247102,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YEYsgwfBMbz6H1aJd7T06arzMH7FbeKK3aWx0merCuc"},
{"content":{"body":"If I was to implement this in a polyfill, I'd setup a dummy `.catch()` on the next promise to avoid the unhandled error, but still yield the original promise later","format":"org.matrix.custom.html","formatted_body":"If I was to implement this in a polyfill, I'd setup a dummy <code>.catch()</code> on the next promise to avoid the unhandled error, but still yield the original promise later","msgtype":"m.text"},"ts":1639677354479,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$5pVmFTD85rv1xLsTF1dqnjmQimH4LhqHVtMOtQKJroQ"},
{"content":{"body":"It's a pretty common occurrence when parallelizing async operations","msgtype":"m.text"},"ts":1639677407847,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$sQYnzUxU6lTEiWvWsqM0BbZTIY9yGqnZ8-AbviWEJbk"}
]