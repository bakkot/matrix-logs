[
{"content":{"body":"This is interesting https://jakearchibald.com/2025/importing-vs-fetching-json/","m.mentions":{},"msgtype":"m.text"},"ts":1761604326780,"senderName":"styfle","senderId":"@styfle:matrix.org","id":"$tDFvOQKuha7xXeYguYz7UXqKFo3dHeYQVE02P7UQLaI"},
{"content":{"body":"It’s interesting insofaras the designers of a thing don’t always precog how the feature will be misused. Great that Jake’s getting ahead of that.","m.mentions":{"user_ids":["@styfle:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$tDFvOQKuha7xXeYguYz7UXqKFo3dHeYQVE02P7UQLaI"}},"msgtype":"m.text"},"ts":1761604554808,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$KcJRgRrGlmRBRKKTCPcPpnbrWfA58WEq4FuQTt0q3jQ"},
{"content":{"body":"This is one of the ways that having an out-of-band mapping from import specifier to fully qualified URL is useful at deterring misuse. Using a fully qualified URL for an import is a smell, and ideally wouldn’t even be possible.","m.mentions":{},"msgtype":"m.text"},"ts":1761604659315,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$DsS6221Z89Ue4MlTtZgLT1dPDNoEn2mh2LNikYEIQcw"},
{"content":{"body":"And I mean that objectively, as most applications should at least be able to endure a bundling transformation when they’re sent to production, and cross-domain reliance is always going to be runtime fragility, even if the bundler allows exits to other sites.","m.mentions":{},"msgtype":"m.text"},"ts":1761604735819,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$udhNae9E2BRb_bBkM3y8eCdUOq_QF622cuO7vTtH9zI"},
{"content":{"body":"I've also been putting some thought to if bytes imports are useful in a Wasm import context, and I think they are - the interesting thing there is if they were hypothetically supported as passive data section imports of Wasm, passive segments do support being dropped after use in initialization to allow for GC. So in theory there could be an application of import bytes for Wasm that _is garbage collectable_ while being maximally useful due to static instantiation. Including this topic in the ESM Integration update at the Wasm CG this week, will share slides with this group after as well.","format":"org.matrix.custom.html","formatted_body":"I've also been putting some thought to if bytes imports are useful in a Wasm import context, and I think they are - the interesting thing there is if they were hypothetically supported as passive data section imports of Wasm, passive segments do support being dropped after use in initialization to allow for GC. So in theory there could be an application of import bytes for Wasm that <em>is garbage collectable</em> while being maximally useful due to static instantiation. Including this topic in the ESM Integration update at the Wasm CG this week, will share slides with this group after as well.","m.mentions":{},"msgtype":"m.text"},"ts":1761606672667,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$Jdmr6c3lgD7fgw2YW6GXbPZ6k29z9xqRpVefrIxZnn8"},
{"content":{"body":"(of course registry needs to be kept around, although immutable data could in theory be treated as lazy / evicted memory moved to say disk cache if that was optimized for)","m.mentions":{},"msgtype":"m.text"},"ts":1761606883620,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$LGZsfdSwmHJp9KDtqtig9ipSvJ_6M7bIEvgWE8lbQqg"},
{"content":{"body":"Very interesting observation about import bytes being collectible. That might endure scrutiny. Assuming you’ve got Finalization for the retaining Uint8Array and immutable ArrayBuffer, there’d be no observable loss if the data had to be refetched for a subsequent import.","m.mentions":{},"msgtype":"m.text"},"ts":1761607231662,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$gGteMXE1nK54PTClZzojDqvuO5eHdQcNP6aup6KR2eA"},
{"content":{"body":"I wonder if there's a spec enabling way to say that each importer may get their own separate instance of the array buffer object, provided the immutable contents remain the same, instead of treating it as a shared object. In theory an `arrayBuffer.transfer()` operation could then provide GC support too for JS.","format":"org.matrix.custom.html","formatted_body":"I wonder if there's a spec enabling way to say that each importer may get their own separate instance of the array buffer object, provided the immutable contents remain the same, instead of treating it as a shared object. In theory an <code>arrayBuffer.transfer()</code> operation could then provide GC support too for JS.","m.mentions":{},"msgtype":"m.text"},"ts":1761607365123,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$kzohQVI756zMnDK176JKXIAV96XZifQlj-vNfUGkFsY"},
{"content":{"body":"Wonder if worth considering if memory questions come up again?","m.mentions":{},"msgtype":"m.text"},"ts":1761607382624,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$1CIlCJfw8e8qfj0ByX8qRe5ik-Vt7osbmCVeMIxUr2w"},
{"content":{"body":"even with such feature, transfer would only work if these weren't immutable","m.mentions":{},"msgtype":"m.text"},"ts":1761607477592,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$EbzIl-dUfJfOpK6aEasSATySPd6MImug4e6Q2racJVw"},
{"content":{"body":"Ah right, so only mutable support detachment? I guess that thwarts that line of consideration then.","m.mentions":{},"msgtype":"m.text"},"ts":1761607548317,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$gQF8TkQFhzM22nV-94K07VRQtQcQUMjbuj4XKZEAExk"},
{"content":{"body":"yeah, detaching causes an observable change to the values you get when wrapping the buffer, so it can't be done for immutable buffers","m.mentions":{},"msgtype":"m.text"},"ts":1761607685475,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$nZvhJ3_T9HeYh133_UcKfucVM1keT8MRxe6WU6qf3GA"}
]