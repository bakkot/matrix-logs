[
{"content":{"body":"> <@kriskowal:matrix.org> nicolo-ribaudo: Caridy is working on First-class Modules spec text. It might be good for you to connect.\n\nAwesome! This week I started refactoring the `HostResolveImportedModule` and `HostImportModuleDynamically` host hooks, because I didn't want to go through host-defined behavior when importing module blocks/fragments (until they import external modules).\n\nI now have a single `HostLoadImportedModule` hook, used both for static and dynamic imports, that \"returns\" an unlinked Module Record. ECMA-262 takes care of iterating through its dependencies, and it recursively calls `HostLoadImportedModule` to visit the whole graph (cc guybedford: this matches your intuition in https://github.com/tc39/proposal-js-module-blocks/pull/65#discussion_r912412376 !).\n\nThis is my proposed refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/\nIf you are curious, this is how the module blocks spec looks like on top of that refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/proposals/module-blocks - the updates to `import()` are relevant for \"layer 0\", because they show how to import a \"module object\".\n\nI believe that the new logic closely resembles the loading logic introduced by \"layer 0\": we could probably just add a step tocheck to 2.d.ii of InnerModuleLoading that calls a `module.[[ImportHook]]` function, rather than always delegating to `HostLoadImportedModule`.\n\nIt would probably also help with module reflection: assuming that `WebAssembly.Module` will be a module source, the proposal could use `HostLoadImportedModule(...).[[ModuleSource]]` instead of introducing a new `HostResolveModuleReflection` AO. This would also guarantee that `import module x from \"x.wasm\"` and `import * as ns from \"x.wasm\"` import the same module, even if they do two different things with it (probably we could guarantee `ns === await import(x)`).\n\nI would love to hear your thoughts on this ðŸ™‚","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$LluC8fhPVyXxFx_Dzey8SuoVh5qBKmsKBVc6mqvaFjo?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br><a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a>: Caridy is working on First-class Modules spec text. It might be good for you to connect.</blockquote></mx-reply><p>Awesome! This week I started refactoring the <code>HostResolveImportedModule</code> and <code>HostImportModuleDynamically</code> host hooks, because I didn't want to go through host-defined behavior when importing module blocks/fragments (until they import external modules).</p>\n<p>I now have a single <code>HostLoadImportedModule</code> hook, used both for static and dynamic imports, that &quot;returns&quot; an unlinked Module Record. ECMA-262 takes care of iterating through its dependencies, and it recursively calls <code>HostLoadImportedModule</code> to visit the whole graph (cc <a href=\"https://matrix.to/#/@guybedford:matrix.org\">guybedford</a>: this matches your intuition in https://github.com/tc39/proposal-js-module-blocks/pull/65#discussion_r912412376 !).</p>\n<p>This is my proposed refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/<br>If you are curious, this is how the module blocks spec looks like on top of that refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/proposals/module-blocks - the updates to <code>import()</code> are relevant for &quot;layer 0&quot;, because they show how to import a &quot;module object&quot;.</p>\n<p>I believe that the new logic closely resembles the loading logic introduced by &quot;layer 0&quot;: we could probably just add a step tocheck to 2.d.ii of InnerModuleLoading that calls a <code>module.[[ImportHook]]</code> function, rather than always delegating to <code>HostLoadImportedModule</code>.</p>\n<p>It would probably also help with module reflection: assuming that <code>WebAssembly.Module</code> will be a module source, the proposal could use <code>HostLoadImportedModule(...).[[ModuleSource]]</code> instead of introducing a new <code>HostResolveModuleReflection</code> AO. This would also guarantee that <code>import module x from &quot;x.wasm&quot;</code> and <code>import * as ns from &quot;x.wasm&quot;</code> import the same module, even if they do two different things with it (probably we could guarantee <code>ns === await import(x)</code>).</p>\n<p>I would love to hear your thoughts on this ðŸ™‚</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$LluC8fhPVyXxFx_Dzey8SuoVh5qBKmsKBVc6mqvaFjo"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> nicolo-ribaudo: Caridy is working on First-class Modules spec text. It might be good for you to connect.\n\nAwesome! This week I started refactoring the `HostResolveImportedModule` and `HostImportModuleDynamically` host hooks, because I didn't want to go through host-defined behavior when importing module blocks/fragments (until they import external modules).\n\nI now have a single `HostLoadImportedModule` hook, used both for static and dynamic imports, that \"returns\" an unlinked Module Record. ECMA-262 takes care of iterating through its dependencies, and it recursively calls `HostLoadImportedModule` to visit the whole graph (cc guybedford: this matches your intuition in https://github.com/tc39/proposal-js-module-blocks/pull/65#discussion_r912412376 !).\n\nThis is my proposed refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/\nIf you are curious, this is how the module blocks spec looks like on top of that refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/proposals/module-blocks - the updates to `import()` are relevant for \"layer 0\", because they show how to import a \"module object\".\n\nI believe that the new logic closely resembles the loading logic introduced by \"layer 0\": we could probably just add a step tocheck to 2.d.ii of InnerModuleLoading that calls a `module.[[ImportHook]]` function, rather than always delegating to `HostLoadImportedModule`.\n\nIt would probably also help with module reflection: assuming that `WebAssembly.Module` will be a module source, the proposal could use `HostLoadImportedModule(...).[[ModuleSource]]` instead of introducing a new `HostResolveModuleReflection` AO. This would also guarantee that `import module x from \"x.wasm\"` and `import * as ns from \"x.wasm\"` import the same module, even if they do two different things with it (probably we could guarantee `ns === await import(x)`).\n\nI would love to hear your thoughts on this ðŸ™‚","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$LluC8fhPVyXxFx_Dzey8SuoVh5qBKmsKBVc6mqvaFjo?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br><a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a>: Caridy is working on First-class Modules spec text. It might be good for you to connect.</blockquote></mx-reply><p>Awesome! This week I started refactoring the <code>HostResolveImportedModule</code> and <code>HostImportModuleDynamically</code> host hooks, because I didn't want to go through host-defined behavior when importing module blocks/fragments (until they import external modules).</p>\n<p>I now have a single <code>HostLoadImportedModule</code> hook, used both for static and dynamic imports, that &quot;returns&quot; an unlinked Module Record. ECMA-262 takes care of iterating through its dependencies, and it recursively calls <code>HostLoadImportedModule</code> to visit the whole graph (cc <a href=\"https://matrix.to/#/@guybedford:matrix.org\">guybedford</a>: this matches your intuition in https://github.com/tc39/proposal-js-module-blocks/pull/65#discussion_r912412376 !).</p>\n<p>This is my proposed refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/<br>If you are curious, this is how the module blocks spec looks like on top of that refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/proposals/module-blocks - the updates to <code>import()</code> are relevant for &quot;layer 0&quot;, because they show how to import a &quot;module object&quot;.</p>\n<p>I believe that the new logic closely resembles the loading logic introduced by &quot;layer 0&quot;: we could probably just add a step tocheck to 2.d.ii of InnerModuleLoading that calls a <code>module.[[ImportHook]]</code> function, rather than always delegating to <code>HostLoadImportedModule</code>.</p>\n<p>It would probably also help with module reflection: assuming that <code>WebAssembly.Module</code> will be a module source, the proposal could use <code>HostLoadImportedModule(...).[[ModuleSource]]</code> instead of introducing a new <code>HostResolveModuleReflection</code> AO. This would also guarantee that <code>import module x from &quot;x.wasm&quot;</code> and <code>import * as ns from &quot;x.wasm&quot;</code> import the same module, even if they do two different things with it (probably we could guarantee <code>ns === await import(x)</code>).</p>\n<p>I would love to hear your thoughts on this ðŸ™‚</p>\n","mimetype":"text/html"}]},"ts":1658537358726,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$mFqfqL9OKNmIH37LJ52jyAGqthTiyLB9WBkwTg7a38w"},
{"content":{"body":"Your description matches my intuition.","msgtype":"m.text","org.matrix.msc1767.text":"Your description matches my intuition."},"ts":1658537585179,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$qQvgKQ4tvY1ix6-8R7D2AiIcDdJ8_1u9PiKKDNiRMQY"},
{"content":{"body":"Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule.","msgtype":"m.text","org.matrix.msc1767.text":"Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule."},"ts":1658537660093,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$5pfABOWvzTwKw37nSA-V2fi8C7-zj9ypBD4otKlpRkk"},
{"content":{"body":"I reviewed this refactor earlier today and it looks great to me.","msgtype":"m.text"},"ts":1658537707149,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$gentvATL7hsb1WPSJcCSd2wSGnKad7pEJy0wG1zcZwI"},
{"content":{"body":"And I think this generally closes the gap with Caridyâ€™s upcoming changes, which had no reasonable default importHook.","msgtype":"m.text","org.matrix.msc1767.text":"And I think this generally closes the gap with Caridyâ€™s upcoming changes, which had no reasonable default importHook."},"ts":1658537722182,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Qu7DMTZqxEF9osf7XdAcf-wy4404ZWv2qVao1LJrIrY"},
{"content":{"body":"This refactor is great because it makes it clear exactly where importHook is called; it is not too often as currently ","format":"org.matrix.custom.html","formatted_body":"This refactor is great because it makes it clear exactly where importHook is called; it is not too often as currently","msgtype":"m.text"},"ts":1658537937680,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kCweZQHdtFHsoXPRpgLC0rLG-67yo7hHVoM7flSwx5Y"},
{"content":{"body":"IMO it would make sense to land separately in HTML and JS already, since it is a significant cleanup, or at least put out for review as a separated item","msgtype":"m.text"},"ts":1658538004773,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$fE-j4ljflhthkUaDowdguYk5QB-mV_70AVOJiU1nIsk"},
{"content":{"body":"Would it be reasonable for HostLoadImportedModule to be the default [[ImportHook]] of a Realm, such that `Module` instances and module blocks can pick it up from their execution context?","format":"org.matrix.custom.html","formatted_body":"Would it be reasonable for HostLoadImportedModule to be the default [[ImportHook]] of a Realm, such that <code>Module</code> instances and module blocks can pick it up from their execution context?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Would it be reasonable for HostLoadImportedModule to be the default [[ImportHook]] of a Realm, such that `Module` instances and module blocks can pick it up from their execution context?","mimetype":"text/plain"},{"body":"Would it be reasonable for HostLoadImportedModule to be the default [[ImportHook]] of a Realm, such that <code>Module</code> instances and module blocks can pick it up from their execution context?","mimetype":"text/html"}]},"ts":1658538329611,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$MEmenUmnDHK6sw4HZ5_DhPtEgUDTx7mP_EMW3ztPrbs"},
{"content":{"body":"That should be behaviorally equivalent, I think.","msgtype":"m.text","org.matrix.msc1767.text":"That should be behaviorally equivalent, I think."},"ts":1658538351063,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$jG5zQX9i50BZKrPEccZIz4Y_L8q8BlYasrGfK42bpfU"},
{"content":{"body":"Or rather, in the case of the `Module` constructor, picked up from the ModuleConstructor.[[Context]].[[Realm]].[[ImportHook]]","format":"org.matrix.custom.html","formatted_body":"Or rather, in the case of the <code>Module</code> constructor, picked up from the ModuleConstructor.[[Context]].[[Realm]].[[ImportHook]]","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Or rather, in the case of the `Module` constructor, picked up from the ModuleConstructor.[[Context]].[[Realm]].[[ImportHook]]","mimetype":"text/plain"},{"body":"Or rather, in the case of the <code>Module</code> constructor, picked up from the ModuleConstructor.[[Context]].[[Realm]].[[ImportHook]]","mimetype":"text/html"}]},"ts":1658538417548,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$aKUVwDRugbEEBPGaBkXuhwT5m90QwDUJT6RniCSKsjs"},
{"content":{"body":"> <@kriskowal:matrix.org> Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule.\n\nI thought about that, but it has a problem: I expect that we will always call `Promise.resolve` on `[[ImportHook]]()`'s result, because its an user-exposed API. This forces a microtask for every imported module, while the old `HostResolveImportedModule` allowed everything to be synchronous (the new `.LoadRequiredModule` always returns a promise, but hosts can implement a sync `HostLoadImportedModule` and then `.LoadRequiredModule` always returns an _already resolved_ promise)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$5pfABOWvzTwKw37nSA-V2fi8C7-zj9ypBD4otKlpRkk?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule.</blockquote></mx-reply>I thought about that, but it has a problem: I expect that we will always call <code>Promise.resolve</code> on <code>[[ImportHook]]()</code>'s result, because its an user-exposed API. This forces a microtask for every imported module, while the old <code>HostResolveImportedModule</code> allowed everything to be synchronous (the new <code>.LoadRequiredModule</code> always returns a promise, but hosts can implement a sync <code>HostLoadImportedModule</code> and then <code>.LoadRequiredModule</code> always returns an <em>already resolved</em> promise)","m.relates_to":{"m.in_reply_to":{"event_id":"$5pfABOWvzTwKw37nSA-V2fi8C7-zj9ypBD4otKlpRkk"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule.\n\nI thought about that, but it has a problem: I expect that we will always call `Promise.resolve` on `[[ImportHook]]()`'s result, because its an user-exposed API. This forces a microtask for every imported module, while the old `HostResolveImportedModule` allowed everything to be synchronous (the new `.LoadRequiredModule` always returns a promise, but hosts can implement a sync `HostLoadImportedModule` and then `.LoadRequiredModule` always returns an _already resolved_ promise)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$5pfABOWvzTwKw37nSA-V2fi8C7-zj9ypBD4otKlpRkk?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule.</blockquote></mx-reply>I thought about that, but it has a problem: I expect that we will always call <code>Promise.resolve</code> on <code>[[ImportHook]]()</code>'s result, because its an user-exposed API. This forces a microtask for every imported module, while the old <code>HostResolveImportedModule</code> allowed everything to be synchronous (the new <code>.LoadRequiredModule</code> always returns a promise, but hosts can implement a sync <code>HostLoadImportedModule</code> and then <code>.LoadRequiredModule</code> always returns an <em>already resolved</em> promise)","mimetype":"text/html"}]},"ts":1658538467637,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$DK_7-Y6Jk7WNhv1XYYi5DvCt8jVoCH6nYDcffRxITHE"},
{"content":{"body":"I see.","msgtype":"m.text","org.matrix.msc1767.text":"I see."},"ts":1658538492808,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$GI5MqlpWFjIDjneAj6ZNlgjKSzbzVv7a9kkKNh3EWjg"},
{"content":{"body":"I think the ends Iâ€™m looking for could be accomplished another way, thenâ€¦","msgtype":"m.text","org.matrix.msc1767.text":"I think the ends Iâ€™m looking for could be accomplished another way, thenâ€¦"},"ts":1658538545678,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$9PPsWs7fS2TFrx-ktDXRaXLDndcbfkWbKJrxfgGhIaw"},
{"content":{"body":"I know that Bun (a new experimental JS runtime) allows `require()` of ESM, and throws if it uses TLA. So there is at least one project that depends on modules loadnig being mostly synchroous (without TLA, `.Evaluate()` returns an already resolved promise)","format":"org.matrix.custom.html","formatted_body":"I know that Bun (a new experimental JS runtime) allows <code>require()</code> of ESM, and throws if it uses TLA. So there is at least one project that depends on modules loadnig being mostly synchroous (without TLA, <code>.Evaluate()</code> returns an already resolved promise)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I know that Bun (a new experimental JS runtime) allows `require()` of ESM, and throws if it uses TLA. So there is at least one project that depends on modules loadnig being mostly synchroous (without TLA, `.Evaluate()` returns an already resolved promise)","mimetype":"text/plain"},{"body":"I know that Bun (a new experimental JS runtime) allows <code>require()</code> of ESM, and throws if it uses TLA. So there is at least one project that depends on modules loadnig being mostly synchroous (without TLA, <code>.Evaluate()</code> returns an already resolved promise)","mimetype":"text/html"}]},"ts":1658538592964,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$3gn4hFygxUIRgc3Bb0t35m_j7wC_A3r980VepnXYKUM"},
{"content":{"body":"That is, for there to be a slot that the HostLoadImportedModule fits into, which a VirtualHostLoadImportedModule would fit in.","msgtype":"m.text","org.matrix.msc1767.text":"That is, for there to be a slot that the HostLoadImportedModule fits into, which a VirtualHostLoadImportedModule would fit in."},"ts":1658538597923,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$k--qozeNdMPoSU_sD4-YK826W6Qp_9RsVQ8HburAgqQ"},
{"content":{"body":"> <@kriskowal:matrix.org> That is, for there to be a slot that the HostLoadImportedModule fits into, which a VirtualHostLoadImportedModule would fit in.\n\nThat would work, instead of the user function we would store an abstract closure that wraps the user function","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$k--qozeNdMPoSU_sD4-YK826W6Qp_9RsVQ8HburAgqQ?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>That is, for there to be a slot that the HostLoadImportedModule fits into, which a VirtualHostLoadImportedModule would fit in.</blockquote></mx-reply>That would work, instead of the user function we would store an abstract closure that wraps the user function","m.relates_to":{"m.in_reply_to":{"event_id":"$k--qozeNdMPoSU_sD4-YK826W6Qp_9RsVQ8HburAgqQ"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> That is, for there to be a slot that the HostLoadImportedModule fits into, which a VirtualHostLoadImportedModule would fit in.\n\nThat would work, instead of the user function we would store an abstract closure that wraps the user function","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$k--qozeNdMPoSU_sD4-YK826W6Qp_9RsVQ8HburAgqQ?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>That is, for there to be a slot that the HostLoadImportedModule fits into, which a VirtualHostLoadImportedModule would fit in.</blockquote></mx-reply>That would work, instead of the user function we would store an abstract closure that wraps the user function","mimetype":"text/html"}]},"ts":1658538632986,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$kjzyKcnabPB46DNHZk10C3-b-WqM4mQfCv4ZkxJh-5w"},
{"content":{"body":"Yeah, Iâ€™m familiar with Bun. It makes some similar architectural choices to Endo.","msgtype":"m.text","org.matrix.msc1767.text":"Yeah, Iâ€™m familiar with Bun. It makes some similar architectural choices to Endo."},"ts":1658538638086,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$E1OStxr87H3hSrhI5bGl8LJehmwWiiPrWFK8wFbLtkQ"},
{"content":{"body":"Or rather is born from similar requirements: All things must bundle.","msgtype":"m.text","org.matrix.msc1767.text":"Or rather is born from similar requirements: All things must bundle."},"ts":1658538694739,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$mKbhzX6bJCkZkm8KOxQr4qnOecurojZxnYqTnkAIYS4"},
{"content":{"body":"Kris Kowal Do you know what's the best way to share my refactor with Caridy? I see that he's not in this room.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a> Do you know what's the best way to share my refactor with Caridy? I see that he's not in this room.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Kris Kowal Do you know what's the best way to share my refactor with Caridy? I see that he's not in this room.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@kriskowal:matrix.org\">Kris Kowal</a> Do you know what's the best way to share my refactor with Caridy? I see that he's not in this room.","mimetype":"text/html"}]},"ts":1658538954808,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$D0K2-7AwYONOZQplmQ5S2pWl6bMtSx0PcCDuig8JLjw"},
{"content":{"body":"Did a quick scan over the refactor spec:\n\n1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.\n2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.\n3. `InnerModuleLoading` is it a normative change? Say, Now loading a module can be unordered (as I can recall)\n\nModule block spec:\n1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)\n2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)\n3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)","format":"org.matrix.custom.html","formatted_body":"<p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, Now loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Did a quick scan over the refactor spec:\n\n1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.\n2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.\n3. `InnerModuleLoading` is it a normative change? Say, Now loading a module can be unordered (as I can recall)\n\nModule block spec:\n1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)\n2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)\n3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)","mimetype":"text/plain"},{"body":"<p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, Now loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n","mimetype":"text/html"}]},"ts":1658547370917,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$-qWLg3a1LKoh8zH72TzC9aeAgeJeJcHwpKdG7ft0IXg"},
{"content":{"body":" * Did a quick scan over the refactor spec:\n\n1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.\n2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.\n3. `InnerModuleLoading` is it a normative change? Say, today loading a module can be unordered (as I can recall)\n\nModule block spec:\n\n1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)\n2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)\n3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)","format":"org.matrix.custom.html","formatted_body":" * <p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, today loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n","m.new_content":{"body":"Did a quick scan over the refactor spec:\n\n1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.\n2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.\n3. `InnerModuleLoading` is it a normative change? Say, today loading a module can be unordered (as I can recall)\n\nModule block spec:\n\n1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)\n2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)\n3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)","format":"org.matrix.custom.html","formatted_body":"<p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, today loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Did a quick scan over the refactor spec:\n\n1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.\n2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.\n3. `InnerModuleLoading` is it a normative change? Say, today loading a module can be unordered (as I can recall)\n\nModule block spec:\n\n1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)\n2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)\n3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)","mimetype":"text/plain"},{"body":"<p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, today loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$-qWLg3a1LKoh8zH72TzC9aeAgeJeJcHwpKdG7ft0IXg","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Did a quick scan over the refactor spec:\n\n1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.\n2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.\n3. `InnerModuleLoading` is it a normative change? Say, today loading a module can be unordered (as I can recall)\n\nModule block spec:\n\n1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)\n2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)\n3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)","mimetype":"text/plain"},{"body":" * <p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, today loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n","mimetype":"text/html"}]},"ts":1658547391641,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$MxqODiSS1KcEZ2QMHUQXDgRCyBGdNW4v2MpZ5H5VISg"},
{"content":{"body":"To review these PRs, understand the ModuleBlock class to stand for Module/ModuleInstance","msgtype":"m.text"},"ts":1658552540595,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$IqCZ-e1VspDpp9zXQYDFRmAP5EMHFKEjvcLmQWU_Zg4"},
{"content":{"body":"Since we are talking about instances, they exist just within one module graph and therefore one realm. You can make a different module instance (eg with structured clone) to get something similar but within another module graph","msgtype":"m.text"},"ts":1658552638293,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$vcE-x8nsc5yl0x8eu87jb1dAWwtPxbvMVgjy6qaxixk"},
{"content":{"body":"Yes, this change is normative, since it makes all environments follow some of the logic that is currently in HTML. I think this logic is pretty reasonable and makes sense to apply universally but we should be careful to examine the various environments that we have to make sure that is appropriate.","msgtype":"m.text"},"ts":1658552770295,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$VqjW-mv9GLs92A_Xr6PQY-tt0KkOJYL9c2PCEaHVNUE"},
{"content":{"body":"How does ContinueDynamicImport Link/Evaluate the same thing multiple times? I agree that it shouldnâ€™t do that","msgtype":"m.text"},"ts":1658552840128,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5OLr85z9_vv2mPYko1idBWBGz8ZNPeiT3BxBtlmGHRM"},
{"content":{"body":"I agree that the source might not always be visible to JS code. How does that relate to these patches?","msgtype":"m.text"},"ts":1658552905789,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$53G5gEGeCkqs3ra_6QjGesEQvoQSguA2chR5aaSk9Lc"},
{"content":{"body":"About AbstractModuleRecord vs CyclicModuleRecord: currently, the notion of an import/dependency is all in CyclicModuleRecord. We could generalize this but I think it would help to have a driving use case where we donâ€™t want to use CyclicModuleRecord, which I canâ€™t think of. This refactoring seems orthogonal to the current PR.","msgtype":"m.text"},"ts":1658553010106,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$SDufRqn9jKGTDaon8zZon3wf3gjPBYQ-9tvMU7GfARs"},
{"content":{"body":"nicolo-ribaudo: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a>: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"nicolo-ribaudo: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a>: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.","mimetype":"text/html"}]},"ts":1658560500758,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$rzJYkaMQLGa3rb2BzDu6FfO3mmTE2vssXFPn_TNitRE"},
{"content":{"body":"> <@jackworks:matrix.org> Did a quick scan over the refactor spec:\n> \n> 1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.\n> 2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.\n> 3. `InnerModuleLoading` is it a normative change? Say, today loading a module can be unordered (as I can recall)\n> \n> Module block spec:\n> \n> 1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)\n> 2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)\n> 3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)\n\nThanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n  - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n  - HTML always calls them even for all module records imported wither with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$-qWLg3a1LKoh8zH72TzC9aeAgeJeJcHwpKdG7ft0IXg?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br><p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, today loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n</blockquote></mx-reply><p>Thanks or the review!</p>\n<ol>\n<li>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:</li>\n</ol>\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported wither with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n<ol start=\"2\">\n<li>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</li>\n<li>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$-qWLg3a1LKoh8zH72TzC9aeAgeJeJcHwpKdG7ft0IXg"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@jackworks:matrix.org> Did a quick scan over the refactor spec:\n> \n> 1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.\n> 2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.\n> 3. `InnerModuleLoading` is it a normative change? Say, today loading a module can be unordered (as I can recall)\n> \n> Module block spec:\n> \n> 1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)\n> 2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)\n> 3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)\n\nThanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n  - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n  - HTML always calls them even for all module records imported wither with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$-qWLg3a1LKoh8zH72TzC9aeAgeJeJcHwpKdG7ft0IXg?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br><p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, today loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n</blockquote></mx-reply><p>Thanks or the review!</p>\n<ol>\n<li>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:</li>\n</ol>\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported wither with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n<ol start=\"2\">\n<li>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</li>\n<li>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","mimetype":"text/html"}]},"ts":1658573107672,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Gr_fOeLRxjGkbBKCa6QdXqHftlJThTFj_G6dwwVpANI"},
{"content":{"body":"> <@guybedford:matrix.org> nicolo-ribaudo: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.\n\nThere is an editorial note that says \"update all the examples of HostResolveImportedModules\"","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$rzJYkaMQLGa3rb2BzDu6FfO3mmTE2vssXFPn_TNitRE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@guybedford:matrix.org\">@guybedford:matrix.org</a><br><a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a>: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.</blockquote></mx-reply>There is an editorial note that says &quot;update all the examples of HostResolveImportedModules&quot;","m.relates_to":{"m.in_reply_to":{"event_id":"$rzJYkaMQLGa3rb2BzDu6FfO3mmTE2vssXFPn_TNitRE"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@guybedford:matrix.org> nicolo-ribaudo: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.\n\nThere is an editorial note that says \"update all the examples of HostResolveImportedModules\"","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$rzJYkaMQLGa3rb2BzDu6FfO3mmTE2vssXFPn_TNitRE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@guybedford:matrix.org\">@guybedford:matrix.org</a><br><a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a>: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.</blockquote></mx-reply>There is an editorial note that says &quot;update all the examples of HostResolveImportedModules&quot;","mimetype":"text/html"}]},"ts":1658573126385,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$krQSDqojWn8f74JiZB2PsIECINNV5lfccuDBBWMiQHA"},
{"content":{"body":" * Thanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n    - HTML always calls them even for all module records imported wither with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$-qWLg3a1LKoh8zH72TzC9aeAgeJeJcHwpKdG7ft0IXg?via=matrix.org&amp;via=igalia.com&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br><p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, today loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n</blockquote></mx-reply> * <p>Thanks or the review!</p>\n<ol>\n<li>\n<p>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:</p>\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported wither with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n</li>\n<li>\n<p>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</p>\n</li>\n<li>\n<p>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</p>\n</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","m.new_content":{"body":"Thanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n    - HTML always calls them even for all module records imported wither with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","format":"org.matrix.custom.html","formatted_body":"<p>Thanks or the review!</p>\n<ol>\n<li>\n<p>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:</p>\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported wither with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n</li>\n<li>\n<p>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</p>\n</li>\n<li>\n<p>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</p>\n</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Thanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n    - HTML always calls them even for all module records imported wither with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","mimetype":"text/plain"},{"body":"<p>Thanks or the review!</p>\n<ol>\n<li>\n<p>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:</p>\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported wither with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n</li>\n<li>\n<p>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</p>\n</li>\n<li>\n<p>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</p>\n</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$Gr_fOeLRxjGkbBKCa6QdXqHftlJThTFj_G6dwwVpANI","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Thanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n    - HTML always calls them even for all module records imported wither with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$-qWLg3a1LKoh8zH72TzC9aeAgeJeJcHwpKdG7ft0IXg?via=matrix.org&amp;via=igalia.com&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br><p>Did a quick scan over the refactor spec:</p>\n<ol>\n<li><code>ContinueDynamicImport</code> should not try to <code>Link()</code> / <code>Evaluate()</code> multiple times.</li>\n<li>Should <code>[[LoadedModules]]</code> be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.</li>\n<li><code>InnerModuleLoading</code> is it a normative change? Say, today loading a module can be unordered (as I can recall)</li>\n</ol>\n<p>Module block spec:</p>\n<ol>\n<li>Why disallow import a module block from another realm? (13.3.10.1, step 6.a)</li>\n<li>Looks like you're not using the building layers from the compartments? (<code>Module</code> and <code>ModuleSource</code> class)</li>\n<li>IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)</li>\n</ol>\n</blockquote></mx-reply> * <p>Thanks or the review!</p>\n<ol>\n<li>\n<p>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:</p>\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported wither with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n</li>\n<li>\n<p>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</p>\n</li>\n<li>\n<p>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</p>\n</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","mimetype":"text/html"}]},"ts":1658573163883,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$RDDDarwa8ZtRggyHxCmAmcXKDiqzv3QmpnQS6vOe4yI"},
{"content":{"body":" * Thanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n    - HTML always calls them even for all module records imported either with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","format":"org.matrix.custom.html","formatted_body":" * <p>Thanks or the review!</p>\n<ol>\n<li>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported either with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n</li>\n<li>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</li>\n<li>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","m.new_content":{"body":"Thanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n    - HTML always calls them even for all module records imported either with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","format":"org.matrix.custom.html","formatted_body":"<p>Thanks or the review!</p>\n<ol>\n<li>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported either with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n</li>\n<li>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</li>\n<li>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Thanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n    - HTML always calls them even for all module records imported either with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","mimetype":"text/plain"},{"body":"<p>Thanks or the review!</p>\n<ol>\n<li>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported either with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n</li>\n<li>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</li>\n<li>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$Gr_fOeLRxjGkbBKCa6QdXqHftlJThTFj_G6dwwVpANI","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Thanks or the review!\n\n1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the \"public interface\" of module records, and we shold use them rather than checking the `[[Status]]` (which is an \"implementation detail\" of Cyclic Module Records). It already happens that they are called multiple times:\n    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated\n    - HTML always calls them even for all module records imported either with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated\n2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.\n3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.\n\nRegarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.","mimetype":"text/plain"},{"body":" * <p>Thanks or the review!</p>\n<ol>\n<li>Both <code>Link()</code> and <code>Evaluate()</code> are idempotent operations: calling them multiple times has no effect. They are the &quot;public interface&quot; of module records, and we shold use them rather than checking the <code>[[Status]]</code> (which is an &quot;implementation detail&quot; of Cyclic Module Records). It already happens that they are called multiple times:\n<ul>\n<li>ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated</li>\n<li>HTML always calls them even for all module records imported either with a <code>&lt;script&gt;</code> tag or with dynamic import, even if they have already been linked/evaluated</li>\n</ul>\n</li>\n<li>ECMA-262 never fiddles with the internals of non-cyclic module records, for example the <code>.Link()</code> and <code>.Evaluate()</code> implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move <code>LoadRequestedModules</code> to Abstract Module Record, where we have <code>Link</code> and <code>Evaluate</code>.</li>\n<li>Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make <code>HostLoadImportedModule</code> behave just like <code>HostLoadResolvedModule</code>/<code>HostImportModuleDynamically</code> depending on where it's called from. I don't think this refatoring is necessarily normative.</li>\n</ol>\n<p>Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.</p>\n","mimetype":"text/html"}]},"ts":1658573179675,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$C3MAZ9EZ5p0eesO4m8PblXspnhuPPXNvqkVJ9DtnzVM"},
{"content":{"body":"Okay, I just would have thought that the InnerModuleLinking logic repeats a lot of the payload logic you have.","msgtype":"m.text","org.matrix.msc1767.text":"Okay, I just would have thought that the InnerModuleLinking logic repeats a lot of the payload logic you have."},"ts":1658619414637,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$thj9HxibA5ENZk9jNQ20UWqiuSo75OQIZ0YFjWbyigs"}
]