[
{"content":{"body":"Come play the top mmorpg https://feetporn.win/ dmcbqw play soon","msgtype":"m.text","org.matrix.msc1767.text":"Come play the top mmorpg https://feetporn.win/ dmcbqw play soon"},"ts":1659065010212,"senderName":"sis3020","senderId":"@sis3020:matrix.org","id":"$ta7u6rbwF3lHLZ57Dww_n6ha_AwAx4GfUrHZAcdpdCc"},
{"content":{"body":"> <@kriskowal:matrix.org> I read the request as one to find a solution to the problem that named imports can’t trigger an export accessor, the way destructuring a module.exports can.\n\nI don't think access a named import _should_ trigger any kind of user code. That's not a good idea.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$UPAxcKmQA7hj1C_hJg57iKs6thRO0JiK6yACVF6C07E?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>I read the request as one to find a solution to the problem that named imports can’t trigger an export accessor, the way destructuring a module.exports can.</blockquote></mx-reply>I don't think access a named import <em>should</em> trigger any kind of user code. That's not a good idea.","m.relates_to":{"m.in_reply_to":{"event_id":"$UPAxcKmQA7hj1C_hJg57iKs6thRO0JiK6yACVF6C07E"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> I read the request as one to find a solution to the problem that named imports can’t trigger an export accessor, the way destructuring a module.exports can.\n\nI don't think access a named import _should_ trigger any kind of user code. That's not a good idea.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$UPAxcKmQA7hj1C_hJg57iKs6thRO0JiK6yACVF6C07E?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>I read the request as one to find a solution to the problem that named imports can’t trigger an export accessor, the way destructuring a module.exports can.</blockquote></mx-reply>I don't think access a named import <em>should</em> trigger any kind of user code. That's not a good idea.","mimetype":"text/html"}]},"ts":1659070667589,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$g0TarUHbkXSqQlx8n8VTCAQ3-qq9Bx86zsqlR82gIYo"},
{"content":{"body":"> <@littledan:matrix.org> Moddable has also brought up sync loading as an important concern for them\n\nI think maybe XS can implement `Promise` and dynamic `import()` in a way that, \n\n- Promise constructor is not constructable\n- No Async Function\n- dynamic `import` or `Module#import()` will resolve the Promise in sync.\n- Promise.then/catch/finally is not callable\n\nFor the given constraint above, the top level await `await import(\"./some-file.js\")` will looks almost sync (maybe there is some ticking problem?)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$ZvxAiN4H_rvvqWCH3Cm6Ac0hUZKFDjVps69OWZkKqMc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Moddable has also brought up sync loading as an important concern for them</blockquote></mx-reply><p>I think maybe XS can implement <code>Promise</code> and dynamic <code>import()</code> in a way that,</p>\n<ul>\n<li>Promise constructor is not constructable</li>\n<li>No Async Function</li>\n<li>dynamic <code>import</code> or <code>Module#import()</code> will resolve the Promise in sync.</li>\n<li>Promise.then/catch/finally is not callable</li>\n</ul>\n<p>For the given constraint above, the top level await <code>await import(&quot;./some-file.js&quot;)</code> will looks almost sync (maybe there is some ticking problem?)</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$ZvxAiN4H_rvvqWCH3Cm6Ac0hUZKFDjVps69OWZkKqMc"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> Moddable has also brought up sync loading as an important concern for them\n\nI think maybe XS can implement `Promise` and dynamic `import()` in a way that, \n\n- Promise constructor is not constructable\n- No Async Function\n- dynamic `import` or `Module#import()` will resolve the Promise in sync.\n- Promise.then/catch/finally is not callable\n\nFor the given constraint above, the top level await `await import(\"./some-file.js\")` will looks almost sync (maybe there is some ticking problem?)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$ZvxAiN4H_rvvqWCH3Cm6Ac0hUZKFDjVps69OWZkKqMc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Moddable has also brought up sync loading as an important concern for them</blockquote></mx-reply><p>I think maybe XS can implement <code>Promise</code> and dynamic <code>import()</code> in a way that,</p>\n<ul>\n<li>Promise constructor is not constructable</li>\n<li>No Async Function</li>\n<li>dynamic <code>import</code> or <code>Module#import()</code> will resolve the Promise in sync.</li>\n<li>Promise.then/catch/finally is not callable</li>\n</ul>\n<p>For the given constraint above, the top level await <code>await import(&quot;./some-file.js&quot;)</code> will looks almost sync (maybe there is some ticking problem?)</p>\n","mimetype":"text/html"}]},"ts":1659071089073,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$MnTIKbijjRwUz5kuMjGKzLvo0KKMJNA7TMXaC2NnBao"},
{"content":{"body":"Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob’s request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors","msgtype":"m.text"},"ts":1659076638906,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$5SfDFdnN6E7toHhrl_1VLgHJaUZo4J8ABRnVEIeL20g"},
{"content":{"body":"> <@jackworks:matrix.org> I think maybe XS can implement `Promise` and dynamic `import()` in a way that, \n> \n> - Promise constructor is not constructable\n> - No Async Function\n> - dynamic `import` or `Module#import()` will resolve the Promise in sync.\n> - Promise.then/catch/finally is not callable\n> \n> For the given constraint above, the top level await `await import(\"./some-file.js\")` will looks almost sync (maybe there is some ticking problem?)\n\nI think this will look more like `Module#importNow()` for Moddable. It is possible to have both `Module#import()` and `Module#importNow()`, where the latter just throws if the transitive dependencies have not yet been loaded. For parity with Compartment, that would entail having `Module#load()`, which would just do the load phase, driving the `importHook` but not linking, initializing, or executing, such that `Module.prototype.import = async () => { await this.load(); return this.importNow(); }`","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$MnTIKbijjRwUz5kuMjGKzLvo0KKMJNA7TMXaC2NnBao?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br><p>I think maybe XS can implement <code>Promise</code> and dynamic <code>import()</code> in a way that,</p>\n<ul>\n<li>Promise constructor is not constructable</li>\n<li>No Async Function</li>\n<li>dynamic <code>import</code> or <code>Module#import()</code> will resolve the Promise in sync.</li>\n<li>Promise.then/catch/finally is not callable</li>\n</ul>\n<p>For the given constraint above, the top level await <code>await import(\"./some-file.js\")</code> will looks almost sync (maybe there is some ticking problem?)</p>\n</blockquote></mx-reply>I think this will look more like <code>Module#importNow()</code> for Moddable. It is possible to have both <code>Module#import()</code> and <code>Module#importNow()</code>, where the latter just throws if the transitive dependencies have not yet been loaded. For parity with Compartment, that would entail having <code>Module#load()</code>, which would just do the load phase, driving the <code>importHook</code> but not linking, initializing, or executing, such that <code>Module.prototype.import = async () =&gt; { await this.load(); return this.importNow(); }</code>","m.relates_to":{"m.in_reply_to":{"event_id":"$MnTIKbijjRwUz5kuMjGKzLvo0KKMJNA7TMXaC2NnBao"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@jackworks:matrix.org> I think maybe XS can implement `Promise` and dynamic `import()` in a way that, \n> \n> - Promise constructor is not constructable\n> - No Async Function\n> - dynamic `import` or `Module#import()` will resolve the Promise in sync.\n> - Promise.then/catch/finally is not callable\n> \n> For the given constraint above, the top level await `await import(\"./some-file.js\")` will looks almost sync (maybe there is some ticking problem?)\n\nI think this will look more like `Module#importNow()` for Moddable. It is possible to have both `Module#import()` and `Module#importNow()`, where the latter just throws if the transitive dependencies have not yet been loaded. For parity with Compartment, that would entail having `Module#load()`, which would just do the load phase, driving the `importHook` but not linking, initializing, or executing, such that `Module.prototype.import = async () => { await this.load(); return this.importNow(); }`","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$MnTIKbijjRwUz5kuMjGKzLvo0KKMJNA7TMXaC2NnBao?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br><p>I think maybe XS can implement <code>Promise</code> and dynamic <code>import()</code> in a way that,</p>\n<ul>\n<li>Promise constructor is not constructable</li>\n<li>No Async Function</li>\n<li>dynamic <code>import</code> or <code>Module#import()</code> will resolve the Promise in sync.</li>\n<li>Promise.then/catch/finally is not callable</li>\n</ul>\n<p>For the given constraint above, the top level await <code>await import(\"./some-file.js\")</code> will looks almost sync (maybe there is some ticking problem?)</p>\n</blockquote></mx-reply>I think this will look more like <code>Module#importNow()</code> for Moddable. It is possible to have both <code>Module#import()</code> and <code>Module#importNow()</code>, where the latter just throws if the transitive dependencies have not yet been loaded. For parity with Compartment, that would entail having <code>Module#load()</code>, which would just do the load phase, driving the <code>importHook</code> but not linking, initializing, or executing, such that <code>Module.prototype.import = async () =&gt; { await this.load(); return this.importNow(); }</code>","mimetype":"text/html"}]},"ts":1659078268245,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Hm6spoYj9V-12DodokEML2sfoMbKE2OVcXmWouX_7LY"},
{"content":{"body":"> <@kriskowal:matrix.org> Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob’s request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors\n\nI've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters as well as using them in a `require`. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$5SfDFdnN6E7toHhrl_1VLgHJaUZo4J8ABRnVEIeL20g?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob’s request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors</blockquote></mx-reply>I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters as well as using them in a <code>require</code>. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","m.relates_to":{"event_id":"$5SfDFdnN6E7toHhrl_1VLgHJaUZo4J8ABRnVEIeL20g","is_falling_back":false,"m.in_reply_to":{"event_id":"$5SfDFdnN6E7toHhrl_1VLgHJaUZo4J8ABRnVEIeL20g"},"rel_type":"m.thread"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob’s request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors\n\nI've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters as well as using them in a `require`. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$5SfDFdnN6E7toHhrl_1VLgHJaUZo4J8ABRnVEIeL20g?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob’s request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors</blockquote></mx-reply>I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters as well as using them in a <code>require</code>. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","mimetype":"text/html"}]},"ts":1659093375277,"senderName":"naugtur","senderId":"@naugtur:matrix.org","id":"$2giwEk3yPDBYYBzB3QZHA0E3MdB_lE1zLGmVoNt5ww0"},
{"content":{"body":"> <@kriskowal:matrix.org> Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob’s request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors\n\n * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$5SfDFdnN6E7toHhrl_1VLgHJaUZo4J8ABRnVEIeL20g?via=matrix.org&amp;via=igalia.com&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob’s request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors</blockquote></mx-reply> * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","m.new_content":{"body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","format":"org.matrix.custom.html","formatted_body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","mimetype":"text/plain"},{"body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$2giwEk3yPDBYYBzB3QZHA0E3MdB_lE1zLGmVoNt5ww0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob’s request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors\n\n * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$5SfDFdnN6E7toHhrl_1VLgHJaUZo4J8ABRnVEIeL20g?via=matrix.org&amp;via=igalia.com&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob’s request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors</blockquote></mx-reply> * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","mimetype":"text/html"}]},"ts":1659093430059,"senderName":"naugtur","senderId":"@naugtur:matrix.org","id":"$nO7RpijXkAyb70V1EYM5G205Ykg0dJkndxDYIFMyoko"},
{"content":{"body":" * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.\n\n\n\n","format":"org.matrix.custom.html","formatted_body":" * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","m.new_content":{"body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.\n\n\n\n","format":"org.matrix.custom.html","formatted_body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.\n\n\n\n","mimetype":"text/plain"},{"body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$2giwEk3yPDBYYBzB3QZHA0E3MdB_lE1zLGmVoNt5ww0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.\n\n\n\n","mimetype":"text/plain"},{"body":" * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.","mimetype":"text/html"}]},"ts":1659094062798,"senderName":"naugtur","senderId":"@naugtur:matrix.org","id":"$1aURR5OMqu5O10cL_ie4AsC2BK3CEtyWzyvM2-8EaVI"},
{"content":{"body":" * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.\n\n[edit] Looks like the above was interference from the testing method. I'm looking at an example of a getter on cjs `exports` that doesn't trigger the getter when default is imported. \nIt's not accessible as a named export though, which might be the whole point here.","format":"org.matrix.custom.html","formatted_body":" * <p>I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.</p>\n<p>[edit] Looks like the above was interference from the testing method. I'm looking at an example of a getter on cjs <code>exports</code> that doesn't trigger the getter when default is imported.<br>It's not accessible as a named export though, which might be the whole point here.</p>\n","m.new_content":{"body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.\n\n[edit] Looks like the above was interference from the testing method. I'm looking at an example of a getter on cjs `exports` that doesn't trigger the getter when default is imported. \nIt's not accessible as a named export though, which might be the whole point here.","format":"org.matrix.custom.html","formatted_body":"<p>I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.</p>\n<p>[edit] Looks like the above was interference from the testing method. I'm looking at an example of a getter on cjs <code>exports</code> that doesn't trigger the getter when default is imported.<br>It's not accessible as a named export though, which might be the whole point here.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.\n\n[edit] Looks like the above was interference from the testing method. I'm looking at an example of a getter on cjs `exports` that doesn't trigger the getter when default is imported. \nIt's not accessible as a named export though, which might be the whole point here.","mimetype":"text/plain"},{"body":"<p>I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.</p>\n<p>[edit] Looks like the above was interference from the testing method. I'm looking at an example of a getter on cjs <code>exports</code> that doesn't trigger the getter when default is imported.<br>It's not accessible as a named export though, which might be the whole point here.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$2giwEk3yPDBYYBzB3QZHA0E3MdB_lE1zLGmVoNt5ww0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.\n\n[edit] Looks like the above was interference from the testing method. I'm looking at an example of a getter on cjs `exports` that doesn't trigger the getter when default is imported. \nIt's not accessible as a named export though, which might be the whole point here.","mimetype":"text/plain"},{"body":" * <p>I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  <code>require</code>d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.</p>\n<p>[edit] Looks like the above was interference from the testing method. I'm looking at an example of a getter on cjs <code>exports</code> that doesn't trigger the getter when default is imported.<br>It's not accessible as a named export though, which might be the whole point here.</p>\n","mimetype":"text/html"}]},"ts":1659094304383,"senderName":"naugtur","senderId":"@naugtur:matrix.org","id":"$_R978t02CTpchLuCIimcKbUetOolhVHIdDpTmR-7dfk"},
{"content":{"body":"I think it would be at least partially satisfying if CJS to CJS laziness were preserved. Lazy CJS to ESM would be at least possible if ESM just grabs the default. ESM to ESM laziness would be possible too, on the default. But lazy named imports are probably not in the cards. I think sync execution is a different kind of laziness that might give us parity for ESM but with a different mechanism. Deferred execution yet another. ","format":"org.matrix.custom.html","formatted_body":"I think it would be at least partially satisfying if CJS to CJS laziness were preserved. Lazy CJS to ESM would be at least possible if ESM just grabs the default. ESM to ESM laziness would be possible too, on the default. But lazy named imports are probably not in the cards. I think sync execution is a different kind of laziness that might give us parity for ESM but with a different mechanism. Deferred execution yet another.","msgtype":"m.text"},"ts":1659105260040,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Znv6uqy825tMnUj7m8OlUObKyW8Iisiw6-P2VE52NkU"},
{"content":{"body":"And of course code splitting and tree shaking are both ESM native solutions in the same space. I’m a fan of linear progressive bundles: where the bundle has disjoint sub-bundles from a sequence of entrypoints.","msgtype":"m.text"},"ts":1659105493588,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Vc6P157MCBC6LSknmMPwPZZATeXoUZ2wBbcoiBmJUnc"},
{"content":{"body":"Ten years ago, FaceBook did something similar for code delivery, but non-linearly. Their bundles attempted to predict common combinations, with minimal but nonzero overlap","msgtype":"m.text"},"ts":1659105603871,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$NPZSkZ9SMgxXvvfn1h3zKWqqzqu20yu1OPLi_CriGm0"}
]