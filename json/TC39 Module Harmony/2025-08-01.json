[
{"content":{"body":"At plenary bakkot expressed dispreference for ModuleSource carrying a non-transferrable importHook. We pretty fully explored and I’ve shelved a design wit ha separate Module constructor, which I’m open to reexamining, but have come to appreciate primacy of ModuleSource as the target of dynamic import, avoiding a need for an `import module` and `import.module` to designate a module instance without forcing evaluation, and other questions like whether module expressions produce Module or ModuleSource instances.\n\nIt occurs to me that we’ve already stepped away from having a per-module-instance module-map, just a module-map on `new Global`. I think that means that the only reason to prefer `importHook` on `Module` or `ModuleSource` is that resolution of import specifiers to full specifiers in the scope of the global module map. So, I am open to revisiting the idea of constructing a `ModuleSource` with some kind of transferable data bag that could express the base specifier.","format":"org.matrix.custom.html","formatted_body":"<p>At plenary <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a> expressed dispreference for ModuleSource carrying a non-transferrable importHook. We pretty fully explored and I’ve shelved a design wit ha separate Module constructor, which I’m open to reexamining, but have come to appreciate primacy of ModuleSource as the target of dynamic import, avoiding a need for an <code>import module</code> and <code>import.module</code> to designate a module instance without forcing evaluation, and other questions like whether module expressions produce Module or ModuleSource instances.</p>\n<p>It occurs to me that we’ve already stepped away from having a per-module-instance module-map, just a module-map on <code>new Global</code>. I think that means that the only reason to prefer <code>importHook</code> on <code>Module</code> or <code>ModuleSource</code> is that resolution of import specifiers to full specifiers in the scope of the global module map. So, I am open to revisiting the idea of constructing a <code>ModuleSource</code> with some kind of transferable data bag that could express the base specifier.</p>\n","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"msgtype":"m.text"},"ts":1754072290689,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$JueUDMBNX04SQwePllDFQwbPxUR82rjV6JJD-NjPJKg"},
{"content":{"body":"I don’t think I’ve fully realized how far we’ve strayed from Caridy’s model, with per-module-instance module-map just with the concessions for ESM source phase imports. Agoric’s and the Endo project’s objectives are not hindered by this at all, but I need to adjust my mental model for the ramifications of transferrable `ModuleSource` identity for purposes of global module map keys.","format":"org.matrix.custom.html","formatted_body":"I don’t think I’ve fully realized how far we’ve strayed from Caridy’s model, with per-module-instance module-map just with the concessions for ESM source phase imports. Agoric’s and the Endo project’s objectives are not hindered by this at all, but I need to adjust my mental model for the ramifications of transferrable <code>ModuleSource</code> identity for purposes of global module map keys.","m.mentions":{},"msgtype":"m.text"},"ts":1754072465032,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$zlKtLf5OnziVNrlKDPE10q-3wkrg3LXSMm6UwgVBt3Y"},
{"content":{"body":"I didn't really get into this, but another way to address this is to make the import hook or other remapping mechanism something which is provided at import time, rather than being ambient data carried by the Module itself","m.mentions":{},"msgtype":"m.text"},"ts":1754072504490,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$RRQygSJOCjJ9nEq1LWDxH2OQ9zBwfg9ZxBfhvqKn_NU"},
{"content":{"body":"* I didn't really get into this, but another way to address this is to make the import hook or other remapping mechanism something which is provided at import time, rather than being ambient data carried by the ModuleSource itself","m.mentions":{},"m.new_content":{"body":"I didn't really get into this, but another way to address this is to make the import hook or other remapping mechanism something which is provided at import time, rather than being ambient data carried by the ModuleSource itself","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$RRQygSJOCjJ9nEq1LWDxH2OQ9zBwfg9ZxBfhvqKn_NU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1754072894892,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$TWEprh619r0e0INNYRiVAjeTm5hP8VpxO_qAESgGDUo"},
{"content":{"body":"though also, don't these have to be per-module-graph anyway? because of:\n\n- using the mapping { 'C' -> 'X' }, module 'A' imports 'B', which imports 'C'. 'B' now exists in the module graph and references objects from 'X'.\n- later, using the mapping { 'C' -> 'Y' }, someone else in the same module graph imports 'B'. presumably this gets the existing 'B' instance (that's what \"in the same module graph\" means). but then they get a confusing result, because 'B' has already been instantiated with a reference to 'X', whereas they're presumably expecting it to reference 'Y'. \n\nimport maps are global for this reason. they can be updated but updates which would conflict with things observed by previous modules are forbiddne.","format":"org.matrix.custom.html","formatted_body":"<p>though also, don't these have to be per-module-graph anyway? because of:</p>\n<ul>\n<li>using the mapping { 'C' -&gt; 'X' }, module 'A' imports 'B', which imports 'C'. 'B' now exists in the module graph and references objects from 'X'.</li>\n<li>later, using the mapping { 'C' -&gt; 'Y' }, someone else in the same module graph imports 'B'. presumably this gets the existing 'B' instance (that's what \"in the same module graph\" means). but then they get a confusing result, because 'B' has already been instantiated with a reference to 'X', whereas they're presumably expecting it to reference 'Y'.</li>\n</ul>\n<p>import maps are global for this reason. they can be updated but updates which would conflict with things observed by previous modules are forbiddne.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1754073174161,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$_ZIsMY7IGWV1hus_J16Wjd2-sPCM1D66SmqkpOViXmw"},
{"content":{"body":"* though also, don't these have to be per-module-graph anyway? because of:\n\n- using the mapping { 'C' -> 'X' }, module 'A' imports 'B', which imports 'C'. 'B' now exists in the module graph and references objects from 'X'.\n- later, using the mapping { 'C' -> 'Y' }, someone else in the same module graph imports 'B'. presumably this gets the existing 'B' instance (that's what \"in the same module graph\" means). but then they get a confusing result, because 'B' has already been instantiated with a reference to 'X', whereas they're presumably expecting it to reference 'Y'.\n\nimport maps are global for this reason. they can be updated but updates which would conflict with things observed by previous modules are forbidden.","format":"org.matrix.custom.html","formatted_body":"* <p>though also, don't these have to be per-module-graph anyway? because of:</p>\n<ul>\n<li>using the mapping { 'C' -&gt; 'X' }, module 'A' imports 'B', which imports 'C'. 'B' now exists in the module graph and references objects from 'X'.</li>\n<li>later, using the mapping { 'C' -&gt; 'Y' }, someone else in the same module graph imports 'B'. presumably this gets the existing 'B' instance (that's what \"in the same module graph\" means). but then they get a confusing result, because 'B' has already been instantiated with a reference to 'X', whereas they're presumably expecting it to reference 'Y'.</li>\n</ul>\n<p>import maps are global for this reason. they can be updated but updates which would conflict with things observed by previous modules are forbidden.</p>\n","m.mentions":{},"m.new_content":{"body":"though also, don't these have to be per-module-graph anyway? because of:\n\n- using the mapping { 'C' -> 'X' }, module 'A' imports 'B', which imports 'C'. 'B' now exists in the module graph and references objects from 'X'.\n- later, using the mapping { 'C' -> 'Y' }, someone else in the same module graph imports 'B'. presumably this gets the existing 'B' instance (that's what \"in the same module graph\" means). but then they get a confusing result, because 'B' has already been instantiated with a reference to 'X', whereas they're presumably expecting it to reference 'Y'.\n\nimport maps are global for this reason. they can be updated but updates which would conflict with things observed by previous modules are forbidden.","format":"org.matrix.custom.html","formatted_body":"<p>though also, don't these have to be per-module-graph anyway? because of:</p>\n<ul>\n<li>using the mapping { 'C' -&gt; 'X' }, module 'A' imports 'B', which imports 'C'. 'B' now exists in the module graph and references objects from 'X'.</li>\n<li>later, using the mapping { 'C' -&gt; 'Y' }, someone else in the same module graph imports 'B'. presumably this gets the existing 'B' instance (that's what \"in the same module graph\" means). but then they get a confusing result, because 'B' has already been instantiated with a reference to 'X', whereas they're presumably expecting it to reference 'Y'.</li>\n</ul>\n<p>import maps are global for this reason. they can be updated but updates which would conflict with things observed by previous modules are forbidden.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_ZIsMY7IGWV1hus_J16Wjd2-sPCM1D66SmqkpOViXmw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1754073176987,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$S00rE40iVv78vD3uORUrvkickTqIis_61XU3VtFLbro"},
{"content":{"body":"Threading the referrer through dynamic `import` is interesting and I’ll have to think through that more, in particular for the case of importing a ModuleSource instance. I will have to think through the ramifications of that and whether it covers all the cases. The `importHook` would be obligated to always return something obtained from `import` or `import.source`, and that might be funny for `import.source(new ModuleSource(), { type, referrer/url/whatever })`.","format":"org.matrix.custom.html","formatted_body":"Threading the referrer through dynamic <code>import</code> is interesting and I’ll have to think through that more, in particular for the case of importing a ModuleSource instance. I will have to think through the ramifications of that and whether it covers all the cases. The <code>importHook</code> would be obligated to always return something obtained from <code>import</code> or <code>import.source</code>, and that might be funny for <code>import.source(new ModuleSource(), { type, referrer/url/whatever })</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1754073489157,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$Hl0C1Ab39Oq-qRpVf07UGerqkulk4JcxtzE__zeKVrE"},
{"content":{"body":"But yes, my intuition is that this might cover all the motivating cases.","m.mentions":{},"msgtype":"m.text"},"ts":1754073550221,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$dynSsuS5iKPCfpa1ra9as_nz-vqLvOQQc1V54bJuUCw"},
{"content":{"body":"And the confusion you mention above, I believe, is adequately addressed by guybedford’s work in the ESM source phase proposal, where importing a ModuleSource uses a different keyspace than importing by specifier. At the first approximation, these are keyed by the identity of the instance, but that identity is transferrable through postMessage and structuredClone, so at a second approximation, they’re keyed by a transmissible unique identifier among agents of an agent cluster.","format":"org.matrix.custom.html","formatted_body":"And the confusion you mention above, I believe, is adequately addressed by <a href=\"https://matrix.to/#/@guybedford:matrix.org\">guybedford</a>’s work in the ESM source phase proposal, where importing a ModuleSource uses a different keyspace than importing by specifier. At the first approximation, these are keyed by the identity of the instance, but that identity is transferrable through postMessage and structuredClone, so at a second approximation, they’re keyed by a transmissible unique identifier among agents of an agent cluster.","m.mentions":{"user_ids":["@guybedford:matrix.org"]},"msgtype":"m.text"},"ts":1754073674109,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$Y8N1As1ligNY8ZGfhWhT6u26GjNQd2lcr-ZXKSdjPYw"},
{"content":{"body":"An `importHook` is thereby in a position to say “for this module specifier, this is the corresponding module source identity” as a sort of alias.","format":"org.matrix.custom.html","formatted_body":"An <code>importHook</code> is thereby in a position to say “for this module specifier, this is the corresponding module source identity” as a sort of alias.","m.mentions":{},"msgtype":"m.text"},"ts":1754073706314,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$1Ygt2m13fe4YHYSPEvObeldA43vsi6b_j46QtS7CJDE"},
{"content":{"body":"Consider:\n```\nimportHook(importSpecifier, { type, fullSpecifier }) {\n  return import.source(new ModuleSource(''), {\n    type,\n    fullSpecifier: resolve(importSpecifier, fullSpecifier),\n   });\n }\n```","format":"org.matrix.custom.html","formatted_body":"<p>Consider:</p>\n<pre><code>importHook(importSpecifier, { type, fullSpecifier }) {\n  return import.source(new ModuleSource(''), {\n    type,\n    fullSpecifier: resolve(importSpecifier, fullSpecifier),\n   });\n }\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1754073856687,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$dSo8wiXBhw163Wm8B5AT4pMNUix3alrzz9piyiKAhM8"},
{"content":{"body":"Hm, I'm still not understanding. Does the import hook govern only the imports from the module itself, or also its transitive imports? I was assuming the latter but if it's the former then I understand how it could work.","m.mentions":{},"msgtype":"m.text"},"ts":1754076547302,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$mdxAEn4_aywE06H76939bC8BmGXfd_sf29rzhIGMzo8"}
]