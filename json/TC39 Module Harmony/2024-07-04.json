[
{"content":{"body":"The use case for exports() is that you might want to wrap your module in another, and you need to know if there is a default to re-export or not","m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720078363320,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$eY64T5dLCFDtxFFWZcYy2v3rQPBv2gjd82zy2EiVyic"},
{"content":{"body":"Or you want to wrap it and wrap all its exported functions in some logging utility ","m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$eY64T5dLCFDtxFFWZcYy2v3rQPBv2gjd82zy2EiVyic"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720078395970,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$ADE8FimxwQrvHqKZPwmM68B9vyR6iPaRiTfZN6I8XXQ"},
{"content":{"body":"I don’t think this proposal has enough machinery to let you do those re-exports because the set of exported names has to be static.","m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$ADE8FimxwQrvHqKZPwmM68B9vyR6iPaRiTfZN6I8XXQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720091014086,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$6S9rbJi0CZDZgFTpaTJcd3BFaZk4ApqjsLfc7fKEa6U"},
{"content":{"body":"That is what has always confused me about the presence of these methods in the proposal. And bundlers are operating at a very different “time” from the other operations on module sources.","m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$6S9rbJi0CZDZgFTpaTJcd3BFaZk4ApqjsLfc7fKEa6U"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720091080089,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$KQkmfW0fC-SSvTct1ygRi_1hfJvzJ6pM5tIuhBi25wQ"},
{"content":{"body":"for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics ","format":"org.matrix.custom.html","formatted_body":"for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics","msgtype":"m.text"},"ts":1720091215227,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Hp56y2D2hwTHm8UZk-vCJrykuV8_sRRWsXKKvSP4uqQ"},
{"content":{"body":"> <@jackworks:matrix.org> for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics \n\nAgreed. The question in my mind was, which parts will and won’t be useful to incrementally ship, when we aren’t yet including that bunch of other proposals yet. I think we all agree on not cutting off the ability to detect ambiguous star exports in the future, right?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT%3Amatrix.org/%24Hp56y2D2hwTHm8UZk-vCJrykuV8_sRRWsXKKvSP4uqQ\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics</blockquote></mx-reply>Agreed. The question in my mind was, which parts will and won’t be useful to incrementally ship, when we aren’t yet including that bunch of other proposals yet. I think we all agree on not cutting off the ability to detect ambiguous star exports in the future, right?","m.relates_to":{"m.in_reply_to":{"event_id":"$Hp56y2D2hwTHm8UZk-vCJrykuV8_sRRWsXKKvSP4uqQ"}},"msgtype":"m.text"},"ts":1720091860311,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$nAKD2_SvxoupXkuHzrj9c2XnAgTVFZbsqmCQr65VRcE"},
{"content":{"body":"if we reflect \"import {x} from y; export { x }\" as imports: [x from y]; export: [x from y], like the source code was \"export { x } from y\", we can detect this case without make the api surface complex","msgtype":"m.text"},"ts":1720092029938,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$yY0USu0hB0WVJ91N478rUrT2ZJWbGBmwqk-7tSCbQ1c"},
{"content":{"body":"The set has to be static at module creation time. i.e. you could do this:\n```js\nasync function wrapModuleHidingX(url) {\n  const source = await import.source(url);\n  const names = source.exportNames().filter(name => name !== \"x\");\n  return new ModuleSource(`\n    export { ${ names.join(\",\") } } from \"${url}\";\n  `);\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>The set has to be static at module creation time. i.e. you could do this:</p>\n<pre><code class=\"language-js\">async function wrapModuleHidingX(url) {\n  const source = await import.source(url);\n  const names = source.exportNames().filter(name =&gt; name !== \"x\");\n  return new ModuleSource(`\n    export { ${ names.join(\",\") } } from \"${url}\";\n  `);\n}\n</code></pre>\n","m.mentions":{},"m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720103070272,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$gfYplyEBMUwyqOtEzArjV8eGGXq9i5AXGX6zq6oQUdE"},
{"content":{"body":"From the modules call today:\n```js\n// mod1\nexport let a;\nexport { a as b };\n\n// mod2\nexport { a as x } from \"mod1\";\n\n// mod3\nexport { b as x } from \"mod3\";\n\n// mod4\nexport * from \"mod2\"\nexport * from \"mod3\"\n```\n\n_If_ the use case is to detect not-actually-ambiguous ambigous re-exports, then the source of `mod1` needs a way to say that `a` and `b` internally refer to the same local binding","format":"org.matrix.custom.html","formatted_body":"<p>From the modules call today:</p>\n<pre><code class=\"language-js\">// mod1\nexport let a;\nexport { a as b };\n\n// mod2\nexport { a as x } from \"mod1\";\n\n// mod3\nexport { b as x } from \"mod3\";\n\n// mod4\nexport * from \"mod2\"\nexport * from \"mod3\"\n</code></pre>\n<p><em>If</em> the use case is to detect not-actually-ambiguous ambigous re-exports, then the source of <code>mod1</code> needs a way to say that <code>a</code> and <code>b</code> internally refer to the same local binding</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1720108148282,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$mkxKUBxG2V_6UFuh4YDeZ49zP2RraNjUM6dAYqisn4c"},
{"content":{"body":"from the above discussion - it is not enough to have a reexports analysis providing `{ importName, exportName }` it must provide the full list of `{ importName, exportName, localName }` for both reexported and local bindings","format":"org.matrix.custom.html","formatted_body":"from the above discussion - it is not enough to have a reexports analysis providing <code>{ importName, exportName }</code> it must provide the full list of <code>{ importName, exportName, localName }</code> for both reexported and local bindings","m.mentions":{},"msgtype":"m.text"},"ts":1720108367464,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$zbPWzWVrnJwvVsPma7-Wd1JlgKB6Imt_CYTA3MUg6ic"},
{"content":{"body":"I should note, though it is a minor and possibly moot thing, if we do go with the names `imports`, `exports`, and `reexports`, it would simplify migration for `ses` if these were accessors, since they have been direct own value properties of module source objects in our system for some years.","format":"org.matrix.custom.html","formatted_body":"I should note, though it is a minor and possibly moot thing, if we do go with the names <code>imports</code>, <code>exports</code>, and <code>reexports</code>, it would simplify migration for <code>ses</code> if these were accessors, since they have been direct own value properties of module source objects in our system for some years.","m.mentions":{},"msgtype":"m.text"},"ts":1720114062696,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$mLDxKkPIDbmKaXMDxrq4uvKo_Ie6ZaKdKhvvCOjVP9E"},
{"content":{"body":"I think there may still be a compat concern there, since we would likely want to treat `import { x } from 'x'; export { x }` as a reexport and not an exports value","format":"org.matrix.custom.html","formatted_body":"I think there may still be a compat concern there, since we would likely want to treat <code>import { x } from 'x'; export { x }</code> as a reexport and not an exports value","m.mentions":{},"msgtype":"m.text"},"ts":1720114152681,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$AquO-MFrRPQbXV3jRka-ciPlcnpatOQtCh2sEu90D6M"},
{"content":{"body":"If the spec converges on `bindings`, we won’t have any trouble migrating.","format":"org.matrix.custom.html","formatted_body":"If the spec converges on <code>bindings</code>, we won’t have any trouble migrating.","m.mentions":{},"msgtype":"m.text"},"ts":1720114250445,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$0BJwQDJxziz2HQKe8X760h-KyQ6jK6ngvW3WdMKDxdQ"},
{"content":{"body":"If we converge on `imports()`, `exports()`, `reexports()` methods, differentiating legacy will be possible but weird.","format":"org.matrix.custom.html","formatted_body":"If we converge on <code>imports()</code>, <code>exports()</code>, <code>reexports()</code> methods, differentiating legacy will be possible but weird.","m.mentions":{},"msgtype":"m.text"},"ts":1720114305728,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$TtwgHVHYi4i4ofD3zA77bAolPmL8IiUi2U6AJwlRhIU"},
{"content":{"body":"We were considering supporting a single `exports()` with form `{ exportName, importName, localName, module }`, where the existence of `module` implies reexports.\n\nOur discussion today was that it might make sense to update `exports()` to return an object, but still leave out this binding info for now until we have a use case. But that by returning an object we could be forwards compatible with full bindings information if needed in future.","format":"org.matrix.custom.html","formatted_body":"<p>We were considering supporting a single <code>exports()</code> with form <code>{ exportName, importName, localName, module }</code>, where the existence of <code>module</code> implies reexports.</p>\n<p>Our discussion today was that it might make sense to update <code>exports()</code> to return an object, but still leave out this binding info for now until we have a use case. But that by returning an object we could be forwards compatible with full bindings information if needed in future.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1720114504845,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$bjuHO30QWsqNp6CjETzs44SPwwFrOmmsQh3gE86QvqA"},
{"content":{"body":"In this universe, does `imports()` capture all import specifiers regardless of whether they’re in import or export statements?","format":"org.matrix.custom.html","formatted_body":"In this universe, does <code>imports()</code> capture all import specifiers regardless of whether they’re in import or export statements?","m.mentions":{},"msgtype":"m.text"},"ts":1720115093509,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$w4qrffL7EDRae5oN3oLvI2pAVxo9EtNrMRy8uu_5Ou0"},
{"content":{"body":"yes, but without bindings information on imports","m.mentions":{},"msgtype":"m.text"},"ts":1720115124678,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$7ZpmCTwGw6VSIzc6uKVmUSDKnSW7TG2dARNeSH2aUeQ"},
{"content":{"body":"And thus `imports()` and `exports()` would obviate `reexports()`?","format":"org.matrix.custom.html","formatted_body":"And thus <code>imports()</code> and <code>exports()</code> would obviate <code>reexports()</code>?","m.mentions":{},"msgtype":"m.text"},"ts":1720115131565,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$nRFV5bBsvjKZ6jTqHMl35-c477iykImUodio7QBZG5w"},
{"content":{"body":"exports() would effectively be the union of direct and indirect exports yes","m.mentions":{},"msgtype":"m.text"},"ts":1720115162985,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$U0pfFieOP6_S2wMt_UaPZtkPoT3Cs7hpkuTs6a6QjZc"},
{"content":{"body":"A nice thing about this idea in abstract is that `imports()` and `exports()` would serve fully orthogonal motivating use cases.","format":"org.matrix.custom.html","formatted_body":"A nice thing about this idea in abstract is that <code>imports()</code> and <code>exports()</code> would serve fully orthogonal motivating use cases.","m.mentions":{},"msgtype":"m.text"},"ts":1720115189301,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$fHNvED9OkIeiThcmzDZaECrBSftzl6Qloh6VuQXxdgk"},
{"content":{"body":"That is, `imports` is for capturing transitive dependencies and `exports` is for foretelling link errors.","format":"org.matrix.custom.html","formatted_body":"That is, <code>imports</code> is for capturing transitive dependencies and <code>exports</code> is for foretelling link errors.","m.mentions":{},"msgtype":"m.text"},"ts":1720115265855,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$vykzoFKGv_zr2y73D9YXc5N5bMqRvnuKtePzBmgsJKk"},
{"content":{"body":"Bundlers need the former, and bundlers would be more polite with the latter.","m.mentions":{},"msgtype":"m.text"},"ts":1720115289426,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$hToO03QhijUbmZgUEl8MiykeAQFFe-Yu_GJDJso-Iyk"},
{"content":{"body":"And I don’t think anyone loves `reexports`. It would not be missed.","format":"org.matrix.custom.html","formatted_body":"And I don’t think anyone loves <code>reexports</code>. It would not be missed.","m.mentions":{},"msgtype":"m.text"},"ts":1720115353827,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$Y4qxuIZWT5cflNfMVV9G0OSe9RDcr4YNNCUXWA2kzFQ"}
]