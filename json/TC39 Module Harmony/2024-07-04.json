[
{"content":{"body":"The use case for exports() is that you might want to wrap your module in another, and you need to know if there is a default to re-export or not","m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720078363320,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$eY64T5dLCFDtxFFWZcYy2v3rQPBv2gjd82zy2EiVyic"},
{"content":{"body":"Or you want to wrap it and wrap all its exported functions in some logging utility ","m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$eY64T5dLCFDtxFFWZcYy2v3rQPBv2gjd82zy2EiVyic"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720078395970,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$ADE8FimxwQrvHqKZPwmM68B9vyR6iPaRiTfZN6I8XXQ"},
{"content":{"body":"I don’t think this proposal has enough machinery to let you do those re-exports because the set of exported names has to be static.","m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$ADE8FimxwQrvHqKZPwmM68B9vyR6iPaRiTfZN6I8XXQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720091014086,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$6S9rbJi0CZDZgFTpaTJcd3BFaZk4ApqjsLfc7fKEa6U"},
{"content":{"body":"That is what has always confused me about the presence of these methods in the proposal. And bundlers are operating at a very different “time” from the other operations on module sources.","m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$6S9rbJi0CZDZgFTpaTJcd3BFaZk4ApqjsLfc7fKEa6U"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720091080089,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$KQkmfW0fC-SSvTct1ygRi_1hfJvzJ6pM5tIuhBi25wQ"},
{"content":{"body":"for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics ","format":"org.matrix.custom.html","formatted_body":"for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics","msgtype":"m.text"},"ts":1720091215227,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Hp56y2D2hwTHm8UZk-vCJrykuV8_sRRWsXKKvSP4uqQ"},
{"content":{"body":"> <@jackworks:matrix.org> for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics \n\nAgreed. The question in my mind was, which parts will and won’t be useful to incrementally ship, when we aren’t yet including that bunch of other proposals yet. I think we all agree on not cutting off the ability to detect ambiguous star exports in the future, right?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT%3Amatrix.org/%24Hp56y2D2hwTHm8UZk-vCJrykuV8_sRRWsXKKvSP4uqQ\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics</blockquote></mx-reply>Agreed. The question in my mind was, which parts will and won’t be useful to incrementally ship, when we aren’t yet including that bunch of other proposals yet. I think we all agree on not cutting off the ability to detect ambiguous star exports in the future, right?","m.relates_to":{"m.in_reply_to":{"event_id":"$Hp56y2D2hwTHm8UZk-vCJrykuV8_sRRWsXKKvSP4uqQ"}},"msgtype":"m.text"},"ts":1720091860311,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$nAKD2_SvxoupXkuHzrj9c2XnAgTVFZbsqmCQr65VRcE"},
{"content":{"body":"if we reflect \"import {x} from y; export { x }\" as imports: [x from y]; export: [x from y], like the source code was \"export { x } from y\", we can detect this case without make the api surface complex","msgtype":"m.text"},"ts":1720092029938,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$yY0USu0hB0WVJ91N478rUrT2ZJWbGBmwqk-7tSCbQ1c"},
{"content":{"body":"The set has to be static at module creation time. i.e. you could do this:\n```js\nasync function wrapModuleHidingX(url) {\n  const source = await import.source(url);\n  const names = source.exportNames().filter(name => name !== \"x\");\n  return new ModuleSource(`\n    export { ${ names.join(\",\") } } from \"${url}\";\n  `);\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>The set has to be static at module creation time. i.e. you could do this:</p>\n<pre><code class=\"language-js\">async function wrapModuleHidingX(url) {\n  const source = await import.source(url);\n  const names = source.exportNames().filter(name =&gt; name !== \"x\");\n  return new ModuleSource(`\n    export { ${ names.join(\",\") } } from \"${url}\";\n  `);\n}\n</code></pre>\n","m.mentions":{},"m.relates_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8","is_falling_back":true,"m.in_reply_to":{"event_id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1720103070272,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$gfYplyEBMUwyqOtEzArjV8eGGXq9i5AXGX6zq6oQUdE"},
{"content":{"body":"From the modules call today:\n```js\n// mod1\nexport let a;\nexport { a as b };\n\n// mod2\nexport { a as x } from \"mod1\";\n\n// mod3\nexport { b as x } from \"mod3\";\n\n// mod4\nexport * from \"mod2\"\nexport * from \"mod3\"\n```\n\n_If_ the use case is to detect not-actually-ambiguous ambigous re-exports, then the source of `mod1` needs a way to say that `a` and `b` internally refer to the same local binding","format":"org.matrix.custom.html","formatted_body":"<p>From the modules call today:</p>\n<pre><code class=\"language-js\">// mod1\nexport let a;\nexport { a as b };\n\n// mod2\nexport { a as x } from \"mod1\";\n\n// mod3\nexport { b as x } from \"mod3\";\n\n// mod4\nexport * from \"mod2\"\nexport * from \"mod3\"\n</code></pre>\n<p><em>If</em> the use case is to detect not-actually-ambiguous ambigous re-exports, then the source of <code>mod1</code> needs a way to say that <code>a</code> and <code>b</code> internally refer to the same local binding</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1720108148282,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$mkxKUBxG2V_6UFuh4YDeZ49zP2RraNjUM6dAYqisn4c"},
{"content":{"body":"from the above discussion - it is not enough to have a reexports analysis providing `{ importName, exportName }` it must provide the full list of `{ importName, exportName, localName }` for both reexported and local bindings","format":"org.matrix.custom.html","formatted_body":"from the above discussion - it is not enough to have a reexports analysis providing <code>{ importName, exportName }</code> it must provide the full list of <code>{ importName, exportName, localName }</code> for both reexported and local bindings","m.mentions":{},"msgtype":"m.text"},"ts":1720108367464,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$zbPWzWVrnJwvVsPma7-Wd1JlgKB6Imt_CYTA3MUg6ic"}
]