[
{"content":{"body":"I’ve been thinking about Luca Casonato’s proposal for ModuleSource and Module sharing access to private origin information and nicolo-ribaudo’s thought about how that would impact multiple-instantiation. It seems clear that it would not be possible for the host module hook to create more than one instance per url in this scheme. That would make it equivalent in utility to any HTML system where a Worker can be instantiated with a configured resolution behavior (like transferring the import map) and importing by URL specifier.","format":"org.matrix.custom.html","formatted_body":"I’ve been thinking about <a href=\"https://matrix.to/#/@lucacasonato:matrix.org\">Luca Casonato</a>’s proposal for ModuleSource and Module sharing access to private origin information and <a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a>’s thought about how that would impact multiple-instantiation. It seems clear that it would not be possible for the host module hook to create more than one instance per url in this scheme. That would make it equivalent in utility to any HTML system where a Worker can be instantiated with a configured resolution behavior (like transferring the import map) and importing by URL specifier.","m.mentions":{"user_ids":["@lucacasonato:matrix.org","@nicolo-ribaudo:matrix.org"]},"msgtype":"m.text"},"ts":1699372027677,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$PpEZHjAemEXdRpO74O1DlQovtK8Qcotp3BdmY3uhzT8"},
{"content":{"body":"And, to emulate the behavior, new Module would need to support return-override if the ModuleSource had an already recognized physical location.","m.mentions":{},"msgtype":"m.text"},"ts":1699372076497,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$IMgMIREKKufBeCeL7bXBMFPgofWZ47OWz6uw_-sQMtA"},
{"content":{"body":" * And, to emulate the behavior, new Module would need to support return-override if the ModuleSource had an already memoized physical location. I feel that’s an undesirable complication.","m.mentions":{},"m.new_content":{"body":"And, to emulate the behavior, new Module would need to support return-override if the ModuleSource had an already memoized physical location. I feel that’s an undesirable complication.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$IMgMIREKKufBeCeL7bXBMFPgofWZ47OWz6uw_-sQMtA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1699372109286,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$QsTb8AXE64zSm4UEMjkfzf941seMdMje1Z-_EzXlL3I"},
{"content":{"body":"It would be good to review yulia’s idea for transferring modules between agents. It seems likely that it would imply fewer complications.","format":"org.matrix.custom.html","formatted_body":"It would be good to review <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia</a>’s idea for transferring modules between agents. It seems likely that it would imply fewer complications.","m.mentions":{"user_ids":["@yulia:mozilla.org"]},"msgtype":"m.text"},"ts":1699372159346,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$b12oTw2ZVe_-J0H878jaJV2d7P_Bkdoodg0KaWK0ddM"},
{"content":{"body":"I would need to know more about the restrictions in terms of what we are visualizing. I think my idea won't help here (which was sharing the import graph by passing it, otherwise falling back on the behavior that would be implemented by modulesource). I think there are other restrictions that would make that unacceptable. From a browser perspective, we don't allow multi-instantiating within the same loader, and I would need to understand a few concrete usecases for this. On the other hand, i can see a usecase for multi-instantiation with module unloading, one frustration we have is the inability to garbage collect a module after instantiation (after which point it is no longer used). We have an api for that internally. Regarding the shared module map: I can see this as making things more memory efficient and allowing us to just pull the sources that we need, in the configuration that we need, and re-run them. However, passing that between different contexts with dynamic import seems like it could be very complex and open up possibilities I haven't thought about. I think the most restricted case is the safest.  We could also introduce a distinction between the dynamic import links and the static ones, and allow sharing of only static links, meaning that dynamic import links would reconstruct, or would point to a sub-tree that is all static and preloaded. but like i said -- this seems verrrry complex","m.mentions":{},"msgtype":"m.text"},"ts":1699372944674,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$yw_WwYNRZaAFm4cCiji4AFBUDETYth5LSB3t3xsDVaQ"},
{"content":{"body":" * I would need to know more about the restrictions in terms of what we are virtualizing. I'm not at all confident in my comment the other day. I think my idea won't help here (which was sharing the import graph by passing it, otherwise falling back on the behavior that would be implemented by modulesource). I think there are other restrictions that would make that unacceptable. From a browser perspective, we don't allow multi-instantiating within the same loader, and I would need to understand a few concrete usecases for this. On the other hand, i can see a usecase for multi-instantiation with module unloading, one frustration we have is the inability to garbage collect a module after instantiation (after which point it is no longer used). We have an api for that internally. Regarding the shared module map: I can see this as making things more memory efficient and allowing us to just pull the sources that we need, in the configuration that we need, and re-run them. However, passing that between different contexts with dynamic import seems like it could be very complex and open up possibilities I haven't thought about. I think the most restricted case is the safest.  We could also introduce a distinction between the dynamic import links and the static ones, and allow sharing of only static links, meaning that dynamic import links would reconstruct, or would point to a sub-tree that is all static and preloaded. but like i said -- this seems verrrry complex","m.mentions":{},"m.new_content":{"body":"I would need to know more about the restrictions in terms of what we are virtualizing. I'm not at all confident in my comment the other day. I think my idea won't help here (which was sharing the import graph by passing it, otherwise falling back on the behavior that would be implemented by modulesource). I think there are other restrictions that would make that unacceptable. From a browser perspective, we don't allow multi-instantiating within the same loader, and I would need to understand a few concrete usecases for this. On the other hand, i can see a usecase for multi-instantiation with module unloading, one frustration we have is the inability to garbage collect a module after instantiation (after which point it is no longer used). We have an api for that internally. Regarding the shared module map: I can see this as making things more memory efficient and allowing us to just pull the sources that we need, in the configuration that we need, and re-run them. However, passing that between different contexts with dynamic import seems like it could be very complex and open up possibilities I haven't thought about. I think the most restricted case is the safest.  We could also introduce a distinction between the dynamic import links and the static ones, and allow sharing of only static links, meaning that dynamic import links would reconstruct, or would point to a sub-tree that is all static and preloaded. but like i said -- this seems verrrry complex","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$yw_WwYNRZaAFm4cCiji4AFBUDETYth5LSB3t3xsDVaQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1699372966893,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$k97dBPdPZ120e8sSkT0u_EXGmPEFYPoSL7tMcUuShG8"},
{"content":{"body":" * I would need to know more about the restrictions in terms of what we are virtualizing. I'm not at all confident in my comment the other day. I think my idea won't help here (which was sharing the import graph by passing it, otherwise falling back on the behavior that would be implemented by modulesource). I think there are other restrictions that would make that unacceptable. From a browser perspective, we don't allow multi-instantiating within the same loader. The spec allows it, but all browsers cache (and the spec is being updated to reflect this. I would need to understand a few concrete usecases for this. On the other hand, i can see a usecase for multi-instantiation with module unloading, one frustration we have is the inability to garbage collect a module after instantiation (after which point it is no longer used). We have an api for that internally. Regarding the shared module map: I can see this as making things more memory efficient and allowing us to just pull the sources that we need, in the configuration that we need, and re-run them. However, passing that between different contexts with dynamic import seems like it could be very complex and open up possibilities I haven't thought about. I think the most restricted case is the safest.  We could also introduce a distinction between the dynamic import links and the static ones, and allow sharing of only static links, meaning that dynamic import links would reconstruct, or would point to a sub-tree that is all static and preloaded. but like i said -- this seems verrrry complex","m.mentions":{},"m.new_content":{"body":"I would need to know more about the restrictions in terms of what we are virtualizing. I'm not at all confident in my comment the other day. I think my idea won't help here (which was sharing the import graph by passing it, otherwise falling back on the behavior that would be implemented by modulesource). I think there are other restrictions that would make that unacceptable. From a browser perspective, we don't allow multi-instantiating within the same loader. The spec allows it, but all browsers cache (and the spec is being updated to reflect this. I would need to understand a few concrete usecases for this. On the other hand, i can see a usecase for multi-instantiation with module unloading, one frustration we have is the inability to garbage collect a module after instantiation (after which point it is no longer used). We have an api for that internally. Regarding the shared module map: I can see this as making things more memory efficient and allowing us to just pull the sources that we need, in the configuration that we need, and re-run them. However, passing that between different contexts with dynamic import seems like it could be very complex and open up possibilities I haven't thought about. I think the most restricted case is the safest.  We could also introduce a distinction between the dynamic import links and the static ones, and allow sharing of only static links, meaning that dynamic import links would reconstruct, or would point to a sub-tree that is all static and preloaded. but like i said -- this seems verrrry complex","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$yw_WwYNRZaAFm4cCiji4AFBUDETYth5LSB3t3xsDVaQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1699373008997,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$5qQfkjZLOIBYDuOS8obGju2ql1F6H7ZqMyoiGRw0mW0"},
{"content":{"body":"yulia: Caridy’s proposing adding a local map from specifier to module instance on each module instance that is intended to unlock multi-instancing, including hot reload, test scaffolds, mocking, &c. Having module instances also unlocks the ability to assemble a module graph without executing it, which is useful for bundling, building a fully-specified import map, &c.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia</a>: Caridy’s proposing adding a local map from specifier to module instance on each module instance that is intended to unlock multi-instancing, including hot reload, test scaffolds, mocking, &amp;c. Having module instances also unlocks the ability to assemble a module graph without executing it, which is useful for bundling, building a fully-specified import map, &amp;c.","m.mentions":{"user_ids":["@yulia:mozilla.org"]},"msgtype":"m.text"},"ts":1699373355062,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$qenGF9tsUXy7wLb5IAVBoolnF51t9vI2dmKb6TnDKoo"},
{"content":{"body":" * yulia: Caridy’s proposing adding a local map from specifier to module instance on each module instance that is intended to unlock multi-instancing, including hot reload, test scaffolds, mocking, &c. Having module instances also unlocks the ability to assemble a module graph without executing it, which is useful for bundling, building a fully-specified import map, &c. https://tc39.es/proposal-compartments/0-module-and-module-source.html","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia</a>: Caridy’s proposing adding a local map from specifier to module instance on each module instance that is intended to unlock multi-instancing, including hot reload, test scaffolds, mocking, &amp;c. Having module instances also unlocks the ability to assemble a module graph without executing it, which is useful for bundling, building a fully-specified import map, &amp;c. https://tc39.es/proposal-compartments/0-module-and-module-source.html","m.mentions":{},"m.new_content":{"body":"yulia: Caridy’s proposing adding a local map from specifier to module instance on each module instance that is intended to unlock multi-instancing, including hot reload, test scaffolds, mocking, &c. Having module instances also unlocks the ability to assemble a module graph without executing it, which is useful for bundling, building a fully-specified import map, &c. https://tc39.es/proposal-compartments/0-module-and-module-source.html","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia</a>: Caridy’s proposing adding a local map from specifier to module instance on each module instance that is intended to unlock multi-instancing, including hot reload, test scaffolds, mocking, &amp;c. Having module instances also unlocks the ability to assemble a module graph without executing it, which is useful for bundling, building a fully-specified import map, &amp;c. https://tc39.es/proposal-compartments/0-module-and-module-source.html","m.mentions":{"user_ids":["@yulia:mozilla.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$qenGF9tsUXy7wLb5IAVBoolnF51t9vI2dmKb6TnDKoo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1699373361200,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$HbShBqH1QDt-uhK2ocXvn_qwIDLmF17wZCwc_Nm_FfM"},
{"content":{"body":"in my mind this is like a distributed network where each node knows its neighbors, is that the right image?","m.mentions":{},"msgtype":"m.text"},"ts":1699373487396,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$XmRzRRl0f5VYf5wBzt6wjTKQIawkp29EIEwdZ2yFWfE"},
{"content":{"body":" * in my mind this is like a distributed network where each node knows its neighbors but not the whole graph, is that the right image?","m.mentions":{},"m.new_content":{"body":"in my mind this is like a distributed network where each node knows its neighbors but not the whole graph, is that the right image?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$XmRzRRl0f5VYf5wBzt6wjTKQIawkp29EIEwdZ2yFWfE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1699373495967,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$L7pNUVBGZrTm1JlfHVO8bObYUeEQq6aDbmhYfJv386c"},
{"content":{"body":"(with the kid right now so my attention is split)","m.mentions":{},"msgtype":"m.text"},"ts":1699373536098,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$in7yB22WLE4kn2FmtKqEDu8jZ4XY7zo76ko9YPc2ZV0"}
]