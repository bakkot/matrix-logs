[
{"content":{"body":"This very interesting case came up in Node.js today  -https://github.com/bojavou/disambiguate-namespace","m.mentions":{},"msgtype":"m.text"},"ts":1720025507867,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$k_GstK8KkTI28byEH-RXB4HorhQj7WoO7sVaDH9ZQdI"},
{"content":{"body":"Apparently when `export * as X from 'x'` was specified, we inadvertantly specified value deduping!!?????","format":"org.matrix.custom.html","formatted_body":"Apparently when <code>export * as X from 'x'</code> was specified, we inadvertantly specified value deduping!!?????","m.mentions":{},"msgtype":"m.text"},"ts":1720025525771,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$klC-R2VCrzLju59GSXlY7IMhu3BzTn1fIOB3fmTx1aI"},
{"content":{"body":"that is `export * from './a'; export * from './b'` where both `a` and `b` contain the source text `export * as X from 'x'` IS NOT AMBIGUOUS!","format":"org.matrix.custom.html","formatted_body":"that is <code>export * from './a'; export * from './b'</code> where both <code>a</code> and <code>b</code> contain the source text <code>export * as X from 'x'</code> IS NOT AMBIGUOUS!","m.mentions":{},"msgtype":"m.text"},"ts":1720025554223,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$9sngYCu-pPIHYIdjR3VKTjZQKQPdnT5rr-8hsmCNVJg"},
{"content":{"body":"might be some V8 / Firefox divergence in the implementation","m.mentions":{},"msgtype":"m.text"},"ts":1720025572495,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$HjAVxjKY8TrS61oBJ3n26vTTaLUzSVnlF3sYV-DQmbo"},
{"content":{"body":"are we sure this is the correctly specified behaviour and not algorithmically incorrect?","m.mentions":{},"msgtype":"m.text"},"ts":1720025782640,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$qF6jXGZ9Mi3W0_csqCjKqCqs9g4NMOOHppZxaXZqdJY"},
{"content":{"body":"would be interested to hear others' takes on this","m.mentions":{},"msgtype":"m.text"},"ts":1720025826447,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$91A6_qiKAQ74Ds54o9BlU77sXkuh6FWPvxoBcQYU_go"},
{"content":{"body":"I have no idea about what is the expected behaviour, but it'd be interesting to dig up the notes to see if it was every discussed","m.mentions":{},"msgtype":"m.text"},"ts":1720026209980,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$CW_56cfgyPJ2z5gn_WrZ_5lSj5b5lXgt0aJkLeDle3s"},
{"content":{"body":"Firefox and V8 do different things - it's an error in V8 and works in Firefox","m.mentions":{},"msgtype":"m.text"},"ts":1720027231092,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$1w8XXp0RR99z11-132P83k1ZHl6dAucd8y3OqALoizk"},
{"content":{"body":"strictly speaking, Firefox is following the spec correctly","m.mentions":{},"msgtype":"m.text"},"ts":1720027239816,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$fAjDto-4U6Duyyhzkx8_7C0M9f03xg36zsjIfrDZDuQ"},
{"content":{"body":"My intuition is that the spec behaviour is correct, since those two exports are pointing to the same binding internally","m.mentions":{},"msgtype":"m.text"},"ts":1720028000298,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$47JIg7uoFt_-6PiN79rkdl6qLCJ2dQm0mbgSoT8ZGmQ"},
{"content":{"body":"For most people either behaviour would be ok though, since nobody thinks about the binding of the namespace object (but only about its value)","m.mentions":{},"msgtype":"m.text"},"ts":1720028042545,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$1ktSypGxS5QqKpqXhQn31MYl70QlhhU02koZUQSSOKU"},
{"content":{"body":"It's the same as `export { foo as X } from \"X\"` in both `a` and `b` is not ambiguous, because they both point to the binding `foo`. `*` is just a special binding name, the same way as `default` is","format":"org.matrix.custom.html","formatted_body":"It's the same as <code>export { foo as X } from \"X\"</code> in both <code>a</code> and <code>b</code> is not ambiguous, because they both point to the binding <code>foo</code>. <code>*</code> is just a special binding name, the same way as <code>default</code> is","m.mentions":{},"msgtype":"m.text"},"ts":1720028113009,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$YAZxfB7Mpsy5zzjJDQdRM993QsrTdqgtvDu7N-6T2J4"},
{"content":{"body":"I suppose so!","m.mentions":{},"msgtype":"m.text"},"ts":1720028137453,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$wxNxHPhN9XKWVWE4UHeimclOhMWc8CPb10B24dMKfUk"},
{"content":{"body":"so for this case, `import {x} from '...'; export {x}` must be reflected as \"reexport\" x from '...'","format":"org.matrix.custom.html","formatted_body":"so for this case, <code>import {x} from '...'; export {x}</code> must be reflected as &quot;reexport&quot; x from '...'","msgtype":"m.text"},"ts":1720030509141,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$DelPXz5wTv9i9Tkjq119ZguZhGzyjSfgTsKZnB5eF7E"},
{"content":{"body":"> <@guybedford:matrix.org> This very interesting case came up in Node.js today  -https://github.com/bojavou/disambiguate-namespace\n\notherwise this might not be reflected","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$k_GstK8KkTI28byEH-RXB4HorhQj7WoO7sVaDH9ZQdI\">In reply to</a> <a href=\"https://matrix.to/#/@guybedford:matrix.org\">@guybedford:matrix.org</a><br>This very interesting case came up in Node.js today  -https:&#47;&#47;github.com&#47;bojavou&#47;disambiguate-namespace</blockquote></mx-reply>otherwise this might not be reflected","m.relates_to":{"m.in_reply_to":{"event_id":"$k_GstK8KkTI28byEH-RXB4HorhQj7WoO7sVaDH9ZQdI"}},"msgtype":"m.text"},"ts":1720030533764,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$m6ERbqUJmz8iDoNM6odq7nLL1isaj16ZqVtHHZVKENs"},
{"content":{"body":"On the topic of `bindings` vs `imports`, `exports`, and `reexports`, I observed during TG3 that a virtual module source constructor needs bindings, but doesn’t necessarily need to be able to see the bindings of another module source. To make a mock, seeing the `exports` of another module is sufficient to create the appropriate `bindings`. So, I am no longer convinced there’s an issue with coherence.","format":"org.matrix.custom.html","formatted_body":"On the topic of <code>bindings</code> vs <code>imports</code>, <code>exports</code>, and <code>reexports</code>, I observed during TG3 that a virtual module source constructor needs bindings, but doesn’t necessarily need to be able to see the bindings of another module source. To make a mock, seeing the <code>exports</code> of another module is sufficient to create the appropriate <code>bindings</code>. So, I am no longer convinced there’s an issue with coherence.","m.mentions":{},"msgtype":"m.text"},"ts":1720043945527,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$VxH-CykJuFBuFG1mqwEo8LEB-r4fGed52Lp2rdFohOw"},
{"content":{"body":"Consider:\n```\nconst source = new ModuleSouce({\n  bindings: [\n    { import: 'x', as: 'a', from: '1.js' },\n    {import: 'x', as: 'b', from: '2.js'},\n    {export: 'default'},\n    {exportAllFrom: '3.js'},\n  ],\n  evaluate(ns) {\n    ns.default = ns.a + ns.b;\n  },\n});\nsource.exports() // ['default']\nsource.imports() // ['1.js', '2.js']\nsource.reexports() // ['3.js']\n```","format":"org.matrix.custom.html","formatted_body":"<p>Consider:</p>\n<pre><code>const source = new ModuleSouce({\n  bindings: [\n    { import: 'x', as: 'a', from: '1.js' },\n    {import: 'x', as: 'b', from: '2.js'},\n    {export: 'default'},\n    {exportAllFrom: '3.js'},\n  ],\n  evaluate(ns) {\n    ns.default = ns.a + ns.b;\n  },\n});\nsource.exports() // ['default']\nsource.imports() // ['1.js', '2.js']\nsource.reexports() // ['3.js']\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1720044196115,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$mSn7SXuKXcvOwDmib3A-3xiOaHeayTjMYhokZDN8aus"},
{"content":{"body":" * Consider:\n\n```\nconst source = new ModuleSouce({\n  bindings: [\n    {import: 'x', as: 'a', from: '1.js' },\n    {import: 'x', as: 'b', from: '2.js'},\n    {export: 'default'},\n    {exportAllFrom: '3.js'},\n  ],\n  evaluate(ns) {\n    ns.default = ns.a + ns.b;\n  },\n});\nsource.exports() // ['default']\nsource.imports() // ['1.js', '2.js']\nsource.reexports() // ['3.js']\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Consider:</p>\n<pre><code>const source = new ModuleSouce({\n  bindings: [\n    {import: 'x', as: 'a', from: '1.js' },\n    {import: 'x', as: 'b', from: '2.js'},\n    {export: 'default'},\n    {exportAllFrom: '3.js'},\n  ],\n  evaluate(ns) {\n    ns.default = ns.a + ns.b;\n  },\n});\nsource.exports() // ['default']\nsource.imports() // ['1.js', '2.js']\nsource.reexports() // ['3.js']\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Consider:\n\n```\nconst source = new ModuleSouce({\n  bindings: [\n    {import: 'x', as: 'a', from: '1.js' },\n    {import: 'x', as: 'b', from: '2.js'},\n    {export: 'default'},\n    {exportAllFrom: '3.js'},\n  ],\n  evaluate(ns) {\n    ns.default = ns.a + ns.b;\n  },\n});\nsource.exports() // ['default']\nsource.imports() // ['1.js', '2.js']\nsource.reexports() // ['3.js']\n```","format":"org.matrix.custom.html","formatted_body":"<p>Consider:</p>\n<pre><code>const source = new ModuleSouce({\n  bindings: [\n    {import: 'x', as: 'a', from: '1.js' },\n    {import: 'x', as: 'b', from: '2.js'},\n    {export: 'default'},\n    {exportAllFrom: '3.js'},\n  ],\n  evaluate(ns) {\n    ns.default = ns.a + ns.b;\n  },\n});\nsource.exports() // ['default']\nsource.imports() // ['1.js', '2.js']\nsource.reexports() // ['3.js']\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mSn7SXuKXcvOwDmib3A-3xiOaHeayTjMYhokZDN8aus","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720044208488,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$gBh50Ll7k-yOp9EQujxsiHVMw54Z6WzwwmrIx2rTDfM"},
{"content":{"body":"the argument that is currently swaying it back for me is actually this ambiguous question though","m.mentions":{},"msgtype":"m.text"},"ts":1720044318238,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$MtJiSoxqa8mCIRVsoyypUvkOxEHeZPbpT2G0MUt1rc8"},
{"content":{"body":"that even if we can determine the names, determining ambiguous exports requires the reexports information","m.mentions":{},"msgtype":"m.text"},"ts":1720044335010,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$i3-iR2wXodmG1sdv8_jM1n84yQNbx37koXGa3lzd-5g"},
{"content":{"body":"so you can make a wrapper with just knowing export star and direct exports","m.mentions":{},"msgtype":"m.text"},"ts":1720044357337,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$AT9aDSXWm5RJQFK-Y2SJIBm0zSbmDcmE9vlXM_PaPCU"},
{"content":{"body":"but you can't detect ambiguous exports without reexports info","m.mentions":{},"msgtype":"m.text"},"ts":1720044370508,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$62U_PYcg9bLXn6Co1s1lSfgLAmFFz_cPCzwShzMPPIw"},
{"content":{"body":"I know when we previously discussed that we determined that was okay not to be able to do","m.mentions":{},"msgtype":"m.text"},"ts":1720044384296,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$yV2IiIdjnRGBbZHWhu6Q8w6pZNZfE56cD_RW2GHA03s"},
{"content":{"body":"but there's certainly an argument there still I suppose","m.mentions":{},"msgtype":"m.text"},"ts":1720044395027,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$rY98kCoo2SVbAGATo_K67iUtCINneBR_lDUkyfyCi4g"},
{"content":{"body":"We may need to go deeper into concrete cases to resolve the question.","m.mentions":{},"msgtype":"m.text"},"ts":1720044431451,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$LLv0LrMQ2TBMQ0tRKup60SswjSg4Dx3VaFS7i2-p8Qw"},
{"content":{"body":"I have so far struggled to come up with a compelling “auto-mock” with the primitives we have.","m.mentions":{},"msgtype":"m.text"},"ts":1720044473019,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$8I3K4tdV4NWHEA1gMgwr1Fcm1Xj0YKi7DWgjX1JuI4w"},
{"content":{"body":"But with some more specific constraints and limitations, there’s probably a reasonable, practical module adapter for something like instrumenting all exported functions.","m.mentions":{},"msgtype":"m.text"},"ts":1720044551829,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$9d47cb_ZQ3SmBIyD8Tyuu3GvTItk4_is5byvimXOnVQ"},
{"content":{"body":"It probably remains useful to think about the question in relation to virtual module sources.","m.mentions":{},"msgtype":"m.text"},"ts":1720044607137,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$TSslTvtS_lUPx79hfxWUzGOaRq5BExPC9LWecIYFTNY"},
{"content":{"body":"I guess the use case question is also - how useful is it to trace reexports","m.mentions":{},"msgtype":"m.text"},"ts":1720044632637,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$m_5p6Wa2iDsPjzov7oAAZwO0NgLbLRnkXXWZ27Wbv90"},
{"content":{"body":"and determine their original definer","m.mentions":{},"msgtype":"m.text"},"ts":1720044639438,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$Vw1Cj7WCbsJAnT3-EXY1oOgBu54Zkx1_IyYKe2AlCR8"},
{"content":{"body":"Right. We need a motivating use case. I can imagine one, but it’s pretty imaginary: providing primitives for LSP to navigate the the definition of an imported name.","m.mentions":{},"msgtype":"m.text"},"ts":1720044699399,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$AUo7AdKlCp3cq3W-XJJWctUFRWvBCLFqkm7ELpRsFR8"},
{"content":{"body":"That’s tenuous because your LSP is going to be looking at the full source text.","m.mentions":{},"msgtype":"m.text"},"ts":1720044735511,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$wQXoJvCZVBNxPhmIWnTAFHO-RS5atVyhB4CHkAYih_o"},
{"content":{"body":"The real and present motivating use case for module source reflection is a bundler, and for a bundler, all you need is `imports()` (assuming it includes `reexports()`). You need `exports()` only to fail-during-bundling if there’s a name collision between multiple reexports.","format":"org.matrix.custom.html","formatted_body":"The real and present motivating use case for module source reflection is a bundler, and for a bundler, all you need is <code>imports()</code> (assuming it includes <code>reexports()</code>). You need <code>exports()</code> only to fail-during-bundling if there’s a name collision between multiple reexports.","m.mentions":{},"msgtype":"m.text"},"ts":1720044873762,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$uZfOOFmctagHsUljP1c-L-OX12lZbUho4IYuV_Z7Ja8"}
]