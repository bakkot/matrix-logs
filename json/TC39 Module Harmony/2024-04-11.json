[
{"content":{"body":"> <@guybedford:matrix.org> this is a good discussion topic, I'd suggest we bring it up in our next meeting if you'd like to join\n\nNobody's here, after opening the agenda doc I guess I was supposed to have added something to the schedule?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$0NfKfmhSwuzV6mScomGVUaT2pw_uz1AhyfUABPwD8Ks?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@guybedford:matrix.org\">@guybedford:matrix.org</a><br>this is a good discussion topic, I&#39;d suggest we bring it up in our next meeting if you&#39;d like to join</blockquote></mx-reply>Nobody's here, after opening the agenda doc I guess I was supposed to have added something to the schedule?","m.mentions":{"user_ids":["@guybedford:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$0NfKfmhSwuzV6mScomGVUaT2pw_uz1AhyfUABPwD8Ks"}},"msgtype":"m.text"},"ts":1712847816218,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$EZ_cOECERyxEcLtiRgmQexsTdfzPN4QfEjVOGdvIirw"},
{"content":{"body":"That or TC39 is still happening and \"next meeting\" didn't mean next week 😄","m.mentions":{},"msgtype":"m.text"},"ts":1712847966468,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$0EqzU_4tO_FesXxKoyvwbjq0JB6mubC5ktxI8Z7MlUU"},
{"content":{"body":"Whips sorry 😅","msgtype":"m.text"},"ts":1712848164259,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$SpL58rnhacY-V062HQVt8rofC_HAdmFmrRA_EEF4tMU"},
{"content":{"body":"Yes, TC39 is still happening ","msgtype":"m.text"},"ts":1712848188383,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$RpiPu4ysXb8jhHTIaBKbDv6FYNzfSxEjUy8FyKDMiKc"},
{"content":{"body":"I rushed out of bed for nothing! 😄 (oops)","m.mentions":{},"msgtype":"m.text"},"ts":1712848207994,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$HVVVRl5GpoOBjg2yPkDq7oo7DiGcI5A61fFl4Wwe9T8"},
{"content":{"body":"(TC39 meetings tend to all be cancelled during TC39 plenary week)","m.mentions":{},"msgtype":"m.text"},"ts":1712848218290,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$bdXKU-9_X61tK8Y1OrkqLdRJCvv-qxWyPlF-5HprBDI"},
{"content":{"body":"sorry, we'll try to update the calendar for accuracy in the future","m.mentions":{},"msgtype":"m.text"},"ts":1712849355060,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$UG6ymvnj1dv-PrLv83-3H03q057SBmtvKPM2cHHTRgA"},
{"content":{"body":"No worries.","m.mentions":{},"msgtype":"m.text"},"ts":1712849366678,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$UWC9G_tid44B_IN3vcmCp-9U09Xs02BsofqNAzKxZXw"},
{"content":{"body":"Also btw, if you have something to talk about please make sure it's on the agenda! We usually consider meeting to be automatically cancelled if 12 hours before the agenda is empty, so that you don't have to wake up early just to discover that the meeting is cancelled","m.mentions":{},"msgtype":"m.text"},"ts":1712849768376,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$1QNvPfgc_zRUKOyAJyzYsSqdQKtcbpZS4xdwtH3cDUE"},
{"content":{"body":"Oh the agenda says \"30 minutes\"","m.mentions":{},"msgtype":"m.text"},"ts":1712849804517,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$XAHg-xkS_cOsY2xZ5m3Gwj69goue180Iz2UoTXz7PMA"},
{"content":{"body":"I always assumed it was something like \"the evening before for the west coast\" 😅","m.mentions":{},"msgtype":"m.text"},"ts":1712849822261,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$6Rtam0gqV8beavO-hLsLPQXK-7kOOEAwhKQG-Tq7xes"},
{"content":{"body":"> <@jakebailey:matrix.org> Yeah. So on one hand, I'd be happy with `import.meta.require` being re-proposed, especially now that Node has `import.meta.dirname` and such, but there's the more general solution too!\n\nIt seems to me what you need that is missing from the spec is the ability to do lazy resolution/more lenient resolution, so that you don't get an error by importing from an id that doesn't resolve","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$vwOI6i9CdYHwF4Piiow6Ahc1z2aIBaZz5Xg75NbnxiA?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jakebailey:matrix.org\">@jakebailey:matrix.org</a><br>Yeah. So on one hand, I'd be happy with <code>import.meta.require</code> being re-proposed, especially now that Node has <code>import.meta.dirname</code> and such, but there's the more general solution too!</blockquote></mx-reply>It seems to me what you need that is missing from the spec is the ability to do lazy resolution/more lenient resolution, so that you don't get an error by importing from an id that doesn't resolve","m.mentions":{"user_ids":["@jakebailey:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$vwOI6i9CdYHwF4Piiow6Ahc1z2aIBaZz5Xg75NbnxiA"}},"msgtype":"m.text"},"ts":1712852105679,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$ZSPVm1kGKhSy-UUjCzYiEs21Y62D4hENCps8QC9quXI"},
{"content":{"body":"(Or maybe there can be an error, but one you can catch)","m.mentions":{},"msgtype":"m.text"},"ts":1712852177829,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$GvcsxD2Iy6aYK5S4DJ1Qn5ys1ZU73WtVUyup1lrsyKA"},
{"content":{"body":" * (Or maybe there can be an error, but one you can catch, though that's not necessarily good for perf)","m.mentions":{},"m.new_content":{"body":"(Or maybe there can be an error, but one you can catch, though that's not necessarily good for perf)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$GvcsxD2Iy6aYK5S4DJ1Qn5ys1ZU73WtVUyup1lrsyKA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712852195475,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$p-o3rdALYy3C3PC6Ts9BVDnmBuDTfRW40RD3LKhVkaM"},
{"content":{"body":"It'd be at the top level, so there's nothing to catch. Technically speaking an import that is allowed to be there but not resolve and not error if not touched is fine, but my impression was that the deferred import proposal still errored on a failed import","m.mentions":{},"msgtype":"m.text"},"ts":1712852243313,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$h1sU3SCypuzY3-7VtUG8zTromQeDcekmt7i_dX72WR0"},
{"content":{"body":"> <@qzhang:igalia.com> It seems to me what you need that is missing from the spec is the ability to do lazy resolution/more lenient resolution, so that you don't get an error by importing from an id that doesn't resolve\n\nThis is a good thread to pull on. browsers are also wondering whether we could let some other types of early errors to come later.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$ZSPVm1kGKhSy-UUjCzYiEs21Y62D4hENCps8QC9quXI?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@qzhang:igalia.com\">@qzhang:igalia.com</a><br>It seems to me what you need that is missing from the spec is the ability to do lazy resolution/more lenient resolution, so that you don't get an error by importing from an id that doesn't resolve</blockquote></mx-reply>This is a good thread to pull on. browsers are also wondering whether we could let some other types of early errors to come later.","m.mentions":{"user_ids":["@qzhang:igalia.com","@jakebailey:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ZSPVm1kGKhSy-UUjCzYiEs21Y62D4hENCps8QC9quXI"}},"msgtype":"m.text"},"ts":1712852249831,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$1WdRwUrkz6-F3edyNuQ2RBNdRjLc-zipR92f9kUsG2w"},
{"content":{"body":"so, we'd end up breaking in browsers if we had `node:fs`","format":"org.matrix.custom.html","formatted_body":"so, we'd end up breaking in browsers if we had <code>node:fs</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712852251343,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$O2d6hhrQKw-XXE9DDhqsh-nBj5UlrGfuLJ8OGPn_RHQ"},
{"content":{"body":"Yes, the import defer proposal is deferring evaluation, not resolution","m.mentions":{},"msgtype":"m.text"},"ts":1712852277813,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$iIorG1_XzEILkh4l8Zk2Je_s1LAbcJGGAFy1Io3UFII"},
{"content":{"body":"WebAssembly started with eager validation, but later permitted lazy","m.mentions":{},"msgtype":"m.text"},"ts":1712852311721,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hXUbwv7cKTkeCCcvgajO-sWYpLLEqkmb147NWAV_7oc"},
{"content":{"body":"But, at some level I think that the abiliy to conditionally require synchronously is a useful construct for some libraries who can't go async, and a sync import now seems like a possible thing","m.mentions":{},"msgtype":"m.text"},"ts":1712852333895,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$9V5LZjVRmmJV5fbpLUtCW3lJXi2kxlBQlPJdD5ne9Ms"},
{"content":{"body":" * But, at some level I think that the abiliy to conditionally require synchronously is a useful construct for some libraries who can't go async, and a sync import now seems like a possible thing without being in CJS","m.mentions":{},"m.new_content":{"body":"But, at some level I think that the abiliy to conditionally require synchronously is a useful construct for some libraries who can't go async, and a sync import now seems like a possible thing without being in CJS","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$9V5LZjVRmmJV5fbpLUtCW3lJXi2kxlBQlPJdD5ne9Ms","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712852351297,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$MXzkQrw0FbQUm9CPaHYwYdFS55U1E41KRE_UhLpdZsI"},
{"content":{"body":"But it does sound like a generally useful thing to have, for example for modules that want to work on both the browser and server side runtimes, otherwise, everyone just puts everything on the global","m.mentions":{},"msgtype":"m.text"},"ts":1712852379037,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$zjmW6PUnsa5XDI62rUYoajCbVZebsOpJaRJd_m6_zII"},
{"content":{"body":"> <@qzhang:igalia.com> But it does sound like a generally useful thing to have, for example for modules that want to work on both the browser and server side runtimes, otherwise, everyone just puts everything on the global\n\nit's true, this is a sort of missing capability from CJS","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$zjmW6PUnsa5XDI62rUYoajCbVZebsOpJaRJd_m6_zII?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@qzhang:igalia.com\">@qzhang:igalia.com</a><br>But it does sound like a generally useful thing to have, for example for modules that want to work on both the browser and server side runtimes, otherwise, everyone just puts everything on the global</blockquote></mx-reply>it's true, this is a sort of missing capability from CJS","m.mentions":{"user_ids":["@qzhang:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zjmW6PUnsa5XDI62rUYoajCbVZebsOpJaRJd_m6_zII"}},"msgtype":"m.text"},"ts":1712852491156,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$87Z2UsVy-Crbt0zRMNQF_ipGyfV72L2ZldL1H73eNcM"},
{"content":{"body":"CJS require() couples resolution + evaluation in one go. ESM import decouples them. In the use case we are talking about, the conditional part is resolution, which currently in ESM is only possible in dynamic import()","m.mentions":{},"msgtype":"m.text"},"ts":1712852495377,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$EJvID8_PDtD6fkhSpW7D7EHVkq9y7a7B5hS-kCfW8m8"},
{"content":{"body":"I guess I don't see those as separate for this use case, since I want the whole thing to be conditional; we precheck and only do this on a \"node like\" system","m.mentions":{},"msgtype":"m.text"},"ts":1712852630270,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$uFuUadd8TNW5PhCob9hoMOt96Y6sZnZ8rDESNoH2ZfU"},
{"content":{"body":"My understanding of the history of ESM is fairly limited, but I think the decoupling in ESM is part of the design (personally, I love it, because that unlocks things like module snapshot, and the coupling in CJS makes me sad). My guess is, making the resolution lazy/conditional/more leinient via syntax is still possible while preserving the decoupling in ESM (could be too naive, too)","m.mentions":{},"msgtype":"m.text"},"ts":1712852714188,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$YnpF8ZtFv7w_VnEob2EWJez6akwcecDXkAu6--GiMFY"},
{"content":{"body":" * My understanding of the history of ESM is fairly limited, but I think the decoupling in ESM is part of the design (personally, I love it, because that unlocks things like module snapshot and tree shaking, and the coupling in CJS makes me sad). My guess is, making the resolution lazy/conditional/more leinient via syntax is still possible while preserving the decoupling in ESM (could be too naive, too)","m.mentions":{},"m.new_content":{"body":"My understanding of the history of ESM is fairly limited, but I think the decoupling in ESM is part of the design (personally, I love it, because that unlocks things like module snapshot and tree shaking, and the coupling in CJS makes me sad). My guess is, making the resolution lazy/conditional/more leinient via syntax is still possible while preserving the decoupling in ESM (could be too naive, too)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$YnpF8ZtFv7w_VnEob2EWJez6akwcecDXkAu6--GiMFY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712852729148,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$cU0QhjuZ8b4qBGVNCBela0KAj1fPJWaC6qBbxXpLHYc"},
{"content":{"body":" * My understanding of the history of ESM is fairly limited, but I think the decoupling in ESM is part of the design (personally, I love it, because that unlocks things like module snapshot and tree shaking, and the coupling in CJS makes me sad). My guess is, making the resolution lazy/conditional/more leinient via syntax is still possible while preserving the decoupling in ESM (I could be too naive, too)","m.mentions":{},"m.new_content":{"body":"My understanding of the history of ESM is fairly limited, but I think the decoupling in ESM is part of the design (personally, I love it, because that unlocks things like module snapshot and tree shaking, and the coupling in CJS makes me sad). My guess is, making the resolution lazy/conditional/more leinient via syntax is still possible while preserving the decoupling in ESM (I could be too naive, too)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$YnpF8ZtFv7w_VnEob2EWJez6akwcecDXkAu6--GiMFY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712852756247,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$6Sm91N8JoCW4gfdf-WiBgwU8b_w8Rw7MG5eqBbo_y3Q"},
{"content":{"body":"That's my understanding too 🙂","m.relates_to":{"event_id":"$YnpF8ZtFv7w_VnEob2EWJez6akwcecDXkAu6--GiMFY","is_falling_back":true,"m.in_reply_to":{"event_id":"$YnpF8ZtFv7w_VnEob2EWJez6akwcecDXkAu6--GiMFY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712852858177,"senderName":"jakobjingleheimer","senderId":"@jakobjingleheimer:matrix.org","id":"$1TtJhWFtTgIWAao2YCU56HyLC1piS4motKr5xfOk804"},
{"content":{"body":"Or maybe, it doesn't need new syntax, just special, standardized import attributes across the platforms that allow weak imports, like what's described in https://lea.verou.me/blog/2020/11/the-case-for-weak-dependencies-in-js/, but also for `import`","format":"org.matrix.custom.html","formatted_body":"Or maybe, it doesn't need new syntax, just special, standardized import attributes across the platforms that allow weak imports, like what's described in https://lea.verou.me/blog/2020/11/the-case-for-weak-dependencies-in-js/, but also for <code>import</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712853486663,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$wIDVhZAIK13NErRUGwsvbt76OFFeO_yeQaHCaoJxW5s"},
{"content":{"body":"(With the potential downside of, what happens if you need to support older versions of browsers/runtimes? 😵‍💫)","m.mentions":{},"msgtype":"m.text"},"ts":1712853559906,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$uxC33_crcBDiqjvdKDu-2W36UX_ZeKqtOLEN7beuHKI"},
{"content":{"body":"jakebailey: Sorry for the meeting confusion - the modules meeting is currently every two weeks, with the next meeting next Thursday. It is still an unsolved mystery why the TC39 calendar isn't reflecting this publicly, while for those of us in the meeting it is reflecting the correct bi-weekly schedule.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jakebailey:matrix.org\">jakebailey</a>: Sorry for the meeting confusion - the modules meeting is currently every two weeks, with the next meeting next Thursday. It is still an unsolved mystery why the TC39 calendar isn't reflecting this publicly, while for those of us in the meeting it is reflecting the correct bi-weekly schedule.","m.mentions":{"user_ids":["@jakebailey:matrix.org"]},"msgtype":"m.text"},"ts":1712853698217,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$WgSDDRW6uJByaMvoRNHQVHSoXJFXNVreajcjFXytvyU"},
{"content":{"body":"```js\nimport fs from \"node:fs\" with { weak: true };\n\n// 1. In Node.js or other runtimes with Node.js compat layer, fs is fs,\n// also applies to named exports for APIs that are supported.\n// 2. In runtimes that don't support it/browsers, fs is undefined..or a symbol? Or something else?\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">import fs from \"node:fs\" with { weak: true };\n\n// 1. In Node.js or other runtimes with Node.js compat layer, fs is fs,\n// also applies to named exports for APIs that are supported.\n// 2. In runtimes that don't support it/browsers, fs is undefined..or a symbol? Or something else?\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712853759864,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$ih3jfAT7cHVwmb2KKxxk8grVRY6aF5HQbC4B-czADDY"},
{"content":{"body":" * jakebailey: Sorry for the meeting confusion. I missed that the meeting was cancelled this week myself, and thought we were on a bi-weekly schedule for some reason!","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@jakebailey:matrix.org\">jakebailey</a>: Sorry for the meeting confusion. I missed that the meeting was cancelled this week myself, and thought we were on a bi-weekly schedule for some reason!","m.mentions":{},"m.new_content":{"body":"jakebailey: Sorry for the meeting confusion. I missed that the meeting was cancelled this week myself, and thought we were on a bi-weekly schedule for some reason!","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jakebailey:matrix.org\">jakebailey</a>: Sorry for the meeting confusion. I missed that the meeting was cancelled this week myself, and thought we were on a bi-weekly schedule for some reason!","m.mentions":{"user_ids":["@jakebailey:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$WgSDDRW6uJByaMvoRNHQVHSoXJFXNVreajcjFXytvyU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712853767795,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$GT1FnA3yoP_q0_q24aaDZ2ej22KNDEyJSI5rLlnV-I0"},
{"content":{"body":"The complexity here was more or less why I was re-proposing `import.meta.require` / `import.meta.importSync` or something, a la `import.meta.dirname` and so on which are Node specific constructs","format":"org.matrix.custom.html","formatted_body":"The complexity here was more or less why I was re-proposing <code>import.meta.require</code> / <code>import.meta.importSync</code> or something, a la <code>import.meta.dirname</code> and so on which are Node specific constructs","m.mentions":{},"msgtype":"m.text"},"ts":1712854002385,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$3EB-274lzIpMEYEFBcmpYZ9MxIq_UCqXngAI96w1oY0"},
{"content":{"body":"With require(ESM), it really felt like we could finally make TypeScript be ESM without breaking the ecosystem, but then I realized that I couldn't without some way to conditionally handle node, so it became self defeating... Without resorting to import conditions anyway, which is where things get super frustrating internally for us","m.mentions":{},"msgtype":"m.text"},"ts":1712854086996,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$JElb0LGA0vjJyL79EzTg3gwBqkPKXujPtpXN4M5kpzk"},
{"content":{"body":"conditional static imports is definitely something we need. there used to be a proposal but it doesn't seem to even be in the proposals table","m.mentions":{},"msgtype":"m.text"},"ts":1712854334839,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$MegSgbd7zExr0NqIiGwsbqOjo-JdUVwGWYABV5_zQq0"},
{"content":{"body":"Why?","m.relates_to":{"event_id":"$MegSgbd7zExr0NqIiGwsbqOjo-JdUVwGWYABV5_zQq0","is_falling_back":true,"m.in_reply_to":{"event_id":"$MegSgbd7zExr0NqIiGwsbqOjo-JdUVwGWYABV5_zQq0"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712854432880,"senderName":"jakobjingleheimer","senderId":"@jakobjingleheimer:matrix.org","id":"$IGCc41drDf58w5TT7a7Iww-H1yg3aXKd0bhuWH8miSY"},
{"content":{"body":"i'm not sure, i'll have to track that down","m.mentions":{},"m.relates_to":{"event_id":"$MegSgbd7zExr0NqIiGwsbqOjo-JdUVwGWYABV5_zQq0","is_falling_back":true,"m.in_reply_to":{"event_id":"$IGCc41drDf58w5TT7a7Iww-H1yg3aXKd0bhuWH8miSY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712854499039,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$bcwE05lSC1zK14eNuHk8Cz2ugTY_LS3-arZJoQA6exs"},
{"content":{"body":"To be clear, i meant why do we need them?","m.relates_to":{"event_id":"$MegSgbd7zExr0NqIiGwsbqOjo-JdUVwGWYABV5_zQq0","is_falling_back":true,"m.in_reply_to":{"event_id":"$bcwE05lSC1zK14eNuHk8Cz2ugTY_LS3-arZJoQA6exs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712854524622,"senderName":"jakobjingleheimer","senderId":"@jakobjingleheimer:matrix.org","id":"$ReP9hJ_-BgoXa8QsDsv07Mz9YD6Ck4PkE6zdEfD5kA4"},
{"content":{"body":"There are some more pragmatic pros to `import.meta.require`, like being (significantly?) faster than `import cjs` on Node.js, or easier to feature detect. Cons are...one more thing on the `import.meta`? I think some consider that evil?","format":"org.matrix.custom.html","formatted_body":"There are some more pragmatic pros to <code>import.meta.require</code>, like being (significantly?) faster than <code>import cjs</code> on Node.js, or easier to feature detect. Cons are...one more thing on the <code>import.meta</code>? I think some consider that evil?","m.mentions":{},"msgtype":"m.text"},"ts":1712854564647,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$O6C1ebfXwaKdHcp2KqNsii4ZD2cqniYgiiWECrvt1vY"},
{"content":{"body":"> <@qzhang:igalia.com> CJS require() couples resolution + evaluation in one go. ESM import decouples them. In the use case we are talking about, the conditional part is resolution, which currently in ESM is only possible in dynamic import()\n\nI think it’s useful to distinguish Node.js loader from abstract CJS loaders (which is a tent with Node.js, bundlers, and others). That makes it clear that the choice to couple resolution and evaluation is a Node.js-specific constraint. CJS and ESM were both designed to cover the web’s need to resolve specifiers for transitive dependencies before evaluation. CJS doesn’t even mandate that evaluation ever occur on the stack of require. I could buy the case for an `import.now` in the language (and `importNowHook` on virtual `Module` instances)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$EJvID8_PDtD6fkhSpW7D7EHVkq9y7a7B5hS-kCfW8m8?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@qzhang:igalia.com\">@qzhang:igalia.com</a><br>CJS require() couples resolution + evaluation in one go. ESM import decouples them. In the use case we are talking about, the conditional part is resolution, which currently in ESM is only possible in dynamic import()</blockquote></mx-reply>I think it’s useful to distinguish Node.js loader from abstract CJS loaders (which is a tent with Node.js, bundlers, and others). That makes it clear that the choice to couple resolution and evaluation is a Node.js-specific constraint. CJS and ESM were both designed to cover the web’s need to resolve specifiers for transitive dependencies before evaluation. CJS doesn’t even mandate that evaluation ever occur on the stack of require. I could buy the case for an <code>import.now</code> in the language (and <code>importNowHook</code> on virtual <code>Module</code> instances)","m.mentions":{"user_ids":["@qzhang:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$EJvID8_PDtD6fkhSpW7D7EHVkq9y7a7B5hS-kCfW8m8"}},"msgtype":"m.text"},"ts":1712854572098,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$vZlq4d8szefDLXJNA8WBmYnAd_qgNsNXnz62qHyNbRM"},
{"content":{"body":" * There are some more pragmatic pros to `import.meta.require`, like being (significantly?) faster than `import cjs` or `import builtin` on Node.js, or easier to feature detect. Cons are...one more thing on the `import.meta`? I think some consider that evil?","format":"org.matrix.custom.html","formatted_body":" * There are some more pragmatic pros to <code>import.meta.require</code>, like being (significantly?) faster than <code>import cjs</code> or <code>import builtin</code> on Node.js, or easier to feature detect. Cons are...one more thing on the <code>import.meta</code>? I think some consider that evil?","m.mentions":{},"m.new_content":{"body":"There are some more pragmatic pros to `import.meta.require`, like being (significantly?) faster than `import cjs` or `import builtin` on Node.js, or easier to feature detect. Cons are...one more thing on the `import.meta`? I think some consider that evil?","format":"org.matrix.custom.html","formatted_body":"There are some more pragmatic pros to <code>import.meta.require</code>, like being (significantly?) faster than <code>import cjs</code> or <code>import builtin</code> on Node.js, or easier to feature detect. Cons are...one more thing on the <code>import.meta</code>? I think some consider that evil?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$O6C1ebfXwaKdHcp2KqNsii4ZD2cqniYgiiWECrvt1vY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712854592055,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$1mk2LtsMUrsdx09GEfBmLxs8XekqmDfFyMROfHWlXxY"},
{"content":{"body":"ah! well, for one, platform-specific deps - like `node:fs` for example. you might want to sync-import a polyfill, but only when a feature test fails.","format":"org.matrix.custom.html","formatted_body":"ah! well, for one, platform-specific deps - like <code>node:fs</code> for example. you might want to sync-import a polyfill, but only when a feature test fails.","m.mentions":{},"m.relates_to":{"event_id":"$MegSgbd7zExr0NqIiGwsbqOjo-JdUVwGWYABV5_zQq0","is_falling_back":true,"m.in_reply_to":{"event_id":"$ReP9hJ_-BgoXa8QsDsv07Mz9YD6Ck4PkE6zdEfD5kA4"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712854614226,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$umFzuJpaOkK0-J_tnoK7ALfVnF2JOO7MVQViNMujaQo"},
{"content":{"body":"The Node.js case is interesting historically. Ryan Dahl was reluctant to embrace CommonJS. When I talked to Bryan Cantril about it in 2010, his take was that it didn’t matter, even though it ran against the “everything async” grain of the platform, because linking a dynamic library is never going to be async.","m.mentions":{},"msgtype":"m.text"},"ts":1712854655586,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$JCMRTUsO0dwOKh3BAiNu67HBr7f6ZoWVl4MA6jceWh4"},
{"content":{"body":"or at least, you need it to be sync the vast majority of the time","m.mentions":{},"msgtype":"m.text"},"ts":1712854720447,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$HQJQtNde1ScC_PX3bTaRzSIDYKINfjYaZNiEuorAxCU"},
{"content":{"body":"In the CommonJS mailing list days, there was a great deal of talk about a `require.async` that would return a promise like dynamic import, but there wasn’t agreement on the design of promises yet.","format":"org.matrix.custom.html","formatted_body":"In the CommonJS mailing list days, there was a great deal of talk about a <code>require.async</code> that would return a promise like dynamic import, but there wasn’t agreement on the design of promises yet.","m.mentions":{},"msgtype":"m.text"},"ts":1712854741254,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$fzrdWMKir_Hu_SlRXNm6YgUPNZ6pJhKHRh4JJIR3ooA"},
{"content":{"body":"One of the other pressures to make Node.js resolution synchronous was that the CJS loader doesn’t opportunistically discover the `package.json` tree, as the ESM does. Embracing the package tree is _interesting_ because resolution can be synchronous if you know every reachable path, and is analogous to having an import-map on the web.","format":"org.matrix.custom.html","formatted_body":"One of the other pressures to make Node.js resolution synchronous was that the CJS loader doesn’t opportunistically discover the <code>package.json</code> tree, as the ESM does. Embracing the package tree is <em>interesting</em> because resolution can be synchronous if you know every reachable path, and is analogous to having an import-map on the web.","m.mentions":{},"msgtype":"m.text"},"ts":1712854857132,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$pnAVsdykbxnQ5xX87xFUb1O20gg7FaBTOb8pKVD2aL8"},
{"content":{"body":"History aside, I think we should have `import.now`, deferred exports, and with both of these, deferring resolution to conditional use is possible.","format":"org.matrix.custom.html","formatted_body":"History aside, I think we should have <code>import.now</code>, deferred exports, and with both of these, deferring resolution to conditional use is possible.","m.mentions":{},"msgtype":"m.text"},"ts":1712854925205,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$TPo8DdAoqlEZeHp8XFA4JBWWrU4lf0eScNSKrnY6f_4"},
{"content":{"body":"node's ESM doesn't allow that tho, because of conditional exports, and because of subpath patterns","m.mentions":{},"msgtype":"m.text"},"ts":1712854985500,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$XCx9M4LDdmkJ9jWCeWCXukAwjGDOhaXgQqFqAm6Bmds"},
{"content":{"body":" * node's ESM doesn't allow knowing every reachable path tho, because of conditional exports, and because of subpath patterns","m.mentions":{},"m.new_content":{"body":"node's ESM doesn't allow knowing every reachable path tho, because of conditional exports, and because of subpath patterns","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$XCx9M4LDdmkJ9jWCeWCXukAwjGDOhaXgQqFqAm6Bmds","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712854998525,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$OM5IskDUtBhBfCyqrAQgdMe0FU0ibUg2vkfhu8Wzlck"},
{"content":{"body":" * node's ESM doesn't allow knowing every reachable path tho, because of conditional exports, and because of subpath patterns (unless you include the filesystem and treat it as immutable, in which case CJS provides the exact same property)","m.mentions":{},"m.new_content":{"body":"node's ESM doesn't allow knowing every reachable path tho, because of conditional exports, and because of subpath patterns (unless you include the filesystem and treat it as immutable, in which case CJS provides the exact same property)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$XCx9M4LDdmkJ9jWCeWCXukAwjGDOhaXgQqFqAm6Bmds","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712855018447,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$bSQoWigqNtLKJ6W9cUfDtQW3UpNfBXH9ZFOjnLzou5Y"},
{"content":{"body":"What does `opportunistically discover the package.json tree` ?","format":"org.matrix.custom.html","formatted_body":"What does <code>opportunistically discover the package.json tree</code> ?","m.mentions":{},"m.relates_to":{"event_id":"$pnAVsdykbxnQ5xX87xFUb1O20gg7FaBTOb8pKVD2aL8","is_falling_back":true,"m.in_reply_to":{"event_id":"$pnAVsdykbxnQ5xX87xFUb1O20gg7FaBTOb8pKVD2aL8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712855037173,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$vV8eaQo5FI4s0oSbhA3W-Tr2KvXH1PMR-SKdcCgSlNw"},
{"content":{"body":" * What does `opportunistically discover the package.json tree`  mean?","format":"org.matrix.custom.html","formatted_body":" * What does <code>opportunistically discover the package.json tree</code>  mean?","m.mentions":{"user_ids":["@kriskowal:aelf.land"]},"m.new_content":{"body":"What does `opportunistically discover the package.json tree`  mean?","format":"org.matrix.custom.html","formatted_body":"What does <code>opportunistically discover the package.json tree</code>  mean?","m.mentions":{"user_ids":["@kriskowal:aelf.land"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$vV8eaQo5FI4s0oSbhA3W-Tr2KvXH1PMR-SKdcCgSlNw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712855040814,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$PzJFOoG0I_s61ZAHJGXeLL0JxUNdrk6rIXf8-6oJ3Ak"},
{"content":{"body":"I think I mis-inferred that changing `import.meta.resolve` from async to sync on both the web and in node meant that it no longer required sync I/O to answer for all paths.","format":"org.matrix.custom.html","formatted_body":"I think I mis-inferred that changing <code>import.meta.resolve</code> from async to sync on both the web and in node meant that it no longer required sync I/O to answer for all paths.","m.mentions":{},"msgtype":"m.text"},"ts":1712855558181,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$fjg5LVfRnVsvSoeWphvnmm0NlvtnzQSome03dCa9B60"},
{"content":{"body":"On the web, the import-map makes it possible to answer for all specifiers without I/O. On Node.js, static resolution makes it sync I/O-free most of the time, but yeah, if Node.js _doesn’t_ locate every package reachable from a module before evaluating a module, it would have to fall through to sync I/O sometimes.","format":"org.matrix.custom.html","formatted_body":"On the web, the import-map makes it possible to answer for all specifiers without I/O. On Node.js, static resolution makes it sync I/O-free most of the time, but yeah, if Node.js <em>doesn’t</em> locate every package reachable from a module before evaluating a module, it would have to fall through to sync I/O sometimes.","m.mentions":{},"msgtype":"m.text"},"ts":1712855657175,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY"},
{"content":{"body":"And of course the extension search path isn’t captured in `package.json` anyway, so yeee.","format":"org.matrix.custom.html","formatted_body":"And of course the extension search path isn’t captured in <code>package.json</code> anyway, so yeee.","m.mentions":{},"msgtype":"m.text"},"ts":1712855686245,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$M1SyUKRARdQkE9-Im1TwDTsENknhbZOAWfYv1vxnwNU"},
{"content":{"body":"related: https://github.com/tc39/proposal-import-attributes/issues/153#issuecomment-1981354653\n```\n// Import config with type \"wasm\" if possible, otherwise with type \"json\".\nimport '//test.local/config' with { type: \"wasm\" },\n       '//test.local/config' with { type: \"json\" }\n\n// Import an empty module if `0m` is valid syntax, otherwise import a BigDecimal polyfill.\nimport '/empty.mjs' with { condition: { \"validSyntax\": \"0m\" } },\n       '/polyfills/BigDecimal.mjs'\n\n\n// Import CSS if possible, otherwise JS.\nimport styles from './styles.css' with { type: \"css\" },\n                   './styles.mjs'\n```","format":"org.matrix.custom.html","formatted_body":"<p>related: https://github.com/tc39/proposal-import-attributes/issues/153#issuecomment-1981354653</p>\n<pre><code>// Import config with type \"wasm\" if possible, otherwise with type \"json\".\nimport '//test.local/config' with { type: \"wasm\" },\n       '//test.local/config' with { type: \"json\" }\n\n// Import an empty module if `0m` is valid syntax, otherwise import a BigDecimal polyfill.\nimport '/empty.mjs' with { condition: { \"validSyntax\": \"0m\" } },\n       '/polyfills/BigDecimal.mjs'\n\n\n// Import CSS if possible, otherwise JS.\nimport styles from './styles.css' with { type: \"css\" },\n                   './styles.mjs'\n</code></pre>\n","m.mentions":{},"m.relates_to":{"event_id":"$MegSgbd7zExr0NqIiGwsbqOjo-JdUVwGWYABV5_zQq0","is_falling_back":true,"m.in_reply_to":{"event_id":"$umFzuJpaOkK0-J_tnoK7ALfVnF2JOO7MVQViNMujaQo"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712855808770,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$SwsxohZygkrK6ZwL6lIc9NJEc0D6KiPahV78xkA6v3g"},
{"content":{"body":" * related: https://github.com/tc39/proposal-import-attributes/issues/153#issuecomment-1981354653\n\n```\n// Import config with type \"wasm\" if possible, otherwise with type \"json\".\nimport '//test.local/config' with { type: \"wasm\" },\n       '//test.local/config' with { type: \"json\" }\n\n// Import an empty module if `0m` is valid syntax, otherwise import a BigDecimal polyfill.\nimport '/empty.mjs' with { condition: { \"validSyntax\": \"0m\" } },\n       '/polyfills/BigDecimal.mjs'\n\n// Import CSS if possible, otherwise JS.\nimport styles from './styles.css' with { type: \"css\" },\n                   './styles.mjs'\n```","format":"org.matrix.custom.html","formatted_body":" * <p>related: https://github.com/tc39/proposal-import-attributes/issues/153#issuecomment-1981354653</p>\n<pre><code>// Import config with type \"wasm\" if possible, otherwise with type \"json\".\nimport '//test.local/config' with { type: \"wasm\" },\n       '//test.local/config' with { type: \"json\" }\n\n// Import an empty module if `0m` is valid syntax, otherwise import a BigDecimal polyfill.\nimport '/empty.mjs' with { condition: { \"validSyntax\": \"0m\" } },\n       '/polyfills/BigDecimal.mjs'\n\n// Import CSS if possible, otherwise JS.\nimport styles from './styles.css' with { type: \"css\" },\n                   './styles.mjs'\n</code></pre>\n","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"m.new_content":{"body":"related: https://github.com/tc39/proposal-import-attributes/issues/153#issuecomment-1981354653\n\n```\n// Import config with type \"wasm\" if possible, otherwise with type \"json\".\nimport '//test.local/config' with { type: \"wasm\" },\n       '//test.local/config' with { type: \"json\" }\n\n// Import an empty module if `0m` is valid syntax, otherwise import a BigDecimal polyfill.\nimport '/empty.mjs' with { condition: { \"validSyntax\": \"0m\" } },\n       '/polyfills/BigDecimal.mjs'\n\n// Import CSS if possible, otherwise JS.\nimport styles from './styles.css' with { type: \"css\" },\n                   './styles.mjs'\n```","format":"org.matrix.custom.html","formatted_body":"<p>related: https://github.com/tc39/proposal-import-attributes/issues/153#issuecomment-1981354653</p>\n<pre><code>// Import config with type \"wasm\" if possible, otherwise with type \"json\".\nimport '//test.local/config' with { type: \"wasm\" },\n       '//test.local/config' with { type: \"json\" }\n\n// Import an empty module if `0m` is valid syntax, otherwise import a BigDecimal polyfill.\nimport '/empty.mjs' with { condition: { \"validSyntax\": \"0m\" } },\n       '/polyfills/BigDecimal.mjs'\n\n// Import CSS if possible, otherwise JS.\nimport styles from './styles.css' with { type: \"css\" },\n                   './styles.mjs'\n</code></pre>\n","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$SwsxohZygkrK6ZwL6lIc9NJEc0D6KiPahV78xkA6v3g","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712855817950,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$vtqEy7FALBcYM6ZrpFiFQIDWioPNViq0qFoQQquKVpc"},
{"content":{"body":"(follow-up on main thread)","m.mentions":{},"m.relates_to":{"event_id":"$pnAVsdykbxnQ5xX87xFUb1O20gg7FaBTOb8pKVD2aL8","is_falling_back":true,"m.in_reply_to":{"event_id":"$vV8eaQo5FI4s0oSbhA3W-Tr2KvXH1PMR-SKdcCgSlNw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712855834888,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$BXiSxu6W6zbz6pY2lvdw2tfCQHe-we2NhHnque3jlHc"},
{"content":{"body":"Not quite sure if I am following but synchronicity of resolution in Node.js is more of an implementation detail that can be changed","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856023474,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$FRBPlNHne-pM4KQf3WtXBxYArreTWhmqJpIo6NJ-7as"},
{"content":{"body":"For CJS and `require(esm)` it does synchronous I/O all the way, querying the nearest the package.json until it reaches the root directory","format":"org.matrix.custom.html","formatted_body":"For CJS and <code>require(esm)</code> it does synchronous I/O all the way, querying the nearest the package.json until it reaches the root directory","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$FRBPlNHne-pM4KQf3WtXBxYArreTWhmqJpIo6NJ-7as"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856088883,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$lF9LWVcGInWtRiuhRbawk1bmZPykWcQERt418xaUgbU"},
{"content":{"body":"(That's actually faster than the async I/O a full `import esm` is doing)","format":"org.matrix.custom.html","formatted_body":"(That's actually faster than the async I/O a full <code>import esm</code> is doing)","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$lF9LWVcGInWtRiuhRbawk1bmZPykWcQERt418xaUgbU"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856110138,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$N5LScJqX9FfE5h2NtVLJda_cjDEd3tGH-451EBjZgFw"},
{"content":{"body":"Yeah, understood on the performance front. That was the grounds for implementing CJS with sync I/O on Node.js.","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$N5LScJqX9FfE5h2NtVLJda_cjDEd3tGH-451EBjZgFw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856154637,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$im-hX1_a5ayC5tQosGP2SCSNqvQAVoNEQnWnbd5X86o"},
{"content":{"body":"And the resolution result is also cached, so `import.meta.resolve` can just throw cache entries in there, or get cached entries","format":"org.matrix.custom.html","formatted_body":"And the resolution result is also cached, so <code>import.meta.resolve</code> can just throw cache entries in there, or get cached entries","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$im-hX1_a5ayC5tQosGP2SCSNqvQAVoNEQnWnbd5X86o"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856165747,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$F09ObBNfXqvY-mOsKk3wQq33iYZfRYhzWkfiSyS9010"},
{"content":{"body":"And I was mistaken that Node.js can avoid I/O for sync ESM. I hadn’t throught through all the cases.","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$F09ObBNfXqvY-mOsKk3wQq33iYZfRYhzWkfiSyS9010"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856183473,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$drqUXX5s62Cb5CXMclFqscA-ypIjicM_jJs7_uxVSZg"},
{"content":{"body":"If it's cached, then no I/O. If it isn't, at least some I/O is always needed to discover package.json, especially when people use `.js` then Node.js need to check `type` field","format":"org.matrix.custom.html","formatted_body":"If it's cached, then no I/O. If it isn't, at least some I/O is always needed to discover package.json, especially when people use <code>.js</code> then Node.js need to check <code>type</code> field","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$drqUXX5s62Cb5CXMclFqscA-ypIjicM_jJs7_uxVSZg"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856229591,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$ZXVKqoJUIOd3mre9lbmtKm42gm4rWJc_rcyaJ_Sj1Uo"},
{"content":{"body":"Right, I’d hoped (but was mistaken) that the `import.meta.resolve` memo could be proven to be complete before a module evaluates.","format":"org.matrix.custom.html","formatted_body":"Right, I’d hoped (but was mistaken) that the <code>import.meta.resolve</code> memo could be proven to be complete before a module evaluates.","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$ZXVKqoJUIOd3mre9lbmtKm42gm4rWJc_rcyaJ_Sj1Uo"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856242770,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$CUcqK9AJgn10hHuLN0PlsM8k0KiAdXevkC38P3kjv6U"},
{"content":{"body":"Largely though, isn't this unrelated? Like, node ESM stuff is now off-thread, and \"looks\" synchronous, but internally can be sync or async however it feels","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$CUcqK9AJgn10hHuLN0PlsM8k0KiAdXevkC38P3kjv6U"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856246360,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$LgR15K4djVTkFvfbqEjGOqre0IsDR-TfqaiKnu0Ls90"},
{"content":{"body":"Node.js ESM is not off thread","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$LgR15K4djVTkFvfbqEjGOqre0IsDR-TfqaiKnu0Ls90"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856260181,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$BIUhPbrMiYLRMRvoM0jYqCx7RGZFmr5uHMcFPo5v8G8"},
{"content":{"body":"Blocking on off-thread work is synchronous from the JS point-of-view.","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$BIUhPbrMiYLRMRvoM0jYqCx7RGZFmr5uHMcFPo5v8G8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856295081,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$92XxGwo_g1gr6q-wwaLQvXCJENeYbSkPBqHPQFV1KiY"},
{"content":{"body":"Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$BIUhPbrMiYLRMRvoM0jYqCx7RGZFmr5uHMcFPo5v8G8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856295127,"senderName":"jakebailey","senderId":"@jakebailey:matrix.org","id":"$r4pC2fMYjKxmoi8IN8kwyeUN860gAG1VchPqbhUSipw"},
{"content":{"body":"What makes it synchronous is that it starves progress on the event loop until complete.","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$r4pC2fMYjKxmoi8IN8kwyeUN860gAG1VchPqbhUSipw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856317255,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$Zgl3JH9XShjsnY4p7qixXwrTd51OQGxZmBykbANZGmU"},
{"content":{"body":"Only custom loaders are, and we are adding something that allows you to do it in-thread, because the off-thread thing is basically in-thread hooks + worker + block on Atomics.wait","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$Zgl3JH9XShjsnY4p7qixXwrTd51OQGxZmBykbANZGmU"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856323580,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$fB9x4kTFqWsO-ElpIz5AW2NOwTsoqA55Gj4nLM6lt6c"},
{"content":{"body":" * Only custom loaders are, and we are proposing to add something that allows you to do it in-thread, because the off-thread thing is basically in-thread hooks + worker + block on Atomics.wait","format":"org.matrix.custom.html","formatted_body":" * Only custom loaders are, and we are proposing to add something that allows you to do it in-thread, because the off-thread thing is basically in-thread hooks + worker + block on Atomics.wait","m.mentions":{"user_ids":["@kriskowal:aelf.land"]},"m.new_content":{"body":"Only custom loaders are, and we are proposing to add something that allows you to do it in-thread, because the off-thread thing is basically in-thread hooks + worker + block on Atomics.wait","format":"org.matrix.custom.html","formatted_body":"Only custom loaders are, and we are proposing to add something that allows you to do it in-thread, because the off-thread thing is basically in-thread hooks + worker + block on Atomics.wait","m.mentions":{"user_ids":["@kriskowal:aelf.land"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$fB9x4kTFqWsO-ElpIz5AW2NOwTsoqA55Gj4nLM6lt6c","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712856354389,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$ViFFGZA69t-AMFc1DbAhiwrgM57qI9hxQO6ujUnoHjw"},
{"content":{"body":"Still it's only off thread when you customize the loader. It's in thread if you are not doing that","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$fB9x4kTFqWsO-ElpIz5AW2NOwTsoqA55Gj4nLM6lt6c"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856400841,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$hqAS1SNYleAycbXIiY9F-V2qvLmLrKtBTaUxmPY6lOQ"},
{"content":{"body":"Deadlock enters the chat :|","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$hqAS1SNYleAycbXIiY9F-V2qvLmLrKtBTaUxmPY6lOQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856405650,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$dVw7pdKNj8g02BmNTMq241L3bwtrekyF1DFdT_dJwlo"},
{"content":{"body":"Yes, the off thread hooks are suffering from deadlocks, another reason to provide in thread hooks","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$dVw7pdKNj8g02BmNTMq241L3bwtrekyF1DFdT_dJwlo"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856426629,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$o9TjoQ6ZhuvE5ikqBHKcxAwxafhiIWTdNrBLksfHolE"},
{"content":{"body":"But then, the default ESM loader without customization is still in the same thread.","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$o9TjoQ6ZhuvE5ikqBHKcxAwxafhiIWTdNrBLksfHolE"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856496257,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$_lpbacqVBJVGT9fX3nJR3oAdFmqRMV-B3eSheXIcV7E"},
{"content":{"body":"And no workers etc.","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$_lpbacqVBJVGT9fX3nJR3oAdFmqRMV-B3eSheXIcV7E"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856506085,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$44DL7a2m0gy5RJlRzsU1TKmPn_62kkSTyCMKGJWxfdM"},
{"content":{"body":"And default ESM loader + future in-thread hooks are also in the same thread. No locks, no worker, not even event loop ticks, everything is synchronous, until you deliberately throw something async in the graph (TLA, network imports, etc.)","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$44DL7a2m0gy5RJlRzsU1TKmPn_62kkSTyCMKGJWxfdM"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856573066,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$2Fy5RVut1c_3ci4hfI72azhwvFTdd4w4tJ4P4wkstiQ"},
{"content":{"body":"Deadlock is happening in only 1 scenario that we know of, right joyee ?","format":"org.matrix.custom.html","formatted_body":"Deadlock is happening in only 1 scenario that we know of, right <a href=\"https://matrix.to/#/@qzhang:igalia.com\">joyee</a> ?","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$2Fy5RVut1c_3ci4hfI72azhwvFTdd4w4tJ4P4wkstiQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856723322,"senderName":"jakobjingleheimer","senderId":"@jakobjingleheimer:matrix.org","id":"$B7yPdaCcPFaY9WxFtVjX_kGVxrjwN_wFTmS7mZu-nyU"},
{"content":{"body":"Currently, yes, but I suspect not being able to control the worker can lead to more","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$B7yPdaCcPFaY9WxFtVjX_kGVxrjwN_wFTmS7mZu-nyU"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856752033,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$X72m1aUs1Uqum40imhkZXl7OT0L4chqG5RrLjHhFIfk"},
{"content":{"body":"And in-thread hooks can allow users to control the worker and work around it","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$X72m1aUs1Uqum40imhkZXl7OT0L4chqG5RrLjHhFIfk"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856814717,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$yhmhjAAXahGMG5HRjpiZDgyeH_koiV9FkOR6-BE0WJI"},
{"content":{"body":"Would Node.js be in a good position to exploit a `ModuleSource` constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?","format":"org.matrix.custom.html","formatted_body":"Would Node.js be in a good position to exploit a <code>ModuleSource</code> constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$yhmhjAAXahGMG5HRjpiZDgyeH_koiV9FkOR6-BE0WJI"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856983791,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$UzI8n05CKE5ELjfi8O-H8rGxt5ZpVNq3rZLU8qAWI7A"},
{"content":{"body":"> Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous\nThe ESM loader is doing unconditional async resolution but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make `import.meta.resolve()` a lot more performant too","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous<br>The ESM loader is doing unconditional async resolution but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make <code>import.meta.resolve()</code> a lot more performant too</p>\n</blockquote>\n","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$UzI8n05CKE5ELjfi8O-H8rGxt5ZpVNq3rZLU8qAWI7A"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712856991696,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$Qa1phBCIJhiBdvE8RFE3c__8ThId1u-F_-F990GzdMo"},
{"content":{"body":" * > Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous\n\nThe ESM loader is doing unconditional async resolution but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make `import.meta.resolve()` a lot more performant too","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous</p>\n</blockquote>\n<p>The ESM loader is doing unconditional async resolution but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make <code>import.meta.resolve()</code> a lot more performant too</p>\n","m.mentions":{"user_ids":["@kriskowal:aelf.land"]},"m.new_content":{"body":"> Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous\n\nThe ESM loader is doing unconditional async resolution but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make `import.meta.resolve()` a lot more performant too","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous</p>\n</blockquote>\n<p>The ESM loader is doing unconditional async resolution but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make <code>import.meta.resolve()</code> a lot more performant too</p>\n","m.mentions":{"user_ids":["@kriskowal:aelf.land"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Qa1phBCIJhiBdvE8RFE3c__8ThId1u-F_-F990GzdMo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712857009132,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$XFJz_2opOKm4Za2LetKfhusAREo3LJa2W4JvJJWrg_k"},
{"content":{"body":"> Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous\n\n * > Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous\n\nThe ESM loader is currently doing unconditional async resolution for `import esm` but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make `import.meta.resolve()` a lot more performant too","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous</p>\n</blockquote>\n<p>The ESM loader is currently doing unconditional async resolution for <code>import esm</code> but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make <code>import.meta.resolve()</code> a lot more performant too</p>\n","m.mentions":{},"m.new_content":{"body":"> Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous\n\nThe ESM loader is currently doing unconditional async resolution for `import esm` but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make `import.meta.resolve()` a lot more performant too","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>Hm, I guess I am misunderstanding about the work that went into making import.meta.resolve synchronous</p>\n</blockquote>\n<p>The ESM loader is currently doing unconditional async resolution for <code>import esm</code> but that is an implementation detail. It can be conditionally async (only when someone does network imports). That'll make <code>import.meta.resolve()</code> a lot more performant too</p>\n","m.mentions":{"user_ids":["@kriskowal:aelf.land"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Qa1phBCIJhiBdvE8RFE3c__8ThId1u-F_-F990GzdMo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712857029103,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$ZXtOi8B2DhDBaBlw_Q-ueKvZ6amS-nkYBNio3EtKuog"},
{"content":{"body":"(Which I suspect is part of why `require(esm)` is 1.2x faster than `import esm`, even, because `require(esm)` is doing a fully synchronous resolution)","format":"org.matrix.custom.html","formatted_body":"(Which I suspect is part of why <code>require(esm)</code> is 1.2x faster than <code>import esm</code>, even, because <code>require(esm)</code> is doing a fully synchronous resolution)","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$Qa1phBCIJhiBdvE8RFE3c__8ThId1u-F_-F990GzdMo"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712857076562,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$mC6CWXABmXTyaMohX-Vddy59HnrmimYxSjTErW7kolU"},
{"content":{"body":"For Node.js at least, which mostly deal with fs I/O, not network, synchronous I/O never shows up in the performance profile of loading any non-trivial app, encoding the UTF8 file content into a V8 string can be like 100x more expensive than I/O","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$mC6CWXABmXTyaMohX-Vddy59HnrmimYxSjTErW7kolU"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712857558157,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$UgBtJZkxyJw1ZhwOkp5TYSQVBC4mP0qMB-HlfK7N_Ic"},
{"content":{"body":" * For Node.js at least, which mostly deal with fs I/O, not network, synchronous I/O never shows up in the performance profile of loading any non-trivial app, encoding the UTF8 file content into a V8 string can be like 10x more expensive than I/O","format":"org.matrix.custom.html","formatted_body":" * For Node.js at least, which mostly deal with fs I/O, not network, synchronous I/O never shows up in the performance profile of loading any non-trivial app, encoding the UTF8 file content into a V8 string can be like 10x more expensive than I/O","m.mentions":{},"m.new_content":{"body":"For Node.js at least, which mostly deal with fs I/O, not network, synchronous I/O never shows up in the performance profile of loading any non-trivial app, encoding the UTF8 file content into a V8 string can be like 10x more expensive than I/O","format":"org.matrix.custom.html","formatted_body":"For Node.js at least, which mostly deal with fs I/O, not network, synchronous I/O never shows up in the performance profile of loading any non-trivial app, encoding the UTF8 file content into a V8 string can be like 10x more expensive than I/O","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$UgBtJZkxyJw1ZhwOkp5TYSQVBC4mP0qMB-HlfK7N_Ic","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712857591348,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$_bwx1zlog7ehinsNtcbQd2RKYRPLCyIZQyKFvr7oIG8"},
{"content":{"body":"> Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?\n\nFrom what I can tell, that looks like an abstraction of source code of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our ModuleWrap, or what's underneath `vm.SourceTextModule`)\n\n","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?</p>\n</blockquote>\n<p>From what I can tell, that looks like an abstraction of source code of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our ModuleWrap, or what's underneath <code>vm.SourceTextModule</code>)</p>\n","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$UgBtJZkxyJw1ZhwOkp5TYSQVBC4mP0qMB-HlfK7N_Ic"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712857890213,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$NTWDR8Ur0A71W17-RdFS1yCncfibdn8ykS-VJsvOsJc"},
{"content":{"body":"> Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?\n\n * > Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?\n\nFrom what I can tell, that looks like an abstraction of source code of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our `ModuleWrap`, or what's underneath `vm.SourceTextModule`)","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?</p>\n</blockquote>\n<p>From what I can tell, that looks like an abstraction of source code of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our <code>ModuleWrap</code>, or what's underneath <code>vm.SourceTextModule</code>)</p>\n","m.mentions":{},"m.new_content":{"body":"> Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?\n\nFrom what I can tell, that looks like an abstraction of source code of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our `ModuleWrap`, or what's underneath `vm.SourceTextModule`)","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?</p>\n</blockquote>\n<p>From what I can tell, that looks like an abstraction of source code of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our <code>ModuleWrap</code>, or what's underneath <code>vm.SourceTextModule</code>)</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$NTWDR8Ur0A71W17-RdFS1yCncfibdn8ykS-VJsvOsJc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712857918779,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$uveVWa-twsWqS9BHRkeukSpHTzAHkXmSl4GR48hje0I"},
{"content":{"body":"> Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?\n\n * > Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?\n\nFrom what I can tell, that looks like an abstraction of source code (+ origin and all?) of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our `ModuleWrap`, or what's underneath `vm.SourceTextModule`)","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?</p>\n</blockquote>\n<p>From what I can tell, that looks like an abstraction of source code (+ origin and all?) of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our <code>ModuleWrap</code>, or what's underneath <code>vm.SourceTextModule</code>)</p>\n","m.mentions":{},"m.new_content":{"body":"> Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?\n\nFrom what I can tell, that looks like an abstraction of source code (+ origin and all?) of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our `ModuleWrap`, or what's underneath `vm.SourceTextModule`)","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>Would Node.js be in a good position to exploit a ModuleSource constructor that has an internal slot with an immutable representation of a compiled module that can be safely shared, without locking, between threads?</p>\n</blockquote>\n<p>From what I can tell, that looks like an abstraction of source code (+ origin and all?) of source text module. I think that can be useful, but whether it needs to be sharable across threads would only matter to those who customize the ESM loader AND use off-thread hooks. For in-thread cases (default, or using in-thread hooks), it's something Node.js can already internally create (I think that's basically our <code>ModuleWrap</code>, or what's underneath <code>vm.SourceTextModule</code>)</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$NTWDR8Ur0A71W17-RdFS1yCncfibdn8ykS-VJsvOsJc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712857985524,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$JG80cJ5UCfTTcUBvvvmwSXAk677iFcRNxaLeu6akAic"},
{"content":{"body":"since we're discussing Node.js here, it's worth mentioning we do want to avoid precluding network imports as being first-class in future though","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$NTWDR8Ur0A71W17-RdFS1yCncfibdn8ykS-VJsvOsJc"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712858518873,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$IIX8JPoqTYVtRdLq3_sh6KXNZlfg6suU7rUY_zOqxm4"},
{"content":{"body":"That can just be conditionally async. You pay for the cost when you actually have network import in the graph. But no need to make everyone slow when there's none","m.mentions":{},"m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$IIX8JPoqTYVtRdLq3_sh6KXNZlfg6suU7rUY_zOqxm4"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712858630411,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$-7wjl3lo9Rm3I_RhU5iIIU-4vuEp2P5a25n5bPlFeiY"},
{"content":{"body":" * That can just be conditionally async. You pay for the cost when you actually have network import in the graph. But no need to make everyone slow when there's nothing async in the graph","format":"org.matrix.custom.html","formatted_body":" * That can just be conditionally async. You pay for the cost when you actually have network import in the graph. But no need to make everyone slow when there's nothing async in the graph","m.mentions":{"user_ids":["@guybedford:matrix.org"]},"m.new_content":{"body":"That can just be conditionally async. You pay for the cost when you actually have network import in the graph. But no need to make everyone slow when there's nothing async in the graph","format":"org.matrix.custom.html","formatted_body":"That can just be conditionally async. You pay for the cost when you actually have network import in the graph. But no need to make everyone slow when there's nothing async in the graph","m.mentions":{"user_ids":["@guybedford:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$-7wjl3lo9Rm3I_RhU5iIIU-4vuEp2P5a25n5bPlFeiY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712858684567,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$0rj2HgblYdA8cMM4WY0-r3D7PpORCNiNrAc-bpFJDPQ"},
{"content":{"body":"Actually with a cache layer, everything can be synchronous again with the cache even if you have network imports…","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$-7wjl3lo9Rm3I_RhU5iIIU-4vuEp2P5a25n5bPlFeiY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712858992418,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$k206BF02ZjebcpXRWZ19IL3WMPD9pgNmkijidiNVn6I"},
{"content":{"body":"* Actually with a cache layer, everything can be synchronous again with the cache even if you have network imports…and you don’t need to pay for the async overhead if the conditional asynchronicity is enforced ","format":"org.matrix.custom.html","formatted_body":"* Actually with a cache layer, everything can be synchronous again with the cache even if you have network imports…and you don’t need to pay for the async overhead if the conditional asynchronicity is enforced","m.new_content":{"body":"Actually with a cache layer, everything can be synchronous again with the cache even if you have network imports…and you don’t need to pay for the async overhead if the conditional asynchronicity is enforced ","format":"org.matrix.custom.html","formatted_body":"Actually with a cache layer, everything can be synchronous again with the cache even if you have network imports…and you don’t need to pay for the async overhead if the conditional asynchronicity is enforced","msgtype":"m.text"},"m.relates_to":{"event_id":"$k206BF02ZjebcpXRWZ19IL3WMPD9pgNmkijidiNVn6I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712859039496,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$3OttyH3TEzTweBKXiyxAURvHXL43CXMbUpZLakkTslg"},
{"content":{"body":"> <@qzhang:igalia.com> For Node.js at least, which mostly deal with fs I/O, not network, synchronous I/O never shows up in the performance profile of loading any non-trivial app, encoding the UTF8 file content into a V8 string can be like 10x more expensive than I/O\n\nThat may depend on the app. Sync I/O (or maybe rather the amount of stats) is causing seconds of slow down for some of our apps during startup. If I/O wouldn’t be a bottleneck, I assume bundling wouldn’t be such a big win in some setups.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT%3Amatrix.org/%24UgBtJZkxyJw1ZhwOkp5TYSQVBC4mP0qMB-HlfK7N_Ic\">In reply to</a> <a href=\"https://matrix.to/#/@qzhang:igalia.com\">@qzhang:igalia.com</a><br>For Node.js at least, which mostly deal with fs I/O, not network, synchronous I/O never shows up in the performance profile of loading any non-trivial app, encoding the UTF8 file content into a V8 string can be like 10x more expensive than I/O</blockquote></mx-reply>That may depend on the app. Sync I/O (or maybe rather the amount of stats) is causing seconds of slow down for some of our apps during startup. If I/O wouldn’t be a bottleneck, I assume bundling wouldn’t be such a big win in some setups.","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":false,"m.in_reply_to":{"event_id":"$UgBtJZkxyJw1ZhwOkp5TYSQVBC4mP0qMB-HlfK7N_Ic"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864221353,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$aKUeG50S8gXy6DkXfbwyECYf1tqvs41qX9PLp3z_NWs"},
{"content":{"body":"Cold startup times was a major reason why I pushed against the super I/O heavy CommonJS resolution style for ESM in node","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$aKUeG50S8gXy6DkXfbwyECYf1tqvs41qX9PLp3z_NWs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864273933,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$8-MOHj1xjhmXlvtFszLiWlNzbzSTuQZP73jd2q2qnZ4"},
{"content":{"body":"> <@jkrems:matrix.org> That may depend on the app. Sync I/O (or maybe rather the amount of stats) is causing seconds of slow down for some of our apps during startup. If I/O wouldn’t be a bottleneck, I assume bundling wouldn’t be such a big win in some setups.\n\nI suspect you are talking about fs.read*, not actual syscall","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT%3Amatrix.org/%24aKUeG50S8gXy6DkXfbwyECYf1tqvs41qX9PLp3z_NWs\">In reply to</a> <a href=\"https://matrix.to/#/@jkrems:matrix.org\">@jkrems:matrix.org</a><br>That may depend on the app. Sync I/O (or maybe rather the amount of stats) is causing seconds of slow down for some of our apps during startup. If I/O wouldn’t be a bottleneck, I assume bundling wouldn’t be such a big win in some setups.</blockquote></mx-reply>I suspect you are talking about fs.read*, not actual syscall","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":false,"m.in_reply_to":{"event_id":"$aKUeG50S8gXy6DkXfbwyECYf1tqvs41qX9PLp3z_NWs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864350070,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$lDk8GqtjU75FPrBbi2Pxp8J_5ljglxqSe7EjlgCYpwo"},
{"content":{"body":"Bundling is a win not because it avoids I/O, but because it avoids resolution (computation heavy)","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$lDk8GqtjU75FPrBbi2Pxp8J_5ljglxqSe7EjlgCYpwo"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864419510,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$KQeI__Qrd08_DCSxtttDxg6I-toV2m4jRXnImFvmePo"},
{"content":{"body":"And in Node.js most of the startup time is spent on compilation and……string encoding (which might mislead people into thinking I/O is slow - it’s actually the Node.js module loader using the fs API that also does the string encoding 😅)","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$KQeI__Qrd08_DCSxtttDxg6I-toV2m4jRXnImFvmePo"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864540577,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$c_A88eAV7PZdN-YI1AdojDXm6fyjNwh6cg0AuLU02HI"},
{"content":{"body":"From our profiling, it was specifically the stat syscalls. I’ll happily yield that it might be edge cases because we run a lot of things on file systems that are backed my networks and can have cold caches. Adding x2/x3 the amount of disk cache entries that need to be warmed up isn’t free","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$c_A88eAV7PZdN-YI1AdojDXm6fyjNwh6cg0AuLU02HI"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864546327,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$q0Px_5fv9sxI0aMlGaCCIzQ2XZNViUGjyPmj2mEUMoc"},
{"content":{"body":"* From our profiling, it was specifically the stat syscalls. I’ll happily yield that it might be edge cases because we run a lot of things on file systems that are backed by network access and can have cold caches. Adding x2/x3 the amount of disk cache entries that need to be warmed up isn’t free","m.new_content":{"body":"From our profiling, it was specifically the stat syscalls. I’ll happily yield that it might be edge cases because we run a lot of things on file systems that are backed by network access and can have cold caches. Adding x2/x3 the amount of disk cache entries that need to be warmed up isn’t free","msgtype":"m.text"},"m.relates_to":{"event_id":"$q0Px_5fv9sxI0aMlGaCCIzQ2XZNViUGjyPmj2mEUMoc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712864570572,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$OGA7nochLHHywOrXe_QIvpx8KslEpdVdJfEcL8tJY-Y"},
{"content":{"body":"Doing it asynchronously can’t save you that, either, if the application still needs to wait for those calls to complete to do anything interesting ","format":"org.matrix.custom.html","formatted_body":"Doing it asynchronously can’t save you that, either, if the application still needs to wait for those calls to complete to do anything interesting","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$q0Px_5fv9sxI0aMlGaCCIzQ2XZNViUGjyPmj2mEUMoc"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864659561,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$lz6-MAQbH5FNF3U3u2FnCUzqCpPHuz5pydK1KNpqP70"},
{"content":{"body":"Doing it async means that the disk cache can be warmed in parallel which makes a huge difference in those scenarios. But I was mostly talking about the I/O cost in general, not specifically about sync vs async I/O. ","format":"org.matrix.custom.html","formatted_body":"Doing it async means that the disk cache can be warmed in parallel which makes a huge difference in those scenarios. But I was mostly talking about the I/O cost in general, not specifically about sync vs async I/O.","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$lz6-MAQbH5FNF3U3u2FnCUzqCpPHuz5pydK1KNpqP70"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864716788,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$w_lHLFHDm638qp59M8dKUI9KHMRj4Gsp5DFdrWBUCTk"},
{"content":{"body":"The syscall can still be done in parallel, just in native threads","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$w_lHLFHDm638qp59M8dKUI9KHMRj4Gsp5DFdrWBUCTk"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864871803,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$OiW4ohNGce0d-i5f0OoRJ2u0pEepi3XOre2R5a--014"},
{"content":{"body":"But also I am sensing you are talking about CJS loading performance, not ESM in Node.js, because that’s already parallel ","format":"org.matrix.custom.html","formatted_body":"But also I am sensing you are talking about CJS loading performance, not ESM in Node.js, because that’s already parallel","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$OiW4ohNGce0d-i5f0OoRJ2u0pEepi3XOre2R5a--014"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864911392,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$f244smsadKkKVj9mVGXyClZuR1jGaJ33tbuYXms951U"},
{"content":{"body":"Yes, I’m talking about what I saw as a “lesson learned from CJS’ resolution system” when we made the ESM decisions","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$f244smsadKkKVj9mVGXyClZuR1jGaJ33tbuYXms951U"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712864960337,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$OoLrd1h-5fQQKhcipdTT12xax6onTqyYbUVO9RLeegY"},
{"content":{"body":"This is stat call which historically suffer from improper cache misses, so it could still be computation problems","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$OoLrd1h-5fQQKhcipdTT12xax6onTqyYbUVO9RLeegY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712865202777,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$O0YdzPtZaztvMB_OE2QqWF01EKQviVI0I5tauJtbFIk"},
{"content":{"body":"Unless the graph structure you have invalidates cache in the module loader a lot, which sounds like the case if you are backing them with network access already. Most Node.js applications don’t do that, though.","m.relates_to":{"event_id":"$16TV0jickPqJzJ_U28Egs21OdnbPj7lYCPfKoAPNQWY","is_falling_back":true,"m.in_reply_to":{"event_id":"$O0YdzPtZaztvMB_OE2QqWF01EKQviVI0I5tauJtbFIk"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712865447686,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$rOhArNks_qBupOWxf_iIUBb8oPsffy9au_-YOJF0u6w"}
]