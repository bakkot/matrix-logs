[
{"content":{"body":"> <@kriskowal:matrix.org> And `Evaluators` give us another box, where we can capture the dynamic `import` behavior for non-modules. Out of these primitives, `Compartment` can be implemented in user code.\n\nI have been out of this conversation for a while, but thinking about this, I'm wondering if an `evaluator.createModuleSource(moduleSourceString): ModuleSource` would make sense. It would clearly be tied to making new evaluators, in a way that can be denied independently from `ModuleSource` existence. However while I believe an evaluator holds its own module graph, I don't think ModuleSource participate in that graph since they're just unevaluated source representation.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$Cwc9qZApVXDxVkHKJQzDF3nXxUOpE80T2t_MCXp0FL0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>And <code>Evaluators</code> give us another box, where we can capture the dynamic <code>import</code> behavior for non-modules. Out of these primitives, <code>Compartment</code> can be implemented in user code.</blockquote></mx-reply>I have been out of this conversation for a while, but thinking about this, I'm wondering if an <code>evaluator.createModuleSource(moduleSourceString): ModuleSource</code> would make sense. It would clearly be tied to making new evaluators, in a way that can be denied independently from <code>ModuleSource</code> existence. However while I believe an evaluator holds its own module graph, I don't think ModuleSource participate in that graph since they're just unevaluated source representation.","m.relates_to":{"m.in_reply_to":{"event_id":"$Cwc9qZApVXDxVkHKJQzDF3nXxUOpE80T2t_MCXp0FL0"}},"msgtype":"m.text"},"ts":1674747559972,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$SiNgeW9X4Ey1mTZ55OSaNaXhJmLvOGLFNpCLxPFe58E"},
{"content":{"body":"Indeed. There would be no entanglement between the `evaluator` and the resulting `ModuleSource`. There _is_ entanglement between the evaluators and module instance in `const evaluators = new Evaluators(); new evaluators.Module(...)`","format":"org.matrix.custom.html","formatted_body":"Indeed. There would be no entanglement between the <code>evaluator</code> and the resulting <code>ModuleSource</code>. There <em>is</em> entanglement between the evaluators and module instance in <code>const evaluators = new Evaluators(); new evaluators.Module(...)</code>","msgtype":"m.text"},"ts":1674748448119,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$j9G1M8wx_CE4lUmh_-pFCGnM6Boy4Wd_J6RaIEwgFU4"},
{"content":{"body":"That entanglement is evident in a number of ways, including the global object visible to the module, the differentiation between direct and indirect `eval` (the `eval` in scope must match the `eval` of the evaluators instance), the evaluators bequeathed to the module block and module blocks under direct eval, and I believe some other cases. If the evaluators are endowed onto their own globalThis, then the `Function`, indirect `eval`, _and_ `Module` are also entangled, such that `(0, eval)('import(\"x\")')` invokes the `importHook` of the evaluators directly and the same story applies to constructed functions.","format":"org.matrix.custom.html","formatted_body":"That entanglement is evident in a number of ways, including the global object visible to the module, the differentiation between direct and indirect <code>eval</code> (the <code>eval</code> in scope must match the <code>eval</code> of the evaluators instance), the evaluators bequeathed to the module block and module blocks under direct eval, and I believe some other cases. If the evaluators are endowed onto their own globalThis, then the <code>Function</code>, indirect <code>eval</code>, <em>and</em> <code>Module</code> are also entangled, such that <code>(0, eval)('import(&quot;x&quot;)')</code> invokes the <code>importHook</code> of the evaluators directly and the same story applies to constructed functions.","msgtype":"m.text"},"ts":1674748807047,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$CahKVeQNMDhd76x4vSGoALOIQ43fJR84hIyRFirGInk"}
]