[
{"content":{"body":"I was looking at the outline for parameter decorators mentioned here: https://github.com/tc39/proposal-decorators/blob/master/EXTENSIONS.md#parameter-decorators-and-annotations, and was thinking about the shape of the context object. I think there are a few things we could add aside from `kind`:\n\n```ts\ninterface ParameterDecoratorContext {\n  kind: \"parameter\";\n  index: number; // ordinal position of parameter\n  name?: string; // name if an Identifier, `undefined` if a binding pattern\n  rest: boolean; // indicates a rest parameter (i.e., `...`)\n  parent:\n    | {\n        kind: \"function\";\n        name?: string;\n      }\n    | {\n        kind: \"method\" | \"getter\" | \"setter\";\n        name: string | symbol;\n        private: boolean;\n        static: boolean;\n        parent: // may be other parents in the future such as `struct`, `object`, etc.\n          | {\n              kind: \"class\";\n              name?: string;\n            }\n      };\n  // phase: \"function\" runs initializers at the start of the function body\n  addInitializer(cb: () => unknown, phase?: \"class\" | \"static\" | \"instance\" | \"function\"): void;\n}\n```\nThe above also incorporates the parent context idea from https://github.com/tc39/proposal-decorators/issues/466","format":"org.matrix.custom.html","formatted_body":"<p>I was looking at the outline for parameter decorators mentioned here: https://github.com/tc39/proposal-decorators/blob/master/EXTENSIONS.md#parameter-decorators-and-annotations, and was thinking about the shape of the context object. I think there are a few things we could add aside from <code>kind</code>:</p>\n<pre><code class=\"language-ts\">interface ParameterDecoratorContext {\n  kind: &quot;parameter&quot;;\n  index: number; // ordinal position of parameter\n  name?: string; // name if an Identifier, `undefined` if a binding pattern\n  rest: boolean; // indicates a rest parameter (i.e., `...`)\n  parent:\n    | {\n        kind: &quot;function&quot;;\n        name?: string;\n      }\n    | {\n        kind: &quot;method&quot; | &quot;getter&quot; | &quot;setter&quot;;\n        name: string | symbol;\n        private: boolean;\n        static: boolean;\n        parent: // may be other parents in the future such as `struct`, `object`, etc.\n          | {\n              kind: &quot;class&quot;;\n              name?: string;\n            }\n      };\n  // phase: &quot;function&quot; runs initializers at the start of the function body\n  addInitializer(cb: () =&gt; unknown, phase?: &quot;class&quot; | &quot;static&quot; | &quot;instance&quot; | &quot;function&quot;): void;\n}\n</code></pre>\n<p>The above also incorporates the parent context idea from https://github.com/tc39/proposal-decorators/issues/466</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I was looking at the outline for parameter decorators mentioned here: https://github.com/tc39/proposal-decorators/blob/master/EXTENSIONS.md#parameter-decorators-and-annotations, and was thinking about the shape of the context object. I think there are a few things we could add aside from `kind`:\n\n```ts\ninterface ParameterDecoratorContext {\n  kind: \"parameter\";\n  index: number; // ordinal position of parameter\n  name?: string; // name if an Identifier, `undefined` if a binding pattern\n  rest: boolean; // indicates a rest parameter (i.e., `...`)\n  parent:\n    | {\n        kind: \"function\";\n        name?: string;\n      }\n    | {\n        kind: \"method\" | \"getter\" | \"setter\";\n        name: string | symbol;\n        private: boolean;\n        static: boolean;\n        parent: // may be other parents in the future such as `struct`, `object`, etc.\n          | {\n              kind: \"class\";\n              name?: string;\n            }\n      };\n  // phase: \"function\" runs initializers at the start of the function body\n  addInitializer(cb: () => unknown, phase?: \"class\" | \"static\" | \"instance\" | \"function\"): void;\n}\n```\nThe above also incorporates the parent context idea from https://github.com/tc39/proposal-decorators/issues/466","mimetype":"text/plain"},{"body":"<p>I was looking at the outline for parameter decorators mentioned here: https://github.com/tc39/proposal-decorators/blob/master/EXTENSIONS.md#parameter-decorators-and-annotations, and was thinking about the shape of the context object. I think there are a few things we could add aside from <code>kind</code>:</p>\n<pre><code class=\"language-ts\">interface ParameterDecoratorContext {\n  kind: &quot;parameter&quot;;\n  index: number; // ordinal position of parameter\n  name?: string; // name if an Identifier, `undefined` if a binding pattern\n  rest: boolean; // indicates a rest parameter (i.e., `...`)\n  parent:\n    | {\n        kind: &quot;function&quot;;\n        name?: string;\n      }\n    | {\n        kind: &quot;method&quot; | &quot;getter&quot; | &quot;setter&quot;;\n        name: string | symbol;\n        private: boolean;\n        static: boolean;\n        parent: // may be other parents in the future such as `struct`, `object`, etc.\n          | {\n              kind: &quot;class&quot;;\n              name?: string;\n            }\n      };\n  // phase: &quot;function&quot; runs initializers at the start of the function body\n  addInitializer(cb: () =&gt; unknown, phase?: &quot;class&quot; | &quot;static&quot; | &quot;instance&quot; | &quot;function&quot;): void;\n}\n</code></pre>\n<p>The above also incorporates the parent context idea from https://github.com/tc39/proposal-decorators/issues/466</p>\n","mimetype":"text/html"}]},"ts":1651686185879,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$y7Ont25W1uee_Ny09dRDQg9Vlgwo8jv8dr0SoPZMM18"},
{"content":{"body":"TS parameter decorators get the parameter index which is necessary for DI, RTTI, and RTTC, so that seems a minimum requirement for a parameter context.","msgtype":"m.text","org.matrix.msc1767.text":"TS parameter decorators get the parameter index which is necessary for DI, RTTI, and RTTC, so that seems a minimum requirement for a parameter context."},"ts":1651686368407,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cNgVu3K8cBiW7cwPg5hMlqiNWTA9ACOSIV77YPcSwMk"},
{"content":{"body":"index and a way to get the context / add an initializer to the method/function so that the parameter and function/method decorators can cooperate would be my requirements","msgtype":"m.text","org.matrix.msc1767.text":"index and a way to get the context / add an initializer to the method/function so that the parameter and function/method decorators can cooperate would be my requirements"},"ts":1651689693595,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ZFXAvmWtXHuc-qe2aN284AstgOJMEAf680b8HGTMw1A"},
{"content":{"body":"I imagine \"add an initializer\" would match the behavior already proposed in EXTENSIONS.md and be somewhat similar to fields.","msgtype":"m.text","org.matrix.msc1767.text":"I imagine \"add an initializer\" would match the behavior already proposed in EXTENSIONS.md and be somewhat similar to fields."},"ts":1651707341406,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$LuORM_40uEQxd6GSc5L3YM7JLIba8DsJJSG3F90Vb9Q"},
{"content":{"body":"We might need to bifurcate `ParameterDecoratorContext` into `kind: \"parameter\"` and `kind: \"rest-parameter\"` (as opposed to a `rest: boolean` property on the context), because rest parameters can't have initializers.","format":"org.matrix.custom.html","formatted_body":"We might need to bifurcate <code>ParameterDecoratorContext</code> into <code>kind: &quot;parameter&quot;</code> and <code>kind: &quot;rest-parameter&quot;</code> (as opposed to a <code>rest: boolean</code> property on the context), because rest parameters can't have initializers.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"We might need to bifurcate `ParameterDecoratorContext` into `kind: \"parameter\"` and `kind: \"rest-parameter\"` (as opposed to a `rest: boolean` property on the context), because rest parameters can't have initializers.","mimetype":"text/plain"},{"body":"We might need to bifurcate <code>ParameterDecoratorContext</code> into <code>kind: &quot;parameter&quot;</code> and <code>kind: &quot;rest-parameter&quot;</code> (as opposed to a <code>rest: boolean</code> property on the context), because rest parameters can't have initializers.","mimetype":"text/html"}]},"ts":1651707397717,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$t9TNucZSkkBBkSSpcRhI_aO2CF8NeQqs-QF0i1eupnw"},
{"content":{"body":"I'm not sure what you mean by \"get the context\" however. Would that be similar to the opaque metadata context object proposal?","msgtype":"m.text","org.matrix.msc1767.text":"I'm not sure what you mean by \"get the context\" however. Would that be similar to the opaque metadata context object proposal?"},"ts":1651707497794,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xHh-aVepcFEYNogf8O0w9aeRF0-JE6XxPsGrJzBFzxw"},
{"content":{"body":"But you should still be able to add an initializer to the function/method definition, no? so it'd just be a runtime error to add an initializer to the rest param?","msgtype":"m.text","org.matrix.msc1767.text":"But you should still be able to add an initializer to the function/method definition, no? so it'd just be a runtime error to add an initializer to the rest param?"},"ts":1651707611987,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$lkaCBYHaa2Hhuu2aR5W2odps0GQV0goA-EtLTFR7mCs"},
{"content":{"body":" * But you should still be able to add an initializer to the function/method definition, no? so it'd just be a runtime error to add an initializer to the rest param?","m.new_content":{"body":"But you should still be able to add an initializer to the function/method definition, no? so it'd just be a runtime error to add an initializer to the rest param?","msgtype":"m.text","org.matrix.msc1767.text":"But you should still be able to add an initializer to the function/method definition, no? so it'd just be a runtime error to add an initializer to the rest param?"},"m.relates_to":{"event_id":"$lkaCBYHaa2Hhuu2aR5W2odps0GQV0goA-EtLTFR7mCs","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * But you should still be able to add an initializer to the function/method definition, no? so it'd just be a runtime error to add an initializer to the rest param?"},"ts":1651707623484,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YXLY-O7qGh4sW1ecbq7jijsdY22lTzEleqWCFpheT78"},
{"content":{"body":"Right, I was referring to the opaque metadata, be able to reference the opaque object of the function/method","msgtype":"m.text","org.matrix.msc1767.text":"Right, I was referring to the opaque metadata, be able to reference the opaque object of the function/method"},"ts":1651707681830,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$_6-heYdbO0Yo0zd9MWip7wu5R4t0DgDe77vPZdHPaS4"},
{"content":{"body":"As I mentioned, I'm mostly interested in runtime checks, and would want to be able to express things like\n\n```\nconst foo = (@string name, @array(number) ...values) => {}\n```","format":"org.matrix.custom.html","formatted_body":"<p>As I mentioned, I'm mostly interested in runtime checks, and would want to be able to express things like</p>\n<pre><code>const foo = (@string name, @array(number) ...values) =&gt; {}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"As I mentioned, I'm mostly interested in runtime checks, and would want to be able to express things like\n\n```\nconst foo = (@string name, @array(number) ...values) => {}\n```","mimetype":"text/plain"},{"body":"<p>As I mentioned, I'm mostly interested in runtime checks, and would want to be able to express things like</p>\n<pre><code>const foo = (@string name, @array(number) ...values) =&gt; {}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1651707876905,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$tZUsdtKTNtmG4Z0zYAUT7feTHMhlfCzGX6YEPZ6pxjU"},
{"content":{"body":"But also be able to add runtime metadata so that I can do things like:\n```\nimport { remotable, awaited } from 'rpc-lib';\n\nconst foo = remotable({\n  foo: (@awaited thing) => {\n    if (myCollection.has(thing)) {\n      ...\n    } else {\n      ...\n    }\n  }\n});\n```\n\nWhere the `remotable` helper (which could be written as an object literal decorator) would be able to get the annotations for the `foo` method on the object it received, and (to really simplify) build a new object with a new `foo` method that will implicitly await on the first argument.\n","format":"org.matrix.custom.html","formatted_body":"<p>But also be able to add runtime metadata so that I can do things like:</p>\n<pre><code>import { remotable, awaited } from 'rpc-lib';\n\nconst foo = remotable({\n  foo: (@awaited thing) =&gt; {\n    if (myCollection.has(thing)) {\n      ...\n    } else {\n      ...\n    }\n  }\n});\n</code></pre>\n<p>Where the <code>remotable</code> helper (which could be written as an object literal decorator) would be able to get the annotations for the <code>foo</code> method on the object it received, and (to really simplify) build a new object with a new <code>foo</code> method that will implicitly await on the first argument.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"But also be able to add runtime metadata so that I can do things like:\n```\nimport { remotable, awaited } from 'rpc-lib';\n\nconst foo = remotable({\n  foo: (@awaited thing) => {\n    if (myCollection.has(thing)) {\n      ...\n    } else {\n      ...\n    }\n  }\n});\n```\n\nWhere the `remotable` helper (which could be written as an object literal decorator) would be able to get the annotations for the `foo` method on the object it received, and (to really simplify) build a new object with a new `foo` method that will implicitly await on the first argument.\n","mimetype":"text/plain"},{"body":"<p>But also be able to add runtime metadata so that I can do things like:</p>\n<pre><code>import { remotable, awaited } from 'rpc-lib';\n\nconst foo = remotable({\n  foo: (@awaited thing) =&gt; {\n    if (myCollection.has(thing)) {\n      ...\n    } else {\n      ...\n    }\n  }\n});\n</code></pre>\n<p>Where the <code>remotable</code> helper (which could be written as an object literal decorator) would be able to get the annotations for the <code>foo</code> method on the object it received, and (to really simplify) build a new object with a new <code>foo</code> method that will implicitly await on the first argument.</p>\n","mimetype":"text/html"}]},"ts":1651708491806,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$JY6xg6AsQ1Kg4mB3rRhErb5HW5IZil01MwhSoZSPqVw"}
]