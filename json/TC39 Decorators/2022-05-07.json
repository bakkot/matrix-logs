[
{"content":{"body":"> <@rbuckton:matrix.org> I don't know. F# computation expressions don't feel as fluid to me as FLWOR/FLWOS syntax, and the ability to introduce arbitrary \"keywords\" inside such a block isn't great for static analysis. That said, being able to add a `distinct` or `count` in a F# query expression is an improvement over C#'s LINQ syntax\n\nWith regards to static analysis, I don’t think there would be a fundamental problem with static analysis of context blocks beyond having to analyze decorated constructs in general. As long as the analyzer knows the identity of a decorator, then it knows the types of the callbacks that are involved in its decorated constructs. \n\nBut it’s true that F# computation expressions are slightly more verbose than bespoke LINQ FLOWR/FLOWS syntax. That’s the price of its being generic. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!jiQJvracogtdUglzPZ%3Amatrix.org/%24yBRT2ButcJwuBjAwV_F9-H3iWRTocS9pNfzsTeYJtMQ\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I don't know. F# computation expressions don't feel as fluid to me as FLWOR/FLWOS syntax, and the ability to introduce arbitrary &quot;keywords&quot; inside such a block isn't great for static analysis. That said, being able to add a <code>distinct</code> or <code>count</code> in a F# query expression is an improvement over C#'s LINQ syntax</blockquote></mx-reply><p>With regards to static analysis, I don’t think there would be a fundamental problem with static analysis of context blocks beyond having to analyze decorated constructs in general. As long as the analyzer knows the identity of a decorator, then it knows the types of the callbacks that are involved in its decorated constructs.</p>\n<p>But it’s true that F# computation expressions are slightly more verbose than bespoke LINQ FLOWR/FLOWS syntax. That’s the price of its being generic.</p>","m.relates_to":{"m.in_reply_to":{"event_id":"$yBRT2ButcJwuBjAwV_F9-H3iWRTocS9pNfzsTeYJtMQ"}},"msgtype":"m.text"},"ts":1651951755029,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$fjgJLL9yXnUIvtxQDOKDSC3R_ZT9Jsdgfhgtjjr3SRk"},
{"content":{"body":"> <@jschoi:matrix.org> With regards to static analysis, I don’t think there would be a fundamental problem with static analysis of context blocks beyond having to analyze decorated constructs in general. As long as the analyzer knows the identity of a decorator, then it knows the types of the callbacks that are involved in its decorated constructs. \n> \n> But it’s true that F# computation expressions are slightly more verbose than bespoke LINQ FLOWR/FLOWS syntax. That’s the price of its being generic.\n\nIt depends to what level you want to support F#-style computations. F# allows custom keywords using a `[<CustomOperation(\"name\")>]` attribute and you can specify options in that attribute that affect parsing, such as `AllowIntoPattern`, `IsLikeJoin`, `MaintainsVariableSpace`, `JoinConditionWord`, etc. Since JS decorators are evaluated at runtime, the engine becomes limited in what static analysis it can do for compilation.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!jiQJvracogtdUglzPZ:matrix.org/$fjgJLL9yXnUIvtxQDOKDSC3R_ZT9Jsdgfhgtjjr3SRk?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@jschoi:matrix.org\">@jschoi:matrix.org</a><br><p>With regards to static analysis, I don’t think there would be a fundamental problem with static analysis of context blocks beyond having to analyze decorated constructs in general. As long as the analyzer knows the identity of a decorator, then it knows the types of the callbacks that are involved in its decorated constructs.</p>\n<p>But it’s true that F# computation expressions are slightly more verbose than bespoke LINQ FLOWR/FLOWS syntax. That’s the price of its being generic.</p></blockquote></mx-reply>It depends to what level you want to support F#-style computations. F# allows custom keywords using a <code>[&lt;CustomOperation(&quot;name&quot;)&gt;]</code> attribute and you can specify options in that attribute that affect parsing, such as <code>AllowIntoPattern</code>, <code>IsLikeJoin</code>, <code>MaintainsVariableSpace</code>, <code>JoinConditionWord</code>, etc. Since JS decorators are evaluated at runtime, the engine becomes limited in what static analysis it can do for compilation.","m.relates_to":{"m.in_reply_to":{"event_id":"$fjgJLL9yXnUIvtxQDOKDSC3R_ZT9Jsdgfhgtjjr3SRk"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@jschoi:matrix.org> With regards to static analysis, I don’t think there would be a fundamental problem with static analysis of context blocks beyond having to analyze decorated constructs in general. As long as the analyzer knows the identity of a decorator, then it knows the types of the callbacks that are involved in its decorated constructs. \n> \n> But it’s true that F# computation expressions are slightly more verbose than bespoke LINQ FLOWR/FLOWS syntax. That’s the price of its being generic.\n\nIt depends to what level you want to support F#-style computations. F# allows custom keywords using a `[<CustomOperation(\"name\")>]` attribute and you can specify options in that attribute that affect parsing, such as `AllowIntoPattern`, `IsLikeJoin`, `MaintainsVariableSpace`, `JoinConditionWord`, etc. Since JS decorators are evaluated at runtime, the engine becomes limited in what static analysis it can do for compilation.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!jiQJvracogtdUglzPZ:matrix.org/$fjgJLL9yXnUIvtxQDOKDSC3R_ZT9Jsdgfhgtjjr3SRk?via=matrix.org\">In reply to</a> <a href=\"https://matrix.to/#/@jschoi:matrix.org\">@jschoi:matrix.org</a><br><p>With regards to static analysis, I don’t think there would be a fundamental problem with static analysis of context blocks beyond having to analyze decorated constructs in general. As long as the analyzer knows the identity of a decorator, then it knows the types of the callbacks that are involved in its decorated constructs.</p>\n<p>But it’s true that F# computation expressions are slightly more verbose than bespoke LINQ FLOWR/FLOWS syntax. That’s the price of its being generic.</p></blockquote></mx-reply>It depends to what level you want to support F#-style computations. F# allows custom keywords using a <code>[&lt;CustomOperation(&quot;name&quot;)&gt;]</code> attribute and you can specify options in that attribute that affect parsing, such as <code>AllowIntoPattern</code>, <code>IsLikeJoin</code>, <code>MaintainsVariableSpace</code>, <code>JoinConditionWord</code>, etc. Since JS decorators are evaluated at runtime, the engine becomes limited in what static analysis it can do for compilation.","mimetype":"text/html"}]},"ts":1651952150887,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$12p9J8_rzlygfuNno0NwmkBFUDHFDIWRJbhBrlzm72w"},
{"content":{"body":"i.e., in F# you can do:\n\n```f#\nquery {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n```\n\nWhich handles `into` based on whether `AllowIntoPattern` is set on the `groupBy` method of the builder.\n\nOr\n\n```f#\nquery {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n```\n\nWhich parses `on` as the `join` condition because it's specified by `JoinConditionWord`.","format":"org.matrix.custom.html","formatted_body":"<p>i.e., in F# you can do:</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n</code></pre>\n<p>Which handles <code>into</code> based on whether <code>AllowIntoPattern</code> is set on the <code>groupBy</code> method of the builder.</p>\n<p>Or</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n</code></pre>\n<p>Which parses <code>on</code> as the <code>join</code> condition because it's specified by <code>JoinConditionWord</code>.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"i.e., in F# you can do:\n\n```f#\nquery {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n```\n\nWhich handles `into` based on whether `AllowIntoPattern` is set on the `groupBy` method of the builder.\n\nOr\n\n```f#\nquery {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n```\n\nWhich parses `on` as the `join` condition because it's specified by `JoinConditionWord`.","mimetype":"text/plain"},{"body":"<p>i.e., in F# you can do:</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n</code></pre>\n<p>Which handles <code>into</code> based on whether <code>AllowIntoPattern</code> is set on the <code>groupBy</code> method of the builder.</p>\n<p>Or</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n</code></pre>\n<p>Which parses <code>on</code> as the <code>join</code> condition because it's specified by <code>JoinConditionWord</code>.</p>\n","mimetype":"text/html"}]},"ts":1651952386167,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$e8x4h4v3LpSEWVvpUw20nWtJiRkcr7MVTWILGoH3ggE"},
{"content":{"body":" * i.e., in F# you can do:\n\n```f#\nquery {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n```\n\nWhich handles `into` based on whether `AllowIntoPattern` is set on the `groupBy` method of the builder.\n\nOr\n\n```f#\nquery {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n```\n\nWhich parses `on` as the `join` condition because it's specified by `JoinConditionWord`.","format":"org.matrix.custom.html","formatted_body":" * <p>i.e., in F# you can do:</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n</code></pre>\n<p>Which handles <code>into</code> based on whether <code>AllowIntoPattern</code> is set on the <code>groupBy</code> method of the builder.</p>\n<p>Or</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n</code></pre>\n<p>Which parses <code>on</code> as the <code>join</code> condition because it's specified by <code>JoinConditionWord</code>.</p>\n","m.new_content":{"body":"i.e., in F# you can do:\n\n```f#\nquery {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n```\n\nWhich handles `into` based on whether `AllowIntoPattern` is set on the `groupBy` method of the builder.\n\nOr\n\n```f#\nquery {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n```\n\nWhich parses `on` as the `join` condition because it's specified by `JoinConditionWord`.","format":"org.matrix.custom.html","formatted_body":"<p>i.e., in F# you can do:</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n</code></pre>\n<p>Which handles <code>into</code> based on whether <code>AllowIntoPattern</code> is set on the <code>groupBy</code> method of the builder.</p>\n<p>Or</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n</code></pre>\n<p>Which parses <code>on</code> as the <code>join</code> condition because it's specified by <code>JoinConditionWord</code>.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"i.e., in F# you can do:\n\n```f#\nquery {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n```\n\nWhich handles `into` based on whether `AllowIntoPattern` is set on the `groupBy` method of the builder.\n\nOr\n\n```f#\nquery {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n```\n\nWhich parses `on` as the `join` condition because it's specified by `JoinConditionWord`.","mimetype":"text/plain"},{"body":"<p>i.e., in F# you can do:</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n</code></pre>\n<p>Which handles <code>into</code> based on whether <code>AllowIntoPattern</code> is set on the <code>groupBy</code> method of the builder.</p>\n<p>Or</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n</code></pre>\n<p>Which parses <code>on</code> as the <code>join</code> condition because it's specified by <code>JoinConditionWord</code>.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$e8x4h4v3LpSEWVvpUw20nWtJiRkcr7MVTWILGoH3ggE","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * i.e., in F# you can do:\n\n```f#\nquery {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n```\n\nWhich handles `into` based on whether `AllowIntoPattern` is set on the `groupBy` method of the builder.\n\nOr\n\n```f#\nquery {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n```\n\nWhich parses `on` as the `join` condition because it's specified by `JoinConditionWord`.","mimetype":"text/plain"},{"body":" * <p>i.e., in F# you can do:</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  groupBy student.Age into g\n  select (g.Key, g.Count())\n}\n</code></pre>\n<p>Which handles <code>into</code> based on whether <code>AllowIntoPattern</code> is set on the <code>groupBy</code> method of the builder.</p>\n<p>Or</p>\n<pre><code class=\"language-f#\">query {\n  for student in db.Student do\n  join selection in db.CourseSelection\n    on (student.StudentID = selection.StudentID)\n  select (student, selection)\n}\n</code></pre>\n<p>Which parses <code>on</code> as the <code>join</code> condition because it's specified by <code>JoinConditionWord</code>.</p>\n","mimetype":"text/html"}]},"ts":1651952415753,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$K4Nqaz6zw5gmIygQrDmsNxLnD5RttuDjLjpa5MwcmIg"},
{"content":{"body":"F# made this much more customizable than C#, which has explicit syntax for `group`, `join`, `into`, `on`, `select`, etc. To do this in JS could mean parsing arbitrary patterns of identifiers and expressions and then enforcing them after the fact:\n\n```\nCoverComputationJoinLikeStatement:\n  Identifier BindingIdentifier `in` LeftHandSideExpression Identifier LeftHandSideExpression\n```\nWhere the first _Identifier_ has to match a custom operation keyword, and the 2nd _Identifier_ has to match that operation's `JoinConditionWord`. Its a level of complexity that I think many would balk at","format":"org.matrix.custom.html","formatted_body":"<p>F# made this much more customizable than C#, which has explicit syntax for <code>group</code>, <code>join</code>, <code>into</code>, <code>on</code>, <code>select</code>, etc. To do this in JS could mean parsing arbitrary patterns of identifiers and expressions and then enforcing them after the fact:</p>\n<pre><code>CoverComputationJoinLikeStatement:\n  Identifier BindingIdentifier `in` LeftHandSideExpression Identifier LeftHandSideExpression\n</code></pre>\n<p>Where the first <em>Identifier</em> has to match a custom operation keyword, and the 2nd <em>Identifier</em> has to match that operation's <code>JoinConditionWord</code>. Its a level of complexity that I think many would balk at</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"F# made this much more customizable than C#, which has explicit syntax for `group`, `join`, `into`, `on`, `select`, etc. To do this in JS could mean parsing arbitrary patterns of identifiers and expressions and then enforcing them after the fact:\n\n```\nCoverComputationJoinLikeStatement:\n  Identifier BindingIdentifier `in` LeftHandSideExpression Identifier LeftHandSideExpression\n```\nWhere the first _Identifier_ has to match a custom operation keyword, and the 2nd _Identifier_ has to match that operation's `JoinConditionWord`. Its a level of complexity that I think many would balk at","mimetype":"text/plain"},{"body":"<p>F# made this much more customizable than C#, which has explicit syntax for <code>group</code>, <code>join</code>, <code>into</code>, <code>on</code>, <code>select</code>, etc. To do this in JS could mean parsing arbitrary patterns of identifiers and expressions and then enforcing them after the fact:</p>\n<pre><code>CoverComputationJoinLikeStatement:\n  Identifier BindingIdentifier `in` LeftHandSideExpression Identifier LeftHandSideExpression\n</code></pre>\n<p>Where the first <em>Identifier</em> has to match a custom operation keyword, and the 2nd <em>Identifier</em> has to match that operation's <code>JoinConditionWord</code>. Its a level of complexity that I think many would balk at</p>\n","mimetype":"text/html"}]},"ts":1651952688351,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZGV6mNWJdsJ_R6s8y2K-J1l_XJ3dC8YO0t-lVQEl9ms"}
]