[
{"content":{"body":"ecmarkup should check that all agorithms either end with a return step or an assertion that it's unreachable","msgtype":"m.text"},"ts":1726618987417,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$e3pq-SFS_tn0fYvC8PkDIXqeuSPGjsmbxsIL4rPeq5g"},
{"content":{"body":"also ACs","msgtype":"m.text"},"ts":1726619129986,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$udZWYTIrHslQXNdO3jzQTG_BrciVQKd2f3KngH9qU_0"},
{"content":{"body":"@shuyuguo:matrix.org FYI I want to discuss https://github.com/tc39/proposal-joint-iteration/pull/30 tomorrow and you may want to read the conversation beforehand if you have time","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shu</a> FYI I want to discuss https://github.com/tc39/proposal-joint-iteration/pull/30 tomorrow and you may want to read the conversation beforehand if you have time","msgtype":"m.text"},"ts":1726625193369,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$G4yxZzdj67f9ekwxGRi7Up9YgIZLrmR-3GP4STHz_0Q"},
{"content":{"body":"brief summary of that issue:\n\nRecall that for a syntactic generator, a `return` statement provides the value to be used alongside the first `{ done: true }`, as in `let g = (function* (){ yield 0; return 1; })(); console.log(g.next(), g.next(), g.next())`\n\nthis is accomplished by, GeneratorStart evaluates the function body to completion, after which it checks whether it ends up with a return completion (in which case its value is used to give the `value` of the final iterator result) or a normal completion (in which case there was no explicit `return` statement, and it ignores the value of the normal completion and uses `undefined`)\n\nbuilt-in generators use the GeneratorStart machinery with an abstract closure instead of a function body, but I don't think it makes sense for them to use the \"check for return vs normal completion\" logic. there's a few ways to accomplish this.\n\none way is to have GeneratorStart assert that the AC produces either a throw completion or a normal completion containing `unused`, which would mean that GeneratorStart would go down the path for implicit returns from syntactic generators. then built-in generators could never have `{ done: true, value: \"something other than undefined\" }`, which seems fine though it's kind of an odd restriction to build in.\n\nanother would be to assert that the AC produces either a throw completion or a _return_ completion, and require the AC to explicitly return `ReturnCompletion(*undefined*)` instead of `NormalCompletion(~unused~)`. Then GeneratorStart would go down the path for _explicit_ returns from syntactic generators, and use the value of the return completion to provide the `value` slot.\n\nI'd mildly prefer the second but am fine either way. Currently we have no asserts in either direction, such that the AC used to define a built-in generator can return both normal and return completions and go down either path, which seems unnecessarily complicated.","format":"org.matrix.custom.html","formatted_body":"<p>brief summary of that issue:</p>\n<p>Recall that for a syntactic generator, a <code>return</code> statement provides the value to be used alongside the first <code>{ done: true }</code>, as in <code>let g = (function* (){ yield 0; return 1; })(); console.log(g.next(), g.next(), g.next())</code></p>\n<p>this is accomplished by, GeneratorStart evaluates the function body to completion, after which it checks whether it ends up with a return completion (in which case its value is used to give the <code>value</code> of the final iterator result) or a normal completion (in which case there was no explicit <code>return</code> statement, and it ignores the value of the normal completion and uses <code>undefined</code>)</p>\n<p>built-in generators use the GeneratorStart machinery with an abstract closure instead of a function body, but I don't think it makes sense for them to use the \"check for return vs normal completion\" logic. there's a few ways to accomplish this.</p>\n<p>one way is to have GeneratorStart assert that the AC produces either a throw completion or a normal completion containing <code>unused</code>, which would mean that GeneratorStart would go down the path for implicit returns from syntactic generators. then built-in generators could never have <code>{ done: true, value: \"something other than undefined\" }</code>, which seems fine though it's kind of an odd restriction to build in.</p>\n<p>another would be to assert that the AC produces either a throw completion or a <em>return</em> completion, and require the AC to explicitly return <code>ReturnCompletion(*undefined*)</code> instead of <code>NormalCompletion(~unused~)</code>. Then GeneratorStart would go down the path for <em>explicit</em> returns from syntactic generators, and use the value of the return completion to provide the <code>value</code> slot.</p>\n<p>I'd mildly prefer the second but am fine either way. Currently we have no asserts in either direction, such that the AC used to define a built-in generator can return both normal and return completions and go down either path, which seems unnecessarily complicated.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1726694697743,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$GW3kK0uytfeTjU1vv63-svYFdsykNBKOYFG7johbSmY"},
{"content":{"body":"(I was considering joining the call to explain this but I have a sleeping baby on top of me currently so that's not happening)","m.mentions":{},"msgtype":"m.text"},"ts":1726694726801,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$z7v8tqeb47zXcMvFE7V3GgVWynp5WU91U02XwSXwH2Y"},
{"content":{"body":"just whisper 😛","msgtype":"m.text"},"ts":1726694750349,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$gK2231VPN20AphmGUY1TtD8TvXwH7LI3g9Gj-0SaPvs"},
{"content":{"body":"also Michael Ficarra I addressed your comments on the remaining ecmarkup PRs","format":"org.matrix.custom.html","formatted_body":"also <a href=\"https://matrix.to/#/@michaelficarra:matrix.org\">Michael Ficarra</a> I addressed your comments on the remaining ecmarkup PRs","m.mentions":{"user_ids":["@michaelficarra:matrix.org"]},"msgtype":"m.text"},"ts":1726694797222,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$u6ppAR5J3YgtQq0tpqtBdHqwStAh3rbryf70tQ98I10"},
{"content":{"body":"@bakkot:matrix.org I still don't like that it's a skip annotation instead of an xfail...","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot</a> I still don&#39;t like that it&#39;s a skip annotation instead of an xfail...","msgtype":"m.text"},"ts":1726694838531,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$S_GDodCavB7k2EfGZ8kx9sHY2bM7NwfJFBosDSGlxkk"},
{"content":{"body":"oh I thought of a way to do the xfail without requiring me to do much work, I'll see about making that change","m.mentions":{},"msgtype":"m.text"},"ts":1726694873159,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$LEKmO-GXzJTOxx3djqGLS9Er8jiLGJOgy1G-Wc5uv9s"},
{"content":{"body":"🙇‍♂️","msgtype":"m.text"},"ts":1726694884046,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$XQ29LYEF4MGr5xa5p7-peaWoDxL04DV2hH4uMpTlWKg"},
{"content":{"body":"> <@bakkot:matrix.org> brief summary of that issue:\n> \n> Recall that for a syntactic generator, a `return` statement provides the value to be used alongside the first `{ done: true }`, as in `let g = (function* (){ yield 0; return 1; })(); console.log(g.next(), g.next(), g.next())`\n> \n> this is accomplished by, GeneratorStart evaluates the function body to completion, after which it checks whether it ends up with a return completion (in which case its value is used to give the `value` of the final iterator result) or a normal completion (in which case there was no explicit `return` statement, and it ignores the value of the normal completion and uses `undefined`)\n> \n> built-in generators use the GeneratorStart machinery with an abstract closure instead of a function body, but I don't think it makes sense for them to use the \"check for return vs normal completion\" logic. there's a few ways to accomplish this.\n> \n> one way is to have GeneratorStart assert that the AC produces either a throw completion or a normal completion containing `unused`, which would mean that GeneratorStart would go down the path for implicit returns from syntactic generators. then built-in generators could never have `{ done: true, value: \"something other than undefined\" }`, which seems fine though it's kind of an odd restriction to build in.\n> \n> another would be to assert that the AC produces either a throw completion or a _return_ completion, and require the AC to explicitly return `ReturnCompletion(*undefined*)` instead of `NormalCompletion(~unused~)`. Then GeneratorStart would go down the path for _explicit_ returns from syntactic generators, and use the value of the return completion to provide the `value` slot.\n> \n> I'd mildly prefer the second but am fine either way. Currently we have no asserts in either direction, such that the AC used to define a built-in generator can return both normal and return completions and go down either path, which seems unnecessarily complicated.\n\nI pretty strongly prefer the former until we have a need for the latter, and I've updated all my iterator proposals to do this","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!nSLHQtIRJQxUJbEuGt%3Amatrix.org/%24GW3kK0uytfeTjU1vv63-svYFdsykNBKOYFG7johbSmY\">In reply to</a><a href=\"https://matrix.to/#/%40bakkot%3Amatrix.org\">@bakkot:matrix.org</a><br /><p>brief summary of that issue:</p>\n<p>Recall that for a syntactic generator, a <code>return</code> statement provides the value to be used alongside the first <code>{ done: true }</code>, as in <code>let g = (function* (){ yield 0; return 1; })(); console.log(g.next(), g.next(), g.next())</code></p>\n<p>this is accomplished by, GeneratorStart evaluates the function body to completion, after which it checks whether it ends up with a return completion (in which case its value is used to give the <code>value</code> of the final iterator result) or a normal completion (in which case there was no explicit <code>return</code> statement, and it ignores the value of the normal completion and uses <code>undefined</code>)</p>\n<p>built-in generators use the GeneratorStart machinery with an abstract closure instead of a function body, but I don't think it makes sense for them to use the \"check for return vs normal completion\" logic. there's a few ways to accomplish this.</p>\n<p>one way is to have GeneratorStart assert that the AC produces either a throw completion or a normal completion containing <code>unused</code>, which would mean that GeneratorStart would go down the path for implicit returns from syntactic generators. then built-in generators could never have <code>{ done: true, value: \"something other than undefined\" }</code>, which seems fine though it's kind of an odd restriction to build in.</p>\n<p>another would be to assert that the AC produces either a throw completion or a <em>return</em> completion, and require the AC to explicitly return <code>ReturnCompletion(*undefined*)</code> instead of <code>NormalCompletion(~unused~)</code>. Then GeneratorStart would go down the path for <em>explicit</em> returns from syntactic generators, and use the value of the return completion to provide the <code>value</code> slot.</p>\n<p>I'd mildly prefer the second but am fine either way. Currently we have no asserts in either direction, such that the AC used to define a built-in generator can return both normal and return completions and go down either path, which seems unnecessarily complicated.</p>\n</blockquote></mx-reply>I pretty strongly prefer the former until we have a need for the latter, and I&#39;ve updated all my iterator proposals to do this","m.relates_to":{"m.in_reply_to":{"event_id":"$GW3kK0uytfeTjU1vv63-svYFdsykNBKOYFG7johbSmY"}},"msgtype":"m.text"},"ts":1726694991065,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$l0m-F2F_OJg72Fz7xChgyIfXDwOAJ30UOzp_8PKSshw"}
]