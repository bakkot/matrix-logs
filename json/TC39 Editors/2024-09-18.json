[
{"content":{"body":"ecmarkup should check that all agorithms either end with a return step or an assertion that it's unreachable","msgtype":"m.text"},"ts":1726618987417,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$e3pq-SFS_tn0fYvC8PkDIXqeuSPGjsmbxsIL4rPeq5g"},
{"content":{"body":"also ACs","msgtype":"m.text"},"ts":1726619129986,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$udZWYTIrHslQXNdO3jzQTG_BrciVQKd2f3KngH9qU_0"},
{"content":{"body":"@shuyuguo:matrix.org FYI I want to discuss https://github.com/tc39/proposal-joint-iteration/pull/30 tomorrow and you may want to read the conversation beforehand if you have time","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shu</a> FYI I want to discuss https://github.com/tc39/proposal-joint-iteration/pull/30 tomorrow and you may want to read the conversation beforehand if you have time","msgtype":"m.text"},"ts":1726625193369,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$G4yxZzdj67f9ekwxGRi7Up9YgIZLrmR-3GP4STHz_0Q"},
{"content":{"body":"brief summary of that issue:\n\nRecall that for a syntactic generator, a `return` statement provides the value to be used alongside the first `{ done: true }`, as in `let g = (function* (){ yield 0; return 1; })(); console.log(g.next(), g.next(), g.next())`\n\nthis is accomplished by, GeneratorStart evaluates the function body to completion, after which it checks whether it ends up with a return completion (in which case its value is used to give the `value` of the final iterator result) or a normal completion (in which case there was no explicit `return` statement, and it ignores the value of the normal completion and uses `undefined`)\n\nbuilt-in generators use the GeneratorStart machinery with an abstract closure instead of a function body, but I don't think it makes sense for them to use the \"check for return vs normal completion\" logic. there's a few ways to accomplish this.\n\none way is to have GeneratorStart assert that the AC produces either a throw completion or a normal completion containing `unused`, which would mean that GeneratorStart would go down the path for implicit returns from syntactic generators. then built-in generators could never have `{ done: true, value: \"something other than undefined\" }`, which seems fine though it's kind of an odd restriction to build in.\n\nanother would be to assert that the AC produces either a throw completion or a _return_ completion, and require the AC to explicitly return `ReturnCompletion(*undefined*)` instead of `NormalCompletion(~unused~)`. Then GeneratorStart would go down the path for _explicit_ returns from syntactic generators, and use the value of the return completion to provide the `value` slot.\n\nI'd mildly prefer the second but am fine either way. Currently we have no asserts in either direction, such that the AC used to define a built-in generator can return both normal and return completions and go down either path, which seems unnecessarily complicated.","format":"org.matrix.custom.html","formatted_body":"<p>brief summary of that issue:</p>\n<p>Recall that for a syntactic generator, a <code>return</code> statement provides the value to be used alongside the first <code>{ done: true }</code>, as in <code>let g = (function* (){ yield 0; return 1; })(); console.log(g.next(), g.next(), g.next())</code></p>\n<p>this is accomplished by, GeneratorStart evaluates the function body to completion, after which it checks whether it ends up with a return completion (in which case its value is used to give the <code>value</code> of the final iterator result) or a normal completion (in which case there was no explicit <code>return</code> statement, and it ignores the value of the normal completion and uses <code>undefined</code>)</p>\n<p>built-in generators use the GeneratorStart machinery with an abstract closure instead of a function body, but I don't think it makes sense for them to use the \"check for return vs normal completion\" logic. there's a few ways to accomplish this.</p>\n<p>one way is to have GeneratorStart assert that the AC produces either a throw completion or a normal completion containing <code>unused</code>, which would mean that GeneratorStart would go down the path for implicit returns from syntactic generators. then built-in generators could never have <code>{ done: true, value: \"something other than undefined\" }</code>, which seems fine though it's kind of an odd restriction to build in.</p>\n<p>another would be to assert that the AC produces either a throw completion or a <em>return</em> completion, and require the AC to explicitly return <code>ReturnCompletion(*undefined*)</code> instead of <code>NormalCompletion(~unused~)</code>. Then GeneratorStart would go down the path for <em>explicit</em> returns from syntactic generators, and use the value of the return completion to provide the <code>value</code> slot.</p>\n<p>I'd mildly prefer the second but am fine either way. Currently we have no asserts in either direction, such that the AC used to define a built-in generator can return both normal and return completions and go down either path, which seems unnecessarily complicated.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1726694697743,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$GW3kK0uytfeTjU1vv63-svYFdsykNBKOYFG7johbSmY"}
]