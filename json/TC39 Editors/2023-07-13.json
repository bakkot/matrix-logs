[
{"content":{"body":"it looks like the validation order of `receiver.set(source, offset)` is basically\n1. Throw if _receiver_ is not a TypedArray.\n2. [in ToIntegerOrInfinity] Throw if _offset_ fails to coerce to a Number.\n3. Throw if _offset_ coerces to negative.\n4. [later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}]\n5. Throw if _receiver_ is associated with a detached ArrayBuffer.\n6. [only in SetTypedArrayFromTypedArray] Throw if _source_ is associated with a detached ArrayBuffer.\n7. [only in SetTypedArrayFromArrayLike] Throw if _source_ fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2**53-1) for later steps).\n8. Throw if _offset_ is infinite or _offset_ plus the length of _source_ exceeds the length of _receiver_.\n9 [only in SetTypedArrayFromTypedArray] Throw if _receiver_ and _source_ have different [[ContentType]] (one BigInt while the other is Number).\n\nIt makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with [how-we-work#119](https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26) and performed **all** validation of _offset_ in the same place after getting the length of _source_—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).","format":"org.matrix.custom.html","formatted_body":"<p>it looks like the validation order of <code>receiver.set(source, offset)</code> is basically</p>\n<ol>\n<li>Throw if <em>receiver</em> is not a TypedArray.</li>\n<li>[in ToIntegerOrInfinity] Throw if <em>offset</em> fails to coerce to a Number.</li>\n<li>Throw if <em>offset</em> coerces to negative.</li>\n<li>[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}]</li>\n<li>Throw if <em>receiver</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>source</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromArrayLike] Throw if <em>source</em> fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2**53-1) for later steps).</li>\n<li>Throw if <em>offset</em> is infinite or <em>offset</em> plus the length of <em>source</em> exceeds the length of <em>receiver</em>.<br>9 [only in SetTypedArrayFromTypedArray] Throw if <em>receiver</em> and <em>source</em> have different [[ContentType]] (one BigInt while the other is Number).</li>\n</ol>\n<p>It makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with <a href=\"https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26\">how-we-work#119</a> and performed <strong>all</strong> validation of <em>offset</em> in the same place after getting the length of <em>source</em>—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).</p>\n","msgtype":"m.text"},"ts":1689215014166,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$ZKNi5t4C22jPqjE5sd1bULaiWk6KmlmlaItZnw-vP48"},
{"content":{"body":" * it looks like the validation order of `receiver.set(source, offset)` is basically\n\n1. Throw if _receiver_ is not a TypedArray.\n2. \\[in ToIntegerOrInfinity\\] Throw if _offset_ fails to coerce to a Number.\n3. Throw if _offset_ coerces to negative.\n4. \\[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}\\]\n5. Throw if _receiver_ is associated with a detached ArrayBuffer.\n6. \\[only in SetTypedArrayFromTypedArray\\] Throw if _source_ is associated with a detached ArrayBuffer.\n7. \\[only in SetTypedArrayFromArrayLike\\] Throw if _source_ fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2\\*\\*53-1) for later steps).\n8. Throw if _offset_ is infinite or _offset_ plus the length of _source_ exceeds the length of _receiver_.\n9. \\[only in SetTypedArrayFromTypedArray\\] Throw if _receiver_ and _source_ have different \\[\\[ContentType\\]\\] (one BigInt while the other is Number).\n\nIt makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with [how-we-work#119](https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26) and performed **all** validation of _offset_ in the same place after getting the length of _source_—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).","format":"org.matrix.custom.html","formatted_body":" * <p>it looks like the validation order of <code>receiver.set(source, offset)</code> is basically</p>\n<ol>\n<li>Throw if <em>receiver</em> is not a TypedArray.</li>\n<li>[in ToIntegerOrInfinity] Throw if <em>offset</em> fails to coerce to a Number.</li>\n<li>Throw if <em>offset</em> coerces to negative.</li>\n<li>[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}]</li>\n<li>Throw if <em>receiver</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>source</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromArrayLike] Throw if <em>source</em> fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2**53-1) for later steps).</li>\n<li>Throw if <em>offset</em> is infinite or <em>offset</em> plus the length of <em>source</em> exceeds the length of <em>receiver</em>.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>receiver</em> and <em>source</em> have different [[ContentType]] (one BigInt while the other is Number).</li>\n</ol>\n<p>It makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with <a href=\"https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26\">how-we-work#119</a> and performed <strong>all</strong> validation of <em>offset</em> in the same place after getting the length of <em>source</em>—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).</p>\n","m.new_content":{"body":"it looks like the validation order of `receiver.set(source, offset)` is basically\n\n1. Throw if _receiver_ is not a TypedArray.\n2. \\[in ToIntegerOrInfinity\\] Throw if _offset_ fails to coerce to a Number.\n3. Throw if _offset_ coerces to negative.\n4. \\[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}\\]\n5. Throw if _receiver_ is associated with a detached ArrayBuffer.\n6. \\[only in SetTypedArrayFromTypedArray\\] Throw if _source_ is associated with a detached ArrayBuffer.\n7. \\[only in SetTypedArrayFromArrayLike\\] Throw if _source_ fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2\\*\\*53-1) for later steps).\n8. Throw if _offset_ is infinite or _offset_ plus the length of _source_ exceeds the length of _receiver_.\n9. \\[only in SetTypedArrayFromTypedArray\\] Throw if _receiver_ and _source_ have different \\[\\[ContentType\\]\\] (one BigInt while the other is Number).\n\nIt makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with [how-we-work#119](https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26) and performed **all** validation of _offset_ in the same place after getting the length of _source_—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).","format":"org.matrix.custom.html","formatted_body":"<p>it looks like the validation order of <code>receiver.set(source, offset)</code> is basically</p>\n<ol>\n<li>Throw if <em>receiver</em> is not a TypedArray.</li>\n<li>[in ToIntegerOrInfinity] Throw if <em>offset</em> fails to coerce to a Number.</li>\n<li>Throw if <em>offset</em> coerces to negative.</li>\n<li>[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}]</li>\n<li>Throw if <em>receiver</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>source</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromArrayLike] Throw if <em>source</em> fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2**53-1) for later steps).</li>\n<li>Throw if <em>offset</em> is infinite or <em>offset</em> plus the length of <em>source</em> exceeds the length of <em>receiver</em>.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>receiver</em> and <em>source</em> have different [[ContentType]] (one BigInt while the other is Number).</li>\n</ol>\n<p>It makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with <a href=\"https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26\">how-we-work#119</a> and performed <strong>all</strong> validation of <em>offset</em> in the same place after getting the length of <em>source</em>—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$ZKNi5t4C22jPqjE5sd1bULaiWk6KmlmlaItZnw-vP48","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1689215075640,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$FLc2OfehC67TXo0mlQvyZ02kvWjam8rn4yXWt3TQTuE"},
{"content":{"body":"gotcha, that all makes sense","msgtype":"m.text"},"ts":1689219983833,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$igCKTOgrTcLC8ikobjPbN7sL6idJKmP7ZAY9pscaCsg"},
{"content":{"body":"i'll leave it be i suppose","msgtype":"m.text"},"ts":1689219990083,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$lFYuMyyGT70xeGfhrisE8bsqvRqaOw_3cyDaBogb3bE"}
]