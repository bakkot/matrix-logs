[
{"content":{"body":"it looks like the validation order of `receiver.set(source, offset)` is basically\n1. Throw if _receiver_ is not a TypedArray.\n2. [in ToIntegerOrInfinity] Throw if _offset_ fails to coerce to a Number.\n3. Throw if _offset_ coerces to negative.\n4. [later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}]\n5. Throw if _receiver_ is associated with a detached ArrayBuffer.\n6. [only in SetTypedArrayFromTypedArray] Throw if _source_ is associated with a detached ArrayBuffer.\n7. [only in SetTypedArrayFromArrayLike] Throw if _source_ fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2**53-1) for later steps).\n8. Throw if _offset_ is infinite or _offset_ plus the length of _source_ exceeds the length of _receiver_.\n9 [only in SetTypedArrayFromTypedArray] Throw if _receiver_ and _source_ have different [[ContentType]] (one BigInt while the other is Number).\n\nIt makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with [how-we-work#119](https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26) and performed **all** validation of _offset_ in the same place after getting the length of _source_—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).","format":"org.matrix.custom.html","formatted_body":"<p>it looks like the validation order of <code>receiver.set(source, offset)</code> is basically</p>\n<ol>\n<li>Throw if <em>receiver</em> is not a TypedArray.</li>\n<li>[in ToIntegerOrInfinity] Throw if <em>offset</em> fails to coerce to a Number.</li>\n<li>Throw if <em>offset</em> coerces to negative.</li>\n<li>[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}]</li>\n<li>Throw if <em>receiver</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>source</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromArrayLike] Throw if <em>source</em> fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2**53-1) for later steps).</li>\n<li>Throw if <em>offset</em> is infinite or <em>offset</em> plus the length of <em>source</em> exceeds the length of <em>receiver</em>.<br>9 [only in SetTypedArrayFromTypedArray] Throw if <em>receiver</em> and <em>source</em> have different [[ContentType]] (one BigInt while the other is Number).</li>\n</ol>\n<p>It makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with <a href=\"https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26\">how-we-work#119</a> and performed <strong>all</strong> validation of <em>offset</em> in the same place after getting the length of <em>source</em>—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).</p>\n","msgtype":"m.text"},"ts":1689215014166,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$ZKNi5t4C22jPqjE5sd1bULaiWk6KmlmlaItZnw-vP48"},
{"content":{"body":" * it looks like the validation order of `receiver.set(source, offset)` is basically\n\n1. Throw if _receiver_ is not a TypedArray.\n2. \\[in ToIntegerOrInfinity\\] Throw if _offset_ fails to coerce to a Number.\n3. Throw if _offset_ coerces to negative.\n4. \\[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}\\]\n5. Throw if _receiver_ is associated with a detached ArrayBuffer.\n6. \\[only in SetTypedArrayFromTypedArray\\] Throw if _source_ is associated with a detached ArrayBuffer.\n7. \\[only in SetTypedArrayFromArrayLike\\] Throw if _source_ fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2\\*\\*53-1) for later steps).\n8. Throw if _offset_ is infinite or _offset_ plus the length of _source_ exceeds the length of _receiver_.\n9. \\[only in SetTypedArrayFromTypedArray\\] Throw if _receiver_ and _source_ have different \\[\\[ContentType\\]\\] (one BigInt while the other is Number).\n\nIt makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with [how-we-work#119](https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26) and performed **all** validation of _offset_ in the same place after getting the length of _source_—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).","format":"org.matrix.custom.html","formatted_body":" * <p>it looks like the validation order of <code>receiver.set(source, offset)</code> is basically</p>\n<ol>\n<li>Throw if <em>receiver</em> is not a TypedArray.</li>\n<li>[in ToIntegerOrInfinity] Throw if <em>offset</em> fails to coerce to a Number.</li>\n<li>Throw if <em>offset</em> coerces to negative.</li>\n<li>[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}]</li>\n<li>Throw if <em>receiver</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>source</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromArrayLike] Throw if <em>source</em> fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2**53-1) for later steps).</li>\n<li>Throw if <em>offset</em> is infinite or <em>offset</em> plus the length of <em>source</em> exceeds the length of <em>receiver</em>.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>receiver</em> and <em>source</em> have different [[ContentType]] (one BigInt while the other is Number).</li>\n</ol>\n<p>It makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with <a href=\"https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26\">how-we-work#119</a> and performed <strong>all</strong> validation of <em>offset</em> in the same place after getting the length of <em>source</em>—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).</p>\n","m.new_content":{"body":"it looks like the validation order of `receiver.set(source, offset)` is basically\n\n1. Throw if _receiver_ is not a TypedArray.\n2. \\[in ToIntegerOrInfinity\\] Throw if _offset_ fails to coerce to a Number.\n3. Throw if _offset_ coerces to negative.\n4. \\[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}\\]\n5. Throw if _receiver_ is associated with a detached ArrayBuffer.\n6. \\[only in SetTypedArrayFromTypedArray\\] Throw if _source_ is associated with a detached ArrayBuffer.\n7. \\[only in SetTypedArrayFromArrayLike\\] Throw if _source_ fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2\\*\\*53-1) for later steps).\n8. Throw if _offset_ is infinite or _offset_ plus the length of _source_ exceeds the length of _receiver_.\n9. \\[only in SetTypedArrayFromTypedArray\\] Throw if _receiver_ and _source_ have different \\[\\[ContentType\\]\\] (one BigInt while the other is Number).\n\nIt makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with [how-we-work#119](https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26) and performed **all** validation of _offset_ in the same place after getting the length of _source_—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).","format":"org.matrix.custom.html","formatted_body":"<p>it looks like the validation order of <code>receiver.set(source, offset)</code> is basically</p>\n<ol>\n<li>Throw if <em>receiver</em> is not a TypedArray.</li>\n<li>[in ToIntegerOrInfinity] Throw if <em>offset</em> fails to coerce to a Number.</li>\n<li>Throw if <em>offset</em> coerces to negative.</li>\n<li>[later steps are in SetTypedArrayFrom{TypedArray,ArrayLike}]</li>\n<li>Throw if <em>receiver</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>source</em> is associated with a detached ArrayBuffer.</li>\n<li>[only in SetTypedArrayFromArrayLike] Throw if <em>source</em> fails to coerce to an Object or fails to return a \"length\" that coerces to a Number (which is otherwise clamped to the inclusive interval from 0 to 2**53-1) for later steps).</li>\n<li>Throw if <em>offset</em> is infinite or <em>offset</em> plus the length of <em>source</em> exceeds the length of <em>receiver</em>.</li>\n<li>[only in SetTypedArrayFromTypedArray] Throw if <em>receiver</em> and <em>source</em> have different [[ContentType]] (one BigInt while the other is Number).</li>\n</ol>\n<p>It makes sense to reject infinite offset at the same place as rejecting finite-but-too-big offset (since both are effectively the same issue), but the overall behavior would be better if it were consistent with <a href=\"https://github.com/tc39/how-we-work/pull/119/files#diff-b48c7b3eba9c6b2a43ae502ddc9eabd1a9c49a2aa5592c64ea8ef548dc81352aR18-R26\">how-we-work#119</a> and performed <strong>all</strong> validation of <em>offset</em> in the same place after getting the length of <em>source</em>—i.e., moving steps 2 and 3 above to immediately before step 8 (and ideally also moving step 9 above to immediately after step 6). Such error reshuffling would indeed be normative, but probably safe (if perhaps too minor to be worthwhile).</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$ZKNi5t4C22jPqjE5sd1bULaiWk6KmlmlaItZnw-vP48","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1689215075640,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$FLc2OfehC67TXo0mlQvyZ02kvWjam8rn4yXWt3TQTuE"},
{"content":{"body":"gotcha, that all makes sense","msgtype":"m.text"},"ts":1689219983833,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$igCKTOgrTcLC8ikobjPbN7sL6idJKmP7ZAY9pscaCsg"},
{"content":{"body":"i'll leave it be i suppose","msgtype":"m.text"},"ts":1689219990083,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$lFYuMyyGT70xeGfhrisE8bsqvRqaOw_3cyDaBogb3bE"},
{"content":{"body":"ok, related - can someone convince me that step 25 isn't broken? https://262.ecma-international.org/12.0/#sec-settypedarrayfromtypedarray\n\nmy 1:1 implementation fails a test on Float32/Float64 arrays, but passes if i unconditionally do step 26","msgtype":"m.text"},"ts":1689270510285,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$liXVHGsoTgC_ss3Tx7QCSc0UuYPyjTKx3NIbenT3_RQ"},
{"content":{"body":"can you elaborate more on what you mean by \"broken\"","msgtype":"m.text"},"ts":1689270604737,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$tOULEW4I5n2gogSsuuYfJcNRgG0j9py1Ds6f5kd5zsQ"},
{"content":{"body":"that reads okay to me?","msgtype":"m.text"},"ts":1689270671868,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$c5dfegC1rTiVLnMYJB0mdW_fy0-LB4bU2qK1fM98jIU"},
{"content":{"body":"so, step 25 basically copies byte by byte - but i'm wondering if perhaps `limit` isn't correct or something","format":"org.matrix.custom.html","formatted_body":"so, step 25 basically copies byte by byte - but i'm wondering if perhaps <code>limit</code> isn't correct or something","msgtype":"m.text"},"ts":1689270764187,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$VUm89aZaua9SyV7wMvGpvoT9FyBXNRoGCyNDJKEiSIc"},
{"content":{"body":"the example i'm working with is `new Float32Array([1, 2, 3]).set(new Float32Array([10]), 1)` which invokes SetTypedArrayFromTypedArray","format":"org.matrix.custom.html","formatted_body":"the example i'm working with is <code>new Float32Array([1, 2, 3]).set(new Float32Array([10]), 1)</code> which invokes SetTypedArrayFromTypedArray","msgtype":"m.text"},"ts":1689270816518,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$27Jqyru6rMXHdCkQdYNvVqvbFXs19aPXBM0-GWlx6-g"},
{"content":{"body":"it's quite obviously possible that my GetValueFromBuffer or SetValueInBuffer implementation is wrong","msgtype":"m.text"},"ts":1689270846750,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$g-9IyB82i6i0PRf0VIJ-LhqLT1MDR4XwATx-1xkjGtU"},
{"content":{"body":"step 26 also uses limit","msgtype":"m.text"},"ts":1689270886407,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xGP2LlWAHOkg8SPkMvqmbx2QPVd5wf38UkGYvjGdnTo"},
{"content":{"body":" * it's quite obviously possible that my GetValueFromBuffer or SetValueInBuffer implementation is wrong - since it's only wrong for Float32 and Float64, it might be in RawBytesToNumeric somewhere","m.new_content":{"body":"it's quite obviously possible that my GetValueFromBuffer or SetValueInBuffer implementation is wrong - since it's only wrong for Float32 and Float64, it might be in RawBytesToNumeric somewhere","msgtype":"m.text"},"m.relates_to":{"event_id":"$g-9IyB82i6i0PRf0VIJ-LhqLT1MDR4XwATx-1xkjGtU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1689270894571,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$rz7AMWgCeaVRYCIk8iP1zIH1vO2Tg3F5lij8w5DI5Ao"},
{"content":{"body":"the only difference is whether you advance the index 1 byte at a time or ElementSize at a time","msgtype":"m.text"},"ts":1689270901471,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VWS8QNxTqgjeGPLc38KoIiY_uqJ8nqRakDZUV1Hjw1s"},
{"content":{"body":"true","msgtype":"m.text"},"ts":1689270901784,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$-0Zi8meT135Yu04DHISDy-6kY-QjHhmlCC4IRrARfF0"},
{"content":{"body":"ok then i'll have to dig into my other implementations, thanks for confirming","msgtype":"m.text"},"ts":1689270942504,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$63W04aSuJNxI53qJ37fm0Bq6asSAXHa97ry7qwk6-5c"},
{"content":{"body":"gl","msgtype":"m.text"},"ts":1689270955417,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$PD2kt7Qc5KDBXdtlcIQGp5z--qn4IfnZz24p3_kIJRI"},
{"content":{"body":"altho - can you help me find an example where skipping step 25 entirely would break, so i can add a test case?","msgtype":"m.text"},"ts":1689270967577,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$AtvKlz5me70q3DEEPL4mBelNbKjUqKA175vvUe6s9T0"},
{"content":{"body":"NaNs is the canonical example in my mind","msgtype":"m.text"},"ts":1689270988426,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$y-hg7aGObQ1aeiWGitz1E9enIdqp-aOCUcNnGfSFbxo"},
{"content":{"body":"25 says preserve NaN bit patterns","msgtype":"m.text"},"ts":1689270998090,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$A_AJLqSbpOIpRcOQOAhRP2sJ-AO9QF2908hZi41eBQ4"},
{"content":{"body":"26 says don't have to","msgtype":"m.text"},"ts":1689270999172,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Ms31KGCsa7-cmV-XbesReyRgxJTn6X5yRZFTHG2swyo"},
{"content":{"body":"ahhh ok, hm","msgtype":"m.text"},"ts":1689271008372,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$cmhyFgD_EY3SBL7S5VttgfQgnREy-IJD5SnaIoDfTZs"},
{"content":{"body":"phew, ok found the problem, thanks for the confirmation","msgtype":"m.text"},"ts":1689272993061,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Y3HEsPIwm2yZzGUlhVfYfr1FnDO9XXKITcgdpQADcIY"},
{"content":{"body":"what was the issue?","msgtype":"m.text"},"ts":1689273013462,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$7ltqt53vQfbVqehlyndrzaIGNP_yitDxQpGEOlG935g"},
{"content":{"body":"for `// 6. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].`, i was doing `var rawValue = $slice(new $Uint8Array(arrayBuffer), byteIndex, 0, elementSize); // step 6`\n\nand i changed it to `var rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6`","format":"org.matrix.custom.html","formatted_body":"<p>for <code>// 6. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].</code>, i was doing <code>var rawValue = $slice(new $Uint8Array(arrayBuffer), byteIndex, 0, elementSize); // step 6</code></p>\n<p>and i changed it to <code>var rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6</code></p>\n","msgtype":"m.text"},"ts":1689274401810,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$m5eRsq43P2bB82Zc-UwpFkz_zbsAx0orbWdLI4Q11pA"}
]