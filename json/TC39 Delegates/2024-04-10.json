[
{"content":{"body":"If you care about performance, it's a bad idea to feed external input into a deterministic hash function. That invites attacks such as Hash Flooding: https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding","m.mentions":{},"msgtype":"m.text"},"ts":1712707263754,"senderName":"waldemar","senderId":"@waldemarh:matrix.org","id":"$eSpQxYv3Q1Lqol9Z8Des0HKSKxVm1TfhD_ooVAz9YBg"},
{"content":{"body":"> <@waldemarh:matrix.org> If you care about performance, it's a bad idea to feed external input into a deterministic hash function. That invites attacks such as Hash Flooding: https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding\n\nV8 rotates its hash function on boot, but at some point there was a security issue where, if you put some Maps in the startup snapshot (which Chrome doesn't do, but Node.js started doing at some point), it forgot to re-rotate them, causing a DOS risk of this form! Fixed by joyee :)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$eSpQxYv3Q1Lqol9Z8Des0HKSKxVm1TfhD_ooVAz9YBg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@waldemarh:matrix.org\">@waldemarh:matrix.org</a><br>If you care about performance, it&#39;s a bad idea to feed external input into a deterministic hash function. That invites attacks such as Hash Flooding: https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding</blockquote></mx-reply>V8 rotates its hash function on boot, but at some point there was a security issue where, if you put some Maps in the startup snapshot (which Chrome doesn't do, but Node.js started doing at some point), it forgot to re-rotate them, causing a DOS risk of this form! Fixed by <a href=\"https://matrix.to/#/@qzhang:igalia.com\">joyee</a> :)","m.mentions":{"user_ids":["@waldemarh:matrix.org","@qzhang:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$eSpQxYv3Q1Lqol9Z8Des0HKSKxVm1TfhD_ooVAz9YBg"}},"msgtype":"m.text"},"ts":1712709626514,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$jrqzhr8MDdS5_tXkZ8w8hHMyMtJhPHANUNpucFjMFr4"},
{"content":{"body":"I am not sure what we're supposed to get from Project Valhalla when primitives/value semantics has already been deemed not an option due to implementability issues","m.mentions":{},"m.relates_to":{"event_id":"$EJdRzZ-hWUSy1gmiXeEqq39C12CrL04y6FHFARpLTNc","is_falling_back":true,"m.in_reply_to":{"event_id":"$jbWZ-JIVp1jNFe2_Y0MmT1Qr38MeENTgdrrTG8BUXHU"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712713794096,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ngizBDi74Fk1aCt1n742uIOhPPpszInQKrZSj4kNFik"},
{"content":{"body":"if the question is class-based vs object-based immutable things, I think there's a lot of interest among JS developers in having easy-to-use mechanisms that aren't based on classes.","m.mentions":{},"m.relates_to":{"event_id":"$EJdRzZ-hWUSy1gmiXeEqq39C12CrL04y6FHFARpLTNc","is_falling_back":true,"m.in_reply_to":{"event_id":"$ngizBDi74Fk1aCt1n742uIOhPPpszInQKrZSj4kNFik"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712713867105,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Mgbz80i1poFYbtJTILZ1AjPp7uP_uRyb5x9omv_kDHU"},
{"content":{"body":" * if the question is class-based vs object-based immutable things, I think there's a lot of interest among JS developers in having easy-to-use mechanisms for immutable data structures that don't force them to write classes","format":"org.matrix.custom.html","formatted_body":" * if the question is class-based vs object-based immutable things, I think there's a lot of interest among JS developers in having easy-to-use mechanisms for immutable data structures that don't force them to write classes","m.mentions":{},"m.new_content":{"body":"if the question is class-based vs object-based immutable things, I think there's a lot of interest among JS developers in having easy-to-use mechanisms for immutable data structures that don't force them to write classes","format":"org.matrix.custom.html","formatted_body":"if the question is class-based vs object-based immutable things, I think there's a lot of interest among JS developers in having easy-to-use mechanisms for immutable data structures that don't force them to write classes","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Mgbz80i1poFYbtJTILZ1AjPp7uP_uRyb5x9omv_kDHU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712713881072,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_Ndd3J0dx-HHnZfkep1EPTOm4DiJSWxBBb30nLohwtI"},
{"content":{"body":"> <@waldemarh:matrix.org> If you care about performance, it's a bad idea to feed external input into a deterministic hash function. That invites attacks such as Hash Flooding: https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding\n\nPerformance and/or security. This is one of the reasons why I indicated non-determinism for string hashing between application restarts is a good thing, actually. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$eSpQxYv3Q1Lqol9Z8Des0HKSKxVm1TfhD_ooVAz9YBg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@waldemarh:matrix.org\">@waldemarh:matrix.org</a><br>If you care about performance, it&#39;s a bad idea to feed external input into a deterministic hash function. That invites attacks such as Hash Flooding: https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding</blockquote></mx-reply>Performance and/or security. This is one of the reasons why I indicated non-determinism for string hashing between application restarts is a good thing, actually.","m.mentions":{"user_ids":["@waldemarh:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$eSpQxYv3Q1Lqol9Z8Des0HKSKxVm1TfhD_ooVAz9YBg"}},"msgtype":"m.text"},"ts":1712714042864,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nSm2egsQrnJbyV6fBcNRRhTGgLLjmGrU7PGh2ora_eU"},
{"content":{"body":"There's a lot of complexity with class-based immutable things, e.g., we'd need to use initializer list-based constructors, so if there's subclassing it's a totally different instantiation protocol. And if they're value types, it's even more complicated if we want to avoid any kind of global registries like we discussed with shared structs.","m.mentions":{},"m.relates_to":{"event_id":"$EJdRzZ-hWUSy1gmiXeEqq39C12CrL04y6FHFARpLTNc","is_falling_back":true,"m.in_reply_to":{"event_id":"$Mgbz80i1poFYbtJTILZ1AjPp7uP_uRyb5x9omv_kDHU"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712714070944,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$EmbyAWNPuyWSONL_GRN1iEf5_SJnYtjZaT4Kb9CuBo4"},
{"content":{"body":"> <@rbuckton:matrix.org> Performance and/or security. This is one of the reasons why I indicated non-determinism for string hashing between application restarts is a good thing, actually.\n\nRight so given that it's simultaneously a good thing and a bad thing, we've so far opted to hide the hashcodes","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$nSm2egsQrnJbyV6fBcNRRhTGgLLjmGrU7PGh2ora_eU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Performance and/or security. This is one of the reasons why I indicated non-determinism for string hashing between application restarts is a good thing, actually.</blockquote></mx-reply>Right so given that it's simultaneously a good thing and a bad thing, we've so far opted to hide the hashcodes","m.mentions":{"user_ids":["@rbuckton:matrix.org","@waldemarh:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$nSm2egsQrnJbyV6fBcNRRhTGgLLjmGrU7PGh2ora_eU"}},"msgtype":"m.text"},"ts":1712714148841,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$SFfqjj_OjIfZffh-aY93N81shhWgoN2jVC7gg9IUZ3o"},
{"content":{"body":"The \"bad thing\" case (non-determinism being bad) seems so narrowly focused that I have a hard time believing it should apply broadly across the language.","m.mentions":{},"msgtype":"m.text"},"ts":1712714451335,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VtkUgiF8SycSiJXVyS-Dk6418Zz9w-fepziXsSoY7gg"},
{"content":{"body":"I don't know that class-based vs object-based is a meaningful distinction in JS, but in any case, the main things I want to take away are\n\n- even in a language with a well-established idiom for .equals/.hash, having the ability to conveniently create objects which are `==` each other is useful\n- they've explored some of the relevant space already, such as having WeakMaps which reject these values (though, this being Java, that behavior is customizable)","format":"org.matrix.custom.html","formatted_body":"<p>I don't know that class-based vs object-based is a meaningful distinction in JS, but in any case, the main things I want to take away are</p>\n<ul>\n<li>even in a language with a well-established idiom for .equals/.hash, having the ability to conveniently create objects which are <code>==</code> each other is useful</li>\n<li>they've explored some of the relevant space already, such as having WeakMaps which reject these values (though, this being Java, that behavior is customizable)</li>\n</ul>\n","m.mentions":{},"m.relates_to":{"event_id":"$EJdRzZ-hWUSy1gmiXeEqq39C12CrL04y6FHFARpLTNc","is_falling_back":true,"m.in_reply_to":{"event_id":"$EmbyAWNPuyWSONL_GRN1iEf5_SJnYtjZaT4Kb9CuBo4"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712714646637,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$io3RbChnpKUA0pCvpBPlbs3hT77Og17A3akx82gEK1s"},
{"content":{"body":"The overhead incurred by a `CompositeKey` just seems like a non-starter to me. Maybe we could find another approach that can overcome these caveats. For example, a `Hasher` class instead of a global `Object.hash()`. A given `Hasher` could just use a monotonically increasing number for each unique object instance it comes across, and maybe is configurable as to how it handles string hashing (e.g., algorithm, randomness, seed values, etc.). Then your equaler looks like `{ equals(a, b), hash(obj, hasher) }` and you then can write `new Map([], { equaler, hasher })`. Object hashes could be deterministic without being a global communications channel. String hashing can be deterministic if you want it to be, or not, as best fits your scenario.","format":"org.matrix.custom.html","formatted_body":"The overhead incurred by a <code>CompositeKey</code> just seems like a non-starter to me. Maybe we could find another approach that can overcome these caveats. For example, a <code>Hasher</code> class instead of a global <code>Object.hash()</code>. A given <code>Hasher</code> could just use a monotonically increasing number for each unique object instance it comes across, and maybe is configurable as to how it handles string hashing (e.g., algorithm, randomness, seed values, etc.). Then your equaler looks like <code>{ equals(a, b), hash(obj, hasher) }</code> and you then can write <code>new Map([], { equaler, hasher })</code>. Object hashes could be deterministic without being a global communications channel. String hashing can be deterministic if you want it to be, or not, as best fits your scenario.","m.mentions":{},"msgtype":"m.text"},"ts":1712715411726,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bg1W0LLGN4sWaWZB0flLuqsdg6fHWSHcxZ3-dkuRJdQ"},
{"content":{"body":"yes, I agree that having objects which === each other is useful; it's unfortunate that we can't go in that direction per implementer feedback, but I think we can still find many related but different improvements to JavaScript.","m.mentions":{},"m.relates_to":{"event_id":"$EJdRzZ-hWUSy1gmiXeEqq39C12CrL04y6FHFARpLTNc","is_falling_back":true,"m.in_reply_to":{"event_id":"$io3RbChnpKUA0pCvpBPlbs3hT77Og17A3akx82gEK1s"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712716410028,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$bkcCk7RnbsXaTkcz6E-RGoOrQexuA5UxHv82G0N8jeQ"},
{"content":{"body":" * yes, I agree that having values which === each other based on their contents is useful; it's unfortunate that we can't go in that direction per implementer feedback, but I think we can still find many related but different improvements to JavaScript.","format":"org.matrix.custom.html","formatted_body":" * yes, I agree that having values which === each other based on their contents is useful; it's unfortunate that we can't go in that direction per implementer feedback, but I think we can still find many related but different improvements to JavaScript.","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.new_content":{"body":"yes, I agree that having values which === each other based on their contents is useful; it's unfortunate that we can't go in that direction per implementer feedback, but I think we can still find many related but different improvements to JavaScript.","format":"org.matrix.custom.html","formatted_body":"yes, I agree that having values which === each other based on their contents is useful; it's unfortunate that we can't go in that direction per implementer feedback, but I think we can still find many related but different improvements to JavaScript.","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$bkcCk7RnbsXaTkcz6E-RGoOrQexuA5UxHv82G0N8jeQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712716493019,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hX9LfAotBLTa8GEgEcZKOV_KkJL37vXmmTSdWSu3eS8"},
{"content":{"body":"Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had classes, we'd have to think through the instantiation protocol. But it's also useful to look at other issues in this area which don't relate to those.","m.mentions":{},"m.relates_to":{"event_id":"$EJdRzZ-hWUSy1gmiXeEqq39C12CrL04y6FHFARpLTNc","is_falling_back":true,"m.in_reply_to":{"event_id":"$bkcCk7RnbsXaTkcz6E-RGoOrQexuA5UxHv82G0N8jeQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712716520038,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$tfmoyUNPd4Mw5nM3HqTlRwNxXwWZLZMI-R4LbqaeDJM"},
{"content":{"body":" * Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through the instantiation protocol. But it's also useful to look at other issues in this area which don't relate to those.","format":"org.matrix.custom.html","formatted_body":" * Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through the instantiation protocol. But it's also useful to look at other issues in this area which don't relate to those.","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.new_content":{"body":"Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through the instantiation protocol. But it's also useful to look at other issues in this area which don't relate to those.","format":"org.matrix.custom.html","formatted_body":"Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through the instantiation protocol. But it's also useful to look at other issues in this area which don't relate to those.","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$tfmoyUNPd4Mw5nM3HqTlRwNxXwWZLZMI-R4LbqaeDJM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712716537526,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$4NyJyc5_smyLau9RZ_yTHRz-A13SXQdVWJ0gg94ILxw"},
{"content":{"body":" * Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through how `new` works. But it's also useful to look at other issues in this area which don't relate to those.","format":"org.matrix.custom.html","formatted_body":" * Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through how <code>new</code> works. But it's also useful to look at other issues in this area which don't relate to those.","m.mentions":{},"m.new_content":{"body":"Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through how `new` works. But it's also useful to look at other issues in this area which don't relate to those.","format":"org.matrix.custom.html","formatted_body":"Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through how <code>new</code> works. But it's also useful to look at other issues in this area which don't relate to those.","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$tfmoyUNPd4Mw5nM3HqTlRwNxXwWZLZMI-R4LbqaeDJM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712716550373,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Clhfx8SK8vX0aThYFvDo5CX72oyIhxmCtGxQ6-bawjc"},
{"content":{"body":"> The overhead incurred by a CompositeKey just seems like a non-starter to me.\n\nIf this means one which is interned so that === works, I agree","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>The overhead incurred by a CompositeKey just seems like a non-starter to me.</p>\n</blockquote>\n<p>If this means one which is interned so that === works, I agree</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712716606538,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$je5mnJTS3n1KFKrc0nIxgD5sSE7jTl6Lfk0OPcNdbvg"},
{"content":{"body":"> <@rbuckton:matrix.org> The \"bad thing\" case (non-determinism being bad) seems so narrowly focused that I have a hard time believing it should apply broadly across the language.\n\nHow do you think we should work through the situation where a bunch of people directly disagree with this judgement?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$VtkUgiF8SycSiJXVyS-Dk6418Zz9w-fepziXsSoY7gg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>The &quot;bad thing&quot; case (non-determinism being bad) seems so narrowly focused that I have a hard time believing it should apply broadly across the language.</blockquote></mx-reply>How do you think we should work through the situation where a bunch of people directly disagree with this judgement?","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$VtkUgiF8SycSiJXVyS-Dk6418Zz9w-fepziXsSoY7gg"}},"msgtype":"m.text"},"ts":1712716641938,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$z8r221W3fcNXOar-4EWAtM_pp_vykyZZ-Td8pMOsY24"},
{"content":{"body":"That's why I mentioned alternatives in the preceding message. I'm willing to consider alternatives that support the scenarios I've discussed. I'd entertain an opaque hash if it were feasible to actually support those scenarios in a performant way. A Composite key cannot satisfy those scenarios as it can never be fast in a custom collection, only in native Map/Set. Maybe I'd be less concerned if a `ConcurrentMap` were in the MVP for shared structs, but I know that shared structs *without* concurrent collections is already a hard sell. The problem is that shared structs *without* concurrent collections is nearly unusable for my use cases without the ability to implement a fast efficient custom collection. To support it in the dev trial I essentially had to tag every shared struct with a monotonically increasing identity to use as the hash, and implement a string hashing algorithm just so I could roll my own `ConcurrentMap`. That approach has a lot of overhead I'd rather avoid.","format":"org.matrix.custom.html","formatted_body":"That's why I mentioned alternatives in the preceding message. I'm willing to consider alternatives that support the scenarios I've discussed. I'd entertain an opaque hash if it were feasible to actually support those scenarios in a performant way. A Composite key cannot satisfy those scenarios as it can never be fast in a custom collection, only in native Map/Set. Maybe I'd be less concerned if a <code>ConcurrentMap</code> were in the MVP for shared structs, but I know that shared structs <em>without</em> concurrent collections is already a hard sell. The problem is that shared structs <em>without</em> concurrent collections is nearly unusable for my use cases without the ability to implement a fast efficient custom collection. To support it in the dev trial I essentially had to tag every shared struct with a monotonically increasing identity to use as the hash, and implement a string hashing algorithm just so I could roll my own <code>ConcurrentMap</code>. That approach has a lot of overhead I'd rather avoid.","m.mentions":{},"msgtype":"m.text"},"ts":1712717353090,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$n4-tnf_bc8izYgIDpEInjVnKigOVlENlEFG0-g_s538"},
{"content":{"body":"tl;dr, I don't need hash/equals if I know I'll get `ConcurrentMap`, but I know that's a long shot at this point. I'd still lament the overhead of a `CompositeKey`, but my primary use cases would be covered. On the other hand, hash/equals means I'm less concerned about when, if ever, I get `ConcurrentMap` since I could readily implement it in userland.","format":"org.matrix.custom.html","formatted_body":"tl;dr, I don't need hash/equals if I know I'll get <code>ConcurrentMap</code>, but I know that's a long shot at this point. I'd still lament the overhead of a <code>CompositeKey</code>, but my primary use cases would be covered. On the other hand, hash/equals means I'm less concerned about when, if ever, I get <code>ConcurrentMap</code> since I could readily implement it in userland.","m.mentions":{},"msgtype":"m.text"},"ts":1712717622680,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vDeibj0qCx8WdrWeKvYl9HXWa15aubOD_dJGwQrLqO4"},
{"content":{"body":"it was not clear to me that this feedback applied to interning at construction time, with a constructor function rather than syntax","m.mentions":{},"m.relates_to":{"event_id":"$EJdRzZ-hWUSy1gmiXeEqq39C12CrL04y6FHFARpLTNc","is_falling_back":true,"m.in_reply_to":{"event_id":"$tfmoyUNPd4Mw5nM3HqTlRwNxXwWZLZMI-R4LbqaeDJM"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712718240639,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Mg22hBrhJ-By-LGppkqvm5VHGDrsfAGqC5FDpVoJb34"},
{"content":{"body":"and being actual `typeof \"object\"` objects rather than a new kind of primitive, and so on","format":"org.matrix.custom.html","formatted_body":"and being actual <code>typeof \"object\"</code> objects rather than a new kind of primitive, and so on","m.mentions":{},"m.relates_to":{"event_id":"$EJdRzZ-hWUSy1gmiXeEqq39C12CrL04y6FHFARpLTNc","is_falling_back":true,"m.in_reply_to":{"event_id":"$Mg22hBrhJ-By-LGppkqvm5VHGDrsfAGqC5FDpVoJb34"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712718305279,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$PIJvb1_qQ6tXt84ta5yiMlsYchr7p5yE_zz0TbENlAw"},
{"content":{"body":"https://matrixlogs.bakkot.com/TC39_Delegates/2024-04-09#L294-L290","m.mentions":{},"m.relates_to":{"event_id":"$EJdRzZ-hWUSy1gmiXeEqq39C12CrL04y6FHFARpLTNc","is_falling_back":true,"m.in_reply_to":{"event_id":"$PIJvb1_qQ6tXt84ta5yiMlsYchr7p5yE_zz0TbENlAw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1712718315176,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$llbA8fst8TN9dv0osfY7qDj_WAsfZIh2hJqY1a4AdcQ"},
{"content":{"body":"Could a hashcode be a global symbol for which `Symbol.keyFor()` returned `undefined`? Wouldn't that avoid the concerns about non-determinism?","format":"org.matrix.custom.html","formatted_body":"Could a hashcode be a global symbol for which <code>Symbol.keyFor()</code> returned <code>undefined</code>? Wouldn't that avoid the concerns about non-determinism?","m.mentions":{},"msgtype":"m.text"},"ts":1712729200145,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$KIKPKOhaYqubriT2gkWG22V0BiyvxQHj3Wzsw47zZGI"},
{"content":{"body":"Symbols don't help non-determinism.\n\n```\ntypeof hash(\"a\"); // \"symbol\"\n\nif (hash(\"a\") === hash(\"b\")) {\n  print(\"foo\");\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"Symbols don't help non-determinism.<br /><br />```<br />typeof hash(\"a\"); // \"symbol\"<br /><br />if (hash(\"a\") === hash(\"b\")) {<br />  print(\"foo\");<br />}<br />```<br />","msgtype":"m.text"},"ts":1712738581918,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$RnbP9GDNepWUzHPShLSsTog31teRRQIU9-_seB1itNw"},
{"content":{"body":"Does the program print foo?","format":"org.matrix.custom.html","formatted_body":"Does the program print foo?","msgtype":"m.text"},"ts":1712738582462,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$wysiEBjlpJy5LX3FlLIXwmJB3Q83aMSftUmeReaey1g"},
{"content":{"body":"If the spec says that the symbol hash of every value is different and never equal, then we haven't hashed into a smaller space.\nIf the spec says which values have the same hash then this opens up code to collisions attacks.\nIf the spec says it's random which values have the same hash then it's non-deterministic if the program prints foo.\n\nis my understanding of the problem statement with the  various design constraints put forward from committee.","format":"org.matrix.custom.html","formatted_body":"If the spec says that the symbol hash of every value is different and never equal, then we haven't hashed into a smaller space.<br />If the spec says which values have the same hash then this opens up code to collisions attacks.<br />If the spec says it's random which values have the same hash then it's non-deterministic if the program prints foo.<br /><br />is my understanding of the problem statement with the  various design constraints put forward from committee.","msgtype":"m.text"},"ts":1712738879303,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$g5BL-gNKhKOpQE6jTnKQZ2dZXQwSfpgY6KjP9hBPzmE"},
{"content":{"body":"> <@rbuckton:matrix.org> Plus, AFAIK equals/hash is how every implementation implements maps natively, it's just not exposed to user code.\n\nAshley Claymore: I understood from this earlier assertion by Ron that implementations have already found ways to square the circle with respect to \"different and never equal\", but maybe I misunderstood?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$xgGvyBKSJ5vJqJeTktcJpw-ibk9n3l_NnCdEmvIg5UA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Plus, AFAIK equals/hash is how every implementation implements maps natively, it&#39;s just not exposed to user code.</blockquote></mx-reply><a href=\"https://matrix.to/#/@aclaymore:matrix.org\">Ashley Claymore</a>: I understood from this earlier assertion by Ron that implementations have already found ways to square the circle with respect to \"different and never equal\", but maybe I misunderstood?","m.mentions":{"user_ids":["@rbuckton:matrix.org","@aclaymore:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$xgGvyBKSJ5vJqJeTktcJpw-ibk9n3l_NnCdEmvIg5UA"}},"msgtype":"m.text"},"ts":1712740482430,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$D_6KG5FP975rTvXjAgnENOgBqXfuOhpdMY3exQagfdA"},
{"content":{"body":"Hashes can have conflicts — in a Map you store a list of entries per each hash. When looking up values in the map, you:\n1. Compute the has of the key\n2. Get the list corresponding to that hash\n3. Iterate through the list to check if the key is indeed there","format":"org.matrix.custom.html","formatted_body":"<p>Hashes can have conflicts — in a Map you store a list of entries per each hash. When looking up values in the map, you:</p>\n<ol>\n<li>Compute the has of the key</li>\n<li>Get the list corresponding to that hash</li>\n<li>Iterate through the list to check if the key is indeed there</li>\n</ol>","msgtype":"m.text"},"ts":1712740712400,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$3WgcSctajYB6X_KrvnmuTScVsIYfcdzqwBWRYaO_o7Q"},
{"content":{"body":"> <@eemeli:mozilla.org> Ashley Claymore: I understood from this earlier assertion by Ron that implementations have already found ways to square the circle with respect to \"different and never equal\", but maybe I misunderstood?\n\nYep. The important part is that this isn't exposed. Apart from trying to measure the execution time. Doing `map.set(\"a\", 1)` I can't tell if there was a hash collision and it had to probe, or the buckets needed to be-resized ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw%3Amatrix.org/%24D_6KG5FP975rTvXjAgnENOgBqXfuOhpdMY3exQagfdA\">In reply to</a> <a href=\"https://matrix.to/#/@eemeli:mozilla.org\">@eemeli:mozilla.org</a><br><a href=\"https://matrix.to/#/@aclaymore:matrix.org\">Ashley Claymore</a>: I understood from this earlier assertion by Ron that implementations have already found ways to square the circle with respect to \"different and never equal\", but maybe I misunderstood?</blockquote></mx-reply>Yep. The important part is that this isn't exposed. Apart from trying to measure the execution time. Doing `map.set(\"a\", 1)` I can't tell if there was a hash collision and it had to probe, or the buckets needed to be-resized ","m.relates_to":{"m.in_reply_to":{"event_id":"$D_6KG5FP975rTvXjAgnENOgBqXfuOhpdMY3exQagfdA"}},"msgtype":"m.text"},"ts":1712741205807,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$W1UazixP5XQ3ilGMQ0RSg9aVM-3TcN18S22lgQ4dq0U"},
{"content":{"body":"Ah, got it. So for a \"different and never equal\" sort of hash, `hash()` would need to remember all the values that have passed through it.\n\nA related thought I had that could limit the impact of that would be making the hash (or composite key, not really sure how they'd be very different) linked to the lifetime of an object. Then `hash(foo, \"a\")` and `hash(bar, \"a\")` would never equal if `foo !== bar`, but `hash(obj, { a: 1, b: 2}) === hash(obj, { b: 2, a: 1 })` could work.","format":"org.matrix.custom.html","formatted_body":"<p>Ah, got it. So for a \"different and never equal\" sort of hash, <code>hash()</code> would need to remember all the values that have passed through it.</p>\n<p>A related thought I had that could limit the impact of that would be making the hash (or composite key, not really sure how they'd be very different) linked to the lifetime of an object. Then <code>hash(foo, \"a\")</code> and <code>hash(bar, \"a\")</code> would never equal if <code>foo !== bar</code>, but <code>hash(obj, { a: 1, b: 2}) === hash(obj, { b: 2, a: 1 })</code> could work.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712742788319,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$nwuEvM2YkwyaX5pRF89oYRTVh0nyt07oG1117ESYc4Q"}
]