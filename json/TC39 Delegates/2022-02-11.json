[
{"content":{"body":"When proposing a new built-in method that returns a list of things, what's the latest guidance about when the list should be an array vs. an iterator? Iterators seem obviously better in the cases where the results can be a long list and/or where the result comes from an async/streaming source. But if the result is short and comes from an immutable native array that's already in memory, then is it OK to return an array to get better ergonomics (`filter`/`map`, `[0]`, etc.) ?  Context: https://github.com/tc39/ecma402/issues/598#issuecomment-1035916876","format":"org.matrix.custom.html","formatted_body":"When proposing a new built-in method that returns a list of things, what's the latest guidance about when the list should be an array vs. an iterator? Iterators seem obviously better in the cases where the results can be a long list and/or where the result comes from an async/streaming source. But if the result is short and comes from an immutable native array that's already in memory, then is it OK to return an array to get better ergonomics (<code>filter</code>/<code>map</code>, <code>[0]</code>, etc.) ?  Context: https://github.com/tc39/ecma402/issues/598#issuecomment-1035916876","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"When proposing a new built-in method that returns a list of things, what's the latest guidance about when the list should be an array vs. an iterator? Iterators seem obviously better in the cases where the results can be a long list and/or where the result comes from an async/streaming source. But if the result is short and comes from an immutable native array that's already in memory, then is it OK to return an array to get better ergonomics (`filter`/`map`, `[0]`, etc.) ?  Context: https://github.com/tc39/ecma402/issues/598#issuecomment-1035916876","mimetype":"text/plain"},{"body":"When proposing a new built-in method that returns a list of things, what's the latest guidance about when the list should be an array vs. an iterator? Iterators seem obviously better in the cases where the results can be a long list and/or where the result comes from an async/streaming source. But if the result is short and comes from an immutable native array that's already in memory, then is it OK to return an array to get better ergonomics (<code>filter</code>/<code>map</code>, <code>[0]</code>, etc.) ?  Context: https://github.com/tc39/ecma402/issues/598#issuecomment-1035916876","mimetype":"text/html"}]},"ts":1644602570291,"senderName":"justingrant","senderId":"@justingrant:matrix.org","id":"$-6VCT2wZo2ZWei3OhsyvXovyO6NaOACRbjh0d20J0KA"},
{"content":{"body":"there is no guidance, we're just gonna fight about it every time probably","msgtype":"m.text"},"ts":1644602660069,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$-ybtB5uf80llSPyGJKKI4A-WsQXeM7nx9-1SQcqq3oI"},
{"content":{"body":"though I think for short collections people are happy with arrays, generally","msgtype":"m.text"},"ts":1644602807096,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$kSrmv6vq-ep_pelUIVKVqvMrV0BqshH2x8jWYierIIw"},
{"content":{"body":"temporal has a couple new array-returning methods, e.g.","msgtype":"m.text"},"ts":1644602837129,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$HVzerSXzOR5AIpdaWU6efsZ-cEAq_XFzRH0fmJXnaUo"},
{"content":{"body":"it only really makes sense to have an iterator when you might have a lot of elements","msgtype":"m.text"},"ts":1644602875780,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$r97PGPS10j_xct_VnsQVhyLfLe94UPKGm-eGHvIkTnU"},
{"content":{"body":"I think all the Temporal methods were changed to return iterators as a result of pre-stage3 review","msgtype":"m.text"},"ts":1644603013696,"senderName":"ptomato","senderId":"@pchimento:igalia.com","id":"$UkI5ouKdT2UIL-SAPDGFzEiM0tdvlQP7RD4yR8M0Qvo"},
{"content":{"body":"We are probably gonna fight about it, but yes, return arrays when the values are short and/or fast to produce. Nothing wrong with them, lots right with them. The web platform uses arrays all over the place.","msgtype":"m.text","org.matrix.msc1767.text":"We are probably gonna fight about it, but yes, return arrays when the values are short and/or fast to produce. Nothing wrong with them, lots right with them. The web platform uses arrays all over the place."},"ts":1644603192888,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$Rygz4WsSKn6H5eDgURRNiD3826LdbNdUFdcBUDITPL8"},
{"content":{"body":"> <@tabatkins:matrix.org> We are probably gonna fight about it, but yes, return arrays when the values are short and/or fast to produce. Nothing wrong with them, lots right with them. The web platform uses arrays all over the place.\n\nImagine when tuples get standardized and we need to talk about whether to return tuples.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw%3Amatrix.org/%24Rygz4WsSKn6H5eDgURRNiD3826LdbNdUFdcBUDITPL8\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>We are probably gonna fight about it, but yes, return arrays when the values are short and/or fast to produce. Nothing wrong with them, lots right with them. The web platform uses arrays all over the place.</blockquote></mx-reply>Imagine when tuples get standardized and we need to talk about whether to return tuples.","m.relates_to":{"m.in_reply_to":{"event_id":"$Rygz4WsSKn6H5eDgURRNiD3826LdbNdUFdcBUDITPL8"}},"msgtype":"m.text"},"ts":1644603259953,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$qxLo2xQxhxAPPOT310F5FM7q97lv8ZrO45qz30p9FUc"},
{"content":{"body":"I'm annoyed every time Python returns a tuple rather than a list, so yeah, I anticipate those being fun.","msgtype":"m.text","org.matrix.msc1767.text":"I'm annoyed every time Python returns a tuple rather than a list, so yeah, I anticipate those being fun."},"ts":1644603291296,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$N7aHiW5nWJ_--Nz9o7r1m6LO7d2cmYiDXYgQ0usjXxM"},
{"content":{"body":"> I think all the Temporal methods were changed to return iterators as a result of pre-stage3 review\n\npretty sure nothing in the temporal spec right now returns an iterator and both `Temporal.Calendar.prototype.fields` and `Temporal.TimeZone.prototype.getPossibleInstantsFor` return arrays","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>I think all the Temporal methods were changed to return iterators as a result of pre-stage3 review</p>\n</blockquote>\n<p>pretty sure nothing in the temporal spec right now returns an iterator and both <code>Temporal.Calendar.prototype.fields</code> and <code>Temporal.TimeZone.prototype.getPossibleInstantsFor</code> return arrays</p>\n","msgtype":"m.text"},"ts":1644603774877,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$usOU2Dlm6GvSXJAifxjbleFf31EQGCHNdpdrENN_eqA"},
{"content":{"body":"unless the rendered spec is out of date","msgtype":"m.text"},"ts":1644603784709,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$NDRFF8r4cASSPA_WZV2-SlWTTeTOL640y9dIpLIL5rQ"},
{"content":{"body":"lots of things _consume_ iterables, which is right and proper","format":"org.matrix.custom.html","formatted_body":"lots of things <em>consume</em> iterables, which is right and proper","msgtype":"m.text"},"ts":1644603794396,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$rZq7m7XhPFJ6yrVmKhqH3vQdOOaUMFnowZ0uH6p-WUA"},
{"content":{"body":"oh, you're right, I was thinking of changing things to consume iterables","msgtype":"m.text"},"ts":1644603878490,"senderName":"ptomato","senderId":"@pchimento:igalia.com","id":"$e3_BCCVLNX4TcdDYEowyumftveX0GFjImqhg_-JaNUg"},
{"content":{"body":"carry on then","msgtype":"m.text"},"ts":1644603880650,"senderName":"ptomato","senderId":"@pchimento:igalia.com","id":"$Njd_ipWFBE0iWlsrIhiqcZV8oQ8xtTMQ2xsVvCrdf94"},
{"content":{"body":"ah yeah anything that takes an array should take an iterator, definitely. (webidl makes this automatic with the `sequence<>` argument type, but I guess you have to be a little more explicit in JS specs)","format":"org.matrix.custom.html","formatted_body":"ah yeah anything that takes an array should take an iterator, definitely. (webidl makes this automatic with the <code>sequence&lt;&gt;</code> argument type, but I guess you have to be a little more explicit in JS specs)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"ah yeah anything that takes an array should take an iterator, definitely. (webidl makes this automatic with the `sequence<>` argument type, but I guess you have to be a little more explicit in JS specs)","mimetype":"text/plain"},{"body":"ah yeah anything that takes an array should take an iterator, definitely. (webidl makes this automatic with the <code>sequence&lt;&gt;</code> argument type, but I guess you have to be a little more explicit in JS specs)","mimetype":"text/html"}]},"ts":1644603954481,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$fNkuMmB8j5tNVpRQbHcekSHabDINZPCCJPwszLN4kFE"},
{"content":{"body":"> though I think for short collections people are happy with arrays, generally\n\nCool. Sounds like the guidance is:\n1. Input parameters that are lists should be`Iterable`\n2. Return values that are long lists or are lists populated from an async or streaming source should be`Iterable`\n3. Return values that are short lists from a synchronous source should be`Array`\n\nIs that right?\n\nFWIW, Temporal has an interesting corner case for (1) above: the `CalendarProtocol.fields` method currently accepts an `Iterable<string>`, as must the equivalent method in the builtin `Temporal.Calendar` class that implements that protocol. But the only callers of that method pass a <10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder. \n\nWhat's the benefit of accepting an `Iterable` in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only `Array` is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>though I think for short collections people are happy with arrays, generally</p>\n</blockquote>\n<p>Cool. Sounds like the guidance is:</p>\n<ol>\n<li>Input parameters that are lists should be<code>Iterable</code></li>\n<li>Return values that are long lists or are lists populated from an async or streaming source should be<code>Iterable</code></li>\n<li>Return values that are short lists from a synchronous source should be<code>Array</code></li>\n</ol>\n<p>Is that right?</p>\n<p>FWIW, Temporal has an interesting corner case for (1) above: the <code>CalendarProtocol.fields</code> method currently accepts an <code>Iterable&lt;string&gt;</code>, as must the equivalent method in the builtin <code>Temporal.Calendar</code> class that implements that protocol. But the only callers of that method pass a &lt;10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder.</p>\n<p>What's the benefit of accepting an <code>Iterable</code> in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only <code>Array</code> is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> though I think for short collections people are happy with arrays, generally\n\nCool. Sounds like the guidance is:\n1. Input parameters that are lists should be`Iterable`\n2. Return values that are long lists or are lists populated from an async or streaming source should be`Iterable`\n3. Return values that are short lists from a synchronous source should be`Array`\n\nIs that right?\n\nFWIW, Temporal has an interesting corner case for (1) above: the `CalendarProtocol.fields` method currently accepts an `Iterable<string>`, as must the equivalent method in the builtin `Temporal.Calendar` class that implements that protocol. But the only callers of that method pass a <10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder. \n\nWhat's the benefit of accepting an `Iterable` in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only `Array` is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053","mimetype":"text/plain"},{"body":"<blockquote>\n<p>though I think for short collections people are happy with arrays, generally</p>\n</blockquote>\n<p>Cool. Sounds like the guidance is:</p>\n<ol>\n<li>Input parameters that are lists should be<code>Iterable</code></li>\n<li>Return values that are long lists or are lists populated from an async or streaming source should be<code>Iterable</code></li>\n<li>Return values that are short lists from a synchronous source should be<code>Array</code></li>\n</ol>\n<p>Is that right?</p>\n<p>FWIW, Temporal has an interesting corner case for (1) above: the <code>CalendarProtocol.fields</code> method currently accepts an <code>Iterable&lt;string&gt;</code>, as must the equivalent method in the builtin <code>Temporal.Calendar</code> class that implements that protocol. But the only callers of that method pass a &lt;10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder.</p>\n<p>What's the benefit of accepting an <code>Iterable</code> in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only <code>Array</code> is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053</p>\n","mimetype":"text/html"}]},"ts":1644610846186,"senderName":"justingrant","senderId":"@justingrant:matrix.org","id":"$47wUDIicIaOV5k2clZF-u8H536xkbQhWzLtEgGaNdTk"},
{"content":{"body":" * > though I think for short collections people are happy with arrays, generally\n\nCool. Sounds like the guidance is:\n1. Input parameters that are lists should be`Iterable`\n2. Return values that are long lists or are lists populated from an async or streaming source should be`Iterable`\n3. Return values that are short lists from a synchronous source should be`Array`\n\nIs that right?\n\nFWIW, Temporal has an interesting corner case for (1) above: the `CalendarProtocol.fields` method currently accepts an `Iterable<string>`, as must the equivalent method in the builtin `Temporal.Calendar` class that implements that protocol. But the only callers of that method pass a <10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder. \n\nWhat's the benefit of accepting an `Iterable` in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only `Array` is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>though I think for short collections people are happy with arrays, generally</p>\n</blockquote>\n<p>Cool. Sounds like the guidance is:</p>\n<ol>\n<li>Input parameters that are lists should be<code>Iterable</code></li>\n<li>Return values that are long lists or are lists populated from an async or streaming source should be<code>Iterable</code></li>\n<li>Return values that are short lists from a synchronous source should be<code>Array</code></li>\n</ol>\n<p>Is that right?</p>\n<p>FWIW, Temporal has an interesting corner case for (1) above: the <code>CalendarProtocol.fields</code> method currently accepts an <code>Iterable&lt;string&gt;</code>, as must the equivalent method in the builtin <code>Temporal.Calendar</code> class that implements that protocol. But the only callers of that method pass a &lt;10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder.</p>\n<p>What's the benefit of accepting an <code>Iterable</code> in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only <code>Array</code> is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053</p>\n","m.new_content":{"body":"> though I think for short collections people are happy with arrays, generally\n\nCool. Sounds like the guidance is:\n1. Input parameters that are lists should be`Iterable`\n2. Return values that are long lists or are lists populated from an async or streaming source should be`Iterable`\n3. Return values that are short lists from a synchronous source should be`Array`\n\nIs that right?\n\nFWIW, Temporal has an interesting corner case for (1) above: the `CalendarProtocol.fields` method currently accepts an `Iterable<string>`, as must the equivalent method in the builtin `Temporal.Calendar` class that implements that protocol. But the only callers of that method pass a <10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder. \n\nWhat's the benefit of accepting an `Iterable` in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only `Array` is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>though I think for short collections people are happy with arrays, generally</p>\n</blockquote>\n<p>Cool. Sounds like the guidance is:</p>\n<ol>\n<li>Input parameters that are lists should be<code>Iterable</code></li>\n<li>Return values that are long lists or are lists populated from an async or streaming source should be<code>Iterable</code></li>\n<li>Return values that are short lists from a synchronous source should be<code>Array</code></li>\n</ol>\n<p>Is that right?</p>\n<p>FWIW, Temporal has an interesting corner case for (1) above: the <code>CalendarProtocol.fields</code> method currently accepts an <code>Iterable&lt;string&gt;</code>, as must the equivalent method in the builtin <code>Temporal.Calendar</code> class that implements that protocol. But the only callers of that method pass a &lt;10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder.</p>\n<p>What's the benefit of accepting an <code>Iterable</code> in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only <code>Array</code> is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> though I think for short collections people are happy with arrays, generally\n\nCool. Sounds like the guidance is:\n1. Input parameters that are lists should be`Iterable`\n2. Return values that are long lists or are lists populated from an async or streaming source should be`Iterable`\n3. Return values that are short lists from a synchronous source should be`Array`\n\nIs that right?\n\nFWIW, Temporal has an interesting corner case for (1) above: the `CalendarProtocol.fields` method currently accepts an `Iterable<string>`, as must the equivalent method in the builtin `Temporal.Calendar` class that implements that protocol. But the only callers of that method pass a <10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder. \n\nWhat's the benefit of accepting an `Iterable` in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only `Array` is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053","mimetype":"text/plain"},{"body":"<blockquote>\n<p>though I think for short collections people are happy with arrays, generally</p>\n</blockquote>\n<p>Cool. Sounds like the guidance is:</p>\n<ol>\n<li>Input parameters that are lists should be<code>Iterable</code></li>\n<li>Return values that are long lists or are lists populated from an async or streaming source should be<code>Iterable</code></li>\n<li>Return values that are short lists from a synchronous source should be<code>Array</code></li>\n</ol>\n<p>Is that right?</p>\n<p>FWIW, Temporal has an interesting corner case for (1) above: the <code>CalendarProtocol.fields</code> method currently accepts an <code>Iterable&lt;string&gt;</code>, as must the equivalent method in the builtin <code>Temporal.Calendar</code> class that implements that protocol. But the only callers of that method pass a &lt;10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder.</p>\n<p>What's the benefit of accepting an <code>Iterable</code> in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only <code>Array</code> is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$47wUDIicIaOV5k2clZF-u8H536xkbQhWzLtEgGaNdTk","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * > though I think for short collections people are happy with arrays, generally\n\nCool. Sounds like the guidance is:\n1. Input parameters that are lists should be`Iterable`\n2. Return values that are long lists or are lists populated from an async or streaming source should be`Iterable`\n3. Return values that are short lists from a synchronous source should be`Array`\n\nIs that right?\n\nFWIW, Temporal has an interesting corner case for (1) above: the `CalendarProtocol.fields` method currently accepts an `Iterable<string>`, as must the equivalent method in the builtin `Temporal.Calendar` class that implements that protocol. But the only callers of that method pass a <10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder. \n\nWhat's the benefit of accepting an `Iterable` in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only `Array` is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053","mimetype":"text/plain"},{"body":" * <blockquote>\n<p>though I think for short collections people are happy with arrays, generally</p>\n</blockquote>\n<p>Cool. Sounds like the guidance is:</p>\n<ol>\n<li>Input parameters that are lists should be<code>Iterable</code></li>\n<li>Return values that are long lists or are lists populated from an async or streaming source should be<code>Iterable</code></li>\n<li>Return values that are short lists from a synchronous source should be<code>Array</code></li>\n</ol>\n<p>Is that right?</p>\n<p>FWIW, Temporal has an interesting corner case for (1) above: the <code>CalendarProtocol.fields</code> method currently accepts an <code>Iterable&lt;string&gt;</code>, as must the equivalent method in the builtin <code>Temporal.Calendar</code> class that implements that protocol. But the only callers of that method pass a &lt;10-element array of static, immutable values. We've gotten implementer feedback that using an Iterable here makes the implementation harder.</p>\n<p>What's the benefit of accepting an <code>Iterable</code> in this case if the only callers of this method are expected to come from inside ECMAScript where we can guarantee that only <code>Array</code> is passed?  FYI https://github.com/tc39/proposal-temporal/issues/2053</p>\n","mimetype":"text/html"}]},"ts":1644610882606,"senderName":"justingrant","senderId":"@justingrant:matrix.org","id":"$EnnqNP5-gCmbeaAOuHwnh2fhc8L5zUjZDE1RHI1YbyM"},
{"content":{"body":"I think we had gotten the feedback during stage 3 review that we should accept an iterable there because a userland implemenation of fields() might want to return one?","msgtype":"m.text"},"ts":1644610995554,"senderName":"ptomato","senderId":"@pchimento:igalia.com","id":"$rPWMhs8oyug-twz50RU19vMa5Ini4efK4TNdd_MNojw"},
{"content":{"body":"If it's actually only supposed to be called internally then it shouldn't be exposed","msgtype":"m.text"},"ts":1644611124369,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$8VW7YQeB8MProAWknSOvUwRKBKc6G6CBrTFD5tpfgmw"},
{"content":{"body":"if it's exposed then you have to design it as if it's going to be used","msgtype":"m.text"},"ts":1644611143601,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$OGX278n7FG4KBQHFQKdyQIkHOQeZp4ViS0mtwhpwLdw"},
{"content":{"body":"anyway for that specific question see https://github.com/tc39/proposal-temporal/issues/1610","msgtype":"m.text"},"ts":1644611207928,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$q6L5es7cpihscfj6zD7IqB-PX4vyMWSiTrfguUZ8qJw"},
{"content":{"body":"this was also discussed in plenary IIRC so you can probably find it in the notes as well","msgtype":"m.text"},"ts":1644611221262,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$4Sj3c46tFLIRkExEcG-zUa8gnW4LVLeYTHRYFsxu8Qs"},
{"content":{"body":"it's exposed because it's necessary for writing a custom calendar, so indeed we have to assume it's going to be used","msgtype":"m.text"},"ts":1644611577788,"senderName":"ptomato","senderId":"@pchimento:igalia.com","id":"$TKS8lf6jdFbqrdiyPR2GWMHk-8u7PxbZCgcltsHcZm4"},
{"content":{"body":"Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression.\n\nHow do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?","format":"org.matrix.custom.html","formatted_body":"<p>Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression <code>?</code> AssignmentExpression <code>:</code> AssignmentExpression.</p>\n<p>How do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression.\n\nHow do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?","mimetype":"text/plain"},{"body":"<p>Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression <code>?</code> AssignmentExpression <code>:</code> AssignmentExpression.</p>\n<p>How do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?</p>\n","mimetype":"text/html"}]},"ts":1644612226198,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$xz91um2V5W3P7yqDFrsPEP3zp0kNA5qlzvcXvx-I9Xo"},
{"content":{"body":" * Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression.\n\nHow do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?","format":"org.matrix.custom.html","formatted_body":" * <p>Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression <code>?</code> AssignmentExpression <code>:</code> AssignmentExpression.</p>\n<p>How do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?</p>\n","m.new_content":{"body":"Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression.\n\nHow do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?","format":"org.matrix.custom.html","formatted_body":"<p>Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression <code>?</code> AssignmentExpression <code>:</code> AssignmentExpression.</p>\n<p>How do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression.\n\nHow do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?","mimetype":"text/plain"},{"body":"<p>Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression <code>?</code> AssignmentExpression <code>:</code> AssignmentExpression.</p>\n<p>How do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$xz91um2V5W3P7yqDFrsPEP3zp0kNA5qlzvcXvx-I9Xo","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression.\n\nHow do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?","mimetype":"text/plain"},{"body":" * <p>Let’s say I have a syntax-directed operation associated with the production ConditionalExpression : ShortCircuitExpression <code>?</code> AssignmentExpression <code>:</code> AssignmentExpression.</p>\n<p>How do I refer in the algorithm to either particular AssignmentExpression, since |AssignmentExpression| is ambiguous?</p>\n","mimetype":"text/html"}]},"ts":1644612235439,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$ZzumjahiDCV8W9cqiwaN5MPne3m0q3t1ZbRM35CDJ0s"},
{"content":{"body":"`the first |AssignmentExpression|`","format":"org.matrix.custom.html","formatted_body":"<code>the first |AssignmentExpression|</code>","msgtype":"m.text"},"ts":1644612346377,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$56lot4Bq8uZSOuAR22aZVXQmippVJfrwmJWBiMCP1i0"}
]