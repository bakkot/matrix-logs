[
{"content":{"body":"rbuckton: (or anyone else who is a grammar expert): i don't understand the `await using` cover grammar","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: (or anyone else who is a grammar expert): i don't understand the <code>await using</code> cover grammar","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"msgtype":"m.text"},"ts":1715981498198,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$NakkUfCxCyMY0QZsnp056KMxlE7ibatYf4bVNWi4C_A"},
{"content":{"body":"the stage 3 spec draft has this:","m.mentions":{},"msgtype":"m.text"},"ts":1715981548479,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$V-i_pfZwKx7TrMOhhB-TuV7pWi05bpf6xpS3y0HZx9U"},
{"content":{"body":"CoverAwaitExpressionAndAwaitUsingDeclarationHead and AwaitExpression are exactly the same. how can you refine a grammar with the same grammar?","m.mentions":{},"msgtype":"m.text"},"ts":1715981597892,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$o54HuQFiIAgMJ2_7Gu0UGd5E36GRHZHLPK5Etx3FSPM"},
{"content":{"body":"the intention must've been that `await using x` in StatementItemList position is parsed in its entire 3 tokens by AwaitUsingDeclaration instead of the first 2 tokens by AwaitExpression, but i don't think you can express that by having a cover grammar for the first two tokens only","format":"org.matrix.custom.html","formatted_body":"the intention must've been that <code>await using x</code> in StatementItemList position is parsed in its entire 3 tokens by AwaitUsingDeclaration instead of the first 2 tokens by AwaitExpression, but i don't think you can express that by having a cover grammar for the first two tokens only","m.mentions":{},"msgtype":"m.text"},"ts":1715981906988,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$K1V0tsIOh1X4Ewf4GakZ3JHoTZoZgLzHB_ReNXtq3YQ"},
{"content":{"body":"i don't know how else to express this though","m.mentions":{},"msgtype":"m.text"},"ts":1715981911387,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9CX4TQWldT5hQuf556Bxjacf5tbworoRxoN3OWIagvw"},
{"content":{"body":"or wait, is that how cover grammars work?","m.mentions":{},"msgtype":"m.text"},"ts":1715981941242,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$11NIyzXJb8hKOOmzlcaOavimjgYlp_HDNDEWviur8Cw"},
{"content":{"body":"It works the same way as `CoverCallExpressionAndAsyncArrowHead`, which refines to `CallMemberExpression` (which is identical)","format":"org.matrix.custom.html","formatted_body":"It works the same way as <code>CoverCallExpressionAndAsyncArrowHead</code>, which refines to <code>CallMemberExpression</code> (which is identical)","m.mentions":{},"msgtype":"m.text"},"ts":1715982151272,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oCQA8Bzp-b6BqTHTW8zvd-ZmxJO0kLvfDOmD79BozqU"},
{"content":{"body":"The difference is that you can parse the cover in places you can't parse AwaitExpression on its own, such as `await using x`. `await using` isn't a legal AwaitExpression if an identifier follows it on the same line, but its parse can be reused for AwaitUsingDeclaration","format":"org.matrix.custom.html","formatted_body":"The difference is that you can parse the cover in places you can't parse AwaitExpression on its own, such as <code>await using x</code>. <code>await using</code> isn't a legal AwaitExpression if an identifier follows it on the same line, but its parse can be reused for AwaitUsingDeclaration","m.mentions":{},"msgtype":"m.text"},"ts":1715982410299,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CVWOzMoXtat3EwhouRJHNonbMeYJtP91yWdlk0zhDdI"},
{"content":{"body":"Just like `async(x)` is a valid call expression as long as it's not followed by a `=>`","format":"org.matrix.custom.html","formatted_body":"Just like <code>async(x)</code> is a valid call expression as long as it's not followed by a <code>=&gt;</code>","m.mentions":{},"msgtype":"m.text"},"ts":1715982481138,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RrcWTK9wyW8PVIQ3TmwbIR64pbmX-A33uHQDCv5OaRA"},
{"content":{"body":" * Just like `async(x)` is a valid call expression as long as it's not followed by a `=>` (or any other illegal token)","format":"org.matrix.custom.html","formatted_body":" * Just like <code>async(x)</code> is a valid call expression as long as it's not followed by a <code>=&gt;</code> (or any other illegal token)","m.mentions":{},"m.new_content":{"body":"Just like `async(x)` is a valid call expression as long as it's not followed by a `=>` (or any other illegal token)","format":"org.matrix.custom.html","formatted_body":"Just like <code>async(x)</code> is a valid call expression as long as it's not followed by a <code>=&gt;</code> (or any other illegal token)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$RrcWTK9wyW8PVIQ3TmwbIR64pbmX-A33uHQDCv5OaRA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715982492114,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eUKtxkPccHILcQ9CwZFyPm4ac1KhpkmNTjBlpGjoeBg"},
{"content":{"body":"oh huh, i see","m.mentions":{},"msgtype":"m.text"},"ts":1715982500009,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$DWVdzRvqTxowQKpIFGNe834htnZ8XVf6k_sZAsEaggo"},
{"content":{"body":"The cover is essentially eagerly parsing out the syntax. Some covers allow more tokens than what any single refinement might use, but that isn't always the case.","m.mentions":{},"msgtype":"m.text"},"ts":1715982582176,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nxtRyXz30nKB0sf7cTD0BWotf010eEk9ZXG4qnoamO4"},
{"content":{"body":"i'm trying to understand why this can't be expressed as AwaitUsingDeclaration: `await` [ntl] `using` [ntl] BindingList without a cover","format":"org.matrix.custom.html","formatted_body":"i'm trying to understand why this can't be expressed as AwaitUsingDeclaration: <code>await</code> [ntl] <code>using</code> [ntl] BindingList without a cover","m.mentions":{},"msgtype":"m.text"},"ts":1715982675002,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$WR5_6sTgKSJ8_HzSgMd6jIZyXt4CcpKuhWgThlhqbOQ"},
{"content":{"body":"it's still the case that there's no valid parse of that sequence of tokens with an AwaitExpression","m.mentions":{},"msgtype":"m.text"},"ts":1715983075817,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6uVPfvieW4ibg0udXBUilZdiDue8zQUUCj02cLRijbQ"},
{"content":{"body":"Given the source text `await using x = y`, you have two potential parses for `await using`: An _ExpressionStatement_ containing an _AwaitExpresion_, or a _LexicalDeclaration_ containing an _AwaitUsingDeclaration_. You have to consider both parses as equally viable until they are not. For _ExpressionStatement_, you descend through _Expression_ to parse `await using`, but _ExpressionStatement_ must end in a `;`. Since `x` is not `;`, it's not a valid _ExpressionStatement_. For _LexicalDeclaration_, you can parse `await using` followed by an identifier and that matches an _AwaitUsingDeclaration_.\nIt's only after both of these potential parses fails that ASI is considered, and a `;` would only be inserted after `await using` if there was a line terminator before the `x`. ","format":"org.matrix.custom.html","formatted_body":"Given the source text <code>await using x = y</code>, you have two potential parses for <code>await using</code>: An <em>ExpressionStatement</em> containing an <em>AwaitExpresion</em>, or a <em>LexicalDeclaration</em> containing an <em>AwaitUsingDeclaration</em>. You have to consider both parses as equally viable until they are not. For <em>ExpressionStatement</em>, you descend through <em>Expression</em> to parse <code>await using</code>, but <em>ExpressionStatement</em> must end in a <code>;</code>. Since <code>x</code> is not <code>;</code>, it's not a valid <em>ExpressionStatement</em>. For <em>LexicalDeclaration</em>, you can parse <code>await using</code> followed by an identifier and that matches an <em>AwaitUsingDeclaration</em>.<br>It's only after both of these potential parses fails that ASI is considered, and a <code>;</code> would only be inserted after <code>await using</code> if there was a line terminator before the <code>x</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1715983216196,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$o-X2cvz_o58WCXXK7lkXKee4Xb6lah2Tyiw5iImf25k"},
{"content":{"body":"Given the source\n```\nawait using\nx = y\n```\nThe same process occurs, except the NLT restriction means AwaitUsingDeclaration isn't a valid parse in that case","format":"org.matrix.custom.html","formatted_body":"<p>Given the source</p>\n<pre><code>await using\nx = y\n</code></pre>\n<p>The same process occurs, except the NLT restriction means AwaitUsingDeclaration isn't a valid parse in that case</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1715983266949,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VclyD89yj8rLfb866Req9Ri8KSyXMxA4SEuUrJHtUnA"},
{"content":{"body":"ah, it's ASI","m.mentions":{},"msgtype":"m.text"},"ts":1715983478820,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$f8tAvu08KRjX4S-KXzMyFRxd8670QO_DMt7fO4i6joY"},
{"content":{"body":"got it","m.mentions":{},"msgtype":"m.text"},"ts":1715983479501,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$NMJwP_LkeKRCDh3FNsVWEX7uNJVrZ2NgRgTZxwTe67g"},
{"content":{"body":" * Given the source text `await using x = y`, you have two potential parses for `await using`: An _ExpressionStatement_ containing an _AwaitExpresion_, or a _LexicalDeclaration_ containing an _AwaitUsingDeclaration_. You have to consider both parses as equally viable until they are not. For _ExpressionStatement_, you descend through _Expression_ to parse `await using`, but _ExpressionStatement_ must end in a `;`. Since `x` is not `;`, it's not a valid _ExpressionStatement_. For _LexicalDeclaration_, you can parse `await using` followed by an identifier and that matches an _AwaitUsingDeclaration_.\nIt's only after both of these potential parses fail that ASI is considered, and a `;` would only be inserted after `await using` if there was a line terminator before the `x`.","format":"org.matrix.custom.html","formatted_body":" * Given the source text <code>await using x = y</code>, you have two potential parses for <code>await using</code>: An <em>ExpressionStatement</em> containing an <em>AwaitExpresion</em>, or a <em>LexicalDeclaration</em> containing an <em>AwaitUsingDeclaration</em>. You have to consider both parses as equally viable until they are not. For <em>ExpressionStatement</em>, you descend through <em>Expression</em> to parse <code>await using</code>, but <em>ExpressionStatement</em> must end in a <code>;</code>. Since <code>x</code> is not <code>;</code>, it's not a valid <em>ExpressionStatement</em>. For <em>LexicalDeclaration</em>, you can parse <code>await using</code> followed by an identifier and that matches an <em>AwaitUsingDeclaration</em>.<br>It's only after both of these potential parses fail that ASI is considered, and a <code>;</code> would only be inserted after <code>await using</code> if there was a line terminator before the <code>x</code>.","m.mentions":{},"m.new_content":{"body":"Given the source text `await using x = y`, you have two potential parses for `await using`: An _ExpressionStatement_ containing an _AwaitExpresion_, or a _LexicalDeclaration_ containing an _AwaitUsingDeclaration_. You have to consider both parses as equally viable until they are not. For _ExpressionStatement_, you descend through _Expression_ to parse `await using`, but _ExpressionStatement_ must end in a `;`. Since `x` is not `;`, it's not a valid _ExpressionStatement_. For _LexicalDeclaration_, you can parse `await using` followed by an identifier and that matches an _AwaitUsingDeclaration_.\nIt's only after both of these potential parses fail that ASI is considered, and a `;` would only be inserted after `await using` if there was a line terminator before the `x`.","format":"org.matrix.custom.html","formatted_body":"Given the source text <code>await using x = y</code>, you have two potential parses for <code>await using</code>: An <em>ExpressionStatement</em> containing an <em>AwaitExpresion</em>, or a <em>LexicalDeclaration</em> containing an <em>AwaitUsingDeclaration</em>. You have to consider both parses as equally viable until they are not. For <em>ExpressionStatement</em>, you descend through <em>Expression</em> to parse <code>await using</code>, but <em>ExpressionStatement</em> must end in a <code>;</code>. Since <code>x</code> is not <code>;</code>, it's not a valid <em>ExpressionStatement</em>. For <em>LexicalDeclaration</em>, you can parse <code>await using</code> followed by an identifier and that matches an <em>AwaitUsingDeclaration</em>.<br>It's only after both of these potential parses fail that ASI is considered, and a <code>;</code> would only be inserted after <code>await using</code> if there was a line terminator before the <code>x</code>.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$o-X2cvz_o58WCXXK7lkXKee4Xb6lah2Tyiw5iImf25k","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715983480566,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5VcEYIfzjsAk_tfB2fNAMPDSRqhlAEGNfCvqDnEFM6k"},
{"content":{"body":"well that's also fucking terrible","m.mentions":{},"msgtype":"m.text"},"ts":1715983490648,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$OyjzGZmX6A9ydxdhCW7SriwTUr1RRhwA9xKV4I4BQbc"},
{"content":{"body":"In TypeScript I just do two token lookahead. If I'm on `await` and the next token is `using`, I check that the token that follows it is not an Identifier on the same line.","format":"org.matrix.custom.html","formatted_body":"In TypeScript I just do two token lookahead. If I'm on <code>await</code> and the next token is <code>using</code>, I check that the token that follows it is not an Identifier on the same line.","m.mentions":{},"msgtype":"m.text"},"ts":1715983587285,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Nj2BOav5PsXwwT5A5Hg8CE2QoWgMkk8UrZ6i2EoEJMI"},
{"content":{"body":"We try to say that ECMA262 is LR(1), but we have a single two-token lookahead with `` [ lookahead != `let` `[` ] `` for _ExpressionStatement_ that violates that. ","format":"org.matrix.custom.html","formatted_body":"We try to say that ECMA262 is LR(1), but we have a single two-token lookahead with <code>[ lookahead != `let` `[` ]</code> for <em>ExpressionStatement</em> that violates that.","m.mentions":{},"msgtype":"m.text"},"ts":1715983712939,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$LoDpxNZ-8qUqAD6a-DxQQUElHg-07G75ZJlp8djG4X0"}
]