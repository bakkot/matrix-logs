[
{"content":{"body":"erights: During plenary you asked if there was anything outside of `export`/`export default` that would make the `Function.prototype.toString` of a class non-`eval`-able given sufficient context for identifiers. I said no, but there is, to a degree. Any computed property name can contain `await` or `yield`, making it non-`eval`-able by default without having to wrap the string in something like an `\"async function * () { ... }\"` first. The context _outside_ of the `eval` itself is not sufficient to support `await` and `yield` on their own. While this is unlikely to occur regularly, it is perfectly legal JS.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@erights:matrix.org\">erights</a>: During plenary you asked if there was anything outside of <code>export</code>/<code>export default</code> that would make the <code>Function.prototype.toString</code> of a class non-<code>eval</code>-able given sufficient context for identifiers. I said no, but there is, to a degree. Any computed property name can contain <code>await</code> or <code>yield</code>, making it non-<code>eval</code>-able by default without having to wrap the string in something like an <code>&quot;async function * () { ... }&quot;</code> first. The context <em>outside</em> of the <code>eval</code> itself is not sufficient to support <code>await</code> and <code>yield</code> on their own. While this is unlikely to occur regularly, it is perfectly legal JS.","msgtype":"m.text"},"ts":1675301142237,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$f5OSV2cnG9vFZp2732XphlC3fx43fej7Rv_mwqqQiFY"}
]