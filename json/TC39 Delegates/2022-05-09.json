[
{"content":{"body":"Unlucky ","msgtype":"m.text"},"ts":1652062658454,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$htcs5e-ilv7sodA7zmmBNgHl11pYs-8yzlJZNR51hUs"},
{"content":{"body":"What's the reason it being rejected? ","msgtype":"m.text"},"ts":1652062659125,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$qTbJK2aXauv5hUHD8Ar6TY7Yx5sh9uh7hMR-nI6R3-I"},
{"content":{"body":"it was considered to be adding too much complexity","msgtype":"m.text","org.matrix.msc1767.text":"it was considered to be adding too much complexity"},"ts":1652066888557,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$7fHRGJe7pe_9BPGEdiM47ksuoD-u1KS8dxAUCyPaaeg"},
{"content":{"body":"ultimately i think that was a mistake (i still see people run into the dynamic import problem in the wild) but what can ya do ðŸ¤·","msgtype":"m.text","org.matrix.msc1767.text":"ultimately i think that was a mistake (i still see people run into the dynamic import problem in the wild) but what can ya do ðŸ¤·"},"ts":1652066939680,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$3sDhiv5OaWtyPccuK0DUXXpWxxPAMp5WLcwLA2qI6e0"},
{"content":{"body":"hmm here are the notes https://github.com/tc39/notes/blob/main/meetings/2018-05/may-24.md#symbolthenable-for-stage-1-or-2","msgtype":"m.text","org.matrix.msc1767.text":"hmm here are the notes https://github.com/tc39/notes/blob/main/meetings/2018-05/may-24.md#symbolthenable-for-stage-1-or-2"},"ts":1652067042011,"senderName":"devsnek","senderId":"@devsnek:matrix.org","id":"$X7jveph3LaI_0Y-l-WAj8UOHvoAbNC6XKykXbw6wph0"},
{"content":{"body":"> <@jackworks:matrix.org> Is it possible to add a Symbol.unthenable and attach it to the module namespace object? \n\nI think unfortunately that ship has definitely sailed. At this point adding such a symbol to the language wouldn't accomplish anything. You can't add such a symbol automatically to all module namespace objects as it'd be Web incompatible. And developers can't add such a symbol themselves (only string identifiers can be exports) before they'd get tripped by a dynamic import.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$ltXz5Ukl3LwA7jBzlHBE_JYcYpG1O6wZfWcikPSZJ94?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br />Is it possible to add a Symbol.unthenable and attach it to the module namespace object?</blockquote></mx-reply>I think unfortunately that ship has definitely sailed. At this point adding such a symbol to the language wouldn't accomplish anything. You can't add such a symbol automatically to all module namespace objects as it'd be Web incompatible. And developers can't add such a symbol themselves (only string identifiers can be exports) before they'd get tripped by a dynamic import.","m.relates_to":{"m.in_reply_to":{"event_id":"$ltXz5Ukl3LwA7jBzlHBE_JYcYpG1O6wZfWcikPSZJ94"}},"msgtype":"m.text"},"ts":1652069092510,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CJbDGMTtOLhrjUV-B3bPmnJclvMV0d_U_xe3RMrRSCc"},
{"content":{"body":"Just some history... the hazard of dynamic import resolving thenables was known ahead of time.  I tried to point it out but it didn't end up going anywhere as it was framed as yet-another-instance of an existing hazard.\n\nhttps://github.com/tc39/proposal-dynamic-import/issues/48","msgtype":"m.text","org.matrix.msc1767.text":"Just some history... the hazard of dynamic import resolving thenables was known ahead of time.  I tried to point it out but it didn't end up going anywhere as it was framed as yet-another-instance of an existing hazard.\n\nhttps://github.com/tc39/proposal-dynamic-import/issues/48"},"ts":1652081181148,"senderName":"Rob Palmer","senderId":"@robpalme:matrix.org","id":"$ktdZQGo-3B7WqMpD6CB2IPEd0sTBJI314iqhPfTF2Dw"},
{"content":{"body":"> <@mhofman:matrix.org> I think unfortunately that ship has definitely sailed. At this point adding such a symbol to the language wouldn't accomplish anything. You can't add such a symbol automatically to all module namespace objects as it'd be Web incompatible. And developers can't add such a symbol themselves (only string identifiers can be exports) before they'd get tripped by a dynamic import.\n\nwhy would it be web incompatible? exports can't provide symbols there, specifically so we CAN add a new symbol to module namespace objects at any time.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$CJbDGMTtOLhrjUV-B3bPmnJclvMV0d_U_xe3RMrRSCc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I think unfortunately that ship has definitely sailed. At this point adding such a symbol to the language wouldn't accomplish anything. You can't add such a symbol automatically to all module namespace objects as it'd be Web incompatible. And developers can't add such a symbol themselves (only string identifiers can be exports) before they'd get tripped by a dynamic import.</blockquote></mx-reply>why would it be web incompatible? exports can't provide symbols there, specifically so we CAN add a new symbol to module namespace objects at any time.","m.relates_to":{"m.in_reply_to":{"event_id":"$CJbDGMTtOLhrjUV-B3bPmnJclvMV0d_U_xe3RMrRSCc"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@mhofman:matrix.org> I think unfortunately that ship has definitely sailed. At this point adding such a symbol to the language wouldn't accomplish anything. You can't add such a symbol automatically to all module namespace objects as it'd be Web incompatible. And developers can't add such a symbol themselves (only string identifiers can be exports) before they'd get tripped by a dynamic import.\n\nwhy would it be web incompatible? exports can't provide symbols there, specifically so we CAN add a new symbol to module namespace objects at any time.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$CJbDGMTtOLhrjUV-B3bPmnJclvMV0d_U_xe3RMrRSCc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I think unfortunately that ship has definitely sailed. At this point adding such a symbol to the language wouldn't accomplish anything. You can't add such a symbol automatically to all module namespace objects as it'd be Web incompatible. And developers can't add such a symbol themselves (only string identifiers can be exports) before they'd get tripped by a dynamic import.</blockquote></mx-reply>why would it be web incompatible? exports can't provide symbols there, specifically so we CAN add a new symbol to module namespace objects at any time.","mimetype":"text/html"}]},"ts":1652122784083,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$4WU1FrWF9nGpeZ7-KS4ThMkpanXrC5mkAsGLeTK0esA"},
{"content":{"body":"or do you just mean, making it unthenable would be incompatible","msgtype":"m.text","org.matrix.msc1767.text":"or do you just mean, making it unthenable would be incompatible"},"ts":1652122857935,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$X4k-h30DpXGhGa2NtHvziSS495jrhptlWhM14KpKF3s"},
{"content":{"body":"I meant adding a symbol such as unthenable by default to all module namespace objects. There are modules in the wild that do expect this thenable behavior","msgtype":"m.text","org.matrix.msc1767.text":"I meant adding a symbol such as unthenable by default to all module namespace objects. There are modules in the wild that do expect this thenable behavior"},"ts":1652122860266,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$jHNlGTuouYo773PCtZ8osn62tBvE97y1vWwpU3hlfxY"},
{"content":{"body":"right, true enough. altho probably not a ton, since having a thenable module is broken in node (i forget if it's broken just in the repl, or just not in the repl)","msgtype":"m.text","org.matrix.msc1767.text":"right, true enough. altho probably not a ton, since having a thenable module is broken in node (i forget if it's broken just in the repl, or just not in the repl)"},"ts":1652122893999,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$fQUH-mX2sGnHo0uRtyfGKmypjSRK3UurrIZwxp_UQgw"},
{"content":{"body":"It definitely works in the browser, I have personally (ab)used this mechanism","msgtype":"m.text","org.matrix.msc1767.text":"It definitely works in the browser, I have personally (ab)used this mechanism"},"ts":1652123081932,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$40XGUz02T8WgVBgftUdUpyZh8KvWH0yICMV5vDANN0Y"},
{"content":{"body":"Ooo boy, did anyone realize we don't actually follow the Promises A+ spec?","msgtype":"m.text","org.matrix.msc1767.text":"Ooo boy, did anyone realize we don't actually follow the Promises A+ spec?"},"ts":1652125302955,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$DEewwlMPfmD_Q7p_hng9RInIPbapnoSwqE5Iuy48NL8"},
{"content":{"body":"We pass the spec's tests, only because it forgot to test a behavior.","msgtype":"m.text","org.matrix.msc1767.text":"We pass the spec's tests, only because it forgot to test a behavior."},"ts":1652125324166,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$3t7Fbze1iAOSx1KyxAOhj7Yi_cutAIdGq_KneXsPNKs"},
{"content":{"body":"Step 13-15 of https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-resolve-functions","msgtype":"m.text","org.matrix.msc1767.text":"Step 13-15 of https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-resolve-functions"},"ts":1652125359474,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$fVWpUp4_F0XGnTr1NKnmG7o868hYbHdxpsgEIdbxsj8"},
{"content":{"body":"We create a new job to handle a thenable passed to `resovle` in `new Promise(res => res(thenable))`","format":"org.matrix.custom.html","formatted_body":"We create a new job to handle a thenable passed to <code>resovle</code> in <code>new Promise(res =&gt; res(thenable))</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"We create a new job to handle a thenable passed to `resovle` in `new Promise(res => res(thenable))`","mimetype":"text/plain"},{"body":"We create a new job to handle a thenable passed to <code>resovle</code> in <code>new Promise(res =&gt; res(thenable))</code>","mimetype":"text/html"}]},"ts":1652125393625,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$wCWRt_CEFyEhlvBDav8Te2RIkcHOTHKBwTI8k-tPcOA"},
{"content":{"body":"That's not correct","msgtype":"m.text","org.matrix.msc1767.text":"That's not correct"},"ts":1652125399495,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$RUIhLOW-N8JfDXZcUgzWlto47IZEEZDfNo4K3rO1AE0"},
{"content":{"body":"https://promisesaplus.com/#point-56","msgtype":"m.text","org.matrix.msc1767.text":"https://promisesaplus.com/#point-56"},"ts":1652125423172,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$s2BS6SyAnwOv0_7KWuQTJEsN0rhkZrM801y3x--3O4g"},
{"content":{"body":"> If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where...","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where...</p>\n</blockquote>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where...","mimetype":"text/plain"},{"body":"<blockquote>\n<p>If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where...</p>\n</blockquote>\n","mimetype":"text/html"}]},"ts":1652125456037,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$l3dgnUfPoRQ5GWKDB82OveRsIcVdMfD67uF1-31WVes"},
{"content":{"body":"It makes no mention of a new job for thenables","msgtype":"m.text","org.matrix.msc1767.text":"It makes no mention of a new job for thenables"},"ts":1652125466925,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$_giWrY1o0JsWahj_dQqTklkLLf_McTpaC0dX7lclbwA"},
{"content":{"body":" * It makes no mention of a new job for thenables","m.new_content":{"body":"It makes no mention of a new job for thenables","msgtype":"m.text","org.matrix.msc1767.text":"It makes no mention of a new job for thenables"},"m.relates_to":{"event_id":"$_giWrY1o0JsWahj_dQqTklkLLf_McTpaC0dX7lclbwA","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * It makes no mention of a new job for thenables"},"ts":1652125479977,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5bamrVRjE-W78gcmA1i4r5pTyIL9BbOPrZbwAkKIiJE"},
{"content":{"body":"This is the root cause of both https://github.com/tc39/ecma262/issues/2770 and https://github.com/tc39/ecma262/issues/1250","msgtype":"m.text","org.matrix.msc1767.text":"This is the root cause of both https://github.com/tc39/ecma262/issues/2770 and https://github.com/tc39/ecma262/issues/1250"},"ts":1652125506223,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Ok5mRMX5oDxXuCsVR9SYp5x0guc4XFGte9-vd-SCcqQ"},
{"content":{"body":"`thenable.then(resolve)` and `resolve(thenable)` are supposed to take the same number of ticks.","format":"org.matrix.custom.html","formatted_body":"<code>thenable.then(resolve)</code> and <code>resolve(thenable)</code> are supposed to take the same number of ticks.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`thenable.then(resolve)` and `resolve(thenable)` are supposed to take the same number of ticks.","mimetype":"text/plain"},{"body":"<code>thenable.then(resolve)</code> and <code>resolve(thenable)</code> are supposed to take the same number of ticks.","mimetype":"text/html"}]},"ts":1652125622452,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$NJoOYf2UyKKauEYvPJJ1vnTfAkgiej36ij0tTC6utts"},
{"content":{"body":"But because `resolve(thenable)` creates a new job for doing the `then.call(prom, onFul, onRej)` and the `then` internally creates a new job before calling `onFul`/`onRej`, we get 2 ticks instead of 1.","format":"org.matrix.custom.html","formatted_body":"But because <code>resolve(thenable)</code> creates a new job for doing the <code>then.call(prom, onFul, onRej)</code> and the <code>then</code> internally creates a new job before calling <code>onFul</code>/<code>onRej</code>, we get 2 ticks instead of 1.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"But because `resolve(thenable)` creates a new job for doing the `then.call(prom, onFul, onRej)` and the `then` internally creates a new job before calling `onFul`/`onRej`, we get 2 ticks instead of 1.","mimetype":"text/plain"},{"body":"But because <code>resolve(thenable)</code> creates a new job for doing the <code>then.call(prom, onFul, onRej)</code> and the <code>then</code> internally creates a new job before calling <code>onFul</code>/<code>onRej</code>, we get 2 ticks instead of 1.","mimetype":"text/html"}]},"ts":1652125685217,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$kCnssKYZZl4OqwPWC0Fp2uBgGeN0GpN2trgLO1sOr3Y"},
{"content":{"body":" * But because `resolve(thenable)` creates a new job for doing the `then.call(prom, onFul, onRej)` and the `then` internally creates a new job before calling `onFul`/`onRej`, we get 2 ticks instead of 1.","format":"org.matrix.custom.html","formatted_body":" * But because <code>resolve(thenable)</code> creates a new job for doing the <code>then.call(prom, onFul, onRej)</code> and the <code>then</code> internally creates a new job before calling <code>onFul</code>/<code>onRej</code>, we get 2 ticks instead of 1.","m.new_content":{"body":"But because `resolve(thenable)` creates a new job for doing the `then.call(prom, onFul, onRej)` and the `then` internally creates a new job before calling `onFul`/`onRej`, we get 2 ticks instead of 1.","format":"org.matrix.custom.html","formatted_body":"But because <code>resolve(thenable)</code> creates a new job for doing the <code>then.call(prom, onFul, onRej)</code> and the <code>then</code> internally creates a new job before calling <code>onFul</code>/<code>onRej</code>, we get 2 ticks instead of 1.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"But because `resolve(thenable)` creates a new job for doing the `then.call(prom, onFul, onRej)` and the `then` internally creates a new job before calling `onFul`/`onRej`, we get 2 ticks instead of 1.","mimetype":"text/plain"},{"body":"But because <code>resolve(thenable)</code> creates a new job for doing the <code>then.call(prom, onFul, onRej)</code> and the <code>then</code> internally creates a new job before calling <code>onFul</code>/<code>onRej</code>, we get 2 ticks instead of 1.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$kCnssKYZZl4OqwPWC0Fp2uBgGeN0GpN2trgLO1sOr3Y","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * But because `resolve(thenable)` creates a new job for doing the `then.call(prom, onFul, onRej)` and the `then` internally creates a new job before calling `onFul`/`onRej`, we get 2 ticks instead of 1.","mimetype":"text/plain"},{"body":" * But because <code>resolve(thenable)</code> creates a new job for doing the <code>then.call(prom, onFul, onRej)</code> and the <code>then</code> internally creates a new job before calling <code>onFul</code>/<code>onRej</code>, we get 2 ticks instead of 1.","mimetype":"text/html"}]},"ts":1652125705757,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$UhQc8mckc6nuCxYbj54MkbJQq42bM0E6-FKMN6TBSH8"},
{"content":{"body":"It might be tricky to untangle this. `Promise.resolve()` should most likely not call `.then` in the same tick (It's already unfortunate it does a `[[Get]]` of the `constructor` and `then`). Maybe there is a way to not use a new callback job if we're already inside then callback job? I haven't thought this through yet.","format":"org.matrix.custom.html","formatted_body":"It might be tricky to untangle this. <code>Promise.resolve()</code> should most likely not call <code>.then</code> in the same tick (It's already unfortunate it does a <code>[[Get]]</code> of the <code>constructor</code> and <code>then</code>). Maybe there is a way to not use a new callback job if we're already inside then callback job? I haven't thought this through yet.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"It might be tricky to untangle this. `Promise.resolve()` should most likely not call `.then` in the same tick (It's already unfortunate it does a `[[Get]]` of the `constructor` and `then`). Maybe there is a way to not use a new callback job if we're already inside then callback job? I haven't thought this through yet.","mimetype":"text/plain"},{"body":"It might be tricky to untangle this. <code>Promise.resolve()</code> should most likely not call <code>.then</code> in the same tick (It's already unfortunate it does a <code>[[Get]]</code> of the <code>constructor</code> and <code>then</code>). Maybe there is a way to not use a new callback job if we're already inside then callback job? I haven't thought this through yet.","mimetype":"text/html"}]},"ts":1652126719891,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$xbH7j0u2uvasyfwIAfnPbhaIY8RxeqPjvt59zSIWxxk"},
{"content":{"body":"Are you thinking about throws?","msgtype":"m.text","org.matrix.msc1767.text":"Are you thinking about throws?"},"ts":1652127010351,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Oad46hL0sI7SaIu3jPLns8tKJQGN32bVxTDUqk9f5nk"},
{"content":{"body":"Note that `Promise.resolve` isn't part of A+, so we could diverge and do an tick before invoking the thenable's `then`","format":"org.matrix.custom.html","formatted_body":"Note that <code>Promise.resolve</code> isn't part of A+, so we could diverge and do an tick before invoking the thenable's <code>then</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Note that `Promise.resolve` isn't part of A+, so we could diverge and do an tick before invoking the thenable's `then`","mimetype":"text/plain"},{"body":"Note that <code>Promise.resolve</code> isn't part of A+, so we could diverge and do an tick before invoking the thenable's <code>then</code>","mimetype":"text/html"}]},"ts":1652127065912,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$RIXuCXoRBBAOB_u3NofIRQjrm1ogonwoJr3QQMLAMSE"},
{"content":{"body":"I'm wondering how you could test this though. The `.then` call would always happen when no user code is on the stack. Maybe the test could create a resolved promise and attach a fulfillment handler (as a \"next tick\" detection) before returning the test thenable, and ensure that the `.then` is called before the \"next tick\" ?","format":"org.matrix.custom.html","formatted_body":"I'm wondering how you could test this though. The <code>.then</code> call would always happen when no user code is on the stack. Maybe the test could create a resolved promise and attach a fulfillment handler (as a &quot;next tick&quot; detection) before returning the test thenable, and ensure that the <code>.then</code> is called before the &quot;next tick&quot; ?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I'm wondering how you could test this though. The `.then` call would always happen when no user code is on the stack. Maybe the test could create a resolved promise and attach a fulfillment handler (as a \"next tick\" detection) before returning the test thenable, and ensure that the `.then` is called before the \"next tick\" ?","mimetype":"text/plain"},{"body":"I'm wondering how you could test this though. The <code>.then</code> call would always happen when no user code is on the stack. Maybe the test could create a resolved promise and attach a fulfillment handler (as a &quot;next tick&quot; detection) before returning the test thenable, and ensure that the <code>.then</code> is called before the &quot;next tick&quot; ?","mimetype":"text/html"}]},"ts":1652127073452,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Y9MrX4DQhuV7PgTIdCzLNVHnCWeeiG2sqreWryxZysU"},
{"content":{"body":"It's easy, I think:\n```\nnew Promise(res => {\n  let sync = true;\n  res({\n    then(onFul) {\n      onFul(called);\n    }\n  });\n  sync = false;\n});\n```","format":"org.matrix.custom.html","formatted_body":"<p>It's easy, I think:</p>\n<pre><code>new Promise(res =&gt; {\n  let sync = true;\n  res({\n    then(onFul) {\n      onFul(called);\n    }\n  });\n  sync = false;\n});\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"It's easy, I think:\n```\nnew Promise(res => {\n  let sync = true;\n  res({\n    then(onFul) {\n      onFul(called);\n    }\n  });\n  sync = false;\n});\n```","mimetype":"text/plain"},{"body":"<p>It's easy, I think:</p>\n<pre><code>new Promise(res =&gt; {\n  let sync = true;\n  res({\n    then(onFul) {\n      onFul(called);\n    }\n  });\n  sync = false;\n});\n</code></pre>\n","mimetype":"text/html"}]},"ts":1652127271790,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$hkmi1agdBIYzC-G73jTOY3RYFRsrmHCVcmHcKJIzW4U"},
{"content":{"body":"ah right, the constructor calls the resolve step, silly me","msgtype":"m.text","org.matrix.msc1767.text":"ah right, the constructor calls the resolve step, silly me"},"ts":1652127307036,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$5q1EQzxyYhcc3YCDggM7KWDvtE5fZoYyzSv82ClJrVg"},
{"content":{"body":"Can you explain why `Promise.resolve(thenable)` shouldn't call `thenable.then` sync?","format":"org.matrix.custom.html","formatted_body":"Can you explain why <code>Promise.resolve(thenable)</code> shouldn't call <code>thenable.then</code> sync?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Can you explain why `Promise.resolve(thenable)` shouldn't call `thenable.then` sync?","mimetype":"text/plain"},{"body":"Can you explain why <code>Promise.resolve(thenable)</code> shouldn't call <code>thenable.then</code> sync?","mimetype":"text/html"}]},"ts":1652127360306,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$d3eu0DuzcJeTJr4xmEv_Pq3OAxY_7eSihbxFlMJrFK8"},
{"content":{"body":" * Can you explain why `Promise.resolve(thenable)` shouldn't call `thenable.then` sync?","format":"org.matrix.custom.html","formatted_body":" * Can you explain why <code>Promise.resolve(thenable)</code> shouldn't call <code>thenable.then</code> sync?","m.new_content":{"body":"Can you explain why `Promise.resolve(thenable)` shouldn't call `thenable.then` sync?","format":"org.matrix.custom.html","formatted_body":"Can you explain why <code>Promise.resolve(thenable)</code> shouldn't call <code>thenable.then</code> sync?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Can you explain why `Promise.resolve(thenable)` shouldn't call `thenable.then` sync?","mimetype":"text/plain"},{"body":"Can you explain why <code>Promise.resolve(thenable)</code> shouldn't call <code>thenable.then</code> sync?","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$d3eu0DuzcJeTJr4xmEv_Pq3OAxY_7eSihbxFlMJrFK8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Can you explain why `Promise.resolve(thenable)` shouldn't call `thenable.then` sync?","mimetype":"text/plain"},{"body":" * Can you explain why <code>Promise.resolve(thenable)</code> shouldn't call <code>thenable.then</code> sync?","mimetype":"text/html"}]},"ts":1652127379403,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$gWf7PKm8BfXVblIGsESvbGqsQCVZsE8IJnqfLLmMn0c"},
{"content":{"body":"It's just a non-obvious reentrancy hazard. Basically the only way to protect yourself from an evil promise is to do `Promise.resolve(() => thenable)`","format":"org.matrix.custom.html","formatted_body":"It's just a non-obvious reentrancy hazard. Basically the only way to protect yourself from an evil promise is to do <code>Promise.resolve(() =&gt; thenable)</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"It's just a non-obvious reentrancy hazard. Basically the only way to protect yourself from an evil promise is to do `Promise.resolve(() => thenable)`","mimetype":"text/plain"},{"body":"It's just a non-obvious reentrancy hazard. Basically the only way to protect yourself from an evil promise is to do <code>Promise.resolve(() =&gt; thenable)</code>","mimetype":"text/html"}]},"ts":1652127504675,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$13bZZXSLfhvnfWkSFwVvslQEbmrCWFD_H7yYfCS5lKs"},
{"content":{"body":"Promise A+ handles reentrancy","msgtype":"m.text","org.matrix.msc1767.text":"Promise A+ handles reentrancy"},"ts":1652127539227,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$wIIeNN1PXMjMtXIyeWedVvw4EyQkXjwe0XORLrN7ajA"},
{"content":{"body":"Which means you're always losing a tick when you don't know where a potential thenable is coming from.","msgtype":"m.text","org.matrix.msc1767.text":"Which means you're always losing a tick when you don't know where a potential thenable is coming from."},"ts":1652127569518,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$BGlaNuqYyvqXBf66yB5EA98Qq24G-IAlKaLYl4WccRA"},
{"content":{"body":"I'm talking about user code trying to protect itself from reentrancy induced by evil promises","msgtype":"m.text","org.matrix.msc1767.text":"I'm talking about user code trying to protect itself from reentrancy induced by evil promises"},"ts":1652127599591,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$OWpDrkhvFac-KHQ9OvuplsR9SN7-tQjv9sHJ9Jn1WTc"},
{"content":{"body":"The `onFul` and `onRej` passed to the thenable's `then` are already job deferred callbacks","format":"org.matrix.custom.html","formatted_body":"The <code>onFul</code> and <code>onRej</code> passed to the thenable's <code>then</code> are already job deferred callbacks","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The `onFul` and `onRej` passed to the thenable's `then` are already job deferred callbacks","mimetype":"text/plain"},{"body":"The <code>onFul</code> and <code>onRej</code> passed to the thenable's <code>then</code> are already job deferred callbacks","mimetype":"text/html"}]},"ts":1652127599592,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$USmMn8Y4SrD-UMechWmHtBNAJ06xm1cpIRCfDLlV8E4"},
{"content":{"body":"They can only be called once","msgtype":"m.text","org.matrix.msc1767.text":"They can only be called once"},"ts":1652127616677,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$GVn3iVCMJXQkY1MnRAT7ECjjyH9MqBMWCRRWA-BfQLA"},
{"content":{"body":"And if `then` throws, then it'll be caught and `onRej` will be called (if neither `onFul` nor `onRej` have already been called)","format":"org.matrix.custom.html","formatted_body":"And if <code>then</code> throws, then it'll be caught and <code>onRej</code> will be called (if neither <code>onFul</code> nor <code>onRej</code> have already been called)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"And if `then` throws, then it'll be caught and `onRej` will be called (if neither `onFul` nor `onRej` have already been called)","mimetype":"text/plain"},{"body":"And if <code>then</code> throws, then it'll be caught and <code>onRej</code> will be called (if neither <code>onFul</code> nor <code>onRej</code> have already been called)","mimetype":"text/html"}]},"ts":1652127642411,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$qynB7gJZ8jndsCCrga3HTfx-8mzk4PH52AV7cG8o21A"},
{"content":{"body":"Aye, we're not talking about the same thing.","msgtype":"m.text","org.matrix.msc1767.text":"Aye, we're not talking about the same thing."},"ts":1652127678763,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$5r-tCgn0T8XgZcJrgxbDqDP-gMS0kpeXU8YKt1kSCHE"},
{"content":{"body":"calling `fooResult.then()` can cause synchronous reentrancy in your code if you can't trust where `fooResult` comes from. And there is simply no way to brand check for a native promise without causing similar hazard (`Promise.resolve` will trigger `constructor` and `then` get logic)","format":"org.matrix.custom.html","formatted_body":"calling <code>fooResult.then()</code> can cause synchronous reentrancy in your code if you can't trust where <code>fooResult</code> comes from. And there is simply no way to brand check for a native promise without causing similar hazard (<code>Promise.resolve</code> will trigger <code>constructor</code> and <code>then</code> get logic)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"calling `fooResult.then()` can cause synchronous reentrancy in your code if you can't trust where `fooResult` comes from. And there is simply no way to brand check for a native promise without causing similar hazard (`Promise.resolve` will trigger `constructor` and `then` get logic)","mimetype":"text/plain"},{"body":"calling <code>fooResult.then()</code> can cause synchronous reentrancy in your code if you can't trust where <code>fooResult</code> comes from. And there is simply no way to brand check for a native promise without causing similar hazard (<code>Promise.resolve</code> will trigger <code>constructor</code> and <code>then</code> get logic)","mimetype":"text/html"}]},"ts":1652127884004,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$tfm08AMLCdM6N1hHYVe3cSI0BtPKqXaGUTQnCg0oD-0"},
{"content":{"body":"Sorry, I'm still not getting it","msgtype":"m.text","org.matrix.msc1767.text":"Sorry, I'm still not getting it"},"ts":1652127945402,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$9sQJL_KYbc7r1fhpoPh-YC3CpTQ4HVIqlpj3kM9wV8Y"},
{"content":{"body":"If you can't trust `fooResult`, then `Promise.resolve(fooResult)` would give you a trusted promise (and I assume you're already doing this because `fooResult` isn't trusted)","format":"org.matrix.custom.html","formatted_body":"If you can't trust <code>fooResult</code>, then <code>Promise.resolve(fooResult)</code> would give you a trusted promise (and I assume you're already doing this because <code>fooResult</code> isn't trusted)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"If you can't trust `fooResult`, then `Promise.resolve(fooResult)` would give you a trusted promise (and I assume you're already doing this because `fooResult` isn't trusted)","mimetype":"text/plain"},{"body":"If you can't trust <code>fooResult</code>, then <code>Promise.resolve(fooResult)</code> would give you a trusted promise (and I assume you're already doing this because <code>fooResult</code> isn't trusted)","mimetype":"text/html"}]},"ts":1652127995463,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$KDIZLlpd385eH_Nbw6hePANucPwsM1xN3cCcXo0oKU8"},
{"content":{"body":"So we haven't introduced a new tick?","msgtype":"m.text","org.matrix.msc1767.text":"So we haven't introduced a new tick?"},"ts":1652128021842,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$jjsyWFHtbSh9WSAyPUNSTx2mLcfIf1JxB7VLRdUcsF0"},
{"content":{"body":"I don't think code should be trying to protect itself from reentrancy induced by evil promises","msgtype":"m.text","org.matrix.msc1767.text":"I don't think code should be trying to protect itself from reentrancy induced by evil promises"},"ts":1652128022966,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$EQ76OpGBe7Oo6qT30W7VgSk8URDdKo89AXZWDafkkBw"},
{"content":{"body":"except in extremely unusual cases","msgtype":"m.text","org.matrix.msc1767.text":"except in extremely unusual cases"},"ts":1652128030275,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ZFJZNOaL2nDdw-jdiet5VxYQUm6OUQzCysnw0pNml6s"},
{"content":{"body":"`Promise.resolve({ get then() { doSomethingEvil(); return () => {}; } })` will call `doSomethingEvil` synchronously.","format":"org.matrix.custom.html","formatted_body":"<code>Promise.resolve({ get then() { doSomethingEvil(); return () =&gt; {}; } })</code> will call <code>doSomethingEvil</code> synchronously.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`Promise.resolve({ get then() { doSomethingEvil(); return () => {}; } })` will call `doSomethingEvil` synchronously.","mimetype":"text/plain"},{"body":"<code>Promise.resolve({ get then() { doSomethingEvil(); return () =&gt; {}; } })</code> will call <code>doSomethingEvil</code> synchronously.","mimetype":"text/html"}]},"ts":1652128108195,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$pnCD6eVb4uGLowUS95KbDQp8z_f_oWmJntXkSKAWXP8"},
{"content":{"body":"> <@bakkot:matrix.org> I don't think code should be trying to protect itself from reentrancy induced by evil promises\n\nDepends on what kind of code you're working on ;)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$EQ76OpGBe7Oo6qT30W7VgSk8URDdKo89AXZWDafkkBw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>I don&#39;t think code should be trying to protect itself from reentrancy induced by evil promises</blockquote></mx-reply>Depends on what kind of code you're working on ;)","m.relates_to":{"m.in_reply_to":{"event_id":"$EQ76OpGBe7Oo6qT30W7VgSk8URDdKo89AXZWDafkkBw"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@bakkot:matrix.org> I don't think code should be trying to protect itself from reentrancy induced by evil promises\n\nDepends on what kind of code you're working on ;)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$EQ76OpGBe7Oo6qT30W7VgSk8URDdKo89AXZWDafkkBw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>I don&#39;t think code should be trying to protect itself from reentrancy induced by evil promises</blockquote></mx-reply>Depends on what kind of code you're working on ;)","mimetype":"text/html"}]},"ts":1652128132969,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$C-YRo1yRFFJWsvcSS2ffaQja4TJLpSExpCEHUVlzKvg"},
{"content":{"body":"> except in extremely unusual cases","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>except in extremely unusual cases</p>\n</blockquote>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> except in extremely unusual cases","mimetype":"text/plain"},{"body":"<blockquote>\n<p>except in extremely unusual cases</p>\n</blockquote>\n","mimetype":"text/html"}]},"ts":1652128147755,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$P4_3d5byNxt6o6Nf39zmjT-KHfwl-IcsbL8YuuGZzVs"},
{"content":{"body":"Given `get then() { doSomethingEvil() }`, is sync calling `then() { doSomethingEvil() }` something we need to protect against?","format":"org.matrix.custom.html","formatted_body":"Given <code>get then() { doSomethingEvil() }</code>, is sync calling <code>then() { doSomethingEvil() }</code> something we need to protect against?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Given `get then() { doSomethingEvil() }`, is sync calling `then() { doSomethingEvil() }` something we need to protect against?","mimetype":"text/plain"},{"body":"Given <code>get then() { doSomethingEvil() }</code>, is sync calling <code>then() { doSomethingEvil() }</code> something we need to protect against?","mimetype":"text/html"}]},"ts":1652128220826,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$qb9-VgW7WtOqkRUFYIJe9GajqvqDGkZvHvB2ySbM1jU"},
{"content":{"body":"Anyway, we're off topic for Justin's topic. I just wish we had a way to brand check native promises so that something like `brandCheck(p) && Reflect.getPrototypeOf(p) === Promise.prototype && !Reflect.getOwnPropertyDescriptor(p)` would be sufficient to know I can safely call `p.then`","format":"org.matrix.custom.html","formatted_body":"Anyway, we're off topic for Justin's topic. I just wish we had a way to brand check native promises so that something like <code>brandCheck(p) &amp;&amp; Reflect.getPrototypeOf(p) === Promise.prototype &amp;&amp; !Reflect.getOwnPropertyDescriptor(p)</code> would be sufficient to know I can safely call <code>p.then</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Anyway, we're off topic for Justin's topic. I just wish we had a way to brand check native promises so that something like `brandCheck(p) && Reflect.getPrototypeOf(p) === Promise.prototype && !Reflect.getOwnPropertyDescriptor(p)` would be sufficient to know I can safely call `p.then`","mimetype":"text/plain"},{"body":"Anyway, we're off topic for Justin's topic. I just wish we had a way to brand check native promises so that something like <code>brandCheck(p) &amp;&amp; Reflect.getPrototypeOf(p) === Promise.prototype &amp;&amp; !Reflect.getOwnPropertyDescriptor(p)</code> would be sufficient to know I can safely call <code>p.then</code>","mimetype":"text/html"}]},"ts":1652128338674,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$vFjnbRZCBb1aoNRlEk6mmLBjMEJO7YY1ZiCINg777kk"},
{"content":{"body":"(given that `Promise.prototype` is frozen of course)","format":"org.matrix.custom.html","formatted_body":"(given that <code>Promise.prototype</code> is frozen of course)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"(given that `Promise.prototype` is frozen of course)","mimetype":"text/plain"},{"body":"(given that <code>Promise.prototype</code> is frozen of course)","mimetype":"text/html"}]},"ts":1652128392047,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$sZKfLsmj5AltCxsFaEa9oTF58LJvzTybuY7kmf7QF-w"},
{"content":{"body":"yes, it is, because `Promise.resolve({ then: class {} })` shouldn't throw, it should reject","format":"org.matrix.custom.html","formatted_body":"yes, it is, because <code>Promise.resolve({ then: class {} })</code> shouldn't throw, it should reject","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"yes, it is, because `Promise.resolve({ then: class {} })` shouldn't throw, it should reject","mimetype":"text/plain"},{"body":"yes, it is, because <code>Promise.resolve({ then: class {} })</code> shouldn't throw, it should reject","mimetype":"text/html"}]},"ts":1652130250499,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$zMn-QctKwTKg7z_V6r6WVHf4OTfqUGXT-qgayLEG15A"},
{"content":{"body":"It would still reject with the correct A+ behavior","msgtype":"m.text","org.matrix.msc1767.text":"It would still reject with the correct A+ behavior"},"ts":1652130459330,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$MdKRoQNfOU8lXtDTUO6YMMsSpQq0tyFZo2fmcjPchAo"},
{"content":{"body":"Throws are caught","msgtype":"m.text","org.matrix.msc1767.text":"Throws are caught"},"ts":1652130470731,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$7RogF_uvUXhrpquUzys331NRNFRbaV6kyBJJmuH_NwA"},
{"content":{"body":"i'd love a stamp on https://github.com/tc39/notes/pull/197 if someone has a sec","msgtype":"m.text","org.matrix.msc1767.text":"i'd love a stamp on https://github.com/tc39/notes/pull/197 if someone has a sec"},"ts":1652137006927,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$ukCO_ePnMk7L_txbHkFOhLbou5kNBvcwc8sv1CQ8KDU"},
{"content":{"body":"Rather than adding a symbol to the module, could we allow a user to add a built-in symbol to a function they export named `then` that would indicate it shouldn't be used for Promise fulfillment? Non-native promises might not understand it, but it would still work for imports. ","format":"org.matrix.custom.html","formatted_body":"Rather than adding a symbol to the module, could we allow a user to add a built-in symbol to a function they export named <code>then</code> that would indicate it shouldn't be used for Promise fulfillment? Non-native promises might not understand it, but it would still work for imports.","msgtype":"m.text"},"ts":1652137654240,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KKPHWRFcXWWVJGuJDiXggSnssyuN9O3Q6QYeF5k86JE"}
]