[
{"content":{"body":"> <@bakkot:matrix.org> honestly I think people may have just not noticed at the time waitAsync was being added\n\nI think you're right, it might be one of those things that slipped through.\n\nFirst, my understanding is that `waitAsync` is still at Stage 3. And while `Atomics` is not normative optional, it relies on `SharedArrayBuffer`, for which the constructor being added to the global object is currently normative optional. That means from an ECMA262 point of view, even when `waitAsync` reaches stage 4, the host is not obligated to offer a clock API, as it can simply deny SAB.\n\nNow I'd go even further, and say there is a way to reconcile a clock API with the requirement some environments have to not allow time measurement of any sort. Let's assume a clock API is modeled like `waitAsync`, i.e. the host resolves a promise after a certain time has elapsed. The promise job queue works by requiring the host to eventually execute promise jobs in the same order as they were enqueued. There is no requirement that the host must instantly make forward progress in processing the promise queue. What a host (or virtualization of one) can do is stop processing any more promise jobs until the wait time has elapsed, then enqueue the resolution of the clock promise. As long as the program doesn't have another way to observe the elapsing of time, that behavior is entirely within spec.\n\nThat means that without a `Date` or other API which reveals elapsing time, then a `Promise.timeout = () => Promise.resolve().then(() => {})` would be spec compliant (modulo ordering of multiple `Promise.timeout` calls with different timeout values within the same synchronous execution, or infinite timeouts). You can even fake the value of `Date` based on the clock API (e.g. with all code executing \"instantly\" until it reaches a wait).\n\nNow of course that doesn't mean all code using a clock API would be compatible with such behavior, as some would expect consistent forward progress to continue during the wait time. I'd argue however such code would be prone to async race conditions.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$6rAUIsdMSHPgwOP9M3T9TSWLCWbwYhM06bxrtM4vBjQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>honestly I think people may have just not noticed at the time waitAsync was being added</blockquote></mx-reply><p>I think you're right, it might be one of those things that slipped through.</p>\n<p>First, my understanding is that <code>waitAsync</code> is still at Stage 3. And while <code>Atomics</code> is not normative optional, it relies on <code>SharedArrayBuffer</code>, for which the constructor being added to the global object is currently normative optional. That means from an ECMA262 point of view, even when <code>waitAsync</code> reaches stage 4, the host is not obligated to offer a clock API, as it can simply deny SAB.</p>\n<p>Now I'd go even further, and say there is a way to reconcile a clock API with the requirement some environments have to not allow time measurement of any sort. Let's assume a clock API is modeled like <code>waitAsync</code>, i.e. the host resolves a promise after a certain time has elapsed. The promise job queue works by requiring the host to eventually execute promise jobs in the same order as they were enqueued. There is no requirement that the host must instantly make forward progress in processing the promise queue. What a host (or virtualization of one) can do is stop processing any more promise jobs until the wait time has elapsed, then enqueue the resolution of the clock promise. As long as the program doesn't have another way to observe the elapsing of time, that behavior is entirely within spec.</p>\n<p>That means that without a <code>Date</code> or other API which reveals elapsing time, then a <code>Promise.timeout = () =&gt; Promise.resolve().then(() =&gt; {})</code> would be spec compliant (modulo ordering of multiple <code>Promise.timeout</code> calls with different timeout values within the same synchronous execution, or infinite timeouts). You can even fake the value of <code>Date</code> based on the clock API (e.g. with all code executing &quot;instantly&quot; until it reaches a wait).</p>\n<p>Now of course that doesn't mean all code using a clock API would be compatible with such behavior, as some would expect consistent forward progress to continue during the wait time. I'd argue however such code would be prone to async race conditions.</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$6rAUIsdMSHPgwOP9M3T9TSWLCWbwYhM06bxrtM4vBjQ"}},"msgtype":"m.text"},"ts":1639449095347,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$R3675lExxZoS5jCGhprlOn7EX-5norn8qUxMgoKF0ow"},
{"content":{"body":"And of course some programs would expect the Web behavior of `setTimeout` which drains the promise job queue before processing I/O jobs (which clocks are)","format":"org.matrix.custom.html","formatted_body":"And of course some programs would expect the Web behavior of <code>setTimeout</code> which drains the promise job queue before processing I/O jobs (which clocks are)","msgtype":"m.text"},"ts":1639449568019,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YsUzfvQEs9iLNUzX7WioYtq9ryZRaObIoGAJCnOzYV8"}
]