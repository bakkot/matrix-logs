[
{"content":{"body":"> <@bakkot:matrix.org> honestly I think people may have just not noticed at the time waitAsync was being added\n\nI think you're right, it might be one of those things that slipped through.\n\nFirst, my understanding is that `waitAsync` is still at Stage 3. And while `Atomics` is not normative optional, it relies on `SharedArrayBuffer`, for which the constructor being added to the global object is currently normative optional. That means from an ECMA262 point of view, even when `waitAsync` reaches stage 4, the host is not obligated to offer a clock API, as it can simply deny SAB.\n\nNow I'd go even further, and say there is a way to reconcile a clock API with the requirement some environments have to not allow time measurement of any sort. Let's assume a clock API is modeled like `waitAsync`, i.e. the host resolves a promise after a certain time has elapsed. The promise job queue works by requiring the host to eventually execute promise jobs in the same order as they were enqueued. There is no requirement that the host must instantly make forward progress in processing the promise queue. What a host (or virtualization of one) can do is stop processing any more promise jobs until the wait time has elapsed, then enqueue the resolution of the clock promise. As long as the program doesn't have another way to observe the elapsing of time, that behavior is entirely within spec.\n\nThat means that without a `Date` or other API which reveals elapsing time, then a `Promise.timeout = () => Promise.resolve().then(() => {})` would be spec compliant (modulo ordering of multiple `Promise.timeout` calls with different timeout values within the same synchronous execution, or infinite timeouts). You can even fake the value of `Date` based on the clock API (e.g. with all code executing \"instantly\" until it reaches a wait).\n\nNow of course that doesn't mean all code using a clock API would be compatible with such behavior, as some would expect consistent forward progress to continue during the wait time. I'd argue however such code would be prone to async race conditions.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$6rAUIsdMSHPgwOP9M3T9TSWLCWbwYhM06bxrtM4vBjQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>honestly I think people may have just not noticed at the time waitAsync was being added</blockquote></mx-reply><p>I think you're right, it might be one of those things that slipped through.</p>\n<p>First, my understanding is that <code>waitAsync</code> is still at Stage 3. And while <code>Atomics</code> is not normative optional, it relies on <code>SharedArrayBuffer</code>, for which the constructor being added to the global object is currently normative optional. That means from an ECMA262 point of view, even when <code>waitAsync</code> reaches stage 4, the host is not obligated to offer a clock API, as it can simply deny SAB.</p>\n<p>Now I'd go even further, and say there is a way to reconcile a clock API with the requirement some environments have to not allow time measurement of any sort. Let's assume a clock API is modeled like <code>waitAsync</code>, i.e. the host resolves a promise after a certain time has elapsed. The promise job queue works by requiring the host to eventually execute promise jobs in the same order as they were enqueued. There is no requirement that the host must instantly make forward progress in processing the promise queue. What a host (or virtualization of one) can do is stop processing any more promise jobs until the wait time has elapsed, then enqueue the resolution of the clock promise. As long as the program doesn't have another way to observe the elapsing of time, that behavior is entirely within spec.</p>\n<p>That means that without a <code>Date</code> or other API which reveals elapsing time, then a <code>Promise.timeout = () =&gt; Promise.resolve().then(() =&gt; {})</code> would be spec compliant (modulo ordering of multiple <code>Promise.timeout</code> calls with different timeout values within the same synchronous execution, or infinite timeouts). You can even fake the value of <code>Date</code> based on the clock API (e.g. with all code executing &quot;instantly&quot; until it reaches a wait).</p>\n<p>Now of course that doesn't mean all code using a clock API would be compatible with such behavior, as some would expect consistent forward progress to continue during the wait time. I'd argue however such code would be prone to async race conditions.</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$6rAUIsdMSHPgwOP9M3T9TSWLCWbwYhM06bxrtM4vBjQ"}},"msgtype":"m.text"},"ts":1639449095347,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$R3675lExxZoS5jCGhprlOn7EX-5norn8qUxMgoKF0ow"},
{"content":{"body":"And of course some programs would expect the Web behavior of `setTimeout` which drains the promise job queue before processing I/O jobs (which clocks are)","format":"org.matrix.custom.html","formatted_body":"And of course some programs would expect the Web behavior of <code>setTimeout</code> which drains the promise job queue before processing I/O jobs (which clocks are)","msgtype":"m.text"},"ts":1639449568019,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YsUzfvQEs9iLNUzX7WioYtq9ryZRaObIoGAJCnOzYV8"},
{"content":{"body":"Mathieu Hofman: `Atomics` relies on SABs only for `wait` and `waitAsync`. the rest was made to work with ABs (not that there's a way to observe that it's atomic with a single thread of execution)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>: <code>Atomics</code> relies on SABs only for <code>wait</code> and <code>waitAsync</code>. the rest was made to work with ABs (not that there's a way to observe that it's atomic with a single thread of execution)","msgtype":"m.text"},"ts":1639452489868,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$4zDM-0vrkfHZ4SmDWaXcXyAJMOvfKHxFAq83rrTU3Kg"},
{"content":{"body":"but your point still stands for `wait` that even if it isn't explicitly marked as normative optional, the fact that SABs can be denied makes it so in practice","format":"org.matrix.custom.html","formatted_body":"but your point still stands for <code>wait</code> that even if it isn't explicitly marked as normative optional, the fact that SABs can be denied makes it so in practice","msgtype":"m.text"},"ts":1639452519448,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$i92lnoMt17lsVxvsFmnA0oNnaLG72i55wkW3SHJvX4k"},
{"content":{"body":"actually, i take that back","msgtype":"m.text"},"ts":1639452557002,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$WD52vbBjsnI02Atm8mkhqcohK0xtDCjXBawZ9s65_1s"},
{"content":{"body":"there is a way to observe something is atomic with a single thread of execution, if you count looking at compiled code output in your model of observability, to see that there's never any unfriendly reorderings","msgtype":"m.text"},"ts":1639452586599,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$YFuxGpVkBhttVKZgvbZLIPQwbfcAvVbLEuNTO8S1zRM"},
{"content":{"body":"> looking at compiled code output in your model of observability\n\nMy model of observability is the program at runtime, so I don't think that counts?","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>looking at compiled code output in your model of observability</p>\n</blockquote>\n<p>My model of observability is the program at runtime, so I don't think that counts?</p>\n","msgtype":"m.text"},"ts":1639452665155,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$lVOw1wsKiRC11V_xp8NOPfcs8NfqUBiMAjNX_8KKo_0"},
{"content":{"body":" * > looking at compiled code output in your model of observability\n\nMy model of observability is the program at runtime, so I don't think that counts?","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>looking at compiled code output in your model of observability</p>\n</blockquote>\n<p>My model of observability is the program at runtime, so I don't think that counts?</p>\n","m.new_content":{"body":"> looking at compiled code output in your model of observability\n\nMy model of observability is the program at runtime, so I don't think that counts?","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>looking at compiled code output in your model of observability</p>\n</blockquote>\n<p>My model of observability is the program at runtime, so I don't think that counts?</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$lVOw1wsKiRC11V_xp8NOPfcs8NfqUBiMAjNX_8KKo_0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639452671774,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$yQapw8dov7FYVlDso4_JNh3-WsL8Ro6KChNDcRHZ4Wc"},
{"content":{"body":"anyway i'm missing the broader context","msgtype":"m.text"},"ts":1639452784386,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$98fUxCTWbYK0bv5UeaVs7QGdLeK96JanqyT1l-TSnaI"},
{"content":{"body":"you want to add a clock API? or just thinking through the exercise?","msgtype":"m.text"},"ts":1639452794231,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$hAskxoEsvYX7G2Ks2L6EZYke1mhSnhHGdhbN3dAHb5Q"},
{"content":{"body":"Thinking through the exercise since people were asking why not if there is `waitAsync`. Also justifying why the presence of `waitAsync` is not such a problem","format":"org.matrix.custom.html","formatted_body":"Thinking through the exercise since people were asking why not if there is <code>waitAsync</code>. Also justifying why the presence of <code>waitAsync</code> is not such a problem","msgtype":"m.text"},"ts":1639452859037,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$82FjfKpKjT448qh0CxrALm-VSoNOIWLHV3_t9PuWzQc"},
{"content":{"body":"it's not a problem for the web platform at least because the timeout value is pretty detached from wall clock time in when the promise handler gets run","msgtype":"m.text"},"ts":1639453016450,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zypPLZ-DpEw68QYyG6bz7W52COpzE7lieEq3G2jTplQ"},
{"content":{"body":"the extent to which it is it not a problem for mark is, i suspect, along the lines of what kevin said :)","msgtype":"m.text"},"ts":1639453040372,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$8WRsfCCQJdb9f1zQAkd2hz-KycA-k1rM2pMG_2q4h9o"},
{"content":{"body":" * the extent to which it is it not a problem for mark is, i suspect, along the lines of what kevin said :)","m.new_content":{"body":"the extent to which it is it not a problem for mark is, i suspect, along the lines of what kevin said :)","msgtype":"m.text"},"m.relates_to":{"event_id":"$8WRsfCCQJdb9f1zQAkd2hz-KycA-k1rM2pMG_2q4h9o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639453049854,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$odD8Frm2WZJQy31yMUQg0DU92hR5omWcA6LeiJj43dA"},
{"content":{"body":"Right, and I'm arguing that you can, according to the way job enqueuing is specified, offer a clock API to \"schedule\" future promise resolutions that does not in fact allow the program to observe time passing or how complex the code executed in-between was, as long as there is not an independent way to observe time passing.","msgtype":"m.text"},"ts":1639453497543,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Lch_JG85Nt26Jzsi-qeofxs-15dPOTXb0lGLOssYZfQ"},
{"content":{"body":"i'm inclined to agree at first blush","msgtype":"m.text"},"ts":1639453583214,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$L7ckElB7RRcCQ70cN8Pf1mua5SSUAf-UjeZEluo7AiA"},
{"content":{"body":"TC39 plenary meeting begins in two hours time.  Details are [here.](https://github.com/tc39/Reflector/issues/402)","format":"org.matrix.custom.html","formatted_body":"TC39 plenary meeting begins in two hours time.  Details are <a href=\"https://github.com/tc39/Reflector/issues/402\">here.</a>","msgtype":"m.text"},"ts":1639497435316,"senderName":"Rob Palmer","senderId":"@robpalme:matrix.org","id":"$QGAZ-Uw2AuvNKwbXIQMmr_ZYMB5OQuVqqYYjjp3ETKE"},
{"content":{"body":"Aki: Rob Palmer bterlson hey folks -- i have someone who would like to be at the regexp set notation presentation but... they can't make it from 11 - 12... which is exactly when mattias wants to present","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@akirose:matrix.org\">Aki</a>: <a href=\"https://matrix.to/#/@robpalme:matrix.org\">Rob Palmer</a> <a href=\"https://matrix.to/#/@bterlson:matrix.org\">bterlson</a> hey folks -- i have someone who would like to be at the regexp set notation presentation but... they can't make it from 11 - 12... which is exactly when mattias wants to present","msgtype":"m.text"},"ts":1639500671455,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$rjyvr4GaPA_AiuIuux4pfcBJZUkhYTmW6vfxUXO1-6E"},
{"content":{"body":"is there a chance (i know this is slim) to do it during lunch?","msgtype":"m.text"},"ts":1639500682070,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$Kdr6AWci4VboVO3mNV2juC42bdsL4ED6o2HVfSLM_yM"}
]