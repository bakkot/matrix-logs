[
{"content":{"body":"> <@shuyuguo:matrix.org> the disagreement i see is the motivation is thus ergonomics, which comes down to feelings, which we disagree on\n\nthere are more benefits than ergonomics, but that is one of the benefits.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$NjNrMYKbSJQ3NeqfA3JO0-xfthB52QL5vmiVsdqL1tg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>the disagreement i see is the motivation is thus ergonomics, which comes down to feelings, which we disagree on</blockquote></mx-reply>there are more benefits than ergonomics, but that is one of the benefits.","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$NjNrMYKbSJQ3NeqfA3JO0-xfthB52QL5vmiVsdqL1tg"}},"msgtype":"m.text"},"ts":1707436876283,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1JOAuNIwgtxbdz5OJhjA50lgdpKBdtckpt9vbyZ9teM"},
{"content":{"body":"> <@rbuckton:matrix.org> there are more benefits than ergonomics, but that is one of the benefits.\n\nmy universe of benefits is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$1JOAuNIwgtxbdz5OJhjA50lgdpKBdtckpt9vbyZ9teM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>there are more benefits than ergonomics, but that is one of the benefits.</blockquote></mx-reply>my universe of benefits is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$1JOAuNIwgtxbdz5OJhjA50lgdpKBdtckpt9vbyZ9teM"}},"msgtype":"m.text"},"ts":1707436935454,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$pq1lBx4D1q09o0ebAyZSwH9S4jlpz-nMrrXsixil-00"},
{"content":{"body":"or am i misunderstanding","m.mentions":{},"msgtype":"m.text"},"ts":1707436940589,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Io-Jgsp9QrkTl0FlTZ40XXy18Gm21Zl-4K6rZ9cUEtU"},
{"content":{"body":"there's performance but i thought we discarded that one","m.mentions":{},"msgtype":"m.text"},"ts":1707436959176,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$U3Bhyfmc7qoD9MbFKSXlCip50915UA1ExD4AEbwyJpk"},
{"content":{"body":"> <@rbuckton:matrix.org> there are more benefits than ergonomics, but that is one of the benefits.\n\n * my universe of benefits for that proposal is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$1JOAuNIwgtxbdz5OJhjA50lgdpKBdtckpt9vbyZ9teM?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>there are more benefits than ergonomics, but that is one of the benefits.</blockquote></mx-reply> * my universe of benefits for that proposal is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?","m.mentions":{},"m.new_content":{"body":"my universe of benefits for that proposal is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?","format":"org.matrix.custom.html","formatted_body":"my universe of benefits for that proposal is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$pq1lBx4D1q09o0ebAyZSwH9S4jlpz-nMrrXsixil-00","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1707436969910,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xVb0_oo8LH-9ZnNVXYZTp8D7Wf70UJzijYmAv7N_u-Y"},
{"content":{"body":"> <@shuyuguo:matrix.org> my universe of benefits for that proposal is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?\n\nwhat is Temporal?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$pq1lBx4D1q09o0ebAyZSwH9S4jlpz-nMrrXsixil-00?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>my universe of benefits for that proposal is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?</blockquote></mx-reply>what is Temporal?","m.mentions":{"user_ids":["@shuyuguo:matrix.org","@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$pq1lBx4D1q09o0ebAyZSwH9S4jlpz-nMrrXsixil-00"}},"msgtype":"m.text"},"ts":1707437014914,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$qt7S0NnH_lnZs5yPoLBkxlMmmFhLM4ldFDAMJY0idmc"},
{"content":{"body":"Temporal is a mix of new capabilities and ergonomics improvements","m.mentions":{},"msgtype":"m.text"},"ts":1707437037859,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ncDT5qd1Y48to5lQw_sMYnGjOCgk3_n5WeHdTY0AUBc"},
{"content":{"body":"i consider Temporal to be like 80% ergonomics","m.mentions":{},"msgtype":"m.text"},"ts":1707437053480,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$M7ZuFiIw8Fp_UWMiPslbLm2o25kNlZhOEkVvCcYPhjA"},
{"content":{"body":"20% performance in the \"we are going to take over distribution\" sense","m.mentions":{},"msgtype":"m.text"},"ts":1707437069839,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Xu9ZDOFiQBlV0jZ8InKRThjc8P-H1T471CYQITejEcE"},
{"content":{"body":"Does “reducing ecosystem fragmentation” fall under ergonomics?","msgtype":"m.text"},"ts":1707437126839,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$KONZ2X9ql-TbeK8zT6Jjb_kFUgbq0Rmt-lfMoSB_MmE"},
{"content":{"body":"* Re: Temporal, does “reducing ecosystem fragmentation” fall under ergonomics? Just wondering. ","format":"org.matrix.custom.html","formatted_body":"* Re: Temporal, does “reducing ecosystem fragmentation” fall under ergonomics? Just wondering.","m.new_content":{"body":"Re: Temporal, does “reducing ecosystem fragmentation” fall under ergonomics? Just wondering. ","format":"org.matrix.custom.html","formatted_body":"Re: Temporal, does “reducing ecosystem fragmentation” fall under ergonomics? Just wondering.","msgtype":"m.text"},"m.relates_to":{"event_id":"$KONZ2X9ql-TbeK8zT6Jjb_kFUgbq0Rmt-lfMoSB_MmE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1707437154806,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$RMoPjTPvFYnmbVVcIUUljb1SF5Ux-uG-o5e7OJb7orc"},
{"content":{"body":"> <@jschoi:matrix.org> Does “reducing ecosystem fragmentation” fall under ergonomics?\n\nHow is the ecosystem currently fragmented for function decorators?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$KONZ2X9ql-TbeK8zT6Jjb_kFUgbq0Rmt-lfMoSB_MmE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jschoi:matrix.org\">@jschoi:matrix.org</a><br>Does “reducing ecosystem fragmentation” fall under ergonomics?</blockquote></mx-reply>How is the ecosystem currently fragmented for function decorators?","m.mentions":{"user_ids":["@jschoi:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$KONZ2X9ql-TbeK8zT6Jjb_kFUgbq0Rmt-lfMoSB_MmE"}},"msgtype":"m.text"},"ts":1707437158549,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Dw-eKVCZipoyOMQ6C8A3iStbgpvlHFtaeo9etJj4B24"},
{"content":{"body":"> <@bakkot:matrix.org> we should probably have not included class decorators, yes; at one point they had additional expressivity and so I was ok with that on those grounds\n\nThis presumes class decorators have no value aside from somehow aggregating class element decorators, but that isn't the case. The registration semantics are critical for use cases like custom elements and packages like `lit`. There are also useful cases like `@Callable`, amongst others. Manual function application is terribly unergonomic for class declarations, and I think its terribly unergonomic for functions as well. Libraries like material-ui use function \"decorators\" in this way, and it makes the code far harder to reason over and pick apart.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$HoBWL4F7cIyKbl99ffeUNgb6w05-UkmAT25VKOjumKQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>we should probably have not included class decorators, yes; at one point they had additional expressivity and so I was ok with that on those grounds</blockquote></mx-reply>This presumes class decorators have no value aside from somehow aggregating class element decorators, but that isn't the case. The registration semantics are critical for use cases like custom elements and packages like <code>lit</code>. There are also useful cases like <code>@Callable</code>, amongst others. Manual function application is terribly unergonomic for class declarations, and I think its terribly unergonomic for functions as well. Libraries like material-ui use function \"decorators\" in this way, and it makes the code far harder to reason over and pick apart.","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$HoBWL4F7cIyKbl99ffeUNgb6w05-UkmAT25VKOjumKQ"}},"msgtype":"m.text"},"ts":1707437172133,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5k0E8dOFmQNorIKUxlWD_OMu6Y7Jppixqyo_bGaPUBo"},
{"content":{"body":"Sorry, was talking about Temporal. ","format":"org.matrix.custom.html","formatted_body":"Sorry, was talking about Temporal.","msgtype":"m.text"},"ts":1707437172292,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$SLsDO2v2BzNguFuV4ifL1z-ksaFFyhI2gA4KvC13Wpw"},
{"content":{"body":"> <@rbuckton:matrix.org> This presumes class decorators have no value aside from somehow aggregating class element decorators, but that isn't the case. The registration semantics are critical for use cases like custom elements and packages like `lit`. There are also useful cases like `@Callable`, amongst others. Manual function application is terribly unergonomic for class declarations, and I think its terribly unergonomic for functions as well. Libraries like material-ui use function \"decorators\" in this way, and it makes the code far harder to reason over and pick apart.\n\nit does not presume they have no value. the claim is that the benefits are not worth the cost.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$5k0E8dOFmQNorIKUxlWD_OMu6Y7Jppixqyo_bGaPUBo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>This presumes class decorators have no value aside from somehow aggregating class element decorators, but that isn't the case. The registration semantics are critical for use cases like custom elements and packages like <code>lit</code>. There are also useful cases like <code>@Callable</code>, amongst others. Manual function application is terribly unergonomic for class declarations, and I think its terribly unergonomic for functions as well. Libraries like material-ui use function \"decorators\" in this way, and it makes the code far harder to reason over and pick apart.</blockquote></mx-reply>it does not presume they have no value. the claim is that the benefits are not worth the cost.","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$5k0E8dOFmQNorIKUxlWD_OMu6Y7Jppixqyo_bGaPUBo"}},"msgtype":"m.text"},"ts":1707437239876,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$lKrxiD0TbJLSolIVl52m-sQNXJT9L1z5qaOYmoFxA38"},
{"content":{"body":"I like reverse pipes, and they were suggested as an area of exploration back in the early pipeline days. That said, I don't think that is readable in the more common cases, as examples like these often function on unary functions, but that's rarely the predominant use case. What you would actually see is something like:\n\n```js\nconst index =\n  route(\"/api/foo\")(^^) <|\n  authorized(\"Administrator\")(^^) <|\n  originCheck(^^) <|\n  rateLimited(5, 1)(^^) <|\n  function () {};\n```\nYou most likely need to use double invocation here if you want to reuse existing decorators (despite those decorators needing to be even more defensive around the missing 2nd argument).\n","format":"org.matrix.custom.html","formatted_body":"<p>I like reverse pipes, and they were suggested as an area of exploration back in the early pipeline days. That said, I don't think that is readable in the more common cases, as examples like these often function on unary functions, but that's rarely the predominant use case. What you would actually see is something like:</p>\n<pre><code class=\"language-js\">const index =\n  route(\"/api/foo\")(^^) &lt;|\n  authorized(\"Administrator\")(^^) &lt;|\n  originCheck(^^) &lt;|\n  rateLimited(5, 1)(^^) &lt;|\n  function () {};\n</code></pre>\n<p>You most likely need to use double invocation here if you want to reuse existing decorators (despite those decorators needing to be even more defensive around the missing 2nd argument).</p>\n","m.mentions":{},"m.relates_to":{"event_id":"$JP6Jju5invA57mppdr-qhfg6QL0-DPiKPJAL5Jj_Jm4","is_falling_back":true,"m.in_reply_to":{"event_id":"$TqpK7uMkpB-sGgwIaDH0yoOPpRqxY30e8uwxi-VCfHI"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707437438654,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0kn_o9nRnDOYLkASHE9huBaBkvF7WFLkd8d7G0Ofd7I"},
{"content":{"body":" * I like reverse pipes, and they were suggested as an area of exploration back in the early pipeline days. That said, I don't think that is readable in the more common cases, as examples like these often focus on unary functions, but that's rarely the predominant use case. What you would actually see is something like:\n\n```js\nconst index =\n  route(\"/api/foo\")(^^) <|\n  authorized(\"Administrator\")(^^) <|\n  originCheck(^^) <|\n  rateLimited(5, 1)(^^) <|\n  function () {};\n```\n\nYou most likely need to use double invocation here if you want to reuse existing decorators (despite those decorators needing to be even more defensive around the missing 2nd argument).","format":"org.matrix.custom.html","formatted_body":" * <p>I like reverse pipes, and they were suggested as an area of exploration back in the early pipeline days. That said, I don't think that is readable in the more common cases, as examples like these often focus on unary functions, but that's rarely the predominant use case. What you would actually see is something like:</p>\n<pre><code class=\"language-js\">const index =\n  route(\"/api/foo\")(^^) &lt;|\n  authorized(\"Administrator\")(^^) &lt;|\n  originCheck(^^) &lt;|\n  rateLimited(5, 1)(^^) &lt;|\n  function () {};\n</code></pre>\n<p>You most likely need to use double invocation here if you want to reuse existing decorators (despite those decorators needing to be even more defensive around the missing 2nd argument).</p>\n","m.mentions":{"user_ids":["@michaelficarra:matrix.org"]},"m.new_content":{"body":"I like reverse pipes, and they were suggested as an area of exploration back in the early pipeline days. That said, I don't think that is readable in the more common cases, as examples like these often focus on unary functions, but that's rarely the predominant use case. What you would actually see is something like:\n\n```js\nconst index =\n  route(\"/api/foo\")(^^) <|\n  authorized(\"Administrator\")(^^) <|\n  originCheck(^^) <|\n  rateLimited(5, 1)(^^) <|\n  function () {};\n```\n\nYou most likely need to use double invocation here if you want to reuse existing decorators (despite those decorators needing to be even more defensive around the missing 2nd argument).","format":"org.matrix.custom.html","formatted_body":"<p>I like reverse pipes, and they were suggested as an area of exploration back in the early pipeline days. That said, I don't think that is readable in the more common cases, as examples like these often focus on unary functions, but that's rarely the predominant use case. What you would actually see is something like:</p>\n<pre><code class=\"language-js\">const index =\n  route(\"/api/foo\")(^^) &lt;|\n  authorized(\"Administrator\")(^^) &lt;|\n  originCheck(^^) &lt;|\n  rateLimited(5, 1)(^^) &lt;|\n  function () {};\n</code></pre>\n<p>You most likely need to use double invocation here if you want to reuse existing decorators (despite those decorators needing to be even more defensive around the missing 2nd argument).</p>\n","m.mentions":{"user_ids":["@michaelficarra:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$0kn_o9nRnDOYLkASHE9huBaBkvF7WFLkd8d7G0Ofd7I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1707437457626,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$qvMRmakTpRq3LZ8rFBiIo2Vr71f1iS9YugIBTF-iqsE"},
{"content":{"body":"And I do not find that more readable in the slightest.","m.mentions":{},"m.relates_to":{"event_id":"$JP6Jju5invA57mppdr-qhfg6QL0-DPiKPJAL5Jj_Jm4","is_falling_back":true,"m.in_reply_to":{"event_id":"$0kn_o9nRnDOYLkASHE9huBaBkvF7WFLkd8d7G0Ofd7I"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707437481485,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KeyeGfHaJJkWEtin-D3M3mNbOEfGZCOq8QUIiLiiWww"},
{"content":{"body":"> <@nicolo-ribaudo:matrix.org> I would hope we would use indexes instead of names if we do param decorators\n\nThis is what we currently do in TS. Parameter names seem like a nice to have capability that is worth exploring as its useful for diagnostics purposes. for example, if your decorator performs some kind of route binding or validation and if that fails it throws an error. It's far more convenient to diagnose `\"The provided value is not supported on parameter 'foo'\"` than `\"The provided value is not supported on parameter 6\"`. Whether we support parameter names is definitely a topic for discussion at stage 1. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$5sGedBEQwRRhShjcSAYiOWKAFfkzRev34r9h1MGdXeE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">@nicolo-ribaudo:matrix.org</a><br>I would hope we would use indexes instead of names if we do param decorators</blockquote></mx-reply>This is what we currently do in TS. Parameter names seem like a nice to have capability that is worth exploring as its useful for diagnostics purposes. for example, if your decorator performs some kind of route binding or validation and if that fails it throws an error. It's far more convenient to diagnose <code>\"The provided value is not supported on parameter 'foo'\"</code> than <code>\"The provided value is not supported on parameter 6\"</code>. Whether we support parameter names is definitely a topic for discussion at stage 1.","m.mentions":{"user_ids":["@nicolo-ribaudo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$5sGedBEQwRRhShjcSAYiOWKAFfkzRev34r9h1MGdXeE"}},"msgtype":"m.text"},"ts":1707437827279,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-pnyoWqR2zW_ySOYEwO7FVsEquyQDut5ueKtY4qD7Mw"},
{"content":{"body":"Didn’t we agree that closed over unary-returning functions are the devil in the pipelines proposal?","m.relates_to":{"event_id":"$JP6Jju5invA57mppdr-qhfg6QL0-DPiKPJAL5Jj_Jm4","is_falling_back":true,"m.in_reply_to":{"event_id":"$KeyeGfHaJJkWEtin-D3M3mNbOEfGZCOq8QUIiLiiWww"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707437970781,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$bRoN59xgCVCf_tdqNuRnzk1I61X9Ayn6ee5ox_24md8"},
{"content":{"body":"> <@shuyuguo:matrix.org> my universe of benefits for that proposal is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?\n\nIt provides both ergonomics benefits (decorator reuse, language consistency), and new capabilities (post decorate registration, function name reflection for diagnostics, metadata).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$pq1lBx4D1q09o0ebAyZSwH9S4jlpz-nMrrXsixil-00?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>my universe of benefits for that proposal is either a new capability, or an ergonomic improvement. that may be a broader brush than what you think of as \"ergonomics\"?</blockquote></mx-reply>It provides both ergonomics benefits (decorator reuse, language consistency), and new capabilities (post decorate registration, function name reflection for diagnostics, metadata).","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$pq1lBx4D1q09o0ebAyZSwH9S4jlpz-nMrrXsixil-00"}},"msgtype":"m.text"},"ts":1707437978129,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1yntN66gFhMMW3Ae79vu6C6CYGiyLHVq-eO90tnkLZs"},
{"content":{"body":"Sorry, me being cheeky isn’t needed here.","m.relates_to":{"event_id":"$JP6Jju5invA57mppdr-qhfg6QL0-DPiKPJAL5Jj_Jm4","is_falling_back":true,"m.in_reply_to":{"event_id":"$bRoN59xgCVCf_tdqNuRnzk1I61X9Ayn6ee5ox_24md8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707438130099,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$KiiWuISAFbDNvvrq01YB5aIX6A2glmkDyF7n4mmNSUE"},
{"content":{"body":"It depends on what capabilities we give to parameter decorators. In TypeScript, such a parameter decorator can only be used for recording metadata. It can't perform method replacement or run code on a per-invocation basis.","m.mentions":{},"m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$QIwYIZsNkwHLfsgQ4snRD3aaNI4rpCJCFPqyf9mu7y0"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707441595253,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$11wbvm1euT-LZ1jPZxED_spdeR5YdfWtkzYzl-lfRc8"},
{"content":{"body":"For constructor parameters, this is a convenient way to associate metadata for dependency injection containers, which is the predominant use case in projects like https://github.com/microsoft/vscode. For method parameters, this is a convenient way to bind HTTP route parameters for RESTful APIs.","m.mentions":{},"m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$11wbvm1euT-LZ1jPZxED_spdeR5YdfWtkzYzl-lfRc8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707441702550,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ssa6Xw_pcrO9Zzv7Tdm6zsICjEO-2iI0H4a0d7IhGZg"},
{"content":{"body":"The parameter decorators proposal described a large number of areas of exploration beyond what TypeScript's version supported, but not all of those capabilities are critical to an MVP version of the proposal. An MVP version I would be comfortable advancing would at a minimum have the same capabilities that such decorators in TS have: parameter index, method name and placement, and the ability to record metadata.","m.mentions":{},"m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$ssa6Xw_pcrO9Zzv7Tdm6zsICjEO-2iI0H4a0d7IhGZg"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707441889001,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$E_bQorK8Fc73iL9eqMdHuz3aYejkDqPuIrU99Nm6Csg"},
{"content":{"body":"Thanks for the response. I’ll think about this. My initial thoughts are that syntactic constructs should meet an incredibly high bar for inclusion in a language. Basically they need to enable a new language construct that wasn’t possible without it","m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$E_bQorK8Fc73iL9eqMdHuz3aYejkDqPuIrU99Nm6Csg"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707441931731,"senderName":"Anthony Bullard","senderId":"@anthonybullard:matrix.org","id":"$Y9j8pDCjW5Knj9y7lftPYk6oSIu3hBmgxfV4lZa3Upw"},
{"content":{"body":"There are a large number of examples on the explainer at https://github.com/tc39/proposal-class-method-parameter-decorators","m.mentions":{},"m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$Y9j8pDCjW5Knj9y7lftPYk6oSIu3hBmgxfV4lZa3Upw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707441943734,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TO22NDLEMWAayZu5qoe2I0pVdIEe8tzvKJDezTO24qE"},
{"content":{"body":"That’s my personal opinion anyway","m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$TO22NDLEMWAayZu5qoe2I0pVdIEe8tzvKJDezTO24qE"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707441962665,"senderName":"Anthony Bullard","senderId":"@anthonybullard:matrix.org","id":"$CP_RLUMp1HRCQVCjP98rcB9OirK17hr-0odRwjvcDKs"},
{"content":{"body":"Parameter decorators were added to TypeScript as a way to parallel what Java annotations or C# attributes can do, which is far more limited than a normal decorator. Even with that limitation, they saw a considerable amount of use in the TS ecosystem.","m.mentions":{},"m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$CP_RLUMp1HRCQVCjP98rcB9OirK17hr-0odRwjvcDKs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707442077013,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DNTPaeSgrsjLTRvlfFV26apda2SqzagmW_jC-cZeS0I"},
{"content":{"body":"A number of the nice-to-haves were based on feedback from the TS community over the years. We don't allow method replacement, so TS parameter decorators couldn't be used for parameter validation without pairing them with a method decorator.","m.mentions":{},"m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$DNTPaeSgrsjLTRvlfFV26apda2SqzagmW_jC-cZeS0I"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707442173268,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fR_aSTRuNAdyBT_3duhatLN2AzBS-_udFCO3dmHnbMk"},
{"content":{"body":"That was seen as a wart in the design, which prompted the proposed adoption of returning a callback that could intercept the bound argument.  That turns out to be a very powerful capability, but is perhaps a power we may not want to grant.","m.mentions":{},"m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$fR_aSTRuNAdyBT_3duhatLN2AzBS-_udFCO3dmHnbMk"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707442332590,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FiPo_NPpwSqPYHUVQzkLQD6NQ_7QmGkx9p3ipKa1bFY"},
{"content":{"body":"having to manually number a series of pseudo-parameter decorators that are far detached from the actual code they represent is extremely unergonomic. Having the runtime provide the parameter index for you, and keeping the declarations physically adjacent to the parameter improves readability and is extremely convenient for refactors.","m.mentions":{},"m.relates_to":{"event_id":"$BQYLiJU8BoUVR4lRLglvhteCuioia665TyHuYgGtols","is_falling_back":true,"m.in_reply_to":{"event_id":"$FiPo_NPpwSqPYHUVQzkLQD6NQ_7QmGkx9p3ipKa1bFY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707442475843,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WxwI2EuZm3bQlkuKA0ORwbjiW1AoLuB4Wfe9ddRuF6o"},
{"content":{"body":"> <@bakkot:matrix.org> while everyone's here, if you would like to think about async iterators, I have written up the two major open questions in my mind, namely:\n> \n> - do you enforce promises settle in order? if so, you can't do rust-style `bufferUnordered`, but if not, you can observe otherwise-impossible sequences.\n> - how do you get concurrency for helpers like `.find`?\n> \n> https://gist.github.com/bakkot/ad58565b203cd845524ac702c3f289f0\n\nReading through this, I’m a little surprised that we’re considering making async iterables support unordered buffering. But it’s an exciting capability.\n\nI feel that the *default* behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially, like how `for await` (and Array.fromAsync) already do. The contract of async iterators implies stable sequentiality to me. I don’t know how strongly I feel about this.\n\nI think that using a Rust-like `bufferUnordered` method is a good idea. It would make developers *opt into* unordered buffering. (I also slightly prefer `bufferUnordered` to `buffered` to clearly indicate the lack of stable order.) I don’t know how I feel about `forEachConcurrent` and `findConcurrent`.\n\nWould `bufferUnordered` return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$oRIIDDlSwjjpcy5nxddLkGleES_IbzBPrg_LbAc0WVQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br><p>while everyone's here, if you would like to think about async iterators, I have written up the two major open questions in my mind, namely:</p>\n<ul>\n<li>do you enforce promises settle in order? if so, you can't do rust-style <code>bufferUnordered</code>, but if not, you can observe otherwise-impossible sequences.</li>\n<li>how do you get concurrency for helpers like <code>.find</code>?</li>\n</ul>\n<p>https://gist.github.com/bakkot/ad58565b203cd845524ac702c3f289f0</p>\n</blockquote></mx-reply><p>Reading through this, I’m a little surprised that we’re considering making async iterables support unordered buffering. But it’s an exciting capability.</p>\n<p>I feel that the <em>default</em> behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially, like how <code>for await</code> (and Array.fromAsync) already do. The contract of async iterators implies stable sequentiality to me. I don’t know how strongly I feel about this.</p>\n<p>I think that using a Rust-like <code>bufferUnordered</code> method is a good idea. It would make developers <em>opt into</em> unordered buffering. (I also slightly prefer <code>bufferUnordered</code> to <code>buffered</code> to clearly indicate the lack of stable order.) I don’t know how I feel about <code>forEachConcurrent</code> and <code>findConcurrent</code>.</p>\n<p>Would <code>bufferUnordered</code> return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?</p>\n","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$oRIIDDlSwjjpcy5nxddLkGleES_IbzBPrg_LbAc0WVQ"}},"msgtype":"m.text"},"ts":1707444143575,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$8BcHhphiqrTkKqxfFFLKc0bX1HS5sAeiDU4U7seajl4"},
{"content":{"body":" * Reading through this, I’m a little surprised that we’re considering making async iterables support unordered buffering. But it’s an exciting capability. It might be especially useful when combining WHATWG Streams.\n\nI feel that the _default_ behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially, like how `for await` (and Array.fromAsync) already do. The contract of async iterators implies stable sequentiality to me. I don’t know how strongly I feel about this.\n\nI think that using a Rust-like `bufferUnordered` method is a good idea. It would make developers _opt into_ unordered buffering. (I also slightly prefer `bufferUnordered` to `buffered` to clearly indicate the lack of stable order.) I don’t know how I feel about `forEachConcurrent` and `findConcurrent`.\n\nWould `bufferUnordered` return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$oRIIDDlSwjjpcy5nxddLkGleES_IbzBPrg_LbAc0WVQ?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br><p>while everyone's here, if you would like to think about async iterators, I have written up the two major open questions in my mind, namely:</p>\n<ul>\n<li>do you enforce promises settle in order? if so, you can't do rust-style <code>bufferUnordered</code>, but if not, you can observe otherwise-impossible sequences.</li>\n<li>how do you get concurrency for helpers like <code>.find</code>?</li>\n</ul>\n<p>https://gist.github.com/bakkot/ad58565b203cd845524ac702c3f289f0</p>\n</blockquote></mx-reply> * <p>Reading through this, I’m a little surprised that we’re considering making async iterables support unordered buffering. But it’s an exciting capability. It might be especially useful when combining WHATWG Streams.</p>\n<p>I feel that the <em>default</em> behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially, like how <code>for await</code> (and Array.fromAsync) already do. The contract of async iterators implies stable sequentiality to me. I don’t know how strongly I feel about this.</p>\n<p>I think that using a Rust-like <code>bufferUnordered</code> method is a good idea. It would make developers <em>opt into</em> unordered buffering. (I also slightly prefer <code>bufferUnordered</code> to <code>buffered</code> to clearly indicate the lack of stable order.) I don’t know how I feel about <code>forEachConcurrent</code> and <code>findConcurrent</code>.</p>\n<p>Would <code>bufferUnordered</code> return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?</p>\n","m.mentions":{},"m.new_content":{"body":"Reading through this, I’m a little surprised that we’re considering making async iterables support unordered buffering. But it’s an exciting capability. It might be especially useful when combining WHATWG Streams.\n\nI feel that the _default_ behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially, like how `for await` (and Array.fromAsync) already do. The contract of async iterators implies stable sequentiality to me. I don’t know how strongly I feel about this.\n\nI think that using a Rust-like `bufferUnordered` method is a good idea. It would make developers _opt into_ unordered buffering. (I also slightly prefer `bufferUnordered` to `buffered` to clearly indicate the lack of stable order.) I don’t know how I feel about `forEachConcurrent` and `findConcurrent`.\n\nWould `bufferUnordered` return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?","format":"org.matrix.custom.html","formatted_body":"<p>Reading through this, I’m a little surprised that we’re considering making async iterables support unordered buffering. But it’s an exciting capability. It might be especially useful when combining WHATWG Streams.</p>\n<p>I feel that the <em>default</em> behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially, like how <code>for await</code> (and Array.fromAsync) already do. The contract of async iterators implies stable sequentiality to me. I don’t know how strongly I feel about this.</p>\n<p>I think that using a Rust-like <code>bufferUnordered</code> method is a good idea. It would make developers <em>opt into</em> unordered buffering. (I also slightly prefer <code>bufferUnordered</code> to <code>buffered</code> to clearly indicate the lack of stable order.) I don’t know how I feel about <code>forEachConcurrent</code> and <code>findConcurrent</code>.</p>\n<p>Would <code>bufferUnordered</code> return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?</p>\n","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$8BcHhphiqrTkKqxfFFLKc0bX1HS5sAeiDU4U7seajl4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1707444336709,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$rnSkbcuw0t-E16lcv0FRIS08nArziCoOWydjy95Qg84"},
{"content":{"body":"A quick note regarding reusing a punctuator in place of `void` for discards. There are very few of these that are viable due to compound assignment:\n\n```js\n// these are all already legal:\nusing *= f();\nusing /= f();\nusing %= f();\nusing += f();\nusing -= f();\nusing &= f();\nusing ^= f();\nusing |= f();\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>A quick note regarding reusing a punctuator in place of <code>void</code> for discards. There are very few of these that are viable due to compound assignment:</p>\n<pre><code class=\"language-js\">// these are all already legal:\nusing *= f();\nusing /= f();\nusing %= f();\nusing += f();\nusing -= f();\nusing &amp;= f();\nusing ^= f();\nusing |= f();\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1707444385614,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BqzIWghglm2v6y1aq3DUGDEfvc7VyILuVV0Efs6r7T0"},
{"content":{"body":"Congrats to libjs for passing the most tests and being faster than V8/SM :)","msgtype":"m.text"},"ts":1707444711739,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$M3ENOByE-AqTZSIvaR0-7px_80oyu_m1i1RlBrftaGE"},
{"content":{"body":"congrats to engine262 for being the slowest","msgtype":"m.text"},"ts":1707445197411,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$_bmULuKTDDBrQrcjeZ7KKJNqZhk51dyKzyLMZ7tmbJA"},
{"content":{"body":"just talked to canadahonk about this, apparently some of the V8/SM experimental flags have changed so slightly inaccurate :P","format":"org.matrix.custom.html","formatted_body":"just talked to canadahonk about this, apparently some of the V8/SM experimental flags have changed so slightly inaccurate :P","m.relates_to":{"event_id":"$M3ENOByE-AqTZSIvaR0-7px_80oyu_m1i1RlBrftaGE","is_falling_back":true,"m.in_reply_to":{"event_id":"$M3ENOByE-AqTZSIvaR0-7px_80oyu_m1i1RlBrftaGE"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707445895719,"senderName":"linusg","senderId":"@linusgroh:matrix.org","id":"$bsxMZN2HRASD05e729-gddGIJThr1RXxhbh9ZJkM2cQ"},
{"content":{"body":"both rhino and nashorn take many hours to complete, check again in a few hours 😅","format":"org.matrix.custom.html","formatted_body":"both rhino and nashorn take many hours to complete, check again in a few hours 😅","m.relates_to":{"event_id":"$_bmULuKTDDBrQrcjeZ7KKJNqZhk51dyKzyLMZ7tmbJA","is_falling_back":true,"m.in_reply_to":{"event_id":"$_bmULuKTDDBrQrcjeZ7KKJNqZhk51dyKzyLMZ7tmbJA"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707446013128,"senderName":"linusg","senderId":"@linusgroh:matrix.org","id":"$u2kMIKdXFhJMkPjCdtamQs_FBNBxRFr9s5ZUN59B_o0"},
{"content":{"body":"jschoi: re:\n\n> I feel that the _default_ behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially\n\nSo, an async iterator doesn't actually do anything itself. It doesn't really make sense to compare the behavior of async iterators to the behavior of `for await`, because the iterator doesn't have any behavior on its own (`buffer` excepted).\n\nInstead of talking about the behavior of an async iterator itself, we can talk about the behavior observed by consumers of an async iterator. A consumer like `for await` will see the same thing in all worlds discussed here (unless one is using the new buffering helpers), because `for await` waits for each promise to settle before pulling the next one, and so could not possibly observe promises settling out of order. The \"can things settle out of order\" question does not affect such consumers at all.\n\nIf we allow settling out of order, that would only be observable to consumers which do multiple calls of `.next()`. There's nothing in the language that does that right now, but you could do it yourself, in principle. Or, as proposed, you could do it with `buffer` or `bufferUnordered` (which would do multiple calls to `.next()` under the hood). With `buffer`, if you pull from it the way `for await` does, you would never see things happening out of order. So the only places this \"settling out of order\" behavior would be observable would be when manually calling `.next()` multiple times, or when using `bufferUnordered`.\n\n> Would `bufferUnordered` return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?\n\nFirst thing. The return value of all helpers would just be instances of AsyncIteratorHelper.","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: re:</p>\n<blockquote>\n<p>I feel that the <em>default</em> behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially</p>\n</blockquote>\n<p>So, an async iterator doesn't actually do anything itself. It doesn't really make sense to compare the behavior of async iterators to the behavior of <code>for await</code>, because the iterator doesn't have any behavior on its own (<code>buffer</code> excepted).</p>\n<p>Instead of talking about the behavior of an async iterator itself, we can talk about the behavior observed by consumers of an async iterator. A consumer like <code>for await</code> will see the same thing in all worlds discussed here (unless one is using the new buffering helpers), because <code>for await</code> waits for each promise to settle before pulling the next one, and so could not possibly observe promises settling out of order. The \"can things settle out of order\" question does not affect such consumers at all.</p>\n<p>If we allow settling out of order, that would only be observable to consumers which do multiple calls of <code>.next()</code>. There's nothing in the language that does that right now, but you could do it yourself, in principle. Or, as proposed, you could do it with <code>buffer</code> or <code>bufferUnordered</code> (which would do multiple calls to <code>.next()</code> under the hood). With <code>buffer</code>, if you pull from it the way <code>for await</code> does, you would never see things happening out of order. So the only places this \"settling out of order\" behavior would be observable would be when manually calling <code>.next()</code> multiple times, or when using <code>bufferUnordered</code>.</p>\n<blockquote>\n<p>Would <code>bufferUnordered</code> return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?</p>\n</blockquote>\n<p>First thing. The return value of all helpers would just be instances of AsyncIteratorHelper.</p>\n","m.mentions":{"user_ids":["@jschoi:matrix.org"]},"msgtype":"m.text"},"ts":1707447301235,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$I96fL4n_SK2-oGoxohX0jItHaKBzyw4pd1qIyvaL6KU"},
{"content":{"body":"On the topic of parameter decorators, I wonder if other people have looked through the examples in the readme of the proposal, and if so what their reactions are: https://github.com/tc39/proposal-class-method-parameter-decorators#ecmascript","m.mentions":{},"msgtype":"m.text"},"ts":1707447864941,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$JyXwlEKQxErXj15gKi7wqwrSN-q2OtgtcHgtMtMTqns"},
{"content":{"body":"it looks incredibly foreign to me","m.mentions":{},"msgtype":"m.text"},"ts":1707447934041,"senderName":"rkirsling","senderId":"@rkirsling:matrix.org","id":"$D5FLJusbspOLGXWmb6FOn2_9gRD58aWk99RUw5MJbUk"},
{"content":{"body":"I have little experience with decorators in any language, but I'm at least used to the idea that they sit atop a method or function or whatever","m.mentions":{},"msgtype":"m.text"},"ts":1707448143032,"senderName":"rkirsling","senderId":"@rkirsling:matrix.org","id":"$1KPLXTUtTYVAO5Vd31iSn0TS2dOA9c2uIyBjf0XslCg"},
{"content":{"body":"Does eshost do as good a job as the engines’ own test262 runners at filling in all of the hooks and such?","m.relates_to":{"event_id":"$M3ENOByE-AqTZSIvaR0-7px_80oyu_m1i1RlBrftaGE","is_falling_back":true,"m.in_reply_to":{"event_id":"$bsxMZN2HRASD05e729-gddGIJThr1RXxhbh9ZJkM2cQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707448948117,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$H8IMGZR6-LKFISXI7FtlnMB_YlyHRtbOwbsGLKECFpA"},
{"content":{"body":"pretty much, yep! ","format":"org.matrix.custom.html","formatted_body":"pretty much, yep! ","m.relates_to":{"event_id":"$M3ENOByE-AqTZSIvaR0-7px_80oyu_m1i1RlBrftaGE","is_falling_back":true,"m.in_reply_to":{"event_id":"$H8IMGZR6-LKFISXI7FtlnMB_YlyHRtbOwbsGLKECFpA"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707449791252,"senderName":"linusg","senderId":"@linusgroh:matrix.org","id":"$XzvwP-JIXcW2qHHpq2GPIekd_ykxFJkfptWOlTtk31w"},
{"content":{"body":"> <@bakkot:matrix.org> jschoi: re:\n> \n> > I feel that the _default_ behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially\n> \n> So, an async iterator doesn't actually do anything itself. It doesn't really make sense to compare the behavior of async iterators to the behavior of `for await`, because the iterator doesn't have any behavior on its own (`buffer` excepted).\n> \n> Instead of talking about the behavior of an async iterator itself, we can talk about the behavior observed by consumers of an async iterator. A consumer like `for await` will see the same thing in all worlds discussed here (unless one is using the new buffering helpers), because `for await` waits for each promise to settle before pulling the next one, and so could not possibly observe promises settling out of order. The \"can things settle out of order\" question does not affect such consumers at all.\n> \n> If we allow settling out of order, that would only be observable to consumers which do multiple calls of `.next()`. There's nothing in the language that does that right now, but you could do it yourself, in principle. Or, as proposed, you could do it with `buffer` or `bufferUnordered` (which would do multiple calls to `.next()` under the hood). With `buffer`, if you pull from it the way `for await` does, you would never see things happening out of order. So the only places this \"settling out of order\" behavior would be observable would be when manually calling `.next()` multiple times, or when using `bufferUnordered`.\n> \n> > Would `bufferUnordered` return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?\n> \n> First thing. The return value of all helpers would just be instances of AsyncIteratorHelper.\n\nThe framing here makes sense. Promises’ settling out of order is unobservable by default to “higher-level” consumers like `for await` or AsyncIterator methods (higher-level = “do not directly call `.next()`).\n\nI think it’d be good to put something like the explanation here into your Gist or your future explainer.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$I96fL4n_SK2-oGoxohX0jItHaKBzyw4pd1qIyvaL6KU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br><p><a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: re:</p>\n<blockquote>\n<p>I feel that the <em>default</em> behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially</p>\n</blockquote>\n<p>So, an async iterator doesn't actually do anything itself. It doesn't really make sense to compare the behavior of async iterators to the behavior of <code>for await</code>, because the iterator doesn't have any behavior on its own (<code>buffer</code> excepted).</p>\n<p>Instead of talking about the behavior of an async iterator itself, we can talk about the behavior observed by consumers of an async iterator. A consumer like <code>for await</code> will see the same thing in all worlds discussed here (unless one is using the new buffering helpers), because <code>for await</code> waits for each promise to settle before pulling the next one, and so could not possibly observe promises settling out of order. The \"can things settle out of order\" question does not affect such consumers at all.</p>\n<p>If we allow settling out of order, that would only be observable to consumers which do multiple calls of <code>.next()</code>. There's nothing in the language that does that right now, but you could do it yourself, in principle. Or, as proposed, you could do it with <code>buffer</code> or <code>bufferUnordered</code> (which would do multiple calls to <code>.next()</code> under the hood). With <code>buffer</code>, if you pull from it the way <code>for await</code> does, you would never see things happening out of order. So the only places this \"settling out of order\" behavior would be observable would be when manually calling <code>.next()</code> multiple times, or when using <code>bufferUnordered</code>.</p>\n<blockquote>\n<p>Would <code>bufferUnordered</code> return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?</p>\n</blockquote>\n<p>First thing. The return value of all helpers would just be instances of AsyncIteratorHelper.</p>\n</blockquote></mx-reply><p>The framing here makes sense. Promises’ settling out of order is unobservable by default to “higher-level” consumers like <code>for await</code> or AsyncIterator methods (higher-level = “do not directly call <code>.next()</code>).</p>\n<p>I think it’d be good to put something like the explanation here into your Gist or your future explainer.</p>\n","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$I96fL4n_SK2-oGoxohX0jItHaKBzyw4pd1qIyvaL6KU"}},"msgtype":"m.text"},"ts":1707449829413,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$TRXLznQ6DS1zOR5NG_6JNGIDX0OEg7jiVCNkpO-G2kE"},
{"content":{"body":" * The framing here, from the perspective of the AsyncIterator consumer, makes sense. Promises’ settling out of order is unobservable by default to “higher-level” consumers like `for await` or AsyncIterator methods (higher-level = “do not directly call `.next()`).\n\nI think it’d be good to put something like the explanation here into your Gist or your future explainer.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$I96fL4n_SK2-oGoxohX0jItHaKBzyw4pd1qIyvaL6KU?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br><p><a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: re:</p>\n<blockquote>\n<p>I feel that the <em>default</em> behavior of AsyncIterators, including AsyncIterators created from arrays of promises, should wait for each promise sequentially</p>\n</blockquote>\n<p>So, an async iterator doesn't actually do anything itself. It doesn't really make sense to compare the behavior of async iterators to the behavior of <code>for await</code>, because the iterator doesn't have any behavior on its own (<code>buffer</code> excepted).</p>\n<p>Instead of talking about the behavior of an async iterator itself, we can talk about the behavior observed by consumers of an async iterator. A consumer like <code>for await</code> will see the same thing in all worlds discussed here (unless one is using the new buffering helpers), because <code>for await</code> waits for each promise to settle before pulling the next one, and so could not possibly observe promises settling out of order. The \"can things settle out of order\" question does not affect such consumers at all.</p>\n<p>If we allow settling out of order, that would only be observable to consumers which do multiple calls of <code>.next()</code>. There's nothing in the language that does that right now, but you could do it yourself, in principle. Or, as proposed, you could do it with <code>buffer</code> or <code>bufferUnordered</code> (which would do multiple calls to <code>.next()</code> under the hood). With <code>buffer</code>, if you pull from it the way <code>for await</code> does, you would never see things happening out of order. So the only places this \"settling out of order\" behavior would be observable would be when manually calling <code>.next()</code> multiple times, or when using <code>bufferUnordered</code>.</p>\n<blockquote>\n<p>Would <code>bufferUnordered</code> return an AsyncIterator that is indistinguishable from other AsyncIterators? Or would it return a new async-iterable type, like Rust’s BufferUnordered class?</p>\n</blockquote>\n<p>First thing. The return value of all helpers would just be instances of AsyncIteratorHelper.</p>\n</blockquote></mx-reply> * <p>The framing here, from the perspective of the AsyncIterator consumer, makes sense. Promises’ settling out of order is unobservable by default to “higher-level” consumers like <code>for await</code> or AsyncIterator methods (higher-level = “do not directly call <code>.next()</code>).</p>\n<p>I think it’d be good to put something like the explanation here into your Gist or your future explainer.</p>\n","m.mentions":{},"m.new_content":{"body":"The framing here, from the perspective of the AsyncIterator consumer, makes sense. Promises’ settling out of order is unobservable by default to “higher-level” consumers like `for await` or AsyncIterator methods (higher-level = “do not directly call `.next()`).\n\nI think it’d be good to put something like the explanation here into your Gist or your future explainer.","format":"org.matrix.custom.html","formatted_body":"<p>The framing here, from the perspective of the AsyncIterator consumer, makes sense. Promises’ settling out of order is unobservable by default to “higher-level” consumers like <code>for await</code> or AsyncIterator methods (higher-level = “do not directly call <code>.next()</code>).</p>\n<p>I think it’d be good to put something like the explanation here into your Gist or your future explainer.</p>\n","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$TRXLznQ6DS1zOR5NG_6JNGIDX0OEg7jiVCNkpO-G2kE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1707449852398,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$uIUdfu2GlmeIFS_iM14vxk0UnH96CnMGFwh1r7AycK4"},
{"content":{"body":"the main advantage of writing a custom runner is that spawning 100k processes is slow (~50k tests each running in sloppy and strict mode) ","format":"org.matrix.custom.html","formatted_body":"the main advantage of writing a custom runner is that spawning 100k processes is slow (~50k tests each running in sloppy and strict mode) ","m.relates_to":{"event_id":"$M3ENOByE-AqTZSIvaR0-7px_80oyu_m1i1RlBrftaGE","is_falling_back":true,"m.in_reply_to":{"event_id":"$XzvwP-JIXcW2qHHpq2GPIekd_ykxFJkfptWOlTtk31w"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707449861763,"senderName":"linusg","senderId":"@linusgroh:matrix.org","id":"$x3lzgCFUuetdsEUGBCtvIy6LxYBKxusMo4VlzravzAk"},
{"content":{"body":"it takes like 4 minutes to run engine262 on test262 with its runner, but eshost apparently takes 2 hours lol","m.relates_to":{"event_id":"$M3ENOByE-AqTZSIvaR0-7px_80oyu_m1i1RlBrftaGE","is_falling_back":true,"m.in_reply_to":{"event_id":"$x3lzgCFUuetdsEUGBCtvIy6LxYBKxusMo4VlzravzAk"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707506358494,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$36pE1-9Cpde0DJFZeI2NhiXumf-u-ro3J5i7ABIAVSs"}
]