[
{"content":{"body":"> <@marjakh:matrix.org> Michael Ficarra: the most chrome / v8 bugs are not because our C++ is doing memory management wrong, they are because we have a logic bug in generating machine code or because our invariants are extremely complex and one part might make a change which violates an invariant somewhere else. happy to talk more about this. interestingly, a huge proportion of the CVEs listed on shu's slide were in my code, and none of my bugs were because of C++, and would've happened even if V8 was written in a memory safe language.\n\nGraalJS takes an approach that ensures JIT-produced code is memory-safe by construction without sacrificing perf: https://medium.com/graalvm/writing-truly-memory-safe-jit-compilers-f79ad44558dd","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw%3Amatrix.org/%24PnFluxO9DAer5dz9ZBMw6xCUjM5tCv4CNF2OM4ziE38\">In reply to</a><a href=\"https://matrix.to/#/%40marjakh%3Amatrix.org\">@marjakh:matrix.org</a><br /><a href=\"https://matrix.to/#/@michaelficarra:matrix.org\">Michael Ficarra</a>: the most chrome / v8 bugs are not because our C++ is doing memory management wrong, they are because we have a logic bug in generating machine code or because our invariants are extremely complex and one part might make a change which violates an invariant somewhere else. happy to talk more about this. interestingly, a huge proportion of the CVEs listed on shu's slide were in my code, and none of my bugs were because of C++, and would've happened even if V8 was written in a memory safe language.</blockquote></mx-reply>GraalJS takes an approach that ensures JIT-produced code is memory-safe by construction without sacrificing perf: https://medium.com/graalvm/writing-truly-memory-safe-jit-compilers-f79ad44558dd","m.relates_to":{"m.in_reply_to":{"event_id":"$PnFluxO9DAer5dz9ZBMw6xCUjM5tCv4CNF2OM4ziE38"}},"msgtype":"m.text"},"ts":1729617016488,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$qJHKJ1oUetkF5w9S106dyHbrfQVRC_rAckSauh7nlBI"},
{"content":{"body":"i'm not sure why there's a connection between partial evaluation and the heap sandbox?","m.mentions":{},"msgtype":"m.text"},"ts":1729630806978,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Ar_9VERbNm51XtLvwsbJitsdhB5XVX-qpXa4U9M7Lpw"},
{"content":{"body":"the thesis of the article is that because graal partially evaluates an interpreter, this class of bugs is avoided","m.mentions":{},"msgtype":"m.text"},"ts":1729630896823,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$fNXLdqjw5JTKR0m0Tk1tlCrsuDkiD2coZRLPi22YyqQ"},
{"content":{"body":"but a heap sandbox is about protecting memory representation being exploited by an attacker, which _can_ arise from type confusion bugs due to JIT bugs, but can also just arise through other vectors","format":"org.matrix.custom.html","formatted_body":"but a heap sandbox is about protecting memory representation being exploited by an attacker, which <em>can</em> arise from type confusion bugs due to JIT bugs, but can also just arise through other vectors","m.mentions":{},"msgtype":"m.text"},"ts":1729630955645,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zBKSzuE1BZfg4mGvRPJwXBNR5cg3sbbiLRLKcJZm3C0"},
{"content":{"body":"a partial evaluator doesn't avoid that by construction. it can avoid some of the attack surface, though, and is a cool technique","m.mentions":{},"msgtype":"m.text"},"ts":1729631095259,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$FOErwytgYUSddew95Nsgn_iXptCsPU2J03mT4GyVzUM"},
{"content":{"body":"the heap sandbox would need to exist at the JVM or the native codegen layer in the GC runtime if you're bundling a GC, not really at the compilation layer. the graal thesis still requires that your interpreter is correct, or all the object runtime code that deal with actual representation of your objects are bug-free, right? the point of the heap sandbox is that it's another containment layering assuming that the VM is already pwned, which is... closer to reality imo","m.mentions":{},"msgtype":"m.text"},"ts":1729631262328,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$63tFZ9ww9WcpOiIwc379B4OsTvJlv1hCt_E8vPxiWYw"},
{"content":{"body":"also caveats about \"without sacrificing performance\" which seems to be about peak performance yada yada yada","m.mentions":{},"msgtype":"m.text"},"ts":1729631319840,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cSYj0h1WWtir2GqsjDQOCk5fqq3_-JeCom29q8uAwfI"},
{"content":{"body":"yes, see this quote:\n\n> This architecture is standard — both the JVM and V8 use it — but viewed from a security perspective the design has a flaw: it’s error prone. The language semantics are implemented twice, once for the interpreter and again for the JIT compiler. It’s critical not only that both places are fully correct but also that they exactly match. Otherwise, the VM becomes exploitable.","format":"org.matrix.custom.html","formatted_body":"yes, see this quote:<br/><br/><blockquote data-md=\">\">This architecture is standard — both the JVM and V8 use it — but viewed from a security perspective the design has a flaw: it’s error prone. The language semantics are implemented twice, once for the interpreter and again for the JIT compiler. It’s critical not only that both places are fully correct but also that they exactly match. Otherwise, the VM becomes exploitable.<br/></blockquote>","msgtype":"m.text"},"ts":1729631907761,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$Lbfv_UQmNLqcv2WFhfLjrov5hBTmb80d_945zFnfobY"},
{"content":{"body":"assuming you have a correct interpreter, you don't have a second implementation (the JIT) which introduces its own bugs or just differences in behaviour","msgtype":"m.text"},"ts":1729631955290,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$e_val-LoJa890ad1juLssxKHya4oMgvFnkSpXKqA6eY"},
{"content":{"body":"but that's a narrower class of bugs than the heap sandbox is designed for","m.mentions":{},"msgtype":"m.text"},"ts":1729632451800,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$L6nAqPk4eKD-x_4bBPVOlzgPF4pcC9prFqkkS-yCP6w"},
{"content":{"body":"i.e., the heap sandbox is defense in depth assuming several class of bugs. this blogpost is saying, our technique can sidestep one such class of bugs","m.mentions":{},"msgtype":"m.text"},"ts":1729632506017,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$QuRC05kQf7NHDtVMMhx_pxdkDSAyMzxL5hu40YNkMgE"}
]