[
{"content":{"body":"There’s a transfer template","m.relates_to":{"event_id":"$mZherF9F0OfWRdfoa-B2RBfAUal59mfgnVI0cZqrAcs","is_falling_back":true,"m.in_reply_to":{"event_id":"$cGCNOtRFTQC11KNmYdIlNJ8iz4KhAS7UjnnWh9bDmNQ"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1716249711841,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Rqv1bTEJEe4IvPaSzVdzFS57EkP_ICAx1KjNSNT_BnM"},
{"content":{"body":"YieldExpression and AwaitExpressions are disallowed in the Initializer of FieldDefinitions, right? where is that checked for? i think i'm missing something","m.mentions":{},"msgtype":"m.text"},"ts":1716324986014,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6SvNHKCxWjZdbxZsePW0o3wqOVR2t8vUfY_nron4WLA"},
{"content":{"body":"the grammar is passing along [?Yield, ?Await] and i don't see a special Early Error for it","m.mentions":{},"msgtype":"m.text"},"ts":1716325018235,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$4u5T5sEQKuKLi0wRnb3_mT9d-HHwXXYofwBOLuQqi8I"},
{"content":{"body":"hmm","m.mentions":{},"msgtype":"m.text"},"ts":1716325830119,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$koBMr-ZXBv8MdDShRX5Bfpt9tLK5HnVCMSmcijeMWuU"},
{"content":{"body":"yeah it should probably not be passed through to the rhs","m.mentions":{},"msgtype":"m.text"},"ts":1716325836322,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$bb63HiwTZwtqHCfAbEF53VVEV5EQ0uSuxmDgWSrDe7s"},
{"content":{"body":"at least for non-static fields; not sure about static","m.mentions":{},"msgtype":"m.text"},"ts":1716325846670,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$AlIidGi7dbbcYGNXqpjBgCCqrNzbu8q917a93m-luf8"},
{"content":{"body":"implementations don't accept either await or yield in both member and `static` AFAICT","format":"org.matrix.custom.html","formatted_body":"implementations don't accept either await or yield in both member and <code>static</code> AFAICT","m.mentions":{},"msgtype":"m.text"},"ts":1716328759671,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$BrBGVGKI6YULTSo5mqspZYqdKK4HjD0JRMr7_lZIDHQ"},
{"content":{"body":"heh, JSC allows it\n```\n$ eshost -h JavaScriptCore -sx 'const iter = (function*(){ return (class { static foo = yield }).foo; })(); iter.next(); print(JSON.stringify(iter.next(42)));'\n#### JavaScriptCore\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":"<p>heh, JSC allows it</p>\n<pre><code>$ eshost -h JavaScriptCore -sx 'const iter = (function*(){ return (class { static foo = yield }).foo; })(); iter.next(); print(JSON.stringify(iter.next(42)));'\n#### JavaScriptCore\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716329937266,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$f86Du6zJb8WyAW4n1bFDw7h_IJeAi-RXvcZRoRdZ_PI"},
{"content":{"body":"sick","m.mentions":{},"msgtype":"m.text"},"ts":1716329954871,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$aZBjNSMjmWXJanWe-uzoahieaIpg-o_rf7g12OF_TPQ"},
{"content":{"body":"does it allow it for member fields?","m.mentions":{},"msgtype":"m.text"},"ts":1716329961822,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LWfD-_Iawk1Dzz8LqlWQyah4RoQ4lKtCEveziyvEBUk"},
{"content":{"body":" * heh, JSC allows it\n\n```\n$ eshost -h JavaScriptCore -sx '\n  const iter = (function*(){ return (class { static foo = yield }).foo; })(); \n  iter.next();\n  print(JSON.stringify(iter.next(42)));\n'\n#### JavaScriptCore\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>heh, JSC allows it</p>\n<pre><code>$ eshost -h JavaScriptCore -sx '\n  const iter = (function*(){ return (class { static foo = yield }).foo; })(); \n  iter.next();\n  print(JSON.stringify(iter.next(42)));\n'\n#### JavaScriptCore\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"heh, JSC allows it\n\n```\n$ eshost -h JavaScriptCore -sx '\n  const iter = (function*(){ return (class { static foo = yield }).foo; })(); \n  iter.next();\n  print(JSON.stringify(iter.next(42)));\n'\n#### JavaScriptCore\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":"<p>heh, JSC allows it</p>\n<pre><code>$ eshost -h JavaScriptCore -sx '\n  const iter = (function*(){ return (class { static foo = yield }).foo; })(); \n  iter.next();\n  print(JSON.stringify(iter.next(42)));\n'\n#### JavaScriptCore\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$f86Du6zJb8WyAW4n1bFDw7h_IJeAi-RXvcZRoRdZ_PI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716329963126,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$kwVf-cX_BEM5ghx_StYle1otrjo3gs1stlTprrdxrW0"},
{"content":{"body":"yes","m.mentions":{},"msgtype":"m.text"},"ts":1716329965953,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$lX-1xXdf_qPKa7zEsEYDrEwhB71VxdM14TDgv7xwkBU"},
{"content":{"body":"that's cursed","m.mentions":{},"msgtype":"m.text"},"ts":1716329971502,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$8jHYXcLXCLSyqNg6BHkb9GV0mM6KHjw1iCodfkd8m_Q"},
{"content":{"body":" * yes:\n```\neshost -h JavaScriptCore -sx '\n  const iter = (function*(){ return (new class { foo = yield }).foo; })();\n  iter.next();\n  print(JSON.stringify(iter.next(42)));\n'\n#### JavaScriptCore\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>yes:</p>\n<pre><code>eshost -h JavaScriptCore -sx '\n  const iter = (function*(){ return (new class { foo = yield }).foo; })();\n  iter.next();\n  print(JSON.stringify(iter.next(42)));\n'\n#### JavaScriptCore\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"yes:\n```\neshost -h JavaScriptCore -sx '\n  const iter = (function*(){ return (new class { foo = yield }).foo; })();\n  iter.next();\n  print(JSON.stringify(iter.next(42)));\n'\n#### JavaScriptCore\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":"<p>yes:</p>\n<pre><code>eshost -h JavaScriptCore -sx '\n  const iter = (function*(){ return (new class { foo = yield }).foo; })();\n  iter.next();\n  print(JSON.stringify(iter.next(42)));\n'\n#### JavaScriptCore\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$lX-1xXdf_qPKa7zEsEYDrEwhB71VxdM14TDgv7xwkBU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716330099645,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$OPIJPbZdkx0xM-ljnNhTj7OnI5YitYCpuCeRwtFznIw"},
{"content":{"body":"I really want to say I have production code that uses this behavior to detect JSC specifically.","m.mentions":{},"m.relates_to":{"event_id":"$f86Du6zJb8WyAW4n1bFDw7h_IJeAi-RXvcZRoRdZ_PI","is_falling_back":true,"m.in_reply_to":{"event_id":"$f86Du6zJb8WyAW4n1bFDw7h_IJeAi-RXvcZRoRdZ_PI"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1716330203083,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$2JRImXkfOv5H5OwcS_Bi92M1COlr2sYzakXWvjLfYEg"},
{"content":{"body":"mm... allows it syntatically but doesn't appear to actually hit the `yield","m.mentions":{},"msgtype":"m.text"},"ts":1716330486076,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$mG-h2Fs9WVIkC7layTr1cmRpNB0U4m-ri11QRXuDadg"},
{"content":{"body":" * mm... allows it syntatically but doesn't appear to actually hit the `yield`","format":"org.matrix.custom.html","formatted_body":" * mm... allows it syntatically but doesn't appear to actually hit the <code>yield</code>","m.mentions":{},"m.new_content":{"body":"mm... allows it syntatically but doesn't appear to actually hit the `yield`","format":"org.matrix.custom.html","formatted_body":"mm... allows it syntatically but doesn't appear to actually hit the <code>yield</code>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mG-h2Fs9WVIkC7layTr1cmRpNB0U4m-ri11QRXuDadg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716330489381,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$zSGCIUC8RSDMSKMI5zoym1WnhRI_7ZujyetebuMwNd0"},
{"content":{"body":"I know, right?","m.mentions":{},"msgtype":"m.text"},"ts":1716330500826,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$zmmUwUPiYipiTj_9mf4louBdMp-z73fb2j57qsuJiBE"},
{"content":{"body":"the first `iter.next()` is already `done: true`","format":"org.matrix.custom.html","formatted_body":"the first <code>iter.next()</code> is already <code>done: true</code>","m.mentions":{},"msgtype":"m.text"},"ts":1716330506196,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$pVluX5Y4FOsTATKN7riQZwbytdQ9cVW1FLMat5FVZG0"},
{"content":{"body":"Aye, one would expect {value: 42, done: true} if it got into the class.","m.mentions":{},"msgtype":"m.text"},"ts":1716330563909,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$QcjIeyzDbHCJ5zhhlspWpTC9BKpI0XNZdn_tf3Rbdy0"},
{"content":{"body":"Very strange.","m.mentions":{},"msgtype":"m.text"},"ts":1716330580685,"senderName":"kriskowal","senderId":"@kriskowal:aelf.land","id":"$k7kVQtMId6e9MN4pu4k8Eo81V5X1pepixVQADHt8LHw"},
{"content":{"body":"classes are haunted","m.mentions":{},"msgtype":"m.text"},"ts":1716330737745,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$E9zHDSJFfSp630yZYrbjWx6uvxDC-d5FlwP-XDxdTZM"},
{"content":{"body":"i'll file an issue","m.mentions":{},"msgtype":"m.text"},"ts":1716330742505,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ifBBgi1nGq5b8C5tBHffXkiGQzUtQVNUyY93a-FRmJo"},
{"content":{"body":"[loads pistol, climbs back in the compiler]","m.mentions":{},"msgtype":"m.text"},"ts":1716330759448,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$xBejrnYUFw9_IaqsCPa34bf-8q_rtQCPt9P2emZ9Yw0"},
{"content":{"body":"there is no imaginable trace which prints `x` and `z` but not `y` here","format":"org.matrix.custom.html","formatted_body":"there is no imaginable trace which prints <code>x</code> and <code>z</code> but not <code>y</code> here","m.mentions":{},"msgtype":"m.text"},"ts":1716330817727,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$63-RQM5tNsiO2i4X-SKtM7Ei-zl3zooIqlCCU5RBZ6g"},
{"content":{"body":"and yet","m.mentions":{},"msgtype":"m.text"},"ts":1716331045473,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$dfCNMJEnfpwY6GDg0pRC4oSuu94ZnBNyszqyTlKUSfM"},
{"content":{"body":"and why is class static blocks +Await?","m.mentions":{},"msgtype":"m.text"},"ts":1716331662135,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xHEo3nc0GEH-4O8nZebU4xKKTYEKtOLRZV1M0zJPtAg"},
{"content":{"body":"To treat `await` as a keyword and and ban it. ","format":"org.matrix.custom.html","formatted_body":"To treat <code>await</code> as a keyword and and ban it.","msgtype":"m.text"},"ts":1716331984497,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5aJ2xYSlV9RNF304OzEpsZHLZ_PMBs_dLpvy-WRO4mU"},
{"content":{"body":"that one does have an explicit error I am almost certain","m.mentions":{},"msgtype":"m.text"},"ts":1716331989152,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$7z53fExol2hA2MqSJ9aZYht8g07sCND6X1YXyaGKlKw"},
{"content":{"body":"* To treat \nawait as a keyword and then ban it.","m.new_content":{"body":"To treat \nawait as a keyword and then ban it.","format":"org.matrix.custom.html","formatted_body":"To treat<br />await as a keyword and then ban it.","msgtype":"m.text"},"m.relates_to":{"event_id":"$5aJ2xYSlV9RNF304OzEpsZHLZ_PMBs_dLpvy-WRO4mU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716332025163,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_J60NNqI5vAd0hj5TsiHg-B6sPRHbLPWfTrxn8J-GH0"},
{"content":{"body":"I do think the spec may be messed up here, because [|PrimaryExpression|](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression) propagates [?Yield, ?Await] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with [+Yield] and to |AwaitExpression| with [+Await] (and likewise [|StatementList|](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList) to |ClassDeclaration|). The engines that reject source like `function* f(){ class C { static foo = yield }; }` are treating the initializer as containing an identifier that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC and engine262 parse per spec, although in evaluation JSC acts like the above and engine262 dies with an assertion failure:\n```\n$ eshost -h JavaScriptCore,engine262 -sx 'const iter = (function* f(){ return (class C { static foo = yield }).foo; })(); try { print(JSON.stringify(iter.next(\"A\"))); print(JSON.stringify(iter.next(\"B\"))); } catch (err) { print(err); }'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\n{\"done\":true}\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I do think the spec may be messed up here, because <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression\">|PrimaryExpression|</a> propagates [?Yield, ?Await] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with [+Yield] and to |AwaitExpression| with [+Await] (and likewise <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList\">|StatementList|</a> to |ClassDeclaration|). The engines that reject source like <code>function* f(){ class C { static foo = yield }; }</code> are treating the initializer as containing an identifier that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC and engine262 parse per spec, although in evaluation JSC acts like the above and engine262 dies with an assertion failure:</p>\n<pre><code>$ eshost -h JavaScriptCore,engine262 -sx 'const iter = (function* f(){ return (class C { static foo = yield }).foo; })(); try { print(JSON.stringify(iter.next(\"A\"))); print(JSON.stringify(iter.next(\"B\"))); } catch (err) { print(err); }'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\n{\"done\":true}\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716332030364,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$xrMrzQFie1QTbo_LVsa9r--yvwlfVppDMdopGzyecM0"},
{"content":{"body":"* To treat `await` as a keyword and then ban it.","m.new_content":{"body":"To treat `await` as a keyword and then ban it.","format":"org.matrix.custom.html","formatted_body":"To treat <code>await</code> as a keyword and then ban it.","msgtype":"m.text"},"m.relates_to":{"event_id":"$5aJ2xYSlV9RNF304OzEpsZHLZ_PMBs_dLpvy-WRO4mU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716332052147,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oauQgsVlkAzj1N60ZU6G8L4rfR5KcNDKLjqQ8g0k6AY"},
{"content":{"body":"you need to propagate the flags through to `FieldDefinition` because the LHS can be a computed property name and it does get those flags","format":"org.matrix.custom.html","formatted_body":"you need to propagate the flags through to <code>FieldDefinition</code> because the LHS can be a computed property name and it does get those flags","m.mentions":{},"msgtype":"m.text"},"ts":1716332130953,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$uiMsM8AXTAsk2lMZnig8_CvxNvlpiCQ7vxdP0o5abPM"},
{"content":{"body":"but it shouldn't go through to the `Initializer`","format":"org.matrix.custom.html","formatted_body":"but it shouldn't go through to the <code>Initializer</code>","m.mentions":{},"msgtype":"m.text"},"ts":1716332137746,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BYHw8Ia5pl9sq2frzDry2oJ838fyo0dif9GckYPDo9A"},
{"content":{"body":" * I do think the spec may be messed up here, because [|PrimaryExpression|](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression) propagates \\[?Yield, ?Await\\] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with \\[+Yield\\] and to |AwaitExpression| with \\[+Await\\] (and likewise [|StatementList|](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList) to |ClassDeclaration|). The engines that reject source like `function* f(){ class C { static foo = yield }; }` are treating the initializer as containing an _identifier_ that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC and engine262 parse per spec, although in evaluation JSC acts like the above and engine262 dies with an assertion failure:\n\n```\n$ eshost -h JavaScriptCore,engine262 -sx '\n  const iter = (function* f(){ return (class C { static foo = yield }).foo; })();\n  try {\n    print(JSON.stringify(iter.next(\"A\")));\n    print(JSON.stringify(iter.next(\"B\")));\n  } catch (err) { print(err); }\n'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\n{\"done\":true}\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>I do think the spec may be messed up here, because <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression\">|PrimaryExpression|</a> propagates [?Yield, ?Await] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with [+Yield] and to |AwaitExpression| with [+Await] (and likewise <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList\">|StatementList|</a> to |ClassDeclaration|). The engines that reject source like <code>function* f(){ class C { static foo = yield }; }</code> are treating the initializer as containing an <em>identifier</em> that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC and engine262 parse per spec, although in evaluation JSC acts like the above and engine262 dies with an assertion failure:</p>\n<pre><code>$ eshost -h JavaScriptCore,engine262 -sx '\n  const iter = (function* f(){ return (class C { static foo = yield }).foo; })();\n  try {\n    print(JSON.stringify(iter.next(\"A\")));\n    print(JSON.stringify(iter.next(\"B\")));\n  } catch (err) { print(err); }\n'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\n{\"done\":true}\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"I do think the spec may be messed up here, because [|PrimaryExpression|](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression) propagates \\[?Yield, ?Await\\] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with \\[+Yield\\] and to |AwaitExpression| with \\[+Await\\] (and likewise [|StatementList|](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList) to |ClassDeclaration|). The engines that reject source like `function* f(){ class C { static foo = yield }; }` are treating the initializer as containing an _identifier_ that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC and engine262 parse per spec, although in evaluation JSC acts like the above and engine262 dies with an assertion failure:\n\n```\n$ eshost -h JavaScriptCore,engine262 -sx '\n  const iter = (function* f(){ return (class C { static foo = yield }).foo; })();\n  try {\n    print(JSON.stringify(iter.next(\"A\")));\n    print(JSON.stringify(iter.next(\"B\")));\n  } catch (err) { print(err); }\n'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\n{\"done\":true}\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I do think the spec may be messed up here, because <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression\">|PrimaryExpression|</a> propagates [?Yield, ?Await] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with [+Yield] and to |AwaitExpression| with [+Await] (and likewise <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList\">|StatementList|</a> to |ClassDeclaration|). The engines that reject source like <code>function* f(){ class C { static foo = yield }; }</code> are treating the initializer as containing an <em>identifier</em> that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC and engine262 parse per spec, although in evaluation JSC acts like the above and engine262 dies with an assertion failure:</p>\n<pre><code>$ eshost -h JavaScriptCore,engine262 -sx '\n  const iter = (function* f(){ return (class C { static foo = yield }).foo; })();\n  try {\n    print(JSON.stringify(iter.next(\"A\")));\n    print(JSON.stringify(iter.next(\"B\")));\n  } catch (err) { print(err); }\n'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\n{\"done\":true}\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$xrMrzQFie1QTbo_LVsa9r--yvwlfVppDMdopGzyecM0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716332141375,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$6NuO96lLr4T3Xb7Kb-Sk_UhsHERLhy7-as7L7Stuhas"},
{"content":{"body":"I agree","m.mentions":{},"msgtype":"m.text"},"ts":1716332226752,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$ZyaFSzrRIFaltUuBqiV2f98McQkOFZZbHWYq4BBsH6A"},
{"content":{"body":"> <@bakkot:matrix.org> that one does have an explicit error I am almost certain\n\nyeah https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions-static-semantics-early-errors\n\n> It is a Syntax Error if |ClassStaticBlockStatementList| Contains `await` is true.\n","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$7z53fExol2hA2MqSJ9aZYht8g07sCND6X1YXyaGKlKw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>that one does have an explicit error I am almost certain</blockquote></mx-reply><p>yeah https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions-static-semantics-early-errors</p>\n<blockquote>\n<p>It is a Syntax Error if |ClassStaticBlockStatementList| Contains <code>await</code> is true.</p>\n</blockquote>\n","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$7z53fExol2hA2MqSJ9aZYht8g07sCND6X1YXyaGKlKw"}},"msgtype":"m.text"},"ts":1716332229804,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$NGQbjI_1tLUJ_jVcoE_HQCVlUxmYp_BdNjQfiP3Xtjo"},
{"content":{"body":"oh good","m.mentions":{},"msgtype":"m.text"},"ts":1716332275656,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$g0EzOn6nd1zAhqpESgIx-wfJuhbLYwL2lm5WzeX71P8"},
{"content":{"body":"whew","m.mentions":{},"msgtype":"m.text"},"ts":1716332284199,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$czgr1kTj_ARQAFF2XkkTK-_nF5rTYsAvSLvWMFqXRm0"},
{"content":{"body":"but that's only in `static { … }` blocks","format":"org.matrix.custom.html","formatted_body":"but that's only in <code>static { … }</code> blocks","m.mentions":{},"msgtype":"m.text"},"ts":1716332302733,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$oKVISzwuelAiHKfN9-XdZXTFMJwgc4VjkgqwJUK1_dU"},
{"content":{"body":"right","m.mentions":{},"msgtype":"m.text"},"ts":1716332309515,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$TOKKpO7dh6BT3Yu3q2EEKp5QAO8WU7aa3sNYmIKK5Nw"},
{"content":{"body":"https://github.com/tc39/ecma262/issues/3333","m.mentions":{},"msgtype":"m.text"},"ts":1716332577861,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Sq7xNuPFriXRaWiXhGaJnG08sj4ZQjJOvQfmBRa_EFA"},
{"content":{"body":" * I do think the spec may be messed up here, because [|PrimaryExpression|](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression) propagates \\[?Yield, ?Await\\] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with \\[+Yield\\] and to |AwaitExpression| with \\[+Await\\] (and likewise [|StatementList|](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList) to |ClassDeclaration|). The engines that reject source like `function* f(){ class C { static foo = yield }; }` are treating the initializer as containing an _identifier_ that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC parses per spec, although in evaluation it acts like the above (and engine262 dies with an assertion failure):\n\n```\n$ eshost -h JavaScriptCore,engine262 -sx '\n  print(\"START\");\n  const iter = (function* f(){ return (class C { static foo = yield }).foo; })();\n  try {\n    print(JSON.stringify(iter.next(\"A\")));\n    print(JSON.stringify(iter.next(\"B\")));\n  } catch (err) { print(err); }\n'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\nSTART\n{\"done\":true}\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>I do think the spec may be messed up here, because <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression\">|PrimaryExpression|</a> propagates [?Yield, ?Await] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with [+Yield] and to |AwaitExpression| with [+Await] (and likewise <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList\">|StatementList|</a> to |ClassDeclaration|). The engines that reject source like <code>function* f(){ class C { static foo = yield }; }</code> are treating the initializer as containing an <em>identifier</em> that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC parses per spec, although in evaluation it acts like the above (and engine262 dies with an assertion failure):</p>\n<pre><code>$ eshost -h JavaScriptCore,engine262 -sx '\n  print(\"START\");\n  const iter = (function* f(){ return (class C { static foo = yield }).foo; })();\n  try {\n    print(JSON.stringify(iter.next(\"A\")));\n    print(JSON.stringify(iter.next(\"B\")));\n  } catch (err) { print(err); }\n'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\nSTART\n{\"done\":true}\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"I do think the spec may be messed up here, because [|PrimaryExpression|](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression) propagates \\[?Yield, ?Await\\] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with \\[+Yield\\] and to |AwaitExpression| with \\[+Await\\] (and likewise [|StatementList|](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList) to |ClassDeclaration|). The engines that reject source like `function* f(){ class C { static foo = yield }; }` are treating the initializer as containing an _identifier_ that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC parses per spec, although in evaluation it acts like the above (and engine262 dies with an assertion failure):\n\n```\n$ eshost -h JavaScriptCore,engine262 -sx '\n  print(\"START\");\n  const iter = (function* f(){ return (class C { static foo = yield }).foo; })();\n  try {\n    print(JSON.stringify(iter.next(\"A\")));\n    print(JSON.stringify(iter.next(\"B\")));\n  } catch (err) { print(err); }\n'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\nSTART\n{\"done\":true}\n{\"done\":true}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I do think the spec may be messed up here, because <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PrimaryExpression\">|PrimaryExpression|</a> propagates [?Yield, ?Await] to |ClassExpression|, which propagates them to |FieldDefinition|, which propagates them to |Initializer|, which propagates them to |AssignmentExpression|, which can expand to |YieldExpression| with [+Yield] and to |AwaitExpression| with [+Await] (and likewise <a href=\"https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-StatementList\">|StatementList|</a> to |ClassDeclaration|). The engines that reject source like <code>function* f(){ class C { static foo = yield }; }</code> are treating the initializer as containing an <em>identifier</em> that is reserved in strict mode code, rather than as containing a yield expression. It seems that only JSC parses per spec, although in evaluation it acts like the above (and engine262 dies with an assertion failure):</p>\n<pre><code>$ eshost -h JavaScriptCore,engine262 -sx '\n  print(\"START\");\n  const iter = (function* f(){ return (class C { static foo = yield }).foo; })();\n  try {\n    print(JSON.stringify(iter.next(\"A\")));\n    print(JSON.stringify(iter.next(\"B\")));\n  } catch (err) { print(err); }\n'\n#### engine262\n\nAssertError: genContext.Generator !== undefined\n\n#### JavaScriptCore\nSTART\n{\"done\":true}\n{\"done\":true}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$xrMrzQFie1QTbo_LVsa9r--yvwlfVppDMdopGzyecM0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716332597557,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$9ZY-XMR5EFTs474AxUcnYYkC75DJ1nELjzcZbfvKkuk"}
]