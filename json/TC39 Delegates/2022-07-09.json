[
{"content":{"body":"> <@bakkot:matrix.org> also Rust's methods are all on the Iterator trait\n\nI think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$gMxp7U8PZERw9ddpdJ-djVfbiRVkJrDtiYbAbEe66pM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>also Rust&#39;s methods are all on the Iterator trait</blockquote></mx-reply>I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)","m.relates_to":{"m.in_reply_to":{"event_id":"$gMxp7U8PZERw9ddpdJ-djVfbiRVkJrDtiYbAbEe66pM"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@bakkot:matrix.org> also Rust's methods are all on the Iterator trait\n\nI think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$gMxp7U8PZERw9ddpdJ-djVfbiRVkJrDtiYbAbEe66pM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">@bakkot:matrix.org</a><br>also Rust&#39;s methods are all on the Iterator trait</blockquote></mx-reply>I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)","mimetype":"text/html"}]},"ts":1657358359162,"senderName":"HE Shi-Jun","senderId":"@haxjs:matrix.org","id":"$U6hTO-fCv-J9R-ASoIiHRyJw8Je70bOkKKziGzFcgdQ"},
{"content":{"body":"> <@ljharb:matrix.org> i'll fix the calendar, not sure where the current deadline event came from\n\nI guess it used the wrong timezone. :)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$3Odj_Bxn-ebWDoL0zpI4u6Ub_W97b0bHZZeApK25wM8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>i&#39;ll fix the calendar, not sure where the current deadline event came from</blockquote></mx-reply>I guess it used the wrong timezone. :)","m.relates_to":{"m.in_reply_to":{"event_id":"$3Odj_Bxn-ebWDoL0zpI4u6Ub_W97b0bHZZeApK25wM8"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@ljharb:matrix.org> i'll fix the calendar, not sure where the current deadline event came from\n\nI guess it used the wrong timezone. :)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$3Odj_Bxn-ebWDoL0zpI4u6Ub_W97b0bHZZeApK25wM8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>i&#39;ll fix the calendar, not sure where the current deadline event came from</blockquote></mx-reply>I guess it used the wrong timezone. :)","mimetype":"text/html"}]},"ts":1657358432925,"senderName":"HE Shi-Jun","senderId":"@haxjs:matrix.org","id":"$brIzcBZB1OZKz12xa3LqjStzj4VFPx0XaJ8gwZJlWuA"},
{"content":{"body":"> <@haxjs:matrix.org> I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)\n\nThis is true, but the fundamental fact remains: in Rust the helpers are on the one-shot thing.\n\nYes, in Rust the compiler will prevent you from making this particular mistake, whereas in JS you are more likely to get bit by it, so yes, there's a significant downside to using iterators that Rust does not have (though all the other languages I named do - nothing prevents you from trying to re-use a Java stream, e.g.).\n\nBut the most important question is whether the helpers are usable and clear when used _correctly_, and on that question, the compiler checks are irrelevant.\n\n(And there's similar problems with accidentally re-using helpers on _iterables_ in other non-rust languages, for that matter - see e.g. the second half of https://stackoverflow.com/a/28513908, which discusses the downsides of C#'s IEnumerable design which were explicitly considered when designing Java's Streams. We're all jealous of Rust's compile-time checks but we still have to design a language which works without them.)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$U6hTO-fCv-J9R-ASoIiHRyJw8Je70bOkKKziGzFcgdQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@haxjs:matrix.org\">@haxjs:matrix.org</a><br>I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)</blockquote></mx-reply><p>This is true, but the fundamental fact remains: in Rust the helpers are on the one-shot thing.</p>\n<p>Yes, in Rust the compiler will prevent you from making this particular mistake, whereas in JS you are more likely to get bit by it, so yes, there's a significant downside to using iterators that Rust does not have (though all the other languages I named do - nothing prevents you from trying to re-use a Java stream, e.g.).</p>\n<p>But the most important question is whether the helpers are usable and clear when used <em>correctly</em>, and on that question, the compiler checks are irrelevant.</p>\n<p>(And there's similar problems with accidentally re-using helpers on <em>iterables</em> in other non-rust languages, for that matter - see e.g. the second half of https://stackoverflow.com/a/28513908, which discusses the downsides of C#'s IEnumerable design which were explicitly considered when designing Java's Streams. We're all jealous of Rust's compile-time checks but we still have to design a language which works without them.)</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$U6hTO-fCv-J9R-ASoIiHRyJw8Je70bOkKKziGzFcgdQ"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@haxjs:matrix.org> I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)\n\nThis is true, but the fundamental fact remains: in Rust the helpers are on the one-shot thing.\n\nYes, in Rust the compiler will prevent you from making this particular mistake, whereas in JS you are more likely to get bit by it, so yes, there's a significant downside to using iterators that Rust does not have (though all the other languages I named do - nothing prevents you from trying to re-use a Java stream, e.g.).\n\nBut the most important question is whether the helpers are usable and clear when used _correctly_, and on that question, the compiler checks are irrelevant.\n\n(And there's similar problems with accidentally re-using helpers on _iterables_ in other non-rust languages, for that matter - see e.g. the second half of https://stackoverflow.com/a/28513908, which discusses the downsides of C#'s IEnumerable design which were explicitly considered when designing Java's Streams. We're all jealous of Rust's compile-time checks but we still have to design a language which works without them.)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$U6hTO-fCv-J9R-ASoIiHRyJw8Je70bOkKKziGzFcgdQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@haxjs:matrix.org\">@haxjs:matrix.org</a><br>I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)</blockquote></mx-reply><p>This is true, but the fundamental fact remains: in Rust the helpers are on the one-shot thing.</p>\n<p>Yes, in Rust the compiler will prevent you from making this particular mistake, whereas in JS you are more likely to get bit by it, so yes, there's a significant downside to using iterators that Rust does not have (though all the other languages I named do - nothing prevents you from trying to re-use a Java stream, e.g.).</p>\n<p>But the most important question is whether the helpers are usable and clear when used <em>correctly</em>, and on that question, the compiler checks are irrelevant.</p>\n<p>(And there's similar problems with accidentally re-using helpers on <em>iterables</em> in other non-rust languages, for that matter - see e.g. the second half of https://stackoverflow.com/a/28513908, which discusses the downsides of C#'s IEnumerable design which were explicitly considered when designing Java's Streams. We're all jealous of Rust's compile-time checks but we still have to design a language which works without them.)</p>\n","mimetype":"text/html"}]},"ts":1657392014795,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$yO2dcQAv3cFjlPiJXYJz1Vda11WF0vvh2UhbZ_h6ch4"},
{"content":{"body":"I vaguely remember that someone a few years ago (was it Domenic Denicola?) trying to figure out in a GitHub Issue if we could ever have chained numeric comparisons like `x <= y < z`—and that sadly the person found that there was no way. Does anyone have a link to that thread?","format":"org.matrix.custom.html","formatted_body":"I vaguely remember that someone a few years ago (was it Domenic Denicola?) trying to figure out in a GitHub Issue if we could ever have chained numeric comparisons like <code>x &lt;= y &lt; z</code>—and that sadly the person found that there was no way. Does anyone have a link to that thread?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I vaguely remember that someone a few years ago (was it Domenic Denicola?) trying to figure out in a GitHub Issue if we could ever have chained numeric comparisons like `x <= y < z`—and that sadly the person found that there was no way. Does anyone have a link to that thread?","mimetype":"text/plain"},{"body":"I vaguely remember that someone a few years ago (was it Domenic Denicola?) trying to figure out in a GitHub Issue if we could ever have chained numeric comparisons like <code>x &lt;= y &lt; z</code>—and that sadly the person found that there was no way. Does anyone have a link to that thread?","mimetype":"text/html"}]},"ts":1657393424851,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$cZ2_ZUUOUdI8mpO2gGnn91sgNW4eLSryjMZN5Lz1few"}
]