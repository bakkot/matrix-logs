[
{"content":{"body":"Hongbo is suggesting the iterator protocol has a high performance overhead (25x perf loss).  Do we know if this is cost is effectively mandated in the spec, or is this just a unfulfilled optimization opportunity in engines?\n\nhttps://www.moonbitlang.com/blog/js-support#benchmark-code-execution-speed-exceeds-javascript-by-25-times","m.mentions":{},"msgtype":"m.text"},"ts":1714725395790,"senderName":"Rob Palmer","senderId":"@robpalme:matrix.org","id":"$i0qEujKlxqVd-TMhxsP33nhxOVhs9Kee-apHDkuRc3I"},
{"content":{"body":"My hope is that engines could optimize Array iteration, but I'm not sure about other cases","msgtype":"m.text"},"ts":1714728957697,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Mzmd3Cq2_4UMGNwUg3Vnct7cM3wNMQXVahiX3WGQHo8"},
{"content":{"body":"With something like iterator helpers, engines could theoretically optimize some parts of iteration knowing the shapes of the inputs and the whole of the graph of iteration operations. It's no small task, though, as it requires verifying that no intermediate steps are observable (proxies, user-defined iterators, patched methods, etc.). ","format":"org.matrix.custom.html","formatted_body":"With something like iterator helpers, engines could theoretically optimize some parts of iteration knowing the shapes of the inputs and the whole of the graph of iteration operations. It's no small task, though, as it requires verifying that no intermediate steps are observable (proxies, user-defined iterators, patched methods, etc.).","msgtype":"m.text"},"ts":1714729557326,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$obKgSVNY4ud0272RYC1IB5iGuJ6gKFtPIlDk1Hpu6Dk"},
{"content":{"body":"Engines brought up the overhead of the iteration protocol at the most recent TC39 meeting, as a source of hesitation for the pattern matching proposal's semantics","m.mentions":{},"msgtype":"m.text"},"ts":1714748365036,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$RmHPuNtOAVejcs8ifxr4qLA6DYliUYFEeAk_4QpklwM"},
{"content":{"body":"engines *sometimes* can reduce or eliminate the overhead in particular cases (e.g., for-of loops over Arrays, as long as you didn't mess with Array.prototype too much) but these optimizations are fragile and difficult to generalize","format":"org.matrix.custom.html","formatted_body":"engines <em>sometimes</em> can reduce or eliminate the overhead in particular cases (e.g., for-of loops over Arrays, as long as you didn't mess with Array.prototype too much) but these optimizations are fragile and difficult to generalize","m.mentions":{},"msgtype":"m.text"},"ts":1714748416499,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$x5HhVWsSnbk64epCND29q7oMDU4MEj0M4_iWG88mzv0"},
{"content":{"body":"I think if we were to do the iteration protocol today, we'd do it differently. But at this point, it'd be expensive to have multiple iteration protocols...","m.mentions":{},"msgtype":"m.text"},"ts":1714748447160,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9-f9zwtYF1p_UrU2dUZv6yTIx8051YOPMxdsROvTls8"},
{"content":{"body":"see some discussion earlier: https://matrixlogs.bakkot.com/TC39_Delegates/2024-04-25#L21","m.mentions":{},"msgtype":"m.text"},"ts":1714748470893,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$kidX7iTTR8ZCTJENWcdub-Mfkvxt9ovZZvdpbTvb0AY"},
{"content":{"body":"that said there is a lot of room for optimizing iterators, in many cases without much in the way of performance cliffs","m.mentions":{},"msgtype":"m.text"},"ts":1714748538535,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$_e3CAk8yCkcHhj2HmIGWH6OHULzDmsUvu0ehthRr3R4"},
{"content":{"body":"it's just a lot of work","m.mentions":{},"msgtype":"m.text"},"ts":1714748556702,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$k6h7DPiC6OrzkFqFowa8D55FMQpojSM9_6zgfd3IA-Y"},
{"content":{"body":"(also it is extremely unlikely to ever be as fast as a bare loop, even with a huge amount of work)","m.mentions":{},"msgtype":"m.text"},"ts":1714748960345,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$owq2sEB1ethehR4Rci9KyKZVk9sqb034E4QkhzgPAL0"},
{"content":{"body":"if we are interested in making iterator helpers faster, something we _could_ do is make all the `{ next, done }` pairs yielded by a given call to an iterator helper be the same object","format":"org.matrix.custom.html","formatted_body":"if we are interested in making iterator helpers faster, something we <em>could</em> do is make all the <code>{ next, done }</code> pairs yielded by a given call to an iterator helper be the same object","m.mentions":{},"msgtype":"m.text"},"ts":1714749384663,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$TYKF-JTFyH5rhHv2xHp_3rnxNBprihVBxvcarmwFRzM"},
{"content":{"body":" * if we are interested in making iterator helpers faster, something we _could_ do is make all the `{ value, done }` pairs yielded by a given call to an iterator helper be the same object","format":"org.matrix.custom.html","formatted_body":" * if we are interested in making iterator helpers faster, something we <em>could</em> do is make all the <code>{ value, done }</code> pairs yielded by a given call to an iterator helper be the same object","m.mentions":{},"m.new_content":{"body":"if we are interested in making iterator helpers faster, something we _could_ do is make all the `{ value, done }` pairs yielded by a given call to an iterator helper be the same object","format":"org.matrix.custom.html","formatted_body":"if we are interested in making iterator helpers faster, something we <em>could</em> do is make all the <code>{ value, done }</code> pairs yielded by a given call to an iterator helper be the same object","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$TYKF-JTFyH5rhHv2xHp_3rnxNBprihVBxvcarmwFRzM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1714749414739,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$4GBt06fFbLGyzLMCx4znu1kMf_kbEgPmBRJAUu_yL04"},
{"content":{"body":"so like\n\n```js\nfunction map(fn) {\n  let result = { value, done }; // probably with those properties being non-configurable\n  let underlying = this;\n  return {\n    next() {\n      let { value, done } = underlying.next();\n      if (!done) value = fn(value);\n      result.value = value;\n      result.done = done;\n      return result;\n    }\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>so like</p>\n<pre><code class=\"language-js\">function map(fn) {\n  let result = { value, done }; // probably with those properties being non-configurable\n  let underlying = this;\n  return {\n    next() {\n      let { value, done } = underlying.next();\n      if (!done) value = fn(value);\n      result.value = value;\n      result.done = done;\n      return result;\n    }\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1714749530345,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ShihEp0qyobcWxdiMWswvk_Ixn7C9zubQXy6yLeOejI"},
{"content":{"body":"this would avoid most of the overhead and no one would ever notice","m.mentions":{},"msgtype":"m.text"},"ts":1714749546588,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$MVQBTlxK0UitKcc09ycHIH2A8npHbKNIfrE4AR56Qw8"},
{"content":{"body":"but it is, as littledan indicates, conceptually quite gross","format":"org.matrix.custom.html","formatted_body":"but it is, as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> indicates, conceptually quite gross","m.mentions":{"user_ids":["@littledan:matrix.org"]},"msgtype":"m.text"},"ts":1714749554911,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$mQQxcm5eKxEwDYJ1dOZfd5m3wfQ3Pd9skQ8psAs21lU"},
{"content":{"body":"> <@robpalme:matrix.org> Hongbo is suggesting the iterator protocol has a high performance overhead (25x perf loss).  Do we know if this is cost is effectively mandated in the spec, or is this just a unfulfilled optimization opportunity in engines?\n> \n> https://www.moonbitlang.com/blog/js-support#benchmark-code-execution-speed-exceeds-javascript-by-25-times\n\nBoth? The iterator protocol imposes a lot of complexity; some of that complexity can be optimized through heroic work in JS engines (and has been!)... but the heroics mean that it's costly to do, particularly in any generalizable fashion. \n\nI haven't looked at Iterator Helpers in a long while, but I'll bet they could certainly have more optimization applied over time, but I suspect a similar story applies: Could we make them faster? Sure, but that work displaces other work, and so we need to see it as important enough. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$i0qEujKlxqVd-TMhxsP33nhxOVhs9Kee-apHDkuRc3I?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@robpalme:matrix.org\">@robpalme:matrix.org</a><br>Hongbo is suggesting the iterator protocol has a high performance overhead (25x perf loss).  Do we know if this is cost is effectively mandated in the spec, or is this just a unfulfilled optimization opportunity in engines?<br/><br/>https://www.moonbitlang.com/blog/js-support#benchmark-code-execution-speed-exceeds-javascript-by-25-times</blockquote></mx-reply><p>Both? The iterator protocol imposes a lot of complexity; some of that complexity can be optimized through heroic work in JS engines (and has been!)... but the heroics mean that it's costly to do, particularly in any generalizable fashion.</p>\n<p>I haven't looked at Iterator Helpers in a long while, but I'll bet they could certainly have more optimization applied over time, but I suspect a similar story applies: Could we make them faster? Sure, but that work displaces other work, and so we need to see it as important enough.</p>\n","m.mentions":{"user_ids":["@robpalme:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$i0qEujKlxqVd-TMhxsP33nhxOVhs9Kee-apHDkuRc3I"}},"msgtype":"m.text"},"ts":1714751202117,"senderName":"mgaudet","senderId":"@mgaudet:mozilla.org","id":"$sD3zQb3_hBNR_ft4fLFIYjo0kz_KKNyF0HvMU_D6aMQ"},
{"content":{"body":"by coincidence I just read an article which  touches on performance of array destructuring, which is the same problem https://www.figma.com/blog/figmas-journey-to-typescript-compiling-away-our-custom-programming-language/#performance-issues-with-array-destructuring","m.mentions":{},"msgtype":"m.text"},"ts":1714751787036,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$esjFLdTIB33QUwJF6JOHKnC-DB0DyjqNsgAaQmN1iw0"}
]