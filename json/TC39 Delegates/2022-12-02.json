[
{"content":{"body":"> <@alex.vincent:matrix.org> rbuckton: I do want to confer with you sometime in December (but not in the next few days) about the resource management, cancellation, and proxy revocation proposals.  Do you attend SES's strategy sessions occasionally?\n\nI haven't so far, mostly due to time constraints. I can make some time though.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$LXcsRgGKx716dB1BpIkXhnawacNsZvwcW76_qLdGsAQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@alex.vincent:matrix.org\">@alex.vincent:matrix.org</a><br><a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: I do want to confer with you sometime in December (but not in the next few days) about the resource management, cancellation, and proxy revocation proposals.  Do you attend SES's strategy sessions occasionally?</blockquote></mx-reply>I haven't so far, mostly due to time constraints. I can make some time though.","m.relates_to":{"m.in_reply_to":{"event_id":"$LXcsRgGKx716dB1BpIkXhnawacNsZvwcW76_qLdGsAQ"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@alex.vincent:matrix.org> rbuckton: I do want to confer with you sometime in December (but not in the next few days) about the resource management, cancellation, and proxy revocation proposals.  Do you attend SES's strategy sessions occasionally?\n\nI haven't so far, mostly due to time constraints. I can make some time though.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$LXcsRgGKx716dB1BpIkXhnawacNsZvwcW76_qLdGsAQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@alex.vincent:matrix.org\">@alex.vincent:matrix.org</a><br><a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: I do want to confer with you sometime in December (but not in the next few days) about the resource management, cancellation, and proxy revocation proposals.  Do you attend SES's strategy sessions occasionally?</blockquote></mx-reply>I haven't so far, mostly due to time constraints. I can make some time though.","mimetype":"text/html"}]},"ts":1669940625827,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SO8IKp_ZFPn_YSR100cEvW8GdnXGd4ZLNhHI60Kkz6o"},
{"content":{"body":"My suggestion was to just close over regular bindings, and when serializing determine if the binding is:\n\n1. rewritable (i.e., globals)\n2. serializable (such as another `module`)\n3. non-portable (anything else)\nand throw if there are any non-portable values.\n\nA side benefit would be that it would be an error to accidentally reference a variable that shadows a global.","format":"org.matrix.custom.html","formatted_body":"<p>My suggestion was to just close over regular bindings, and when serializing determine if the binding is:</p>\n<ol>\n<li>rewritable (i.e., globals)</li>\n<li>serializable (such as another <code>module</code>)</li>\n<li>non-portable (anything else)<br>and throw if there are any non-portable values.</li>\n</ol>\n<p>A side benefit would be that it would be an error to accidentally reference a variable that shadows a global.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"My suggestion was to just close over regular bindings, and when serializing determine if the binding is:\n\n1. rewritable (i.e., globals)\n2. serializable (such as another `module`)\n3. non-portable (anything else)\nand throw if there are any non-portable values.\n\nA side benefit would be that it would be an error to accidentally reference a variable that shadows a global.","mimetype":"text/plain"},{"body":"<p>My suggestion was to just close over regular bindings, and when serializing determine if the binding is:</p>\n<ol>\n<li>rewritable (i.e., globals)</li>\n<li>serializable (such as another <code>module</code>)</li>\n<li>non-portable (anything else)<br>and throw if there are any non-portable values.</li>\n</ol>\n<p>A side benefit would be that it would be an error to accidentally reference a variable that shadows a global.</p>\n","mimetype":"text/html"}],"m.relates_to":{"m.in_reply_to":{"event_id":"$P9TwzPG7Qr3PhAyChKux2JqhUc_1mh4_Z79qxkQ2LRk"}}},"ts":1669940897138,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UHXhzVOvGqNkK84zWxXmF_6YAY4HYnveTVUNkd9AZS0"},
{"content":{"body":" * My suggestion was to just close over regular bindings, and when serializing determine if the binding is:\n\n1. rewritable (i.e., globals)\n2. serializable (such as another `module`)\n3. non-portable (anything else)\nand throw if there are any non-portable values.\n\nA side benefit would be that it would be an error to accidentally reference a variable that shadows a global.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$P9TwzPG7Qr3PhAyChKux2JqhUc_1mh4_Z79qxkQ2LRk?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br><p>Honestly it sounds like we're starting to get at, module fragments should be in a separate namespace. Neither variables nor strings, but a secret third thing. As an obviously unusable strawman, let's say they begin with <code>##</code> :). So the example would be:</p>\n<pre><code class=\"language-js\">module ##a { let b = getAModule(); await import(b); /* obviously targets the lexically scoped variable */ }\nmodule ##b { import ##a; /* obviously targets the module declaration */ }\n</code></pre>\n</blockquote></mx-reply> * <p>My suggestion was to just close over regular bindings, and when serializing determine if the binding is:</p>\n<ol>\n<li>rewritable (i.e., globals)</li>\n<li>serializable (such as another <code>module</code>)</li>\n<li>non-portable (anything else)<br>and throw if there are any non-portable values.</li>\n</ol>\n<p>A side benefit would be that it would be an error to accidentally reference a variable that shadows a global.</p>\n","m.new_content":{"body":"My suggestion was to just close over regular bindings, and when serializing determine if the binding is:\n\n1. rewritable (i.e., globals)\n2. serializable (such as another `module`)\n3. non-portable (anything else)\nand throw if there are any non-portable values.\n\nA side benefit would be that it would be an error to accidentally reference a variable that shadows a global.","format":"org.matrix.custom.html","formatted_body":"<p>My suggestion was to just close over regular bindings, and when serializing determine if the binding is:</p>\n<ol>\n<li>rewritable (i.e., globals)</li>\n<li>serializable (such as another <code>module</code>)</li>\n<li>non-portable (anything else)<br>and throw if there are any non-portable values.</li>\n</ol>\n<p>A side benefit would be that it would be an error to accidentally reference a variable that shadows a global.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"My suggestion was to just close over regular bindings, and when serializing determine if the binding is:\n\n1. rewritable (i.e., globals)\n2. serializable (such as another `module`)\n3. non-portable (anything else)\nand throw if there are any non-portable values.\n\nA side benefit would be that it would be an error to accidentally reference a variable that shadows a global.","mimetype":"text/plain"},{"body":"<p>My suggestion was to just close over regular bindings, and when serializing determine if the binding is:</p>\n<ol>\n<li>rewritable (i.e., globals)</li>\n<li>serializable (such as another <code>module</code>)</li>\n<li>non-portable (anything else)<br>and throw if there are any non-portable values.</li>\n</ol>\n<p>A side benefit would be that it would be an error to accidentally reference a variable that shadows a global.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$UHXhzVOvGqNkK84zWxXmF_6YAY4HYnveTVUNkd9AZS0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * My suggestion was to just close over regular bindings, and when serializing determine if the binding is:\n\n1. rewritable (i.e., globals)\n2. serializable (such as another `module`)\n3. non-portable (anything else)\nand throw if there are any non-portable values.\n\nA side benefit would be that it would be an error to accidentally reference a variable that shadows a global.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$P9TwzPG7Qr3PhAyChKux2JqhUc_1mh4_Z79qxkQ2LRk?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br><p>Honestly it sounds like we're starting to get at, module fragments should be in a separate namespace. Neither variables nor strings, but a secret third thing. As an obviously unusable strawman, let's say they begin with <code>##</code> :). So the example would be:</p>\n<pre><code class=\"language-js\">module ##a { let b = getAModule(); await import(b); /* obviously targets the lexically scoped variable */ }\nmodule ##b { import ##a; /* obviously targets the module declaration */ }\n</code></pre>\n</blockquote></mx-reply> * <p>My suggestion was to just close over regular bindings, and when serializing determine if the binding is:</p>\n<ol>\n<li>rewritable (i.e., globals)</li>\n<li>serializable (such as another <code>module</code>)</li>\n<li>non-portable (anything else)<br>and throw if there are any non-portable values.</li>\n</ol>\n<p>A side benefit would be that it would be an error to accidentally reference a variable that shadows a global.</p>\n","mimetype":"text/html"}]},"ts":1669940920867,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PlYf0hxCvO8MfawG1h6I__c12sQtuZIlzs4U2Jjv5do"},
{"content":{"body":"To further clarify, we'd determine if a _binding_ is rewritable or not rewritable, and if the binding is not rewritable, determine if its _value_ is portable (i.e., serializable) or non-portable.","format":"org.matrix.custom.html","formatted_body":"To further clarify, we'd determine if a <em>binding</em> is rewritable or not rewritable, and if the binding is not rewritable, determine if its <em>value</em> is portable (i.e., serializable) or non-portable.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"To further clarify, we'd determine if a _binding_ is rewritable or not rewritable, and if the binding is not rewritable, determine if its _value_ is portable (i.e., serializable) or non-portable.","mimetype":"text/plain"},{"body":"To further clarify, we'd determine if a <em>binding</em> is rewritable or not rewritable, and if the binding is not rewritable, determine if its <em>value</em> is portable (i.e., serializable) or non-portable.","mimetype":"text/html"}]},"ts":1669940978541,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wy_I9y-pVrlrDdZ8Nbe_VFCy6P9W_Qtbc8B1b_B7I80"},
{"content":{"body":"When blöcks was presented, there was a lot of skepticism about this particular aspect of the proposal. It is very deliberate that module blocks omits it.","msgtype":"m.text"},"ts":1669941006573,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$17Xi1UgMPeo-qiLdz7w9DPexXZtmGd4lblT4S25_nj4"},
{"content":{"body":"I honestly don’t understand how we could make this mechanism work well enough, given how dynamic JS is and how this committee tries to meet expectations of all the edge cases working well (eg with eval)","msgtype":"m.text"},"ts":1669941079235,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hBGAZMfldFqGepkE_OvK88OJCzB5FNTq00tDvIzJW88"},
{"content":{"body":"I like that you have some details spelled out though ","format":"org.matrix.custom.html","formatted_body":"I like that you have some details spelled out though","msgtype":"m.text"},"ts":1669941105546,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$AfnrLpeVPt2lLlFdYmWmUjBfrsB6iUmqIyW1BoRUBaM"},
{"content":{"body":"IIRC, the blöcks proposal wanted you to substitute the bindings explicitly when you instantiated the block ","msgtype":"m.text","org.matrix.msc1767.text":"IIRC, the blöcks proposal wanted you to substitute the bindings explicitly when you instantiated the block "},"ts":1669941165145,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hzt3K2K9kkaGD6JaSQ4X6c5WOwnxaBsXNHPD3JNdtFc"},
{"content":{"body":"In particular I don’t know how “rewritable” would work. Module blocks is content with just reevaluating in the other realm.","msgtype":"m.text"},"ts":1669941177831,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$j5r4a-iouwGwXCC8o42S6gvqr3lkkKpGIh-akdTanwM"},
{"content":{"body":"> <@littledan:matrix.org> In particular I don’t know how “rewritable” would work. Module blocks is content with just reevaluating in the other realm.\n\nThat's exactly what I mean by rewritable: \"these are the things that you just reevaluate in the other realm\"","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$j5r4a-iouwGwXCC8o42S6gvqr3lkkKpGIh-akdTanwM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>In particular I don’t know how “rewritable” would work. Module blocks is content with just reevaluating in the other realm.</blockquote></mx-reply>That's exactly what I mean by rewritable: &quot;these are the things that you just reevaluate in the other realm&quot;","m.relates_to":{"m.in_reply_to":{"event_id":"$j5r4a-iouwGwXCC8o42S6gvqr3lkkKpGIh-akdTanwM"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> In particular I don’t know how “rewritable” would work. Module blocks is content with just reevaluating in the other realm.\n\nThat's exactly what I mean by rewritable: \"these are the things that you just reevaluate in the other realm\"","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$j5r4a-iouwGwXCC8o42S6gvqr3lkkKpGIh-akdTanwM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>In particular I don’t know how “rewritable” would work. Module blocks is content with just reevaluating in the other realm.</blockquote></mx-reply>That's exactly what I mean by rewritable: &quot;these are the things that you just reevaluate in the other realm&quot;","mimetype":"text/html"}]},"ts":1669941209309,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$sOeyvPyAcsYcw8YHEAcgcxejg0eM25QhKgVmw6J2Hhs"},
{"content":{"body":"Ah Ok","msgtype":"m.text"},"ts":1669941216922,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$AW9HMwjgMw8cdA8ogRbO1iLVg9M1vUmqMit_LCD05-c"},
{"content":{"body":"The current proposal allows you to lexically reference another `module` and explicitly breaks that model, since you're not just looking up that name in another realm.","format":"org.matrix.custom.html","formatted_body":"The current proposal allows you to lexically reference another <code>module</code> and explicitly breaks that model, since you're not just looking up that name in another realm.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The current proposal allows you to lexically reference another `module` and explicitly breaks that model, since you're not just looking up that name in another realm.","mimetype":"text/plain"},{"body":"The current proposal allows you to lexically reference another <code>module</code> and explicitly breaks that model, since you're not just looking up that name in another realm.","mimetype":"text/html"}]},"ts":1669941245021,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xp5HrrmO0IGKB9zgUI-YA6P1T2qc56RLTPgu7GGEZ2E"},
{"content":{"body":" * The current proposal allows you to lexically reference another `module` and explicitly breaks that model, since you're not just looking up that name in another realm.","format":"org.matrix.custom.html","formatted_body":" * The current proposal allows you to lexically reference another <code>module</code> and explicitly breaks that model, since you're not just looking up that name in another realm.","m.new_content":{"body":"The current proposal allows you to lexically reference another `module` and explicitly breaks that model, since you're not just looking up that name in another realm.","format":"org.matrix.custom.html","formatted_body":"The current proposal allows you to lexically reference another <code>module</code> and explicitly breaks that model, since you're not just looking up that name in another realm.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The current proposal allows you to lexically reference another `module` and explicitly breaks that model, since you're not just looking up that name in another realm.","mimetype":"text/plain"},{"body":"The current proposal allows you to lexically reference another <code>module</code> and explicitly breaks that model, since you're not just looking up that name in another realm.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$xp5HrrmO0IGKB9zgUI-YA6P1T2qc56RLTPgu7GGEZ2E","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * The current proposal allows you to lexically reference another `module` and explicitly breaks that model, since you're not just looking up that name in another realm.","mimetype":"text/plain"},{"body":" * The current proposal allows you to lexically reference another <code>module</code> and explicitly breaks that model, since you're not just looking up that name in another realm.","mimetype":"text/html"}]},"ts":1669941261843,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xGElc9LGSlgLXCe2MO2aC2g4BN924I7tQBVxlr91vTo"},
{"content":{"body":"So the other thing is, given module blocks, you can define a system which serializes a list of things and then passes them as arguments to a default-exported function. I guess a bit more unergonomic due to the duplication though.","msgtype":"m.text"},"ts":1669941278139,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$AwhIBHugvApgRTNQ0wTXtTjYf5NM4tmNTOBCtm_fWog"},
{"content":{"body":"> <@littledan:matrix.org> So the other thing is, given module blocks, you can define a system which serializes a list of things and then passes them as arguments to a default-exported function. I guess a bit more unergonomic due to the duplication though.\n\nI had thought of that approach when I discussed the proposal with my team on Monday.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$AwhIBHugvApgRTNQ0wTXtTjYf5NM4tmNTOBCtm_fWog?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>So the other thing is, given module blocks, you can define a system which serializes a list of things and then passes them as arguments to a default-exported function. I guess a bit more unergonomic due to the duplication though.</blockquote></mx-reply>I had thought of that approach when I discussed the proposal with my team on Monday.","m.relates_to":{"m.in_reply_to":{"event_id":"$AwhIBHugvApgRTNQ0wTXtTjYf5NM4tmNTOBCtm_fWog"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> So the other thing is, given module blocks, you can define a system which serializes a list of things and then passes them as arguments to a default-exported function. I guess a bit more unergonomic due to the duplication though.\n\nI had thought of that approach when I discussed the proposal with my team on Monday.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$AwhIBHugvApgRTNQ0wTXtTjYf5NM4tmNTOBCtm_fWog?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>So the other thing is, given module blocks, you can define a system which serializes a list of things and then passes them as arguments to a default-exported function. I guess a bit more unergonomic due to the duplication though.</blockquote></mx-reply>I had thought of that approach when I discussed the proposal with my team on Monday.","mimetype":"text/html"}]},"ts":1669941316766,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dFgFn51L_WM-Q-nGhs7ru3zrkjfh1CBrGbUp3D5AtKs"},
{"content":{"body":"> <@rbuckton:matrix.org> The current proposal allows you to lexically reference another `module` and explicitly breaks that model, since you're not just looking up that name in another realm.\n\nYeah, I can empathize with this; this is why I raised the separate namespace idea above","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw%3Amatrix.org/%24xp5HrrmO0IGKB9zgUI-YA6P1T2qc56RLTPgu7GGEZ2E\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>The current proposal allows you to lexically reference another <code>module</code> and explicitly breaks that model, since you're not just looking up that name in another realm.</blockquote></mx-reply>Yeah, I can empathize with this; this is why I raised the separate namespace idea above","m.relates_to":{"m.in_reply_to":{"event_id":"$xp5HrrmO0IGKB9zgUI-YA6P1T2qc56RLTPgu7GGEZ2E"}},"msgtype":"m.text"},"ts":1669941330078,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$JPUs7-Kmp8d-DHdvpCexU6n9R4pb594Fy9dF8GL2Zdg"},
{"content":{"body":"Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the `Module`, which would mean no lexical scoping.","format":"org.matrix.custom.html","formatted_body":"Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the <code>Module</code>, which would mean no lexical scoping.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the `Module`, which would mean no lexical scoping.","mimetype":"text/plain"},{"body":"Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the <code>Module</code>, which would mean no lexical scoping.","mimetype":"text/html"}]},"ts":1669941362512,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$d3dxPR4l3RBes3ccwr05BLmP23HTeJPczyEwLORqSLg"},
{"content":{"body":"That would still work with bundlers, though they'd need to emit a chunk of code at the bottom of the file that linked all of the declarations together.","msgtype":"m.text","org.matrix.msc1767.text":"That would still work with bundlers, though they'd need to emit a chunk of code at the bottom of the file that linked all of the declarations together."},"ts":1669941399013,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Udq4a7K_9QSXrxafHC2O7J2YTOKR7hNU3xVb1HwY9wI"},
{"content":{"body":" * Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the `Module`, which would mean no lexical scoping.","format":"org.matrix.custom.html","formatted_body":" * Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the <code>Module</code>, which would mean no lexical scoping.","m.new_content":{"body":"Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the `Module`, which would mean no lexical scoping.","format":"org.matrix.custom.html","formatted_body":"Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the <code>Module</code>, which would mean no lexical scoping.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the `Module`, which would mean no lexical scoping.","mimetype":"text/plain"},{"body":"Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the <code>Module</code>, which would mean no lexical scoping.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$d3dxPR4l3RBes3ccwr05BLmP23HTeJPczyEwLORqSLg","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the `Module`, which would mean no lexical scoping.","mimetype":"text/plain"},{"body":" * Another approach would be to go the WASM route where you have to explicitly provide any external module references when instantiating the <code>Module</code>, which would mean no lexical scoping.","mimetype":"text/html"}]},"ts":1669941413662,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$AHtKNEjQL-UNubDB6iQEr2qKCYwtttV4G1x4Xtia0FY"},
{"content":{"body":"Yeah, Nicolo has sketched out this chunk of code in a gist. It would work with module expressions + the importHook in the module constructor","msgtype":"m.text"},"ts":1669941432734,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Tp9dvw4_tlkl8psgsGggvFt6ShQ9tgf74Gqz-aWCAYU"},
{"content":{"body":"I got the impression that V8 was highly skeptical of this hook. Module declarations are more limited in expressiveness; more “static”","msgtype":"m.text"},"ts":1669941461912,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$mK0G27fXmiQvVWCk-OmFl6tvmPjAQQbRAQMYAtFZ8-w"},
{"content":{"body":"Anyway there are probably bundler use cases that need the dynamic hook","msgtype":"m.text"},"ts":1669941479823,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Aal6LzA1aillr00iwGHslBdFwEzvMz6F5aMxHW-I4T0"},
{"content":{"body":"If there was no lexical closure for modules, you could still have `import {} from id` but you'd need to define those ids when instantiating the module, i.e. `await import(module { import foo; }, { bindings: { foo: module {} } })`","format":"org.matrix.custom.html","formatted_body":"If there was no lexical closure for modules, you could still have <code>import {} from id</code> but you'd need to define those ids when instantiating the module, i.e. <code>await import(module { import foo; }, { bindings: { foo: module {} } })</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"If there was no lexical closure for modules, you could still have `import {} from id` but you'd need to define those ids when instantiating the module, i.e. `await import(module { import foo; }, { bindings: { foo: module {} } })`","mimetype":"text/plain"},{"body":"If there was no lexical closure for modules, you could still have <code>import {} from id</code> but you'd need to define those ids when instantiating the module, i.e. <code>await import(module { import foo; }, { bindings: { foo: module {} } })</code>","mimetype":"text/html"}]},"ts":1669941529064,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SJTkXRY3RdnIkXJvXICDRYZ3Olk21eL6o9tNQoirn0M"},
{"content":{"body":"> <@rbuckton:matrix.org> That would still work with bundlers, though they'd need to emit a chunk of code at the bottom of the file that linked all of the declarations together.\n\nThis is consistent with what’s possible with just module expressions and the Module constructor.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$Udq4a7K_9QSXrxafHC2O7J2YTOKR7hNU3xVb1HwY9wI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>That would still work with bundlers, though they&#39;d need to emit a chunk of code at the bottom of the file that linked all of the declarations together.</blockquote></mx-reply>This is consistent with what’s possible with just module expressions and the Module constructor.","m.relates_to":{"m.in_reply_to":{"event_id":"$Udq4a7K_9QSXrxafHC2O7J2YTOKR7hNU3xVb1HwY9wI"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> That would still work with bundlers, though they'd need to emit a chunk of code at the bottom of the file that linked all of the declarations together.\n\nThis is consistent with what’s possible with just module expressions and the Module constructor.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$Udq4a7K_9QSXrxafHC2O7J2YTOKR7hNU3xVb1HwY9wI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>That would still work with bundlers, though they&#39;d need to emit a chunk of code at the bottom of the file that linked all of the declarations together.</blockquote></mx-reply>This is consistent with what’s possible with just module expressions and the Module constructor.","mimetype":"text/html"}]},"ts":1669941541529,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$WygcSRjJWCFFTflhJBJvCvBTNsEdjtVcy364H1-Tx0M"},
{"content":{"body":"That would be roughly analogous to the blocks proposal where you'd need to supply values for bindings.","msgtype":"m.text","org.matrix.msc1767.text":"That would be roughly analogous to the blocks proposal where you'd need to supply values for bindings."},"ts":1669941562765,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7jRtEnPJbGG1SVd1520MzGGvDiOeWxhO0QEz1ySz564"},
{"content":{"body":" * That would be roughly analogous to the blöcks proposal where you'd need to supply values for bindings.","m.new_content":{"body":"That would be roughly analogous to the blöcks proposal where you'd need to supply values for bindings.","msgtype":"m.text","org.matrix.msc1767.text":"That would be roughly analogous to the blöcks proposal where you'd need to supply values for bindings."},"m.relates_to":{"event_id":"$7jRtEnPJbGG1SVd1520MzGGvDiOeWxhO0QEz1ySz564","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * That would be roughly analogous to the blöcks proposal where you'd need to supply values for bindings."},"ts":1669941617439,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$A-QT4EtCpOAWKsLZgo9HbOdCFmgboNOZLvauiVj5LVo"},
{"content":{"body":"Concretely, this is Nicolò’s sketch of a module expression and Module constructor bundle generator https://gist.github.com/nicolo-ribaudo/81f18db096659ac8447ca94f50f2c37a","msgtype":"m.text","org.matrix.msc1767.text":"Concretely, this is Nicolò’s sketch of a module expression and Module constructor bundle generator https://gist.github.com/nicolo-ribaudo/81f18db096659ac8447ca94f50f2c37a"},"ts":1669941665712,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$js14EC41fLDi_60mUXdxSYuKpVtj8TGHreK1YQrjdjQ"},
{"content":{"body":"You could even do that with module declarations and stitch them together using a `with` clause:\n\n```js\nmodule foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n```","format":"org.matrix.custom.html","formatted_body":"<p>You could even do that with module declarations and stitch them together using a <code>with</code> clause:</p>\n<pre><code class=\"language-js\">module foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"You could even do that with module declarations and stitch them together using a `with` clause:\n\n```js\nmodule foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n```","mimetype":"text/plain"},{"body":"<p>You could even do that with module declarations and stitch them together using a <code>with</code> clause:</p>\n<pre><code class=\"language-js\">module foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n</code></pre>\n","mimetype":"text/html"}]},"ts":1669941717487,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ko1zr-4588W8S57h3qhBdCcm3O-0qxwpLIrb3J9NjEA"},
{"content":{"body":" * You could even do that with module declarations and stitch them together using a `with` clause:\n\n```js\nmodule foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n```","format":"org.matrix.custom.html","formatted_body":" * <p>You could even do that with module declarations and stitch them together using a <code>with</code> clause:</p>\n<pre><code class=\"language-js\">module foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n</code></pre>\n","m.new_content":{"body":"You could even do that with module declarations and stitch them together using a `with` clause:\n\n```js\nmodule foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n```","format":"org.matrix.custom.html","formatted_body":"<p>You could even do that with module declarations and stitch them together using a <code>with</code> clause:</p>\n<pre><code class=\"language-js\">module foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"You could even do that with module declarations and stitch them together using a `with` clause:\n\n```js\nmodule foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n```","mimetype":"text/plain"},{"body":"<p>You could even do that with module declarations and stitch them together using a <code>with</code> clause:</p>\n<pre><code class=\"language-js\">module foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$ko1zr-4588W8S57h3qhBdCcm3O-0qxwpLIrb3J9NjEA","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * You could even do that with module declarations and stitch them together using a `with` clause:\n\n```js\nmodule foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n```","mimetype":"text/plain"},{"body":" * <p>You could even do that with module declarations and stitch them together using a <code>with</code> clause:</p>\n<pre><code class=\"language-js\">module foo { }\nmodule bar { import foo } // NOTE: not a closure, just an unsatisfied binding\nimport bar with { bindings: { foo } };\n</code></pre>\n","mimetype":"text/html"}]},"ts":1669941748024,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$AQVBKquLBWf9aMeAKXITdDPuonYKPkUWmTmhh9IEW10"},
{"content":{"body":"In my opinion, module expressions fully solve the bundling problem.","msgtype":"m.text","org.matrix.msc1767.text":"In my opinion, module expressions fully solve the bundling problem."},"ts":1669941762206,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$fN6R6-Xn07nxPnHanfABT6sZQJEo_-MqqkSisHvH4fA"},
{"content":{"body":"Its definitely not as convenient","msgtype":"m.text","org.matrix.msc1767.text":"Its definitely not as convenient"},"ts":1669941763277,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$T7htu2ECnw5yBhG8VDfRw8Y6PpDRHhyf5KGiqYOVDFs"},
{"content":{"body":"Pardon module expressions + `Module` constructor.","format":"org.matrix.custom.html","formatted_body":"Pardon module expressions + <code>Module</code> constructor.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Pardon module expressions + `Module` constructor.","mimetype":"text/plain"},{"body":"Pardon module expressions + <code>Module</code> constructor.","mimetype":"text/html"}]},"ts":1669941795070,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$fjHvTzeUadPmTkdCPvE2VH-Mn2_ktt2Rh89rzrYIHJ8"},
{"content":{"body":"(`ModuleSource` constructor not being necessary to that end and if the committee is intransigent about `ModuleSource` providing a path to `eval`, I’m in favor of further separation of layers.)","format":"org.matrix.custom.html","formatted_body":"(<code>ModuleSource</code> constructor not being necessary to that end and if the committee is intransigent about <code>ModuleSource</code> providing a path to <code>eval</code>, I’m in favor of further separation of layers.)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"(`ModuleSource` constructor not being necessary to that end and if the committee is intransigent about `ModuleSource` providing a path to `eval`, I’m in favor of further separation of layers.)","mimetype":"text/plain"},{"body":"(<code>ModuleSource</code> constructor not being necessary to that end and if the committee is intransigent about <code>ModuleSource</code> providing a path to <code>eval</code>, I’m in favor of further separation of layers.)","mimetype":"text/html"}]},"ts":1669941845556,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$ssWEhKw43MxUlk9rhG3fiDZOOUfrhwmJTPrvlzCrgMM"},
{"content":{"body":"> <@kriskowal:matrix.org> In my opinion, module expressions fully solve the bundling problem.\n\nI assume that a pure module expression solution would do something like:\n```js\nconst foo = module {}\nconst bar = module { import \"#foo\"; }\n// replace resolver hook to resolve \"#foo\" with `foo`\n// ...\n// profit?\n```","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$fN6R6-Xn07nxPnHanfABT6sZQJEo_-MqqkSisHvH4fA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>In my opinion, module expressions fully solve the bundling problem.</blockquote></mx-reply><p>I assume that a pure module expression solution would do something like:</p>\n<pre><code class=\"language-js\">const foo = module {}\nconst bar = module { import &quot;#foo&quot;; }\n// replace resolver hook to resolve &quot;#foo&quot; with `foo`\n// ...\n// profit?\n</code></pre>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$fN6R6-Xn07nxPnHanfABT6sZQJEo_-MqqkSisHvH4fA"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> In my opinion, module expressions fully solve the bundling problem.\n\nI assume that a pure module expression solution would do something like:\n```js\nconst foo = module {}\nconst bar = module { import \"#foo\"; }\n// replace resolver hook to resolve \"#foo\" with `foo`\n// ...\n// profit?\n```","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$fN6R6-Xn07nxPnHanfABT6sZQJEo_-MqqkSisHvH4fA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>In my opinion, module expressions fully solve the bundling problem.</blockquote></mx-reply><p>I assume that a pure module expression solution would do something like:</p>\n<pre><code class=\"language-js\">const foo = module {}\nconst bar = module { import &quot;#foo&quot;; }\n// replace resolver hook to resolve &quot;#foo&quot; with `foo`\n// ...\n// profit?\n</code></pre>\n","mimetype":"text/html"}]},"ts":1669941869504,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WBCZaMmTbzJGtcWTQ43ey_WDQJ8XPiupCDD94ZlXec8"},
{"content":{"body":"Though, in my opinion, `ModuleSource` is no more egregious a path to `eval` than `<script type=module src=*>`. It is certainly not a direct-eval evil.","format":"org.matrix.custom.html","formatted_body":"Though, in my opinion, <code>ModuleSource</code> is no more egregious a path to <code>eval</code> than <code>&lt;script type=module src=*&gt;</code>. It is certainly not a direct-eval evil.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Though, in my opinion, `ModuleSource` is no more egregious a path to `eval` than `<script type=module src=*>`. It is certainly not a direct-eval evil.","mimetype":"text/plain"},{"body":"Though, in my opinion, <code>ModuleSource</code> is no more egregious a path to <code>eval</code> than <code>&lt;script type=module src=*&gt;</code>. It is certainly not a direct-eval evil.","mimetype":"text/html"}]},"ts":1669941919146,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$TUz7ErfXRgjUghox9v7vplu0DIytCBjzapUVuHu_ykE"},
{"content":{"body":"I mean, there's always `import(\"data:text/javascript,console.log('hello')\")` :)","format":"org.matrix.custom.html","formatted_body":"I mean, there's always <code>import(&quot;data:text/javascript,console.log('hello')&quot;)</code> :)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I mean, there's always `import(\"data:text/javascript,console.log('hello')\")` :)","mimetype":"text/plain"},{"body":"I mean, there's always <code>import(&quot;data:text/javascript,console.log('hello')&quot;)</code> :)","mimetype":"text/html"}]},"ts":1669941981090,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PrMoBpw2dcek3wbVLEGiEw-uCDXG1IpYFIIqNxiIrcg"},
{"content":{"body":"> <@rbuckton:matrix.org> I assume that a pure module expression solution would do something like:\n> ```js\n> const foo = module {}\n> const bar = module { import \"#foo\"; }\n> // replace resolver hook to resolve \"#foo\" with `foo`\n> // ...\n> // profit?\n> ```\n\nClose enough, though it won’t have to rewrite import specifiers. It can remap original specifiers to arbitrary other module blocks to effect the same linkage as occurred in the original physical locations. This is good because specifiers are typically scoped to not reveal the full physical location.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$WBCZaMmTbzJGtcWTQ43ey_WDQJ8XPiupCDD94ZlXec8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>I assume that a pure module expression solution would do something like:</p>\n<pre><code class=\"language-js\">const foo = module {}\nconst bar = module { import \"#foo\"; }\n// replace resolver hook to resolve \"#foo\" with `foo`\n// ...\n// profit?\n</code></pre>\n</blockquote></mx-reply>Close enough, though it won’t have to rewrite import specifiers. It can remap original specifiers to arbitrary other module blocks to effect the same linkage as occurred in the original physical locations. This is good because specifiers are typically scoped to not reveal the full physical location.","m.relates_to":{"m.in_reply_to":{"event_id":"$WBCZaMmTbzJGtcWTQ43ey_WDQJ8XPiupCDD94ZlXec8"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> I assume that a pure module expression solution would do something like:\n> ```js\n> const foo = module {}\n> const bar = module { import \"#foo\"; }\n> // replace resolver hook to resolve \"#foo\" with `foo`\n> // ...\n> // profit?\n> ```\n\nClose enough, though it won’t have to rewrite import specifiers. It can remap original specifiers to arbitrary other module blocks to effect the same linkage as occurred in the original physical locations. This is good because specifiers are typically scoped to not reveal the full physical location.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$WBCZaMmTbzJGtcWTQ43ey_WDQJ8XPiupCDD94ZlXec8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>I assume that a pure module expression solution would do something like:</p>\n<pre><code class=\"language-js\">const foo = module {}\nconst bar = module { import \"#foo\"; }\n// replace resolver hook to resolve \"#foo\" with `foo`\n// ...\n// profit?\n</code></pre>\n</blockquote></mx-reply>Close enough, though it won’t have to rewrite import specifiers. It can remap original specifiers to arbitrary other module blocks to effect the same linkage as occurred in the original physical locations. This is good because specifiers are typically scoped to not reveal the full physical location.","mimetype":"text/html"}]},"ts":1669941995002,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$NdEf-KbHgiB8rx6yGPNkGmXSkPIyh0hRGzvIPETDR6c"},
{"content":{"body":"In any case, I think we get a lot of bang from the module harmony proposals even if `ModuleSource` is replaced with something like `Module.parse` that can confirm the integrity of a module string and reflect its import/export bindings. Bundlers need that and on the evaluator side, module expressions suffice. We would still want an `ModuleSource` inert constructor just to host the `prototype`, since module expressions have a `source` of that prototype. And, at the end of the day, that’s equivalent to what what we’d have with a full-power `ModuleSource` constructor under a no-unsafe-eval CSP.","format":"org.matrix.custom.html","formatted_body":"In any case, I think we get a lot of bang from the module harmony proposals even if <code>ModuleSource</code> is replaced with something like <code>Module.parse</code> that can confirm the integrity of a module string and reflect its import/export bindings. Bundlers need that and on the evaluator side, module expressions suffice. We would still want an <code>ModuleSource</code> inert constructor just to host the <code>prototype</code>, since module expressions have a <code>source</code> of that prototype. And, at the end of the day, that’s equivalent to what what we’d have with a full-power <code>ModuleSource</code> constructor under a no-unsafe-eval CSP.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"In any case, I think we get a lot of bang from the module harmony proposals even if `ModuleSource` is replaced with something like `Module.parse` that can confirm the integrity of a module string and reflect its import/export bindings. Bundlers need that and on the evaluator side, module expressions suffice. We would still want an `ModuleSource` inert constructor just to host the `prototype`, since module expressions have a `source` of that prototype. And, at the end of the day, that’s equivalent to what what we’d have with a full-power `ModuleSource` constructor under a no-unsafe-eval CSP.","mimetype":"text/plain"},{"body":"In any case, I think we get a lot of bang from the module harmony proposals even if <code>ModuleSource</code> is replaced with something like <code>Module.parse</code> that can confirm the integrity of a module string and reflect its import/export bindings. Bundlers need that and on the evaluator side, module expressions suffice. We would still want an <code>ModuleSource</code> inert constructor just to host the <code>prototype</code>, since module expressions have a <code>source</code> of that prototype. And, at the end of the day, that’s equivalent to what what we’d have with a full-power <code>ModuleSource</code> constructor under a no-unsafe-eval CSP.","mimetype":"text/html"}]},"ts":1669942167539,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$nKi0wyfeiJCm5cfrbayNHDUPOdZlzsAFYRBVF6lmrIM"},
{"content":{"body":"Concretely though, `new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })` does the trick of remapping an import to a particular `Module` instance. You can extrapolate from there.","format":"org.matrix.custom.html","formatted_body":"Concretely though, <code>new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })</code> does the trick of remapping an import to a particular <code>Module</code> instance. You can extrapolate from there.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Concretely though, `new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })` does the trick of remapping an import to a particular `Module` instance. You can extrapolate from there.","mimetype":"text/plain"},{"body":"Concretely though, <code>new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })</code> does the trick of remapping an import to a particular <code>Module</code> instance. You can extrapolate from there.","mimetype":"text/html"}]},"ts":1669942244499,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$xDERyNAi3yamUySbmumOIvl3DU7dG_F6dwAUnRdT3WE"},
{"content":{"body":" * Concretely though, `new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })` does the trick of remapping an import to a particular `Module` instance. You can extrapolate from there.","format":"org.matrix.custom.html","formatted_body":" * Concretely though, <code>new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })</code> does the trick of remapping an import to a particular <code>Module</code> instance. You can extrapolate from there.","m.new_content":{"body":"Concretely though, `new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })` does the trick of remapping an import to a particular `Module` instance. You can extrapolate from there.","format":"org.matrix.custom.html","formatted_body":"Concretely though, <code>new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })</code> does the trick of remapping an import to a particular <code>Module</code> instance. You can extrapolate from there.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Concretely though, `new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })` does the trick of remapping an import to a particular `Module` instance. You can extrapolate from there.","mimetype":"text/plain"},{"body":"Concretely though, <code>new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })</code> does the trick of remapping an import to a particular <code>Module</code> instance. You can extrapolate from there.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$xDERyNAi3yamUySbmumOIvl3DU7dG_F6dwAUnRdT3WE","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Concretely though, `new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })` does the trick of remapping an import to a particular `Module` instance. You can extrapolate from there.","mimetype":"text/plain"},{"body":" * Concretely though, <code>new Module((module { import './foo.js' }).source, { importHook() { return fooModule; })</code> does the trick of remapping an import to a particular <code>Module</code> instance. You can extrapolate from there.","mimetype":"text/html"}]},"ts":1669942263249,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$1jFP3A_0myYTscSz0LnK0ZYRlZXx0Og2f-TfAGIyEW4"},
{"content":{"body":"In fact, module expressions are preferable to module declarations as a vessel for bundles because the module can be injected verbatim between the braces of a module expression.","msgtype":"m.text","org.matrix.msc1767.text":"In fact, module expressions are preferable to module declarations as a vessel for bundles because the module can be injected verbatim between the braces of a module expression."},"ts":1669942333785,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$DoTD3KMdORz_NDavg7Ca-WlcRA9NBGvee1KVor_yN-8"},
{"content":{"body":"Though, no doubt in every case that matters, there will be a minification pass and a sourcemap, so that advantage isn’t likely to be realized in any case that matters.","msgtype":"m.text","org.matrix.msc1767.text":"Though, no doubt in every case that matters, there will be a minification pass and a sourcemap, so that advantage isn’t likely to be realized in any case that matters."},"ts":1669942385134,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$bUEoVTcqnLLZ3LeT_o7FtbLlLoKlz2jpDN5AsjFT60Y"},
{"content":{"body":"Where module declarations shine though is that they do not require `import()` to trampoline into user space `importHook` functions, which shu hinted could limit their usefulness in production.","format":"org.matrix.custom.html","formatted_body":"Where module declarations shine though is that they do not require <code>import()</code> to trampoline into user space <code>importHook</code> functions, which <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a> hinted could limit their usefulness in production.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Where module declarations shine though is that they do not require `import()` to trampoline into user space `importHook` functions, which shu hinted could limit their usefulness in production.","mimetype":"text/plain"},{"body":"Where module declarations shine though is that they do not require <code>import()</code> to trampoline into user space <code>importHook</code> functions, which <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a> hinted could limit their usefulness in production.","mimetype":"text/html"}]},"ts":1669942453916,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$-E0s468l2wZpifUQbdw38fXasiyrRRC33S2EguWAalc"},
{"content":{"body":"But the downside is that they place a new cognitive burden on developers, who will now need to choose between using lexical or stringy module specifiers on a case-by-case basis, depending on whether they want the bundle (or worker payload!) to come with its own singleton of a module or exit to the host’s singleton of the module.","msgtype":"m.text","org.matrix.msc1767.text":"But the downside is that they place a new cognitive burden on developers, who will now need to choose between using lexical or stringy module specifiers on a case-by-case basis, depending on whether they want the bundle (or worker payload!) to come with its own singleton of a module or exit to the host’s singleton of the module."},"ts":1669942564772,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$bKET_J-9a1F1cgO3ydYbRgLJSzqH5sqMqxCAgHMRdf4"},
{"content":{"body":"That’ll be an attractive nuisance for the worker case, since each time you “add” an entrypoint module expression/declaration to a worker, that entrypoint will retain a separate instance of its module declaration graph and connect to shared instances from the host for any remaining stringy specifiers.","msgtype":"m.text","org.matrix.msc1767.text":"That’ll be an attractive nuisance for the worker case, since each time you “add” an entrypoint module expression/declaration to a worker, that entrypoint will retain a separate instance of its module declaration graph and connect to shared instances from the host for any remaining stringy specifiers."},"ts":1669942663913,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$ycxZoXosujwOJTwGBNtXxwmiDbSfW6TI8pnoi8gweF4"},
{"content":{"body":"I think that’ll have some negative consequences for the ecosystem, where libraries will be compelled to export a module declaration instead of their own API, so that the consumer can decide whether they want to instantiate it or transport it.","msgtype":"m.text","org.matrix.msc1767.text":"I think that’ll have some negative consequences for the ecosystem, where libraries will be compelled to export a module declaration instead of their own API, so that the consumer can decide whether they want to instantiate it or transport it."},"ts":1669942774304,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$dtwV0vXzTrwusocd9tRFDrprNI8jMj8webTur5bXgzw"},
{"content":{"body":"And in fact, they do not need module declarations to have that choice. They get the same facility from module import reflection.","msgtype":"m.text","org.matrix.msc1767.text":"And in fact, they do not need module declarations to have that choice. They get the same facility from module import reflection."},"ts":1669942794282,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Q9owefWtXynRREr88Tta17q2ai2Om3HM8wQjT1JoWlY"},
{"content":{"body":"That is, `postMessage` can send an array of `ModuleSources` with a description of their linkage and the receiver can rehydrate the graph with `Module` and a little machinery, just like a bundle.","format":"org.matrix.custom.html","formatted_body":"That is, <code>postMessage</code> can send an array of <code>ModuleSources</code> with a description of their linkage and the receiver can rehydrate the graph with <code>Module</code> and a little machinery, just like a bundle.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"That is, `postMessage` can send an array of `ModuleSources` with a description of their linkage and the receiver can rehydrate the graph with `Module` and a little machinery, just like a bundle.","mimetype":"text/plain"},{"body":"That is, <code>postMessage</code> can send an array of <code>ModuleSources</code> with a description of their linkage and the receiver can rehydrate the graph with <code>Module</code> and a little machinery, just like a bundle.","mimetype":"text/html"}]},"ts":1669942925827,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$tWUdpu1Ox88REC_lnw58nKH9wFUDm1wK9sBEFNrxeDI"}
]