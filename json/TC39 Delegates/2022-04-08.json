[
{"content":{"body":"> <@rbuckton:matrix.org> I think the issue with using AbortSignal for proxy revocation is the async callback nature of EventTarget. When you revoke a proxy you want it revoked immediately. Yes, a proxy can check if the AbortSignal has been aborted when the proxy is used, but that still introduces GC issues.\n\nit's not observable in the user land. so \"check signal when use\" is equal to \"GC on aborted\"","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$70l5bDVohYJcJnCXqyAb0TeE4lFoAAz9_3ATNdkDYhE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I think the issue with using AbortSignal for proxy revocation is the async callback nature of EventTarget. When you revoke a proxy you want it revoked immediately. Yes, a proxy can check if the AbortSignal has been aborted when the proxy is used, but that still introduces GC issues.</blockquote></mx-reply>it's not observable in the user land. so &quot;check signal when use&quot; is equal to &quot;GC on aborted&quot;","m.relates_to":{"m.in_reply_to":{"event_id":"$70l5bDVohYJcJnCXqyAb0TeE4lFoAAz9_3ATNdkDYhE"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> I think the issue with using AbortSignal for proxy revocation is the async callback nature of EventTarget. When you revoke a proxy you want it revoked immediately. Yes, a proxy can check if the AbortSignal has been aborted when the proxy is used, but that still introduces GC issues.\n\nit's not observable in the user land. so \"check signal when use\" is equal to \"GC on aborted\"","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$70l5bDVohYJcJnCXqyAb0TeE4lFoAAz9_3ATNdkDYhE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I think the issue with using AbortSignal for proxy revocation is the async callback nature of EventTarget. When you revoke a proxy you want it revoked immediately. Yes, a proxy can check if the AbortSignal has been aborted when the proxy is used, but that still introduces GC issues.</blockquote></mx-reply>it's not observable in the user land. so &quot;check signal when use&quot; is equal to &quot;GC on aborted&quot;","mimetype":"text/html"}]},"ts":1649397233221,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$ApeOdHncl8qeyABw_1YV6W9q0sP2battS_s3eavQOck"},
{"content":{"body":"I took another look at the DOM spec. \"abort algorithms\" that are added by the Host (not by the user) are synchronously executed and aren't part of the `abort` event dispatch.","format":"org.matrix.custom.html","formatted_body":"I took another look at the DOM spec. &quot;abort algorithms&quot; that are added by the Host (not by the user) are synchronously executed and aren't part of the <code>abort</code> event dispatch.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I took another look at the DOM spec. \"abort algorithms\" that are added by the Host (not by the user) are synchronously executed and aren't part of the `abort` event dispatch.","mimetype":"text/plain"},{"body":"I took another look at the DOM spec. &quot;abort algorithms&quot; that are added by the Host (not by the user) are synchronously executed and aren't part of the <code>abort</code> event dispatch.","mimetype":"text/html"}]},"ts":1649397311894,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CYWStYLHhKvykLQV5jxtSsaIh4AHwIrhuD3kFzhAFJ8"},
{"content":{"body":"I'm not sure what you mean by \"not observable in user-land\". If I create a function closure over an object graph that takes up a lot of memory and add that closure to an AbortSignal, the AbortSignal will hold the whole object graph in memory as long as the abort signal is alive, even if the signal is already aborted.","msgtype":"m.text","org.matrix.msc1767.text":"I'm not sure what you mean by \"not observable in user-land\". If I create a function closure over an object graph that takes up a lot of memory and add that closure to an AbortSignal, the AbortSignal will hold the whole object graph in memory as long as the abort signal is alive, even if the signal is already aborted."},"ts":1649397392380,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$osUaDQMmJ3HoUXavH9QKrn_pBM6D9dL707Ab36RkmL0"},
{"content":{"body":"For the massive proxy revoke proposal, we don't need (and don't want) a callback (for each proxy).\n\nThe RS in the spec will be: next time when the proxy is accessed, check the AbortSignal flag, if aborted, revoke it now.\n\nBut for the Proxy revoke, it is just drop the Proxy.[[Target]] and Proxy.[[Handler]], which means once it is aborted, the engine can do GC immediately (no need to \"check the AbortSignal flag on the next access\" so there is no memory leak).","msgtype":"m.text","org.matrix.msc1767.text":"For the massive proxy revoke proposal, we don't need (and don't want) a callback (for each proxy).\n\nThe RS in the spec will be: next time when the proxy is accessed, check the AbortSignal flag, if aborted, revoke it now.\n\nBut for the Proxy revoke, it is just drop the Proxy.[[Target]] and Proxy.[[Handler]], which means once it is aborted, the engine can do GC immediately (no need to \"check the AbortSignal flag on the next access\" so there is no memory leak)."},"ts":1649397961091,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$PEYwThsGppOJZYLYDBZloXvyPhfqjVanLex4IAcaipQ"},
{"content":{"body":"If the main goal is reducing revoke function allocations. Could the API be:\n\n```\nlet [proxyFactory, revokeAll] = Proxy.collection();\n\nlet p = proxyFactory(t, h);\nrevokeAll();\nArray.isArray(p); // Error!\n```","format":"org.matrix.custom.html","formatted_body":"<p>If the main goal is reducing revoke function allocations. Could the API be:</p>\n<pre><code>let [proxyFactory, revokeAll] = Proxy.collection();\n\nlet p = proxyFactory(t, h);\nrevokeAll();\nArray.isArray(p); // Error!\n</code></pre>","msgtype":"m.text"},"ts":1649399748718,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$gLV8771f_fRjs0_jM0mSNljhUSvYVvws15OujSUII9w"},
{"content":{"body":"That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail (best effort)","msgtype":"m.text"},"ts":1649399796492,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$Fvu1HXzglvGdIZ-9ijBA-p1lX8jViC8FYbLuHnvi7a0"},
{"content":{"body":"* That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail","m.new_content":{"body":"That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail","msgtype":"m.text"},"m.relates_to":{"event_id":"$Fvu1HXzglvGdIZ-9ijBA-p1lX8jViC8FYbLuHnvi7a0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1649399888286,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$Vieo21VHK6UsZoSoQO1fA3fMn_r3-Jc5JBCil5-0XtI"},
{"content":{"body":"* That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail (best effort)","m.new_content":{"body":"That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail (best effort)","msgtype":"m.text"},"m.relates_to":{"event_id":"$Fvu1HXzglvGdIZ-9ijBA-p1lX8jViC8FYbLuHnvi7a0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1649399922530,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$BzTAxvnXHzj77ekWujvxRnV2MOXzzM60KtwlOe5kHhM"},
{"content":{"body":"rbuckton: I have to say I don't understand the hangup around event listeners. You'd only add an event listener to an AbortSignal if you implemented the aborting in userland. Web platform features use \"abort algorithms\" instead.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: I have to say I don't understand the hangup around event listeners. You'd only add an event listener to an AbortSignal if you implemented the aborting in userland. Web platform features use &quot;abort algorithms&quot; instead.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"rbuckton: I have to say I don't understand the hangup around event listeners. You'd only add an event listener to an AbortSignal if you implemented the aborting in userland. Web platform features use \"abort algorithms\" instead.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: I have to say I don't understand the hangup around event listeners. You'd only add an event listener to an AbortSignal if you implemented the aborting in userland. Web platform features use &quot;abort algorithms&quot; instead.","mimetype":"text/html"}]},"ts":1649401577688,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$FJGISJVaUBpVQjJybok5iOwiDhbOTrukGz0BwvdPx4k"},
{"content":{"body":"And I imagine the web platform has reasons it depends on synchronous dispatch of \"abort algorithms\"? What I don't understand is why only the web platform has that privilege while user code has to rely on asynchronous notification. ","msgtype":"m.text","org.matrix.msc1767.text":"And I imagine the web platform has reasons it depends on synchronous dispatch of \"abort algorithms\"? What I don't understand is why only the web platform has that privilege while user code has to rely on asynchronous notification. "},"ts":1649403348108,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zAzqYwwPby4Oro85gL9r0ox_XQn9tFH5xR0M1W_CnH8"},
{"content":{"body":"My other concern is that an AbortSignal can only be aborted once, but an `abort` event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how `Promise` ensures callbacks are evaluated once, an `abort` event could theoretically be executed multiple times, and most `abort` handlers probably aren't written to be robust enough to handle that case.","format":"org.matrix.custom.html","formatted_body":"My other concern is that an AbortSignal can only be aborted once, but an <code>abort</code> event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how <code>Promise</code> ensures callbacks are evaluated once, an <code>abort</code> event could theoretically be executed multiple times, and most <code>abort</code> handlers probably aren't written to be robust enough to handle that case.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"My other concern is that an AbortSignal can only be aborted once, but an `abort` event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how `Promise` ensures callbacks are evaluated once, an `abort` event could theoretically be executed multiple times, and most `abort` handlers probably aren't written to be robust enough to handle that case.","mimetype":"text/plain"},{"body":"My other concern is that an AbortSignal can only be aborted once, but an <code>abort</code> event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how <code>Promise</code> ensures callbacks are evaluated once, an <code>abort</code> event could theoretically be executed multiple times, and most <code>abort</code> handlers probably aren't written to be robust enough to handle that case.","mimetype":"text/html"}]},"ts":1649403604531,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$AsNOjUPwNTpltNFUnhBzkg4m5DIdJWLiKCCEIZeAcvI"},
{"content":{"body":"So my concern is that the mechanism is inconsistent and fragile, and works until it doesn't. The web platform doesn't have to worry about any of this because internally it gets to do the *right* thing (synchronous \"abort algorithms\" that are only executed once). User code isn't so lucky, and that's 90% of my use case for cancellation.","format":"org.matrix.custom.html","formatted_body":"So my concern is that the mechanism is inconsistent and fragile, and works until it doesn't. The web platform doesn't have to worry about any of this because internally it gets to do the <em>right</em> thing (synchronous &quot;abort algorithms&quot; that are only executed once). User code isn't so lucky, and that's 90% of my use case for cancellation.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"So my concern is that the mechanism is inconsistent and fragile, and works until it doesn't. The web platform doesn't have to worry about any of this because internally it gets to do the *right* thing (synchronous \"abort algorithms\" that are only executed once). User code isn't so lucky, and that's 90% of my use case for cancellation.","mimetype":"text/plain"},{"body":"So my concern is that the mechanism is inconsistent and fragile, and works until it doesn't. The web platform doesn't have to worry about any of this because internally it gets to do the <em>right</em> thing (synchronous &quot;abort algorithms&quot; that are only executed once). User code isn't so lucky, and that's 90% of my use case for cancellation.","mimetype":"text/html"}]},"ts":1649403704252,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Om1nHftqOZIsD5HZGwbCF1jf1R_9ZVnjlMGGuZGa4O0"},
{"content":{"body":" * My other concern is that an AbortSignal can only be aborted once, but an `abort` event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how `Promise` ensures callbacks are evaluated once, an `abort` event could theoretically be executed multiple times, and most `abort` handlers probably aren't written to be robust enough to handle that case.","format":"org.matrix.custom.html","formatted_body":" * My other concern is that an AbortSignal can only be aborted once, but an <code>abort</code> event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how <code>Promise</code> ensures callbacks are evaluated once, an <code>abort</code> event could theoretically be executed multiple times, and most <code>abort</code> handlers probably aren't written to be robust enough to handle that case.","m.new_content":{"body":"My other concern is that an AbortSignal can only be aborted once, but an `abort` event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how `Promise` ensures callbacks are evaluated once, an `abort` event could theoretically be executed multiple times, and most `abort` handlers probably aren't written to be robust enough to handle that case.","format":"org.matrix.custom.html","formatted_body":"My other concern is that an AbortSignal can only be aborted once, but an <code>abort</code> event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how <code>Promise</code> ensures callbacks are evaluated once, an <code>abort</code> event could theoretically be executed multiple times, and most <code>abort</code> handlers probably aren't written to be robust enough to handle that case.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"My other concern is that an AbortSignal can only be aborted once, but an `abort` event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how `Promise` ensures callbacks are evaluated once, an `abort` event could theoretically be executed multiple times, and most `abort` handlers probably aren't written to be robust enough to handle that case.","mimetype":"text/plain"},{"body":"My other concern is that an AbortSignal can only be aborted once, but an <code>abort</code> event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how <code>Promise</code> ensures callbacks are evaluated once, an <code>abort</code> event could theoretically be executed multiple times, and most <code>abort</code> handlers probably aren't written to be robust enough to handle that case.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$AsNOjUPwNTpltNFUnhBzkg4m5DIdJWLiKCCEIZeAcvI","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * My other concern is that an AbortSignal can only be aborted once, but an `abort` event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how `Promise` ensures callbacks are evaluated once, an `abort` event could theoretically be executed multiple times, and most `abort` handlers probably aren't written to be robust enough to handle that case.","mimetype":"text/plain"},{"body":" * My other concern is that an AbortSignal can only be aborted once, but an <code>abort</code> event can be raised many times (even if only once by the system) due to dispatchEvent. Unlike how <code>Promise</code> ensures callbacks are evaluated once, an <code>abort</code> event could theoretically be executed multiple times, and most <code>abort</code> handlers probably aren't written to be robust enough to handle that case.","mimetype":"text/html"}]},"ts":1649403791841,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dF028pkjJywhokhGWuWN9fKCazv6B1Nj_AO-tNlxCcQ"},
{"content":{"body":"> <@aclaymore:matrix.org> If the main goal is reducing revoke function allocations. Could the API be:\n> \n> ```\n> let [proxyFactory, revokeAll] = Proxy.collection();\n> \n> let p = proxyFactory(t, h);\n> revokeAll();\n> Array.isArray(p); // Error!\n> ```\n\nInteresting, maybe we can do this","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$gLV8771f_fRjs0_jM0mSNljhUSvYVvws15OujSUII9w?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br /><p>If the main goal is reducing revoke function allocations. Could the API be:</p>\n<pre><code>let [proxyFactory, revokeAll] = Proxy.collection();\n\nlet p = proxyFactory(t, h);\nrevokeAll();\nArray.isArray(p); // Error!\n</code></pre></blockquote></mx-reply>Interesting, maybe we can do this","m.relates_to":{"m.in_reply_to":{"event_id":"$gLV8771f_fRjs0_jM0mSNljhUSvYVvws15OujSUII9w"}},"msgtype":"m.text"},"ts":1649411872546,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$lSMjuZYLlGdc4WLyGB4Upf9RS1mZXL-d9Aidx2Yh2YQ"},
{"content":{"body":"checking my memory because the notes don't seem super clear: for `toSorted()` in the change array by copy proposal, the consensus is that `toSorted()`, unlike `sort()`, _does not_ distinguish holes from `undefined`","format":"org.matrix.custom.html","formatted_body":"checking my memory because the notes don't seem super clear: for <code>toSorted()</code> in the change array by copy proposal, the consensus is that <code>toSorted()</code>, unlike <code>sort()</code>, <em>does not</em> distinguish holes from <code>undefined</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"checking my memory because the notes don't seem super clear: for `toSorted()` in the change array by copy proposal, the consensus is that `toSorted()`, unlike `sort()`, _does not_ distinguish holes from `undefined`","mimetype":"text/plain"},{"body":"checking my memory because the notes don't seem super clear: for <code>toSorted()</code> in the change array by copy proposal, the consensus is that <code>toSorted()</code>, unlike <code>sort()</code>, <em>does not</em> distinguish holes from <code>undefined</code>","mimetype":"text/html"}]},"ts":1649437325647,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$STm-4DWXjx2CA8rDAZxfP_gTTU1w6itKqSeAAoOXVcw"},
{"content":{"body":"is that right?","msgtype":"m.text","org.matrix.msc1767.text":"is that right?"},"ts":1649437327104,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$-8ZrfiIKsblc6SIUv4m0hKfn79TxDmPMLvfbkPab9J8"},
{"content":{"body":"rbuckton: asynchronous? Event dispatch is synchronous.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: asynchronous? Event dispatch is synchronous.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"rbuckton: asynchronous? Event dispatch is synchronous.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: asynchronous? Event dispatch is synchronous.","mimetype":"text/html"}]},"ts":1649437346244,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$2AvcSUWYNtGOdwGSfh4-OLBQ57RDtdzDzvacY0jL3GQ"},
{"content":{"body":"cc Ashley Claymore for `toSorted()` question","format":"org.matrix.custom.html","formatted_body":"cc <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">Ashley Claymore</a> for <code>toSorted()</code> question","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"cc Ashley Claymore for `toSorted()` question","mimetype":"text/plain"},{"body":"cc <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">Ashley Claymore</a> for <code>toSorted()</code> question","mimetype":"text/html"}]},"ts":1649437362059,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$jxdErr7pTU9KagywN44RIwzOI5q48zn4Jsd36pdXfno"},
{"content":{"body":"You remember correctly: toSorted always performs Get without checking if it's an own property","msgtype":"m.text"},"ts":1649437393816,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$x35TDNLwbYbHfnpAYuPr7eXwf2MBLBmrGimSNtcgogk"},
{"content":{"body":"* You remember correctly: toSorted always performs Get without checking if it's an own property","m.new_content":{"body":"You remember correctly: toSorted always performs Get without checking if it's an own property","msgtype":"m.text"},"m.relates_to":{"event_id":"$x35TDNLwbYbHfnpAYuPr7eXwf2MBLBmrGimSNtcgogk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1649437435090,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$jenvuqYhXuQiMPPifg1wSnFWpHvnM6D7cpQSsDFTthc"},
{"content":{"body":"thank you","msgtype":"m.text","org.matrix.msc1767.text":"thank you"},"ts":1649437487438,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Nj9HtVZiGTpCaQR9j7RmgCNTx-iMGNlzZqrlP6p-o6E"}
]