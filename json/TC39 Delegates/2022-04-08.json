[
{"content":{"body":"> <@rbuckton:matrix.org> I think the issue with using AbortSignal for proxy revocation is the async callback nature of EventTarget. When you revoke a proxy you want it revoked immediately. Yes, a proxy can check if the AbortSignal has been aborted when the proxy is used, but that still introduces GC issues.\n\nit's not observable in the user land. so \"check signal when use\" is equal to \"GC on aborted\"","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$70l5bDVohYJcJnCXqyAb0TeE4lFoAAz9_3ATNdkDYhE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I think the issue with using AbortSignal for proxy revocation is the async callback nature of EventTarget. When you revoke a proxy you want it revoked immediately. Yes, a proxy can check if the AbortSignal has been aborted when the proxy is used, but that still introduces GC issues.</blockquote></mx-reply>it's not observable in the user land. so &quot;check signal when use&quot; is equal to &quot;GC on aborted&quot;","m.relates_to":{"m.in_reply_to":{"event_id":"$70l5bDVohYJcJnCXqyAb0TeE4lFoAAz9_3ATNdkDYhE"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> I think the issue with using AbortSignal for proxy revocation is the async callback nature of EventTarget. When you revoke a proxy you want it revoked immediately. Yes, a proxy can check if the AbortSignal has been aborted when the proxy is used, but that still introduces GC issues.\n\nit's not observable in the user land. so \"check signal when use\" is equal to \"GC on aborted\"","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$70l5bDVohYJcJnCXqyAb0TeE4lFoAAz9_3ATNdkDYhE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I think the issue with using AbortSignal for proxy revocation is the async callback nature of EventTarget. When you revoke a proxy you want it revoked immediately. Yes, a proxy can check if the AbortSignal has been aborted when the proxy is used, but that still introduces GC issues.</blockquote></mx-reply>it's not observable in the user land. so &quot;check signal when use&quot; is equal to &quot;GC on aborted&quot;","mimetype":"text/html"}]},"ts":1649397233221,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$ApeOdHncl8qeyABw_1YV6W9q0sP2battS_s3eavQOck"},
{"content":{"body":"I took another look at the DOM spec. \"abort algorithms\" that are added by the Host (not by the user) are synchronously executed and aren't part of the `abort` event dispatch.","format":"org.matrix.custom.html","formatted_body":"I took another look at the DOM spec. &quot;abort algorithms&quot; that are added by the Host (not by the user) are synchronously executed and aren't part of the <code>abort</code> event dispatch.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I took another look at the DOM spec. \"abort algorithms\" that are added by the Host (not by the user) are synchronously executed and aren't part of the `abort` event dispatch.","mimetype":"text/plain"},{"body":"I took another look at the DOM spec. &quot;abort algorithms&quot; that are added by the Host (not by the user) are synchronously executed and aren't part of the <code>abort</code> event dispatch.","mimetype":"text/html"}]},"ts":1649397311894,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CYWStYLHhKvykLQV5jxtSsaIh4AHwIrhuD3kFzhAFJ8"},
{"content":{"body":"I'm not sure what you mean by \"not observable in user-land\". If I create a function closure over an object graph that takes up a lot of memory and add that closure to an AbortSignal, the AbortSignal will hold the whole object graph in memory as long as the abort signal is alive, even if the signal is already aborted.","msgtype":"m.text","org.matrix.msc1767.text":"I'm not sure what you mean by \"not observable in user-land\". If I create a function closure over an object graph that takes up a lot of memory and add that closure to an AbortSignal, the AbortSignal will hold the whole object graph in memory as long as the abort signal is alive, even if the signal is already aborted."},"ts":1649397392380,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$osUaDQMmJ3HoUXavH9QKrn_pBM6D9dL707Ab36RkmL0"},
{"content":{"body":"For the massive proxy revoke proposal, we don't need (and don't want) a callback (for each proxy).\n\nThe RS in the spec will be: next time when the proxy is accessed, check the AbortSignal flag, if aborted, revoke it now.\n\nBut for the Proxy revoke, it is just drop the Proxy.[[Target]] and Proxy.[[Handler]], which means once it is aborted, the engine can do GC immediately (no need to \"check the AbortSignal flag on the next access\" so there is no memory leak).","msgtype":"m.text","org.matrix.msc1767.text":"For the massive proxy revoke proposal, we don't need (and don't want) a callback (for each proxy).\n\nThe RS in the spec will be: next time when the proxy is accessed, check the AbortSignal flag, if aborted, revoke it now.\n\nBut for the Proxy revoke, it is just drop the Proxy.[[Target]] and Proxy.[[Handler]], which means once it is aborted, the engine can do GC immediately (no need to \"check the AbortSignal flag on the next access\" so there is no memory leak)."},"ts":1649397961091,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$PEYwThsGppOJZYLYDBZloXvyPhfqjVanLex4IAcaipQ"},
{"content":{"body":"If the main goal is reducing revoke function allocations. Could the API be:\n\n```\nlet [proxyFactory, revokeAll] = Proxy.collection();\n\nlet p = proxyFactory(t, h);\nrevokeAll();\nArray.isArray(p); // Error!\n```","format":"org.matrix.custom.html","formatted_body":"<p>If the main goal is reducing revoke function allocations. Could the API be:</p>\n<pre><code>let [proxyFactory, revokeAll] = Proxy.collection();\n\nlet p = proxyFactory(t, h);\nrevokeAll();\nArray.isArray(p); // Error!\n</code></pre>","msgtype":"m.text"},"ts":1649399748718,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$gLV8771f_fRjs0_jM0mSNljhUSvYVvws15OujSUII9w"},
{"content":{"body":"That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail (best effort)","msgtype":"m.text"},"ts":1649399796492,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$Fvu1HXzglvGdIZ-9ijBA-p1lX8jViC8FYbLuHnvi7a0"},
{"content":{"body":"* That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail","m.new_content":{"body":"That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail","msgtype":"m.text"},"m.relates_to":{"event_id":"$Fvu1HXzglvGdIZ-9ijBA-p1lX8jViC8FYbLuHnvi7a0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1649399888286,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$Vieo21VHK6UsZoSoQO1fA3fMn_r3-Jc5JBCil5-0XtI"},
{"content":{"body":"* That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail (best effort)","m.new_content":{"body":"That way GC could be specced that the references are dropped immediately, but if that actually happens is an implementation detail (best effort)","msgtype":"m.text"},"m.relates_to":{"event_id":"$Fvu1HXzglvGdIZ-9ijBA-p1lX8jViC8FYbLuHnvi7a0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1649399922530,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$BzTAxvnXHzj77ekWujvxRnV2MOXzzM60KtwlOe5kHhM"},
{"content":{"body":"rbuckton: I have to say I don't understand the hangup around event listeners. You'd only add an event listener to an AbortSignal if you implemented the aborting in userland. Web platform features use \"abort algorithms\" instead.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: I have to say I don't understand the hangup around event listeners. You'd only add an event listener to an AbortSignal if you implemented the aborting in userland. Web platform features use &quot;abort algorithms&quot; instead.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"rbuckton: I have to say I don't understand the hangup around event listeners. You'd only add an event listener to an AbortSignal if you implemented the aborting in userland. Web platform features use \"abort algorithms\" instead.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: I have to say I don't understand the hangup around event listeners. You'd only add an event listener to an AbortSignal if you implemented the aborting in userland. Web platform features use &quot;abort algorithms&quot; instead.","mimetype":"text/html"}]},"ts":1649401577688,"senderName":"annevk","senderId":"@annevk:mozilla.org","id":"$FJGISJVaUBpVQjJybok5iOwiDhbOTrukGz0BwvdPx4k"}
]