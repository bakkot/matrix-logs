[
{"content":{"body":"Apropos of this, Agoric uses a variant of XS that can start from a heap snapshot and it would be neat for us to be able to take advantage of that with a test262 runner.","m.mentions":{},"m.relates_to":{"event_id":"$M3ENOByE-AqTZSIvaR0-7px_80oyu_m1i1RlBrftaGE","is_falling_back":true,"m.in_reply_to":{"event_id":"$36pE1-9Cpde0DJFZeI2NhiXumf-u-ro3J5i7ABIAVSs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1707957940535,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$p_QVMqArc-U0kbLMtUyZfagDPbSMAgjqws8koZJXupk"},
{"content":{"body":"this bug is genuinely cursed: https://github.com/bjrjk/CVE-2022-4262/blob/main/FA/FA.md\n\nit relies on\n- the thing where you need to re-parse arrows when you encoutner the `=>`\n- computed property name syntax\n- class bodies are strict mode\n- you can put arbitrary expressions in arrow parameters\n- direct eval depends on strictness of surrounding context\n\ngood example of a real-life security issue arising as a direct consequence of making the language so complicated.","format":"org.matrix.custom.html","formatted_body":"<p>this bug is genuinely cursed: https://github.com/bjrjk/CVE-2022-4262/blob/main/FA/FA.md</p>\n<p>it relies on</p>\n<ul>\n<li>the thing where you need to re-parse arrows when you encoutner the <code>=&gt;</code></li>\n<li>computed property name syntax</li>\n<li>class bodies are strict mode</li>\n<li>you can put arbitrary expressions in arrow parameters</li>\n<li>direct eval depends on strictness of surrounding context</li>\n</ul>\n<p>good example of a real-life security issue arising as a direct consequence of making the language so complicated.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1707958222576,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$nnjRUdfPqqicWZL_seqMwmItYt4OJrVc9ZLZmsAZofQ"},
{"content":{"body":"wow that is a doozy","m.mentions":{},"msgtype":"m.text"},"ts":1707990661128,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$M5DsHkz582n7GR4T_0AJsBA_2b9DP2Zp4nWszZQZhIc"},
{"content":{"body":"ES6 broke a lot of assumptions that engines could previously make in their parser/bytecode generator, eg around scoping and what can occur in an expression position. Fortunately we havenâ€™t touched that area very much since ES6. Maybe the most significant thing we have done is private fields/methods (which involve scoping), the biggest Stage 3 one is decorators (which add evaluation into new places), and the biggest future thing is do expressions (which I expect to be nontrivial to implement for this reason in some engines, even if they omit break/continue/return, but those certainly make this surface much bigger)","msgtype":"m.text"},"ts":1708003922830,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$DesZ64gn2bvTOsvuDVy9KAGnnFgB6M7tcB5726f1gqY"},
{"content":{"body":"There were lots of other bugs in the process that just got caught sooner somehow or other ","format":"org.matrix.custom.html","formatted_body":"There were lots of other bugs in the process that just got caught sooner somehow or other","msgtype":"m.text"},"ts":1708003976589,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$br-by0JMLTYyrZ_ERpT-SVm5_S1Rcg6HWWTu8GssOPU"},
{"content":{"body":"class fields and class static blocks probably fall into the category of new expression positions that could cause these kinds of implementation errors, too","m.mentions":{},"msgtype":"m.text"},"ts":1708011562122,"senderName":"Michael Ficarra","senderId":"@michaelficarra:matrix.org","id":"$IBh3LHDrbX7rJ-jGgaiiYWNPOXp3c_9e-Ydyz1L1kSo"}
]