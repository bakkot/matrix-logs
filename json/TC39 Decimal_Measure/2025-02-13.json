[
{"content":{"body":"one thing that's nice about having decimal as the underlying data for measure/amount (and, looking forward, for smart units), is that things like reciporcals, squaring & cubing, multiplication arise quite naturally. Decimal128 is a good fit because it offers a lot of precision in the face of these operations","m.mentions":{},"msgtype":"m.text"},"ts":1739431197396,"senderName":"Jesse","senderId":"@jesse:igalia.com","id":"$TjJQzCdiqXX46LL0Et4LteOaWzsXM1cP0TAtJf9ZDII"},
{"content":{"body":"Mostly I'm trying to estimate complexity in terms of the conceptual load we're introducing. Right now we have two types in the spec that hold a numerical value (number and bigint), and with Amount we're due to introduce a third one. The core pitch with Decimal (as I understand it) is to represent decimal numbers, i.e. ones coming from the real world. But don't those almost always have some implicit unit attached? Its stated primary use case is for monetary values, so why not include the currency code with the value? I would think that it would be a very positive feature for something like\n```\nnew Amount(42, { currency: 'USD' }).add(new Amount(13, { currency: 'BTC' }))\n```\nto throw an error.\n\nSo from a JS developer point of view, I would think that it'd be simpler to understand a single Amount as being the thing to use for values coming from the real world, rather than needing to decide between an Amount and a Decimal, depending on what sort of operations might need to be done with the value.","format":"org.matrix.custom.html","formatted_body":"<p>Mostly I'm trying to estimate complexity in terms of the conceptual load we're introducing. Right now we have two types in the spec that hold a numerical value (number and bigint), and with Amount we're due to introduce a third one. The core pitch with Decimal (as I understand it) is to represent decimal numbers, i.e. ones coming from the real world. But don't those almost always have some implicit unit attached? Its stated primary use case is for monetary values, so why not include the currency code with the value? I would think that it would be a very positive feature for something like</p>\n<pre><code>new Amount(42, { currency: 'USD' }).add(new Amount(13, { currency: 'BTC' }))\n</code></pre>\n<p>to throw an error.</p>\n<p>So from a JS developer point of view, I would think that it'd be simpler to understand a single Amount as being the thing to use for values coming from the real world, rather than needing to decide between an Amount and a Decimal, depending on what sort of operations might need to be done with the value.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1739447861000,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$LmHrSiswkCYmrF0sLOgNXdh5HpcG7yG2yHIzbOYbn3o"},
{"content":{"body":"Let's say I start with two values\n```\nconst foo = new Amount(42, { currency: 'EUR' })\nconst bar = new Amount(13, { currency: 'EUR' })\n```\n\nWith an amount that did decimal math, I could add those up as\n```\nfoo.add(bar)\n```\nbut if their values were Decimal instances, then I'd need to do\n```\nconst sum = foo.value.add(bar.value)\nnew Amount(sum, { currency: foo.currency })\n```\n\nTo me that seems clumsier, more verbose, and it skips all the validation fo the former about `foo` and `bar` being addable.","format":"org.matrix.custom.html","formatted_body":"<p>Let's say I start with two values</p>\n<pre><code>const foo = new Amount(42, { currency: 'EUR' })\nconst bar = new Amount(13, { currency: 'EUR' })\n</code></pre>\n<p>With an amount that did decimal math, I could add those up as</p>\n<pre><code>foo.add(bar)\n</code></pre>\n<p>but if their values were Decimal instances, then I'd need to do</p>\n<pre><code>const sum = foo.value.add(bar.value)\nnew Amount(sum, { currency: foo.currency })\n</code></pre>\n<p>To me that seems clumsier, more verbose, and it skips all the validation fo the former about <code>foo</code> and <code>bar</code> being addable.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1739448090149,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$MeUTx9ZpSE5p5OwJ6c6dTnRt6YI0SDmxr204sgu0BAw"},
{"content":{"body":"Are there many use cases for decimal values that do not have an implicit unit or currency attached to them?","m.mentions":{},"msgtype":"m.text"},"ts":1739448235303,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$wNhc7stOaKKZfZ03iu8kKn8kk4PdkjXJJVp7mqvzfbA"},
{"content":{"body":"Is there a meeting today at 18:00?","m.mentions":{},"msgtype":"m.text"},"ts":1739456458762,"senderName":"sffc","senderId":"@sffc:mozilla.org","id":"$zzrsIi0vrr-po7XOMMGD8Y7X4nL0v8zMb_R6mXv7K8A"},
{"content":{"body":"I at least intend to join the call at the link mentioned in the Reflector issue: https://meetings.igalia.com/tc39jsnumerics","m.mentions":{},"msgtype":"m.text"},"ts":1739456955979,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$TUxWUI-XnVPcRbYZsD6-8IKgT_Z5Alu3qWUpwYS_Vqs"},
{"content":{"body":"Also, issue link: https://github.com/tc39/Reflector/issues/551","m.mentions":{},"msgtype":"m.text"},"ts":1739456985618,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$7HmgDrfmYJdemJT3J0ciLQ86G9RLoOkjLs0QHqpDv-M"},
{"content":{"body":"yes, meeting today at 18:00 CET!","m.mentions":{},"msgtype":"m.text"},"ts":1739457581074,"senderName":"Jesse","senderId":"@jesse:igalia.com","id":"$bJfPidgXXGm1cOsDAarezu3_SHlQgC50VZ9nG2onHcs"},
{"content":{"body":"(it's not yet in the TC39 calendar yet, sorry)","m.mentions":{},"msgtype":"m.text"},"ts":1739457592127,"senderName":"Jesse","senderId":"@jesse:igalia.com","id":"$5J8t1MpwptrcbGpbgYRoMpqjK-TqGWqt5ANoQWRGZ_A"},
{"content":{"body":"eemeli: Do you have any thoughts on the complexity that nicolo-ribaudo noted?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@eemeli:mozilla.org\">eemeli</a>: Do you have any thoughts on the complexity that <a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a> noted?","m.mentions":{"user_ids":["@eemeli:mozilla.org","@nicolo-ribaudo:matrix.org"]},"msgtype":"m.text"},"ts":1739461559019,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$xXj9Js-V3l1_IbJlsl64svHKtFWA-ihLmE6-DCF_3qI"},
{"content":{"body":"The compatibility check will need to take into account the operation type and possibly include a conversion; for instance, adding `meter` and `centimeter` should be allowed with a conversion of one into the other, while adding `kilogram` to `meter-per-second` should fail. Multiplying a `kilogram` with a `meter-per-second` should still work, resulting in a `kilogram-meter-per-second`. The `-per-` infix/divisor is already supported by Intl.NumberFormat, btw.\n\nSimilarly, adding a unitless value to one with a unit should fail, while multiplication ought to work. Currencies should not be considered convertible between different codes.\n\nIn general, operating on things that may include a unit/currency and a precision indicator in addition to a numerical value does add a little bit of work, but only when those fields are actually used. Beyond the compatibility check & possible conversion, we would need to apply some strategy to merging the precisions.\n\nAs a default strategy, the significant-figures approach should work: If either Amount has its precision as fraction digits, that number is converted to significant digits by adding `Math.floor(Math.log10(n) + 1)` to the value. if only one Amount has it set, that's applied on the result. If both have, then the smaller significant digits value is applied to the result. This same strategy can work for all arithmetic operations.\n\nAs a later step, it could be possible to customize the precision calculation strategy, similarly to how it's possible to consider different precision indicators to work next to fraction & significant digits (e.g. error bars).\n\nThe arithmetic operation on the value ought to be defined just as it is currently proposed for Decimal.","format":"org.matrix.custom.html","formatted_body":"<p>The compatibility check will need to take into account the operation type and possibly include a conversion; for instance, adding <code>meter</code> and <code>centimeter</code> should be allowed with a conversion of one into the other, while adding <code>kilogram</code> to <code>meter-per-second</code> should fail. Multiplying a <code>kilogram</code> with a <code>meter-per-second</code> should still work, resulting in a <code>kilogram-meter-per-second</code>. The <code>-per-</code> infix/divisor is already supported by Intl.NumberFormat, btw.</p>\n<p>Similarly, adding a unitless value to one with a unit should fail, while multiplication ought to work. Currencies should not be considered convertible between different codes.</p>\n<p>In general, operating on things that may include a unit/currency and a precision indicator in addition to a numerical value does add a little bit of work, but only when those fields are actually used. Beyond the compatibility check &amp; possible conversion, we would need to apply some strategy to merging the precisions.</p>\n<p>As a default strategy, the significant-figures approach should work: If either Amount has its precision as fraction digits, that number is converted to significant digits by adding <code>Math.floor(Math.log10(n) + 1)</code> to the value. if only one Amount has it set, that's applied on the result. If both have, then the smaller significant digits value is applied to the result. This same strategy can work for all arithmetic operations.</p>\n<p>As a later step, it could be possible to customize the precision calculation strategy, similarly to how it's possible to consider different precision indicators to work next to fraction &amp; significant digits (e.g. error bars).</p>\n<p>The arithmetic operation on the value ought to be defined just as it is currently proposed for Decimal.</p>\n","m.mentions":{"user_ids":["@nicolo-ribaudo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$vuOiL3jQH7gYaCByJbRjXM8GX3NE37pxG6YgeeADjm0"}},"msgtype":"m.text"},"ts":1739463585985,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$anjzZOVslCzM1EpJComyzBHSZ2Ua_kmtaVTfOUkPxIg"},
{"content":{"body":"* The compatibility check will need to take into account the operation type and possibly include a conversion; for instance, adding `meter` and `centimeter` should be allowed with a conversion of one into the other, while adding `kilogram` to `meter-per-second` should fail. Multiplying a `kilogram` with a `meter-per-second` should still work, resulting in a `kilogram-meter-per-second`. The `-per-` infix/divisor is already supported by Intl.NumberFormat, btw.\n\nSimilarly, adding a unitless value to one with a unit should fail, while multiplication ought to work. Currencies should not be considered convertible between different codes.\n\nIn general, operating on things that may include a unit/currency and a precision indicator in addition to a numerical value does add a little bit of work, but only when those fields are actually used. Beyond the compatibility check & possible conversion, we would need to apply some strategy to merging the precisions.\n\nAs a default strategy, the significant-figures approach should work: If either Amount has its precision as fraction digits, that number is converted to significant digits by adding `Math.floor(Math.log10(n) + 1)` to the value. if only one Amount has a precision set, that's applied on the result. If both have, then the smaller significant digits value is applied to the result. This same strategy can work for all arithmetic operations.\n\nAs a later step, it could be possible to customize the precision calculation strategy, similarly to how it's possible to consider different precision indicators to work next to fraction & significant digits (e.g. error bars).\n\nThe arithmetic operation on the value ought to be defined just as it is currently proposed for Decimal.","format":"org.matrix.custom.html","formatted_body":"* <p>The compatibility check will need to take into account the operation type and possibly include a conversion; for instance, adding <code>meter</code> and <code>centimeter</code> should be allowed with a conversion of one into the other, while adding <code>kilogram</code> to <code>meter-per-second</code> should fail. Multiplying a <code>kilogram</code> with a <code>meter-per-second</code> should still work, resulting in a <code>kilogram-meter-per-second</code>. The <code>-per-</code> infix/divisor is already supported by Intl.NumberFormat, btw.</p>\n<p>Similarly, adding a unitless value to one with a unit should fail, while multiplication ought to work. Currencies should not be considered convertible between different codes.</p>\n<p>In general, operating on things that may include a unit/currency and a precision indicator in addition to a numerical value does add a little bit of work, but only when those fields are actually used. Beyond the compatibility check &amp; possible conversion, we would need to apply some strategy to merging the precisions.</p>\n<p>As a default strategy, the significant-figures approach should work: If either Amount has its precision as fraction digits, that number is converted to significant digits by adding <code>Math.floor(Math.log10(n) + 1)</code> to the value. if only one Amount has a precision set, that's applied on the result. If both have, then the smaller significant digits value is applied to the result. This same strategy can work for all arithmetic operations.</p>\n<p>As a later step, it could be possible to customize the precision calculation strategy, similarly to how it's possible to consider different precision indicators to work next to fraction &amp; significant digits (e.g. error bars).</p>\n<p>The arithmetic operation on the value ought to be defined just as it is currently proposed for Decimal.</p>\n","m.mentions":{},"m.new_content":{"body":"The compatibility check will need to take into account the operation type and possibly include a conversion; for instance, adding `meter` and `centimeter` should be allowed with a conversion of one into the other, while adding `kilogram` to `meter-per-second` should fail. Multiplying a `kilogram` with a `meter-per-second` should still work, resulting in a `kilogram-meter-per-second`. The `-per-` infix/divisor is already supported by Intl.NumberFormat, btw.\n\nSimilarly, adding a unitless value to one with a unit should fail, while multiplication ought to work. Currencies should not be considered convertible between different codes.\n\nIn general, operating on things that may include a unit/currency and a precision indicator in addition to a numerical value does add a little bit of work, but only when those fields are actually used. Beyond the compatibility check & possible conversion, we would need to apply some strategy to merging the precisions.\n\nAs a default strategy, the significant-figures approach should work: If either Amount has its precision as fraction digits, that number is converted to significant digits by adding `Math.floor(Math.log10(n) + 1)` to the value. if only one Amount has a precision set, that's applied on the result. If both have, then the smaller significant digits value is applied to the result. This same strategy can work for all arithmetic operations.\n\nAs a later step, it could be possible to customize the precision calculation strategy, similarly to how it's possible to consider different precision indicators to work next to fraction & significant digits (e.g. error bars).\n\nThe arithmetic operation on the value ought to be defined just as it is currently proposed for Decimal.","format":"org.matrix.custom.html","formatted_body":"<p>The compatibility check will need to take into account the operation type and possibly include a conversion; for instance, adding <code>meter</code> and <code>centimeter</code> should be allowed with a conversion of one into the other, while adding <code>kilogram</code> to <code>meter-per-second</code> should fail. Multiplying a <code>kilogram</code> with a <code>meter-per-second</code> should still work, resulting in a <code>kilogram-meter-per-second</code>. The <code>-per-</code> infix/divisor is already supported by Intl.NumberFormat, btw.</p>\n<p>Similarly, adding a unitless value to one with a unit should fail, while multiplication ought to work. Currencies should not be considered convertible between different codes.</p>\n<p>In general, operating on things that may include a unit/currency and a precision indicator in addition to a numerical value does add a little bit of work, but only when those fields are actually used. Beyond the compatibility check &amp; possible conversion, we would need to apply some strategy to merging the precisions.</p>\n<p>As a default strategy, the significant-figures approach should work: If either Amount has its precision as fraction digits, that number is converted to significant digits by adding <code>Math.floor(Math.log10(n) + 1)</code> to the value. if only one Amount has a precision set, that's applied on the result. If both have, then the smaller significant digits value is applied to the result. This same strategy can work for all arithmetic operations.</p>\n<p>As a later step, it could be possible to customize the precision calculation strategy, similarly to how it's possible to consider different precision indicators to work next to fraction &amp; significant digits (e.g. error bars).</p>\n<p>The arithmetic operation on the value ought to be defined just as it is currently proposed for Decimal.</p>\n","m.mentions":{"user_ids":["@nicolo-ribaudo:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$anjzZOVslCzM1EpJComyzBHSZ2Ua_kmtaVTfOUkPxIg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1739463689272,"senderName":"eemeli","senderId":"@eemeli:mozilla.org","id":"$Ycnn9qAKUkU_MSRZ8L1exqbXv7-p-V-Do-mKbbu5Qb0"}
]