[
{"content":{"body":"* I'm not even sure if per-store configurability (if it's a global default to push things in the call/resolve-time vs registration-time direction in the cases where both are available) will be a solution; sometimes you want the registration-time ancestor of the call-time ancestor","m.new_content":{"body":"I'm not even sure if per-store configurability (if it's a global default to push things in the call/resolve-time vs registration-time direction in the cases where both are available) will be a solution; sometimes you want the registration-time ancestor of the call-time ancestor","msgtype":"m.text"},"m.relates_to":{"event_id":"$ryBuQY1TAk-YaTynFMThn1qNuIQuUtSiUuqvXk4jzFM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716257431037,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XBazbfVz7CKB5_Ld08XJq-u9gZbWOxutxIt7O-UgZtk"},
{"content":{"body":"Wow, this really blew up over the last few days","msgtype":"m.text"},"ts":1716265940824,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$IWsipWsPkVjZi22So4B-r8-o4n5ftZs2rSZOA837Q4E"},
{"content":{"body":"> <@stephenbelanger:matrix.org> It's not _just_ the timing of enabling PromiseHook. It is that the portion of an async function _before_ the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.\n\nI donâ€™t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesnâ€™t matter where the awaits are.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24e81Db5rUOuJqELJkBTIAC6zEjDm0KHxPZuBX11_DxBM\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br />It's not <em>just</em> the timing of enabling PromiseHook. It is that the portion of an async function <em>before</em> the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.</blockquote></mx-reply>I donâ€™t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesnâ€™t matter where the awaits are.","m.relates_to":{"m.in_reply_to":{"event_id":"$e81Db5rUOuJqELJkBTIAC6zEjDm0KHxPZuBX11_DxBM"}},"msgtype":"m.text"},"ts":1716266048689,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$J7GW2rvBLD-Z0CAn67XpYnYGS6silxRBjuVKrDCCaIY"},
{"content":{"body":"> <@legendecas:matrix.org> The proposal as it current stands is maintaining the lexical consistent value inside a async function body across `await` for `AsyncContext.Variable`, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.\n\nExactly.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24S4OmJohIvXsYjwtstNmKt2U08TnljgtYw_7a4nhaKvQ\">In reply to</a><a href=\"https://matrix.to/#/%40legendecas%3Amatrix.org\">@legendecas:matrix.org</a><br />The proposal as it current stands is maintaining the lexical consistent value inside a async function body across <code>await</code> for <code>AsyncContext.Variable</code>, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.</blockquote></mx-reply>Exactly.","m.relates_to":{"m.in_reply_to":{"event_id":"$S4OmJohIvXsYjwtstNmKt2U08TnljgtYw_7a4nhaKvQ"}},"msgtype":"m.text"},"ts":1716266075911,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ht1_uQvSu-IQ2SaA-apuv7lUmTJC4sDWNZo07uijGJs"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Yes. That is actually what users keep telling me they are _expecting_.\n\nAre there links to issue reports for this?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%242EcBVuanDELbtF-R0YQCsVt-TGdwVBXolmCJJgq4vHY\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br />Yes. That is actually what users keep telling me they are <em>expecting</em>.</blockquote></mx-reply>Are there links to issue reports for this?","m.relates_to":{"m.in_reply_to":{"event_id":"$2EcBVuanDELbtF-R0YQCsVt-TGdwVBXolmCJJgq4vHY"}},"msgtype":"m.text"},"ts":1716266139959,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$cI5sAUtz_PXzDZ6SOWYLXzKV0eco7JM6DPFxcem7S_A"},
{"content":{"body":"> <@shaylew:matrix.org> (See the warnings about rust `tracing::Span` in async code https://docs.rs/tracing/latest/tracing/span/struct.Span.html#in-asynchronous-code for some consequences of this sort of design in the wild -- but they're better off because Futures are expressive enough to write `Future::instrument` without needing built-in help)\n\nThis example doesnâ€™t apply in our case, since any cooperate threading (another promise resuming in JS) would have restored its own context.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24xVDD-YHyM2CwOU9BJXcBJQkDMnUXXmthWTudW4KJOo0\">In reply to</a><a href=\"https://matrix.to/#/%40shaylew%3Amatrix.org\">@shaylew:matrix.org</a><br />(See the warnings about rust <code>tracing::Span</code> in async code https://docs.rs/tracing/latest/tracing/span/struct.Span.html#in-asynchronous-code for some consequences of this sort of design in the wild -- but they're better off because Futures are expressive enough to write <code>Future::instrument</code> without needing built-in help)</blockquote></mx-reply>This example doesnâ€™t apply in our case, since any cooperate threading (another promise resuming in JS) would have restored its own context.","m.relates_to":{"m.in_reply_to":{"event_id":"$xVDD-YHyM2CwOU9BJXcBJQkDMnUXXmthWTudW4KJOo0"}},"msgtype":"m.text"},"ts":1716266223363,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ThYwMuDt3oeRTiB3YtAQiQZChZYe3zj6PdqF1sEV1ng"},
{"content":{"body":"> <@abotella:igalia.com> sure, people rewriting code from callbacks to promises might prefer resolution time, but what about people writing async/await code from scratch? Do we know what they need? Would we be breaking them?\n\nAnd itâ€™s not just web APIs, anything trying to cache fetches or other async behavior, any module level initializion using a promise, will break any user.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24xG_pP60Uu_Zg1MIaT7yqOSXcuD-_0ZUrmgFLnxm7QoY\">In reply to</a><a href=\"https://matrix.to/#/%40abotella%3Aigalia.com\">@abotella:igalia.com</a><br />sure, people rewriting code from callbacks to promises might prefer resolution time, but what about people writing async/await code from scratch? Do we know what they need? Would we be breaking them?</blockquote></mx-reply>And itâ€™s not just web APIs, anything trying to cache fetches or other async behavior, any module level initializion using a promise, will break any user.","m.relates_to":{"m.in_reply_to":{"event_id":"$xG_pP60Uu_Zg1MIaT7yqOSXcuD-_0ZUrmgFLnxm7QoY"}},"msgtype":"m.text"},"ts":1716266645909,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$qyJT_M5XDmDoulj2sbvLPdlQI9pjqmYxhgillOk40z4"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Flowing _around_ is essentially just local variable scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case _why_ anyone would want that flow but have not yet got any answer on that. ðŸ¤”\n\nItâ€™s a local variable scope that propagates to child calls automatically. I explicitly want this becasue itâ€™s understandable, and easy to debug.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24Mkao1EfWuQGyTH6bR7IPAjokFjaYz1Abkn4avXUTqZA\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br />Flowing <em>around</em> is essentially just local variable scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case <em>why</em> anyone would want that flow but have not yet got any answer on that. ðŸ¤”</blockquote></mx-reply>Itâ€™s a local variable scope that propagates to child calls automatically. I explicitly want this becasue itâ€™s understandable, and easy to debug.","m.relates_to":{"m.in_reply_to":{"event_id":"$Mkao1EfWuQGyTH6bR7IPAjokFjaYz1Abkn4avXUTqZA"}},"msgtype":"m.text"},"ts":1716266843961,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$y5DKxn6NCzN7MTCni1ctV5BqAFOd-dzjlI054hud4HQ"},
{"content":{"body":"> <@abotella:igalia.com> even with `.set()`, I don't think this would be dynamic scoping, at least not in the sense that https://github.com/tc39/proposal-async-context/blob/master/SCOPING.md discusses\n\nUnfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they [reasoned](https://github.com/endojs/endo/pull/1424) about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24AIM8URDD1qR5yIIWIKC4Cni8-br0ycKaywqGAHZX14s\">In reply to</a><a href=\"https://matrix.to/#/%40abotella%3Aigalia.com\">@abotella:igalia.com</a><br />even with <code>.set()</code>, I don't think this would be dynamic scoping, at least not in the sense that https://github.com/tc39/proposal-async-context/blob/master/SCOPING.md discusses</blockquote></mx-reply>Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they <a data-md href=\"https://github.com/endojs/endo/pull/1424\">reasoned</a> about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.","m.relates_to":{"m.in_reply_to":{"event_id":"$AIM8URDD1qR5yIIWIKC4Cni8-br0ycKaywqGAHZX14s"}},"msgtype":"m.text"},"ts":1716266986399,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$BROpTk5Quk0KF_WsLpM0Vu4yr2cVmg4eq4tGVL2SdNw"},
{"content":{"body":"> <@stephenhicks:matrix.org> One concern I have with the mutable variable idea is how one is supposed to bound the mutation - I think it's common to make a change with a lifetime, which is why we've gravitated toward the `run()` encapsulation.  As you've pointed out, with the flow-through semantics, `run` is very clearly the wrong name, and `set` is much more appropriate.  But your example also hints at some mechanism whereby changes to the variable would still somehow go out of scope?  I think that's important, but it seems like it would lead to lots of confusion.  If some other scope is entered internally, would that inner scope accidentally prune off a branch of var mutations?  That also doesn't seem right.\n\nI think allowing unbounded `set`s opens up the same problems as scoping, and introduces a global leak that is unfixable (how do you ever know when the last set value is not needed anymore?).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24O2xCHhzaTg4bBosv8plBgiALDWJjvLZ_HLo-VmbgZHE\">In reply to</a><a href=\"https://matrix.to/#/%40stephenhicks%3Amatrix.org\">@stephenhicks:matrix.org</a><br />One concern I have with the mutable variable idea is how one is supposed to bound the mutation - I think it's common to make a change with a lifetime, which is why we've gravitated toward the <code>run()</code> encapsulation.  As you've pointed out, with the flow-through semantics, <code>run</code> is very clearly the wrong name, and <code>set</code> is much more appropriate.  But your example also hints at some mechanism whereby changes to the variable would still somehow go out of scope?  I think that's important, but it seems like it would lead to lots of confusion.  If some other scope is entered internally, would that inner scope accidentally prune off a branch of var mutations?  That also doesn't seem right.</blockquote></mx-reply>I think allowing unbounded <code data-md=\"`\">set</code>s opens up the same problems as scoping, and introduces a global leak that is unfixable (how do you ever know when the last set value is not needed anymore?).","m.relates_to":{"m.in_reply_to":{"event_id":"$O2xCHhzaTg4bBosv8plBgiALDWJjvLZ_HLo-VmbgZHE"}},"msgtype":"m.text"},"ts":1716267116361,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$IgD43mXmpbyG09HttMHjP2rYHxGCCBkfJVK3cN60svE"}
]