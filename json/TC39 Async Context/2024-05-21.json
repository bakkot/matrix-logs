[
{"content":{"body":"* I'm not even sure if per-store configurability (if it's a global default to push things in the call/resolve-time vs registration-time direction in the cases where both are available) will be a solution; sometimes you want the registration-time ancestor of the call-time ancestor","m.new_content":{"body":"I'm not even sure if per-store configurability (if it's a global default to push things in the call/resolve-time vs registration-time direction in the cases where both are available) will be a solution; sometimes you want the registration-time ancestor of the call-time ancestor","msgtype":"m.text"},"m.relates_to":{"event_id":"$ryBuQY1TAk-YaTynFMThn1qNuIQuUtSiUuqvXk4jzFM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716257431037,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XBazbfVz7CKB5_Ld08XJq-u9gZbWOxutxIt7O-UgZtk"},
{"content":{"body":"Wow, this really blew up over the last few days","msgtype":"m.text"},"ts":1716265940824,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$IWsipWsPkVjZi22So4B-r8-o4n5ftZs2rSZOA837Q4E"},
{"content":{"body":"> <@stephenbelanger:matrix.org> It's not _just_ the timing of enabling PromiseHook. It is that the portion of an async function _before_ the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.\n\nI donâ€™t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesnâ€™t matter where the awaits are.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24e81Db5rUOuJqELJkBTIAC6zEjDm0KHxPZuBX11_DxBM\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br />It's not <em>just</em> the timing of enabling PromiseHook. It is that the portion of an async function <em>before</em> the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.</blockquote></mx-reply>I donâ€™t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesnâ€™t matter where the awaits are.","m.relates_to":{"m.in_reply_to":{"event_id":"$e81Db5rUOuJqELJkBTIAC6zEjDm0KHxPZuBX11_DxBM"}},"msgtype":"m.text"},"ts":1716266048689,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$J7GW2rvBLD-Z0CAn67XpYnYGS6silxRBjuVKrDCCaIY"},
{"content":{"body":"> <@legendecas:matrix.org> The proposal as it current stands is maintaining the lexical consistent value inside a async function body across `await` for `AsyncContext.Variable`, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.\n\nExactly.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24S4OmJohIvXsYjwtstNmKt2U08TnljgtYw_7a4nhaKvQ\">In reply to</a><a href=\"https://matrix.to/#/%40legendecas%3Amatrix.org\">@legendecas:matrix.org</a><br />The proposal as it current stands is maintaining the lexical consistent value inside a async function body across <code>await</code> for <code>AsyncContext.Variable</code>, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.</blockquote></mx-reply>Exactly.","m.relates_to":{"m.in_reply_to":{"event_id":"$S4OmJohIvXsYjwtstNmKt2U08TnljgtYw_7a4nhaKvQ"}},"msgtype":"m.text"},"ts":1716266075911,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ht1_uQvSu-IQ2SaA-apuv7lUmTJC4sDWNZo07uijGJs"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Yes. That is actually what users keep telling me they are _expecting_.\n\nAre there links to issue reports for this?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%242EcBVuanDELbtF-R0YQCsVt-TGdwVBXolmCJJgq4vHY\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br />Yes. That is actually what users keep telling me they are <em>expecting</em>.</blockquote></mx-reply>Are there links to issue reports for this?","m.relates_to":{"m.in_reply_to":{"event_id":"$2EcBVuanDELbtF-R0YQCsVt-TGdwVBXolmCJJgq4vHY"}},"msgtype":"m.text"},"ts":1716266139959,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$cI5sAUtz_PXzDZ6SOWYLXzKV0eco7JM6DPFxcem7S_A"},
{"content":{"body":"> <@shaylew:matrix.org> (See the warnings about rust `tracing::Span` in async code https://docs.rs/tracing/latest/tracing/span/struct.Span.html#in-asynchronous-code for some consequences of this sort of design in the wild -- but they're better off because Futures are expressive enough to write `Future::instrument` without needing built-in help)\n\nThis example doesnâ€™t apply in our case, since any cooperate threading (another promise resuming in JS) would have restored its own context.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24xVDD-YHyM2CwOU9BJXcBJQkDMnUXXmthWTudW4KJOo0\">In reply to</a><a href=\"https://matrix.to/#/%40shaylew%3Amatrix.org\">@shaylew:matrix.org</a><br />(See the warnings about rust <code>tracing::Span</code> in async code https://docs.rs/tracing/latest/tracing/span/struct.Span.html#in-asynchronous-code for some consequences of this sort of design in the wild -- but they're better off because Futures are expressive enough to write <code>Future::instrument</code> without needing built-in help)</blockquote></mx-reply>This example doesnâ€™t apply in our case, since any cooperate threading (another promise resuming in JS) would have restored its own context.","m.relates_to":{"m.in_reply_to":{"event_id":"$xVDD-YHyM2CwOU9BJXcBJQkDMnUXXmthWTudW4KJOo0"}},"msgtype":"m.text"},"ts":1716266223363,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ThYwMuDt3oeRTiB3YtAQiQZChZYe3zj6PdqF1sEV1ng"},
{"content":{"body":"> <@abotella:igalia.com> sure, people rewriting code from callbacks to promises might prefer resolution time, but what about people writing async/await code from scratch? Do we know what they need? Would we be breaking them?\n\nAnd itâ€™s not just web APIs, anything trying to cache fetches or other async behavior, any module level initializion using a promise, will break any user.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24xG_pP60Uu_Zg1MIaT7yqOSXcuD-_0ZUrmgFLnxm7QoY\">In reply to</a><a href=\"https://matrix.to/#/%40abotella%3Aigalia.com\">@abotella:igalia.com</a><br />sure, people rewriting code from callbacks to promises might prefer resolution time, but what about people writing async/await code from scratch? Do we know what they need? Would we be breaking them?</blockquote></mx-reply>And itâ€™s not just web APIs, anything trying to cache fetches or other async behavior, any module level initializion using a promise, will break any user.","m.relates_to":{"m.in_reply_to":{"event_id":"$xG_pP60Uu_Zg1MIaT7yqOSXcuD-_0ZUrmgFLnxm7QoY"}},"msgtype":"m.text"},"ts":1716266645909,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$qyJT_M5XDmDoulj2sbvLPdlQI9pjqmYxhgillOk40z4"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Flowing _around_ is essentially just local variable scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case _why_ anyone would want that flow but have not yet got any answer on that. ðŸ¤”\n\nItâ€™s a local variable scope that propagates to child calls automatically. I explicitly want this becasue itâ€™s understandable, and easy to debug.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24Mkao1EfWuQGyTH6bR7IPAjokFjaYz1Abkn4avXUTqZA\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br />Flowing <em>around</em> is essentially just local variable scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case <em>why</em> anyone would want that flow but have not yet got any answer on that. ðŸ¤”</blockquote></mx-reply>Itâ€™s a local variable scope that propagates to child calls automatically. I explicitly want this becasue itâ€™s understandable, and easy to debug.","m.relates_to":{"m.in_reply_to":{"event_id":"$Mkao1EfWuQGyTH6bR7IPAjokFjaYz1Abkn4avXUTqZA"}},"msgtype":"m.text"},"ts":1716266843961,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$y5DKxn6NCzN7MTCni1ctV5BqAFOd-dzjlI054hud4HQ"},
{"content":{"body":"> <@abotella:igalia.com> even with `.set()`, I don't think this would be dynamic scoping, at least not in the sense that https://github.com/tc39/proposal-async-context/blob/master/SCOPING.md discusses\n\nUnfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they [reasoned](https://github.com/endojs/endo/pull/1424) about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24AIM8URDD1qR5yIIWIKC4Cni8-br0ycKaywqGAHZX14s\">In reply to</a><a href=\"https://matrix.to/#/%40abotella%3Aigalia.com\">@abotella:igalia.com</a><br />even with <code>.set()</code>, I don't think this would be dynamic scoping, at least not in the sense that https://github.com/tc39/proposal-async-context/blob/master/SCOPING.md discusses</blockquote></mx-reply>Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they <a data-md href=\"https://github.com/endojs/endo/pull/1424\">reasoned</a> about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.","m.relates_to":{"m.in_reply_to":{"event_id":"$AIM8URDD1qR5yIIWIKC4Cni8-br0ycKaywqGAHZX14s"}},"msgtype":"m.text"},"ts":1716266986399,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$BROpTk5Quk0KF_WsLpM0Vu4yr2cVmg4eq4tGVL2SdNw"},
{"content":{"body":"> <@stephenhicks:matrix.org> One concern I have with the mutable variable idea is how one is supposed to bound the mutation - I think it's common to make a change with a lifetime, which is why we've gravitated toward the `run()` encapsulation.  As you've pointed out, with the flow-through semantics, `run` is very clearly the wrong name, and `set` is much more appropriate.  But your example also hints at some mechanism whereby changes to the variable would still somehow go out of scope?  I think that's important, but it seems like it would lead to lots of confusion.  If some other scope is entered internally, would that inner scope accidentally prune off a branch of var mutations?  That also doesn't seem right.\n\nI think allowing unbounded `set`s opens up the same problems as scoping, and introduces a global leak that is unfixable (how do you ever know when the last set value is not needed anymore?).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24O2xCHhzaTg4bBosv8plBgiALDWJjvLZ_HLo-VmbgZHE\">In reply to</a><a href=\"https://matrix.to/#/%40stephenhicks%3Amatrix.org\">@stephenhicks:matrix.org</a><br />One concern I have with the mutable variable idea is how one is supposed to bound the mutation - I think it's common to make a change with a lifetime, which is why we've gravitated toward the <code>run()</code> encapsulation.  As you've pointed out, with the flow-through semantics, <code>run</code> is very clearly the wrong name, and <code>set</code> is much more appropriate.  But your example also hints at some mechanism whereby changes to the variable would still somehow go out of scope?  I think that's important, but it seems like it would lead to lots of confusion.  If some other scope is entered internally, would that inner scope accidentally prune off a branch of var mutations?  That also doesn't seem right.</blockquote></mx-reply>I think allowing unbounded <code data-md=\"`\">set</code>s opens up the same problems as scoping, and introduces a global leak that is unfixable (how do you ever know when the last set value is not needed anymore?).","m.relates_to":{"m.in_reply_to":{"event_id":"$O2xCHhzaTg4bBosv8plBgiALDWJjvLZ_HLo-VmbgZHE"}},"msgtype":"m.text"},"ts":1716267116361,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$IgD43mXmpbyG09HttMHjP2rYHxGCCBkfJVK3cN60svE"},
{"content":{"body":"> <@stephenbelanger:matrix.org> There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically _guess_ what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which _could_ be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we _want_ is for the _correct_ context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.\n\nI think this is what Iâ€™m missing. I donâ€™t understand why could would need to guess, Iâ€™m naively assuming its always follows-from the last child and child-of the current parent. Whatâ€™s a case where this isnâ€™t correct? How does the flows-through solve holding holding the hundreds of thousands of concurrent spans?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%247845b1Ylx3JkiWv6_8b0hC6-nGeUDFf8tFhq98KG9HU\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br />There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically <em>guess</em> what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which <em>could</em> be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we <em>want</em> is for the <em>correct</em> context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.</blockquote></mx-reply>I think this is what Iâ€™m missing. I donâ€™t understand why could would need to guess, Iâ€™m naively assuming its always follows-from the last child and child-of the current parent. Whatâ€™s a case where this isnâ€™t correct? How does the flows-through solve holding holding the hundreds of thousands of concurrent spans?","m.relates_to":{"m.in_reply_to":{"event_id":"$7845b1Ylx3JkiWv6_8b0hC6-nGeUDFf8tFhq98KG9HU"}},"msgtype":"m.text"},"ts":1716267429723,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$J04qbpt5vBynoFjWi2BICpzTzKYmLqb8FyIt_0c8sm8"},
{"content":{"body":"(Also, sorry for not respondning a whole lot, normal coprorate BS is taking up all my free time)","msgtype":"m.text"},"ts":1716267475614,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$sV311zUSXtQY-hx6C1yLH1QFBN4pseq-yYTth1IznQk"},
{"content":{"body":"> <@jridgewell:matrix.org> Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they [reasoned](https://github.com/endojs/endo/pull/1424) about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.\n\nis there any documentation anywhere about what SES needs from new proposals?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$BROpTk5Quk0KF_WsLpM0Vu4yr2cVmg4eq4tGVL2SdNw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they <a data-md href=\"https://github.com/endojs/endo/pull/1424\">reasoned</a> about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.</blockquote></mx-reply>is there any documentation anywhere about what SES needs from new proposals?","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$BROpTk5Quk0KF_WsLpM0Vu4yr2cVmg4eq4tGVL2SdNw"}},"msgtype":"m.text"},"ts":1716281377801,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$w_ZSe9TPq4i_OR_HShDRVue3P3b8OGMQylfHv82R-cU"},
{"content":{"body":"> <@littledan:matrix.org> Honestly I have to agree with others who pointed out that some in TC39 will see this version to be \"not well behaved\"\n\nIn my view, considering in-place mutation as \"not well behaved\" because of unintended flow consequences just says to me that the flow model is not clearly defined and _correct_ enough to be _certain_ of what the behaviour will be. If the model is actually _correct_ and _consistent_ then there should be no reason that setting partway through a scope should produce any sort of unexpected behaviour.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$y8QQYsPoB6MME9bFzlTaLMfb12GGR6g6IO425ZGi1EY?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Honestly I have to agree with others who pointed out that some in TC39 will see this version to be &quot;not well behaved&quot;</blockquote></mx-reply>In my view, considering in-place mutation as \"not well behaved\" because of unintended flow consequences just says to me that the flow model is not clearly defined and <em>correct</em> enough to be <em>certain</em> of what the behaviour will be. If the model is actually <em>correct</em> and <em>consistent</em> then there should be no reason that setting partway through a scope should produce any sort of unexpected behaviour.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$y8QQYsPoB6MME9bFzlTaLMfb12GGR6g6IO425ZGi1EY"}},"msgtype":"m.text"},"ts":1716282077088,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$lhdjxjhczMYsCW6rYoTLhk3hb0lshf9QAE4POf9uGHQ"},
{"content":{"body":"> <@jasnell:matrix.org> I just have to admit the use cases are valid and there are many places where We Need Both .... makes things way more complicated tho\n\nYes, particularly with async/await the callback-scoped version starts to make less and less sense. This was the whole reason that way back _before_ we settled on `AsyncLocalStorage` I was backing the `AsyncLocal` proposal which _only_ did the set/get style and left the flow scoping semantics up to the runtime to get right.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$Q7TPj-TGO7SKy0o-el3aoqx6hLthUB9Rzk2F3CwRsNE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jasnell:matrix.org\">@jasnell:matrix.org</a><br>I just have to admit the use cases are valid and there are many places where We Need Both .... makes things way more complicated tho</blockquote></mx-reply>Yes, particularly with async/await the callback-scoped version starts to make less and less sense. This was the whole reason that way back <em>before</em> we settled on <code>AsyncLocalStorage</code> I was backing the <code>AsyncLocal</code> proposal which <em>only</em> did the set/get style and left the flow scoping semantics up to the runtime to get right.","m.mentions":{"user_ids":["@jasnell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Q7TPj-TGO7SKy0o-el3aoqx6hLthUB9Rzk2F3CwRsNE"}},"msgtype":"m.text"},"ts":1716282184849,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$3P4irBNWwzmf6qT31fCjekDOjZPNkDOTJpCzofIH_JA"},
{"content":{"body":"> <@jridgewell:matrix.org> Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they [reasoned](https://github.com/endojs/endo/pull/1424) about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.\n\nI'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable from an outer scope?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$BROpTk5Quk0KF_WsLpM0Vu4yr2cVmg4eq4tGVL2SdNw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they <a data-md href=\"https://github.com/endojs/endo/pull/1424\">reasoned</a> about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.</blockquote></mx-reply>I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable from an outer scope?","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$BROpTk5Quk0KF_WsLpM0Vu4yr2cVmg4eq4tGVL2SdNw"}},"msgtype":"m.text"},"ts":1716282390182,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$FfbAhz31YBdjZjBIBTTWqjrc71gen1m462NFZr2ignQ"},
{"content":{"body":"> <@jridgewell:matrix.org> Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they [reasoned](https://github.com/endojs/endo/pull/1424) about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.\n\n * I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$BROpTk5Quk0KF_WsLpM0Vu4yr2cVmg4eq4tGVL2SdNw?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they <a data-md=\"\" href=\"https://github.com/endojs/endo/pull/1424\">reasoned</a> about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.</blockquote></mx-reply> * I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?","m.mentions":{},"m.new_content":{"body":"I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?","format":"org.matrix.custom.html","formatted_body":"I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$FfbAhz31YBdjZjBIBTTWqjrc71gen1m462NFZr2ignQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716282406814,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$H0BqO19z2nA4Vv9ZyCkJKl_QgISoiMvfDil0qJFQB14"},
{"content":{"body":"> <@littledan:matrix.org> my experience with mutable dynamically bound variables in Factor was negative. It can be surprising how much or little the write to the variable is propagated up/backwards and then read by someone else. `.run` has a simple answer to this question: it isn't propagated up/backwards.\n\nIt doesn't mutate the slot, but if you store an object in it you can propagate mutations up the tree. I think all we can really do is make captures be a copy of what the reference points to at the time and not be the same binding, so at least that top-level mapping of store to value doesn't propagate upward. This is also partly _why_ I think it's important that it be treated as a _variable_ and not a _bag of data_, because data bags are problematic when it comes to leaking mutations.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$icrzyRaXAswsPBilYBUAY2p8WBl_CsimC5C3QrBj9LI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>my experience with mutable dynamically bound variables in Factor was negative. It can be surprising how much or little the write to the variable is propagated up/backwards and then read by someone else. <code>.run</code> has a simple answer to this question: it isn't propagated up/backwards.</blockquote></mx-reply>It doesn't mutate the slot, but if you store an object in it you can propagate mutations up the tree. I think all we can really do is make captures be a copy of what the reference points to at the time and not be the same binding, so at least that top-level mapping of store to value doesn't propagate upward. This is also partly <em>why</em> I think it's important that it be treated as a <em>variable</em> and not a <em>bag of data</em>, because data bags are problematic when it comes to leaking mutations.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$icrzyRaXAswsPBilYBUAY2p8WBl_CsimC5C3QrBj9LI"}},"msgtype":"m.text"},"ts":1716282481258,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$jXblGorXaDcBnvrK-lx87JZL7rw8EN5-k4f5KpPLNU8"},
{"content":{"body":"> <@littledan:matrix.org> so we ended up rediscovering that setting a dynamically scoped variable was an anti-pattern, and we moved towards doing .run instead\n\nThis is what I lean toward at this point, personally. Though I _do_ see that there are a few scenarios where it doesn't _quite_ work the way you want it unless you do things like breaking out of awaits. Unfortunately this is how the OTel context works--you can activate a context within the _current_ scope.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$XsUQ_6Lash2Q65FI1GoD6dwkuHrDNxTIIq7ls7_GRko?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>so we ended up rediscovering that setting a dynamically scoped variable was an anti-pattern, and we moved towards doing .run instead</blockquote></mx-reply>This is what I lean toward at this point, personally. Though I <em>do</em> see that there are a few scenarios where it doesn't <em>quite</em> work the way you want it unless you do things like breaking out of awaits. Unfortunately this is how the OTel context works--you can activate a context within the <em>current</em> scope.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$XsUQ_6Lash2Q65FI1GoD6dwkuHrDNxTIIq7ls7_GRko"}},"msgtype":"m.text"},"ts":1716282624371,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$5OroK6n4-I2cmQhQ1JkyRSjHs39DofwFsLKV99kEmd0"},
{"content":{"body":"What do you mean by breaking out of awaits?","msgtype":"m.text"},"ts":1716282681684,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$le0BRQj40XNFDAOnxVwLXeZBWWk1_228ObkJr1bAuBs"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.\n\nComparison with other languages would be really useful if we can figure out where to look ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.</blockquote></mx-reply>Comparison with other languages would be really useful if we can figure out where to look","m.relates_to":{"m.in_reply_to":{"event_id":"$hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY"}},"msgtype":"m.text"},"ts":1716283068949,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$CHBBS-7t_FAfTDjUBBNwz9AoKqAgqnfSrROJz_2L37A"},
{"content":{"body":"> <@jridgewell:matrix.org> I donâ€™t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesnâ€™t matter where the awaits are.\n\nThe spec, as it is presently, calls for capturing the context at the point where an await happens, not where the promise being awaited resolves. The context flows _into_ that promise, and it _would_ flow all the way to the point of resolving, but then we orphan that branch and return the context back to the captured value of that outer await.\n\nIn this particular example though, it's using `store.enterWith(...)` which effectively sets the value in the _current_ scope without creating a new scope first. Because the initial segment of an async function executes synchronously, if that occurs _before_ the first await of that _internal_ function then the point at which the outer function captures its await will have already change _its_ context and so will adopt that inner context. Whereas if that inner function modifies the current context _after_ the first await within that inner function it will have already passed the point where the outer function captured the await context and so it would _not_ use that value. The fact this sometimes changes the outer function context and sometimes doesn't is extremely confusing. Users are expecting it to _always_ change the outer context, as indicated in the issue, because it is logically a continuation and should therefore behave the same as it would were it written with callbacks instead.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$J7GW2rvBLD-Z0CAn67XpYnYGS6silxRBjuVKrDCCaIY?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>I donâ€™t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesnâ€™t matter where the awaits are.</blockquote></mx-reply><p>The spec, as it is presently, calls for capturing the context at the point where an await happens, not where the promise being awaited resolves. The context flows <em>into</em> that promise, and it <em>would</em> flow all the way to the point of resolving, but then we orphan that branch and return the context back to the captured value of that outer await.</p>\n<p>In this particular example though, it's using <code>store.enterWith(...)</code> which effectively sets the value in the <em>current</em> scope without creating a new scope first. Because the initial segment of an async function executes synchronously, if that occurs <em>before</em> the first await of that <em>internal</em> function then the point at which the outer function captures its await will have already change <em>its</em> context and so will adopt that inner context. Whereas if that inner function modifies the current context <em>after</em> the first await within that inner function it will have already passed the point where the outer function captured the await context and so it would <em>not</em> use that value. The fact this sometimes changes the outer function context and sometimes doesn't is extremely confusing. Users are expecting it to <em>always</em> change the outer context, as indicated in the issue, because it is logically a continuation and should therefore behave the same as it would were it written with callbacks instead.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$J7GW2rvBLD-Z0CAn67XpYnYGS6silxRBjuVKrDCCaIY"}},"msgtype":"m.text"},"ts":1716283331772,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$3sHajTIJT9-P5frOGLM2vmT7Nrinp3sgk1iSQJocucQ"},
{"content":{"body":"> <@jridgewell:matrix.org> Are there links to issue reports for this?\n\nThe issue I just posted yesterday was exactly this, and we get _numerous_ reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that _expected_ the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$cI5sAUtz_PXzDZ6SOWYLXzKV0eco7JM6DPFxcem7S_A?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Are there links to issue reports for this?</blockquote></mx-reply>The issue I just posted yesterday was exactly this, and we get <em>numerous</em> reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that <em>expected</em> the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$cI5sAUtz_PXzDZ6SOWYLXzKV0eco7JM6DPFxcem7S_A"}},"msgtype":"m.text"},"ts":1716283563875,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$wrjKYIlTRU4IVRB4_JV1h_v3qihmISlB1k3UBahN4Fw"},
{"content":{"body":"> <@jridgewell:matrix.org> Itâ€™s a local variable scope that propagates to child calls automatically. I explicitly want this becasue itâ€™s understandable, and easy to debug.\n\nYes, I get that people want this \"around\" flow. I'm fine with people wanting it. I'm just not clear what exactly the _reason_ is why they want it. What _specifically_ is the use case for that flow?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$y5DKxn6NCzN7MTCni1ctV5BqAFOd-dzjlI054hud4HQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Itâ€™s a local variable scope that propagates to child calls automatically. I explicitly want this becasue itâ€™s understandable, and easy to debug.</blockquote></mx-reply>Yes, I get that people want this \"around\" flow. I'm fine with people wanting it. I'm just not clear what exactly the <em>reason</em> is why they want it. What <em>specifically</em> is the use case for that flow?","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$y5DKxn6NCzN7MTCni1ctV5BqAFOd-dzjlI054hud4HQ"}},"msgtype":"m.text"},"ts":1716283678998,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$mbt4tRkExjNVKSDPt49s9HmvJBZSUR8RecrTFR0OA3w"},
{"content":{"body":"> <@jridgewell:matrix.org> I think this is what Iâ€™m missing. I donâ€™t understand why could would need to guess, Iâ€™m naively assuming its always follows-from the last child and child-of the current parent. Whatâ€™s a case where this isnâ€™t correct? How does the flows-through solve holding holding the hundreds of thousands of concurrent spans?\n\nConsider this code:\n\n```js\nasync function doSomething() {\n  await doAThing() // first span\n  await doAnotherThing() // no span\n  await doYetAnotherThing() // second span should be follows-from first\n}\n```\n\nIf we have call `doSomething()` twice in a `Promise.all(...)`, which we do not instrument or have any particular awareness of--maybe it's user code--then we'll get two spans being created for the first awaits of each, then when the second spans come in they will no have a way to differentiate because the `doSomething()` itself would have the same context when it runs both times and would be restoring that over the awaits, blowing away the context we had from the inner function calls which we otherwise _could_ associate with if we had flow-through semantics.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$J04qbpt5vBynoFjWi2BICpzTzKYmLqb8FyIt_0c8sm8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>I think this is what Iâ€™m missing. I donâ€™t understand why could would need to guess, Iâ€™m naively assuming its always follows-from the last child and child-of the current parent. Whatâ€™s a case where this isnâ€™t correct? How does the flows-through solve holding holding the hundreds of thousands of concurrent spans?</blockquote></mx-reply><p>Consider this code:</p>\n<pre><code class=\"language-js\">async function doSomething() {\n  await doAThing() // first span\n  await doAnotherThing() // no span\n  await doYetAnotherThing() // second span should be follows-from first\n}\n</code></pre>\n<p>If we have call <code>doSomething()</code> twice in a <code>Promise.all(...)</code>, which we do not instrument or have any particular awareness of--maybe it's user code--then we'll get two spans being created for the first awaits of each, then when the second spans come in they will no have a way to differentiate because the <code>doSomething()</code> itself would have the same context when it runs both times and would be restoring that over the awaits, blowing away the context we had from the inner function calls which we otherwise <em>could</em> associate with if we had flow-through semantics.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$J04qbpt5vBynoFjWi2BICpzTzKYmLqb8FyIt_0c8sm8"}},"msgtype":"m.text"},"ts":1716284163933,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$GSKpgZYYZpQ4PQ8MhgZ3Dn7qA2G-5nmnxdE7IKzsI6Y"},
{"content":{"body":"> <@abotella:igalia.com> I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?\n\nYeah, I really don't get what the security concerns are here. You need access to the variable instance to retrieve the data. Sharing any _normal_ variable would have the same security implications.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FfbAhz31YBdjZjBIBTTWqjrc71gen1m462NFZr2ignQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?</blockquote></mx-reply>Yeah, I really don't get what the security concerns are here. You need access to the variable instance to retrieve the data. Sharing any <em>normal</em> variable would have the same security implications.","m.mentions":{"user_ids":["@abotella:igalia.com","@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$FfbAhz31YBdjZjBIBTTWqjrc71gen1m462NFZr2ignQ"}},"msgtype":"m.text"},"ts":1716284343655,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$IsvoCo3Oj_tvor8_8M-GDLT5Kq1C_YBkmlECtbS7UQI"},
{"content":{"body":"> <@littledan:matrix.org> What do you mean by breaking out of awaits?\n\nI mean the flow-through semantics. The `store.run(...)` form is not particularly usable in async functions, having an in-scope mutation would make more sense, or _at least_ some way to inform the context to _not_ bind around the await when what you actually _want_ is the flow-through semantics.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$le0BRQj40XNFDAOnxVwLXeZBWWk1_228ObkJr1bAuBs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>What do you mean by breaking out of awaits?</blockquote></mx-reply>I mean the flow-through semantics. The <code>store.run(...)</code> form is not particularly usable in async functions, having an in-scope mutation would make more sense, or <em>at least</em> some way to inform the context to <em>not</em> bind around the await when what you actually <em>want</em> is the flow-through semantics.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$le0BRQj40XNFDAOnxVwLXeZBWWk1_228ObkJr1bAuBs"}},"msgtype":"m.text"},"ts":1716284504210,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$_KW1BOA-JOMjwoh3tvfeGgKSoTLtzfZw-nfwUpKmq30"},
{"content":{"body":"Most other languages I've seen don't have a user-provided scoping mechanism for context, the runtime decides it themselves.","m.mentions":{},"msgtype":"m.text"},"ts":1716284590330,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$z_UKYkUAj0L0pyLvTgvYs0tuZ008aIq50tDdCPleTRk"},
{"content":{"body":"Like Ruby does that with fiber locals as just a simple map that it manages on its own without any user-provided scopes.","m.mentions":{},"msgtype":"m.text"},"ts":1716284614840,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$YkvWceMbcMThAO36mR-Tyq-jUIw42Vh6tE7_WWApodQ"},
{"content":{"body":"https://docs.ruby-lang.org/en/master/Fiber.html#method-i-storage","m.mentions":{},"msgtype":"m.text"},"ts":1716284640706,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$e7OHjwELNwLZxpgLh1GbrJGGJnqihyQRkFFKCX92rOA"},
{"content":{"body":"And go has its explicit `Context` object which you have to pass through manually, but you basically do clones every time you want to modify it and it flows downward through the calls you make passing in the modified version.","format":"org.matrix.custom.html","formatted_body":"And go has its explicit <code>Context</code> object which you have to pass through manually, but you basically do clones every time you want to modify it and it flows downward through the calls you make passing in the modified version.","m.mentions":{},"msgtype":"m.text"},"ts":1716284726850,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$fqvImSdivTXqHiPH1lDsqHr8GzbUf9zoFYA7l710Kr0"},
{"content":{"body":".NET also has AsyncLocal, which is basically exactly what was originally proposed in Node.js _before_ AsyncLocalStorage was chosen instead, because people didn't trust the Node.js runtime to manage scopes correctly. https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0","format":"org.matrix.custom.html","formatted_body":".NET also has AsyncLocal, which is basically exactly what was originally proposed in Node.js <em>before</em> AsyncLocalStorage was chosen instead, because people didn't trust the Node.js runtime to manage scopes correctly. https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0","m.mentions":{},"msgtype":"m.text"},"ts":1716284801805,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$jTA6uMEeIOum5o14v9982GMBG98pkb_h49c8td1_rMA"},
{"content":{"body":"Again, doing the simple key/value hash map type structure with no user-supplied scoping mechanism.","m.mentions":{},"msgtype":"m.text"},"ts":1716284836876,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$4kp9Emb1jlJDJXPvtBT677Au8yiztV2iqz3OapoC2Uo"},
{"content":{"body":"> <@stephenbelanger:matrix.org> The issue I just posted yesterday was exactly this, and we get _numerous_ reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that _expected_ the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.\n\nThe issue was confusing for it's use on `enterWith` and performance optimization that make an `AsyncLocalStorage` behaves differently when modification of `AsyncLocalStorage` was performed at different positions in an async function body. Matteo could expand in detail about his original use case but as I talked to him in private I think `AsyncLocalStorage.run` could satisfy his needs.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$wrjKYIlTRU4IVRB4_JV1h_v3qihmISlB1k3UBahN4Fw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>The issue I just posted yesterday was exactly this, and we get <em>numerous</em> reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that <em>expected</em> the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.</blockquote></mx-reply>The issue was confusing for it's use on <code>enterWith</code> and performance optimization that make an <code>AsyncLocalStorage</code> behaves differently when modification of <code>AsyncLocalStorage</code> was performed at different positions in an async function body. Matteo could expand in detail about his original use case but as I talked to him in private I think <code>AsyncLocalStorage.run</code> could satisfy his needs.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$wrjKYIlTRU4IVRB4_JV1h_v3qihmISlB1k3UBahN4Fw"}},"msgtype":"m.text"},"ts":1716284848957,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$XrZbGYOqQGCg2sHQO56Nj-VNDxiyQ5a7b-G6IC0vxWw"},
{"content":{"body":"> <@stephenbelanger:matrix.org> The issue I just posted yesterday was exactly this, and we get _numerous_ reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that _expected_ the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.\n\n * The issue was confusing for it's use on `enterWith` and performance optimization that make an `AsyncLocalStorage` behaves differently when modification of `AsyncLocalStorage` was performed at different positions in an async function body. Matteo could expand in detail about his original use case but as I talked to him in private I think `AsyncLocalStorage.run` could satisfy his needs. Let's wait if he wants to expand on it on the issue.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$wrjKYIlTRU4IVRB4_JV1h_v3qihmISlB1k3UBahN4Fw?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>The issue I just posted yesterday was exactly this, and we get <em>numerous</em> reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that <em>expected</em> the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.</blockquote></mx-reply> * The issue was confusing for it's use on <code>enterWith</code> and performance optimization that make an <code>AsyncLocalStorage</code> behaves differently when modification of <code>AsyncLocalStorage</code> was performed at different positions in an async function body. Matteo could expand in detail about his original use case but as I talked to him in private I think <code>AsyncLocalStorage.run</code> could satisfy his needs. Let's wait if he wants to expand on it on the issue.","m.mentions":{},"m.new_content":{"body":"The issue was confusing for it's use on `enterWith` and performance optimization that make an `AsyncLocalStorage` behaves differently when modification of `AsyncLocalStorage` was performed at different positions in an async function body. Matteo could expand in detail about his original use case but as I talked to him in private I think `AsyncLocalStorage.run` could satisfy his needs. Let's wait if he wants to expand on it on the issue.","format":"org.matrix.custom.html","formatted_body":"The issue was confusing for it's use on <code>enterWith</code> and performance optimization that make an <code>AsyncLocalStorage</code> behaves differently when modification of <code>AsyncLocalStorage</code> was performed at different positions in an async function body. Matteo could expand in detail about his original use case but as I talked to him in private I think <code>AsyncLocalStorage.run</code> could satisfy his needs. Let's wait if he wants to expand on it on the issue.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$XrZbGYOqQGCg2sHQO56Nj-VNDxiyQ5a7b-G6IC0vxWw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716284903757,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$MsXSOLq5NczYLojxrruw04IZL97TRTnAIKrELwNXFE4"},
{"content":{"body":" * The issue was confusing for it's use on `enterWith` and performance optimization that make an `AsyncLocalStorage` behaves differently when modification of `AsyncLocalStorage` was performed at different positions in an async function body. Let's wait to see if Matteo wants to expand on his original requirement on the issue.","format":"org.matrix.custom.html","formatted_body":" * The issue was confusing for it's use on <code>enterWith</code> and performance optimization that make an <code>AsyncLocalStorage</code> behaves differently when modification of <code>AsyncLocalStorage</code> was performed at different positions in an async function body. Let's wait to see if Matteo wants to expand on his original requirement on the issue.","m.mentions":{},"m.new_content":{"body":"The issue was confusing for it's use on `enterWith` and performance optimization that make an `AsyncLocalStorage` behaves differently when modification of `AsyncLocalStorage` was performed at different positions in an async function body. Let's wait to see if Matteo wants to expand on his original requirement on the issue.","format":"org.matrix.custom.html","formatted_body":"The issue was confusing for it's use on <code>enterWith</code> and performance optimization that make an <code>AsyncLocalStorage</code> behaves differently when modification of <code>AsyncLocalStorage</code> was performed at different positions in an async function body. Let's wait to see if Matteo wants to expand on his original requirement on the issue.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$XrZbGYOqQGCg2sHQO56Nj-VNDxiyQ5a7b-G6IC0vxWw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716284990888,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$-_iP2YFlYB-WuyKe0VBZlbTbu-ToCLDzrGsh_VJMm6E"},
{"content":{"body":"Python also does the plain map with a set/get and manages context scopes on its own. https://docs.python.org/3/library/contextvars.html","m.mentions":{},"msgtype":"m.text"},"ts":1716285050980,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$f9RoiEmyAj4x_u2_ey1SEoWsZuXH4oPRWv0BSxe547I"},
{"content":{"body":"As far as I'm aware, JavaScript is the _only_ language that thinks (for some reason) that this needs to be handed over to the user rather than just letting them modify the _current_ scope.","format":"org.matrix.custom.html","formatted_body":"As far as I'm aware, JavaScript is the <em>only</em> language that thinks (for some reason) that this needs to be handed over to the user rather than just letting them modify the <em>current</em> scope.","m.mentions":{},"msgtype":"m.text"},"ts":1716285100135,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$viD47ZgGuioaZuRY7kJvyDcyWN9MIIdVUmVNJwzvlWw"},
{"content":{"body":"Probably because we had bad experiences with domains in Node.js. But I think that's less a problem of set/get and more that domains itself was just bad. ðŸ˜¬","m.mentions":{},"msgtype":"m.text"},"ts":1716285151215,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$1jynYcxbapQJyS3Zg4VSYBR725KQpG6fAn7AjCgu7qg"},
{"content":{"body":"> <@stephenbelanger:matrix.org> As far as I'm aware, JavaScript is the _only_ language that thinks (for some reason) that this needs to be handed over to the user rather than just letting them modify the _current_ scope.\n\nin Rust, there's tokio's `task_local!` / `LocalKey`","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$viD47ZgGuioaZuRY7kJvyDcyWN9MIIdVUmVNJwzvlWw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>As far as I'm aware, JavaScript is the <em>only</em> language that thinks (for some reason) that this needs to be handed over to the user rather than just letting them modify the <em>current</em> scope.</blockquote></mx-reply>in Rust, there's tokio's <code>task_local!</code> / <code>LocalKey</code>","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$viD47ZgGuioaZuRY7kJvyDcyWN9MIIdVUmVNJwzvlWw"}},"msgtype":"m.text"},"ts":1716285166918,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Jn1FbSzNbwHASKMJjo8t_6Pht16GaInaG1IFOqIB8S0"},
{"content":{"body":"which doesn't let you modify the current scope","m.mentions":{},"msgtype":"m.text"},"ts":1716285176660,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$u0njNb5egAQ8ZFk33tWy3Z2JHinJW8DdS8qJ3mPGOyg"},
{"content":{"body":"> <@stephenbelanger:matrix.org> .NET also has AsyncLocal, which is basically exactly what was originally proposed in Node.js _before_ AsyncLocalStorage was chosen instead, because people didn't trust the Node.js runtime to manage scopes correctly. https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0\n\nhttps://dotnetfiddle.net/7ulHg0 AFAICT dotnet doesn't flow-through values even it allows `.set` pattern","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$jTA6uMEeIOum5o14v9982GMBG98pkb_h49c8td1_rMA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>.NET also has AsyncLocal, which is basically exactly what was originally proposed in Node.js <em>before</em> AsyncLocalStorage was chosen instead, because people didn't trust the Node.js runtime to manage scopes correctly. https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0</blockquote></mx-reply>https://dotnetfiddle.net/7ulHg0 AFAICT dotnet doesn't flow-through values even it allows <code>.set</code> pattern","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$jTA6uMEeIOum5o14v9982GMBG98pkb_h49c8td1_rMA"}},"msgtype":"m.text"},"ts":1716285212579,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$OGRrElpDl-mmSb221RJdIvelMhHq_a9VmLMXU0dRKAM"},
{"content":{"body":"Yep, flow-through is a different issue from the matter of if set/get are reasonable. I mostly brought that up because of James talking about that split idea.","m.mentions":{},"msgtype":"m.text"},"ts":1716285294692,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$hBuNCxChVy_nIrxu1P7Q_9Hv8sJyskUxGxdZOT2mmBs"},
{"content":{"body":"That's great. I really appreciate distinguishing the two topics","m.mentions":{},"msgtype":"m.text"},"ts":1716285322934,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Z-4WYHrN1F7VlxUMaLrQoFG3HIq_-gRnHTlOxnAQQEY"},
{"content":{"body":"But I think what would probably actually _make sense_ is to just have multiple context types which work in the set/get mode and use the two types to differentiate the flows.","format":"org.matrix.custom.html","formatted_body":"But I think what would probably actually <em>make sense</em> is to just have multiple context types which work in the set/get mode and use the two types to differentiate the flows.","m.mentions":{},"msgtype":"m.text"},"ts":1716285338682,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$C6RrL53vCX373vKFbj5r683qnixOgydHTcFY55j_3cE"},
{"content":{"body":"One can be a \"modify current context and flow into children only\" type while the other can be \"modify for any logically following execution\" type.","m.mentions":{},"msgtype":"m.text"},"ts":1716285383557,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$vOt8JaR-1jbfxvtpe5ysiE5oFkrPZ5i5FXtCDNnuRFM"},
{"content":{"body":"I think `ContinuationLocal` clear describes the logical execution flow style. I feel like the `AsyncLocal` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows so we aren't creating confusion?","format":"org.matrix.custom.html","formatted_body":"I think <code>ContinuationLocal</code> clear describes the logical execution flow style. I feel like the <code>AsyncLocal</code> name is a bit vague about exactly <em>how</em> it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly <em>how</em> it flows so we aren't creating confusion?","m.mentions":{},"msgtype":"m.text"},"ts":1716287286331,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$FwzourmzRu65nHVmccPeQ5BKZepslz_ALWJu5d-cT2I"},
{"content":{"body":" * I think `ContinuationContext` clear describes the logical execution flow style. I feel like the `AsyncContext` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows so we aren't creating confusion?","format":"org.matrix.custom.html","formatted_body":" * I think <code>ContinuationContext</code> clear describes the logical execution flow style. I feel like the <code>AsyncContext</code> name is a bit vague about exactly <em>how</em> it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly <em>how</em> it flows so we aren't creating confusion?","m.mentions":{},"m.new_content":{"body":"I think `ContinuationContext` clear describes the logical execution flow style. I feel like the `AsyncContext` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows so we aren't creating confusion?","format":"org.matrix.custom.html","formatted_body":"I think <code>ContinuationContext</code> clear describes the logical execution flow style. I feel like the <code>AsyncContext</code> name is a bit vague about exactly <em>how</em> it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly <em>how</em> it flows so we aren't creating confusion?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$FwzourmzRu65nHVmccPeQ5BKZepslz_ALWJu5d-cT2I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716287339940,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$WH72RukBTJvF7C5Dsg940QxrcgPrXQD-_pYvtOtfUKY"},
{"content":{"body":" * I think `ContinuationContext` clearly describes the logical execution flow style. I feel like the `AsyncContext` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows so we aren't creating confusion?","format":"org.matrix.custom.html","formatted_body":" * I think <code>ContinuationContext</code> clearly describes the logical execution flow style. I feel like the <code>AsyncContext</code> name is a bit vague about exactly <em>how</em> it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly <em>how</em> it flows so we aren't creating confusion?","m.mentions":{},"m.new_content":{"body":"I think `ContinuationContext` clearly describes the logical execution flow style. I feel like the `AsyncContext` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows so we aren't creating confusion?","format":"org.matrix.custom.html","formatted_body":"I think <code>ContinuationContext</code> clearly describes the logical execution flow style. I feel like the <code>AsyncContext</code> name is a bit vague about exactly <em>how</em> it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly <em>how</em> it flows so we aren't creating confusion?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$FwzourmzRu65nHVmccPeQ5BKZepslz_ALWJu5d-cT2I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716287347439,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$nUht793ySM08TKvfkYN6s9ZRB70mLAQkY5s0xgXZuks"},
{"content":{"body":" * I think `ContinuationContext` clearly describes the logical execution flow style. I feel like the `AsyncContext` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows through async code so we aren't creating confusion?","format":"org.matrix.custom.html","formatted_body":" * I think <code>ContinuationContext</code> clearly describes the logical execution flow style. I feel like the <code>AsyncContext</code> name is a bit vague about exactly <em>how</em> it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly <em>how</em> it flows through async code so we aren't creating confusion?","m.mentions":{},"m.new_content":{"body":"I think `ContinuationContext` clearly describes the logical execution flow style. I feel like the `AsyncContext` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows through async code so we aren't creating confusion?","format":"org.matrix.custom.html","formatted_body":"I think <code>ContinuationContext</code> clearly describes the logical execution flow style. I feel like the <code>AsyncContext</code> name is a bit vague about exactly <em>how</em> it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly <em>how</em> it flows through async code so we aren't creating confusion?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$FwzourmzRu65nHVmccPeQ5BKZepslz_ALWJu5d-cT2I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716287369856,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$VHmn7P22NDgsjILRIHYX8GZGJgmBrFTezMx225LhaRI"},
{"content":{"body":"I wonder if we need the \"async\" in the name at all. `CallContext` might communicate the flow semantics better? Or even `ImplicitCallContext` to make it even _more_ clear that this is data which gets passed around without needing to do so explicitly? ðŸ¤”","format":"org.matrix.custom.html","formatted_body":"I wonder if we need the \"async\" in the name at all. <code>CallContext</code> might communicate the flow semantics better? Or even <code>ImplicitCallContext</code> to make it even <em>more</em> clear that this is data which gets passed around without needing to do so explicitly? ðŸ¤”","m.mentions":{},"msgtype":"m.text"},"ts":1716287509558,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$wPDwiDBDNqiCVPf7ZYYM4vIvWbI-uOdLA6377G5zBpY"},
{"content":{"body":"Another reason the set/get model kind of makes more sense is you can build the `store.run(...)` model on top of it whereas the reverse is _not_ possible.\n\n```js\nrun(value, scope) {\n  const previous = this.get()\n  try {\n    this.set(value)\n    return scope()\n  } finally {\n    this.set(previous)\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Another reason the set/get model kind of makes more sense is you can build the <code>store.run(...)</code> model on top of it whereas the reverse is <em>not</em> possible.</p>\n<pre><code class=\"language-js\">run(value, scope) {\n  const previous = this.get()\n  try {\n    this.set(value)\n    return scope()\n  } finally {\n    this.set(previous)\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716288268639,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zEfV3lI5HmcQ24d9WQCT_665asK4P5j3lk9SJGvf46U"},
{"content":{"body":"I've been looking through https://github.com/endojs/endo/blob/markm-fluid-scopes/packages/eventual-send/src/async-contexts/README.md and I think I more or less understand the security concerns, and `set()` definitely violates the \"unobservable to anything that cannot run in the spawned turn\" condition","format":"org.matrix.custom.html","formatted_body":"I've been looking through https://github.com/endojs/endo/blob/markm-fluid-scopes/packages/eventual-send/src/async-contexts/README.md and I think I more or less understand the security concerns, and <code>set()</code> definitely violates the \"unobservable to anything that cannot run in the spawned turn\" condition","m.mentions":{},"msgtype":"m.text"},"ts":1716289336946,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$aFu2nuyvhlup_RTg9ESUHPwZm2zga-w4FLmo_9yCEKA"},
{"content":{"body":"I'm not yet sure whether the resolution context behavior of promises would, though","m.mentions":{},"msgtype":"m.text"},"ts":1716289424575,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$HX7_9XamDGU0DFq1lEFCVwqdCQ-tVk0wv4oj7CGtf6A"},
{"content":{"body":"I think it would as well","m.mentions":{},"msgtype":"m.text"},"ts":1716289496915,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$QiCD03nJatnoZ3-mSmKOXD1yA37q91lteTmBrFo9dmc"},
{"content":{"body":"so either of those behaviors would probably get strong opposition from the SES folks","m.mentions":{},"msgtype":"m.text"},"ts":1716289510740,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$hawM_gX4xo3vas3qMMXnSeMsb430HFe9iw3sWQf2u9s"},
{"content":{"body":"the thing that breaks confidentiality is global wrap, though","m.mentions":{},"msgtype":"m.text"},"ts":1716289568359,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$k70Gq1du2pYzNpM3GDNows1lozmADMtKM49a8qldaJ4"},
{"content":{"body":"but we can't remove it (in favor of instance wrap) without making a bunch of use cases impossible or impractical","m.mentions":{},"msgtype":"m.text"},"ts":1716289595269,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$wgnUyDdLXn9zy0LQ2XbvoCBteFXEaSTOzTNlC4TQi94"},
{"content":{"body":"no, wait, even the behavior of `then` would allow that kind of leaks","format":"org.matrix.custom.html","formatted_body":"no, wait, even the behavior of <code>then</code> would allow that kind of leaks","m.mentions":{},"msgtype":"m.text"},"ts":1716289987728,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$s8MRpsWwEVr_jjYT5nBNYyxvlgZUOOSC8eg0-Lqazb0"},
{"content":{"body":" * no, wait, even the behavior of `then` would allow that kind of information leaks","format":"org.matrix.custom.html","formatted_body":" * no, wait, even the behavior of <code>then</code> would allow that kind of information leaks","m.mentions":{},"m.new_content":{"body":"no, wait, even the behavior of `then` would allow that kind of information leaks","format":"org.matrix.custom.html","formatted_body":"no, wait, even the behavior of <code>then</code> would allow that kind of information leaks","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$s8MRpsWwEVr_jjYT5nBNYyxvlgZUOOSC8eg0-Lqazb0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716289992232,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$tE4-AJF-tZPHt3bUSpSpPilMP69hwJHMqG4OF1DU52s"},
{"content":{"body":" * actually, no, even the behavior of `then` would allow that kind of information leaks","format":"org.matrix.custom.html","formatted_body":" * actually, no, even the behavior of <code>then</code> would allow that kind of information leaks","m.mentions":{},"m.new_content":{"body":"actually, no, even the behavior of `then` would allow that kind of information leaks","format":"org.matrix.custom.html","formatted_body":"actually, no, even the behavior of <code>then</code> would allow that kind of information leaks","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$s8MRpsWwEVr_jjYT5nBNYyxvlgZUOOSC8eg0-Lqazb0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716290013887,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$EYVNXW1cNbduSabmiZXQmDNzoo4KEVlJvwntu1r2U-s"},
{"content":{"body":"Yes, then is basically exposing wrap as defined","msgtype":"m.text"},"ts":1716290199487,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$oQX-uD8q2oUUQfTc9PTROyc5753rqygRq2_NwcOgVsk"},
{"content":{"body":"* Yes, then is basically exposing global wrap as defined","m.new_content":{"body":"Yes, then is basically exposing global wrap as defined","msgtype":"m.text"},"m.relates_to":{"event_id":"$oQX-uD8q2oUUQfTc9PTROyc5753rqygRq2_NwcOgVsk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716290210197,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$5MBxgLUyKL1gar09iQJ9fEs3Oiy7U33LrlxzoTz-qsI"},
{"content":{"body":"well, I guess in this case it wouldn't properly be `then` that wraps, but `resolve`/`reject`","format":"org.matrix.custom.html","formatted_body":"well, I guess in this case it wouldn't properly be <code>then</code> that wraps, but <code>resolve</code>/<code>reject</code>","m.mentions":{},"msgtype":"m.text"},"ts":1716290348899,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$W0ZrGc9Bppnoz53bjUNTRqkNTan-VAvEidBn_Bo2sQ0"},
{"content":{"body":"I don't get SES opposition. The data related to a variable is completely inaccessible without the variable instance reference. A value is _already_ being exposed, it's just being exposed through essentially managed binding update of an earlier defined variable. The patterns of context management through a variable store _are not_ insecure unless you're sharing the store object in the first place which _obviously_ should not be done with unknown/untrusted things. But opposing context management designs _because_ this is possible makes no sense when you can do the same thing with _any_ form of variable reference.","format":"org.matrix.custom.html","formatted_body":"I don't get SES opposition. The data related to a variable is completely inaccessible without the variable instance reference. A value is <em>already</em> being exposed, it's just being exposed through essentially managed binding update of an earlier defined variable. The patterns of context management through a variable store <em>are not</em> insecure unless you're sharing the store object in the first place which <em>obviously</em> should not be done with unknown/untrusted things. But opposing context management designs <em>because</em> this is possible makes no sense when you can do the same thing with <em>any</em> form of variable reference.","m.mentions":{},"msgtype":"m.text"},"ts":1716290436891,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$wCfwuu0LSBKmOJE-vO8XGOY_-PE_VY9bRsoUk5ggzNc"},
{"content":{"body":"the thing they're concerned with is that global wrap would let two components establish a channel of communication by letting one have a local AsyncContext.Variable and another have global wrap","m.mentions":{},"msgtype":"m.text"},"ts":1716290695984,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$NOfEamZLjS2u5g26SL9vssKMicUn4WTIrd5MD_lLsvE"},
{"content":{"body":"the idea is that, if the component with global wrap can have access to multiple contexts that are set by the other component, then they can reset one such context at some later point, which would communicate information to the other component","m.mentions":{},"msgtype":"m.text"},"ts":1716290779777,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$uZ6-MzlrR1nacuOGdEi2jhIle6o1ssXH6N-XUYXjSbE"},
{"content":{"body":" * the idea is that, if the component with global wrap can have access to multiple contexts that are set by the other component, then they can reset one such context at some later point, which would communicate information to the other component if that one is called later","m.mentions":{},"m.new_content":{"body":"the idea is that, if the component with global wrap can have access to multiple contexts that are set by the other component, then they can reset one such context at some later point, which would communicate information to the other component if that one is called later","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$uZ6-MzlrR1nacuOGdEi2jhIle6o1ssXH6N-XUYXjSbE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716290814846,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Th81F1MMskp2kV2b5uzzP3GnEZ90JCdwJXCHt5lSycA"},
{"content":{"body":"Ehhh..._sort of_. They can \"communicate\" in the _intended_ sense that a global wrap can change the behaviour in a way that it is _intending_ to be global.","format":"org.matrix.custom.html","formatted_body":"Ehhh...<em>sort of</em>. They can \"communicate\" in the <em>intended</em> sense that a global wrap can change the behaviour in a way that it is <em>intending</em> to be global.","m.mentions":{},"msgtype":"m.text"},"ts":1716290854017,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$EADyHbzAkmKaAt32W3g8fk4CuKW5XLy4_elZqrmUUSE"},
{"content":{"body":"But this is also why I prefer instance-scoped bind as the default--you're not messing with a global graph and therefore influencing unrelated things.","m.mentions":{},"msgtype":"m.text"},"ts":1716290879854,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$lK4KwPyAhKhcPMvYJ6dWc-3z5cOnaUlsweuLPsRb7Cs"},
{"content":{"body":"But sometimes you _need_ to influence the global graph.","format":"org.matrix.custom.html","formatted_body":"But sometimes you <em>need</em> to influence the global graph.","m.mentions":{},"msgtype":"m.text"},"ts":1716290894154,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$K8SrliUHIS20GVSbJm3u_DYiJyl4OfMbqUyIyK49pZQ"},
{"content":{"body":"That _forced_ bind though is why I made WindowChannel--so you can explicitly _accept_ a suggested context change rather than having it forced on you.","format":"org.matrix.custom.html","formatted_body":"That <em>forced</em> bind though is why I made WindowChannel--so you can explicitly <em>accept</em> a suggested context change rather than having it forced on you.","m.mentions":{},"msgtype":"m.text"},"ts":1716290932101,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zaTKM-6Z9K3P6QGhFdsiOCTDEyC5wAmrZRjbhCexdgs"},
{"content":{"body":"> <@stephenbelanger:matrix.org> But sometimes you _need_ to influence the global graph.\n\nI don't necessarily disagree, but `set()` establishes a communications channel that's not limited to one microtask and its outgoing data flow","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$K8SrliUHIS20GVSbJm3u_DYiJyl4OfMbqUyIyK49pZQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>But sometimes you <em>need</em> to influence the global graph.</blockquote></mx-reply>I don't necessarily disagree, but <code>set()</code> establishes a communications channel that's not limited to one microtask and its outgoing data flow","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$K8SrliUHIS20GVSbJm3u_DYiJyl4OfMbqUyIyK49pZQ"}},"msgtype":"m.text"},"ts":1716290956801,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$6ksZi9CGqNjW3aXsp5nYvMHs4Nkpez1_Ad32InM6pxA"},
{"content":{"body":"and that seems to be the thing they're concerned about","m.mentions":{},"msgtype":"m.text"},"ts":1716290968141,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$ob6bhxIOnccBo7gmTn_O8AkmyiU5t9AsYH7PW1IQ69s"},
{"content":{"body":"> <@stephenbelanger:matrix.org> But sometimes you _need_ to influence the global graph.\n\n * I don't necessarily disagree, but `set()` establishes a communications channel that's not limited to one microtask and its outgoing scoped data flow","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$K8SrliUHIS20GVSbJm3u_DYiJyl4OfMbqUyIyK49pZQ?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>But sometimes you <em>need</em> to influence the global graph.</blockquote></mx-reply> * I don't necessarily disagree, but <code>set()</code> establishes a communications channel that's not limited to one microtask and its outgoing scoped data flow","m.mentions":{},"m.new_content":{"body":"I don't necessarily disagree, but `set()` establishes a communications channel that's not limited to one microtask and its outgoing scoped data flow","format":"org.matrix.custom.html","formatted_body":"I don't necessarily disagree, but <code>set()</code> establishes a communications channel that's not limited to one microtask and its outgoing scoped data flow","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$6ksZi9CGqNjW3aXsp5nYvMHs4Nkpez1_Ad32InM6pxA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716290994534,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$B5LRfdpfAu08OnLuX7fafm06qrU_m77YDAgm2nOuAgU"},
{"content":{"body":"> <@abotella:igalia.com> I don't necessarily disagree, but `set()` establishes a communications channel that's not limited to one microtask and its outgoing scoped data flow\n\nHow so? The runtime can define that the scope of a set alteration lives to the end of the current microtask.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$6ksZi9CGqNjW3aXsp5nYvMHs4Nkpez1_Ad32InM6pxA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>I don't necessarily disagree, but <code>set()</code> establishes a communications channel that's not limited to one microtask and its outgoing scoped data flow</blockquote></mx-reply>How so? The runtime can define that the scope of a set alteration lives to the end of the current microtask.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$6ksZi9CGqNjW3aXsp5nYvMHs4Nkpez1_Ad32InM6pxA"}},"msgtype":"m.text"},"ts":1716291009964,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$0Ub9fPMufPXzMrzvXY5HLYqdWoMFX2wcQ1bnbh08G44"},
{"content":{"body":"This is what most _other_ languages do.","format":"org.matrix.custom.html","formatted_body":"This is what most <em>other</em> languages do.","m.mentions":{},"msgtype":"m.text"},"ts":1716291032465,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$OXU-qpuoyNlJ3QvX7HIimKW-1hYj_srYVgtz-8uu6Rk"},
{"content":{"body":"When the current tick ends at it would transition to an async continuation it terminates the context and sets whatever would get restored for the continuation.","m.mentions":{},"msgtype":"m.text"},"ts":1716291068555,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$tOMLFNySV4QU8BgorXlxuy_7mmeGQQ3PXAa_VuRDQKU"},
{"content":{"body":"Or explicitly null/undefined/empty if nothing was captured for that continuation.","m.mentions":{},"msgtype":"m.text"},"ts":1716291097274,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$dgeLo3YnE3ehy3olaKyOtSAz2ocbleDghtRDAlOLUg8"},
{"content":{"body":"But the point is, a `set(...)` never crosses over into unrelated activity.","format":"org.matrix.custom.html","formatted_body":"But the point is, a <code>set(...)</code> never crosses over into unrelated activity.","m.mentions":{},"msgtype":"m.text"},"ts":1716291110814,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Jm5pQKojwFnqNGzNAE6tS3oD-tMK-pvv9_FCfDffsvk"},
{"content":{"body":"Basically this, but with the `scope.run(...)` being implicitly provided by the runtime:\n\n```js\n// Any calls to set(...) get cleared when scope ends\nscope.run(() => {\n  store.set(1)\n})\n```","format":"org.matrix.custom.html","formatted_body":"<p>Basically this, but with the <code>scope.run(...)</code> being implicitly provided by the runtime:</p>\n<pre><code class=\"language-js\">// Any calls to set(...) get cleared when scope ends\nscope.run(() =&gt; {\n  store.set(1)\n})\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716291208092,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$RNM2rRYcTtb06wPDymbfjza0egJ0QGYnJ4dKpTM6OMo"},
{"content":{"body":"And, to be clear, we are essentially _already doing this_ with propagation.","format":"org.matrix.custom.html","formatted_body":"And, to be clear, we are essentially <em>already doing this</em> with propagation.","m.mentions":{},"msgtype":"m.text"},"ts":1716291243926,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$f2-ct9SkQBnniNqG8fxJ_uXPu1cZRJKc6VDEaH_n5uU"},
{"content":{"body":"All we need to do is raise the set one level out to whatever the _current_ thing which _could have_ had a scope is, and set _there_ rather than introducing a _new_ scope.","format":"org.matrix.custom.html","formatted_body":"All we need to do is raise the set one level out to whatever the <em>current</em> thing which <em>could have</em> had a scope is, and set <em>there</em> rather than introducing a <em>new</em> scope.","m.mentions":{},"msgtype":"m.text"},"ts":1716291295905,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kkTsbCyp7y2JgBbHCzx5e0_WZQV9VL98B5sHxAp5UOs"},
{"content":{"body":" * When the current tick ends and it would transition to an async continuation it terminates the context and sets whatever would get restored for the continuation.","m.mentions":{},"m.new_content":{"body":"When the current tick ends and it would transition to an async continuation it terminates the context and sets whatever would get restored for the continuation.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$tOMLFNySV4QU8BgorXlxuy_7mmeGQQ3PXAa_VuRDQKU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716291340053,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$XsQ44LNNOg7AP-pUxlFAoFPuCjEOs7IT-iPXJaI-M-w"},
{"content":{"body":"The only real concern is that the store needs copy-on-write semantics so that changes don't leak backward in time within the same scope by modifying the _same_ map. The `set(...)` should clone the map and future captures within the same scope should see the _new_ map.","format":"org.matrix.custom.html","formatted_body":"The only real concern is that the store needs copy-on-write semantics so that changes don't leak backward in time within the same scope by modifying the <em>same</em> map. The <code>set(...)</code> should clone the map and future captures within the same scope should see the <em>new</em> map.","m.mentions":{},"msgtype":"m.text"},"ts":1716291486358,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$HcxJk0Q3UhJxL94RIAPozyUqWKr7M_A1P--z4Bvq8oI"},
{"content":{"body":"I think I misspoke","m.mentions":{},"msgtype":"m.text"},"ts":1716291647213,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$UkSUzK02AclEmGKySknm8HXM-DFilx-Aa3DPXtwUkg4"},
{"content":{"body":"I would argue the set/get model is actually _easier_ to reason about because users can't produce strange scopes that don't behave quite the way they expect, like `const gen = (function*() { ... })(); store.run(1, gen.next())`.","format":"org.matrix.custom.html","formatted_body":"I would argue the set/get model is actually <em>easier</em> to reason about because users can't produce strange scopes that don't behave quite the way they expect, like <code>const gen = (function*() { ... })(); store.run(1, gen.next())</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1716291650286,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$wRy41DVX3npU8HOjVLzco0rSHRU2WN2YiE7p64l4wiU"},
{"content":{"body":"and this whole thing is somewhat hurting my brain","m.mentions":{},"msgtype":"m.text"},"ts":1716291656865,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$wCtkjlmkcDHdQbZ2nP_GjqkcTVS_ICgaGdfe-GVZoTU"},
{"content":{"body":"> So if I understand correctly the readme in this PR, a new turn can learn explicit information to where it came from, but it cannot use that information to covertly communicate or affect the integrity of other turns that were also spawned at the same time, if it didn't have a way to do so without async context.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>So if I understand correctly the readme in this PR, a new turn can learn explicit information to where it came from, but it cannot use that information to covertly communicate or affect the integrity of other turns that were also spawned at the same time, if it didn't have a way to do so without async context.</p>\n</blockquote>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716291661883,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Hs0VuhoEQRVx1CLZdeqrLt7gB0dJytvQk7GIb9iV-FQ"},
{"content":{"body":"I understand \"turn\" to mean \"microtask\" here","m.mentions":{},"msgtype":"m.text"},"ts":1716291683015,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$-uqP2Ql7AtpDWyI7Pfv710i2l1HojZE6rdbd2jowBio"},
{"content":{"body":" * I would argue the set/get model is actually _easier_ to reason about because users can't produce strange scopes that don't behave quite the way they expect, like `const gen = (function*() { ... })(); store.run(1, () => gen.next())`.","format":"org.matrix.custom.html","formatted_body":" * I would argue the set/get model is actually <em>easier</em> to reason about because users can't produce strange scopes that don't behave quite the way they expect, like <code>const gen = (function*() { ... })(); store.run(1, () =&gt; gen.next())</code>.","m.mentions":{},"m.new_content":{"body":"I would argue the set/get model is actually _easier_ to reason about because users can't produce strange scopes that don't behave quite the way they expect, like `const gen = (function*() { ... })(); store.run(1, () => gen.next())`.","format":"org.matrix.custom.html","formatted_body":"I would argue the set/get model is actually <em>easier</em> to reason about because users can't produce strange scopes that don't behave quite the way they expect, like <code>const gen = (function*() { ... })(); store.run(1, () =&gt; gen.next())</code>.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$wRy41DVX3npU8HOjVLzco0rSHRU2WN2YiE7p64l4wiU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716291696977,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$dRjjbRYnuZUw0aztkpK7wznBMj1W0W8VJQKkF8A0k8g"},
{"content":{"body":" * I understand \"turn\" to mean \"(micro)task\" here","m.mentions":{},"m.new_content":{"body":"I understand \"turn\" to mean \"(micro)task\" here","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$-uqP2Ql7AtpDWyI7Pfv710i2l1HojZE6rdbd2jowBio","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716291723258,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$kwPbO13ByZ3zypEzQNZ4I-RZ92rDFw5iVTuXL3jDET4"},
{"content":{"body":"in the end, I don't know how much of this is needed, because the current proposal already establishes a new overt channel, and `set` would be no different","format":"org.matrix.custom.html","formatted_body":"in the end, I don't know how much of this is needed, because the current proposal already establishes a new overt channel, and <code>set</code> would be no different","m.mentions":{},"msgtype":"m.text"},"ts":1716291799788,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$czf2oUB36XFgIDvumeh2-S2TKIVtVudIpz3-pv32B-Q"},
{"content":{"body":"I don't fully understand the fact that the SES folks are fine with having it be scoped to within the (micro)task","m.mentions":{},"msgtype":"m.text"},"ts":1716291830474,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$V-vT5jqZqUabCrW634-qWCFyJxw05XO9dXiQbVECIk4"},
{"content":{"body":"but I was trying to explain what I understand to be their concerns","m.mentions":{},"msgtype":"m.text"},"ts":1716291857624,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$KV2-MMfY_8fPjeB8k__YvP74b6AcLz-m7hldmfdIImc"},
{"content":{"body":"Yep, so that would be true of the flow-around semantics. A caller can't see into a callee, but a callee can receive context from their caller.\n\nThat is _not_ true of the flow-through semantics as they can set context which can be viewed in a callee via part of it being continuation of that call resolving. However, I don't think _that_ is a security concern either as:\n- It's _intentional_ that it has that communication flow\n- That data is _still_ not accessible without sharing the variable instance reference. All bets are off on security once you start explicitly sharing data stores.","format":"org.matrix.custom.html","formatted_body":"<p>Yep, so that would be true of the flow-around semantics. A caller can't see into a callee, but a callee can receive context from their caller.</p>\n<p>That is <em>not</em> true of the flow-through semantics as they can set context which can be viewed in a callee via part of it being continuation of that call resolving. However, I don't think <em>that</em> is a security concern either as:</p>\n<ul>\n<li>It's <em>intentional</em> that it has that communication flow</li>\n<li>That data is <em>still</em> not accessible without sharing the variable instance reference. All bets are off on security once you start explicitly sharing data stores.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716291913610,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$2hgTyzzbsONlJ-mYn2mJ6yAWDvj_i8kVR3_qZewXrwA"},
{"content":{"body":"I'd like to hear Mathieu Hofman's thoughts on this","format":"org.matrix.custom.html","formatted_body":"I'd like to hear <a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>'s thoughts on this","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"msgtype":"m.text"},"ts":1716291981326,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$8eUb0RwhmZcoM0ONcZT546ZBHwaRYCcTCy-VIRmFRAc"},
{"content":{"body":"You have to both _explicitly_ pass that data _out_ of the callee via the `set(...)` and explicitly _retrieve_ it by having access to the store in caller when it calls `get(...)`.","format":"org.matrix.custom.html","formatted_body":"You have to both <em>explicitly</em> pass that data <em>out</em> of the callee via the <code>set(...)</code> and explicitly <em>retrieve</em> it by having access to the store in caller when it calls <code>get(...)</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1716292026321,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$hFHqNFjV2miYiwFR7QZma57s9NiCH80-RXYvUUTvmfA"},
{"content":{"body":"So really the communication channel between the things is already _quite explicitly_ defined.","format":"org.matrix.custom.html","formatted_body":"So really the communication channel between the things is already <em>quite explicitly</em> defined.","m.mentions":{},"msgtype":"m.text"},"ts":1716292048676,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$c_LQZpcVvQOys1g9cXpPYXX2yVfBbTCsHZFbf1ZV2Q4"},
{"content":{"body":"It's no different than if I passed an event emitter into the callee and attached a listener in the caller to receive events.","m.mentions":{},"msgtype":"m.text"},"ts":1716292089639,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$5CuCiOD9OK5TBEb3Tofte1pDJM0RMr2WEzjN_iQH_f0"},
{"content":{"body":" * It's no different than if I store an event emitter globally, attached a listener in the caller to receive events, and then emit an event inside the callee from that same global event emitter.","m.mentions":{},"m.new_content":{"body":"It's no different than if I store an event emitter globally, attached a listener in the caller to receive events, and then emit an event inside the callee from that same global event emitter.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$5CuCiOD9OK5TBEb3Tofte1pDJM0RMr2WEzjN_iQH_f0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716292263663,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$pKM8LjLghYcb6uWDNP5o5Jfb286cAB7X0fDZU-xjtEk"},
{"content":{"body":"I think you're missing the point: the communications channel they're worried about is one enabled by global wrap","m.mentions":{},"msgtype":"m.text"},"ts":1716292281474,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Ectp1b9MOUUwADLLRXh_eu20yYGl5nNiaUBZ61fRY74"},
{"content":{"body":"which can be used by a component that doesn't have access to the variable to set the context in which the component with access to it is called","m.mentions":{},"msgtype":"m.text"},"ts":1716292324314,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$rE5RzQGi7YNiRNZlzYBfOiC7SAwfAPtut1r5VKI0a_o"},
{"content":{"body":"> <@stephenbelanger:matrix.org> But this is also why I prefer instance-scoped bind as the default--you're not messing with a global graph and therefore influencing unrelated things.\n\nSee:","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$lK4KwPyAhKhcPMvYJ6dWc-3z5cOnaUlsweuLPsRb7Cs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>But this is also why I prefer instance-scoped bind as the default--you&#39;re not messing with a global graph and therefore influencing unrelated things.</blockquote></mx-reply>See:","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$lK4KwPyAhKhcPMvYJ6dWc-3z5cOnaUlsweuLPsRb7Cs"}},"msgtype":"m.text"},"ts":1716292344412,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zA8kqktrUvGwwgTX7Bu6BF68qI0Y0UDQ6bcPpalWPtY"},
{"content":{"body":"without the knowledge of the component that sets both of those components up","m.mentions":{},"msgtype":"m.text"},"ts":1716292345468,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$t8BbvN83tn7y_z298V4V5Hp1Ud97ndBH6ZGt-Bj8jCc"},
{"content":{"body":"> <@stephenbelanger:matrix.org> See:\n\nbut global wrap would still be available in your model","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$zA8kqktrUvGwwgTX7Bu6BF68qI0Y0UDQ6bcPpalWPtY?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>See:</blockquote></mx-reply>but global wrap would still be available in your model","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zA8kqktrUvGwwgTX7Bu6BF68qI0Y0UDQ6bcPpalWPtY"}},"msgtype":"m.text"},"ts":1716292365228,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$oiO3cQfA4PS0m66GHdb7vs1Kco_cCDaQxs6YWR99Vk4"},
{"content":{"body":"the fact that it's available is the confidentiality risk","m.mentions":{},"msgtype":"m.text"},"ts":1716292375399,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Hi-ihgTM3VmNkJOmlCMdAgYh_DWiM1CCeRG-mMow8K8"},
{"content":{"body":"and you could do the same with then","m.mentions":{},"msgtype":"m.text"},"ts":1716292390726,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$gT0bFZU_r_wgOsrbr5BErqA6vMkWnHg7hE0eeEuIKqc"},
{"content":{"body":"You can do the same thing with event emitters though. If you make a global you can emit from anywhere, you can subscribe from anywhere and you can _unsubscribe_ from anywhere.","format":"org.matrix.custom.html","formatted_body":"You can do the same thing with event emitters though. If you make a global you can emit from anywhere, you can subscribe from anywhere and you can <em>unsubscribe</em> from anywhere.","m.mentions":{},"msgtype":"m.text"},"ts":1716292403406,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$0BKmxczsi0L_pPyqKbxGQMnUDMGR_QD-gsq5j4OQCcU"},
{"content":{"body":" * and you could do the same with then, I think","m.mentions":{},"m.new_content":{"body":"and you could do the same with then, I think","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$gT0bFZU_r_wgOsrbr5BErqA6vMkWnHg7hE0eeEuIKqc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716292405017,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Vx1t6tFrfF6REjxQwPO43k8pAWaKgH--aeg_56oQZM8"},
{"content":{"body":"but here there isn't a global","m.mentions":{},"msgtype":"m.text"},"ts":1716292449539,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$fAk7M0xx8MYcVf3xRmUOqPkYke2gxwF01MB0dWEVFV4"},
{"content":{"body":"And yes, global wrap would still be available but, as I've said, I would _strongly_ advise against its use.","format":"org.matrix.custom.html","formatted_body":"And yes, global wrap would still be available but, as I've said, I would <em>strongly</em> advise against its use.","m.mentions":{},"msgtype":"m.text"},"ts":1716292482819,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$VUuwWPnKJoMFXGrzoLWBVuueg_8NvtPpFR5kG_fPkr8"},
{"content":{"body":"Though the WindowChannel can replace global bind so you always have to opt-in to forced graph changes.","m.mentions":{},"msgtype":"m.text"},"ts":1716292525429,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$QuKyUc_ASc0Iw0_I-mHVWbtK-PeHM8eXuShW9CE5M8c"},
{"content":{"body":"Which _can_ eliminate that problem.","format":"org.matrix.custom.html","formatted_body":"Which <em>can</em> eliminate that problem.","m.mentions":{},"msgtype":"m.text"},"ts":1716292540922,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$pmiBdorfroJNK85UY-I8fuVCpZMf9Lv4AD00WCFcycQ"},
{"content":{"body":"But depends on WindowChannel.","m.mentions":{},"msgtype":"m.text"},"ts":1716292548036,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$xmSBKFuKLYkK9Azs8HBJ3gDzDD1BoX7LRvoYjA1Xyao"},
{"content":{"body":"So unless we do that (or something like it) we're stuck with a global bind. I don't think global binding is avoidable when things like connection pools can exist. We _need_ a way for users to be able to communicate that something should be routed around in a particular way.","format":"org.matrix.custom.html","formatted_body":"So unless we do that (or something like it) we're stuck with a global bind. I don't think global binding is avoidable when things like connection pools can exist. We <em>need</em> a way for users to be able to communicate that something should be routed around in a particular way.","m.mentions":{},"msgtype":"m.text"},"ts":1716292605968,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$wG7xVoqDNSyzTzs3MQ3JQUoRV6IG4ovRy1JpQjRhx7o"},
{"content":{"body":"But we _could_ be doing it in a way which the author of that code can provide a _suggestion_ that something should be routed around and a store owner can provide some sort of _acceptance_ of such changes.","format":"org.matrix.custom.html","formatted_body":"But we <em>could</em> be doing it in a way which the author of that code can provide a <em>suggestion</em> that something should be routed around and a store owner can provide some sort of <em>acceptance</em> of such changes.","m.mentions":{},"msgtype":"m.text"},"ts":1716292668850,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$LLphk2yvBjDqNRhcha-7ExB_NdZMthmQdrgPMCQX1yk"},
{"content":{"body":"That sort of suggest/accept model adds a bunch of complexity though.","m.mentions":{},"msgtype":"m.text"},"ts":1716292700667,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$cKFoSZcTEBo0oeS_KN9hFmeA8vYAPuUgEfGMGQNx6S0"},
{"content":{"body":"> <@stephenbelanger:matrix.org> And yes, global wrap would still be available but, as I've said, I would _strongly_ advise against its use.\n\nbut resolve and then would use global wrap, and it seems like they would still allow this channel","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$VUuwWPnKJoMFXGrzoLWBVuueg_8NvtPpFR5kG_fPkr8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>And yes, global wrap would still be available but, as I've said, I would <em>strongly</em> advise against its use.</blockquote></mx-reply>but resolve and then would use global wrap, and it seems like they would still allow this channel","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$VUuwWPnKJoMFXGrzoLWBVuueg_8NvtPpFR5kG_fPkr8"}},"msgtype":"m.text"},"ts":1716292986470,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$wu-vOmkh-whQfzib5XHsrz-GeAcVWi5O9XrYvlJJrzQ"},
{"content":{"body":"and those are fundamental to promises, so it would make promises and async/await effectively impossible in a SES environment","m.mentions":{},"msgtype":"m.text"},"ts":1716293122447,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$MHAAn8DYTE833s_zWmO_BCKW39IsKJdFoqc4WTL0OnU"},
{"content":{"body":" * and those are fundamental to promises, so it would make promises and async/await impossible in a SES environment","m.mentions":{},"m.new_content":{"body":"and those are fundamental to promises, so it would make promises and async/await impossible in a SES environment","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$MHAAn8DYTE833s_zWmO_BCKW39IsKJdFoqc4WTL0OnU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716293139341,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$xgxzDGTJoi3qDGERw4a60bBPQWm6Mx9_c1DdinwcoxU"},
{"content":{"body":" * and those are fundamental to promises, so it would make promises and async/await impossible in a SES environment which doesn't prevent use of AsyncContxt","m.mentions":{},"m.new_content":{"body":"and those are fundamental to promises, so it would make promises and async/await impossible in a SES environment which doesn't prevent use of AsyncContxt","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$MHAAn8DYTE833s_zWmO_BCKW39IsKJdFoqc4WTL0OnU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716293176617,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$UOZb8KVBcSzffzeOCOc2HF_VwLztUY34qbQT_bNcoOw"},
{"content":{"body":" * and those are fundamental to promises, so it would make promises and async/await impossible in a SES environment which doesn't prevent use of AsyncContext","m.mentions":{},"m.new_content":{"body":"and those are fundamental to promises, so it would make promises and async/await impossible in a SES environment which doesn't prevent use of AsyncContext","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$MHAAn8DYTE833s_zWmO_BCKW39IsKJdFoqc4WTL0OnU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716293179837,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$WbG_xpqK9iMd_C4gdQPbYUiaJxJeAGL3lbrs0HE1Oho"},
{"content":{"body":"> <@abotella:igalia.com> but resolve and then would use global wrap, and it seems like they would still allow this channel\n\nThey would in the _current_ model. But _potentially_ they could do the same suggest/accept thing. That would both give us control to have the different flows we expect, _and_ resolve that security concern.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$wu-vOmkh-whQfzib5XHsrz-GeAcVWi5O9XrYvlJJrzQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>but resolve and then would use global wrap, and it seems like they would still allow this channel</blockquote></mx-reply>They would in the <em>current</em> model. But <em>potentially</em> they could do the same suggest/accept thing. That would both give us control to have the different flows we expect, <em>and</em> resolve that security concern.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$wu-vOmkh-whQfzib5XHsrz-GeAcVWi5O9XrYvlJJrzQ"}},"msgtype":"m.text"},"ts":1716293598634,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$eLiHiD7tJYh7dXg7A9QfbIldkAD3kUz_WBIP0CQki_I"},
{"content":{"body":"Though arguably it's not _actually_ an issue if the the behaviour is to _always_ do a particular thing. It'd just be an observable side effect of how execution works, same as how microtask timing is an observable side effect.","format":"org.matrix.custom.html","formatted_body":"Though arguably it's not <em>actually</em> an issue if the the behaviour is to <em>always</em> do a particular thing. It'd just be an observable side effect of how execution works, same as how microtask timing is an observable side effect.","m.mentions":{},"msgtype":"m.text"},"ts":1716293707044,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$3PCSJRoH0oClQDofdkjeH7M8yZJTyJ3X900Ui0Q7iV0"},
{"content":{"body":" * Though arguably it's not _actually_ an issue if the behaviour is to _always_ do a particular thing. It'd just be an observable side effect of how execution works, same as how microtask timing is an observable side effect.","format":"org.matrix.custom.html","formatted_body":" * Though arguably it's not <em>actually</em> an issue if the behaviour is to <em>always</em> do a particular thing. It'd just be an observable side effect of how execution works, same as how microtask timing is an observable side effect.","m.mentions":{},"m.new_content":{"body":"Though arguably it's not _actually_ an issue if the behaviour is to _always_ do a particular thing. It'd just be an observable side effect of how execution works, same as how microtask timing is an observable side effect.","format":"org.matrix.custom.html","formatted_body":"Though arguably it's not <em>actually</em> an issue if the behaviour is to <em>always</em> do a particular thing. It'd just be an observable side effect of how execution works, same as how microtask timing is an observable side effect.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$3PCSJRoH0oClQDofdkjeH7M8yZJTyJ3X900Ui0Q7iV0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716293786667,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$k37F_F1UysUVRIQUwUmEmw0F6zPnvKQbEDyWIMtt6ZQ"},
{"content":{"body":"> <@abotella:igalia.com> is there any documentation anywhere about what SES needs from new proposals?\n\nlol no itâ€™s more of a vibe. We have asked them for these docs several times over the years and their response is â€œyes that is a great idea, someone should definitely write thatâ€","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24w_ZSe9TPq4i_OR_HShDRVue3P3b8OGMQylfHv82R-cU\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>is there any documentation anywhere about what SES needs from new proposals?</blockquote></mx-reply>lol no itâ€™s more of a vibe. We have asked them for these docs several times over the years and their response is â€œyes that is a great idea, someone should definitely write thatâ€","m.relates_to":{"m.in_reply_to":{"event_id":"$w_ZSe9TPq4i_OR_HShDRVue3P3b8OGMQylfHv82R-cU"}},"msgtype":"m.text"},"ts":1716294840922,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$z0EpL_-IULSjpNZJAc-tOHyFZY-96O4kdFI2wNM2Lrw"},
{"content":{"body":"> <@littledan:matrix.org> lol no itâ€™s more of a vibe. We have asked them for these docs several times over the years and their response is â€œyes that is a great idea, someone should definitely write thatâ€\n\nand yet in https://github.com/endojs/endo/pull/1424 some of them were saying that it should be up to proposal authors to make sure their proposals work with SES??","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$z0EpL_-IULSjpNZJAc-tOHyFZY-96O4kdFI2wNM2Lrw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>lol no itâ€™s more of a vibe. We have asked them for these docs several times over the years and their response is â€œyes that is a great idea, someone should definitely write thatâ€</blockquote></mx-reply>and yet in https://github.com/endojs/endo/pull/1424 some of them were saying that it should be up to proposal authors to make sure their proposals work with SES??","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$z0EpL_-IULSjpNZJAc-tOHyFZY-96O4kdFI2wNM2Lrw"}},"msgtype":"m.text"},"ts":1716295426880,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$XycARQ9W1SphAMPWzIEpCKH9lckwKBNJZTFSW6nC3qE"},
{"content":{"body":"> <@abotella:igalia.com> is there any documentation anywhere about what SES needs from new proposals?\n\nThe guiding principle I have been following is \"the final goal is to be able to run/wrap some code in a sandbox without that code being able to neither detect it not affect the outer environment in any way\".\n\nJS is not there (yet? They hope that one day it will be), but anything that moves us further away from that goal is bad","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$w_ZSe9TPq4i_OR_HShDRVue3P3b8OGMQylfHv82R-cU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br />is there any documentation anywhere about what SES needs from new proposals?</blockquote></mx-reply><p>The guiding principle I have been following is &quot;the final goal is to be able to run/wrap some code in a sandbox without that code being able to neither detect it not affect the outer environment in any way&quot;.</p>\n<p>JS is not there (yet? They hope that one day it will be), but anything that moves us further away from that goal is bad</p>","m.relates_to":{"m.in_reply_to":{"event_id":"$w_ZSe9TPq4i_OR_HShDRVue3P3b8OGMQylfHv82R-cU"}},"msgtype":"m.text"},"ts":1716295521376,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Eltzho49eddqixCpfRHwSjBIRWHVFC18oagWJAx16ZU"},
{"content":{"body":"With the exception of infinite loops, that everybody pretends do not exist","msgtype":"m.text"},"ts":1716295571332,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$ljMwmmbC8A1570qJQrEoOopUIKD65n5NXgOYobiPoB0"},
{"content":{"body":"* The guiding principle I have been following is \"the final goal is to be able to run/wrap some code in a sandbox that emulates any other JS environment, without that code being able to neither detect it not affect the outer environment in any way\".\nJS is not there (yet? They hope that one day it will be), but anything that moves us further away from that goal is bad\n","m.new_content":{"body":"> <@abotella:igalia.com> is there any documentation anywhere about what SES needs from new proposals?\n\nThe guiding principle I have been following is \"the final goal is to be able to run/wrap some code in a sandbox that emulates any other JS environment, without that code being able to neither detect it not affect the outer environment in any way\".\nJS is not there (yet? They hope that one day it will be), but anything that moves us further away from that goal is bad\n","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$w_ZSe9TPq4i_OR_HShDRVue3P3b8OGMQylfHv82R-cU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">Andreu Botella</a><br />is there any documentation anywhere about what SES needs from new proposals?</blockquote></mx-reply>The guiding principle I have been following is &quot;the final goal is to be able to run/wrap some code in a sandbox that emulates any other JS environment, without that code being able to neither detect it not affect the outer environment in any way&quot;.<br />JS is not there (yet? They hope that one day it will be), but anything that moves us further away from that goal is bad","msgtype":"m.text"},"m.relates_to":{"event_id":"$Eltzho49eddqixCpfRHwSjBIRWHVFC18oagWJAx16ZU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716295605643,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$18iT1OHVLSmPi-E-AiNgDg6Gmhm3w3Gs-TRC3SCEv3k"},
{"content":{"body":"with something like compartments, you would be able to detect that you're in one because the prototypes are frozen, but I guess the important point is that you can't tell which sandbox you're in, right?","m.mentions":{},"msgtype":"m.text"},"ts":1716295770321,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$iCbmhC17uX8kGdDKxvmWH1j7xhiI5cJOL45Jhwbaq-A"},
{"content":{"body":"> <@abotella:igalia.com> and yet in https://github.com/endojs/endo/pull/1424 some of them were saying that it should be up to proposal authors to make sure their proposals work with SES??\n\nyes, that's how it's generally done","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$XycARQ9W1SphAMPWzIEpCKH9lckwKBNJZTFSW6nC3qE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>and yet in https://github.com/endojs/endo/pull/1424 some of them were saying that it should be up to proposal authors to make sure their proposals work with SES??</blockquote></mx-reply>yes, that's how it's generally done","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$XycARQ9W1SphAMPWzIEpCKH9lckwKBNJZTFSW6nC3qE"}},"msgtype":"m.text"},"ts":1716296989915,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$OCUK0pHe5KLVqEhlVhc96bsE2uov_Rfp_kLoAB2ivOo"},
{"content":{"body":"Seems odd to me to block a specification proposal on something else that is apparently unspecified. ðŸ¤”","m.mentions":{},"msgtype":"m.text"},"ts":1716297555259,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$BxGgRHV_WZ9gpRnFHGvDCANxjYDFo5JypP-LKN5rK7k"},
{"content":{"body":"If they expect conformance they should be responsible for clearly communicating what conformance means.","m.mentions":{},"msgtype":"m.text"},"ts":1716297596296,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$c_KgA5rMBjmkyoOaMa8r-o8gqTjf_NOzoomGm9W-tXk"},
{"content":{"body":"well, they are available for conversations","m.mentions":{},"msgtype":"m.text"},"ts":1716302633032,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Uu7zkMpGNpyaAtxU6XvrhNTjkXebZ-UfN1qW2x7AADc"},
{"content":{"body":"> <@abotella:igalia.com> is there any documentation anywhere about what SES needs from new proposals?\n\nNo, this is just recollection from the meetings I had with them. That dynamic scoping doc in the proposal was written by @legendecas:matrix.org and I before meeting with them, based on our own understanding of their objections from the first plenary meeting where they rejected the proposal.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24w_ZSe9TPq4i_OR_HShDRVue3P3b8OGMQylfHv82R-cU\">In reply to</a><a href=\"https://matrix.to/#/%40abotella%3Aigalia.com\">@abotella:igalia.com</a><br />is there any documentation anywhere about what SES needs from new proposals?</blockquote></mx-reply>No, this is just recollection from the meetings I had with them. That dynamic scoping doc in the proposal was written by <a href=\"https://matrix.to/#/%40legendecas%3Amatrix.org\">@Chengzhong Wu</a> and I before meeting with them, based on our own understanding of their objections from the first plenary meeting where they rejected the proposal.","m.relates_to":{"m.in_reply_to":{"event_id":"$w_ZSe9TPq4i_OR_HShDRVue3P3b8OGMQylfHv82R-cU"}},"msgtype":"m.text"},"ts":1716317080271,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$zH80C2Pej09SEEXOJk-FsuwoASamCXvuedzXBISUDxc"},
{"content":{"body":"Based on https://github.com/endojs/endo/blob/markm-fluid-scopes/packages/eventual-send/src/async-contexts/README.md, it seems like the current spec text does open a communications channel, but it's one they don't think breaks SES because you can't observe it from outside of the task a `.run()` call happens in","format":"org.matrix.custom.html","formatted_body":"Based on https://github.com/endojs/endo/blob/markm-fluid-scopes/packages/eventual-send/src/async-contexts/README.md, it seems like the current spec text does open a communications channel, but it's one they don't think breaks SES because you can't observe it from outside of the task a <code>.run()</code> call happens in","m.mentions":{},"msgtype":"m.text"},"ts":1716317317014,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$vWzCaIL_R9Dfb2mP5k47tez9TG-VuOY5t6XVBpPhi0g"},
{"content":{"body":"I don't really see why that makes it not break SES, but that seems to be the reasoning","m.mentions":{},"msgtype":"m.text"},"ts":1716317333348,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$OznTBC5H2BuBXE9tltaBsw366nA0_9ytPqkzXdzeqgE"},
{"content":{"body":"and that doesn't apply with resolution time or `set()`","format":"org.matrix.custom.html","formatted_body":"and that doesn't apply with resolution time or <code>set()</code>","m.mentions":{},"msgtype":"m.text"},"ts":1716317355382,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$BPI1C6WrrgIjATMFkSAVbsjSUubbZnUD8SDlnBJuQRs"},
{"content":{"body":"Iâ€™m telling you, itâ€™s a vibe","msgtype":"m.text"},"ts":1716317373431,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$z_meWd-tsqotzYhOAF0usrnySD5KVCNrSa5MwAuwAlQ"},
{"content":{"body":"Thereâ€™s no single thing that the SES things are going for; it is very loosely around enabling membranes but not just that","msgtype":"m.text"},"ts":1716317525286,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$jEVoKO9DjqcowdrkUaPaZtTHcSiASSgjXB-I1lmqjDg"},
{"content":{"body":"> <@abotella:igalia.com> I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?\n\nThereâ€™s two directions. If `foo` calls `bar`, and itâ€™s completely normal that `foo` can change a parameter to `bar`, but itâ€™s not normal if `bar` can change one of `foo`â€™s parameters. If both share a mutable object, thatâ€™s fine to mutate it in `bar`, but `bar` canâ€™t replace `foo`s reference. This was one of the things we discussed based on the OCAP language meeting.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24FfbAhz31YBdjZjBIBTTWqjrc71gen1m462NFZr2ignQ\">In reply to</a><a href=\"https://matrix.to/#/%40abotella%3Aigalia.com\">@abotella:igalia.com</a><br />I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?</blockquote></mx-reply>Thereâ€™s two directions. If <code data-md=\"`\">foo</code> calls <code data-md=\"`\">bar</code>, and itâ€™s completely normal that <code data-md=\"`\">foo</code> can change a parameter to <code data-md=\"`\">bar</code>, but itâ€™s not normal if <code data-md=\"`\">bar</code> can change one of <code data-md=\"`\">foo</code>â€™s parameters. If both share a mutable object, thatâ€™s fine to mutate it in <code data-md=\"`\">bar</code>, but <code data-md=\"`\">bar</code> canâ€™t replace <code data-md=\"`\">foo</code>s reference. This was one of the things we discussed based on the OCAP language meeting.","m.relates_to":{"m.in_reply_to":{"event_id":"$FfbAhz31YBdjZjBIBTTWqjrc71gen1m462NFZr2ignQ"}},"msgtype":"m.text"},"ts":1716317586409,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$vPuTeJVEe5VUnec9uL2rVyqktexBoKGsDoI1G41D5WE"},
{"content":{"body":"> <@stephenbelanger:matrix.org> The spec, as it is presently, calls for capturing the context at the point where an await happens, not where the promise being awaited resolves. The context flows _into_ that promise, and it _would_ flow all the way to the point of resolving, but then we orphan that branch and return the context back to the captured value of that outer await.\n> \n> In this particular example though, it's using `store.enterWith(...)` which effectively sets the value in the _current_ scope without creating a new scope first. Because the initial segment of an async function executes synchronously, if that occurs _before_ the first await of that _internal_ function then the point at which the outer function captures its await will have already change _its_ context and so will adopt that inner context. Whereas if that inner function modifies the current context _after_ the first await within that inner function it will have already passed the point where the outer function captured the await context and so it would _not_ use that value. The fact this sometimes changes the outer function context and sometimes doesn't is extremely confusing. Users are expecting it to _always_ change the outer context, as indicated in the issue, because it is logically a continuation and should therefore behave the same as it would were it written with callbacks instead.\n\nWhat is the example code? What is the indicated issue URL? Weâ€™d previosuly discussed why we donâ€™t have an `enterWith` API because of cases like this, it needs to properly restore the context after the execution of the inner async function pauses its await. Part of the reason we discussed `using` declarations with modifications to `await` keyword to restore the previous context at the suspend point.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%243sHajTIJT9-P5frOGLM2vmT7Nrinp3sgk1iSQJocucQ\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br /><p>The spec, as it is presently, calls for capturing the context at the point where an await happens, not where the promise being awaited resolves. The context flows <em>into</em> that promise, and it <em>would</em> flow all the way to the point of resolving, but then we orphan that branch and return the context back to the captured value of that outer await.</p>\n<p>In this particular example though, it's using <code>store.enterWith(...)</code> which effectively sets the value in the <em>current</em> scope without creating a new scope first. Because the initial segment of an async function executes synchronously, if that occurs <em>before</em> the first await of that <em>internal</em> function then the point at which the outer function captures its await will have already change <em>its</em> context and so will adopt that inner context. Whereas if that inner function modifies the current context <em>after</em> the first await within that inner function it will have already passed the point where the outer function captured the await context and so it would <em>not</em> use that value. The fact this sometimes changes the outer function context and sometimes doesn't is extremely confusing. Users are expecting it to <em>always</em> change the outer context, as indicated in the issue, because it is logically a continuation and should therefore behave the same as it would were it written with callbacks instead.</p>\n</blockquote></mx-reply>What is the example code? What is the indicated issue URL? Weâ€™d previosuly discussed why we donâ€™t have an <code data-md=\"`\">enterWith</code> API because of cases like this, it needs to properly restore the context after the execution of the inner async function pauses its await. Part of the reason we discussed <code data-md=\"`\">using</code> declarations with modifications to <code data-md=\"`\">await</code> keyword to restore the previous context at the suspend point.","m.relates_to":{"m.in_reply_to":{"event_id":"$3sHajTIJT9-P5frOGLM2vmT7Nrinp3sgk1iSQJocucQ"}},"msgtype":"m.text"},"ts":1716318337727,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$PC8w5gAQfzkUyMTSmOnMRIEMgVlgsuyJdSCY79lGaRQ"},
{"content":{"body":"> <@stephenbelanger:matrix.org> The issue I just posted yesterday was exactly this, and we get _numerous_ reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that _expected_ the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.\n\nWhat issue? There were like 400 messages in this channel over the last week.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24wrjKYIlTRU4IVRB4_JV1h_v3qihmISlB1k3UBahN4Fw\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br />The issue I just posted yesterday was exactly this, and we get <em>numerous</em> reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that <em>expected</em> the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.</blockquote></mx-reply>What issue? There were like 400 messages in this channel over the last week.","m.relates_to":{"m.in_reply_to":{"event_id":"$wrjKYIlTRU4IVRB4_JV1h_v3qihmISlB1k3UBahN4Fw"}},"msgtype":"m.text"},"ts":1716318380484,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$RkvRiEMBW7NuC9yy1mCiaRU6NXzBa8ct_JmVDDyS50I"},
{"content":{"body":"https://github.com/nodejs/node/issues/53037","m.mentions":{},"msgtype":"m.text"},"ts":1716318385057,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$V0ntfYACGz19pewy0tL9tx1n2n0YYb5sjofAW3IoVdU"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Consider this code:\n> \n> ```js\n> async function doSomething() {\n>   await doAThing() // first span\n>   await doAnotherThing() // no span\n>   await doYetAnotherThing() // second span should be follows-from first\n> }\n> ```\n> \n> If we have call `doSomething()` twice in a `Promise.all(...)`, which we do not instrument or have any particular awareness of--maybe it's user code--then we'll get two spans being created for the first awaits of each, then when the second spans come in they will no have a way to differentiate because the `doSomething()` itself would have the same context when it runs both times and would be restoring that over the awaits, blowing away the context we had from the inner function calls which we otherwise _could_ associate with if we had flow-through semantics.\n\nSo itâ€™s the case where `doSomething` doesnâ€™t create a parent span for its children? And we have to infer order of sibilngs when two `doSomething` calls are interleaved. Is this not just user error?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24GSKpgZYYZpQ4PQ8MhgZ3Dn7qA2G-5nmnxdE7IKzsI6Y\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br /><p>Consider this code:</p>\n<pre><code class=\"language-js\">async function doSomething() {\n  await doAThing() // first span\n  await doAnotherThing() // no span\n  await doYetAnotherThing() // second span should be follows-from first\n}\n</code></pre>\n<p>If we have call <code>doSomething()</code> twice in a <code>Promise.all(...)</code>, which we do not instrument or have any particular awareness of--maybe it's user code--then we'll get two spans being created for the first awaits of each, then when the second spans come in they will no have a way to differentiate because the <code>doSomething()</code> itself would have the same context when it runs both times and would be restoring that over the awaits, blowing away the context we had from the inner function calls which we otherwise <em>could</em> associate with if we had flow-through semantics.</p>\n</blockquote></mx-reply>So itâ€™s the case where <code data-md=\"`\">doSomething</code> doesnâ€™t create a parent span for its children? And we have to infer order of sibilngs when two <code data-md=\"`\">doSomething</code> calls are interleaved. Is this not just user error?","m.relates_to":{"m.in_reply_to":{"event_id":"$GSKpgZYYZpQ4PQ8MhgZ3Dn7qA2G-5nmnxdE7IKzsI6Y"}},"msgtype":"m.text"},"ts":1716318949091,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$T7nC37I7C98fbqhFo9BnY9K6iQvJ11hYe1so3w9pxS8"},
{"content":{"body":"* No, this is just recollection from the meetings I had with them. That dynamic scoping doc in the proposal was written by @legendecas:matrix.org and me before meeting with them, based on our own understanding of their objections from the first plenary meeting where they rejected the proposal.","format":"org.matrix.custom.html","formatted_body":"No, this is just recollection from the meetings I had with them. That dynamic scoping doc in the proposal was written by <a href=\"https://matrix.to/#/%40legendecas%3Amatrix.org\">@Chengzhong Wu</a> and me before meeting with them, based on our own understanding of their objections from the first plenary meeting where they rejected the proposal.","m.new_content":{"body":"No, this is just recollection from the meetings I had with them. That dynamic scoping doc in the proposal was written by @legendecas:matrix.org and me before meeting with them, based on our own understanding of their objections from the first plenary meeting where they rejected the proposal.","format":"org.matrix.custom.html","formatted_body":"No, this is just recollection from the meetings I had with them. That dynamic scoping doc in the proposal was written by <a href=\"https://matrix.to/#/%40legendecas%3Amatrix.org\">@Chengzhong Wu</a> and me before meeting with them, based on our own understanding of their objections from the first plenary meeting where they rejected the proposal.","msgtype":"m.text"},"m.relates_to":{"event_id":"$zH80C2Pej09SEEXOJk-FsuwoASamCXvuedzXBISUDxc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716319978908,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$LGq2ZcMCNKi-l2nc6sr_MRZ7BOvFTBcfaa-Pob68Yys"},
{"content":{"body":"I spoke with the tracing experts I'm working with and they strongly prefer \"flow around\" semantics over \"flow through\" await (with a caveat that their primary experience is in other languages).  In particular, the concern is that the ability to do an unbounded `set()` isn't a good situation.  Further, they weren't at all concerned with the visibility issues from pruning off subtasks by binding around them, for two reasons: (1) exact follows-from relationships are primarily relevant for critical path analysis, which already has numerous other issues making it intractable, and (2) we can get a reasonable enough picture with the mutable trace objects referenced in a \"lexically scoped\" async store (i.e. what's currently proposed here).  The rough structure we use (IIUC) is that the async-local variables are trivially cheap span IDs and the global store is a log of events that includes those IDs.  When a span begins/ends, it gets a new ID the start/end times and parents are appended to the log (along with any additional metadata).  The graph can then be reconstructed later from that log.\n\nI agree completely with Justin's assessment of the `doSomething()` example - it wouldn't be an issue if `doSomething` were properly instrumented.  If you branch into two parallel subtasks without making a child span, you're asking for a bad time.","format":"org.matrix.custom.html","formatted_body":"<p>I spoke with the tracing experts I'm working with and they strongly prefer \"flow around\" semantics over \"flow through\" await (with a caveat that their primary experience is in other languages).  In particular, the concern is that the ability to do an unbounded <code>set()</code> isn't a good situation.  Further, they weren't at all concerned with the visibility issues from pruning off subtasks by binding around them, for two reasons: (1) exact follows-from relationships are primarily relevant for critical path analysis, which already has numerous other issues making it intractable, and (2) we can get a reasonable enough picture with the mutable trace objects referenced in a \"lexically scoped\" async store (i.e. what's currently proposed here).  The rough structure we use (IIUC) is that the async-local variables are trivially cheap span IDs and the global store is a log of events that includes those IDs.  When a span begins/ends, it gets a new ID the start/end times and parents are appended to the log (along with any additional metadata).  The graph can then be reconstructed later from that log.</p>\n<p>I agree completely with Justin's assessment of the <code>doSomething()</code> example - it wouldn't be an issue if <code>doSomething</code> were properly instrumented.  If you branch into two parallel subtasks without making a child span, you're asking for a bad time.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716329850533,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$AzfxGX4WIn0oNN76OoNSas6dX-T5kfDJZxaCLqzzNUI"},
{"content":{"body":"All that said, even if flows-around is the correct (default) behavior for `await` (and don't forget about `yield`), the question of accessing causal context in callbacks passed to builtin and userland scheduling APIs is still relevant, and needs to be addressed (in a way that hopefully doesn't break \"lexical encapsulation\").  So we do still need to be working on the question of callingContext or something like it.","format":"org.matrix.custom.html","formatted_body":"All that said, even if flows-around is the correct (default) behavior for <code>await</code> (and don't forget about <code>yield</code>), the question of accessing causal context in callbacks passed to builtin and userland scheduling APIs is still relevant, and needs to be addressed (in a way that hopefully doesn't break \"lexical encapsulation\").  So we do still need to be working on the question of callingContext or something like it.","m.mentions":{},"msgtype":"m.text"},"ts":1716330108774,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Sv2imN5ApSmOAnq_jndNpocB_2PMLc27alDxFBVeFCo"},
{"content":{"body":"Do you think that the default context for events (and other APIs that could have more than one context) should be the registration time one?","m.mentions":{},"msgtype":"m.text"},"ts":1716330596093,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$OUUgtS2SPDzkRJqN1G18nEfbX_Q1LRe6Ptpur-YFDjc"},
{"content":{"body":"I've been rethinking this, but I don't trust my intuitions on this","m.mentions":{},"msgtype":"m.text"},"ts":1716330693711,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$bWaPc246LQqv2B3MJJP3K0CtMZPLkcliDLpuH9W1oqc"},
{"content":{"body":"What are your current thoughts, Andrey?","msgtype":"m.text"},"ts":1716335049485,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$HKqPHD3TUwWoxwrzoKoAcIht9IgRQ5QZp56Ql9wN0bY"},
{"content":{"body":"* What are your current thoughts, Andreu?","m.new_content":{"body":"What are your current thoughts, Andreu?","msgtype":"m.text"},"m.relates_to":{"event_id":"$HKqPHD3TUwWoxwrzoKoAcIht9IgRQ5QZp56Ql9wN0bY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716335054192,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$OXoYX24aAiv15zkM4JF2yKQlFxT6OTr7ZBd-jPdfPKM"},
{"content":{"body":"Even if you arenâ€™t sure of them","msgtype":"m.text"},"ts":1716335066229,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$P3jd_cglyLzN5xEEvPOGNlMYQ6fMxOJsWPvVrXHtlcE"},
{"content":{"body":"I think that maybe the only cases where events should be registration time are the ones where there isn't any possible JS origin for the event","m.mentions":{},"msgtype":"m.text"},"ts":1716335251753,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$HGPy3GoPzfoQoGLYa5mgJk4khDLn-CGKfL9W7qWhdAc"},
{"content":{"body":"even in things that are parallel to scheduling API, such as the message event, the thing that is parallel to calling e.g. `setTimeout` is the message sending","format":"org.matrix.custom.html","formatted_body":"even in things that are parallel to scheduling API, such as the message event, the thing that is parallel to calling e.g. <code>setTimeout</code> is the message sending","m.mentions":{},"msgtype":"m.text"},"ts":1716335293705,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$61FKSqZCKXfuRabuYDkcM10fX8M-V2mj9VZ9bdmYa0A"},
{"content":{"body":"not the registration","m.mentions":{},"msgtype":"m.text"},"ts":1716335296597,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$RWLMUBw6hkcNk-_v1O7W4ubZcv89xpWNE3g53pTEZbQ"},
{"content":{"body":"but I suspect that would need a lot of global wrap","m.mentions":{},"msgtype":"m.text"},"ts":1716335314220,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Ww4-aEkjRd2MBEg4CnsDuHVZNVTKqvOt9ljFiC1SkKQ"},
{"content":{"body":" * but I suspect that would lead to a lot of use of global wrap","m.mentions":{},"m.new_content":{"body":"but I suspect that would lead to a lot of use of global wrap","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Ww4-aEkjRd2MBEg4CnsDuHVZNVTKqvOt9ljFiC1SkKQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716335335109,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$HcYnXcYuDTQ3fE-58_CMwAyfaJ8NQfL69nwWYBEYKgQ"},
{"content":{"body":"Yes, I am coming around to that point of view as well. You could think of it like, it should give â€œas much information as possibleâ€ about the cause.","msgtype":"m.text"},"ts":1716335344024,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$vqcA1sENgq1Io2Ybt9HvUpEodVzoKN_FhCqMCQrN3Vw"},
{"content":{"body":"Along the lines of the arguments that  weâ€™ve been discussing, but just applied to callbacks","msgtype":"m.text"},"ts":1716335379944,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$QE7z5Oir093hkqEYfe6s9mgWqgSE5R171xN9eqrvgxk"},
{"content":{"body":"but we'd have to look into why zone.js went with registration for all events","m.mentions":{},"msgtype":"m.text"},"ts":1716335443114,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$BWXwS_uK19yvxN0dU0izdfM5G83zMUG1LBnkg4WjjTM"},
{"content":{"body":"and whether that works for its users","m.mentions":{},"msgtype":"m.text"},"ts":1716335504808,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$URzKU17waPeGJmEaTugz_hdwOeZm6XWiaf4XSZsILxo"}
]