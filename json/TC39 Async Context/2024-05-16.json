[
{"content":{"body":"> <@littledan:matrix.org> For promise-based APIs: I am having trouble picturing what we would want and how; maybe you could give a concrete example of where you don’t want the restore-around-await semantics (“registration time”) and what you want instead?\n\nWe basically _never_ want to restore around await. We want context changes to flow through the resolve path and back to the continuation of that resolve after the await. It would do that automatically if we had that separate set that does resolve path flow rather than register path flow. Any then and await binds would just get skipped and instead the context value at the resolve point would be what gets propagated into the continuation.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$W6468VK7qSle9rGybni44-O0SSTglVmvDdgJQZpN68c?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>For promise-based APIs: I am having trouble picturing what we would want and how; maybe you could give a concrete example of where you don’t want the restore-around-await semantics (“registration time”) and what you want instead?</blockquote></mx-reply>We basically <em>never</em> want to restore around await. We want context changes to flow through the resolve path and back to the continuation of that resolve after the await. It would do that automatically if we had that separate set that does resolve path flow rather than register path flow. Any then and await binds would just get skipped and instead the context value at the resolve point would be what gets propagated into the continuation.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$W6468VK7qSle9rGybni44-O0SSTglVmvDdgJQZpN68c"}},"msgtype":"m.text"},"ts":1715863627194,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$gUpxA1WdrMRzqX2X71LhCweelKb-GVgNizVktE6P4K8"},
{"content":{"body":"So our main concern for APM uses is that code which is functionally equivalent from the user perspective should produce an equivalent context graph. In the example I posted yesterday (https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e) I have three examples of an http request using async/await, raw promises, and callbacks respectively. All three examples are functionally identical from user-facing execution flow perspective, yet they produce _very_ different context graphs from AsyncContext because promises and async/await follow registration path rather than resolve path.","format":"org.matrix.custom.html","formatted_body":"So our main concern for APM uses is that code which is functionally equivalent from the user perspective should produce an equivalent context graph. In the example I posted yesterday (https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e) I have three examples of an http request using async/await, raw promises, and callbacks respectively. All three examples are functionally identical from user-facing execution flow perspective, yet they produce <em>very</em> different context graphs from AsyncContext because promises and async/await follow registration path rather than resolve path.","m.mentions":{},"msgtype":"m.text"},"ts":1715863999842,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$YDAponkU-xnSArj25wjPwe7wJ9OsSEIuonbu66h9QVk"},
{"content":{"body":"It's very confusing to users when they rewrite their code from callbacks to promises and suddenly their traces look very different because the flow of the context graph is so different.","m.mentions":{},"msgtype":"m.text"},"ts":1715864049407,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$8BzygyTYkU74Ftg_hVYiQ5z7tb83yWzEAXTbRY4obCQ"}
]