[
{"content":{"body":"I was thinking that the unhandled rejection context here is `\"foo\"`, not `\"baz\"`:\n```js\nasyncVar.run(\"foo\", main);\n\nasync function main() {\n\tawait asyncVar.run(\"bar\", async () => {\n\t\tawait asyncVar.run(\"baz\", async () => {\n\t\t\tthrow new Error();\n\t\t});\n\t});\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I was thinking that the unhandled rejection context here is <code>\"foo\"</code>, not <code>\"baz\"</code>:</p>\n<pre><code class=\"language-js\">asyncVar.run(\"foo\", main);\n\nasync function main() {\n\tawait asyncVar.run(\"bar\", async () =&gt; {\n\t\tawait asyncVar.run(\"baz\", async () =&gt; {\n\t\t\tthrow new Error();\n\t\t});\n\t});\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719839472632,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$-U5pW_mwO2UMMP1Vk6MyBngnvYdRIqW2mImf9P0EW7c"},
{"content":{"body":"so shouldn't it be the same for sync errors?","m.mentions":{},"msgtype":"m.text"},"ts":1719839485492,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$YgrG3oIZyR2lNxI06x1Y3mp4fX58uz_zhgq0hl3Qz3s"},
{"content":{"body":" * so shouldn't it be the same for sync unhandled errors?","m.mentions":{},"m.new_content":{"body":"so shouldn't it be the same for sync unhandled errors?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$YgrG3oIZyR2lNxI06x1Y3mp4fX58uz_zhgq0hl3Qz3s","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719839490581,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$1ZWcRD_ilkZoYR-RBTETe7ukTcR5vDtONh6-GvvRW3E"},
{"content":{"body":"I don't understand what you're getting at; the async/await case is different since it corresponds to a bunch of nested try/catch/rethrow patterns.","m.mentions":{},"msgtype":"m.text"},"ts":1719840540985,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$G5EfVaC1XLBqkfF1xcEY57jWqk6UAxR6VmxS69ih66s"},
{"content":{"body":"will that be obvious to developers?","m.mentions":{},"msgtype":"m.text"},"ts":1719840651055,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$A-tM9nLg68ht3keXy_TgZBYfN6n-CvrmKUNjbXWoXAI"},
{"content":{"body":"no, developers will expect that the inner place where the error inside the async/await is the source. But making it \"also broken\" for sync exceptions won't fix that expectation.","m.mentions":{},"msgtype":"m.text"},"ts":1719840688305,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9_hZm9hYUv-elAjPwbUicdkIJ356i6F0hBkXDu8kkyQ"},
{"content":{"body":"Are we talking about the callback's context or the one that's hung on the `unhandledrejection`/`error` event?  If the former, I'm arguing it should always be registration context.  Would it be possible for `event.errorSnapshot` to be `\"baz\"` even for the `unhandledrejection` case?","format":"org.matrix.custom.html","formatted_body":"Are we talking about the callback's context or the one that's hung on the <code>unhandledrejection</code>/<code>error</code> event?  If the former, I'm arguing it should always be registration context.  Would it be possible for <code>event.errorSnapshot</code> to be <code>\"baz\"</code> even for the <code>unhandledrejection</code> case?","m.mentions":{},"msgtype":"m.text"},"ts":1719865775348,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$2OWEowMx-8HWEnglQ3kmWP8w9KEJbdsvxEJpA6jRwfE"},
{"content":{"body":"I've come around to the view that one of the advantages of heterogeneous access to causal contexts (which I was arguing against a few weeks ago) is that you can target more clearly exactly which context you get.","m.mentions":{},"msgtype":"m.text"},"ts":1719865957245,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$t9UhJw6pQiSM9yWg0HP3Iajd6kQyXU6oEN7pdHhMhMQ"},
{"content":{"body":"I think we're talking about the supplemental context that exists as a property","m.mentions":{},"msgtype":"m.text"},"ts":1719865958071,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$DvQRW4TtK7MlealaPRSZkSfz_4P-0IOuWyqwhWevUek"},
{"content":{"body":"even for that there's a lot of decisions to make!","m.mentions":{},"msgtype":"m.text"},"ts":1719865977470,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$s5KQo0O-o48rNfdy2drqtgbV9yk3OXl_mVrFkVq5WN8"},
{"content":{"body":"yes there are","m.mentions":{},"msgtype":"m.text"},"ts":1719865987685,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$YJHzGCOegfAZV7BNQhdhiPzda5lOAh8sCVRjzgAwdGQ"},
{"content":{"body":"we *could* expose a whole bunch of them, but IMO one of them will probably be good enough to start, and people won't really be so great at choosing between a bunch of them anyway","format":"org.matrix.custom.html","formatted_body":"we <em>could</em> expose a whole bunch of them, but IMO one of them will probably be good enough to start, and people won't really be so great at choosing between a bunch of them anyway","m.mentions":{},"msgtype":"m.text"},"ts":1719866010695,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ttFlFLPd468lxnF9v-3YMRkRPs6pmYEaaF6u7gvPHSc"},
{"content":{"body":"so i guess i'm asking, is there a reasonable way to spec it so that the unhandled rejection is _also_ baz?","format":"org.matrix.custom.html","formatted_body":"so i guess i'm asking, is there a reasonable way to spec it so that the unhandled rejection is <em>also</em> baz?","m.mentions":{},"msgtype":"m.text"},"ts":1719866030641,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$1BIILQ2bISYygUlkWazcKmzh-zxv1HRAv64xm8Nhs-Y"},
{"content":{"body":"right, I don't think we should expose a ton","m.mentions":{},"msgtype":"m.text"},"ts":1719866045267,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wNai7g_H3AwpeiaZJVhbUMZ0UIJI5PcE7v1axkJxlu0"},
{"content":{"body":"> <@stephenhicks:matrix.org> so i guess i'm asking, is there a reasonable way to spec it so that the unhandled rejection is _also_ baz?\n\nI have a huge amount of trouble understanding how that'd work. BUT we could make it so that error objects have a causal context when they're allocated or thrown for the first time, and maybe that'd solve most of the problem.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$1BIILQ2bISYygUlkWazcKmzh-zxv1HRAv64xm8Nhs-Y?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>so i guess i'm asking, is there a reasonable way to spec it so that the unhandled rejection is <em>also</em> baz?</blockquote></mx-reply>I have a huge amount of trouble understanding how that'd work. BUT we could make it so that error objects have a causal context when they're allocated or thrown for the first time, and maybe that'd solve most of the problem.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$1BIILQ2bISYygUlkWazcKmzh-zxv1HRAv64xm8Nhs-Y"}},"msgtype":"m.text"},"ts":1719866087900,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$rH8zFjj0DEn8kjePMivm3hIF7BLyfojBXZhaJKvpmZ0"},
{"content":{"body":"IMO error construction should capture a context snapshot and you can read out of that later by accessing some property on that error.","msgtype":"m.text"},"ts":1719866100275,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$9EWQl1WoHonoFQlkN1T2BkOPXWI--slGnPlar-UNZws"}
]