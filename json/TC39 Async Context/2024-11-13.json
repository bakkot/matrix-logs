[
{"content":{"body":"In terms of events that we wanted to set to dispatch-context from the start, there was mention of same-window `postMessage` (I assume it's nonsense to talk about preserving context when messaging a different window?).  Would `MessageChannel` also be covered here?  (the reason I ask is that I'm working on a userland `aroundEach` for Jasmine - it mostly works, but only if I polyfill context propagation for `MessagePort.prototype.onmessage`)","format":"org.matrix.custom.html","formatted_body":"In terms of events that we wanted to set to dispatch-context from the start, there was mention of same-window <code>postMessage</code> (I assume it's nonsense to talk about preserving context when messaging a different window?).  Would <code>MessageChannel</code> also be covered here?  (the reason I ask is that I'm working on a userland <code>aroundEach</code> for Jasmine - it mostly works, but only if I polyfill context propagation for <code>MessagePort.prototype.onmessage</code>)","m.mentions":{},"msgtype":"m.text"},"ts":1731472848869,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$yvxWbFYxXVvfzVa7ucp9NfhU3cXftjRel87LxXP0I74"},
{"content":{"body":"agree, these tasks are pretty similar and I think we should apply the same policy on them. Contexts should not be preserved across agents. But if the async context variable is explicitly passed to a different window, I don't see it to be a problem to preserve the context?","m.mentions":{},"msgtype":"m.text"},"ts":1731499094909,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$DaSpNj3rdSUmu3vyXXujD8CTwSbKd07usaBZ6uKo8fg"},
{"content":{"body":" * agree, these tasks are pretty similar and I think we should apply the same policy on them. Contexts should not be preserved across agents. But if the async context variable is explicitly passed to a different window, I don't see it to be a problem to preserve the context.","m.mentions":{},"m.new_content":{"body":"agree, these tasks are pretty similar and I think we should apply the same policy on them. Contexts should not be preserved across agents. But if the async context variable is explicitly passed to a different window, I don't see it to be a problem to preserve the context.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$DaSpNj3rdSUmu3vyXXujD8CTwSbKd07usaBZ6uKo8fg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731499108229,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$ihYfU2qfdkf_BjdHIQbZDKjXTWbNe9bBIdRKhhQqFoA"},
{"content":{"body":"> <@stephenhicks:matrix.org> In terms of events that we wanted to set to dispatch-context from the start, there was mention of same-window `postMessage` (I assume it's nonsense to talk about preserving context when messaging a different window?).  Would `MessageChannel` also be covered here?  (the reason I ask is that I'm working on a userland `aroundEach` for Jasmine - it mostly works, but only if I polyfill context propagation for `MessagePort.prototype.onmessage`)\n\nGiven that there is a use case we can surely include it in the list","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$yvxWbFYxXVvfzVa7ucp9NfhU3cXftjRel87LxXP0I74?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br />In terms of events that we wanted to set to dispatch-context from the start, there was mention of same-window <code>postMessage</code> (I assume it's nonsense to talk about preserving context when messaging a different window?).  Would <code>MessageChannel</code> also be covered here?  (the reason I ask is that I'm working on a userland <code>aroundEach</code> for Jasmine - it mostly works, but only if I polyfill context propagation for <code>MessagePort.prototype.onmessage</code>)</blockquote></mx-reply>Given that there is a use case we can surely include it in the list","m.relates_to":{"m.in_reply_to":{"event_id":"$yvxWbFYxXVvfzVa7ucp9NfhU3cXftjRel87LxXP0I74"}},"msgtype":"m.text"},"ts":1731499116382,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$kR3RExGwy5Wlb-HFiJC0cncyqrnJ59FDKNyew3AohyA"},
{"content":{"body":"> <@legendecas:matrix.org> agree, these tasks are pretty similar and I think we should apply the same policy on them. Contexts should not be preserved across agents. But if the async context variable is explicitly passed to a different window, I don't see it to be a problem to preserve the context.\n\nYeah I think context preservation should work across realms in the same agent: if they can pass (some) objects to each other, they should be able to preserve the context","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$DaSpNj3rdSUmu3vyXXujD8CTwSbKd07usaBZ6uKo8fg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br />agree, these tasks are pretty similar and I think we should apply the same policy on them. Contexts should not be preserved across agents. But if the async context variable is explicitly passed to a different window, I don't see it to be a problem to preserve the context.</blockquote></mx-reply>Yeah I think context preservation should work across realms in the same agent: if they can pass (some) objects to each other, they should be able to preserve the context","m.relates_to":{"m.in_reply_to":{"event_id":"$DaSpNj3rdSUmu3vyXXujD8CTwSbKd07usaBZ6uKo8fg"}},"msgtype":"m.text"},"ts":1731499154769,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$ZfdYDRPO2DWRbLuz1pyaxAtkXsmlIPPo7ASktJi0FTE"},
{"content":{"body":"Part of the reason why we focused on same-window `postMessage` is because that is sometimes used as a scheduler","format":"org.matrix.custom.html","formatted_body":"Part of the reason why we focused on same-window <code>postMessage</code> is because that is sometimes used as a scheduler","m.mentions":{},"msgtype":"m.text"},"ts":1731499244095,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$bSFGRGnwQQ4zvScQ-ULkmIb2QUTiArH9VwjMlMfVRPE"},
{"content":{"body":"but yeah, it makes sense to extend that to other windows in the same agent, or to `MessageChannel`","format":"org.matrix.custom.html","formatted_body":"but yeah, it makes sense to extend that to other windows in the same agent, or to <code>MessageChannel</code>","m.mentions":{},"msgtype":"m.text"},"ts":1731499290264,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$lC6LWUbXnE3u0zanKqFkBDT0F8OOKRPCdfOiaQ3XAWI"},
{"content":{"body":"i've been playing around with async context and disposables, and i realized they don't really work well together because we don't restore the context around suspend points (except in async generators?). curious if anyone else has thought about this at all.","m.mentions":{},"msgtype":"m.text"},"ts":1731516395695,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$o6tUOb2s_1bfHzf6pVtINeWIE6DgCB21juyAY2JFWXM"},
{"content":{"body":"async context variable disposable needs https://tc39.es/proposal-async-context/#sec-generatorresume to play well with generator/yield","m.mentions":{},"msgtype":"m.text"},"ts":1731516494573,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$9y9CCoYEU1VVSio4PsJJ9zkwMogWk5d-14BhxeDFKxw"},
{"content":{"body":"more specifically i was hoping these two examples would behave the same, but the second one doesn't work because you'd have to restore the context \"inside\" await, before it returns to the caller. https://gist.github.com/devsnek/2eee5001144f7e39513e3694ca6b3e8d","m.mentions":{},"msgtype":"m.text"},"ts":1731516871964,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$i-39gXsHMgLJtVsIknWlG6vpqeqrSUHppHmupZ7Rvzs"},
{"content":{"body":" * more specifically i was hoping these two examples would behave the same, but the second one doesn't work because you'd have to restore the context \"inside\" await, after it sets the adds the promise reaction and before it returns to the caller. https://gist.github.com/devsnek/2eee5001144f7e39513e3694ca6b3e8d","m.mentions":{},"m.new_content":{"body":"more specifically i was hoping these two examples would behave the same, but the second one doesn't work because you'd have to restore the context \"inside\" await, after it sets the adds the promise reaction and before it returns to the caller. https://gist.github.com/devsnek/2eee5001144f7e39513e3694ca6b3e8d","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$i-39gXsHMgLJtVsIknWlG6vpqeqrSUHppHmupZ7Rvzs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731516988520,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$XG4iabXVPW9lENumlFtoXSIM-GC_hINr0QWq1xAo_YA"},
{"content":{"body":"I'm not sure I quite understand your example.  You've written `[[AsyncContext]] = 'FOO'` but (syntax aside) the current proposal doesn't allow just setting the context.  Are you assuming something like\n```javascript\n{\n  using _ = asyncVar.with('FOO');\n  foo();\n}\n```\nor are you thinking of something else entirely?","format":"org.matrix.custom.html","formatted_body":"<p>I'm not sure I quite understand your example.  You've written <code>[[AsyncContext]] = 'FOO'</code> but (syntax aside) the current proposal doesn't allow just setting the context.  Are you assuming something like</p>\n<pre><code class=\"language-javascript\">{\n  using _ = asyncVar.with('FOO');\n  foo();\n}\n</code></pre>\n<p>or are you thinking of something else entirely?</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731523259746,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$-JUadcf3DgTaWDvTL0Lg_Rh7R2CqwpS2RAxgZJGgmH8"},
{"content":{"body":" * I'm not sure I quite understand your example.  You've written `[[AsyncContext]] = 'FOO'` but (syntax aside) the current proposal doesn't allow just setting the context.  Are you assuming something like\n\n```javascript\n{\n  using _ = asyncVar.setWithDisposable('FOO');\n  foo();\n}\n```\n\nor are you thinking of something else entirely?","format":"org.matrix.custom.html","formatted_body":" * <p>I'm not sure I quite understand your example.  You've written <code>[[AsyncContext]] = 'FOO'</code> but (syntax aside) the current proposal doesn't allow just setting the context.  Are you assuming something like</p>\n<pre><code class=\"language-javascript\">{\n  using _ = asyncVar.setWithDisposable('FOO');\n  foo();\n}\n</code></pre>\n<p>or are you thinking of something else entirely?</p>\n","m.mentions":{},"m.new_content":{"body":"I'm not sure I quite understand your example.  You've written `[[AsyncContext]] = 'FOO'` but (syntax aside) the current proposal doesn't allow just setting the context.  Are you assuming something like\n\n```javascript\n{\n  using _ = asyncVar.setWithDisposable('FOO');\n  foo();\n}\n```\n\nor are you thinking of something else entirely?","format":"org.matrix.custom.html","formatted_body":"<p>I'm not sure I quite understand your example.  You've written <code>[[AsyncContext]] = 'FOO'</code> but (syntax aside) the current proposal doesn't allow just setting the context.  Are you assuming something like</p>\n<pre><code class=\"language-javascript\">{\n  using _ = asyncVar.setWithDisposable('FOO');\n  foo();\n}\n</code></pre>\n<p>or are you thinking of something else entirely?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$-JUadcf3DgTaWDvTL0Lg_Rh7R2CqwpS2RAxgZJGgmH8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731523292906,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$rGLu-GnBvnC3fGq5wFkugOCMICHb8PgLqyeg0K8jG0Y"},
{"content":{"body":"That said, we're currently thinking about the impact of whether `yield` preserves context (i.e. the initialization context from the initial generator call), or whether it brings in the context from the surrounding `next()` caller (i.e. the dispatch context).  If it uses initialization context then context is sensibly block-scoped, and `using` makes a lot more sense.  If context might change across a `yield` then it's a lot less clear that `using` is at all viable, since the state to clean up at the end of the block scope may have changed out from under it.  So if `yield` exposes the dispatch context, then we're back to reconsidering what an `enterWith` or `set` semantics might look like.  In particular is the question of whether `set` in an inner/outer function body should change the value out from under an outer/inner function.  I.e.\n```javascript\nasync function f() {\n  g();  // n.b. not awaited\n  x.set(2);\n  await 1;\n  console.log(y.get()); // 3 ?\n}\nasync function g() {\n  await 1;\n  console.log(x.get()); // 2 ?\n  y.set(3);\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>That said, we're currently thinking about the impact of whether <code>yield</code> preserves context (i.e. the initialization context from the initial generator call), or whether it brings in the context from the surrounding <code>next()</code> caller (i.e. the dispatch context).  If it uses initialization context then context is sensibly block-scoped, and <code>using</code> makes a lot more sense.  If context might change across a <code>yield</code> then it's a lot less clear that <code>using</code> is at all viable, since the state to clean up at the end of the block scope may have changed out from under it.  So if <code>yield</code> exposes the dispatch context, then we're back to reconsidering what an <code>enterWith</code> or <code>set</code> semantics might look like.  In particular is the question of whether <code>set</code> in an inner/outer function body should change the value out from under an outer/inner function.  I.e.</p>\n<pre><code class=\"language-javascript\">async function f() {\n  g();  // n.b. not awaited\n  x.set(2);\n  await 1;\n  console.log(y.get()); // 3 ?\n}\nasync function g() {\n  await 1;\n  console.log(x.get()); // 2 ?\n  y.set(3);\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731523795649,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$A7kMUIHDUo8oHU2ZVW4GOZC-_gZkD7_L1P1qru924_A"},
{"content":{"body":"and how exactly one sets the boundaries on where mutations _do_ affect","format":"org.matrix.custom.html","formatted_body":"and how exactly one sets the boundaries on where mutations <em>do</em> affect","m.mentions":{},"msgtype":"m.text"},"ts":1731523900257,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$nP-gG8TwPOeZ9chpL4DSBXlQCRzaAgLYJkAj6LLMso8"},
{"content":{"body":"snek I'm also not fully understanding your question, but it _seems_ similar to a discussion we had in the past:\n\n```js\nrunWithContext(1, async () => {\n  console.log(getContext()) // 1\n  await new Promise(resolve => runWithContext(2, resolve));\n  console.log(getContext()) // ?\n});\n```\n\nIs answering what the second `getContext()` call logs the same as answering your question?","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@devsnek:matrix.org\">snek</a> I'm also not fully understanding your question, but it <em>seems</em> similar to a discussion we had in the past:</p>\n<pre><code class=\"language-js\">runWithContext(1, async () =&gt; {\n  console.log(getContext()) // 1\n  await new Promise(resolve =&gt; runWithContext(2, resolve));\n  console.log(getContext()) // ?\n});\n</code></pre>\n<p>Is answering what the second <code>getContext()</code> call logs the same as answering your question?</p>\n","m.mentions":{"user_ids":["@devsnek:matrix.org"]},"msgtype":"m.text"},"ts":1731524502265,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$3RxqRMfFnEufu04UhCxx6shxbPp5xOymgvZyQWiccxs"},
{"content":{"body":"> <@stephenhicks:matrix.org> I'm not sure I quite understand your example.  You've written `[[AsyncContext]] = 'FOO'` but (syntax aside) the current proposal doesn't allow just setting the context.  Are you assuming something like\n> \n> ```javascript\n> {\n>   using _ = asyncVar.setWithDisposable('FOO');\n>   foo();\n> }\n> ```\n> \n> or are you thinking of something else entirely?\n\nyes i am thinking about a disposable like that","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$-JUadcf3DgTaWDvTL0Lg_Rh7R2CqwpS2RAxgZJGgmH8?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>I'm not sure I quite understand your example.  You've written <code>[[AsyncContext]] = 'FOO'</code> but (syntax aside) the current proposal doesn't allow just setting the context.  Are you assuming something like</p>\n<pre><code class=\"language-javascript\">{\n  using _ = asyncVar.setWithDisposable('FOO');\n  foo();\n}\n</code></pre>\n<p>or are you thinking of something else entirely?</p>\n</blockquote></mx-reply>yes i am thinking about a disposable like that","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$-JUadcf3DgTaWDvTL0Lg_Rh7R2CqwpS2RAxgZJGgmH8"}},"msgtype":"m.text"},"ts":1731524627393,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$UzAzzsEA-pxbwU5fig9wfy_eBBeNU0fTD0DOT0vVGp8"},
{"content":{"body":"except this doesn't work with async functions because they don't restore the scope on awaits, you're forced to wrap the function.","m.mentions":{},"msgtype":"m.text"},"ts":1731524680555,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$uSAa3ZgVFgic42c4cTOj6esVYYBqNiopBbKYEUVkcl4"},
{"content":{"body":"Async functions capture the scope right before pausing and restore them when resuming:\n\n- right before pausing, step 7 of await (https://tc39.es/ecma262/#await) calls PerformPromiseThen\n- step 7 of PerformPromiseThen (https://tc39.es/proposal-async-context/#sec-performpromisethen) takes a snapshot of the async context\n\n- when the promise is resolved, step 1.d of the reaction job created in NewPromiseReactionJob (https://tc39.es/proposal-async-context/#sec-newpromisereactionjob) restores the context before running the code after the await","format":"org.matrix.custom.html","formatted_body":"<p>Async functions capture the scope right before pausing and restore them when resuming:</p>\n<ul>\n<li>\n<p>right before pausing, step 7 of await (https://tc39.es/ecma262/#await) calls PerformPromiseThen</p>\n</li>\n<li>\n<p>step 7 of PerformPromiseThen (https://tc39.es/proposal-async-context/#sec-performpromisethen) takes a snapshot of the async context</p>\n</li>\n<li>\n<p>when the promise is resolved, step 1.d of the reaction job created in NewPromiseReactionJob (https://tc39.es/proposal-async-context/#sec-newpromisereactionjob) restores the context before running the code after the await</p>\n</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731525230465,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Uwy6d9uF8MSYr7zUmC5iyUKNZaXmNEtk50cqdB9KjWA"},
{"content":{"body":"that's not exactly what i'm talking about","m.mentions":{},"msgtype":"m.text"},"ts":1731525290926,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$LZwWQWDwG6GGRLtynHCvzbTSM1I9Nc40TSd1Y9lIzIo"},
{"content":{"body":"its about code that effectively uses `enterWith`","format":"org.matrix.custom.html","formatted_body":"its about code that effectively uses <code>enterWith</code>","m.mentions":{},"msgtype":"m.text"},"ts":1731525366426,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$NwlNrbSjJbAXGOXbiI-_PDlyV7FCg6Rv4hX9kkhKdg4"},
{"content":{"body":"i'm referring to specifically when the async function is suspended, it does not restore the context. additionally, the promise reactions capture and restore their context. i'm basically suggesting that async function body evaluation should do the same.","m.mentions":{},"msgtype":"m.text"},"ts":1731525483415,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$jbS0x9dyUM5WlWaptxgwel9fUSHCTm-sFl9mCxwKoaE"},
{"content":{"body":" * i'm referring to specifically when the async function is suspended, it does not restore the context. additionally, as you noted, the promise reactions capture and restore their context. i'm basically suggesting that async function body evaluation should do the same.","m.mentions":{},"m.new_content":{"body":"i'm referring to specifically when the async function is suspended, it does not restore the context. additionally, as you noted, the promise reactions capture and restore their context. i'm basically suggesting that async function body evaluation should do the same.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$jbS0x9dyUM5WlWaptxgwel9fUSHCTm-sFl9mCxwKoaE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731525514347,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$hLBQXzg1b6eya3KdXWoe_z4SD1Iu_i8JdYRprH8CV1o"},
{"content":{"body":"Oh you mean that before pausing they restore the context that was active before that the code in the async function run?","m.mentions":{},"msgtype":"m.text"},"ts":1731525539285,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$FTb0gE2WAyuQHVyOi952UpP4UI30tiykNDLmpWxmqNY"},
{"content":{"body":"ye","m.mentions":{},"msgtype":"m.text"},"ts":1731525557517,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$uroh8EgdYwISzFmuQtwHF70ttjbzvZldanS0tilTYwc"},
{"content":{"body":" * yes","m.mentions":{},"m.new_content":{"body":"yes","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$uroh8EgdYwISzFmuQtwHF70ttjbzvZldanS0tilTYwc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731525558594,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$rZS4-aijJ9_HsDQfBZU5QTaS4DZx5koju-31xxJsE4A"},
{"content":{"body":"this is only relevant if you can \"mutate\" async variables though, which the proposal currently does not allow","m.mentions":{},"msgtype":"m.text"},"ts":1731525583197,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$-CNHOX7qUwLVVj8RTz9WWL0XIBxp61b4UtcvWRhygg4"},
{"content":{"body":"Ok -- just within the current AsyncContext itself this seems to be only editorial right? It's not observable, and it only becomes observable if somebody builds a new API that behaves like async context and uses the same propagation mechanism","m.mentions":{},"msgtype":"m.text"},"ts":1731525598063,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Db2ktdPxXaB7XX5IHX7_ppYMONpTN3mRegY3rvqEED8"}
]