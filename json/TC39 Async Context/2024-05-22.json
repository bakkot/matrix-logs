[
{"content":{"body":"I was kinda thinking out loud, and the fact that zone.js was probably the main reason why we were going with registration-time by default is something I noticed just now","m.mentions":{},"msgtype":"m.text"},"ts":1716336087308,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$XRZozLgHBJtF1UShw0_HXE01xJIUanZ84IkZYd7yyuc"},
{"content":{"body":"but I will","m.mentions":{},"msgtype":"m.text"},"ts":1716336089976,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$YdDCTpK7m4ZlmB84JP1xk2py0Gm6w6-wMVbKg64kHfk"},
{"content":{"body":"I think Jia Li is the person, but I didnâ€™t manage to reach him through Twitter DMs https://x.com/Jialipassion","msgtype":"m.text"},"ts":1716336276552,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$NKYHTY9XeC4HFsXvytZQO9DFKE1WGqZGYwKU4S90B6s"},
{"content":{"body":"We can work with other Angular devs to get his attention if we have trouble","msgtype":"m.text"},"ts":1716336346562,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$GE2kqgxL40U8zjVNjKL80K7lY-jy_OoZryNWeXvNj84"},
{"content":{"body":"Or meet him in Tokyo for TC39 this October! He showed up at last yearâ€™s community event","msgtype":"m.text"},"ts":1716336380266,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$VNxEaMpM7bNSMtpff3JBwfLHDJXX-2OUKV0dyyoz9xo"},
{"content":{"body":"hm, I can't going to Finland, but I'd love to have a business reason to go to Tokyo ðŸ˜…","m.mentions":{},"msgtype":"m.text"},"ts":1716336622109,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$dfN-VTBH82PiItpfBDj_1PEAqibQoioiZKQiq-Wtf2A"},
{"content":{"body":"> <@abotella:igalia.com> I think that maybe the only cases where events should be registration time are the ones where there isn't any possible JS origin for the event\n\nAn argument could be made that if there is no other JS origin, then registration time _is_ the origin.  That said, I'm a little horrified by what this will mean for polyfills...","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$HGPy3GoPzfoQoGLYa5mgJk4khDLn-CGKfL9W7qWhdAc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br />I think that maybe the only cases where events should be registration time are the ones where there isn't any possible JS origin for the event</blockquote></mx-reply>An argument could be made that if there is no other JS origin, then registration time <em>is</em> the origin.  That said, I'm a little horrified by what this will mean for polyfills...","m.relates_to":{"m.in_reply_to":{"event_id":"$HGPy3GoPzfoQoGLYa5mgJk4khDLn-CGKfL9W7qWhdAc"}},"msgtype":"m.text"},"ts":1716337501029,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$R7prkfrZ9HIT9WgobPEYmjQMDMTj_CxpYakiEvuB6Z8"},
{"content":{"body":"The implementation (and specification) of this version will certainly be more complex, including for browsers. So it is important that we consolidate documentation for exactly why this design is useful and provides better context.","msgtype":"m.text"},"ts":1716339725752,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$k2HFfgBR6PB2KJQlB1BT25moOHpn-30wWYFvLwoSDFY"},
{"content":{"body":"Sometimes the most relevant context isnâ€™t there exactly synchronously and needs to be saved and restored (unhandled rejection is an example of this)","msgtype":"m.text"},"ts":1716339795743,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hHQOcpkIQgf9R-j7K9fgBYSHKdLeDQZStwEWnCeqcr4"},
{"content":{"body":"> <@jridgewell:matrix.org> What is the example code? What is the indicated issue URL? Weâ€™d previosuly discussed why we donâ€™t have an `enterWith` API because of cases like this, it needs to properly restore the context after the execution of the inner async function pauses its await. Part of the reason we discussed `using` declarations with modifications to `await` keyword to restore the previous context at the suspend point.\n\nThis is exactly what I'm talking about. You seem to be explicitly aiming for binding _around_ awaits, cutting off the branched execution merging back. This is explicitly what most users have told me they _don't_ want. The code coming _out_ of that await is a continuation, so it's essentially the same as if the remaining code was passed into that call as a callback, which _does_ propagate context through. The fact that promises and async/await _will not_ flow context through to continuations is extremely confusing to literally every user I've talked to about this. The whole _point_ of context management to everyone I have talked to is to be able to set a value at some point in a branch of async execution and to be able to retrieve that same value _anywhere_ in logically continuing execution, which _any_ merge point like awaits, promise continuations, or callbacks all _are_.\n\nThe fact we are specifying a behaviour which seemingly no one outside of this group is asking for is very strange to me.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$PC8w5gAQfzkUyMTSmOnMRIEMgVlgsuyJdSCY79lGaRQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>What is the example code? What is the indicated issue URL? Weâ€™d previosuly discussed why we donâ€™t have an <code data-md=\"`\">enterWith</code> API because of cases like this, it needs to properly restore the context after the execution of the inner async function pauses its await. Part of the reason we discussed <code data-md=\"`\">using</code> declarations with modifications to <code data-md=\"`\">await</code> keyword to restore the previous context at the suspend point.</blockquote></mx-reply><p>This is exactly what I'm talking about. You seem to be explicitly aiming for binding <em>around</em> awaits, cutting off the branched execution merging back. This is explicitly what most users have told me they <em>don't</em> want. The code coming <em>out</em> of that await is a continuation, so it's essentially the same as if the remaining code was passed into that call as a callback, which <em>does</em> propagate context through. The fact that promises and async/await <em>will not</em> flow context through to continuations is extremely confusing to literally every user I've talked to about this. The whole <em>point</em> of context management to everyone I have talked to is to be able to set a value at some point in a branch of async execution and to be able to retrieve that same value <em>anywhere</em> in logically continuing execution, which <em>any</em> merge point like awaits, promise continuations, or callbacks all <em>are</em>.</p>\n<p>The fact we are specifying a behaviour which seemingly no one outside of this group is asking for is very strange to me.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$PC8w5gAQfzkUyMTSmOnMRIEMgVlgsuyJdSCY79lGaRQ"}},"msgtype":"m.text"},"ts":1716369762955,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$cQ9q3UPjgtkXx1nC_4beJu1EP-4ZHvcHGYjS1CgNU-I"},
{"content":{"body":"> <@jridgewell:matrix.org> What issue? There were like 400 messages in this channel over the last week.\n\nhttps://github.com/nodejs/node/issues/53037","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$RkvRiEMBW7NuC9yy1mCiaRU6NXzBa8ct_JmVDDyS50I?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>What issue? There were like 400 messages in this channel over the last week.</blockquote></mx-reply>https://github.com/nodejs/node/issues/53037","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$RkvRiEMBW7NuC9yy1mCiaRU6NXzBa8ct_JmVDDyS50I"}},"msgtype":"m.text"},"ts":1716369808155,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$8JUWrTs92nVcv9TG-JTQCkXQMjdU5moW6_heA43Ijck"},
{"content":{"body":"> <@jridgewell:matrix.org> So itâ€™s the case where `doSomething` doesnâ€™t create a parent span for its children? And we have to infer order of sibilngs when two `doSomething` calls are interleaved. Is this not just user error?\n\nNo, this is not user error. This is a common execution pattern which auto-instrumentation needs to be able to resolve, and it can't be done unless we flow context _through_ merging branches.\n\nThis is user code which _we do not control_ but are expected to be able to trace through correctly. There is no user error here because the user expects to not have to modify their code for it to be traceable, and there's no error in how APM vendors are handling these situations because we simply lack the tools for it to be _possible_ to track directly. This was the entire point of creating AsyncLocalStorage in the _first_ place, but it sadly only got _part_ of the way to correctness due to resource constraints and lacking runtime capabilities.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$T7nC37I7C98fbqhFo9BnY9K6iQvJ11hYe1so3w9pxS8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>So itâ€™s the case where <code data-md=\"`\">doSomething</code> doesnâ€™t create a parent span for its children? And we have to infer order of sibilngs when two <code data-md=\"`\">doSomething</code> calls are interleaved. Is this not just user error?</blockquote></mx-reply><p>No, this is not user error. This is a common execution pattern which auto-instrumentation needs to be able to resolve, and it can't be done unless we flow context <em>through</em> merging branches.</p>\n<p>This is user code which <em>we do not control</em> but are expected to be able to trace through correctly. There is no user error here because the user expects to not have to modify their code for it to be traceable, and there's no error in how APM vendors are handling these situations because we simply lack the tools for it to be <em>possible</em> to track directly. This was the entire point of creating AsyncLocalStorage in the <em>first</em> place, but it sadly only got <em>part</em> of the way to correctness due to resource constraints and lacking runtime capabilities.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$T7nC37I7C98fbqhFo9BnY9K6iQvJ11hYe1so3w9pxS8"}},"msgtype":"m.text"},"ts":1716370093794,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$XWboUZC-WkYlf9snbtO6MlDZUjnOSZWGS_otsKivjxE"},
{"content":{"body":"> <@stephenhicks:matrix.org> I spoke with the tracing experts I'm working with and they strongly prefer \"flow around\" semantics over \"flow through\" await (with a caveat that their primary experience is in other languages).  In particular, the concern is that the ability to do an unbounded `set()` isn't a good situation.  Further, they weren't at all concerned with the visibility issues from pruning off subtasks by binding around them, for two reasons: (1) exact follows-from relationships are primarily relevant for critical path analysis, which already has numerous other issues making it intractable, and (2) we can get a reasonable enough picture with the mutable trace objects referenced in a \"lexically scoped\" async store (i.e. what's currently proposed here).  The rough structure we use (IIUC) is that the async-local variables are trivially cheap span IDs and the global store is a log of events that includes those IDs.  When a span begins/ends, it gets a new ID the start/end times and parents are appended to the log (along with any additional metadata).  The graph can then be reconstructed later from that log.\n> \n> I agree completely with Justin's assessment of the `doSomething()` example - it wouldn't be an issue if `doSomething` were properly instrumented.  If you branch into two parallel subtasks without making a child span, you're asking for a bad time.\n\nFor the first part:\n- In what way is critical path analysis intractable? This is literally what tracing products are _for_.\n- Mutable trace objects are what the entire industry does _presently_ for Node.js. Every tracing product also has at least 30%+ CPU overhead and 50%+ memory overhead as a result. _All_ tracing products are completely unusable at massive scale, which is why most FAANG is either flying practically _blind_ with Node.js (Netflix), or doesn't use it in production _at all_ because the tooling insufficient\n\nAs for the second part:\n- The `doSomething()` function here is user code calling into some _other_ things we instrument. We have no awareness of this code as it's not part of any userland module, therefore it is impossible for us to instrument. This is an _extremely common_ scenario which tracing products are _expected_ to be able to trace. APM vendors are _constantly_ losing deals because we are unable to product correct traces for many prospective customers.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$AzfxGX4WIn0oNN76OoNSas6dX-T5kfDJZxaCLqzzNUI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>I spoke with the tracing experts I'm working with and they strongly prefer \"flow around\" semantics over \"flow through\" await (with a caveat that their primary experience is in other languages).  In particular, the concern is that the ability to do an unbounded <code>set()</code> isn't a good situation.  Further, they weren't at all concerned with the visibility issues from pruning off subtasks by binding around them, for two reasons: (1) exact follows-from relationships are primarily relevant for critical path analysis, which already has numerous other issues making it intractable, and (2) we can get a reasonable enough picture with the mutable trace objects referenced in a \"lexically scoped\" async store (i.e. what's currently proposed here).  The rough structure we use (IIUC) is that the async-local variables are trivially cheap span IDs and the global store is a log of events that includes those IDs.  When a span begins/ends, it gets a new ID the start/end times and parents are appended to the log (along with any additional metadata).  The graph can then be reconstructed later from that log.</p>\n<p>I agree completely with Justin's assessment of the <code>doSomething()</code> example - it wouldn't be an issue if <code>doSomething</code> were properly instrumented.  If you branch into two parallel subtasks without making a child span, you're asking for a bad time.</p>\n</blockquote></mx-reply><p>For the first part:</p>\n<ul>\n<li>In what way is critical path analysis intractable? This is literally what tracing products are <em>for</em>.</li>\n<li>Mutable trace objects are what the entire industry does <em>presently</em> for Node.js. Every tracing product also has at least 30%+ CPU overhead and 50%+ memory overhead as a result. <em>All</em> tracing products are completely unusable at massive scale, which is why most FAANG is either flying practically <em>blind</em> with Node.js (Netflix), or doesn't use it in production <em>at all</em> because the tooling insufficient</li>\n</ul>\n<p>As for the second part:</p>\n<ul>\n<li>The <code>doSomething()</code> function here is user code calling into some <em>other</em> things we instrument. We have no awareness of this code as it's not part of any userland module, therefore it is impossible for us to instrument. This is an <em>extremely common</em> scenario which tracing products are <em>expected</em> to be able to trace. APM vendors are <em>constantly</em> losing deals because we are unable to product correct traces for many prospective customers.</li>\n</ul>\n","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$AzfxGX4WIn0oNN76OoNSas6dX-T5kfDJZxaCLqzzNUI"}},"msgtype":"m.text"},"ts":1716370548405,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$qU7Ym0cuzi0LFmOEy4DEvrAVKYGYGXjwXUNugO_xj_8"},
{"content":{"body":"> <@abotella:igalia.com> I was kinda thinking out loud, and the fact that zone.js was probably the main reason why we were going with registration-time by default is something I noticed just now\n\nNode.js defaults to running everything in the scope where the emit happened, but [EventEmitterAsyncResource](https://nodejs.org/api/events.html#class-eventseventemitterasyncresource-extends-eventemitter) exists to chose register time for an entire event emitter as-needed.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$XRZozLgHBJtF1UShw0_HXE01xJIUanZ84IkZYd7yyuc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>I was kinda thinking out loud, and the fact that zone.js was probably the main reason why we were going with registration-time by default is something I noticed just now</blockquote></mx-reply>Node.js defaults to running everything in the scope where the emit happened, but <a href=\"https://nodejs.org/api/events.html#class-eventseventemitterasyncresource-extends-eventemitter\">EventEmitterAsyncResource</a> exists to chose register time for an entire event emitter as-needed.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$XRZozLgHBJtF1UShw0_HXE01xJIUanZ84IkZYd7yyuc"}},"msgtype":"m.text"},"ts":1716370797890,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$M89WeVzidOakzSPpJdS3JJQpv3vKHONKE3xdVeilmuw"},
{"content":{"body":"> <@stephenhicks:matrix.org> An argument could be made that if there is no other JS origin, then registration time _is_ the origin.  That said, I'm a little horrified by what this will mean for polyfills...\n\nHow about an option on `dispatchEvent` to discard the current origin and use the registration time one?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$R7prkfrZ9HIT9WgobPEYmjQMDMTj_CxpYakiEvuB6Z8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>An argument could be made that if there is no other JS origin, then registration time <em>is</em> the origin.  That said, I'm a little horrified by what this will mean for polyfills...</blockquote></mx-reply>How about an option on <code>dispatchEvent</code> to discard the current origin and use the registration time one?","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$R7prkfrZ9HIT9WgobPEYmjQMDMTj_CxpYakiEvuB6Z8"}},"msgtype":"m.text"},"ts":1716388032659,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$0WW7QPGM4-ZnBGJ3knflSVOTNF7k4iUvoZdVGgeSQeY"},
{"content":{"body":"> <@stephenhicks:matrix.org> An argument could be made that if there is no other JS origin, then registration time _is_ the origin.  That said, I'm a little horrified by what this will mean for polyfills...\n\n * How about an option on `dispatchEvent` to fire the event with the registration context, rather than the current one?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$R7prkfrZ9HIT9WgobPEYmjQMDMTj_CxpYakiEvuB6Z8?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>An argument could be made that if there is no other JS origin, then registration time <em>is</em> the origin.  That said, I'm a little horrified by what this will mean for polyfills...</blockquote></mx-reply> * How about an option on <code>dispatchEvent</code> to fire the event with the registration context, rather than the current one?","m.mentions":{},"m.new_content":{"body":"How about an option on `dispatchEvent` to fire the event with the registration context, rather than the current one?","format":"org.matrix.custom.html","formatted_body":"How about an option on <code>dispatchEvent</code> to fire the event with the registration context, rather than the current one?","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$0WW7QPGM4-ZnBGJ3knflSVOTNF7k4iUvoZdVGgeSQeY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716388799993,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$JxIW5vTXo6dXCMHTFSE4O-HyV2ndCZXp-Zs8kcG3UN4"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Node.js defaults to running everything in the scope where the emit happened, but [EventEmitterAsyncResource](https://nodejs.org/api/events.html#class-eventseventemitterasyncresource-extends-eventemitter) exists to chose register time for an entire event emitter as-needed.\n\nit seems like that is meant for user-defined emitters, and can't be used for built-ins","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$M89WeVzidOakzSPpJdS3JJQpv3vKHONKE3xdVeilmuw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Node.js defaults to running everything in the scope where the emit happened, but <a href=\"https://nodejs.org/api/events.html#class-eventseventemitterasyncresource-extends-eventemitter\">EventEmitterAsyncResource</a> exists to chose register time for an entire event emitter as-needed.</blockquote></mx-reply>it seems like that is meant for user-defined emitters, and can't be used for built-ins","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$M89WeVzidOakzSPpJdS3JJQpv3vKHONKE3xdVeilmuw"}},"msgtype":"m.text"},"ts":1716390263292,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Urngb_d-yMgw7AB6mrUiqg_MItRw4lUimN-NpofJry8"},
{"content":{"body":"do you ever use that to monkeypatch built-ins? is it better than just monkeypatching the `EventEmitter` methods on the object itself?","format":"org.matrix.custom.html","formatted_body":"do you ever use that to monkeypatch built-ins? is it better than just monkeypatching the <code>EventEmitter</code> methods on the object itself?","m.mentions":{},"msgtype":"m.text"},"ts":1716390315766,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$VfknXC84WWx6tbDZl8bOEs5pa3VTgd_6cQEVhOLR0tU"},
{"content":{"body":"> <@abotella:igalia.com> How about an option on `dispatchEvent` to fire the event with the registration context, rather than the current one?\n\nI'm not quite sure how to think about that one... my initial reaction is that I still don't like touching specific scheduling APIs because it sets a weird precedent that every scheduling API needs to change to account for this.  But maybe this is a \"you can't keep your cake and eat it\" situation where we're saying that we need to provide this control.  Overall, I don't think the one who calls dispatchEvent is the one who knows which context it should be in.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$0WW7QPGM4-ZnBGJ3knflSVOTNF7k4iUvoZdVGgeSQeY?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>How about an option on <code>dispatchEvent</code> to fire the event with the registration context, rather than the current one?</blockquote></mx-reply>I'm not quite sure how to think about that one... my initial reaction is that I still don't like touching specific scheduling APIs because it sets a weird precedent that every scheduling API needs to change to account for this.  But maybe this is a \"you can't keep your cake and eat it\" situation where we're saying that we need to provide this control.  Overall, I don't think the one who calls dispatchEvent is the one who knows which context it should be in.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$0WW7QPGM4-ZnBGJ3knflSVOTNF7k4iUvoZdVGgeSQeY"}},"msgtype":"m.text"},"ts":1716394227253,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$r95m8fKzn3lO4VuiNHeLWM_yEvlWFHdplE7WyfsXE9o"},
{"content":{"body":"> <@stephenbelanger:matrix.org> This is exactly what I'm talking about. You seem to be explicitly aiming for binding _around_ awaits, cutting off the branched execution merging back. This is explicitly what most users have told me they _don't_ want. The code coming _out_ of that await is a continuation, so it's essentially the same as if the remaining code was passed into that call as a callback, which _does_ propagate context through. The fact that promises and async/await _will not_ flow context through to continuations is extremely confusing to literally every user I've talked to about this. The whole _point_ of context management to everyone I have talked to is to be able to set a value at some point in a branch of async execution and to be able to retrieve that same value _anywhere_ in logically continuing execution, which _any_ merge point like awaits, promise continuations, or callbacks all _are_.\n> \n> The fact we are specifying a behaviour which seemingly no one outside of this group is asking for is very strange to me.\n\nHonestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).\n\nIf you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$cQ9q3UPjgtkXx1nC_4beJu1EP-4ZHvcHGYjS1CgNU-I?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br><p>This is exactly what I'm talking about. You seem to be explicitly aiming for binding <em>around</em> awaits, cutting off the branched execution merging back. This is explicitly what most users have told me they <em>don't</em> want. The code coming <em>out</em> of that await is a continuation, so it's essentially the same as if the remaining code was passed into that call as a callback, which <em>does</em> propagate context through. The fact that promises and async/await <em>will not</em> flow context through to continuations is extremely confusing to literally every user I've talked to about this. The whole <em>point</em> of context management to everyone I have talked to is to be able to set a value at some point in a branch of async execution and to be able to retrieve that same value <em>anywhere</em> in logically continuing execution, which <em>any</em> merge point like awaits, promise continuations, or callbacks all <em>are</em>.</p>\n<p>The fact we are specifying a behaviour which seemingly no one outside of this group is asking for is very strange to me.</p>\n</blockquote></mx-reply><p>Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).</p>\n<p>If you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$cQ9q3UPjgtkXx1nC_4beJu1EP-4ZHvcHGYjS1CgNU-I"}},"msgtype":"m.text"},"ts":1716395310772,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Qfd0eq8fDtAm2MXQhXwxPPMfF9B8Yna91A5dJSVSvig"},
{"content":{"body":" * Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).\n\nIf you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for the tracking execution flow, or is there something else that could do it more naturally?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$cQ9q3UPjgtkXx1nC_4beJu1EP-4ZHvcHGYjS1CgNU-I?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br><p>This is exactly what I'm talking about. You seem to be explicitly aiming for binding <em>around</em> awaits, cutting off the branched execution merging back. This is explicitly what most users have told me they <em>don't</em> want. The code coming <em>out</em> of that await is a continuation, so it's essentially the same as if the remaining code was passed into that call as a callback, which <em>does</em> propagate context through. The fact that promises and async/await <em>will not</em> flow context through to continuations is extremely confusing to literally every user I've talked to about this. The whole <em>point</em> of context management to everyone I have talked to is to be able to set a value at some point in a branch of async execution and to be able to retrieve that same value <em>anywhere</em> in logically continuing execution, which <em>any</em> merge point like awaits, promise continuations, or callbacks all <em>are</em>.</p>\n<p>The fact we are specifying a behaviour which seemingly no one outside of this group is asking for is very strange to me.</p>\n</blockquote></mx-reply> * <p>Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).</p>\n<p>If you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for the tracking execution flow, or is there something else that could do it more naturally?</p>\n","m.mentions":{},"m.new_content":{"body":"Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).\n\nIf you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for the tracking execution flow, or is there something else that could do it more naturally?","format":"org.matrix.custom.html","formatted_body":"<p>Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).</p>\n<p>If you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for the tracking execution flow, or is there something else that could do it more naturally?</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Qfd0eq8fDtAm2MXQhXwxPPMfF9B8Yna91A5dJSVSvig","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716395408680,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$N9V3XHvxEBMrAfPsfnwttIKl-3yH9qZDzBoY9fNUou0"},
{"content":{"body":" * Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).\n\nIf you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for tracking execution flow, or is there something else that could do it more naturally?","format":"org.matrix.custom.html","formatted_body":" * <p>Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).</p>\n<p>If you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for tracking execution flow, or is there something else that could do it more naturally?</p>\n","m.mentions":{},"m.new_content":{"body":"Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).\n\nIf you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for tracking execution flow, or is there something else that could do it more naturally?","format":"org.matrix.custom.html","formatted_body":"<p>Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).</p>\n<p>If you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for tracking execution flow, or is there something else that could do it more naturally?</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Qfd0eq8fDtAm2MXQhXwxPPMfF9B8Yna91A5dJSVSvig","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716395423718,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Gjx-KsQkvP1Tp9qktK9HMcTW2LyLMIHTd-oNI4r0n3s"},
{"content":{"body":"Cancellation is an example of a use case where bind-around is what we want.  Suppose we have a \"globally well-known\" `abort: AsyncContext.Variable<AbortSignal>` for the current task.  Well-behaved jobs can inspect it and `throwIfAborted`, pass it along to things like `fetch` (or even have `fetch` use it implicitly), etc.  Suppose you want to do something that can be cancelled independently of the upstream abort - you can `const c = new AbortController()` and then `abort.run(AbortSignal.any(abort.get(), c.signal), ...)`, and the child task can be cancelled by either the parent or the new child controller.  Now imagine you've just programmatically added 5 cards to a view, which each need to fetch data and render themselves.  You might kick off 5 fetches, each with its own child signal.  If the user dismisses one of those cards while it was still loading, we can abort that one child controller individually.  But it would clearly be a mistake to end up with one of those child signals as the current signal after `await Promise.all(childCards)`.","format":"org.matrix.custom.html","formatted_body":"Cancellation is an example of a use case where bind-around is what we want.  Suppose we have a \"globally well-known\" <code>abort: AsyncContext.Variable&lt;AbortSignal&gt;</code> for the current task.  Well-behaved jobs can inspect it and <code>throwIfAborted</code>, pass it along to things like <code>fetch</code> (or even have <code>fetch</code> use it implicitly), etc.  Suppose you want to do something that can be cancelled independently of the upstream abort - you can <code>const c = new AbortController()</code> and then <code>abort.run(AbortSignal.any(abort.get(), c.signal), ...)</code>, and the child task can be cancelled by either the parent or the new child controller.  Now imagine you've just programmatically added 5 cards to a view, which each need to fetch data and render themselves.  You might kick off 5 fetches, each with its own child signal.  If the user dismisses one of those cards while it was still loading, we can abort that one child controller individually.  But it would clearly be a mistake to end up with one of those child signals as the current signal after <code>await Promise.all(childCards)</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1716396713301,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$YOUcvSSNhvv5MPaDpswcjfwqpPhYsuhN-1fPQBKPnsc"},
{"content":{"body":"> <@stephenbelanger:matrix.org> This is exactly what I'm talking about. You seem to be explicitly aiming for binding _around_ awaits, cutting off the branched execution merging back. This is explicitly what most users have told me they _don't_ want. The code coming _out_ of that await is a continuation, so it's essentially the same as if the remaining code was passed into that call as a callback, which _does_ propagate context through. The fact that promises and async/await _will not_ flow context through to continuations is extremely confusing to literally every user I've talked to about this. The whole _point_ of context management to everyone I have talked to is to be able to set a value at some point in a branch of async execution and to be able to retrieve that same value _anywhere_ in logically continuing execution, which _any_ merge point like awaits, promise continuations, or callbacks all _are_.\n> \n> The fact we are specifying a behaviour which seemingly no one outside of this group is asking for is very strange to me.\n\nI think youâ€™re misinterpreting my statement. We can have flow-through semantics without `enterWith`. `enterWith` is a foot-gun that exposes an unfixable memory leak, and I specifically opose that. I will not accept a design that has an unparied enter/exit.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24cQ9q3UPjgtkXx1nC_4beJu1EP-4ZHvcHGYjS1CgNU-I\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br /><p>This is exactly what I'm talking about. You seem to be explicitly aiming for binding <em>around</em> awaits, cutting off the branched execution merging back. This is explicitly what most users have told me they <em>don't</em> want. The code coming <em>out</em> of that await is a continuation, so it's essentially the same as if the remaining code was passed into that call as a callback, which <em>does</em> propagate context through. The fact that promises and async/await <em>will not</em> flow context through to continuations is extremely confusing to literally every user I've talked to about this. The whole <em>point</em> of context management to everyone I have talked to is to be able to set a value at some point in a branch of async execution and to be able to retrieve that same value <em>anywhere</em> in logically continuing execution, which <em>any</em> merge point like awaits, promise continuations, or callbacks all <em>are</em>.</p>\n<p>The fact we are specifying a behaviour which seemingly no one outside of this group is asking for is very strange to me.</p>\n</blockquote></mx-reply>I think youâ€™re misinterpreting my statement. We can have flow-through semantics without <code data-md=\"`\">enterWith</code>. <code data-md=\"`\">enterWith</code> is a foot-gun that exposes an unfixable memory leak, and I specifically opose that. I will not accept a design that has an unparied enter/exit.","m.relates_to":{"m.in_reply_to":{"event_id":"$cQ9q3UPjgtkXx1nC_4beJu1EP-4ZHvcHGYjS1CgNU-I"}},"msgtype":"m.text"},"ts":1716397359519,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$JsvC1qVfImnloaqsXnw2hvcVqbQPwYSQzyUwNTBr50g"},
{"content":{"body":"> <@abotella:igalia.com> I think that maybe the only cases where events should be registration time are the ones where there isn't any possible JS origin for the event\n\nJustin Ridgewell: I was wondering about your thoughts on this ^ , since you suggested that the behavior for events should probably follow zone.js, and this does the opposite","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$HGPy3GoPzfoQoGLYa5mgJk4khDLn-CGKfL9W7qWhdAc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>I think that maybe the only cases where events should be registration time are the ones where there isn&#39;t any possible JS origin for the event</blockquote></mx-reply><a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a>: I was wondering about your thoughts on this ^ , since you suggested that the behavior for events should probably follow zone.js, and this does the opposite","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$HGPy3GoPzfoQoGLYa5mgJk4khDLn-CGKfL9W7qWhdAc"}},"msgtype":"m.text"},"ts":1716397528590,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$q9M4aLpKTvK2U2tI3MlTBuU06TLXbvToP7gbpGG1Jbw"},
{"content":{"body":"What APIs would that include? I think that means all click listeners are call-time, but what context is that for a userâ€™s click vs a programatic click?","msgtype":"m.text"},"ts":1716397618210,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$0P-j08HYpUVbTLBvgUF0sc7RCamXIiQAR83YLIxmgog"},
{"content":{"body":"For a user's click, it would be registration time, and for a programatic click, it would be call time on the call to `.click()`","format":"org.matrix.custom.html","formatted_body":"For a user's click, it would be registration time, and for a programatic click, it would be call time on the call to <code>.click()</code>","m.mentions":{},"msgtype":"m.text"},"ts":1716397668794,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$tUYRjAd0UCipTGfOhzMmWNvwpKSciIq9wM0BUDeneIk"},
{"content":{"body":"Iâ€™d prefer registration-time for consistentcy, but Iâ€™d see both options being acceptable.","msgtype":"m.text"},"ts":1716397688764,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$8D5tPEAPjhyNotLF5n-1cU0ku5SPB3JV0cbUj91Fuac"},
{"content":{"body":"* Iâ€™d prefer registration-time for both cases for consistentcy, but Iâ€™d see both options being acceptable.","m.new_content":{"body":"Iâ€™d prefer registration-time for both cases for consistentcy, but Iâ€™d see both options being acceptable.","msgtype":"m.text"},"m.relates_to":{"event_id":"$8D5tPEAPjhyNotLF5n-1cU0ku5SPB3JV0cbUj91Fuac","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716397704644,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$OHFUM0UhLuR7kNu2xBnWrYnW3di-KCjkhNTeDJDJvTk"},
{"content":{"body":"Was the `unwrap()` API discussed?","format":"org.matrix.custom.html","formatted_body":"Was the <code data-md=\"`\">unwrap()</code> API discussed?","msgtype":"m.text"},"ts":1716397777162,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ZCanqbr4PmuMEU-9qYViLrNOh5eaEMEelIE1-6ciTx8"},
{"content":{"body":"no","m.mentions":{},"msgtype":"m.text"},"ts":1716397811490,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$e9OxBiU8wI_Hf5PxGVuCaT4qrTgHzSMI-WqlIiy07ok"},
{"content":{"body":"I'm not too much of a fan of `unwrap()`, but it is an option we could use","format":"org.matrix.custom.html","formatted_body":"I'm not too much of a fan of <code>unwrap()</code>, but it is an option we could use","m.mentions":{},"msgtype":"m.text"},"ts":1716397891179,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$MG9UyJSMzvL-z1xuQ_WBTzBGrAA6O3RmznBsb03t9rU"},
{"content":{"body":"btw, I think at some point Jatin said he had a use case for detecting the null context (the difference between user's click and programmatic click in this case)","m.mentions":{},"msgtype":"m.text"},"ts":1716398003691,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$9yHHPuLmEOCwv6ok9aVzqZQlebyG54ZGWS3_sxJi22w"},
{"content":{"body":"Steve Hicks: do you know anything about that?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">Steve Hicks</a>: do you know anything about that?","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"msgtype":"m.text"},"ts":1716398021474,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$NI4-4LrW9r2IBp0im9qc7o_kVKIuNUL8TL0sBLXhROw"},
{"content":{"body":"> <@abotella:igalia.com> do you ever use that to monkeypatch built-ins? is it better than just monkeypatching the `EventEmitter` methods on the object itself?\n\nNope, it's for a user of EventEmitter to explicitly opt-in to that flow. APMs need to go for direct patching though.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$VfknXC84WWx6tbDZl8bOEs5pa3VTgd_6cQEVhOLR0tU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>do you ever use that to monkeypatch built-ins? is it better than just monkeypatching the <code>EventEmitter</code> methods on the object itself?</blockquote></mx-reply>Nope, it's for a user of EventEmitter to explicitly opt-in to that flow. APMs need to go for direct patching though.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$VfknXC84WWx6tbDZl8bOEs5pa3VTgd_6cQEVhOLR0tU"}},"msgtype":"m.text"},"ts":1716398299789,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$z89aResQEU03FsKOGZij8Ob-ep-DV7GaHmb_b0-gjCE"},
{"content":{"body":"> <@abotella:igalia.com> do you ever use that to monkeypatch built-ins? is it better than just monkeypatching the `EventEmitter` methods on the object itself?\n\nNode.js builtins have async hooks built-in support so it is not necessary to patch built-ins to avoid empty context","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$VfknXC84WWx6tbDZl8bOEs5pa3VTgd_6cQEVhOLR0tU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>do you ever use that to monkeypatch built-ins? is it better than just monkeypatching the <code>EventEmitter</code> methods on the object itself?</blockquote></mx-reply>Node.js builtins have async hooks built-in support so it is not necessary to patch built-ins to avoid empty context","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$VfknXC84WWx6tbDZl8bOEs5pa3VTgd_6cQEVhOLR0tU"}},"msgtype":"m.text"},"ts":1716398477489,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$HRU63mNd0INxFvBS-eOXizwtZjaVrtopDm4A_XMgsec"},
{"content":{"body":"However, this support is not defined in web platform yet","m.mentions":{},"msgtype":"m.text"},"ts":1716398543396,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$K5hX0lLGZrCQoIfiHqnzg1FckvOU-QY9zmlOgP01seM"},
{"content":{"body":"> <@stephenhicks:matrix.org> Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).\n> \n> If you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for tracking execution flow, or is there something else that could do it more naturally?\n\nYep, I get that you have different use cases, and I _assume_ with this much energy pushing in that direction there must be some _valid_ reasons for aiming for these semantics. However, in Node.js most users are coming from the space of having a bunch of historically callback-oriented code taking advantage of context flowing to logically continuing execution so they can flow data between their components without needing to get teams owning intermediary components to explicitly pass along their bits of data. In more _recent_ history they are starting to adapt that callback code to promise code and then being confused/angry/disappointed that their data no longer flows into that later code.\n\nI suggested yesterday that it might make sense to have a separate equivalent to AsyncContext called something like ContinuationContext which more semantically matches the downstream availability semantics these users are expecting. I also commented that I think the naming of AsyncContext could maybe be more illustrative of exactly _what_ the flow is to not confuse users into thinking this thing has the flow they are expecting.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$Qfd0eq8fDtAm2MXQhXwxPPMfF9B8Yna91A5dJSVSvig?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).</p>\n<p>If you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is \"context\" even the right concept for tracking execution flow, or is there something else that could do it more naturally?</p>\n</blockquote></mx-reply><p>Yep, I get that you have different use cases, and I <em>assume</em> with this much energy pushing in that direction there must be some <em>valid</em> reasons for aiming for these semantics. However, in Node.js most users are coming from the space of having a bunch of historically callback-oriented code taking advantage of context flowing to logically continuing execution so they can flow data between their components without needing to get teams owning intermediary components to explicitly pass along their bits of data. In more <em>recent</em> history they are starting to adapt that callback code to promise code and then being confused/angry/disappointed that their data no longer flows into that later code.</p>\n<p>I suggested yesterday that it might make sense to have a separate equivalent to AsyncContext called something like ContinuationContext which more semantically matches the downstream availability semantics these users are expecting. I also commented that I think the naming of AsyncContext could maybe be more illustrative of exactly <em>what</em> the flow is to not confuse users into thinking this thing has the flow they are expecting.</p>\n","m.mentions":{"user_ids":["@stephenhicks:matrix.org","@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Qfd0eq8fDtAm2MXQhXwxPPMfF9B8Yna91A5dJSVSvig"}},"msgtype":"m.text"},"ts":1716398870062,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$2xRi1qQ1tpBEv2heQoRnf0LqH-yYpYPw8Goxg2P9EoM"},
{"content":{"body":"> <@stephenhicks:matrix.org> Cancellation is an example of a use case where bind-around is what we want.  Suppose we have a \"globally well-known\" `abort: AsyncContext.Variable<AbortSignal>` for the current task.  Well-behaved jobs can inspect it and `throwIfAborted`, pass it along to things like `fetch` (or even have `fetch` use it implicitly), etc.  Suppose you want to do something that can be cancelled independently of the upstream abort - you can `const c = new AbortController()` and then `abort.run(AbortSignal.any(abort.get(), c.signal), ...)`, and the child task can be cancelled by either the parent or the new child controller.  Now imagine you've just programmatically added 5 cards to a view, which each need to fetch data and render themselves.  You might kick off 5 fetches, each with its own child signal.  If the user dismisses one of those cards while it was still loading, we can abort that one child controller individually.  But it would clearly be a mistake to end up with one of those child signals as the current signal after `await Promise.all(childCards)`.\n\nHmm...I can see value to _both_ flows when it comes to cancellation, actually. But I assume the _inner_ promises being awaited would just raise exceptions to the outer function doing the awaiting, allowing those to do their own exception handling? Personally though I feel like what you would actually _want_ is for the level at which you do the run to be \"around\" scoped and then _nested_ branches to be _through_ scoped so it raises all the way up to the _intended_ scope boundary and not introducing an additional exception type to intermediate layers. That seems like the same SES concern state above of communication between two points unexpectedly influencing the intermediate layers.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$YOUcvSSNhvv5MPaDpswcjfwqpPhYsuhN-1fPQBKPnsc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Cancellation is an example of a use case where bind-around is what we want.  Suppose we have a \"globally well-known\" <code>abort: AsyncContext.Variable&lt;AbortSignal&gt;</code> for the current task.  Well-behaved jobs can inspect it and <code>throwIfAborted</code>, pass it along to things like <code>fetch</code> (or even have <code>fetch</code> use it implicitly), etc.  Suppose you want to do something that can be cancelled independently of the upstream abort - you can <code>const c = new AbortController()</code> and then <code>abort.run(AbortSignal.any(abort.get(), c.signal), ...)</code>, and the child task can be cancelled by either the parent or the new child controller.  Now imagine you've just programmatically added 5 cards to a view, which each need to fetch data and render themselves.  You might kick off 5 fetches, each with its own child signal.  If the user dismisses one of those cards while it was still loading, we can abort that one child controller individually.  But it would clearly be a mistake to end up with one of those child signals as the current signal after <code>await Promise.all(childCards)</code>.</blockquote></mx-reply>Hmm...I can see value to <em>both</em> flows when it comes to cancellation, actually. But I assume the <em>inner</em> promises being awaited would just raise exceptions to the outer function doing the awaiting, allowing those to do their own exception handling? Personally though I feel like what you would actually <em>want</em> is for the level at which you do the run to be \"around\" scoped and then <em>nested</em> branches to be <em>through</em> scoped so it raises all the way up to the <em>intended</em> scope boundary and not introducing an additional exception type to intermediate layers. That seems like the same SES concern state above of communication between two points unexpectedly influencing the intermediate layers.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$YOUcvSSNhvv5MPaDpswcjfwqpPhYsuhN-1fPQBKPnsc"}},"msgtype":"m.text"},"ts":1716399209584,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Ac4oNsrA8AuGBbBRi6YcZQ-8wZ0WkM9SlvAPw3jIhCg"},
{"content":{"body":"> <@jridgewell:matrix.org> I think youâ€™re misinterpreting my statement. We can have flow-through semantics without `enterWith`. `enterWith` is a foot-gun that exposes an unfixable memory leak, and I specifically opose that. I will not accept a design that has an unparied enter/exit.\n\nIt's _not_ an unpaired enter/exit though. The enter/exit is just left up to the runtime. so a microtask boundary, or the execution scope of the top-level script or module. There's still a clearly defined scope you can use, and this is what _literally every other language does_, it's just under full control of the runtime to define them rather than leaving it up to the user to define their own _custom_ boundaries, which are arguably _more_ complex to reason about because the runtime can't do things like having the optimizer rearrange execution _around_ these boundaries without breaking the context guarantees.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$JsvC1qVfImnloaqsXnw2hvcVqbQPwYSQzyUwNTBr50g?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>I think youâ€™re misinterpreting my statement. We can have flow-through semantics without <code data-md=\"`\">enterWith</code>. <code data-md=\"`\">enterWith</code> is a foot-gun that exposes an unfixable memory leak, and I specifically opose that. I will not accept a design that has an unparied enter/exit.</blockquote></mx-reply>It's <em>not</em> an unpaired enter/exit though. The enter/exit is just left up to the runtime. so a microtask boundary, or the execution scope of the top-level script or module. There's still a clearly defined scope you can use, and this is what <em>literally every other language does</em>, it's just under full control of the runtime to define them rather than leaving it up to the user to define their own <em>custom</em> boundaries, which are arguably <em>more</em> complex to reason about because the runtime can't do things like having the optimizer rearrange execution <em>around</em> these boundaries without breaking the context guarantees.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$JsvC1qVfImnloaqsXnw2hvcVqbQPwYSQzyUwNTBr50g"}},"msgtype":"m.text"},"ts":1716399415712,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Rba1vG-R6XEprfwYhsNQSU3gLqr1EBXZwdU_QJLdds4"},
{"content":{"body":"What all other languages which have _automatically_ propagated context do is exactly this:\n\n```js\nstore.defineScope(() => {\n  store.setForCurrentScope('foo')\n})\n```\n\nWith the exception that the `store.defineScope(...)` part is just implicitly encoded into barrier within the language/runtime itself.","format":"org.matrix.custom.html","formatted_body":"<p>What all other languages which have <em>automatically</em> propagated context do is exactly this:</p>\n<pre><code class=\"language-js\">store.defineScope(() =&gt; {\n  store.setForCurrentScope('foo')\n})\n</code></pre>\n<p>With the exception that the <code>store.defineScope(...)</code> part is just implicitly encoded into barrier within the language/runtime itself.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716399762616,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$v91IqLf2tSozc_FqBeTTM9AbfIhjnA9X-XVRhOVQExA"},
{"content":{"body":"So .NET defines a scope around each async function call.","m.mentions":{},"msgtype":"m.text"},"ts":1716399779604,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$lmElW6Z-593joIfZPCMMY5MLaxR54qIt0RFOFYFyMxI"},
{"content":{"body":"Which produces exactly the semantics you are describing.","m.mentions":{},"msgtype":"m.text"},"ts":1716399797621,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$6Z6UBYilU-8cvZBhaYrD29OU9H6f6j3MJwMeqK6Zn6s"},
{"content":{"body":"While _also_ allowing mutability of the slot _within_ that function _safely_.","format":"org.matrix.custom.html","formatted_body":"While <em>also</em> allowing mutability of the slot <em>within</em> that function <em>safely</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1716399812590,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$c6cnBma-Yg1aCWnRRMO_Lr8_W0PQC70NZ5MvlZIXAgg"},
{"content":{"body":"The _only_ difference with how AsyncContext is defined _presently_ is just that the `defineScope(...)` and `setForCurrentScope(...)` concepts are forcefully made to be only possible to do at the same point, but in terms of actual safety and control they are identical.","format":"org.matrix.custom.html","formatted_body":"The <em>only</em> difference with how AsyncContext is defined <em>presently</em> is just that the <code>defineScope(...)</code> and <code>setForCurrentScope(...)</code> concepts are forcefully made to be only possible to do at the same point, but in terms of actual safety and control they are identical.","m.mentions":{},"msgtype":"m.text"},"ts":1716399916559,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$fw5pw2fL6tNY6s-av7ZCbdFPSfacZwSGyn90OzQK_xo"},
{"content":{"body":"And nothing _stops_ us from _also_ providing users the ability to describe _additional_ scopes.","format":"org.matrix.custom.html","formatted_body":"And nothing <em>stops</em> us from <em>also</em> providing users the ability to describe <em>additional</em> scopes.","m.mentions":{},"msgtype":"m.text"},"ts":1716399937494,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$x7UpzYei1m18UBCgH4XjBUmac5EEsCAFSM8K6y3ks5U"},
{"content":{"body":"We're also _essentially_ already _doing_ this with capture scopes around things like awaits. They are just another manifestation of setting a value for some synchronous window. The fact that it is propagated from elsewhere is somewhat immaterial.","format":"org.matrix.custom.html","formatted_body":"We're also <em>essentially</em> already <em>doing</em> this with capture scopes around things like awaits. They are just another manifestation of setting a value for some synchronous window. The fact that it is propagated from elsewhere is somewhat immaterial.","m.mentions":{},"msgtype":"m.text"},"ts":1716400016276,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ktiWM8ft0wguVKvb8l4lTm8ELn9Vh76AIShSgFVKljo"},
{"content":{"body":" * What all other languages which have _automatically_ propagated context do is exactly this:\n\n```js\nstore.defineScope(() => {\n  store.setForCurrentScope('foo')\n})\n```\n\nWith the exception that the `store.defineScope(...)` part is just implicitly encoded into many barriers within the language/runtime itself.","format":"org.matrix.custom.html","formatted_body":" * <p>What all other languages which have <em>automatically</em> propagated context do is exactly this:</p>\n<pre><code class=\"language-js\">store.defineScope(() =&gt; {\n  store.setForCurrentScope('foo')\n})\n</code></pre>\n<p>With the exception that the <code>store.defineScope(...)</code> part is just implicitly encoded into many barriers within the language/runtime itself.</p>\n","m.mentions":{},"m.new_content":{"body":"What all other languages which have _automatically_ propagated context do is exactly this:\n\n```js\nstore.defineScope(() => {\n  store.setForCurrentScope('foo')\n})\n```\n\nWith the exception that the `store.defineScope(...)` part is just implicitly encoded into many barriers within the language/runtime itself.","format":"org.matrix.custom.html","formatted_body":"<p>What all other languages which have <em>automatically</em> propagated context do is exactly this:</p>\n<pre><code class=\"language-js\">store.defineScope(() =&gt; {\n  store.setForCurrentScope('foo')\n})\n</code></pre>\n<p>With the exception that the <code>store.defineScope(...)</code> part is just implicitly encoded into many barriers within the language/runtime itself.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$v91IqLf2tSozc_FqBeTTM9AbfIhjnA9X-XVRhOVQExA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716400043118,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$VvRBJzaUdZuJj29EXyReulZ6SnKPasKj5gxOW8M7-QI"},
{"content":{"body":"The set/get style is _much_ better in terms of closure reduction, more flexible and better suited to async/await flows, and _equally_ as safe as the `store.run(...)` form.","format":"org.matrix.custom.html","formatted_body":"The set/get style is <em>much</em> better in terms of closure reduction, more flexible and better suited to async/await flows, and <em>equally</em> as safe as the <code>store.run(...)</code> form.","m.mentions":{},"msgtype":"m.text"},"ts":1716400171012,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kEYbV196HAwqjX2rWnH3n8-41toRiDwLlSfwg29I-N0"}
]