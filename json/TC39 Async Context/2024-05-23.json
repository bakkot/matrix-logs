[
{"content":{"body":"> <@jridgewell:matrix.org> I think we can extend this as well. Imagine the parent is doing a fetch and creates an abort signal, then passes that same signal to the children to perform their fetches. They each setup their own fetch state otherwise, maybe logging. It’d be surprising that the parent aborting their fetch causes the child’s fetch to inherit the parent’s fetch state.\n\nI'm not quite sure what you're saying.  If you pass the same signal to the children, then aborting them is exactly what I'd expect.  It should be a conscious choice which signal to pass, and reusing a signal indicates to me precisely that you want them all to abort together.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$qc4o6xAuLmMGSnqobU-1Kx7gEQxRCIkpOM4xpMz0YOk?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>I think we can extend this as well. Imagine the parent is doing a fetch and creates an abort signal, then passes that same signal to the children to perform their fetches. They each setup their own fetch state otherwise, maybe logging. It’d be surprising that the parent aborting their fetch causes the child’s fetch to inherit the parent’s fetch state.</blockquote></mx-reply>I'm not quite sure what you're saying.  If you pass the same signal to the children, then aborting them is exactly what I'd expect.  It should be a conscious choice which signal to pass, and reusing a signal indicates to me precisely that you want them all to abort together.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$qc4o6xAuLmMGSnqobU-1Kx7gEQxRCIkpOM4xpMz0YOk"}},"msgtype":"m.text"},"ts":1716433802362,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$UqjGMalRo8AwLh-XujP5SubGGKppe7M708cj_bGRkow"},
{"content":{"body":"I expect the children to abort, not for the cleanup code in the children to assume the signaling event’s context.","msgtype":"m.text"},"ts":1716434021796,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$E-G19u7NkdV3GohtoiZSUKvPNhquN_zinFpqk-keRJk"},
{"content":{"body":"Gotcha, I think I misunderstood \"sets up their own fetch state\".  You were saying that they might add some of their own async vars as well, and that it should be encapsulated to the child rather than flowing through from the parent.  I agree.","m.mentions":{},"msgtype":"m.text"},"ts":1716434146479,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$c5POf51babZYOg5iXgBcoOHvffJDIQ5O14-xupfITAU"},
{"content":{"body":"Yes, rereading it now I didn’t word it well.","msgtype":"m.text"},"ts":1716434190455,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Jl6-lnJ8Jo8htU7ffUGX8np8A571vwi-_jcn_slsmIQ"},
{"content":{"body":"Another example where encapsulated (defualt flow-around) approach makes sense is to behave like React's `<Context.Provider>`.  That API is designed to avoid \"prop drilling\", where an outer JSX component needs to pass data to an inner JSX component, but due to JSX's design, this ends up requiring every component in between to accept and pass along that same data.  The generally accepted solution is to put a `<Context>` element around the outside, and then it can be accessed directly by any descendent without adding arguments everywhere in between.  If, for some reason, there were an additional provider for the same context variable, it would override the previous one, but only for the current scope - so it's clean.  It would be very susprising if changes to this context in a child scope ended up affecting other sibling subcomponents.\n\nIn general, this use case of \"implicit parameter propagation without needing to virally change the signatures  in between\" is relevant both in JSX but also in ordinary JS, and it basically always wants the bind-around approach.","format":"org.matrix.custom.html","formatted_body":"<p>Another example where encapsulated (defualt flow-around) approach makes sense is to behave like React's <code>&lt;Context.Provider&gt;</code>.  That API is designed to avoid \"prop drilling\", where an outer JSX component needs to pass data to an inner JSX component, but due to JSX's design, this ends up requiring every component in between to accept and pass along that same data.  The generally accepted solution is to put a <code>&lt;Context&gt;</code> element around the outside, and then it can be accessed directly by any descendent without adding arguments everywhere in between.  If, for some reason, there were an additional provider for the same context variable, it would override the previous one, but only for the current scope - so it's clean.  It would be very susprising if changes to this context in a child scope ended up affecting other sibling subcomponents.</p>\n<p>In general, this use case of \"implicit parameter propagation without needing to virally change the signatures  in between\" is relevant both in JSX but also in ordinary JS, and it basically always wants the bind-around approach.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716438555406,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$w2wckcaV25TOCAAoDFYoirw763aN2TGBOlIuImy8J-s"},
{"content":{"body":"Hello, I am Jia Li, the maintainer of the Zone.js, thank you for having me here.","m.mentions":{},"msgtype":"m.text"},"ts":1716456454501,"senderName":"Jia Li","senderId":"@jiali.passion:matrix.org","id":"$v0gswA7pTlY5sLOS3lmIhVn8YZ_IcSry-CF80AOvBsQ"},
{"content":{"body":"> <@jiali.passion:matrix.org> Hello, I am Jia Li, the maintainer of the Zone.js, thank you for having me here.\n\nThank you so much for joining! We were wondering, could you tell us about how Zone.js arrived at its current policy of which fallbacks to zone-wrap and how? I have heard that this changed over time to fix bugs. We are trying to work out the analogous policy for AsyncContext.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24v0gswA7pTlY5sLOS3lmIhVn8YZ_IcSry-CF80AOvBsQ\">In reply to</a> <a href=\"https://matrix.to/#/@jiali.passion:matrix.org\">@jiali.passion:matrix.org</a><br>Hello, I am Jia Li, the maintainer of the Zone.js, thank you for having me here.</blockquote></mx-reply>Thank you so much for joining! We were wondering, could you tell us about how Zone.js arrived at its current policy of which fallbacks to zone-wrap and how? I have heard that this changed over time to fix bugs. We are trying to work out the analogous policy for AsyncContext.","m.relates_to":{"m.in_reply_to":{"event_id":"$v0gswA7pTlY5sLOS3lmIhVn8YZ_IcSry-CF80AOvBsQ"}},"msgtype":"m.text"},"ts":1716468549275,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XNleONOsOiadh0UH3XZpDcfxNZ_sJ0nNJ63fVPCwRzE"},
{"content":{"body":"One particular example we have have been thinking about is, what zone should an event run in, when it is triggered by JS? I guess Zone.js runs it in the zone where the event was registered, but we are thinking about running it in the zone which triggered the event.","msgtype":"m.text"},"ts":1716468810602,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$BhMFyYXnGC8Sd04IbQRiRZYgAyLFz0FUjfVJXlA90Fc"},
{"content":{"body":"* One particular example we have been thinking about is, what zone should an event run in, when it is triggered by JS? I guess Zone.js runs it in the zone where the event was registered, but we are thinking about running it in the zone which triggered the event.","m.new_content":{"body":"One particular example we have been thinking about is, what zone should an event run in, when it is triggered by JS? I guess Zone.js runs it in the zone where the event was registered, but we are thinking about running it in the zone which triggered the event.","msgtype":"m.text"},"m.relates_to":{"event_id":"$BhMFyYXnGC8Sd04IbQRiRZYgAyLFz0FUjfVJXlA90Fc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716468854978,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$sUYtaL2UcSglhVQ-eJwgscX4u1pM3ZadZ1YIncYhJfI"},
{"content":{"body":"littledan: \nYeah, I remembered this issue have been discussed in the earlier stage of zone.js development, the policy of Zone.js is the callback should run in the same context(zone) when the task is scheduled.  \n1. for macrotask, such as `setTimeout(callback)`, the `setTimeout` call schedule the async operation, so the callback should be in the same context(zone) with the setTimeout call\n```\nzone1.run(() => {\n  setTimeout(() => {\n    console.log(Zone.current.name); // should be zone1\n  }, 0);\n});\n```\n2. about eventTask such as `button.addEventListener('click', handler);`, we considered the schedule process is the `addEventListener` call instead of the dispatchEvent call.\n```\nzone1.run(() => {\n  button.addEventListener('click', () => {\n     console.log(Zone.current.name) // should be zone1;\n  });\n\n  zone2.run(() => {\n    button.dispatchEvent(clickEvent);\n  });\n});\n```\n3. for microtask such as Promise, the schedule process is when `promise.then` is called.\n\n```\nlet p = null;\nzone1.run(() => {\n  p = new Promise(...);\n});\nzone2.run(() => {\n  p.then(() => {\n    console.log(Zone.current); // will be zone2\n  })\n});\n```\n","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a>:<br>Yeah, I remembered this issue have been discussed in the earlier stage of zone.js development, the policy of Zone.js is the callback should run in the same context(zone) when the task is scheduled.</p>\n<ol>\n<li>for macrotask, such as <code>setTimeout(callback)</code>, the <code>setTimeout</code> call schedule the async operation, so the callback should be in the same context(zone) with the setTimeout call</li>\n</ol>\n<pre><code>zone1.run(() =&gt; {\n  setTimeout(() =&gt; {\n    console.log(Zone.current.name); // should be zone1\n  }, 0);\n});\n</code></pre>\n<ol start=\"2\">\n<li>about eventTask such as <code>button.addEventListener('click', handler);</code>, we considered the schedule process is the <code>addEventListener</code> call instead of the dispatchEvent call.</li>\n</ol>\n<pre><code>zone1.run(() =&gt; {\n  button.addEventListener('click', () =&gt; {\n     console.log(Zone.current.name) // should be zone1;\n  });\n\n  zone2.run(() =&gt; {\n    button.dispatchEvent(clickEvent);\n  });\n});\n</code></pre>\n<ol start=\"3\">\n<li>for microtask such as Promise, the schedule process is when <code>promise.then</code> is called.</li>\n</ol>\n<pre><code>let p = null;\nzone1.run(() =&gt; {\n  p = new Promise(...);\n});\nzone2.run(() =&gt; {\n  p.then(() =&gt; {\n    console.log(Zone.current); // will be zone2\n  })\n});\n</code></pre>\n","m.mentions":{"user_ids":["@littledan:matrix.org"]},"msgtype":"m.text"},"ts":1716472003442,"senderName":"Jia Li","senderId":"@jiali.passion:matrix.org","id":"$tUWgV6BZ8wvZx7WhAcwXXfGoQYz6E3v598eSoNV_4qE"},
{"content":{"body":"Jia Li: What kind of feedback have you gotten over time about this policy? Do people ever complain that it gives them the wrong results?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jiali.passion:matrix.org\">Jia Li</a>: What kind of feedback have you gotten over time about this policy? Do people ever complain that it gives them the wrong results?","m.mentions":{"user_ids":["@jiali.passion:matrix.org"]},"msgtype":"m.text"},"ts":1716472053836,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XEMUTo4_gpUW7tYFXgb3DVGkBgX3VQyUQya0tzEHofA"},
{"content":{"body":"About eventTask, some people asks the question why the zone is not the zone when the event triggered which is confuse in some cases, but in Angular, event task basically always run in the same zone, so there are no big difference about using the register zone or the trigger zone(they are the same in the 99% of the use cases).\n \nAnd I think the event trigger such as `dispatchEvent` is a synchronized operation, so depends on should we consider eventTask as an async operation, if it is , I think using the register zone is reasonable, if not, zone.js should leave the eventTask alone and not wrap it at all. ","format":"org.matrix.custom.html","formatted_body":"<p>About eventTask, some people asks the question why the zone is not the zone when the event triggered which is confuse in some cases, but in Angular, event task basically always run in the same zone, so there are no big difference about using the register zone or the trigger zone(they are the same in the 99% of the use cases).</p>\n<p>And I think the event trigger such as <code>dispatchEvent</code> is a synchronized operation, so depends on should we consider eventTask as an async operation, if it is , I think using the register zone is reasonable, if not, zone.js should leave the eventTask alone and not wrap it at all.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716472584240,"senderName":"Jia Li","senderId":"@jiali.passion:matrix.org","id":"$PyMorwEJyFP88-apLDqkOW2vW7BtsRKTv8mR2iK3E-E"},
{"content":{"body":"> <@jridgewell:matrix.org> There’s literally no exit in the code sample, meaning the value is leaked. There is no way for a user’s runtime to know when the execution graph has ended, and there’s no way the committee would expose that as an API. This was also brought up by Andreu in response to Jason’s proposed design a few days ago, and they also mention that it’s an unsolvable leak. Allowing an enter to exist without a paired exit is an awful design.\n\nThe exit is the end of the scope function. It applies scopes in _exactly the same way_. It just does it implicitly at the runtime level. And yes, there most certainly _is_ a way to know when execution ends: any time the runtime would become _idle_ and/or transition to microtask processing it knowns it has reached the end of the current selection of synchronous code. At that point you end that context.\n\n_However_, you don't _actually_ need to know when an end occurs if all execution descends from a root at the beginning of execution as then the _start_ of any execution would be propagating and therefore swapping out the context value _anyway_, so clearing it at the _end_ actually becomes unnecessary. There's actually been mathematical proofs of this for the .NET implementation.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$lnOzU3Tu0A9i5c-Z4AZGgrPpUMewbcCeakuTeQaWPI0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>There’s literally no exit in the code sample, meaning the value is leaked. There is no way for a user’s runtime to know when the execution graph has ended, and there’s no way the committee would expose that as an API. This was also brought up by Andreu in response to Jason’s proposed design a few days ago, and they also mention that it’s an unsolvable leak. Allowing an enter to exist without a paired exit is an awful design.</blockquote></mx-reply><p>The exit is the end of the scope function. It applies scopes in <em>exactly the same way</em>. It just does it implicitly at the runtime level. And yes, there most certainly <em>is</em> a way to know when execution ends: any time the runtime would become <em>idle</em> and/or transition to microtask processing it knowns it has reached the end of the current selection of synchronous code. At that point you end that context.</p>\n<p><em>However</em>, you don't <em>actually</em> need to know when an end occurs if all execution descends from a root at the beginning of execution as then the <em>start</em> of any execution would be propagating and therefore swapping out the context value <em>anyway</em>, so clearing it at the <em>end</em> actually becomes unnecessary. There's actually been mathematical proofs of this for the .NET implementation.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$lnOzU3Tu0A9i5c-Z4AZGgrPpUMewbcCeakuTeQaWPI0"}},"msgtype":"m.text"},"ts":1716474552132,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$xS91z6fRplJE7alUQv2xaxkYUmdHRwBJdtf4r8s8a6I"},
{"content":{"body":"> <@jridgewell:matrix.org> There’s literally no exit in the code sample, meaning the value is leaked. There is no way for a user’s runtime to know when the execution graph has ended, and there’s no way the committee would expose that as an API. This was also brought up by Andreu in response to Jason’s proposed design a few days ago, and they also mention that it’s an unsolvable leak. Allowing an enter to exist without a paired exit is an awful design.\n\n * The exit is the end of the scope function. It applies scopes in _exactly the same way_. It just does it implicitly at the runtime level. And yes, there most certainly _is_ a way to know when execution ends: any time the runtime would become _idle_ and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. At that point you end that context.\n\n_However_, you don't _actually_ need to know when an end occurs if all execution descends from a root at the beginning of execution as then the _start_ of any execution would be propagating and therefore swapping out the context value _anyway_, so clearing it at the _end_ actually becomes unnecessary. There's actually been mathematical proofs of this for the .NET implementation.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$lnOzU3Tu0A9i5c-Z4AZGgrPpUMewbcCeakuTeQaWPI0?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>There’s literally no exit in the code sample, meaning the value is leaked. There is no way for a user’s runtime to know when the execution graph has ended, and there’s no way the committee would expose that as an API. This was also brought up by Andreu in response to Jason’s proposed design a few days ago, and they also mention that it’s an unsolvable leak. Allowing an enter to exist without a paired exit is an awful design.</blockquote></mx-reply> * <p>The exit is the end of the scope function. It applies scopes in <em>exactly the same way</em>. It just does it implicitly at the runtime level. And yes, there most certainly <em>is</em> a way to know when execution ends: any time the runtime would become <em>idle</em> and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. At that point you end that context.</p>\n<p><em>However</em>, you don't <em>actually</em> need to know when an end occurs if all execution descends from a root at the beginning of execution as then the <em>start</em> of any execution would be propagating and therefore swapping out the context value <em>anyway</em>, so clearing it at the <em>end</em> actually becomes unnecessary. There's actually been mathematical proofs of this for the .NET implementation.</p>\n","m.mentions":{},"m.new_content":{"body":"The exit is the end of the scope function. It applies scopes in _exactly the same way_. It just does it implicitly at the runtime level. And yes, there most certainly _is_ a way to know when execution ends: any time the runtime would become _idle_ and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. At that point you end that context.\n\n_However_, you don't _actually_ need to know when an end occurs if all execution descends from a root at the beginning of execution as then the _start_ of any execution would be propagating and therefore swapping out the context value _anyway_, so clearing it at the _end_ actually becomes unnecessary. There's actually been mathematical proofs of this for the .NET implementation.","format":"org.matrix.custom.html","formatted_body":"<p>The exit is the end of the scope function. It applies scopes in <em>exactly the same way</em>. It just does it implicitly at the runtime level. And yes, there most certainly <em>is</em> a way to know when execution ends: any time the runtime would become <em>idle</em> and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. At that point you end that context.</p>\n<p><em>However</em>, you don't <em>actually</em> need to know when an end occurs if all execution descends from a root at the beginning of execution as then the <em>start</em> of any execution would be propagating and therefore swapping out the context value <em>anyway</em>, so clearing it at the <em>end</em> actually becomes unnecessary. There's actually been mathematical proofs of this for the .NET implementation.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$xS91z6fRplJE7alUQv2xaxkYUmdHRwBJdtf4r8s8a6I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716474892571,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$RvlnF3LY_60DtYQ4Ut-yG3ttgnYQzSGJCrWwxammixo"},
{"content":{"body":" * The exit is the end of the scope function. It applies scopes in _exactly the same way_. It just does it implicitly at the runtime level. And yes, there most certainly _is_ a way to know when execution ends: any time the runtime would become _idle_ and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. At that point you end that context.\n\n_However_, you don't _actually_ need to know when an end occurs if all execution descends from a root at the beginning of execution as then the _start_ of any execution would be propagating and therefore swapping out the context value _anyway_, so clearing it at the _end_ actually becomes unnecessary as it would be immediately followed by a change _anyway_. There's actually been mathematical proofs of this for the .NET implementation.","format":"org.matrix.custom.html","formatted_body":" * <p>The exit is the end of the scope function. It applies scopes in <em>exactly the same way</em>. It just does it implicitly at the runtime level. And yes, there most certainly <em>is</em> a way to know when execution ends: any time the runtime would become <em>idle</em> and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. At that point you end that context.</p>\n<p><em>However</em>, you don't <em>actually</em> need to know when an end occurs if all execution descends from a root at the beginning of execution as then the <em>start</em> of any execution would be propagating and therefore swapping out the context value <em>anyway</em>, so clearing it at the <em>end</em> actually becomes unnecessary as it would be immediately followed by a change <em>anyway</em>. There's actually been mathematical proofs of this for the .NET implementation.</p>\n","m.mentions":{},"m.new_content":{"body":"The exit is the end of the scope function. It applies scopes in _exactly the same way_. It just does it implicitly at the runtime level. And yes, there most certainly _is_ a way to know when execution ends: any time the runtime would become _idle_ and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. At that point you end that context.\n\n_However_, you don't _actually_ need to know when an end occurs if all execution descends from a root at the beginning of execution as then the _start_ of any execution would be propagating and therefore swapping out the context value _anyway_, so clearing it at the _end_ actually becomes unnecessary as it would be immediately followed by a change _anyway_. There's actually been mathematical proofs of this for the .NET implementation.","format":"org.matrix.custom.html","formatted_body":"<p>The exit is the end of the scope function. It applies scopes in <em>exactly the same way</em>. It just does it implicitly at the runtime level. And yes, there most certainly <em>is</em> a way to know when execution ends: any time the runtime would become <em>idle</em> and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. At that point you end that context.</p>\n<p><em>However</em>, you don't <em>actually</em> need to know when an end occurs if all execution descends from a root at the beginning of execution as then the <em>start</em> of any execution would be propagating and therefore swapping out the context value <em>anyway</em>, so clearing it at the <em>end</em> actually becomes unnecessary as it would be immediately followed by a change <em>anyway</em>. There's actually been mathematical proofs of this for the .NET implementation.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$xS91z6fRplJE7alUQv2xaxkYUmdHRwBJdtf4r8s8a6I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716474933033,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$B6GWYxySvyAzSYvi-euXuytXp0cj2dWl5x0FMEjvuis"},
{"content":{"body":"> <@jiali.passion:matrix.org> About eventTask, some people asks the question why the zone is not the zone when the event triggered which is confuse in some cases, but in Angular, event task basically always run in the same zone, so there are no big difference about using the register zone or the trigger zone(they are the same in the 99% of the use cases).\n>  \n> And I think the event trigger such as `dispatchEvent` is a synchronized operation, so depends on should we consider eventTask as an async operation, if it is , I think using the register zone is reasonable, if not, zone.js should leave the eventTask alone and not wrap it at all.\n\nNot wrapping at all seems kinda incomplete as well; sometimes no JS was on the stack when the event was triggered. I was imagining that the registration-time zone should be used for some of those cases (e.g., onload)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$PyMorwEJyFP88-apLDqkOW2vW7BtsRKTv8mR2iK3E-E?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jiali.passion:matrix.org\">@jiali.passion:matrix.org</a><br><p>About eventTask, some people asks the question why the zone is not the zone when the event triggered which is confuse in some cases, but in Angular, event task basically always run in the same zone, so there are no big difference about using the register zone or the trigger zone(they are the same in the 99% of the use cases).</p>\n<p>And I think the event trigger such as <code>dispatchEvent</code> is a synchronized operation, so depends on should we consider eventTask as an async operation, if it is , I think using the register zone is reasonable, if not, zone.js should leave the eventTask alone and not wrap it at all.</p>\n</blockquote></mx-reply>Not wrapping at all seems kinda incomplete as well; sometimes no JS was on the stack when the event was triggered. I was imagining that the registration-time zone should be used for some of those cases (e.g., onload)","m.mentions":{"user_ids":["@jiali.passion:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$PyMorwEJyFP88-apLDqkOW2vW7BtsRKTv8mR2iK3E-E"}},"msgtype":"m.text"},"ts":1716475139755,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$aT5yfMysQ_S-NO4h_5AAgUqI8TAPG_fDsRjyL2O8JLk"},
{"content":{"body":"Even for clicking, sometimes you dispatchEvent, but usually you actually just click, in which case you don't have anything to go on besides the registration zone","m.mentions":{},"msgtype":"m.text"},"ts":1716475189209,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_0vCw6oVlWdWMtrm7fUWP7CR32cpB0MPoCPO9W0JALo"},
{"content":{"body":"so maybe the \"triggering zone\" should be used *when it exists*, otherwise you fall back to the registration-time zone","format":"org.matrix.custom.html","formatted_body":"so maybe the \"triggering zone\" should be used <em>when it exists</em>, otherwise you fall back to the registration-time zone","m.mentions":{},"msgtype":"m.text"},"ts":1716475212904,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$eIVx_RLftuRBA2vEkK1b-YjRQd-MMqL5LD9KG7rGQU4"}
]