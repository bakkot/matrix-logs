[
{"content":{"body":"> <@littledan:matrix.org> we have to have this conversation with Steven and Signals people about Computed's context -- there's a concern that call-time context there would constitute \"Zalgo\": a computed signal could be forced in many different ways, and it should be giving the same answer regardless of context (of course we need some debugging/perf analysis tools to be possible)\n\nI agree that there's definite problems with computed signals - it's possible that two setters feed into the same computed signal and could have been set in different contexts, plus the fact that they're computed lazily might point to the reader's context as the correct call-time context (i.e. coming from the other direction). So there's potentially three or more different options and not necessarily a good way to disambiguate all of them.\n\nThat said, if there's no way to access the context(s) that set the signal(s) that caused the recompute, then tracing in many UI frameworks is essentially sunk. In my experience, it's a _very_ common pattern to have an event handler do nothing but update a signal. If the tracing framework initiates a trace in the event handler then the trace would simply die then and there, whereas we'd like to be able to link that trace to any downstream reactions/effects, all the way to the re-render.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rorB792EDNX34EdSfB9td7vBuxOAeqgNiPuJLANCVPg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />we have to have this conversation with Steven and Signals people about Computed's context -- there's a concern that call-time context there would constitute &quot;Zalgo&quot;: a computed signal could be forced in many different ways, and it should be giving the same answer regardless of context (of course we need some debugging/perf analysis tools to be possible)</blockquote></mx-reply><p>I agree that there's definite problems with computed signals - it's possible that two setters feed into the same computed signal and could have been set in different contexts, plus the fact that they're computed lazily might point to the reader's context as the correct call-time context (i.e. coming from the other direction). So there's potentially three or more different options and not necessarily a good way to disambiguate all of them.</p>\n<p>That said, if there's no way to access the context(s) that set the signal(s) that caused the recompute, then tracing in many UI frameworks is essentially sunk. In my experience, it's a <em>very</em> common pattern to have an event handler do nothing but update a signal. If the tracing framework initiates a trace in the event handler then the trace would simply die then and there, whereas we'd like to be able to link that trace to any downstream reactions/effects, all the way to the re-render.</p>","m.relates_to":{"m.in_reply_to":{"event_id":"$rorB792EDNX34EdSfB9td7vBuxOAeqgNiPuJLANCVPg"}},"msgtype":"m.text"},"ts":1712893000862,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$23-3PdqSmo1N_BD8c1PZwPS1aES-blPqladV_bfziFQ"},
{"content":{"body":"I see... so in this case, it's like application state should be registration-based, but tracing state should be call-based... :(","m.mentions":{},"msgtype":"m.text"},"ts":1712927930479,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kE5oQXK-3M9cbgsWqIfRihrtCU41AVsnyMoxLQd_9AY"},
{"content":{"body":"What's an example of application state that you'd want to be registration-based? My general (but somewhat uninformed) rule-of-thumb is that if a callback is intended to be called multiple times, it's more likely to want call-time context.","msgtype":"m.text"},"ts":1712930842429,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$BgDZfxiY_v4YXlVU2UZYZpMNiUkSbJ8XI6PW-y_pmP0"},
{"content":{"body":"an example is if we wanted to use AsyncContext for tracking the owner in tree-based rendering, or generally, React Context-style information","m.mentions":{},"msgtype":"m.text"},"ts":1712931085433,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$cMdE81CQo6ATf2f1izMg747v2V26_ntTRuI3mWGPWi0"},
{"content":{"body":"we could use AsyncContext.Snapshot.wrap for these cases but then it'd defeat tracing, sounds like...","m.mentions":{},"msgtype":"m.text"},"ts":1712931107156,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XiKT3nwRc12DJ1dFMQEbI4HJiuLe2YPdFg41pqTlJ1w"},
{"content":{"body":"also for the style of React Hooks using global variables under the hood","m.mentions":{},"msgtype":"m.text"},"ts":1712931150073,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ioTpyO6FdM_-BDFy3BYIkG4_Vm9T4Tl7oIIz_3Z-n84"},
{"content":{"body":"restoring the context after await is an example of registration-time behavior I think","m.mentions":{},"msgtype":"m.text"},"ts":1712931197483,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$FzPcfpAMdePaRzt_lwn7CcpEcA028ecnhtFFEsFFCOs"},
{"content":{"body":"(especially obvious if you consider what explicit calls of .then() should do)","m.mentions":{},"msgtype":"m.text"},"ts":1712931214319,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$V6P2rvliLM9uOjCkcPt4C1MX1KuMYA1ltZ1wmYCj5HA"},
{"content":{"body":"That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot.","format":"org.matrix.custom.html","formatted_body":"That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot.","m.mentions":{},"msgtype":"m.text"},"ts":1712942510924,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA"},
{"content":{"body":" * That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot on reentry","format":"org.matrix.custom.html","formatted_body":" * That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot on reentry","m.mentions":{},"m.new_content":{"body":"That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot on reentry","format":"org.matrix.custom.html","formatted_body":"That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot on reentry","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712942958120,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$rJDW0gTEw7KxpnvaUUFHwOIXGCG1jzm3kL9LoLWgJOM"},
{"content":{"body":"> <@stephenhicks:matrix.org> That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot on reentry\n\nJustin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot on reentry</blockquote></mx-reply>Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA"}},"msgtype":"m.text"},"ts":1712944255096,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hpD38YcJDfOpLVKTsFpsatmT1I8ygRID6AfRBH2SPJ4"},
{"content":{"body":"> <@stephenhicks:matrix.org> That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot on reentry\n\n * Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await or yield\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot on reentry</blockquote></mx-reply> * Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await or yield\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","m.mentions":{},"m.new_content":{"body":"Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await or yield\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","format":"org.matrix.custom.html","formatted_body":"Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await or yield\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$hpD38YcJDfOpLVKTsFpsatmT1I8ygRID6AfRBH2SPJ4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712944289086,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$gKSk8XoWsIDmWcFStJDt6cSYMbnOY278y01zZhHzj1w"},
{"content":{"body":"well, with a disposable there would be","m.mentions":{},"msgtype":"m.text"},"ts":1712944290272,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$rwSBkLQQYJ4Wajyrm7LSy_3KTysfvQ_5Yaiwz6PtY2k"},
{"content":{"body":" * well, with a disposable there would be a difference","m.mentions":{},"m.new_content":{"body":"well, with a disposable there would be a difference","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rwSBkLQQYJ4Wajyrm7LSy_3KTysfvQ_5Yaiwz6PtY2k","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712944304533,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$ltqdFwgsKwDQofdiJS3h4QT_r2QZjJpKELBm5Isr4Vc"},
{"content":{"body":"right, if we had some flat way of doing `run` within a function, I'd *definitely* want the semantics to be, preserve what was before the await/yield; I don't see any argument for \"restore the one at function entry\"","format":"org.matrix.custom.html","formatted_body":"right, if we had some flat way of doing <code>run</code> within a function, I'd <em>definitely</em> want the semantics to be, preserve what was before the await/yield; I don't see any argument for \"restore the one at function entry\"","m.mentions":{},"msgtype":"m.text"},"ts":1712944342666,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$EE4J65daW7UNc3n3A2G9kSxb90Z8IlVGtD7gobAF0aw"},
{"content":{"body":"I think await and yield are maybe separate questions, but otherwise I agree.","m.mentions":{},"msgtype":"m.text"},"ts":1712944378945,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$04FV12Rl2Oo2YpiVJAL-J5uKlZSA5PrKGHEP5xqrIZo"},
{"content":{"body":" * I think await and yield are _maybe_ separate questions, but otherwise I agree.","format":"org.matrix.custom.html","formatted_body":" * I think await and yield are <em>maybe</em> separate questions, but otherwise I agree.","m.mentions":{},"m.new_content":{"body":"I think await and yield are _maybe_ separate questions, but otherwise I agree.","format":"org.matrix.custom.html","formatted_body":"I think await and yield are <em>maybe</em> separate questions, but otherwise I agree.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$04FV12Rl2Oo2YpiVJAL-J5uKlZSA5PrKGHEP5xqrIZo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712944405697,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$FJBNSuXXxvn9N5mnKiS_77iydbp0GrLwZmgyERgJAkI"},
{"content":{"body":"is there any post which captures your thoughts on yield? it's been a little hard for me to follow the threads given their length","m.mentions":{},"msgtype":"m.text"},"ts":1712944409334,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$GZtvgZz4UByP6lM3c9-mx2iVC05b2LnDEnRCrXl8S6k"},
{"content":{"body":"I don't really use generators, so I don't have particularly strong feelings on yield, beyond recognizing that that's at least a small handful of people who seem to want to be able to observe the calling context somehow or other.  My bigger concern is repeated callbacks, which I think are a little easier to reason about.","m.mentions":{},"msgtype":"m.text"},"ts":1712944533279,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$h3nUmmduPLoMODvrLOza0Y_Q2KPCDLdrgvYa44_sAKc"},
{"content":{"body":"on yield, it seems like the biggest users in frameworks would actually *benefit* from these semantics because they end up using yield as a replacement for await","format":"org.matrix.custom.html","formatted_body":"on yield, it seems like the biggest users in frameworks would actually <em>benefit</em> from these semantics because they end up using yield as a replacement for await","m.mentions":{},"msgtype":"m.text"},"ts":1712944571613,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$G_peJ0cOIZC3_CntshZ2mx0KEvQHBkesJZ0ItoxjJIY"},
{"content":{"body":"but I like focusing on the concrete and want to understand more about your thoughts on callbacks","m.mentions":{},"msgtype":"m.text"},"ts":1712944605714,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$qDON-8doFlBubxutjfq_SDeKTpWOaWI38gWGt7yRV1k"},
{"content":{"body":"I _think_ yield-as-await already gets the right behavior automatically based on how promises work.","format":"org.matrix.custom.html","formatted_body":"I <em>think</em> yield-as-await already gets the right behavior automatically based on how promises work.","m.mentions":{},"msgtype":"m.text"},"ts":1712944609925,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$sZN-xRbdnfdkzNpkjJeHbs0P0AsY5t_t5zVhM0ley5M"},
{"content":{"body":"> <@stephenhicks:matrix.org> I _think_ yield-as-await already gets the right behavior automatically based on how promises work.\n\nthere's a tiny leak when it comes to thenables... but I think if you want the other behavior you're doing it wrong","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$sZN-xRbdnfdkzNpkjJeHbs0P0AsY5t_t5zVhM0ley5M?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I <em>think</em> yield-as-await already gets the right behavior automatically based on how promises work.</blockquote></mx-reply>there's a tiny leak when it comes to thenables... but I think if you want the other behavior you're doing it wrong","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$sZN-xRbdnfdkzNpkjJeHbs0P0AsY5t_t5zVhM0ley5M"}},"msgtype":"m.text"},"ts":1712944635008,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$qeu8lEEXU485Fchq5gIMoRvjifziA-FvmAgoyw5rVzw"},
{"content":{"body":"(but I haven't thought through the details)","m.mentions":{},"msgtype":"m.text"},"ts":1712944635771,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$ts_aW59fNkYWE-iz8EM8ZwSMLYppw4CtQjazJfcOcP4"},
{"content":{"body":"What I've heard is, Koa doesn't force a Promise.resolve the way native await does, and that's where the difference comes from","m.mentions":{},"msgtype":"m.text"},"ts":1712944674546,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$TiVogktjS-ZJ2rHJFU4v6S2uTuNwAm7HoUWf6Pz39B8"},
{"content":{"body":"For repeated callbacks, it's common to register handlers or data producer graphs at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for _each_ iniating circumstance, rather than the (empty) app-init context.","format":"org.matrix.custom.html","formatted_body":"For repeated callbacks, it's common to register handlers or data producer graphs at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for <em>each</em> iniating circumstance, rather than the (empty) app-init context.","m.mentions":{},"msgtype":"m.text"},"ts":1712944761818,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Ubs78a6Ld9IYjcxCL2gEADHor1jIL_TwJXheCrqQZJc"},
{"content":{"body":" * For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for _each_ iniating circumstance, rather than the (empty) app-init context.","format":"org.matrix.custom.html","formatted_body":" * For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for <em>each</em> iniating circumstance, rather than the (empty) app-init context.","m.mentions":{},"m.new_content":{"body":"For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for _each_ iniating circumstance, rather than the (empty) app-init context.","format":"org.matrix.custom.html","formatted_body":"For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for <em>each</em> iniating circumstance, rather than the (empty) app-init context.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Ubs78a6Ld9IYjcxCL2gEADHor1jIL_TwJXheCrqQZJc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712944778743,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$elbD21vYQMwRsb9h5kaUaYMaAvaicyuFkGyYx_6ew9E"},
{"content":{"body":"> <@stephenhicks:matrix.org> For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for _each_ iniating circumstance, rather than the (empty) app-init context.\n\ndo you think that events should have registration-time semantics for things that are expected to be one-use, i.e. `loadend` on XHR?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$Ubs78a6Ld9IYjcxCL2gEADHor1jIL_TwJXheCrqQZJc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for <em>each</em> iniating circumstance, rather than the (empty) app-init context.</blockquote></mx-reply>do you think that events should have registration-time semantics for things that are expected to be one-use, i.e. <code>loadend</code> on XHR?","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Ubs78a6Ld9IYjcxCL2gEADHor1jIL_TwJXheCrqQZJc"}},"msgtype":"m.text"},"ts":1712944837431,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$NjczyTiBjVuNp1K23oE4xu-wQuXbx_aiqIfbhIqsCh8"},
{"content":{"body":"you can use a single `XMLHttpRequest` object for multiple fetches, but I don't think most uses do that","format":"org.matrix.custom.html","formatted_body":"you can use a single <code>XMLHttpRequest</code> object for multiple fetches, but I don't think most uses do that","m.mentions":{},"msgtype":"m.text"},"ts":1712944876937,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$LnS18sQI2m8rzLNU1vafhMlVnoYHjWhenlApgKVW7iA"},
{"content":{"body":"More concretely, we have an internal framework that writes code like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      return item.clone().setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":"<p>More concretely, we have an internal framework that writes code like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      return item.clone().setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712945357800,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$1yc6h_I-9Ops-nBHlAWu8kJA3APe6NtycWOR3hFaZf0"},
{"content":{"body":"(is this the same internal framework that Jatin works on?)","m.mentions":{},"msgtype":"m.text"},"ts":1712945404268,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9V3JDXonyqvQ0H7zlKFbTnH_O6eECtu_rCRB8BUMFZA"},
{"content":{"body":"My understanding is that this sort of loosely-coupled data binding is common in external frameworks as well.  Yes, it's the same.","m.mentions":{},"msgtype":"m.text"},"ts":1712945426067,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$yhiHLSUQ47wWlt_VhSN2om_RSqst8gUBCeHeQ0EbjsE"},
{"content":{"body":"hey how do people feel about getting a logo for AsyncContext like we have for Signals? https://github.com/tc39/proposal-signals/blob/main/signals-logo.png","m.mentions":{},"msgtype":"m.text"},"ts":1712945458047,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_iRoqfbOmYCB2Dtik_u66Sr9TUc0iJkfIwaOruym1Ik"},
{"content":{"body":"I can ask my friend who did the other one if he could do this too","m.mentions":{},"msgtype":"m.text"},"ts":1712945476363,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$VJT4KSofyGTMrCR1hbbbpHyvTWh3sFe4nF4Ra_LkW3Q"},
{"content":{"body":"somehow logos make it easier to talk about things, sometimes","m.mentions":{},"msgtype":"m.text"},"ts":1712945499171,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$wHJPYhJvhKsavKUoB21ysyFIQPlLt2zN1VzmWuBdzTQ"},
{"content":{"body":" * More concretely, we have an internal framework that writes code like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":" * <p>More concretely, we have an internal framework that writes code like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"m.new_content":{"body":"More concretely, we have an internal framework that writes code like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":"<p>More concretely, we have an internal framework that writes code like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$1yc6h_I-9Ops-nBHlAWu8kJA3APe6NtycWOR3hFaZf0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712946006854,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$IfpEToFip6EcDNUq4AGtSJVsr3A02Ex_6Xov5ZRWToY"},
{"content":{"body":" * More concretely, we have an internal framework that writes code (very roughly) like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":" * <p>More concretely, we have an internal framework that writes code (very roughly) like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"m.new_content":{"body":"More concretely, we have an internal framework that writes code (very roughly) like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":"<p>More concretely, we have an internal framework that writes code (very roughly) like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$1yc6h_I-9Ops-nBHlAWu8kJA3APe6NtycWOR3hFaZf0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712946045725,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$pCe62GApR4bUptoNr2FxHRysisD-HoVZviB9o5fcazI"},
{"content":{"body":" * More concretely, we have an internal framework that writes code (very roughly) like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\n// in a totally different file:\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":" * <p>More concretely, we have an internal framework that writes code (very roughly) like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\n// in a totally different file:\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"m.new_content":{"body":"More concretely, we have an internal framework that writes code (very roughly) like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\n// in a totally different file:\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":"<p>More concretely, we have an internal framework that writes code (very roughly) like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\n// in a totally different file:\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$1yc6h_I-9Ops-nBHlAWu8kJA3APe6NtycWOR3hFaZf0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712946070081,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$-d4jMWlRRkfp7bStEx8KaGPeCVIPiXIjxkabn0_QK84"},
{"content":{"body":"I need to better understand the concern about `using` and an async context scope. As I understand it, even with `[Symbol.enter]` you're concerned it's possible exit the function without exiting the scope?","format":"org.matrix.custom.html","formatted_body":"I need to better understand the concern about <code>using</code> and an async context scope. As I understand it, even with <code>[Symbol.enter]</code> you're concerned it's possible exit the function without exiting the scope?","m.mentions":{},"msgtype":"m.text"},"ts":1712947313971,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zYUUSX9QOP6eJgizvbIRaOGyn3f6Q4p8Gig2dqjzmdM"},
{"content":{"body":"> <@rbuckton:matrix.org> I need to better understand the concern about `using` and an async context scope. As I understand it, even with `[Symbol.enter]` you're concerned it's possible exit the function without exiting the scope?\n\nthe concern is that buggy (or malicious) code that calls `[Symbol.enter]` but not `[Symbol.dispose]` would change the context available when the function returns","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$zYUUSX9QOP6eJgizvbIRaOGyn3f6Q4p8Gig2dqjzmdM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I need to better understand the concern about <code>using</code> and an async context scope. As I understand it, even with <code>[Symbol.enter]</code> you're concerned it's possible exit the function without exiting the scope?</blockquote></mx-reply>the concern is that buggy (or malicious) code that calls <code>[Symbol.enter]</code> but not <code>[Symbol.dispose]</code> would change the context available when the function returns","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zYUUSX9QOP6eJgizvbIRaOGyn3f6Q4p8Gig2dqjzmdM"}},"msgtype":"m.text"},"ts":1712947592131,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$AsCoARONTBdY6Z3nwqBtwzjdNVCFDBQ-eTlVWQ6C2Oc"},
{"content":{"body":"currently in the AsyncContext proposal there's no way to change the context in the middle of a function execution","m.mentions":{},"msgtype":"m.text"},"ts":1712947613482,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$cL6VIot8T7V4mKO2j7tyQHvfSnUDrHpns-qnBUnBhko"},
{"content":{"body":"and I think this was a design goal, which is why we didn't adopt `AsyncLocalStorage`'s `enterWith`","format":"org.matrix.custom.html","formatted_body":"and I think this was a design goal, which is why we didn't adopt <code>AsyncLocalStorage</code>'s <code>enterWith</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712947642293,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$4Dl_gptxRtNhDfqeu0VEk9o6Sh_nbY4Eickn_IsSA88"},
{"content":{"body":"How does this:\n\n```js\nfunction f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n```\n\ndiffer from this:\n\n```js\nfunction f() {\n  let result;\n  function* g(cb) {\n    using scope = new AsyncContext.Scope();\n    result = cb();\n    yield;\n  }\n  g().next();\n  return result;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>How does this:</p>\n<pre><code class=\"language-js\">function f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n</code></pre>\n<p>differ from this:</p>\n<pre><code class=\"language-js\">function f() {\n  let result;\n  function* g(cb) {\n    using scope = new AsyncContext.Scope();\n    result = cb();\n    yield;\n  }\n  g().next();\n  return result;\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712947678043,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NnpK9Yl4K1VCQY8u-cOzLeh4CDa4j7SuoKRvdQPIGI4"},
{"content":{"body":"That would also result in a dangling scope, even with some kind of more comprehensive enforcement of `using`","format":"org.matrix.custom.html","formatted_body":"That would also result in a dangling scope, even with some kind of more comprehensive enforcement of <code>using</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712947732543,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9xN6d03CMR-vx6pvI_XO8YkVK445ND8PorXd5L0nROQ"},
{"content":{"body":" * How does this:\n\n```js\nfunction f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n```\n\ndiffer from this:\n\n```js\nfunction f() {\n  function* g() {\n    using scope = new AsyncContext.Scope();\n    // do work\n    yield;\n  }\n  g().next();\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>How does this:</p>\n<pre><code class=\"language-js\">function f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n</code></pre>\n<p>differ from this:</p>\n<pre><code class=\"language-js\">function f() {\n  function* g() {\n    using scope = new AsyncContext.Scope();\n    // do work\n    yield;\n  }\n  g().next();\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"How does this:\n\n```js\nfunction f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n```\n\ndiffer from this:\n\n```js\nfunction f() {\n  function* g() {\n    using scope = new AsyncContext.Scope();\n    // do work\n    yield;\n  }\n  g().next();\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>How does this:</p>\n<pre><code class=\"language-js\">function f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n</code></pre>\n<p>differ from this:</p>\n<pre><code class=\"language-js\">function f() {\n  function* g() {\n    using scope = new AsyncContext.Scope();\n    // do work\n    yield;\n  }\n  g().next();\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$NnpK9Yl4K1VCQY8u-cOzLeh4CDa4j7SuoKRvdQPIGI4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712947818246,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yIjh-3kjN3-VMEy14aNauiUC8ipYgZx_rec3JuXM7P0"},
{"content":{"body":"the current scope text switches the context when generators are paused and restored – there's still discussion about whether this is the right behavior, but that would take care of that","m.mentions":{},"msgtype":"m.text"},"ts":1712947826977,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$elC7wkTLwTGACgyAPAKsw4d0qUGOqY7tQgS56jqAtPI"},
{"content":{"body":"yeah, neither of those is acceptable, that's the thing","m.mentions":{},"msgtype":"m.text"},"ts":1712947831093,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$BvxVVAoQw3RuGh5rXfooKxJAFzACguELAmMjLBHo33M"},
{"content":{"body":"the current API is based on `.run(cb)` instead","format":"org.matrix.custom.html","formatted_body":"the current API is based on <code>.run(cb)</code> instead","m.mentions":{},"msgtype":"m.text"},"ts":1712947842752,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$dDDjGcQ4s3fpxmUVm-4VcsI7MChVyrSNIYjRkAfVzTA"},
{"content":{"body":"If failing to exit the scope is unacceptable, then there's no way to achieve that kind of enforcement with `using`","format":"org.matrix.custom.html","formatted_body":"If failing to exit the scope is unacceptable, then there's no way to achieve that kind of enforcement with <code>using</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712947883490,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gj1yQjGXiGodF3qLmF9C6Xjs9puaKcbDsvwR33Da_KQ"},
{"content":{"body":"I guess the fact that AsyncContext *can* switch the scope for generators is a thing that no other use cases could do, so maybe that doesn't apply more generally","format":"org.matrix.custom.html","formatted_body":"I guess the fact that AsyncContext <em>can</em> switch the scope for generators is a thing that no other use cases could do, so maybe that doesn't apply more generally","m.mentions":{},"msgtype":"m.text"},"ts":1712947938517,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$_YRjIpi_7jMBJg5PrK5Z2NqhKOSYDuzbFQgQHCkYoBQ"},
{"content":{"body":"Async functions would also result in a dangling scope\n```js\nasync function f(p) {\n  using scope = new AsyncContext.Scope();\n  // do work\n  await p;\n}\n\nconst { promise, resolve } = Promise.withResolves();\nf(p);\n// never call resolve()\n```","format":"org.matrix.custom.html","formatted_body":"<p>Async functions would also result in a dangling scope</p>\n<pre><code class=\"language-js\">async function f(p) {\n  using scope = new AsyncContext.Scope();\n  // do work\n  await p;\n}\n\nconst { promise, resolve } = Promise.withResolves();\nf(p);\n// never call resolve()\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712947973045,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TtgT9PV4W0-tKxmI6YOyabtpBctXsWVXcbDj1j5qEzw"},
{"content":{"body":" * I guess the fact that AsyncContext _can_ switch the scope for generators is a thing that no userland use cases could do, so maybe that doesn't apply more generally","format":"org.matrix.custom.html","formatted_body":" * I guess the fact that AsyncContext <em>can</em> switch the scope for generators is a thing that no userland use cases could do, so maybe that doesn't apply more generally","m.mentions":{},"m.new_content":{"body":"I guess the fact that AsyncContext _can_ switch the scope for generators is a thing that no userland use cases could do, so maybe that doesn't apply more generally","format":"org.matrix.custom.html","formatted_body":"I guess the fact that AsyncContext <em>can</em> switch the scope for generators is a thing that no userland use cases could do, so maybe that doesn't apply more generally","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_YRjIpi_7jMBJg5PrK5Z2NqhKOSYDuzbFQgQHCkYoBQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712947974325,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$CDXCGBED_N_y3pImzxuhOvE-l13fTOe2rowB63mmy98"},
{"content":{"body":"This leads me to believe that `AsyncContext.Scope` isn't viable.","format":"org.matrix.custom.html","formatted_body":"This leads me to believe that <code>AsyncContext.Scope</code> isn't viable.","m.mentions":{},"msgtype":"m.text"},"ts":1712948092527,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc"},
{"content":{"body":"a different thing in the space of `using` could hypothetically solve this problem--maybe more along the lines of what you described Python can do in `with`.","format":"org.matrix.custom.html","formatted_body":"a different thing in the space of <code>using</code> could hypothetically solve this problem--maybe more along the lines of what you described Python can do in <code>with</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1712948121142,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$jqGnLNdYEkvUMrfl4K-TxeiufM92aOixcF_u0v36X3w"},
{"content":{"body":"not that we need that, but the name of the proposal kinda feels like a tease, *almost* getting us there","format":"org.matrix.custom.html","formatted_body":"not that we need that, but the name of the proposal kinda feels like a tease, <em>almost</em> getting us there","m.mentions":{},"msgtype":"m.text"},"ts":1712948145977,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$1vt2q5oimBblY0XnNsQQVhfwp4037rcOjL2UCmCvNT4"},
{"content":{"body":"Python's `with` would have the exact same issues. ","format":"org.matrix.custom.html","formatted_body":"Python's <code>with</code> would have the exact same issues.","m.mentions":{},"msgtype":"m.text"},"ts":1712948155928,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2XnJuMS-aeg6qwwc8b35kopx75VkgXeXigczL9Y6j1M"},
{"content":{"body":"> <@rbuckton:matrix.org> This leads me to believe that `AsyncContext.Scope` isn't viable.\n\nI think it would be viable, because AsyncContext needs to integrate with generator resuming and promise continuations. But maybe similar use cases implemented in userland could not.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>This leads me to believe that <code>AsyncContext.Scope</code> isn't viable.</blockquote></mx-reply>I think it would be viable, because AsyncContext needs to integrate with generator resuming and promise continuations. But maybe similar use cases implemented in userland could not.","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc"}},"msgtype":"m.text"},"ts":1712948158225,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$7f9sBYNC-FF4QfMg7qi8u8VrgvpTm5CNyBunuNguzyQ"},
{"content":{"body":"And I'm not necessarily willing to ask for the strict `using` enforcement proposal to change to fit use cases which are limited to spec proposals","format":"org.matrix.custom.html","formatted_body":"And I'm not necessarily willing to ask for the strict <code>using</code> enforcement proposal to change to fit use cases which are limited to spec proposals","m.mentions":{},"msgtype":"m.text"},"ts":1712948198727,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$fl9jQUXN0IXdsxpeAVtsDZiNJU7WFGWyQLfjggcBoIo"},
{"content":{"body":"in the extreme case: if `using` was passed the delimited continuation as an argument...","format":"org.matrix.custom.html","formatted_body":"in the extreme case: if <code>using</code> was passed the delimited continuation as an argument...","m.mentions":{},"msgtype":"m.text"},"ts":1712948203511,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$clvlia933s4KK49Bx1IzOIZMUIr62oDrTRSkbtyDaiA"},
{"content":{"body":" * And I'm not willing to ask for the strict `using` enforcement proposal to change to fit use cases which are limited to spec proposals","format":"org.matrix.custom.html","formatted_body":" * And I'm not willing to ask for the strict <code>using</code> enforcement proposal to change to fit use cases which are limited to spec proposals","m.mentions":{},"m.new_content":{"body":"And I'm not willing to ask for the strict `using` enforcement proposal to change to fit use cases which are limited to spec proposals","format":"org.matrix.custom.html","formatted_body":"And I'm not willing to ask for the strict <code>using</code> enforcement proposal to change to fit use cases which are limited to spec proposals","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$fl9jQUXN0IXdsxpeAVtsDZiNJU7WFGWyQLfjggcBoIo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712948206887,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$ME7N6_bnZOQfqbemw06CbftaEoyBX1Bw65uhZ5cRjSw"},
{"content":{"body":"> <@rbuckton:matrix.org> This leads me to believe that `AsyncContext.Scope` isn't viable.\n\nI think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as _before_ the Scope is entered.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>This leads me to believe that <code>AsyncContext.Scope</code> isn't viable.</blockquote></mx-reply>I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as <em>before</em> the Scope is entered.","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc"}},"msgtype":"m.text"},"ts":1712948297150,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$lVzwyhK8RSZBm-yZq5ea_tSAqimAkOsoS_vnepmm1w8"},
{"content":{"body":"> <@littledan:matrix.org> in the extreme case: if `using` was passed the delimited continuation as an argument...\n\nI don't see how this wouldn't be significantly worse.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$clvlia933s4KK49Bx1IzOIZMUIr62oDrTRSkbtyDaiA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>in the extreme case: if <code>using</code> was passed the delimited continuation as an argument...</blockquote></mx-reply>I don't see how this wouldn't be significantly worse.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$clvlia933s4KK49Bx1IzOIZMUIr62oDrTRSkbtyDaiA"}},"msgtype":"m.text"},"ts":1712948300383,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VyE2um579d7GKaUKj0L85m_yrkvTojxv6a7-a5cCcDI"},
{"content":{"body":"> <@rbuckton:matrix.org> I don't see how this wouldn't be significantly worse.\n\nit would solve the problem that Andreu is talking about, while also, yes, being a crazy thing that we definitely shouldn't do","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$VyE2um579d7GKaUKj0L85m_yrkvTojxv6a7-a5cCcDI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I don't see how this wouldn't be significantly worse.</blockquote></mx-reply>it would solve the problem that Andreu is talking about, while also, yes, being a crazy thing that we definitely shouldn't do","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$VyE2um579d7GKaUKj0L85m_yrkvTojxv6a7-a5cCcDI"}},"msgtype":"m.text"},"ts":1712948329194,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9Wh06KJT8cpWpIgEvXAocVO4ZZWYSi6mrsGuP_9jjHU"},
{"content":{"body":"the design of `.run(cb)` forces you to extract the delimited continuation manually","format":"org.matrix.custom.html","formatted_body":"the design of <code>.run(cb)</code> forces you to extract the delimited continuation manually","m.mentions":{},"msgtype":"m.text"},"ts":1712948348845,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$IUb8RSegevf94-34ddyanrY2RukZ6Hcqyk1L6UOU1do"},
{"content":{"body":"> <@rbuckton:matrix.org> This leads me to believe that `AsyncContext.Scope` isn't viable.\n\n * I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as _before_ the Scope is entered.  Specifically, it would _not_ mutate the current context.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>This leads me to believe that <code>AsyncContext.Scope</code> isn't viable.</blockquote></mx-reply> * I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as <em>before</em> the Scope is entered.  Specifically, it would <em>not</em> mutate the current context.","m.mentions":{},"m.new_content":{"body":"I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as _before_ the Scope is entered.  Specifically, it would _not_ mutate the current context.","format":"org.matrix.custom.html","formatted_body":"I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as <em>before</em> the Scope is entered.  Specifically, it would <em>not</em> mutate the current context.","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$lVzwyhK8RSZBm-yZq5ea_tSAqimAkOsoS_vnepmm1w8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712948352297,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$KKVbhzD8nhdUj4Mj39kzJaGFZ5xwlb4TWrC_2j8wRzA"},
{"content":{"body":"Where I see a problem is\n```\n{\n  using scope = new AsyncContext.Scope();\n  // ...\n  const innerScope =  new AsyncContext.Scope();\n  innerScope[Symbol.enter]();\n  // ...\n}\n// what happens to vars set on innerScope?\ninnerScope[Symbol.dispose]();\n// what happens now?","format":"org.matrix.custom.html","formatted_body":"<p>Where I see a problem is</p>\n<pre><code>{\n  using scope = new AsyncContext.Scope();\n  // ...\n  const innerScope =  new AsyncContext.Scope();\n  innerScope[Symbol.enter]();\n  // ...\n}\n// what happens to vars set on innerScope?\ninnerScope[Symbol.dispose]();\n// what happens now?\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712948479675,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$CMbFUqMC01QYnoKVOhOwHy45obhSgp-HpnJuChUoIZ0"},
{"content":{"body":"if you were to treat this like a stack, as `run(cb)` would do, I would expect `innerScope` to be on top of the stack, and when `scope` is disposed it should throw if it's not on the top of the stack.","format":"org.matrix.custom.html","formatted_body":"if you were to treat this like a stack, as <code>run(cb)</code> would do, I would expect <code>innerScope</code> to be on top of the stack, and when <code>scope</code> is disposed it should throw if it's not on the top of the stack.","m.mentions":{},"msgtype":"m.text"},"ts":1712948570273,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PLFnr9Od5k8ZHRi8sI60QBxBPXSiSAnWjHOHaRHYtP4"},
{"content":{"body":"> <@stephenhicks:matrix.org> Where I see a problem is\n> ```\n> {\n>   using scope = new AsyncContext.Scope();\n>   // ...\n>   const innerScope =  new AsyncContext.Scope();\n>   innerScope[Symbol.enter]();\n>   // ...\n> }\n> // what happens to vars set on innerScope?\n> innerScope[Symbol.dispose]();\n> // what happens now?\n\nI think this could be worked around by keeping the scope depth and invalidating `innerScope` if `scope` has been disposed. But I'm not sure at this point if this would work for async functions and generators","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$CMbFUqMC01QYnoKVOhOwHy45obhSgp-HpnJuChUoIZ0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>Where I see a problem is</p>\n<pre><code>{\n  using scope = new AsyncContext.Scope();\n  // ...\n  const innerScope =  new AsyncContext.Scope();\n  innerScope[Symbol.enter]();\n  // ...\n}\n// what happens to vars set on innerScope?\ninnerScope[Symbol.dispose]();\n// what happens now?\n</code></pre>\n</blockquote></mx-reply>I think this could be worked around by keeping the scope depth and invalidating <code>innerScope</code> if <code>scope</code> has been disposed. But I'm not sure at this point if this would work for async functions and generators","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$CMbFUqMC01QYnoKVOhOwHy45obhSgp-HpnJuChUoIZ0"}},"msgtype":"m.text"},"ts":1712948588687,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$IT7cNOf-HPwr32tw3NRJU3iJwm4pM1LAQwBwJm50tKg"},
{"content":{"body":"Do you have to keep track of when you enter or exit a function with `run()`?","format":"org.matrix.custom.html","formatted_body":"Do you have to keep track of when you enter or exit a function with <code>run()</code>?","m.mentions":{},"msgtype":"m.text"},"ts":1712948663758,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$I5uG9D9ZsV82cvx0fZzwkntBvWNJ0_oNTIGzvOgx4w4"},
{"content":{"body":"No","msgtype":"m.text"},"ts":1712948692755,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$h9mOE_tGBHz_FCydPuCY8sEAPJXZc4Zyq2a1xQARzDc"},
{"content":{"body":"Run enters, invokes the cb, then exits. It can’t leave a dirty stack.","msgtype":"m.text"},"ts":1712948723690,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$pr7LmNqvTB5Wjz2CHkvdWq1oa6H2D3VVSmrjD8ivTTU"}
]