[
{"content":{"body":"> <@littledan:matrix.org> we have to have this conversation with Steven and Signals people about Computed's context -- there's a concern that call-time context there would constitute \"Zalgo\": a computed signal could be forced in many different ways, and it should be giving the same answer regardless of context (of course we need some debugging/perf analysis tools to be possible)\n\nI agree that there's definite problems with computed signals - it's possible that two setters feed into the same computed signal and could have been set in different contexts, plus the fact that they're computed lazily might point to the reader's context as the correct call-time context (i.e. coming from the other direction). So there's potentially three or more different options and not necessarily a good way to disambiguate all of them.\n\nThat said, if there's no way to access the context(s) that set the signal(s) that caused the recompute, then tracing in many UI frameworks is essentially sunk. In my experience, it's a _very_ common pattern to have an event handler do nothing but update a signal. If the tracing framework initiates a trace in the event handler then the trace would simply die then and there, whereas we'd like to be able to link that trace to any downstream reactions/effects, all the way to the re-render.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rorB792EDNX34EdSfB9td7vBuxOAeqgNiPuJLANCVPg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />we have to have this conversation with Steven and Signals people about Computed's context -- there's a concern that call-time context there would constitute &quot;Zalgo&quot;: a computed signal could be forced in many different ways, and it should be giving the same answer regardless of context (of course we need some debugging/perf analysis tools to be possible)</blockquote></mx-reply><p>I agree that there's definite problems with computed signals - it's possible that two setters feed into the same computed signal and could have been set in different contexts, plus the fact that they're computed lazily might point to the reader's context as the correct call-time context (i.e. coming from the other direction). So there's potentially three or more different options and not necessarily a good way to disambiguate all of them.</p>\n<p>That said, if there's no way to access the context(s) that set the signal(s) that caused the recompute, then tracing in many UI frameworks is essentially sunk. In my experience, it's a <em>very</em> common pattern to have an event handler do nothing but update a signal. If the tracing framework initiates a trace in the event handler then the trace would simply die then and there, whereas we'd like to be able to link that trace to any downstream reactions/effects, all the way to the re-render.</p>","m.relates_to":{"m.in_reply_to":{"event_id":"$rorB792EDNX34EdSfB9td7vBuxOAeqgNiPuJLANCVPg"}},"msgtype":"m.text"},"ts":1712893000862,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$23-3PdqSmo1N_BD8c1PZwPS1aES-blPqladV_bfziFQ"},
{"content":{"body":"I see... so in this case, it's like application state should be registration-based, but tracing state should be call-based... :(","m.mentions":{},"msgtype":"m.text"},"ts":1712927930479,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kE5oQXK-3M9cbgsWqIfRihrtCU41AVsnyMoxLQd_9AY"},
{"content":{"body":"What's an example of application state that you'd want to be registration-based? My general (but somewhat uninformed) rule-of-thumb is that if a callback is intended to be called multiple times, it's more likely to want call-time context.","msgtype":"m.text"},"ts":1712930842429,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$BgDZfxiY_v4YXlVU2UZYZpMNiUkSbJ8XI6PW-y_pmP0"},
{"content":{"body":"an example is if we wanted to use AsyncContext for tracking the owner in tree-based rendering, or generally, React Context-style information","m.mentions":{},"msgtype":"m.text"},"ts":1712931085433,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$cMdE81CQo6ATf2f1izMg747v2V26_ntTRuI3mWGPWi0"},
{"content":{"body":"we could use AsyncContext.Snapshot.wrap for these cases but then it'd defeat tracing, sounds like...","m.mentions":{},"msgtype":"m.text"},"ts":1712931107156,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XiKT3nwRc12DJ1dFMQEbI4HJiuLe2YPdFg41pqTlJ1w"},
{"content":{"body":"also for the style of React Hooks using global variables under the hood","m.mentions":{},"msgtype":"m.text"},"ts":1712931150073,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ioTpyO6FdM_-BDFy3BYIkG4_Vm9T4Tl7oIIz_3Z-n84"},
{"content":{"body":"restoring the context after await is an example of registration-time behavior I think","m.mentions":{},"msgtype":"m.text"},"ts":1712931197483,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$FzPcfpAMdePaRzt_lwn7CcpEcA028ecnhtFFEsFFCOs"},
{"content":{"body":"(especially obvious if you consider what explicit calls of .then() should do)","m.mentions":{},"msgtype":"m.text"},"ts":1712931214319,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$V6P2rvliLM9uOjCkcPt4C1MX1KuMYA1ltZ1wmYCj5HA"},
{"content":{"body":"That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot.","format":"org.matrix.custom.html","formatted_body":"That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot.","m.mentions":{},"msgtype":"m.text"},"ts":1712942510924,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA"},
{"content":{"body":" * That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot on reentry","format":"org.matrix.custom.html","formatted_body":" * That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot on reentry","m.mentions":{},"m.new_content":{"body":"That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot on reentry","format":"org.matrix.custom.html","formatted_body":"That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot on reentry","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712942958120,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$rJDW0gTEw7KxpnvaUUFHwOIXGCG1jzm3kL9LoLWgJOM"},
{"content":{"body":"> <@stephenhicks:matrix.org> That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot on reentry\n\nJustin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot on reentry</blockquote></mx-reply>Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA"}},"msgtype":"m.text"},"ts":1712944255096,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hpD38YcJDfOpLVKTsFpsatmT1I8ygRID6AfRBH2SPJ4"},
{"content":{"body":"> <@stephenhicks:matrix.org> That's a good point about `await`.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be _preserved_ across an `await`, rather than _restored_ to some particular snapshot on reentry\n\n * Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await or yield\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$WXAkAX7lHwvwUabF5ZBn_hfvQFI9enR1Qsb48N7BKaA?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>That's a good point about <code>await</code>.  I brought it up in the context of async generators in https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2048897179 - I think my general expectation is that context needs to be <em>preserved</em> across an <code>await</code>, rather than <em>restored</em> to some particular snapshot on reentry</blockquote></mx-reply> * Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await or yield\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","m.mentions":{},"m.new_content":{"body":"Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await or yield\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","format":"org.matrix.custom.html","formatted_body":"Justin keeps talking about \"restoring to the initial snapshot\" but I've always been thinking about the semantics as \"preserving the one that was right before the await or yield\" (that's my mental model for AsyncContext in general). In the end, there isn't an observable difference between them, though.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$hpD38YcJDfOpLVKTsFpsatmT1I8ygRID6AfRBH2SPJ4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712944289086,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$gKSk8XoWsIDmWcFStJDt6cSYMbnOY278y01zZhHzj1w"},
{"content":{"body":"well, with a disposable there would be","m.mentions":{},"msgtype":"m.text"},"ts":1712944290272,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$rwSBkLQQYJ4Wajyrm7LSy_3KTysfvQ_5Yaiwz6PtY2k"},
{"content":{"body":" * well, with a disposable there would be a difference","m.mentions":{},"m.new_content":{"body":"well, with a disposable there would be a difference","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rwSBkLQQYJ4Wajyrm7LSy_3KTysfvQ_5Yaiwz6PtY2k","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712944304533,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$ltqdFwgsKwDQofdiJS3h4QT_r2QZjJpKELBm5Isr4Vc"},
{"content":{"body":"right, if we had some flat way of doing `run` within a function, I'd *definitely* want the semantics to be, preserve what was before the await/yield; I don't see any argument for \"restore the one at function entry\"","format":"org.matrix.custom.html","formatted_body":"right, if we had some flat way of doing <code>run</code> within a function, I'd <em>definitely</em> want the semantics to be, preserve what was before the await/yield; I don't see any argument for \"restore the one at function entry\"","m.mentions":{},"msgtype":"m.text"},"ts":1712944342666,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$EE4J65daW7UNc3n3A2G9kSxb90Z8IlVGtD7gobAF0aw"},
{"content":{"body":"I think await and yield are maybe separate questions, but otherwise I agree.","m.mentions":{},"msgtype":"m.text"},"ts":1712944378945,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$04FV12Rl2Oo2YpiVJAL-J5uKlZSA5PrKGHEP5xqrIZo"},
{"content":{"body":" * I think await and yield are _maybe_ separate questions, but otherwise I agree.","format":"org.matrix.custom.html","formatted_body":" * I think await and yield are <em>maybe</em> separate questions, but otherwise I agree.","m.mentions":{},"m.new_content":{"body":"I think await and yield are _maybe_ separate questions, but otherwise I agree.","format":"org.matrix.custom.html","formatted_body":"I think await and yield are <em>maybe</em> separate questions, but otherwise I agree.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$04FV12Rl2Oo2YpiVJAL-J5uKlZSA5PrKGHEP5xqrIZo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712944405697,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$FJBNSuXXxvn9N5mnKiS_77iydbp0GrLwZmgyERgJAkI"},
{"content":{"body":"is there any post which captures your thoughts on yield? it's been a little hard for me to follow the threads given their length","m.mentions":{},"msgtype":"m.text"},"ts":1712944409334,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$GZtvgZz4UByP6lM3c9-mx2iVC05b2LnDEnRCrXl8S6k"},
{"content":{"body":"I don't really use generators, so I don't have particularly strong feelings on yield, beyond recognizing that that's at least a small handful of people who seem to want to be able to observe the calling context somehow or other.  My bigger concern is repeated callbacks, which I think are a little easier to reason about.","m.mentions":{},"msgtype":"m.text"},"ts":1712944533279,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$h3nUmmduPLoMODvrLOza0Y_Q2KPCDLdrgvYa44_sAKc"},
{"content":{"body":"on yield, it seems like the biggest users in frameworks would actually *benefit* from these semantics because they end up using yield as a replacement for await","format":"org.matrix.custom.html","formatted_body":"on yield, it seems like the biggest users in frameworks would actually <em>benefit</em> from these semantics because they end up using yield as a replacement for await","m.mentions":{},"msgtype":"m.text"},"ts":1712944571613,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$G_peJ0cOIZC3_CntshZ2mx0KEvQHBkesJZ0ItoxjJIY"},
{"content":{"body":"but I like focusing on the concrete and want to understand more about your thoughts on callbacks","m.mentions":{},"msgtype":"m.text"},"ts":1712944605714,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$qDON-8doFlBubxutjfq_SDeKTpWOaWI38gWGt7yRV1k"},
{"content":{"body":"I _think_ yield-as-await already gets the right behavior automatically based on how promises work.","format":"org.matrix.custom.html","formatted_body":"I <em>think</em> yield-as-await already gets the right behavior automatically based on how promises work.","m.mentions":{},"msgtype":"m.text"},"ts":1712944609925,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$sZN-xRbdnfdkzNpkjJeHbs0P0AsY5t_t5zVhM0ley5M"},
{"content":{"body":"> <@stephenhicks:matrix.org> I _think_ yield-as-await already gets the right behavior automatically based on how promises work.\n\nthere's a tiny leak when it comes to thenables... but I think if you want the other behavior you're doing it wrong","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$sZN-xRbdnfdkzNpkjJeHbs0P0AsY5t_t5zVhM0ley5M?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I <em>think</em> yield-as-await already gets the right behavior automatically based on how promises work.</blockquote></mx-reply>there's a tiny leak when it comes to thenables... but I think if you want the other behavior you're doing it wrong","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$sZN-xRbdnfdkzNpkjJeHbs0P0AsY5t_t5zVhM0ley5M"}},"msgtype":"m.text"},"ts":1712944635008,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$qeu8lEEXU485Fchq5gIMoRvjifziA-FvmAgoyw5rVzw"},
{"content":{"body":"(but I haven't thought through the details)","m.mentions":{},"msgtype":"m.text"},"ts":1712944635771,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$ts_aW59fNkYWE-iz8EM8ZwSMLYppw4CtQjazJfcOcP4"},
{"content":{"body":"What I've heard is, Koa doesn't force a Promise.resolve the way native await does, and that's where the difference comes from","m.mentions":{},"msgtype":"m.text"},"ts":1712944674546,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$TiVogktjS-ZJ2rHJFU4v6S2uTuNwAm7HoUWf6Pz39B8"},
{"content":{"body":"For repeated callbacks, it's common to register handlers or data producer graphs at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for _each_ iniating circumstance, rather than the (empty) app-init context.","format":"org.matrix.custom.html","formatted_body":"For repeated callbacks, it's common to register handlers or data producer graphs at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for <em>each</em> iniating circumstance, rather than the (empty) app-init context.","m.mentions":{},"msgtype":"m.text"},"ts":1712944761818,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Ubs78a6Ld9IYjcxCL2gEADHor1jIL_TwJXheCrqQZJc"},
{"content":{"body":" * For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for _each_ iniating circumstance, rather than the (empty) app-init context.","format":"org.matrix.custom.html","formatted_body":" * For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for <em>each</em> iniating circumstance, rather than the (empty) app-init context.","m.mentions":{},"m.new_content":{"body":"For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for _each_ iniating circumstance, rather than the (empty) app-init context.","format":"org.matrix.custom.html","formatted_body":"For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for <em>each</em> iniating circumstance, rather than the (empty) app-init context.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Ubs78a6Ld9IYjcxCL2gEADHor1jIL_TwJXheCrqQZJc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712944778743,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$elbD21vYQMwRsb9h5kaUaYMaAvaicyuFkGyYx_6ew9E"},
{"content":{"body":"> <@stephenhicks:matrix.org> For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for _each_ iniating circumstance, rather than the (empty) app-init context.\n\ndo you think that events should have registration-time semantics for things that are expected to be one-use, i.e. `loadend` on XHR?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$Ubs78a6Ld9IYjcxCL2gEADHor1jIL_TwJXheCrqQZJc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>For repeated callbacks, it's common to register handlers or data pipelines at application start time.  These callbacks run every time a particular interaction or data flow happens.  There's no meaningful context when they're registered, so it's much more relevant to propagate the call-time context for <em>each</em> iniating circumstance, rather than the (empty) app-init context.</blockquote></mx-reply>do you think that events should have registration-time semantics for things that are expected to be one-use, i.e. <code>loadend</code> on XHR?","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Ubs78a6Ld9IYjcxCL2gEADHor1jIL_TwJXheCrqQZJc"}},"msgtype":"m.text"},"ts":1712944837431,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$NjczyTiBjVuNp1K23oE4xu-wQuXbx_aiqIfbhIqsCh8"},
{"content":{"body":"you can use a single `XMLHttpRequest` object for multiple fetches, but I don't think most uses do that","format":"org.matrix.custom.html","formatted_body":"you can use a single <code>XMLHttpRequest</code> object for multiple fetches, but I don't think most uses do that","m.mentions":{},"msgtype":"m.text"},"ts":1712944876937,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$LnS18sQI2m8rzLNU1vafhMlVnoYHjWhenlApgKVW7iA"},
{"content":{"body":"More concretely, we have an internal framework that writes code like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      return item.clone().setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":"<p>More concretely, we have an internal framework that writes code like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      return item.clone().setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712945357800,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$1yc6h_I-9Ops-nBHlAWu8kJA3APe6NtycWOR3hFaZf0"},
{"content":{"body":"(is this the same internal framework that Jatin works on?)","m.mentions":{},"msgtype":"m.text"},"ts":1712945404268,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9V3JDXonyqvQ0H7zlKFbTnH_O6eECtu_rCRB8BUMFZA"},
{"content":{"body":"My understanding is that this sort of loosely-coupled data binding is common in external frameworks as well.  Yes, it's the same.","m.mentions":{},"msgtype":"m.text"},"ts":1712945426067,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$yhiHLSUQ47wWlt_VhSN2om_RSqst8gUBCeHeQ0EbjsE"},
{"content":{"body":"hey how do people feel about getting a logo for AsyncContext like we have for Signals? https://github.com/tc39/proposal-signals/blob/main/signals-logo.png","m.mentions":{},"msgtype":"m.text"},"ts":1712945458047,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_iRoqfbOmYCB2Dtik_u66Sr9TUc0iJkfIwaOruym1Ik"},
{"content":{"body":"I can ask my friend who did the other one if he could do this too","m.mentions":{},"msgtype":"m.text"},"ts":1712945476363,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$VJT4KSofyGTMrCR1hbbbpHyvTWh3sFe4nF4Ra_LkW3Q"},
{"content":{"body":"somehow logos make it easier to talk about things, sometimes","m.mentions":{},"msgtype":"m.text"},"ts":1712945499171,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$wHJPYhJvhKsavKUoB21ysyFIQPlLt2zN1VzmWuBdzTQ"},
{"content":{"body":" * More concretely, we have an internal framework that writes code like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":" * <p>More concretely, we have an internal framework that writes code like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"m.new_content":{"body":"More concretely, we have an internal framework that writes code like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":"<p>More concretely, we have an internal framework that writes code like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$1yc6h_I-9Ops-nBHlAWu8kJA3APe6NtycWOR3hFaZf0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712946006854,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$IfpEToFip6EcDNUq4AGtSJVsr3A02Ex_6Xov5ZRWToY"},
{"content":{"body":" * More concretely, we have an internal framework that writes code (very roughly) like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":" * <p>More concretely, we have an internal framework that writes code (very roughly) like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"m.new_content":{"body":"More concretely, we have an internal framework that writes code (very roughly) like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":"<p>More concretely, we have an internal framework that writes code (very roughly) like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$1yc6h_I-9Ops-nBHlAWu8kJA3APe6NtycWOR3hFaZf0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712946045725,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$pCe62GApR4bUptoNr2FxHRysisD-HoVZviB9o5fcazI"},
{"content":{"body":" * More concretely, we have an internal framework that writes code (very roughly) like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\n// in a totally different file:\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":" * <p>More concretely, we have an internal framework that writes code (very roughly) like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\n// in a totally different file:\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"m.new_content":{"body":"More concretely, we have an internal framework that writes code (very roughly) like this:\n\n```\nclass UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return <button on:click={this.onClick}>{item.getVotes()}</button>;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\n// in a totally different file:\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) => response.getId(),\n    (item: ItemDetail) => item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) => {\n      item.setVotes(response.getNewVoteCount());\n    });\n```\n\nIn this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.","format":"org.matrix.custom.html","formatted_body":"<p>More concretely, we have an internal framework that writes code (very roughly) like this:</p>\n<pre><code>class UpvoteButtonComponent {\n  constructor(private readonly rpcService: RpcService, private readonly id: string) {}\n  render(item: ItemDetail) {\n    return &lt;button on:click={this.onClick}&gt;{item.getVotes()}&lt;/button&gt;;\n  }\n  onClick() {\n    this.rpcService.sendUpvote(new UpvoteRequest().setId(this.id));\n  }\n}\n// in a totally different file:\nRpcService.registerMiddleware(UpvoteResponse.typeId, ItemDetail.typeId,\n    (response: UpvoteResponse) =&gt; response.getId(),\n    (item: ItemDetail) =&gt; item.getId(),\n    (response: UpvoteResponse, item: ItemDetail) =&gt; {\n      item.setVotes(response.getNewVoteCount());\n    });\n</code></pre>\n<p>In this example, there's a lot of loose coupling: the click handler just fires-and-forgets an RPC.  The RPC service has some middleware registered that gets a response of a certain type and then indexes all the cached ItemDetail models by their ID, retrieves the matching detail, and updates its votes.  The UI data binding then picks up this change and rerenders the component.  What I need to be able to do is thread a trace through that sequence of loosely coupled triggers.  The callbacks are all registered once, when the module is loaded, but they need to carry along the call-time context in order to preserve the trace.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$1yc6h_I-9Ops-nBHlAWu8kJA3APe6NtycWOR3hFaZf0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712946070081,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$-d4jMWlRRkfp7bStEx8KaGPeCVIPiXIjxkabn0_QK84"},
{"content":{"body":"I need to better understand the concern about `using` and an async context scope. As I understand it, even with `[Symbol.enter]` you're concerned it's possible exit the function without exiting the scope?","format":"org.matrix.custom.html","formatted_body":"I need to better understand the concern about <code>using</code> and an async context scope. As I understand it, even with <code>[Symbol.enter]</code> you're concerned it's possible exit the function without exiting the scope?","m.mentions":{},"msgtype":"m.text"},"ts":1712947313971,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zYUUSX9QOP6eJgizvbIRaOGyn3f6Q4p8Gig2dqjzmdM"},
{"content":{"body":"> <@rbuckton:matrix.org> I need to better understand the concern about `using` and an async context scope. As I understand it, even with `[Symbol.enter]` you're concerned it's possible exit the function without exiting the scope?\n\nthe concern is that buggy (or malicious) code that calls `[Symbol.enter]` but not `[Symbol.dispose]` would change the context available when the function returns","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$zYUUSX9QOP6eJgizvbIRaOGyn3f6Q4p8Gig2dqjzmdM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I need to better understand the concern about <code>using</code> and an async context scope. As I understand it, even with <code>[Symbol.enter]</code> you're concerned it's possible exit the function without exiting the scope?</blockquote></mx-reply>the concern is that buggy (or malicious) code that calls <code>[Symbol.enter]</code> but not <code>[Symbol.dispose]</code> would change the context available when the function returns","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zYUUSX9QOP6eJgizvbIRaOGyn3f6Q4p8Gig2dqjzmdM"}},"msgtype":"m.text"},"ts":1712947592131,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$AsCoARONTBdY6Z3nwqBtwzjdNVCFDBQ-eTlVWQ6C2Oc"},
{"content":{"body":"currently in the AsyncContext proposal there's no way to change the context in the middle of a function execution","m.mentions":{},"msgtype":"m.text"},"ts":1712947613482,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$cL6VIot8T7V4mKO2j7tyQHvfSnUDrHpns-qnBUnBhko"},
{"content":{"body":"and I think this was a design goal, which is why we didn't adopt `AsyncLocalStorage`'s `enterWith`","format":"org.matrix.custom.html","formatted_body":"and I think this was a design goal, which is why we didn't adopt <code>AsyncLocalStorage</code>'s <code>enterWith</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712947642293,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$4Dl_gptxRtNhDfqeu0VEk9o6Sh_nbY4Eickn_IsSA88"},
{"content":{"body":"How does this:\n\n```js\nfunction f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n```\n\ndiffer from this:\n\n```js\nfunction f() {\n  let result;\n  function* g(cb) {\n    using scope = new AsyncContext.Scope();\n    result = cb();\n    yield;\n  }\n  g().next();\n  return result;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>How does this:</p>\n<pre><code class=\"language-js\">function f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n</code></pre>\n<p>differ from this:</p>\n<pre><code class=\"language-js\">function f() {\n  let result;\n  function* g(cb) {\n    using scope = new AsyncContext.Scope();\n    result = cb();\n    yield;\n  }\n  g().next();\n  return result;\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712947678043,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NnpK9Yl4K1VCQY8u-cOzLeh4CDa4j7SuoKRvdQPIGI4"},
{"content":{"body":"That would also result in a dangling scope, even with some kind of more comprehensive enforcement of `using`","format":"org.matrix.custom.html","formatted_body":"That would also result in a dangling scope, even with some kind of more comprehensive enforcement of <code>using</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712947732543,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9xN6d03CMR-vx6pvI_XO8YkVK445ND8PorXd5L0nROQ"},
{"content":{"body":" * How does this:\n\n```js\nfunction f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n```\n\ndiffer from this:\n\n```js\nfunction f() {\n  function* g() {\n    using scope = new AsyncContext.Scope();\n    // do work\n    yield;\n  }\n  g().next();\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>How does this:</p>\n<pre><code class=\"language-js\">function f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n</code></pre>\n<p>differ from this:</p>\n<pre><code class=\"language-js\">function f() {\n  function* g() {\n    using scope = new AsyncContext.Scope();\n    // do work\n    yield;\n  }\n  g().next();\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"How does this:\n\n```js\nfunction f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n```\n\ndiffer from this:\n\n```js\nfunction f() {\n  function* g() {\n    using scope = new AsyncContext.Scope();\n    // do work\n    yield;\n  }\n  g().next();\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>How does this:</p>\n<pre><code class=\"language-js\">function f() {\n  const scopeEnterable = new AsyncContext.Scope();\n  scopeEnterable[Symbol.enter]();\n  // do work\n  // forget to exit scope\n}\n</code></pre>\n<p>differ from this:</p>\n<pre><code class=\"language-js\">function f() {\n  function* g() {\n    using scope = new AsyncContext.Scope();\n    // do work\n    yield;\n  }\n  g().next();\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$NnpK9Yl4K1VCQY8u-cOzLeh4CDa4j7SuoKRvdQPIGI4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712947818246,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yIjh-3kjN3-VMEy14aNauiUC8ipYgZx_rec3JuXM7P0"},
{"content":{"body":"the current scope text switches the context when generators are paused and restored – there's still discussion about whether this is the right behavior, but that would take care of that","m.mentions":{},"msgtype":"m.text"},"ts":1712947826977,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$elC7wkTLwTGACgyAPAKsw4d0qUGOqY7tQgS56jqAtPI"},
{"content":{"body":"yeah, neither of those is acceptable, that's the thing","m.mentions":{},"msgtype":"m.text"},"ts":1712947831093,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$BvxVVAoQw3RuGh5rXfooKxJAFzACguELAmMjLBHo33M"},
{"content":{"body":"the current API is based on `.run(cb)` instead","format":"org.matrix.custom.html","formatted_body":"the current API is based on <code>.run(cb)</code> instead","m.mentions":{},"msgtype":"m.text"},"ts":1712947842752,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$dDDjGcQ4s3fpxmUVm-4VcsI7MChVyrSNIYjRkAfVzTA"},
{"content":{"body":"If failing to exit the scope is unacceptable, then there's no way to achieve that kind of enforcement with `using`","format":"org.matrix.custom.html","formatted_body":"If failing to exit the scope is unacceptable, then there's no way to achieve that kind of enforcement with <code>using</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712947883490,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gj1yQjGXiGodF3qLmF9C6Xjs9puaKcbDsvwR33Da_KQ"},
{"content":{"body":"I guess the fact that AsyncContext *can* switch the scope for generators is a thing that no other use cases could do, so maybe that doesn't apply more generally","format":"org.matrix.custom.html","formatted_body":"I guess the fact that AsyncContext <em>can</em> switch the scope for generators is a thing that no other use cases could do, so maybe that doesn't apply more generally","m.mentions":{},"msgtype":"m.text"},"ts":1712947938517,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$_YRjIpi_7jMBJg5PrK5Z2NqhKOSYDuzbFQgQHCkYoBQ"},
{"content":{"body":"Async functions would also result in a dangling scope\n```js\nasync function f(p) {\n  using scope = new AsyncContext.Scope();\n  // do work\n  await p;\n}\n\nconst { promise, resolve } = Promise.withResolves();\nf(p);\n// never call resolve()\n```","format":"org.matrix.custom.html","formatted_body":"<p>Async functions would also result in a dangling scope</p>\n<pre><code class=\"language-js\">async function f(p) {\n  using scope = new AsyncContext.Scope();\n  // do work\n  await p;\n}\n\nconst { promise, resolve } = Promise.withResolves();\nf(p);\n// never call resolve()\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712947973045,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TtgT9PV4W0-tKxmI6YOyabtpBctXsWVXcbDj1j5qEzw"},
{"content":{"body":" * I guess the fact that AsyncContext _can_ switch the scope for generators is a thing that no userland use cases could do, so maybe that doesn't apply more generally","format":"org.matrix.custom.html","formatted_body":" * I guess the fact that AsyncContext <em>can</em> switch the scope for generators is a thing that no userland use cases could do, so maybe that doesn't apply more generally","m.mentions":{},"m.new_content":{"body":"I guess the fact that AsyncContext _can_ switch the scope for generators is a thing that no userland use cases could do, so maybe that doesn't apply more generally","format":"org.matrix.custom.html","formatted_body":"I guess the fact that AsyncContext <em>can</em> switch the scope for generators is a thing that no userland use cases could do, so maybe that doesn't apply more generally","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_YRjIpi_7jMBJg5PrK5Z2NqhKOSYDuzbFQgQHCkYoBQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712947974325,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$CDXCGBED_N_y3pImzxuhOvE-l13fTOe2rowB63mmy98"},
{"content":{"body":"This leads me to believe that `AsyncContext.Scope` isn't viable.","format":"org.matrix.custom.html","formatted_body":"This leads me to believe that <code>AsyncContext.Scope</code> isn't viable.","m.mentions":{},"msgtype":"m.text"},"ts":1712948092527,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc"},
{"content":{"body":"a different thing in the space of `using` could hypothetically solve this problem--maybe more along the lines of what you described Python can do in `with`.","format":"org.matrix.custom.html","formatted_body":"a different thing in the space of <code>using</code> could hypothetically solve this problem--maybe more along the lines of what you described Python can do in <code>with</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1712948121142,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$jqGnLNdYEkvUMrfl4K-TxeiufM92aOixcF_u0v36X3w"},
{"content":{"body":"not that we need that, but the name of the proposal kinda feels like a tease, *almost* getting us there","format":"org.matrix.custom.html","formatted_body":"not that we need that, but the name of the proposal kinda feels like a tease, <em>almost</em> getting us there","m.mentions":{},"msgtype":"m.text"},"ts":1712948145977,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$1vt2q5oimBblY0XnNsQQVhfwp4037rcOjL2UCmCvNT4"},
{"content":{"body":"Python's `with` would have the exact same issues. ","format":"org.matrix.custom.html","formatted_body":"Python's <code>with</code> would have the exact same issues.","m.mentions":{},"msgtype":"m.text"},"ts":1712948155928,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2XnJuMS-aeg6qwwc8b35kopx75VkgXeXigczL9Y6j1M"},
{"content":{"body":"> <@rbuckton:matrix.org> This leads me to believe that `AsyncContext.Scope` isn't viable.\n\nI think it would be viable, because AsyncContext needs to integrate with generator resuming and promise continuations. But maybe similar use cases implemented in userland could not.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>This leads me to believe that <code>AsyncContext.Scope</code> isn't viable.</blockquote></mx-reply>I think it would be viable, because AsyncContext needs to integrate with generator resuming and promise continuations. But maybe similar use cases implemented in userland could not.","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc"}},"msgtype":"m.text"},"ts":1712948158225,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$7f9sBYNC-FF4QfMg7qi8u8VrgvpTm5CNyBunuNguzyQ"},
{"content":{"body":"And I'm not necessarily willing to ask for the strict `using` enforcement proposal to change to fit use cases which are limited to spec proposals","format":"org.matrix.custom.html","formatted_body":"And I'm not necessarily willing to ask for the strict <code>using</code> enforcement proposal to change to fit use cases which are limited to spec proposals","m.mentions":{},"msgtype":"m.text"},"ts":1712948198727,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$fl9jQUXN0IXdsxpeAVtsDZiNJU7WFGWyQLfjggcBoIo"},
{"content":{"body":"in the extreme case: if `using` was passed the delimited continuation as an argument...","format":"org.matrix.custom.html","formatted_body":"in the extreme case: if <code>using</code> was passed the delimited continuation as an argument...","m.mentions":{},"msgtype":"m.text"},"ts":1712948203511,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$clvlia933s4KK49Bx1IzOIZMUIr62oDrTRSkbtyDaiA"},
{"content":{"body":" * And I'm not willing to ask for the strict `using` enforcement proposal to change to fit use cases which are limited to spec proposals","format":"org.matrix.custom.html","formatted_body":" * And I'm not willing to ask for the strict <code>using</code> enforcement proposal to change to fit use cases which are limited to spec proposals","m.mentions":{},"m.new_content":{"body":"And I'm not willing to ask for the strict `using` enforcement proposal to change to fit use cases which are limited to spec proposals","format":"org.matrix.custom.html","formatted_body":"And I'm not willing to ask for the strict <code>using</code> enforcement proposal to change to fit use cases which are limited to spec proposals","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$fl9jQUXN0IXdsxpeAVtsDZiNJU7WFGWyQLfjggcBoIo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712948206887,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$ME7N6_bnZOQfqbemw06CbftaEoyBX1Bw65uhZ5cRjSw"},
{"content":{"body":"> <@rbuckton:matrix.org> This leads me to believe that `AsyncContext.Scope` isn't viable.\n\nI think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as _before_ the Scope is entered.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>This leads me to believe that <code>AsyncContext.Scope</code> isn't viable.</blockquote></mx-reply>I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as <em>before</em> the Scope is entered.","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc"}},"msgtype":"m.text"},"ts":1712948297150,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$lVzwyhK8RSZBm-yZq5ea_tSAqimAkOsoS_vnepmm1w8"},
{"content":{"body":"> <@littledan:matrix.org> in the extreme case: if `using` was passed the delimited continuation as an argument...\n\nI don't see how this wouldn't be significantly worse.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$clvlia933s4KK49Bx1IzOIZMUIr62oDrTRSkbtyDaiA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>in the extreme case: if <code>using</code> was passed the delimited continuation as an argument...</blockquote></mx-reply>I don't see how this wouldn't be significantly worse.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$clvlia933s4KK49Bx1IzOIZMUIr62oDrTRSkbtyDaiA"}},"msgtype":"m.text"},"ts":1712948300383,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VyE2um579d7GKaUKj0L85m_yrkvTojxv6a7-a5cCcDI"},
{"content":{"body":"> <@rbuckton:matrix.org> I don't see how this wouldn't be significantly worse.\n\nit would solve the problem that Andreu is talking about, while also, yes, being a crazy thing that we definitely shouldn't do","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$VyE2um579d7GKaUKj0L85m_yrkvTojxv6a7-a5cCcDI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I don't see how this wouldn't be significantly worse.</blockquote></mx-reply>it would solve the problem that Andreu is talking about, while also, yes, being a crazy thing that we definitely shouldn't do","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$VyE2um579d7GKaUKj0L85m_yrkvTojxv6a7-a5cCcDI"}},"msgtype":"m.text"},"ts":1712948329194,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9Wh06KJT8cpWpIgEvXAocVO4ZZWYSi6mrsGuP_9jjHU"},
{"content":{"body":"the design of `.run(cb)` forces you to extract the delimited continuation manually","format":"org.matrix.custom.html","formatted_body":"the design of <code>.run(cb)</code> forces you to extract the delimited continuation manually","m.mentions":{},"msgtype":"m.text"},"ts":1712948348845,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$IUb8RSegevf94-34ddyanrY2RukZ6Hcqyk1L6UOU1do"},
{"content":{"body":"> <@rbuckton:matrix.org> This leads me to believe that `AsyncContext.Scope` isn't viable.\n\n * I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as _before_ the Scope is entered.  Specifically, it would _not_ mutate the current context.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$MgAPJTu7_skxbUR_rV3YywgmygiEhDNNrjWknSkx8Xc?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>This leads me to believe that <code>AsyncContext.Scope</code> isn't viable.</blockquote></mx-reply> * I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as <em>before</em> the Scope is entered.  Specifically, it would <em>not</em> mutate the current context.","m.mentions":{},"m.new_content":{"body":"I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as _before_ the Scope is entered.  Specifically, it would _not_ mutate the current context.","format":"org.matrix.custom.html","formatted_body":"I think you're missing something here.  The issue is only in any shared contexts.  The context outside the async function isn't affected by the Scope.  I assume the point of Scope is that it effectively makes a child context \"in place\" - so it wouldn't impact any other function bodies that were sharing the same context as <em>before</em> the Scope is entered.  Specifically, it would <em>not</em> mutate the current context.","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$lVzwyhK8RSZBm-yZq5ea_tSAqimAkOsoS_vnepmm1w8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712948352297,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$KKVbhzD8nhdUj4Mj39kzJaGFZ5xwlb4TWrC_2j8wRzA"},
{"content":{"body":"Where I see a problem is\n```\n{\n  using scope = new AsyncContext.Scope();\n  // ...\n  const innerScope =  new AsyncContext.Scope();\n  innerScope[Symbol.enter]();\n  // ...\n}\n// what happens to vars set on innerScope?\ninnerScope[Symbol.dispose]();\n// what happens now?","format":"org.matrix.custom.html","formatted_body":"<p>Where I see a problem is</p>\n<pre><code>{\n  using scope = new AsyncContext.Scope();\n  // ...\n  const innerScope =  new AsyncContext.Scope();\n  innerScope[Symbol.enter]();\n  // ...\n}\n// what happens to vars set on innerScope?\ninnerScope[Symbol.dispose]();\n// what happens now?\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712948479675,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$CMbFUqMC01QYnoKVOhOwHy45obhSgp-HpnJuChUoIZ0"},
{"content":{"body":"if you were to treat this like a stack, as `run(cb)` would do, I would expect `innerScope` to be on top of the stack, and when `scope` is disposed it should throw if it's not on the top of the stack.","format":"org.matrix.custom.html","formatted_body":"if you were to treat this like a stack, as <code>run(cb)</code> would do, I would expect <code>innerScope</code> to be on top of the stack, and when <code>scope</code> is disposed it should throw if it's not on the top of the stack.","m.mentions":{},"msgtype":"m.text"},"ts":1712948570273,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PLFnr9Od5k8ZHRi8sI60QBxBPXSiSAnWjHOHaRHYtP4"},
{"content":{"body":"> <@stephenhicks:matrix.org> Where I see a problem is\n> ```\n> {\n>   using scope = new AsyncContext.Scope();\n>   // ...\n>   const innerScope =  new AsyncContext.Scope();\n>   innerScope[Symbol.enter]();\n>   // ...\n> }\n> // what happens to vars set on innerScope?\n> innerScope[Symbol.dispose]();\n> // what happens now?\n\nI think this could be worked around by keeping the scope depth and invalidating `innerScope` if `scope` has been disposed. But I'm not sure at this point if this would work for async functions and generators","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$CMbFUqMC01QYnoKVOhOwHy45obhSgp-HpnJuChUoIZ0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>Where I see a problem is</p>\n<pre><code>{\n  using scope = new AsyncContext.Scope();\n  // ...\n  const innerScope =  new AsyncContext.Scope();\n  innerScope[Symbol.enter]();\n  // ...\n}\n// what happens to vars set on innerScope?\ninnerScope[Symbol.dispose]();\n// what happens now?\n</code></pre>\n</blockquote></mx-reply>I think this could be worked around by keeping the scope depth and invalidating <code>innerScope</code> if <code>scope</code> has been disposed. But I'm not sure at this point if this would work for async functions and generators","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$CMbFUqMC01QYnoKVOhOwHy45obhSgp-HpnJuChUoIZ0"}},"msgtype":"m.text"},"ts":1712948588687,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$IT7cNOf-HPwr32tw3NRJU3iJwm4pM1LAQwBwJm50tKg"},
{"content":{"body":"Do you have to keep track of when you enter or exit a function with `run()`?","format":"org.matrix.custom.html","formatted_body":"Do you have to keep track of when you enter or exit a function with <code>run()</code>?","m.mentions":{},"msgtype":"m.text"},"ts":1712948663758,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$I5uG9D9ZsV82cvx0fZzwkntBvWNJ0_oNTIGzvOgx4w4"},
{"content":{"body":"No","msgtype":"m.text"},"ts":1712948692755,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$h9mOE_tGBHz_FCydPuCY8sEAPJXZc4Zyq2a1xQARzDc"},
{"content":{"body":"Run enters, invokes the cb, then exits. It can’t leave a dirty stack.","msgtype":"m.text"},"ts":1712948723690,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$pr7LmNqvTB5Wjz2CHkvdWq1oa6H2D3VVSmrjD8ivTTU"},
{"content":{"body":"One way I could envision this behavior would be something like this very naive implementation:\n\n```js\nAsyncContext.run = function (ctx, cb) {\n  using scope = new AsyncContext.Scope(ctx);\n  return cb();\n}\nAsyncContext.Scope = class Scope {\n  static #top;\n  #prev;\n  #ctx;\n  constructor(ctx) {\n    this.#ctx = ctx;\n    this.#prev = Scope.#top;\n    Scope.#top = this;\n    // other scope setup work\n  }\n  [Symbol.dispose]() {\n    if (this !== Scope.#top) throw new Error();\n    Scope.#top = this.#prev;\n    // other scope teardown work\n  }\n}\n```\nEach time you create a new `Scope`, you're pushing it into a stack. When you fail to pop a scope, you get an error. ","format":"org.matrix.custom.html","formatted_body":"<p>One way I could envision this behavior would be something like this very naive implementation:</p>\n<pre><code class=\"language-js\">AsyncContext.run = function (ctx, cb) {\n  using scope = new AsyncContext.Scope(ctx);\n  return cb();\n}\nAsyncContext.Scope = class Scope {\n  static #top;\n  #prev;\n  #ctx;\n  constructor(ctx) {\n    this.#ctx = ctx;\n    this.#prev = Scope.#top;\n    Scope.#top = this;\n    // other scope setup work\n  }\n  [Symbol.dispose]() {\n    if (this !== Scope.#top) throw new Error();\n    Scope.#top = this.#prev;\n    // other scope teardown work\n  }\n}\n</code></pre>\n<p>Each time you create a new <code>Scope</code>, you're pushing it into a stack. When you fail to pop a scope, you get an error.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712949110346,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9vvP6kojwjxxjkBgHbnSUOfXL1c7WKNLLBBaUmRZrWQ"},
{"content":{"body":"(I'll also point out that this is effectively impossible to polyfill, for whatever it's worth - you'd need to instrument every function with a local variable to store the current context in, rather than relying on a global.)","m.mentions":{},"msgtype":"m.text"},"ts":1712949128585,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$a_bAQMvyGgjUVbZCrjLUa5LaUJ9rhkxBkHv6if6ML08"},
{"content":{"body":"This doesn't require strict enforcement and it throws when used incorrectly. Theoretically, before you throw you could also walk the stack from `#top` to `this` and exit those contexts as well, but it's still better to error than to exit silently.","format":"org.matrix.custom.html","formatted_body":"This doesn't require strict enforcement and it throws when used incorrectly. Theoretically, before you throw you could also walk the stack from <code>#top</code> to <code>this</code> and exit those contexts as well, but it's still better to error than to exit silently.","m.mentions":{},"msgtype":"m.text"},"ts":1712949374211,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IXyalNUWQrNme8RIQVlALAQLlbpaZnxO58DukJA3W54"},
{"content":{"body":"I think that still leaves a dirty stack, just with an error telling you that something went wrong. It doesn’t prevent the misuse from happening.","msgtype":"m.text"},"ts":1712949501095,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$4KoFhinh-sL1fvAcw5PT0Tsl8kXm01QEn9TvymK4ANc"},
{"content":{"body":"> <@stephenhicks:matrix.org> (I'll also point out that this is effectively impossible to polyfill, for whatever it's worth - you'd need to instrument every function with a local variable to store the current context in, rather than relying on a global.)\n\nIs this in reply to Ron, or the scoped feature in general? I think it’s easily polyfillable.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24a_bAQMvyGgjUVbZCrjLUa5LaUJ9rhkxBkHv6if6ML08\">In reply to</a><a href=\"https://matrix.to/#/%40stephenhicks%3Amatrix.org\">@stephenhicks:matrix.org</a><br />(I&#39;ll also point out that this is effectively impossible to polyfill, for whatever it&#39;s worth - you&#39;d need to instrument every function with a local variable to store the current context in, rather than relying on a global.)</blockquote></mx-reply>Is this in reply to Ron, or the scoped feature in general? I think it’s easily polyfillable.","m.relates_to":{"m.in_reply_to":{"event_id":"$a_bAQMvyGgjUVbZCrjLUa5LaUJ9rhkxBkHv6if6ML08"}},"msgtype":"m.text"},"ts":1712949550483,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$u1ozAjVz-kFjMx05g-nRHYwvYY_a0NCbSft6Jjjk4gc"},
{"content":{"body":"> <@jridgewell:matrix.org> I think that still leaves a dirty stack, just with an error telling you that something went wrong. It doesn’t prevent the misuse from happening.\n\n`using` doesn't prevent a dirty stack, as I illustrated with the generator and async function example. And as I mentioned, you can clean up the stack before you error.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$4KoFhinh-sL1fvAcw5PT0Tsl8kXm01QEn9TvymK4ANc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>I think that still leaves a dirty stack, just with an error telling you that something went wrong. It doesn’t prevent the misuse from happening.</blockquote></mx-reply><code>using</code> doesn't prevent a dirty stack, as I illustrated with the generator and async function example. And as I mentioned, you can clean up the stack before you error.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$4KoFhinh-sL1fvAcw5PT0Tsl8kXm01QEn9TvymK4ANc"}},"msgtype":"m.text"},"ts":1712949555394,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BzAhzqGUKpRm45gvc0PBpz2hNhajmnsmuppXhwT3_Jc"},
{"content":{"body":"I disagree, it defintely does","msgtype":"m.text"},"ts":1712949602203,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$K1MzxD1zo-ybSTB1hJsxrB-Qy_JU-BaRZAilRRZWhtk"},
{"content":{"body":"not within the context of `run`.","format":"org.matrix.custom.html","formatted_body":"not within the context of <code>run</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1712949617559,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8pcQkZLsutDhTKNAeVXHDyk2GA4WrCrrmuZmNE6WSaU"},
{"content":{"body":" * ~~not within the context of `run`.~~ sorry, misread the comment","format":"org.matrix.custom.html","formatted_body":" * ~~not within the context of <code>run</code>.~~ sorry, misread the comment","m.mentions":{},"m.new_content":{"body":"~~not within the context of `run`.~~ sorry, misread the comment","format":"org.matrix.custom.html","formatted_body":"~~not within the context of <code>run</code>.~~ sorry, misread the comment","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$8pcQkZLsutDhTKNAeVXHDyk2GA4WrCrrmuZmNE6WSaU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712949660269,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CuFFNFD0tRZCgKFRDkWA2dAINvXi_daQQ7anLd5yMbU"},
{"content":{"body":"How does `using` prevent a dirty stack, given the examples I just posted?","format":"org.matrix.custom.html","formatted_body":"How does <code>using</code> prevent a dirty stack, given the examples I just posted?","m.mentions":{},"msgtype":"m.text"},"ts":1712949673409,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$pE9upTX62fMOvRknH7_J3N7fxx-JlgKkbmf6rlUbZ5w"},
{"content":{"body":"I assume a generator has a magic behavior that does context capturing when started and resumed? Is there any reason you wouldn't do the same for normal function execution? Or is that just too expensive?","m.mentions":{},"msgtype":"m.text"},"ts":1712949840547,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2MAHhFlpLy2WI4so1tLpe_xgoNauyHhDNQn2RSrpF64"},
{"content":{"body":"It requires a modification in the internal pausing behavior for `await` and `yield`","format":"org.matrix.custom.html","formatted_body":"It requires a modification in the internal pausing behavior for <code data-md=\"`\">await</code> and <code data-md=\"`\">yield</code>","msgtype":"m.text"},"ts":1712949870175,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$QQDe1IyCHIL86WdtSf4kw6JAypb_GSb8u9K1e0v8qSY"},
{"content":{"body":"> <@rbuckton:matrix.org> I assume a generator has a magic behavior that does context capturing when started and resumed? Is there any reason you wouldn't do the same for normal function execution? Or is that just too expensive?\n\nI guess we could do that, but I expect that would break a lot of optimizations in engines","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$2MAHhFlpLy2WI4so1tLpe_xgoNauyHhDNQn2RSrpF64?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I assume a generator has a magic behavior that does context capturing when started and resumed? Is there any reason you wouldn&#39;t do the same for normal function execution? Or is that just too expensive?</blockquote></mx-reply>I guess we could do that, but I expect that would break a lot of optimizations in engines","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$2MAHhFlpLy2WI4so1tLpe_xgoNauyHhDNQn2RSrpF64"}},"msgtype":"m.text"},"ts":1712949919856,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$dmaP9GmyqmwcyhPbN0UIK2Ld28Lb4CcdSuNByJh4mEk"},
{"content":{"body":"I expect that's true.","m.mentions":{},"msgtype":"m.text"},"ts":1712949956794,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$U5GDToL5AL0KitCmeC89Io7vJ5_i3ksJ8teo95mWqoc"},
{"content":{"body":"Assuming some magical enforcement of syntactic `using` does support your case, how would you expect it to work? Any alternative I've considered so far breaks some other different feature of resource management.","format":"org.matrix.custom.html","formatted_body":"Assuming some magical enforcement of syntactic <code>using</code> does support your case, how would you expect it to work? Any alternative I've considered so far breaks some other different feature of resource management.","m.mentions":{},"msgtype":"m.text"},"ts":1712950150015,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oaL5-8YCNTErGZkfm_y_hb-XfBhzmb976NWyObvxDOA"},
{"content":{"body":" * Assuming some magical enforcement of syntactic `using` does support your case, how would you expect it to work? Any alternative I've considered so far breaks some other important feature of resource management.","format":"org.matrix.custom.html","formatted_body":" * Assuming some magical enforcement of syntactic <code>using</code> does support your case, how would you expect it to work? Any alternative I've considered so far breaks some other important feature of resource management.","m.mentions":{},"m.new_content":{"body":"Assuming some magical enforcement of syntactic `using` does support your case, how would you expect it to work? Any alternative I've considered so far breaks some other important feature of resource management.","format":"org.matrix.custom.html","formatted_body":"Assuming some magical enforcement of syntactic <code>using</code> does support your case, how would you expect it to work? Any alternative I've considered so far breaks some other important feature of resource management.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$oaL5-8YCNTErGZkfm_y_hb-XfBhzmb976NWyObvxDOA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712950158696,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9KVBgInuECUmxtIXIFvi0nyOCsReI3HzlCEncL7ddN8"},
{"content":{"body":"> <@jridgewell:matrix.org> Is this in reply to Ron, or the scoped feature in general? I think it’s easily polyfillable.\n\nI was referring to `Scope` in general - I may just not be seeing it, but short of instrumenting _every_ function to have its own separate mutable context, I don't see how two function bodies sharing the same `run` context could have `Scope` mutations from one be isolated from being observed in the other.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$u1ozAjVz-kFjMx05g-nRHYwvYY_a0NCbSft6Jjjk4gc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Is this in reply to Ron, or the scoped feature in general? I think it’s easily polyfillable.</blockquote></mx-reply>I was referring to <code>Scope</code> in general - I may just not be seeing it, but short of instrumenting <em>every</em> function to have its own separate mutable context, I don't see how two function bodies sharing the same <code>run</code> context could have <code>Scope</code> mutations from one be isolated from being observed in the other.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$u1ozAjVz-kFjMx05g-nRHYwvYY_a0NCbSft6Jjjk4gc"}},"msgtype":"m.text"},"ts":1712950185057,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Z54sro6GFTQrO4ArQQenC-7exMolGazMk1aNdN9ohxE"},
{"content":{"body":"For example, lets say you could check a `function.using` meta property from inside the constructor that is only set when you write `using x = new Scope(ctx)`. That breaks composability, which is another core capability of resource management.","format":"org.matrix.custom.html","formatted_body":"For example, lets say you could check a <code>function.using</code> meta property from inside the constructor that is only set when you write <code>using x = new Scope(ctx)</code>. That breaks composability, which is another core capability of resource management.","m.mentions":{},"msgtype":"m.text"},"ts":1712950256084,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nsU8ITWqG47tMusmMkfzeLGdlYrhiilhX4Gcb8Ga2gA"},
{"content":{"body":"That’s fine, `AsyncContext` is not composable","format":"org.matrix.custom.html","formatted_body":"That’s fine, <code data-md=\"`\">AsyncContext</code> is not composable","msgtype":"m.text"},"ts":1712950302754,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ZxF2yatX2MUorftC7nDq4Zl2Qpwrqig-yiFUiY0XUko"},
{"content":{"body":"It prevents a user from wrapping `Scope` in another function to make decisions. It prevents a user from entering a `Scope` conditionally. It prevents instrumentation.","format":"org.matrix.custom.html","formatted_body":"It prevents a user from wrapping <code>Scope</code> in another function to make decisions. It prevents a user from entering a <code>Scope</code> conditionally. It prevents instrumentation.","m.mentions":{},"msgtype":"m.text"},"ts":1712950308643,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4d_1EY8dbCmTlqnLB9zCWZBGOoexxu0VD1HKjy1Ntks"},
{"content":{"body":"That would be a huge footgun. ","m.mentions":{},"msgtype":"m.text"},"ts":1712950353342,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_gELwx71DYg6iZmb8dm-jjAME0Zh5YZqRxourZBg5w0"},
{"content":{"body":"* That’s fine, `Scope` is not composable","format":"org.matrix.custom.html","formatted_body":"That’s fine, <code data-md=\"`\">Scope</code> is not composable","m.new_content":{"body":"That’s fine, `Scope` is not composable","format":"org.matrix.custom.html","formatted_body":"That’s fine, <code data-md=\"`\">Scope</code> is not composable","msgtype":"m.text"},"m.relates_to":{"event_id":"$ZxF2yatX2MUorftC7nDq4Zl2Qpwrqig-yiFUiY0XUko","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712950353569,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$pxWQgsJ-tpxAz8iMCvctmtNV0cPNqdTelVJwUpVnGGE"},
{"content":{"body":"How? We’re jsut trying to allow unnested use of `Variable`. We don’t need to do anything else.","format":"org.matrix.custom.html","formatted_body":"How? We’re jsut trying to allow unnested use of <code data-md=\"`\">Variable</code>. We don’t need to do anything else.","msgtype":"m.text"},"ts":1712950426603,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$R0KdEpCu0X2ngbADX8cyeoLiy4eSygbN9STEAc42wZ0"},
{"content":{"body":"> <@stephenhicks:matrix.org> I was referring to `Scope` in general - I may just not be seeing it, but short of instrumenting _every_ function to have its own separate mutable context, I don't see how two function bodies sharing the same `run` context could have `Scope` mutations from one be isolated from being observed in the other.\n\nWouldn’t the `dispose` take care of that? And for the dangling async/generator’s mentioned above, it requires a small modification to the pausing behavior.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24Z54sro6GFTQrO4ArQQenC-7exMolGazMk1aNdN9ohxE\">In reply to</a><a href=\"https://matrix.to/#/%40stephenhicks%3Amatrix.org\">@stephenhicks:matrix.org</a><br />I was referring to <code>Scope</code> in general - I may just not be seeing it, but short of instrumenting <em>every</em> function to have its own separate mutable context, I don't see how two function bodies sharing the same <code>run</code> context could have <code>Scope</code> mutations from one be isolated from being observed in the other.</blockquote></mx-reply>Wouldn’t the <code data-md=\"`\">dispose</code> take care of that? And for the dangling async/generator’s mentioned above, it requires a small modification to the pausing behavior.","m.relates_to":{"m.in_reply_to":{"event_id":"$Z54sro6GFTQrO4ArQQenC-7exMolGazMk1aNdN9ohxE"}},"msgtype":"m.text"},"ts":1712950535354,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$qDOPh3seTZW5NOxP8JmGU3uwxuR5huQpysyrUNqB6wg"},
{"content":{"body":"It's a footgun because it's confusing to users. If I had `using x = new Scope(ctx)`, and wanted to refactor to `const createScope = ctx => new Scope(ctx); using x = createScope(ctx);`, it suddenly breaks. Nothing else does that in the language, as far as I'm aware.","format":"org.matrix.custom.html","formatted_body":"It's a footgun because it's confusing to users. If I had <code>using x = new Scope(ctx)</code>, and wanted to refactor to <code>const createScope = ctx =&gt; new Scope(ctx); using x = createScope(ctx);</code>, it suddenly breaks. Nothing else does that in the language, as far as I'm aware.","m.mentions":{},"msgtype":"m.text"},"ts":1712950549320,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lR4_oxd_K7Se-flJ6kCk5P909mXaYP3f-TmlY8ilUsY"},
{"content":{"body":"It's a TCP violation, made worse because that specific change did not involve new syntax. the \"new syntax\" part didn't move.","m.mentions":{},"msgtype":"m.text"},"ts":1712950610327,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BxVlYhrgmHmBTCuKkMsf0S0XQ14AXpMqKHPoGf42ckw"},
{"content":{"body":"Perfect, The normal case now is `v.run(1, () => …)`, which also wouldn’t work that way.","format":"org.matrix.custom.html","formatted_body":"Perfect, The normal case now is <code data-md=\"`\">v.run(1, () =&gt; …)</code>, which also wouldn’t work that way.","msgtype":"m.text"},"ts":1712950638070,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Rt4jrysX5_ZsBVnvZIVBe_DH19NTCE4ocz8hpi4srVU"},
{"content":{"body":"take any valid expression in `v.run(...)` and turn it into an arrow and it would still work.","format":"org.matrix.custom.html","formatted_body":"take any valid expression in <code>v.run(...)</code> and turn it into an arrow and it would still work.","m.mentions":{},"msgtype":"m.text"},"ts":1712950707602,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$D5gPVhI6Gbm-O5NtW3DGZDyHYpW-GIr-OlSlMk4byOk"},
{"content":{"body":"with perhaps the only distinction being `this` receiver handling, which is a known quantity.","format":"org.matrix.custom.html","formatted_body":"with perhaps the only distinction being <code>this</code> receiver handling, which is a known quantity.","m.mentions":{},"msgtype":"m.text"},"ts":1712950769091,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HxPMNBpN0bLOvSpu57OGmiPqNYN07xq4fcCzxHzlJIs"},
{"content":{"body":"```\n// Doesn't keep 1 on the context stack\nconst createScope = ctx => new Scope(ctx, 1);\nusing x = createScope(ctx);\ndoStuff();\n\n// Doesn't keep 1 on the context stack\nconst run = () => v.run(1, () => {})\nrun();\ndoStuff();\n```","format":"org.matrix.custom.html","formatted_body":"<pre data-md=\"```\"><code>// Doesn&#39;t keep 1 on the context stack\nconst createScope = ctx =&gt; new Scope(ctx, 1);\nusing x = createScope(ctx);\ndoStuff();\n\n// Doesn&#39;t keep 1 on the context stack\nconst run = () =&gt; v.run(1, () =&gt; {})\nrun();\ndoStuff();\n</code></pre>","msgtype":"m.text"},"ts":1712950845912,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$NpJTxjcLHp3LVtjCCMzrGxUgL7LCfP8yPEmS2M-kaAI"},
{"content":{"body":"These are the same programs","msgtype":"m.text"},"ts":1712950850411,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5anLavkzJ8a1NX-2yAbklZ0Ohjk4bclG_8ogIXRT61s"},
{"content":{"body":"So, I stand corrected. _One_ thing in the language has that oddity, and that's how `this` receivers work. The complexity of `this` receivers is not something I want to repeat.","format":"org.matrix.custom.html","formatted_body":"So, I stand corrected. <em>One</em> thing in the language has that oddity, and that's how <code>this</code> receivers work. The complexity of <code>this</code> receivers is not something I want to repeat.","m.mentions":{},"msgtype":"m.text"},"ts":1712950863887,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8V3DECivn8TimSpS6Flfh-x7BM_3D8Av3vGs2UBjfG8"},
{"content":{"body":"Where was `doStuff` before? If your original code was\n```js\nv.run(1, () => {})\ndoStuff();\n```\nthen it has the same behavior.","format":"org.matrix.custom.html","formatted_body":"<p>Where was <code>doStuff</code> before? If your original code was</p>\n<pre><code class=\"language-js\">v.run(1, () =&gt; {})\ndoStuff();\n</code></pre>\n<p>then it has the same behavior.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712950930618,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$x9podkILx4WbKwghKMIJI6tvtj30it-tB_Nnr0N6fJI"},
{"content":{"body":"If your code was `v.run(1, () => { doStuff(); });`, then you didn't refactor it you changed it to a different behavior.","format":"org.matrix.custom.html","formatted_body":"If your code was <code>v.run(1, () =&gt; { doStuff(); });</code>, then you didn't refactor it you changed it to a different behavior.","m.mentions":{},"msgtype":"m.text"},"ts":1712950997429,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OXnAZqAPUMv34dXDOs4wOdSDsD4TWLc-a7WerzuMqIM"},
{"content":{"body":"I'm talking about changing this\n\n```js\nv.run(1, () => doStuff());\n```\n\ninto this\n```js\nconst f = () => doStuff();\nv.run(1, () => f());\n```\nor this\n```js\nconst f = () => 1;\nv.run(f(), () => doStuff());\n```","format":"org.matrix.custom.html","formatted_body":"<p>I'm talking about changing this</p>\n<pre><code class=\"language-js\">v.run(1, () =&gt; doStuff());\n</code></pre>\n<p>into this</p>\n<pre><code class=\"language-js\">const f = () =&gt; doStuff();\nv.run(1, () =&gt; f());\n</code></pre>\n<p>or this</p>\n<pre><code class=\"language-js\">const f = () =&gt; 1;\nv.run(f(), () =&gt; doStuff());\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712951057840,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jX5KW1bSQgS_Bmt8MF-isJNHCeF8s6gh31M6zhkMNm0"},
{"content":{"body":"the average JS developer would expect both of those refactorings to be valid.","m.mentions":{},"msgtype":"m.text"},"ts":1712951107342,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Xsx_NAoOYZzPgz-5IWTKi35tJ4chpX93HGNUmItKVCg"},
{"content":{"body":"Ah, I missed `const createScope = ctx => new Scope(ctx);`, I thought you were doing `using new Scope(…)` inside the arrow.","format":"org.matrix.custom.html","formatted_body":"Ah, I missed <code data-md=\"`\">const createScope = ctx =&gt; new Scope(ctx);</code>, I thought you were doing <code data-md=\"`\">using new Scope(…)</code> inside the arrow.","msgtype":"m.text"},"ts":1712951134168,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$iijpLSO5aL0Q_eYc5Ru6Bsjl8am2PUItt1kptWQFQYI"},
{"content":{"body":"* Ah, I misread `const createScope = ctx => new Scope(ctx);`, I thought you were doing `using new Scope(…)` inside the arrow.","format":"org.matrix.custom.html","formatted_body":"Ah, I misread <code data-md=\"`\">const createScope = ctx =&gt; new Scope(ctx);</code>, I thought you were doing <code data-md=\"`\">using new Scope(…)</code> inside the arrow.","m.new_content":{"body":"Ah, I misread `const createScope = ctx => new Scope(ctx);`, I thought you were doing `using new Scope(…)` inside the arrow.","format":"org.matrix.custom.html","formatted_body":"Ah, I misread <code data-md=\"`\">const createScope = ctx =&gt; new Scope(ctx);</code>, I thought you were doing <code data-md=\"`\">using new Scope(…)</code> inside the arrow.","msgtype":"m.text"},"m.relates_to":{"event_id":"$iijpLSO5aL0Q_eYc5Ru6Bsjl8am2PUItt1kptWQFQYI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712951140595,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$SDjZ3ZEhJWYO4qDAhDJIG1vj9gwal-DhGcJhmgVSr80"},
{"content":{"body":"No.","m.mentions":{},"msgtype":"m.text"},"ts":1712951144654,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Yq9WzY2ooMUf_5DMbcI6Et1ne98fYdemZ2VUvdv8jeQ"},
{"content":{"body":"```\nconst createScope = ctx => new Scope(ctx, 1);\nusing _ = createScope(ctx);\nctx.get() === 1\n```\n\nThat works in my head? `using` is syntactic, it invokes `scope[Symbol.enter]()`, `function.using` check passes, you get a scope","format":"org.matrix.custom.html","formatted_body":"<pre data-md=\"```\"><code>const createScope = ctx =&gt; new Scope(ctx, 1);\nusing _ = createScope(ctx);\nctx.get() === 1\n</code></pre><br/>That works in my head? <code data-md=\"`\">using</code> is syntactic, it invokes <code data-md=\"`\">scope[Symbol.enter]()</code>, <code data-md=\"`\">function.using</code> check passes, you get a scope","msgtype":"m.text"},"ts":1712951211481,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$0Dqmn3XLoYGcUHF-q8oCgiQvXoMrY2CqsfKdmxyYDWk"},
{"content":{"body":"* ```\nconst createScope = ctx => new Scope(ctx, 1);\nusing _ = createScope(ctx);\nctx.get() === 1\n```\n\nThat works in my head? `using` is syntactic, it invokes `scope[Symbol.enter]()`, `function.using` check passes, you get a scoped update","format":"org.matrix.custom.html","formatted_body":"<pre data-md=\"```\"><code>const createScope = ctx =&gt; new Scope(ctx, 1);\nusing _ = createScope(ctx);\nctx.get() === 1\n</code></pre><br/>That works in my head? <code data-md=\"`\">using</code> is syntactic, it invokes <code data-md=\"`\">scope[Symbol.enter]()</code>, <code data-md=\"`\">function.using</code> check passes, you get a scoped update","m.new_content":{"body":"```\nconst createScope = ctx => new Scope(ctx, 1);\nusing _ = createScope(ctx);\nctx.get() === 1\n```\n\nThat works in my head? `using` is syntactic, it invokes `scope[Symbol.enter]()`, `function.using` check passes, you get a scoped update","format":"org.matrix.custom.html","formatted_body":"<pre data-md=\"```\"><code>const createScope = ctx =&gt; new Scope(ctx, 1);\nusing _ = createScope(ctx);\nctx.get() === 1\n</code></pre><br/>That works in my head? <code data-md=\"`\">using</code> is syntactic, it invokes <code data-md=\"`\">scope[Symbol.enter]()</code>, <code data-md=\"`\">function.using</code> check passes, you get a scoped update","msgtype":"m.text"},"m.relates_to":{"event_id":"$0Dqmn3XLoYGcUHF-q8oCgiQvXoMrY2CqsfKdmxyYDWk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712951243040,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$56qk0zcZDETw32cDhgXPi2dUuRZT7BYcRlt_oD7ffLY"},
{"content":{"body":"How is `new Scope` supposed to know its part of a `using`.","format":"org.matrix.custom.html","formatted_body":"How is <code>new Scope</code> supposed to know its part of a <code>using</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1712951248851,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1MBOxPHcs_4CrddJAliS2wX797qKkBx1MmG5EE6sW3I"},
{"content":{"body":" * How is `new Scope` supposed to know its part of a `using`?","format":"org.matrix.custom.html","formatted_body":" * How is <code>new Scope</code> supposed to know its part of a <code>using</code>?","m.mentions":{},"m.new_content":{"body":"How is `new Scope` supposed to know its part of a `using`?","format":"org.matrix.custom.html","formatted_body":"How is <code>new Scope</code> supposed to know its part of a <code>using</code>?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$1MBOxPHcs_4CrddJAliS2wX797qKkBx1MmG5EE6sW3I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712951253553,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rMkq1Rdh86e2LTMsgTdiZxtHn93yjUikyh14r6TwPYU"},
{"content":{"body":"`function.using`?","format":"org.matrix.custom.html","formatted_body":"<code data-md=\"`\">function.using</code>?","msgtype":"m.text"},"ts":1712951262435,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$LLWNU0JRD5kmTTbTfuwHH2ZMuf37Whd0bP3NGEhzyBk"},
{"content":{"body":"That doesn't work here.","m.mentions":{},"msgtype":"m.text"},"ts":1712951269444,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$H1zFnk9Gb4vGQhYqfy4sf7s_Tpq5qfXLo54pQoGUaNI"},
{"content":{"body":"Consider this:\n```js\nconst createScope = ctx => {\n  new Scope(otherCtx);\n  return new Scope(ctx);\n}\nusing _ = createScope(ctx);\n```","format":"org.matrix.custom.html","formatted_body":"<p>Consider this:</p>\n<pre><code class=\"language-js\">const createScope = ctx =&gt; {\n  new Scope(otherCtx);\n  return new Scope(ctx);\n}\nusing _ = createScope(ctx);\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712951299649,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ra6l1aDcVOI_xGZLtGXLPLEU4j-96TEzgm-PPCy0_Uc"},
{"content":{"body":"brb","m.mentions":{},"msgtype":"m.text"},"ts":1712951307426,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bWuxb-0r3r-uovyyqBgBlg7Z-yqXghxcMl6P8xwYT6s"},
{"content":{"body":"What’s `new Scope(otherCtx)` supposed to do there? You only enter the returned `new Scope(ctx)`?","format":"org.matrix.custom.html","formatted_body":"What’s <code data-md=\"`\">new Scope(otherCtx)</code> supposed to do there? You only enter the returned <code data-md=\"`\">new Scope(ctx)</code>?","msgtype":"m.text"},"ts":1712951377812,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$4oCOjIwwYO4ww9JBDXton2TLobu8QucyNLLYIpEyICw"},
{"content":{"body":"I'm saying that if `function.using` works when I extract `new Scope` out into another function, then it works for every `new Scope` created inside that expression.","format":"org.matrix.custom.html","formatted_body":"I'm saying that if <code>function.using</code> works when I extract <code>new Scope</code> out into another function, then it works for every <code>new Scope</code> created inside that expression.","m.mentions":{},"msgtype":"m.text"},"ts":1712951434247,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$i-GUKM1ibOhwIzhdxBgbZGMJxliy3pAHB5IYy0njI9M"},
{"content":{"body":"```\nclass Scope {\n  // ...\n  [Symbol.enter]() {\n    if (!function.using) throw new Error();\n    // Update Agent.[[AsyncContextMapping]]\n  }\n  [Symbol.dispose]() {\n    // Restore Agent.[[AsyncContextMapping]] \n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre data-md=\"```\"><code>class Scope {\n  // ...\n  [Symbol.enter]() {\n    if (!function.using) throw new Error();\n    // Update Agent.[[AsyncContextMapping]]\n  }\n  [Symbol.dispose]() {\n    // Restore Agent.[[AsyncContextMapping]] \n  }\n}\n</code></pre>","msgtype":"m.text"},"ts":1712951440181,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$MShJu1NEDQWs3dNEUhhXEavJnPhB4LQ2R6f-bxqYVwo"},
{"content":{"body":"It’s only checked when entering?","msgtype":"m.text"},"ts":1712951458060,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$65Wx5Hzaa63aOWVEWpnONdUwfntTsc8OjXj_4pv1Pws"},
{"content":{"body":"```js\nusing _ = (() => {\n  runMyEntireProgramWithFunctionUsingEqualsTrue();\n})();","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">using _ = (() =&gt; {\n  runMyEntireProgramWithFunctionUsingEqualsTrue();\n})();\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712951472216,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MQQbij0okzn1FBtusI5OixYp8Hi0fzKdUVXdagcGyk8"},
{"content":{"body":"Does it matter?","m.mentions":{},"msgtype":"m.text"},"ts":1712951513272,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UH9HQJDEvpHk5I6tzxZSGaOjE0NyiHSFyOxQXiIB0CI"},
{"content":{"body":"```js\nusing _ = {\n  [Symbol.enter]() {\n    runMyEntireProgramWithFunctionUsingEqualsTrue();\n  }\n};\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">using _ = {\n  [Symbol.enter]() {\n    runMyEntireProgramWithFunctionUsingEqualsTrue();\n  }\n};\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712951540695,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VvoeoanKtkS_wA6MLq8pG7o2ZMZI4Y2d4UF0gjkn6ag"},
{"content":{"body":"Either way, that's not what `Symbol.enter` is for. ","format":"org.matrix.custom.html","formatted_body":"Either way, that's not what <code>Symbol.enter</code> is for.","m.mentions":{},"msgtype":"m.text"},"ts":1712951634076,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RMgIKcPgpGdG3vJYMOGNVEqwcX7GALuMHwzZCSeBKKU"},
{"content":{"body":"If we only set `function.using` when calling `[Symbol.enter]()`, that means you're going to want to delay resource setup until `[Symbol.enter]()` is called, which I called out as something we expressly do not want.","format":"org.matrix.custom.html","formatted_body":"If we only set <code>function.using</code> when calling <code>[Symbol.enter]()</code>, that means you're going to want to delay resource setup until <code>[Symbol.enter]()</code> is called, which I called out as something we expressly do not want.","m.mentions":{},"msgtype":"m.text"},"ts":1712951685868,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UDxC6Dp4IruoKfKXoOJ6Kmh-XnmVO12aqjBy-oHRUaQ"},
{"content":{"body":"> <@rbuckton:matrix.org> ```js\n> using _ = (() => {\n>   runMyEntireProgramWithFunctionUsingEqualsTrue();\n> })();\n\nI need to think about this more.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24MQQbij0okzn1FBtusI5OixYp8Hi0fzKdUVXdagcGyk8\">In reply to</a><a href=\"https://matrix.to/#/%40rbuckton%3Amatrix.org\">@rbuckton:matrix.org</a><br /><pre><code class=\"language-js\">using _ = (() =&gt; {\n  runMyEntireProgramWithFunctionUsingEqualsTrue();\n})();\n</code></pre>\n</blockquote></mx-reply>I need to think about this more.","m.relates_to":{"m.in_reply_to":{"event_id":"$MQQbij0okzn1FBtusI5OixYp8Hi0fzKdUVXdagcGyk8"}},"msgtype":"m.text"},"ts":1712951735010,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$s0-ws9xC36jCN-y6_Lm75dK2R35jSNy4GetkSGnJfAo"},
{"content":{"body":"> <@rbuckton:matrix.org> If we only set `function.using` when calling `[Symbol.enter]()`, that means you're going to want to delay resource setup until `[Symbol.enter]()` is called, which I called out as something we expressly do not want.\n\nYah, it returns a new object with a `Symbol.dispose` method. Exactly what’ll happen here.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24UDxC6Dp4IruoKfKXoOJ6Kmh-XnmVO12aqjBy-oHRUaQ\">In reply to</a><a href=\"https://matrix.to/#/%40rbuckton%3Amatrix.org\">@rbuckton:matrix.org</a><br />If we only set <code>function.using</code> when calling <code>[Symbol.enter]()</code>, that means you're going to want to delay resource setup until <code>[Symbol.enter]()</code> is called, which I called out as something we expressly do not want.</blockquote></mx-reply>Yah, it returns a new object with a <code data-md=\"`\">Symbol.dispose</code> method. Exactly what’ll happen here.","m.relates_to":{"m.in_reply_to":{"event_id":"$UDxC6Dp4IruoKfKXoOJ6Kmh-XnmVO12aqjBy-oHRUaQ"}},"msgtype":"m.text"},"ts":1712951783971,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$RHDvWbP6H3cYS1co7YZkMcW2bGDskdxFv4gHeZuw-lw"},
{"content":{"body":"And it still breaks composability. An advanced JS dev might want to subclass or wrap `Scope` with their own class, and now you've broken them.","format":"org.matrix.custom.html","formatted_body":"And it still breaks composability. An advanced JS dev might want to subclass or wrap <code>Scope</code> with their own class, and now you've broken them.","m.mentions":{},"msgtype":"m.text"},"ts":1712951785584,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ufluF0XaMjzHv2HcOMbnRRRET12jSIS6RMLwgMZm9TM"},
{"content":{"body":"> <@jridgewell:matrix.org> Yah, it returns a new object with a `Symbol.dispose` method. Exactly what’ll happen here.\n\nThat is an abuse of the mechanism, and is one of the reasons I don't actually want `[Symbol.enter]`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$RHDvWbP6H3cYS1co7YZkMcW2bGDskdxFv4gHeZuw-lw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Yah, it returns a new object with a <code data-md=\"`\">Symbol.dispose</code> method. Exactly what’ll happen here.</blockquote></mx-reply>That is an abuse of the mechanism, and is one of the reasons I don't actually want <code>[Symbol.enter]</code>.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$RHDvWbP6H3cYS1co7YZkMcW2bGDskdxFv4gHeZuw-lw"}},"msgtype":"m.text"},"ts":1712951863912,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yrT9ytowMqinBtBv3rx-vTLEEhm0VZZqlV9FenVG1Dc"},
{"content":{"body":"IMO, it might be better to have `[Symbol.enter]` be a property and not a method.","format":"org.matrix.custom.html","formatted_body":"IMO, it might be better to have <code>[Symbol.enter]</code> be a property and not a method.","m.mentions":{},"msgtype":"m.text"},"ts":1712951888821,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OlLbwcvtsmABHfdXLBoj68rw_Ag5cbDRFt4G6tmr48Q"},
{"content":{"body":"> <@rbuckton:matrix.org> And it still breaks composability. An advanced JS dev might want to subclass or wrap `Scope` with their own class, and now you've broken them.\n\nI’m looking to replace nesting of `v.run(…, () => {…})` with inline code. Desiging for subclassing or any other power features isn’t the goal.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24ufluF0XaMjzHv2HcOMbnRRRET12jSIS6RMLwgMZm9TM\">In reply to</a><a href=\"https://matrix.to/#/%40rbuckton%3Amatrix.org\">@rbuckton:matrix.org</a><br />And it still breaks composability. An advanced JS dev might want to subclass or wrap <code>Scope</code> with their own class, and now you've broken them.</blockquote></mx-reply>I’m looking to replace nesting of <code data-md=\"`\">v.run(…, () =&gt; {…})</code> with inline code. Desiging for subclassing or any other power features isn’t the goal.","m.relates_to":{"m.in_reply_to":{"event_id":"$ufluF0XaMjzHv2HcOMbnRRRET12jSIS6RMLwgMZm9TM"}},"msgtype":"m.text"},"ts":1712951958620,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$uLSCJlPiqeE3BTM9RWg7FDkLLpk0IA_76qTYrzTjxX0"},
{"content":{"body":"Lets say you have an api like `openFile(path)` that you want to produce a resource. If you want enforcement, you want to write\n```js\nfunction openFile(path) {\n  const handle = new FileHandle(...);\n  return { [Symbol.enter]() { return handle; } };\n}\n```\nnot\n```js\nfunction openFile(path) {\n  return { [Symbol.enter]() { return new FileHndle(path); } };\n}\n```\nOtherwise people could just call `[Symbol.enter]()` repeatedly on the result of the same `openFile` call.\n","format":"org.matrix.custom.html","formatted_body":"<p>Lets say you have an api like <code>openFile(path)</code> that you want to produce a resource. If you want enforcement, you want to write</p>\n<pre><code class=\"language-js\">function openFile(path) {\n  const handle = new FileHandle(...);\n  return { [Symbol.enter]() { return handle; } };\n}\n</code></pre>\n<p>not</p>\n<pre><code class=\"language-js\">function openFile(path) {\n  return { [Symbol.enter]() { return new FileHndle(path); } };\n}\n</code></pre>\n<p>Otherwise people could just call <code>[Symbol.enter]()</code> repeatedly on the result of the same <code>openFile</code> call.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712952046990,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Yqvx-ixH0rntMY3SKjluHqguguhAaCv7tRiSuT2ppj4"},
{"content":{"body":"> <@jridgewell:matrix.org> I’m looking to replace nesting of `v.run(…, () => {…})` with inline code. Desiging for subclassing or any other power features isn’t the goal.\n\n`AsyncContext` is itself a power feature. The Venn diagram of class of developers that will write code using it, and the class of developers that might have reasons to compose it with other code it is nearly a circle.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$uLSCJlPiqeE3BTM9RWg7FDkLLpk0IA_76qTYrzTjxX0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>I’m looking to replace nesting of <code data-md=\"`\">v.run(…, () =&gt; {…})</code> with inline code. Desiging for subclassing or any other power features isn’t the goal.</blockquote></mx-reply><code>AsyncContext</code> is itself a power feature. The Venn diagram of class of developers that will write code using it, and the class of developers that might have reasons to compose it with other code it is nearly a circle.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$uLSCJlPiqeE3BTM9RWg7FDkLLpk0IA_76qTYrzTjxX0"}},"msgtype":"m.text"},"ts":1712952261825,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$l2do0wm0LtFzOix-BIrAcD3ar8u5saXNULD0JWyfNOs"},
{"content":{"body":"> Otherwise people could just call [Symbol.enter]() repeatedly on the result of the same openFile call.\nI don’t see how this example differs from the `Scope` class above?","format":"org.matrix.custom.html","formatted_body":"<blockquote data-md=\">\">Otherwise people could just call [Symbol.enter]() repeatedly on the result of the same openFile call.<br/></blockquote>I don’t see how this example differs from the <code data-md=\"`\">Scope</code> class above?","msgtype":"m.text"},"ts":1712952369895,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$_I8KLSnrn4efDQiztMdr0NB1ydfsxUh8ZfMhlKmBCMY"},
{"content":{"body":"Because there are thousands of reasons to use a file handle via composition.","m.mentions":{},"msgtype":"m.text"},"ts":1712952435807,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2ku6-z3uu3RkTFJ3Avv09Zp9sBSEU6bAN7RNQgYVmc8"},
{"content":{"body":"That was specfically about the “abuse of the mechanism”, right? I don’t see how your single-prepared `FileHandle` that can be entered multiple times differs from the `Scope` class that can be entered multile times? We already hold the `ctx` and `value`, we don’t need to initlize it.","format":"org.matrix.custom.html","formatted_body":"That was specfically about the “abuse of the mechanism”, right? I don’t see how your single-prepared <code data-md=\"`\">FileHandle</code> that can be entered multiple times differs from the <code data-md=\"`\">Scope</code> class that can be entered multile times? We already hold the <code data-md=\"`\">ctx</code> and <code data-md=\"`\">value</code>, we don’t need to initlize it.","msgtype":"m.text"},"ts":1712952572874,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$_CrY6grlML8L_NHaI6XIEd7KNJhnBXy9vI9FLSOjoXM"},
{"content":{"body":"This discussion has done more to convince me that `Symbol.enter` _shouldn't_ be a method than it might have convinced me to give it any kind of special privilege like `function.using`","format":"org.matrix.custom.html","formatted_body":"This discussion has done more to convince me that <code>Symbol.enter</code> <em>shouldn't</em> be a method than it might have convinced me to give it any kind of special privilege like <code>function.using</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712952574542,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hEgv6F7TFdFFPW1wnG4bEbo3caNfkbptjqc74gh8_r8"},
{"content":{"body":"You need to change contexts, which is the actual \"resource\" you're guarding","m.mentions":{},"msgtype":"m.text"},"ts":1712952620978,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$sO2tMdQ4I_Gk2TKWe9Z00O5GdumQigh5TKEhf0z4dOk"},
{"content":{"body":"I assume the essence of what you want is to ensure that developers ship correct programs?","m.mentions":{},"msgtype":"m.text"},"ts":1712952703301,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-spbwFhBgZSxvEsg-HfMBcDHOi-tl7UrSJhWvceNRqs"},
{"content":{"body":"(using this feature)","m.mentions":{},"msgtype":"m.text"},"ts":1712952716045,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xV0apchF9IkueKLZjOk4QAuMQvDGQP4Mx1SiBNEtfNo"},
{"content":{"body":"And what you want is for the runtime to be able to inform the user when they are using the feature incorrectly.","m.mentions":{},"msgtype":"m.text"},"ts":1712952769583,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DwkQO1TcYg6XqQnOlvnNTYwfSOW7a5CNQJxFSQRaNCc"},
{"content":{"body":"The purpose of `[Symbol.enter]` is to guide JS users to proper use of the `using` keyword, while giving sophisticated developers an opt-out mechanism to allow for composability and extend these mechanisms in userland.","format":"org.matrix.custom.html","formatted_body":"The purpose of <code>[Symbol.enter]</code> is to guide JS users to proper use of the <code>using</code> keyword, while giving sophisticated developers an opt-out mechanism to allow for composability and extend these mechanisms in userland.","m.mentions":{},"msgtype":"m.text"},"ts":1712952932752,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-KBD-L6NAu-gHWQq0IQrrr5L5cPu5tHAyVkuS5r2zQ8"},
{"content":{"body":"I think you’re purposefully containing the feature, which prevents us from using it.","msgtype":"m.text"},"ts":1712952977856,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$K7dKn37YwzcCoU5Q6UpzgOeAY6g2UFUAGdgEhABZwWk"},
{"content":{"body":"If it is absolutely imperative that a context cannot be used in this way, then I would argue that it should only be accessible via `run`. ","format":"org.matrix.custom.html","formatted_body":"If it is absolutely imperative that a context cannot be used in this way, then I would argue that it should only be accessible via <code>run</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1712953000470,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3gF9UoSvU3icVBI5Z-RUFvyMAn0Wkgbqeteeo-uJe0Y"},
{"content":{"body":"I'm purposefully *not* constraining the feature.","format":"org.matrix.custom.html","formatted_body":"I'm purposefully <em>not</em> constraining the feature.","m.mentions":{},"msgtype":"m.text"},"ts":1712953024518,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$pemWDCaIB-2ULXTWw9PypuU5LQrx_0iXz4e9fZ2if_w"},
{"content":{"body":"We have a valid use case, and you’re telling me we’re abusing the mechanism!","msgtype":"m.text"},"ts":1712953057709,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$667SzV3mWF2vi0IW4RaeRVFTplnLSzCfm5MKETQq4eg"},
{"content":{"body":"I think you’re going to be sorely disapoointed with userland `Symbol.enter` functions, and if we land on `get [Symbol.dispose]()` then that’ll be abused too.","format":"org.matrix.custom.html","formatted_body":"I think you’re going to be sorely disapoointed with userland <code data-md=\"`\">Symbol.enter</code> functions, and if we land on <code data-md=\"`\">get [Symbol.dispose]()</code> then that’ll be abused too.","msgtype":"m.text"},"ts":1712953128225,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$06vYVz10KvNSHsViPBg_6DGYJTIBtS4d4u7GdC8FKp8"},
{"content":{"body":"Yes, I think its a potential use case, but I'm not sure I'm comfortable with the complexity it adds as it will make composition impossible.","m.mentions":{},"msgtype":"m.text"},"ts":1712953162806,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ESi5cqRU1e0_dKRaQpkM9mJgKqNlhbSfdb7URRxRxRE"},
{"content":{"body":"* I think you’re going to be sorely disapoointed with userland `Symbol.enter` functions, and if the proposal doesn’t move forward, `get [Symbol.dispose]()` will be abused too.","format":"org.matrix.custom.html","formatted_body":"I think you’re going to be sorely disapoointed with userland <code data-md=\"`\">Symbol.enter</code> functions, and if the proposal doesn’t move forward, <code data-md=\"`\">get [Symbol.dispose]()</code> will be abused too.","m.new_content":{"body":"I think you’re going to be sorely disapoointed with userland `Symbol.enter` functions, and if the proposal doesn’t move forward, `get [Symbol.dispose]()` will be abused too.","format":"org.matrix.custom.html","formatted_body":"I think you’re going to be sorely disapoointed with userland <code data-md=\"`\">Symbol.enter</code> functions, and if the proposal doesn’t move forward, <code data-md=\"`\">get [Symbol.dispose]()</code> will be abused too.","msgtype":"m.text"},"m.relates_to":{"event_id":"$06vYVz10KvNSHsViPBg_6DGYJTIBtS4d4u7GdC8FKp8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712953301827,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$1u4PHFUFddsFuXU5y79ASZyLS_S1YSecLvHqXPKW2Nc"},
{"content":{"body":"Adding a feature like `function.using` would cause significant problems with adoption. Users would be confused why some resources work with `using` and `DisposableStack`, while others don't. It would turn the feature into a minefield.","format":"org.matrix.custom.html","formatted_body":"Adding a feature like <code>function.using</code> would cause significant problems with adoption. Users would be confused why some resources work with <code>using</code> and <code>DisposableStack</code>, while others don't. It would turn the feature into a minefield.","m.mentions":{},"msgtype":"m.text"},"ts":1712953339021,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZIHlFSKeQp5bb0jD1BiMWMKlp7Hh5Zgm_Reg8B4ret4"},
{"content":{"body":"`[Symbol.enter]` is, at most, compromise. It still allows `using` and `DisposableStack` to be used interchangably.","format":"org.matrix.custom.html","formatted_body":"<code>[Symbol.enter]</code> is, at most, compromise. It still allows <code>using</code> and <code>DisposableStack</code> to be used interchangably.","m.mentions":{},"msgtype":"m.text"},"ts":1712953383163,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZU8MeQJZwaQgKiaR-01sIQNu96vDZEkSAgDKcN77CGc"},
{"content":{"body":"i was wondering this during plenary: can TS build [[nodiscard]]?","m.mentions":{},"msgtype":"m.text"},"ts":1712953619004,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$KvhbFCPEOOg-KNIp1GxaBhXC4golunIFrHl0_R3gs7o"},
{"content":{"body":"`[Symbol.enter]` is supposed to be the \"staff entry only\" mechanism to opt-out. `Scope` could use that, and maybe even `get [Symbol.dispose]()` for good measure, and perform implicit cleanup and then throw when the stack of `context` switches doesn't match what's expected, and that's likely to catch the majority of user errors.","format":"org.matrix.custom.html","formatted_body":"<code>[Symbol.enter]</code> is supposed to be the \"staff entry only\" mechanism to opt-out. <code>Scope</code> could use that, and maybe even <code>get [Symbol.dispose]()</code> for good measure, and perform implicit cleanup and then throw when the stack of <code>context</code> switches doesn't match what's expected, and that's likely to catch the majority of user errors.","m.mentions":{},"msgtype":"m.text"},"ts":1712953637298,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$6adMjRFcutk06oQfOWtsOgbDn-cIYHkbdUBKNE1KFtM"},
{"content":{"body":"> <@shuyuguo:matrix.org> i was wondering this during plenary: can TS build [[nodiscard]]?\n\nIf that's type information that would affect runtime emit, then no.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$KvhbFCPEOOg-KNIp1GxaBhXC4golunIFrHl0_R3gs7o?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>i was wondering this during plenary: can TS build [[nodiscard]]?</blockquote></mx-reply>If that's type information that would affect runtime emit, then no.","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$KvhbFCPEOOg-KNIp1GxaBhXC4golunIFrHl0_R3gs7o"}},"msgtype":"m.text"},"ts":1712953653229,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tFAg9OV7QHNX6A2L5fyMNO5_DKIQHQH1ideNI1F0cDg"},
{"content":{"body":"If we have to emit a suboptimal wrapper around every single operation to ensure that it's doing the right thing, then no.","m.mentions":{},"msgtype":"m.text"},"ts":1712953699920,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1xYigoSRcfZeQUjSWnZ66MleSoW2KnAUTXCEAKWn45s"},
{"content":{"body":"what about nodiscard as a type error/warning?","m.mentions":{},"msgtype":"m.text"},"ts":1712953723418,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$gVYEtQWhFDHvTVhM2f74W70vhBHV7jKuPRDgr6kz4wQ"},
{"content":{"body":"I proposed it to typescript-eslint for `using`: https://github.com/typescript-eslint/typescript-eslint/issues/8255","format":"org.matrix.custom.html","formatted_body":"I proposed it to typescript-eslint for <code>using</code>: https://github.com/typescript-eslint/typescript-eslint/issues/8255","m.mentions":{},"msgtype":"m.text"},"ts":1712953732108,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$hp6DK6gPo1gRvqhgqxpshEgeUVVRHDlN9PV2Xkhhv-4"},
{"content":{"body":"> <@abotella:igalia.com> what about nodiscard as a type error/warning?\n\nWe've considered that. It becomes complicated when you have to mark use sites such as parameters as well. It's not out of the question, but we haven't implemented it yet.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$gVYEtQWhFDHvTVhM2f74W70vhBHV7jKuPRDgr6kz4wQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>what about nodiscard as a type error/warning?</blockquote></mx-reply>We've considered that. It becomes complicated when you have to mark use sites such as parameters as well. It's not out of the question, but we haven't implemented it yet.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$gVYEtQWhFDHvTVhM2f74W70vhBHV7jKuPRDgr6kz4wQ"}},"msgtype":"m.text"},"ts":1712953790955,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BgWYaZV5HikkyeLKoiBdFZIvFlPUn3ddnqK-XVcu2A0"},
{"content":{"body":"You want both `using` and `DisposableStack.prototype.use()` to be considered valid use sites.","format":"org.matrix.custom.html","formatted_body":"You want both <code>using</code> and <code>DisposableStack.prototype.use()</code> to be considered valid use sites.","m.mentions":{},"msgtype":"m.text"},"ts":1712953878257,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fY5qf6jr2TorE07FSI1OLc7FEgOjBfikbdXEPC9wywc"},
{"content":{"body":"And you want users to be able to build their own `DisposableStack` subclasses or wrappers that can also declare a parameter as a valid use site.","format":"org.matrix.custom.html","formatted_body":"And you want users to be able to build their own <code>DisposableStack</code> subclasses or wrappers that can also declare a parameter as a valid use site.","m.mentions":{},"msgtype":"m.text"},"ts":1712953907489,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Sq1pQpAAHX7IQaPJDVcbPut19qhlwZlJdONdnY9bpOY"},
{"content":{"body":"e.g., for polyfills and shims, if nothing else.","m.mentions":{},"msgtype":"m.text"},"ts":1712953925532,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ns_W5sMA9B1KT7LrEVDzDMaVMVV-sLLqxtTq8N1i-Ko"},
{"content":{"body":"> <@rbuckton:matrix.org> `[Symbol.enter]` is supposed to be the \"staff entry only\" mechanism to opt-out. `Scope` could use that, and maybe even `get [Symbol.dispose]()` for good measure, and perform implicit cleanup and then throw when the stack of `context` switches doesn't match what's expected, and that's likely to catch the majority of user errors.\n\nThis allows mallicous dynamic scoping of a caller’s variable, and it’ll get shot down if we propose it.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%246adMjRFcutk06oQfOWtsOgbDn-cIYHkbdUBKNE1KFtM\">In reply to</a><a href=\"https://matrix.to/#/%40rbuckton%3Amatrix.org\">@rbuckton:matrix.org</a><br /><code>[Symbol.enter]</code> is supposed to be the \"staff entry only\" mechanism to opt-out. <code>Scope</code> could use that, and maybe even <code>get [Symbol.dispose]()</code> for good measure, and perform implicit cleanup and then throw when the stack of <code>context</code> switches doesn't match what's expected, and that's likely to catch the majority of user errors.</blockquote></mx-reply>This allows mallicous dynamic scoping of a caller’s variable, and it’ll get shot down if we propose it.","m.relates_to":{"m.in_reply_to":{"event_id":"$6adMjRFcutk06oQfOWtsOgbDn-cIYHkbdUBKNE1KFtM"}},"msgtype":"m.text"},"ts":1712953985225,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$CWwonL7mT6xQ769yaVcsQqveOvNPEjoH2y8gH8fWFW4"},
{"content":{"body":"I've given it quite a bit of thought.","m.mentions":{},"msgtype":"m.text"},"ts":1712953993677,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_jMNPpLX1P-CRwu8iv3GugmLHX0QINc53qQEvKLmur0"},
{"content":{"body":"I don't think we need `AsyncContext.Scope`. For me it's a nice to have, and changing strict enforcement to allow it seems to raise more problems than it solves.","format":"org.matrix.custom.html","formatted_body":"I don't think we need <code>AsyncContext.Scope</code>. For me it's a nice to have, and changing strict enforcement to allow it seems to raise more problems than it solves.","m.mentions":{},"msgtype":"m.text"},"ts":1712954065915,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$a94qJsW0qX3fIhJCYLlOkr9FHaFlV35i3RhgnvoS2MA"},
{"content":{"body":"I'm not sure you can get the guarantees you want from `using` without introducing confusion and poisoning adoption.","format":"org.matrix.custom.html","formatted_body":"I'm not sure you can get the guarantees you want from <code>using</code> without introducing confusion and poisoning adoption.","m.mentions":{},"msgtype":"m.text"},"ts":1712954078716,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wrSjz80cEPrbHuuwVdtyVtuVUOXTEo7TiipOTEABQnc"},
{"content":{"body":".NET has `ExecutionContext`, which is essentially the same as `AsyncContext`. It supports `Run`, as well as `Capture` and `Restore`, flow control, and `Dispose`, and has for decades. It's unfortunate that `AsyncContext` has far stricter requirements.","format":"org.matrix.custom.html","formatted_body":".NET has <code>ExecutionContext</code>, which is essentially the same as <code>AsyncContext</code>. It supports <code>Run</code>, as well as <code>Capture</code> and <code>Restore</code>, flow control, and <code>Dispose</code>, and has for decades. It's unfortunate that <code>AsyncContext</code> has far stricter requirements.","m.mentions":{},"msgtype":"m.text"},"ts":1712954287939,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XjeM51CwKjqzzTx9VECZcB9y4r7BctkbRQ6jvE2927Q"},
{"content":{"body":"This steps all over the explicit-resource-management proposal, but what if we modify the runtime evaluation of `using` to handle this internally? Don’t expose a `dispose` or `enter` method.","format":"org.matrix.custom.html","formatted_body":"This steps all over the explicit-resource-management proposal, but what if we modify the runtime evaluation of <code data-md=\"`\">using</code> to handle this internally? Don’t expose a <code data-md=\"`\">dispose</code> or <code data-md=\"`\">enter</code> method.","msgtype":"m.text"},"ts":1712954304489,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ZevlmvG0g7coWcR5Hi9Up_pUWQ22sXLR3FLvE25wc5c"},
{"content":{"body":"It still breaks symetry, you can’t wrap it, but it solves the nesting.","msgtype":"m.text"},"ts":1712954340156,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Lr_Okki_RAZqeqzZLyB2kNmy0RrsQdQbsyh4U8DzyMc"},
{"content":{"body":"How? That sounds like breaking composability.","m.mentions":{},"msgtype":"m.text"},"ts":1712954342377,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QS91X66NnFVvblw9K4hgLTMTZZ9onUVb57llIBWAmfw"},
{"content":{"body":"* It still breaks symetry with `DisposableStack`, you can’t wrap it, but it solves the nesting.","format":"org.matrix.custom.html","formatted_body":"It still breaks symetry with <code data-md=\"`\">DisposableStack</code>, you can’t wrap it, but it solves the nesting.","m.new_content":{"body":"It still breaks symetry with `DisposableStack`, you can’t wrap it, but it solves the nesting.","format":"org.matrix.custom.html","formatted_body":"It still breaks symetry with <code data-md=\"`\">DisposableStack</code>, you can’t wrap it, but it solves the nesting.","msgtype":"m.text"},"m.relates_to":{"event_id":"$Lr_Okki_RAZqeqzZLyB2kNmy0RrsQdQbsyh4U8DzyMc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712954348781,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$8MVhegYy1E4Ny4qVFMHH7s7o3eLMwngj9exFarEPvuk"},
{"content":{"body":"If I can't store a disposable in a field on my class so that I can clean it up when my class is disposed, then resource management is useless.","m.mentions":{},"msgtype":"m.text"},"ts":1712954383743,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IDISaeQXt4lZL5mbbG29vQSzniS8jCRHO4aPqqLBMVk"},
{"content":{"body":"Again, I’m not trying to solve composibility. Your choice is `v.run(…)` or `using _ = Scope(…)`","format":"org.matrix.custom.html","formatted_body":"Again, I’m not trying to solve composibility. Your choice is <code data-md=\"`\">v.run(…)</code> or <code data-md=\"`\">using _ = Scope(…)</code>","msgtype":"m.text"},"ts":1712954405407,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$itfB69GiqmtI5es_EYQWf01JyD_CK69mDKm8zjWkfb4"},
{"content":{"body":"Any solution to `using _ = Scope(...)` _must not_ break composability in general, and should not poison adoption.","format":"org.matrix.custom.html","formatted_body":"Any solution to <code>using _ = Scope(...)</code> <em>must not</em> break composability in general, and should not poison adoption.","m.mentions":{},"msgtype":"m.text"},"ts":1712954510984,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Zuqasuxcx2utlQ__Gx3tBySvXv4y84zelyTZHH5tp8A"},
{"content":{"body":"\"in general\" meaning, anything else that isn't `new Scope`","format":"org.matrix.custom.html","formatted_body":"\"in general\" meaning, anything else that isn't <code>new Scope</code>","m.mentions":{},"msgtype":"m.text"},"ts":1712954549459,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cOTdjeySbG_S3DBbid3-dSbcmA_Dns27Ax04FNMH264"},
{"content":{"body":"But the altenative isn’t composable either.","msgtype":"m.text"},"ts":1712954550850,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$F6JiFD5gWPIb9Ts4YZrEmKacuCRxN1SQugcYawKN6Io"},
{"content":{"body":" * Any solution to `using _ = new Scope(...)` _must not_ break composability in general, and should not poison adoption.","format":"org.matrix.custom.html","formatted_body":" * Any solution to <code>using _ = new Scope(...)</code> <em>must not</em> break composability in general, and should not poison adoption.","m.mentions":{},"m.new_content":{"body":"Any solution to `using _ = new Scope(...)` _must not_ break composability in general, and should not poison adoption.","format":"org.matrix.custom.html","formatted_body":"Any solution to <code>using _ = new Scope(...)</code> <em>must not</em> break composability in general, and should not poison adoption.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Zuqasuxcx2utlQ__Gx3tBySvXv4y84zelyTZHH5tp8A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712954554753,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$trCbuu27TX-zfiXQh07WB1BKQiemTnc-mfl_6BkYqJg"},
{"content":{"body":"Your class field hypothetical would only be able to expose the new context within the the scope of its methods with `this.v.run(…)`, same as with `using _ = this.scope;`","format":"org.matrix.custom.html","formatted_body":"Your class field hypothetical would only be able to expose the new context within the the scope of its methods with <code data-md=\"`\">this.v.run(…)</code>, same as with <code data-md=\"`\">using _ = this.scope;</code>","msgtype":"m.text"},"ts":1712954658939,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$p-8Cqy-KhUqR-kLk4KnPkxcCE1UPSPHGnsCker6H7rE"},
{"content":{"body":"are you planning to freeze `[Symbol.dispose]` and `[Symbol.enter]` on `Scope`?","format":"org.matrix.custom.html","formatted_body":"are you planning to freeze <code>[Symbol.dispose]</code> and <code>[Symbol.enter]</code> on <code>Scope</code>?","m.mentions":{},"msgtype":"m.text"},"ts":1712954660611,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IFAM1hwBz3BUbTOnE9KvCFWpy75DVs82vs1NRHYVnoM"},
{"content":{"body":"Neither exist","msgtype":"m.text"},"ts":1712954675822,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$uCU4d8ehqDjySRrOpoX6JzsDzhuIUZsmEIG1i6ijnMU"},
{"content":{"body":"It’s not a traditional disposable, can’t be use with `*Stacks`","format":"org.matrix.custom.html","formatted_body":"It’s not a traditional disposable, can’t be use with <code data-md=\"`\">*Stacks</code>","msgtype":"m.text"},"ts":1712954720277,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$rO8Oba8xvjB0GgU4k8lQyJvrBQDF1te-mxpbHY6WvW8"},
{"content":{"body":"Can’t manually call the methods to enter or exit.","msgtype":"m.text"},"ts":1712954732561,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$dL8v_AQ4VTogLESm9NO-SwNHXoCujw8UyOBJ0Dihs7c"},
{"content":{"body":"Can’t leak, only exists within `using`’s scope.","format":"org.matrix.custom.html","formatted_body":"Can’t leak, only exists within <code data-md=\"`\">using</code>’s scope.","msgtype":"m.text"},"ts":1712954743096,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$8rE_m_lyqvz7XljQSRCDhNG33Cx8n9r24m50EmNpyA4"},
{"content":{"body":"> <@jridgewell:matrix.org> Your class field hypothetical would only be able to expose the new context within the the scope of its methods with `this.v.run(…)`, same as with `using _ = this.scope;`\n\nMy hypothetical might be something like:\n\n```js\nclass NamedScope {\n  name;\n  #scope;\n  constructor(ctx, name) {\n    this.name = name;\n    this.#scope = new AsyncContext.Scope(ctx);\n  }\n  [Symbol.dispose]() {\n    using _ = this.#scope;\n    this.#scope = undefined;\n  }\n}\n\nusing scope = new NamedScope(ctx, \"foo\");\n...\n```\n\n","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$p-8Cqy-KhUqR-kLk4KnPkxcCE1UPSPHGnsCker6H7rE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Your class field hypothetical would only be able to expose the new context within the the scope of its methods with <code data-md=\"`\">this.v.run(…)</code>, same as with <code data-md=\"`\">using _ = this.scope;</code></blockquote></mx-reply><p>My hypothetical might be something like:</p>\n<pre><code class=\"language-js\">class NamedScope {\n  name;\n  #scope;\n  constructor(ctx, name) {\n    this.name = name;\n    this.#scope = new AsyncContext.Scope(ctx);\n  }\n  [Symbol.dispose]() {\n    using _ = this.#scope;\n    this.#scope = undefined;\n  }\n}\n\nusing scope = new NamedScope(ctx, \"foo\");\n...\n</code></pre>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$p-8Cqy-KhUqR-kLk4KnPkxcCE1UPSPHGnsCker6H7rE"}},"msgtype":"m.text"},"ts":1712954788813,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Waw-pY9qUqDfgB0YNfT1pD4otdaujvwoJiCENQZRmKo"},
{"content":{"body":"What would that be with the current AsyncContext’s `run()`?","format":"org.matrix.custom.html","formatted_body":"What would that be with the current AsyncContext’s <code data-md=\"`\">run()</code>?","msgtype":"m.text"},"ts":1712954851132,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$xgpgs6byde9_Ikk-dC7MBqRt__CMlcqxuMVtVsZuGDk"},
{"content":{"body":"> <@jridgewell:matrix.org> Neither exist\n\nI'm talking about before a hypothetical discussion about alternatives. If `Scope` was never going to have them to begin with, then `using` definitely doesn't seem like the right fit.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$uCU4d8ehqDjySRrOpoX6JzsDzhuIUZsmEIG1i6ijnMU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Neither exist</blockquote></mx-reply>I'm talking about before a hypothetical discussion about alternatives. If <code>Scope</code> was never going to have them to begin with, then <code>using</code> definitely doesn't seem like the right fit.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$uCU4d8ehqDjySRrOpoX6JzsDzhuIUZsmEIG1i6ijnMU"}},"msgtype":"m.text"},"ts":1712954896438,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cocof7gEn8H1pzzzERkz0dFJ1p9PAUHAii2UgX0-ATM"},
{"content":{"body":"`class NamedScope extends Scope {}` might work, `Scope` could hold a `[[Dispose]]` slot.","format":"org.matrix.custom.html","formatted_body":"<code data-md=\"`\">class NamedScope extends Scope {}</code> might work, <code data-md=\"`\">Scope</code> could hold a <code data-md=\"`\">[[Dispose]]</code> slot.","msgtype":"m.text"},"ts":1712954905789,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$rPB6XCFuVvPhjdnGZWs6nyZHG9mfZrQTKugUF9_eDsc"},
{"content":{"body":"There is no `[[Dispose]]` slot in resource management. If what you're proposing requires dramatic changes to resource management for one specific case, it seems more like you need an independent syntax.","format":"org.matrix.custom.html","formatted_body":"There is no <code>[[Dispose]]</code> slot in resource management. If what you're proposing requires dramatic changes to resource management for one specific case, it seems more like you need an independent syntax.","m.mentions":{},"msgtype":"m.text"},"ts":1712955041160,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8fBYFwBuSUKoth8-giPRu_4Mu_xwZCqOsrcpk2IpILc"},
{"content":{"body":"```\nwith scope (ctx) {\n}\n```\nor something. What you want to dispose is not a resource, and it doesn't fit within the semantics of `using`.","format":"org.matrix.custom.html","formatted_body":"<pre><code>with scope (ctx) {\n}\n</code></pre>\n<p>or something. What you want to dispose is not a resource, and it doesn't fit within the semantics of <code>using</code>.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712955097596,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KPT4Kz-zn_vTo4SIPKTd4jaymyb9aefDk5YmpKJpW7g"},
{"content":{"body":"or even `using scope (ctx) {}`, maybe.","format":"org.matrix.custom.html","formatted_body":"or even <code>using scope (ctx) {}</code>, maybe.","m.mentions":{},"msgtype":"m.text"},"ts":1712955141900,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UiMQ1WpoNbg6zlRTZzf9ku3Ym3764SECCuOEw-9TbYg"},
{"content":{"body":"It would require an additional branch in `AddDisposableResource` and 2 additional `hint`s to differentiate sync/async syntax from sync/async `stack.use()`","format":"org.matrix.custom.html","formatted_body":"It would require an additional branch in <code data-md=\"`\">AddDisposableResource</code> and 2 additional <code data-md=\"`\">hint</code>s to differentiate sync/async syntax from sync/async <code data-md=\"`\">stack.use()</code>","msgtype":"m.text"},"ts":1712955156050,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$DrHVfvWvZG6K_AggkMI_5Bm-TZpGpEcgWwDsoJj4o1c"},
{"content":{"body":"You're asking to carve out a narrow corner case for a single type that can't be used the way any other resource could be used. ","m.mentions":{},"msgtype":"m.text"},"ts":1712955247147,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KnWTf-lBtgZ8TsEfTM25u_i9BcXD4x-SSRxzjQ0XHeU"},
{"content":{"body":"> <@rbuckton:matrix.org> or even `using scope (ctx) {}`, maybe.\n\nThat at least gets rid of the TCP issues with `run()`, but still requires a nesting layer. Maybe that’s ok.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24UiMQ1WpoNbg6zlRTZzf9ku3Ym3764SECCuOEw-9TbYg\">In reply to</a><a href=\"https://matrix.to/#/%40rbuckton%3Amatrix.org\">@rbuckton:matrix.org</a><br />or even <code>using scope (ctx) {}</code>, maybe.</blockquote></mx-reply>That at least gets rid of the TCP issues with <code data-md=\"`\">run()</code>, but still requires a nesting layer. Maybe that’s ok.","m.relates_to":{"m.in_reply_to":{"event_id":"$UiMQ1WpoNbg6zlRTZzf9ku3Ym3764SECCuOEw-9TbYg"}},"msgtype":"m.text"},"ts":1712955279144,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$YOmzu2T6D7-28mYF8QYoE0PKFlohvF_Mz9AKGxw5q0k"},
{"content":{"body":"Yes, I’m willing to privelege language features above userland implemenations.","msgtype":"m.text"},"ts":1712955305422,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$2ut34b5hTMmmajYUOgtMPsjJaKrE2L4E2d_ZCC20UfA"},
{"content":{"body":"We do that all the time.","msgtype":"m.text"},"ts":1712955336986,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ocz4fpI9aqvCPZs5r1g-lwU_T4mdNslbddJlqss-pOs"},
{"content":{"body":"If there is to be a special purpose carve-out, i'd much rather there be a syntactic opt-in so users could differentiate between what's safe to refactor to a `DisposableStack` and what isn't.","format":"org.matrix.custom.html","formatted_body":"If there is to be a special purpose carve-out, i'd much rather there be a syntactic opt-in so users could differentiate between what's safe to refactor to a <code>DisposableStack</code> and what isn't.","m.mentions":{},"msgtype":"m.text"},"ts":1712955364779,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mZF6XLRMMKcaBEGq6cncBfE0S_wALC3NeBWJsoBOARc"},
{"content":{"body":"> <@jridgewell:matrix.org> Yes, I’m willing to privelege language features above userland implemenations.\n\nThere is a line though. `AbortSignal` does the same thing and it's one of the worst parts of the design. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$2ut34b5hTMmmajYUOgtMPsjJaKrE2L4E2d_ZCC20UfA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Yes, I’m willing to privelege language features above userland implemenations.</blockquote></mx-reply>There is a line though. <code>AbortSignal</code> does the same thing and it's one of the worst parts of the design.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$2ut34b5hTMmmajYUOgtMPsjJaKrE2L4E2d_ZCC20UfA"}},"msgtype":"m.text"},"ts":1712955431307,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UFvg1_DROixc8-GrsR03AURyJX6kI62iedb05Y9qiXc"},
{"content":{"body":"I was thinking more `Promsie` fast paths","format":"org.matrix.custom.html","formatted_body":"I was thinking more <code data-md=\"`\">Promsie</code> fast paths","msgtype":"m.text"},"ts":1712955495378,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$R23Byvr7O4o18VgrytUUAp2Lx5IrA0ijXCQ6mEUThSE"},
{"content":{"body":"* I was thinking more `Promise` fast paths","format":"org.matrix.custom.html","formatted_body":"I was thinking more <code data-md=\"`\">Promise</code> fast paths","m.new_content":{"body":"I was thinking more `Promise` fast paths","format":"org.matrix.custom.html","formatted_body":"I was thinking more <code data-md=\"`\">Promise</code> fast paths","msgtype":"m.text"},"m.relates_to":{"event_id":"$R23Byvr7O4o18VgrytUUAp2Lx5IrA0ijXCQ6mEUThSE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712955502962,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$TRN7wozl2Mg4D0Bvzi7hYDcttctKDNBqn7A7QccVmJ4"},
{"content":{"body":"I can understand special cases like skipping an Await for a native `Promise` but not a thenable. You're already async at that point. But not for a corner case that might cause users to see an entire feature as suspect.","format":"org.matrix.custom.html","formatted_body":"I can understand special cases like skipping an Await for a native <code>Promise</code> but not a thenable. You're already async at that point. But not for a corner case that might cause users to see an entire feature as suspect.","m.mentions":{},"msgtype":"m.text"},"ts":1712955542901,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zqyNPB9gNuDHDC-wNsN0gueAfy10OojnYQAR-tc64oA"},
{"content":{"body":"I was too. This is not a Promise fast path.","m.mentions":{},"msgtype":"m.text"},"ts":1712955556877,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oVVW5JlBl0AkFCFYvx-DCA4gwfgbY_sqyKlDUGFkgK4"},
{"content":{"body":"Promise fast paths require you to practically go out of your way to observe them and people have been preaching against Zalgo for a decade so people don't take a dependency on ordering. ","m.mentions":{},"msgtype":"m.text"},"ts":1712955699959,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mLRWVvqRCSm8ZkmMmiqGDgJGNiQpwgRmjvMjebWw_eU"},
{"content":{"body":"What I don't understand is that if `AsyncContext.Scope` wasn't going to have a `[Symbol.enter]` or `[Symbol.dispose]` to begin with, and planned to special case `AddDisposableResource`, why would a dangling `[Symbol.enter]` have even been a concern to begin with?","format":"org.matrix.custom.html","formatted_body":"What I don't understand is that if <code>AsyncContext.Scope</code> wasn't going to have a <code>[Symbol.enter]</code> or <code>[Symbol.dispose]</code> to begin with, and planned to special case <code>AddDisposableResource</code>, why would a dangling <code>[Symbol.enter]</code> have even been a concern to begin with?","m.mentions":{},"msgtype":"m.text"},"ts":1712955830764,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2PwnwrLMSRVLfS0_Bj6h8-H91l_K8UfIU0t_3TiSztQ"},
{"content":{"body":"Yah, this would need to throw if you used it incorrectly. It’s a bit different from fast-path, but I think it’s still a priveleging language features thing.","msgtype":"m.text"},"ts":1712955880006,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$8NvUqDgNaNBbyjlNm2-HGa9PJ6OBOl4HnRgDX1slums"},
{"content":{"body":"This is a different approach.","msgtype":"m.text"},"ts":1712955895865,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$CloyCniKTvD7sR9n0mwn1Icl9CjVVSgYIWfyZyNVtJk"},
{"content":{"body":"If we can’t get a `function.using` to detect a public `Scope[Symbol.enter]` is being invoked with syntatic `using`, then we can’t expose that functionality.","format":"org.matrix.custom.html","formatted_body":"If we can’t get a <code data-md=\"`\">function.using</code> to detect a public <code data-md=\"`\">Scope[Symbol.enter]</code> is being invoked with syntatic <code data-md=\"`\">using</code>, then we can’t expose that functionality.","msgtype":"m.text"},"ts":1712955953848,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Cd8dUzA4DF68E4nyMRUlTEKyPCDW4p7vznmoYytzLrE"},
{"content":{"body":"So what if we didn’t expose anything?","msgtype":"m.text"},"ts":1712955960606,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$YmR8Rb7ks2br9ERcieYBAHUT9P6cpUga2TyANoGhApA"},
{"content":{"body":"Move it all internal to the language.","msgtype":"m.text"},"ts":1712955971571,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$LWzqFMaQM_Q6ZhvgJ0eygbMdoEuTRvOVaEIabCL5tWo"},
{"content":{"body":"That still wouldn't address my concern about poisoning adoption. If users expect that `using x = res()` and `stack.use(res())` can be used interchangeably, or that you can use the fairly common \"extract to new function\" refactoring, then having a single thing that breaks those expectations makes the feature untrustworthy. The only way to address that would be a syntactic opt-in.","format":"org.matrix.custom.html","formatted_body":"That still wouldn't address my concern about poisoning adoption. If users expect that <code>using x = res()</code> and <code>stack.use(res())</code> can be used interchangeably, or that you can use the fairly common \"extract to new function\" refactoring, then having a single thing that breaks those expectations makes the feature untrustworthy. The only way to address that would be a syntactic opt-in.","m.mentions":{},"msgtype":"m.text"},"ts":1712956101454,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$EHW3LF23bBkCbaaMB_P4LaNr69532bRrPMNa-UKvW3w"},
{"content":{"body":"And with my TypeScript hat on, there's no way we could type `Scope` in the type system if it depends on a private slot.","format":"org.matrix.custom.html","formatted_body":"And with my TypeScript hat on, there's no way we could type <code>Scope</code> in the type system if it depends on a private slot.","m.mentions":{},"msgtype":"m.text"},"ts":1712956195015,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Gfw_LETWIhSnOaGlbEKO16ca1jr9HcqRjOclOjP-EcE"},
{"content":{"body":"Well, maybe not no way. No good way.","m.mentions":{},"msgtype":"m.text"},"ts":1712956212478,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hhaxSMHeENbV2mQYlSFcpXOTxFS6_Ez3BKOpnZKItRk"},
{"content":{"body":"What would you type?","msgtype":"m.text"},"ts":1712956234323,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Cr4XrGf-NyZFaIgY3jEe0XupfavblcnnWLYPoGYN6io"},
{"content":{"body":"The syntatic `using`?","format":"org.matrix.custom.html","formatted_body":"The syntatic <code data-md=\"`\">using</code>?","msgtype":"m.text"},"ts":1712956245073,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$3udhY0kxDV0o2s8dIaYxhggsRYzyfBphgDoaP7qSlmg"},
{"content":{"body":"We'd have to have a declaration of `class Scope { #_ }` and the checker would have to not only verify such a type was reachable, but that it was nominally checked as a result of the private field.","format":"org.matrix.custom.html","formatted_body":"We'd have to have a declaration of <code>class Scope { #_ }</code> and the checker would have to not only verify such a type was reachable, but that it was nominally checked as a result of the private field.","m.mentions":{},"msgtype":"m.text"},"ts":1712956268521,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Bc7RN-v16qY8QP0d31myrTOUyGQ3jxfuu0Axb8BKL-4"},
{"content":{"body":"Yes","m.mentions":{},"msgtype":"m.text"},"ts":1712956271833,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JDZojAxRyrrk2iEetSUHE_pqCYPgyRipOxe5DCQq68A"},
{"content":{"body":"It is a type error if the RHS of a `using` is neither `null`, `undefined`, nor `Disposable`.","format":"org.matrix.custom.html","formatted_body":"It is a type error if the RHS of a <code>using</code> is neither <code>null</code>, <code>undefined</code>, nor <code>Disposable</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1712956298759,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2NWkZMkPQd1hXAjF6AGKERBIgv_4oM1L3j6cQyOR-WY"},
{"content":{"body":"Wouldn’t it just be `DisposableInterface | Scope`?","format":"org.matrix.custom.html","formatted_body":"Wouldn’t it just be <code data-md=\"`\">DisposableInterface | Scope</code>?","msgtype":"m.text"},"ts":1712956319239,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$hVwOCsz4JMcjOdSYaDa3BOmjWsruIyliLIlT9ee1r3A"},
{"content":{"body":"And `stack.use()` would only accept `DisposableInterface`","format":"org.matrix.custom.html","formatted_body":"And <code data-md=\"`\">stack.use()</code> would only accept <code data-md=\"`\">DisposableInterface</code>","msgtype":"m.text"},"ts":1712956354363,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$pRajPGpRYoMfZaa-0XYuWuuWY6suYgDejHOohedRVZQ"},
{"content":{"body":"You need a `Scope` that isn't comparable via a structural comparison.","format":"org.matrix.custom.html","formatted_body":"You need a <code>Scope</code> that isn't comparable via a structural comparison.","m.mentions":{},"msgtype":"m.text"},"ts":1712956356295,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MvHKCiQ831_2YFX8o6IvzPIhtYcqE1aKwW40Q927viI"},
{"content":{"body":"Oh, ok.","msgtype":"m.text"},"ts":1712956369103,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$h1v9TPZlLsqtADBFo7zN83xzAMKS1r3Npx0PsB9uU7I"},
{"content":{"body":"Like, if the definition of `Scope` was just \n```ts\ndeclare class Scope {\n  constructor(ctx: AsyncContext);\n}\n```\nThat's essentially just `{}`, meaning everything is assignable to it.","format":"org.matrix.custom.html","formatted_body":"<p>Like, if the definition of <code>Scope</code> was just</p>\n<pre><code class=\"language-ts\">declare class Scope {\n  constructor(ctx: AsyncContext);\n}\n</code></pre>\n<p>That's essentially just <code>{}</code>, meaning everything is assignable to it.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1712956426348,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wmuM_oAvK-dGIxAMN-TYANolYdMDBCJGxZnq8CjO4P8"},
{"content":{"body":"I understand now","msgtype":"m.text"},"ts":1712956454395,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$dliHSB17eNjx9CmjFvcg7TJ_oyk560bFCsicq_LVfPw"},
{"content":{"body":"We generally don't make such narrow distinctions when it depends on spec internal features. For example, we don't differentiate `Symbol.iterator` vs `Symbol()` vs `Symbol.for()` when used as a `WeakMap` key as that depends on spec internal information that isn't available via structural comparisons.","format":"org.matrix.custom.html","formatted_body":"We generally don't make such narrow distinctions when it depends on spec internal features. For example, we don't differentiate <code>Symbol.iterator</code> vs <code>Symbol()</code> vs <code>Symbol.for()</code> when used as a <code>WeakMap</code> key as that depends on spec internal information that isn't available via structural comparisons.","m.mentions":{},"msgtype":"m.text"},"ts":1712956554105,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9ethzEcXQAqkLgo5vBzo0wdJ1-xvDpBcMMBLR0oNSpw"},
{"content":{"body":"> <@rbuckton:matrix.org> Like, if the definition of `Scope` was just \n> ```ts\n> declare class Scope {\n>   constructor(ctx: AsyncContext);\n> }\n> ```\n> That's essentially just `{}`, meaning everything is assignable to it.\n\nIf `using` required `Disposable | Scope | null | undefined` on the RHS and we did the structural comparison to the above, that is reduced to `unknown` (i.e., `unknown` and `null | undefined | {}` are essentially the same)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$wmuM_oAvK-dGIxAMN-TYANolYdMDBCJGxZnq8CjO4P8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>Like, if the definition of <code>Scope</code> was just</p>\n<pre><code class=\"language-ts\">declare class Scope {\n  constructor(ctx: AsyncContext);\n}\n</code></pre>\n<p>That's essentially just <code>{}</code>, meaning everything is assignable to it.</p>\n</blockquote></mx-reply>If <code>using</code> required <code>Disposable | Scope | null | undefined</code> on the RHS and we did the structural comparison to the above, that is reduced to <code>unknown</code> (i.e., <code>unknown</code> and <code>null | undefined | {}</code> are essentially the same)","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$wmuM_oAvK-dGIxAMN-TYANolYdMDBCJGxZnq8CjO4P8"}},"msgtype":"m.text"},"ts":1712956683395,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RQYU1BX_sTd81Qu2vzmOs42GW4rt_DnMoCctW0Yn_QM"}
]