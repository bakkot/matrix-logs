[
{"content":{"body":"> <@stephenhicks:matrix.org> Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).\n\nHow would noWrap work?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).</blockquote></mx-reply>How would noWrap work?","m.relates_to":{"m.in_reply_to":{"event_id":"$EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw"}},"msgtype":"m.text"},"ts":1715907220800,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$YGSwAvvDL09E7_tX0CQwAO_xL9R1U-3UvW_A-e5z16M"},
{"content":{"body":"Like it cancels out a wrap that happens around it?","msgtype":"m.text"},"ts":1715907292752,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uplQ9zEoK3Gu_qN5QFM8IZJRZccaeYGul0xwHvkvlyg"},
{"content":{"body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel _all_ wraps that happen around it?  not quite clear - it's just one option.","format":"org.matrix.custom.html","formatted_body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel <em>all</em> wraps that happen around it?  not quite clear - it's just one option.","m.mentions":{},"msgtype":"m.text"},"ts":1715910138145,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$fo9bNJpWvVkYyBLuA_TTB2aw53ue3_x5DHip2Gm5lYo"},
{"content":{"body":"It feels kinda vaguely non-compositional to cancel out wrap; maybe better to avoid wrapping in the first place. Weren’t we discussing options for that? (But then you run into the “no null context” issue also)","msgtype":"m.text"},"ts":1715912773343,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$PKy07SQDTP-xYyBrSjIWI6gnTIfLV_eh1j4vqgyMMt0"},
{"content":{"body":"I am not being very clear with noncompositional… I guess I mean, if you replace f with n => f(n), then noWrap stops working","format":"org.matrix.custom.html","formatted_body":"I am not being very clear with noncompositional… I guess I mean, if you replace f with n =&gt; f(n), then noWrap stops working","msgtype":"m.text"},"ts":1715912830280,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$CW0k7Q39o1t9xziXUZasl2c0i1y3VidrKGo0yigKQQ0"},
{"content":{"body":"not necessarily - it depends on how it's implemente.d","m.mentions":{},"msgtype":"m.text"},"ts":1715912861651,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc"},
{"content":{"body":" * not necessarily - it depends on how it's implemented.","m.mentions":{},"m.new_content":{"body":"not necessarily - it depends on how it's implemented.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715912869320,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$3VgL5DTrLBB7-jwRfgdf8VSxZOvAiMr_db9LKuRp5qQ"},
{"content":{"body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to `n => f(n)`, though it makes `wrap` no longer idempotent (i.e. `wrap(wrap(unwrap(f))) == wrap(f)`) and there's potentially weirdness around `unwrap(unwrap(f)) == f` or some such...","format":"org.matrix.custom.html","formatted_body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to <code>n =&gt; f(n)</code>, though it makes <code>wrap</code> no longer idempotent (i.e. <code>wrap(wrap(unwrap(f))) == wrap(f)</code>) and there's potentially weirdness around <code>unwrap(unwrap(f)) == f</code> or some such...","m.mentions":{},"msgtype":"m.text"},"ts":1715912973250,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wKTF6I0lWpbosIXMTo4FDdkbmekefYaJejvaNBpT3Hc"},
{"content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer","m.mentions":{},"msgtype":"m.text"},"ts":1715913011588,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI"},
{"content":{"body":" * or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"m.new_content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715913020611,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$FYgMsDLwJQrbZAhm14izw2ZZoktgRAI5IU1f2ZFxb5g"},
{"content":{"body":"but it would only work from the _inside_ - `unwrap(wrap(f)) == wrap(f)`, which is surprising","format":"org.matrix.custom.html","formatted_body":"but it would only work from the <em>inside</em> - <code>unwrap(wrap(f)) == wrap(f)</code>, which is surprising","m.mentions":{},"msgtype":"m.text"},"ts":1715913056643,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$nS6aLBYhrD7a5-MEY_Qee5EmvI9yoGmzC-o5lZNUeNc"},
{"content":{"body":"I don't love those properties... but I think any observability of `callingContext` probably breaks idempotency of `wrap`, so maybe there's no way to keep that one?","format":"org.matrix.custom.html","formatted_body":"I don't love those properties... but I think any observability of <code>callingContext</code> probably breaks idempotency of <code>wrap</code>, so maybe there's no way to keep that one?","m.mentions":{},"msgtype":"m.text"},"ts":1715913162489,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$akZY0WOEvY3nOCx-3AdUHGACfPDnFDsQnxNaDTpSCc0"},
{"content":{"body":"Huh, how would it figure out the previous one at runtime? Currently you can just use a single global variable for the current snapshot.","msgtype":"m.text"},"ts":1715933264279,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Ubc6S-24ylQdPdalM-MjqRn2FrSfCDFsd0kdQq7oaWA"},
{"content":{"body":"> <@legendecas:matrix.org> Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case\n\nThe resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.\n\n```js\nasync function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n```","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case</blockquote></mx-reply><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U"}},"msgtype":"m.text"},"ts":1715934967864,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg"}
]