[
{"content":{"body":"> <@stephenhicks:matrix.org> Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).\n\nHow would noWrap work?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).</blockquote></mx-reply>How would noWrap work?","m.relates_to":{"m.in_reply_to":{"event_id":"$EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw"}},"msgtype":"m.text"},"ts":1715907220800,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$YGSwAvvDL09E7_tX0CQwAO_xL9R1U-3UvW_A-e5z16M"},
{"content":{"body":"Like it cancels out a wrap that happens around it?","msgtype":"m.text"},"ts":1715907292752,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uplQ9zEoK3Gu_qN5QFM8IZJRZccaeYGul0xwHvkvlyg"},
{"content":{"body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel _all_ wraps that happen around it?  not quite clear - it's just one option.","format":"org.matrix.custom.html","formatted_body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel <em>all</em> wraps that happen around it?  not quite clear - it's just one option.","m.mentions":{},"msgtype":"m.text"},"ts":1715910138145,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$fo9bNJpWvVkYyBLuA_TTB2aw53ue3_x5DHip2Gm5lYo"},
{"content":{"body":"It feels kinda vaguely non-compositional to cancel out wrap; maybe better to avoid wrapping in the first place. Werenâ€™t we discussing options for that? (But then you run into the â€œno null contextâ€ issue also)","msgtype":"m.text"},"ts":1715912773343,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$PKy07SQDTP-xYyBrSjIWI6gnTIfLV_eh1j4vqgyMMt0"},
{"content":{"body":"I am not being very clear with noncompositionalâ€¦ I guess I mean, if you replace f with n => f(n), then noWrap stops working","format":"org.matrix.custom.html","formatted_body":"I am not being very clear with noncompositionalâ€¦ I guess I mean, if you replace f with n =&gt; f(n), then noWrap stops working","msgtype":"m.text"},"ts":1715912830280,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$CW0k7Q39o1t9xziXUZasl2c0i1y3VidrKGo0yigKQQ0"},
{"content":{"body":"not necessarily - it depends on how it's implemente.d","m.mentions":{},"msgtype":"m.text"},"ts":1715912861651,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc"},
{"content":{"body":" * not necessarily - it depends on how it's implemented.","m.mentions":{},"m.new_content":{"body":"not necessarily - it depends on how it's implemented.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715912869320,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$3VgL5DTrLBB7-jwRfgdf8VSxZOvAiMr_db9LKuRp5qQ"},
{"content":{"body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to `n => f(n)`, though it makes `wrap` no longer idempotent (i.e. `wrap(wrap(unwrap(f))) == wrap(f)`) and there's potentially weirdness around `unwrap(unwrap(f)) == f` or some such...","format":"org.matrix.custom.html","formatted_body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to <code>n =&gt; f(n)</code>, though it makes <code>wrap</code> no longer idempotent (i.e. <code>wrap(wrap(unwrap(f))) == wrap(f)</code>) and there's potentially weirdness around <code>unwrap(unwrap(f)) == f</code> or some such...","m.mentions":{},"msgtype":"m.text"},"ts":1715912973250,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wKTF6I0lWpbosIXMTo4FDdkbmekefYaJejvaNBpT3Hc"},
{"content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer","m.mentions":{},"msgtype":"m.text"},"ts":1715913011588,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI"},
{"content":{"body":" * or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"m.new_content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715913020611,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$FYgMsDLwJQrbZAhm14izw2ZZoktgRAI5IU1f2ZFxb5g"},
{"content":{"body":"but it would only work from the _inside_ - `unwrap(wrap(f)) == wrap(f)`, which is surprising","format":"org.matrix.custom.html","formatted_body":"but it would only work from the <em>inside</em> - <code>unwrap(wrap(f)) == wrap(f)</code>, which is surprising","m.mentions":{},"msgtype":"m.text"},"ts":1715913056643,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$nS6aLBYhrD7a5-MEY_Qee5EmvI9yoGmzC-o5lZNUeNc"},
{"content":{"body":"I don't love those properties... but I think any observability of `callingContext` probably breaks idempotency of `wrap`, so maybe there's no way to keep that one?","format":"org.matrix.custom.html","formatted_body":"I don't love those properties... but I think any observability of <code>callingContext</code> probably breaks idempotency of <code>wrap</code>, so maybe there's no way to keep that one?","m.mentions":{},"msgtype":"m.text"},"ts":1715913162489,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$akZY0WOEvY3nOCx-3AdUHGACfPDnFDsQnxNaDTpSCc0"},
{"content":{"body":"Huh, how would it figure out the previous one at runtime? Currently you can just use a single global variable for the current snapshot.","msgtype":"m.text"},"ts":1715933264279,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Ubc6S-24ylQdPdalM-MjqRn2FrSfCDFsd0kdQq7oaWA"},
{"content":{"body":"> <@legendecas:matrix.org> Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case\n\nThe resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.\n\n```js\nasync function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n```","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case</blockquote></mx-reply><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U"}},"msgtype":"m.text"},"ts":1715934967864,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg"},
{"content":{"body":"Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.","msgtype":"m.text"},"ts":1715935330060,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw"},
{"content":{"body":"> <@littledan:matrix.org> where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)\n\nThere's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically _guess_ what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which _could_ be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we _want_ is for the _correct_ context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$h_zhAigENlGCCHlTu8LV8JAy1-U9w9n7QrjlnenFFEI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)</blockquote></mx-reply>There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically <em>guess</em> what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which <em>could</em> be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we <em>want</em> is for the <em>correct</em> context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$h_zhAigENlGCCHlTu8LV8JAy1-U9w9n7QrjlnenFFEI"}},"msgtype":"m.text"},"ts":1715935361677,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7845b1Ylx3JkiWv6_8b0hC6-nGeUDFf8tFhq98KG9HU"},
{"content":{"body":"> <@littledan:matrix.org> I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)\n\nWe don't need the list of all context historically, only a way at any given snapshot restore to elect to keep the prior value which already flowed in and additionally to be able to have a way to configure stores to capture resolve time of promises rather than register time.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$dMLpRbSSuZA1rSMR4AGSCXfE2W0sNPwaPATL2edwOIU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)</blockquote></mx-reply>We don't need the list of all context historically, only a way at any given snapshot restore to elect to keep the prior value which already flowed in and additionally to be able to have a way to configure stores to capture resolve time of promises rather than register time.","m.mentions":{"user_ids":["@littledan:matrix.org","@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$dMLpRbSSuZA1rSMR4AGSCXfE2W0sNPwaPATL2edwOIU"}},"msgtype":"m.text"},"ts":1715935551918,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$nmHe_RGyhL8l9LamJChEU-_S2182izt6R4u-tPUQ8CE"},
{"content":{"body":"> <@stephenhicks:matrix.org> The \"don't bind around await\" case feels a lot like \"just use a global variable\" to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you're not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would \"just work\" since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn't actually have to wait - and maybe also when two independent jobs are running interleaved?\n> \n> So a global variable is obviously a bit too naive to work, but where I'm struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you're presumably not clobbering the actual container variable, then that part shouldn't need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it's important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.\n\nIt's not that we need _no_ binds for async/await, it's that we want it to bind at the resolve point of the promise being awaited rather than at registration time directly at the point the await occurs. This would mean context would flow _through_ promises rather than _around_ them. It would _also_ mean the restore which occurs _after_ the await resumes would be that resolve point value rather than what the value was before the await occurred.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$he4xZQ-PdgdKX904BDMhD42g2oD1ix0HioQEZHm1iJo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>The &quot;don&#39;t bind around await&quot; case feels a lot like &quot;just use a global variable&quot; to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you&#39;re not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would &quot;just work&quot; since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn&#39;t actually have to wait - and maybe also when two independent jobs are running interleaved?<br/><br/>So a global variable is obviously a bit too naive to work, but where I&#39;m struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you&#39;re presumably not clobbering the actual container variable, then that part shouldn&#39;t need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it&#39;s important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.</blockquote></mx-reply>It's not that we need <em>no</em> binds for async/await, it's that we want it to bind at the resolve point of the promise being awaited rather than at registration time directly at the point the await occurs. This would mean context would flow <em>through</em> promises rather than <em>around</em> them. It would <em>also</em> mean the restore which occurs <em>after</em> the await resumes would be that resolve point value rather than what the value was before the await occurred.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$he4xZQ-PdgdKX904BDMhD42g2oD1ix0HioQEZHm1iJo"}},"msgtype":"m.text"},"ts":1715935917954,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$r9w1iV0V6p9dgy8FqaFKuT6onyjAEZWn--y-PlIe2fU"},
{"content":{"body":"> <@stephenhicks:matrix.org> To Stephen's point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I'd argue that it's a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.\n\nIt's _intentional_ that it behaves that way with callbacks. That's how context management is _supposed_ to work as it's not useful for most cases if it doesn't flow into continuations. That's literally the _point_ of the \"async\" in AsyncLocalStorage.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$ixvqlJf4UxI_zT7HE3zHuzsSn-jlIEwdJ6_UKEUtcIA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>To Stephen&#39;s point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I&#39;d argue that it&#39;s a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.</blockquote></mx-reply>It's <em>intentional</em> that it behaves that way with callbacks. That's how context management is <em>supposed</em> to work as it's not useful for most cases if it doesn't flow into continuations. That's literally the <em>point</em> of the \"async\" in AsyncLocalStorage.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ixvqlJf4UxI_zT7HE3zHuzsSn-jlIEwdJ6_UKEUtcIA"}},"msgtype":"m.text"},"ts":1715936037976,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$XZQIAbcYyd_64GK2ySxnvS5WDhu0Oxfv1v9QOfo1tQQ"},
{"content":{"body":"I'm not even sure what use there _would_ be for the other way with callbacks. I don't see any use case for that flow. ðŸ¤”","format":"org.matrix.custom.html","formatted_body":"I'm not even sure what use there <em>would</em> be for the other way with callbacks. I don't see any use case for that flow. ðŸ¤”","m.mentions":{},"msgtype":"m.text"},"ts":1715936085906,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$DIF0Jy2Iy4Tv8XItMYRIJfLFTX_64LAZjWYKnM6JOGg"},
{"content":{"body":"> <@littledan:matrix.org> Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.\n\nYes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.</blockquote></mx-reply>Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw"}},"msgtype":"m.text"},"ts":1715936285980,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.\n\nOther languages work the way you are proposing we adopt for JS? That is great to know. Can you suggest a concrete one for us to look into?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.</blockquote></mx-reply>Other languages work the way you are proposing we adopt for JS? That is great to know. Can you suggest a concrete one for us to look into?","m.relates_to":{"m.in_reply_to":{"event_id":"$hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY"}},"msgtype":"m.text"},"ts":1715936327882,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$lOTrKs6K3U031OZlstw_udw5DCNpqOv2OHDEYcju86c"},
{"content":{"body":"Bytecode manipulation isnâ€™t magic; I would be surprised if we canâ€™t do whatâ€™s achieved with it","msgtype":"m.text"},"ts":1715936365166,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5c27WJNn3PFAgSaLA-PfMpQnKvaFOSmt5zEiTDl_6VQ"},
{"content":{"body":"Not sure. Like I said, most do this externally to the runtime itself so I'm unsure if any particular language is a good example of it.","m.mentions":{},"msgtype":"m.text"},"ts":1715936402350,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$o7J_9aDr6JHkxyYCJG8l6c0U-j39Lzp5P5sfGPQAorY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> The resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.\n> \n> ```js\n> async function foo() {\n>   console.log('1')\n>   await Promise.resolve()\n>   console.log('3')\n> }\n> foo()\n> console.log('2')\n> ```\n\n```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n</blockquote></mx-reply><pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg"}},"msgtype":"m.text"},"ts":1715936532623,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8"},
{"content":{"body":"Thatâ€™s OK if itâ€™s external, if it implements the right semantics I am still happy to have that as the reference point","msgtype":"m.text"},"ts":1715936545021,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$7HKpOGEjGOtNVQMRC8Wrdpx_2k8FNCsb4olu-xI2wSs"},
{"content":{"body":"> <@littledan:matrix.org> Bytecode manipulation isnâ€™t magic; I would be surprised if we canâ€™t do whatâ€™s achieved with it\n\nMuch of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$5c27WJNn3PFAgSaLA-PfMpQnKvaFOSmt5zEiTDl_6VQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Bytecode manipulation isnâ€™t magic; I would be surprised if we canâ€™t do whatâ€™s achieved with it</blockquote></mx-reply>Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$5c27WJNn3PFAgSaLA-PfMpQnKvaFOSmt5zEiTDl_6VQ"}},"msgtype":"m.text"},"ts":1715936552024,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$dUMTKiCoN678Wyf5pbK9TD3b0KMdfx3El18XlMCtA0E"},
{"content":{"body":" * ```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n</blockquote></mx-reply> * <pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{},"m.new_content":{"body":"```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715936590168,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Aer2fMndjp9NayGngicLDcbvp_oh6_i7Rl5oZnYdx-4"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.\n\nSounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24dUMTKiCoN678Wyf5pbK9TD3b0KMdfx3El18XlMCtA0E\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.</blockquote></mx-reply>Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy","m.relates_to":{"m.in_reply_to":{"event_id":"$dUMTKiCoN678Wyf5pbK9TD3b0KMdfx3El18XlMCtA0E"}},"msgtype":"m.text"},"ts":1715936613179,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$rx1tKRz1gsnZqo647tWhU6F5olyxdyTRcqLDIjFVxms"},
{"content":{"body":" * ```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":" * <pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{},"m.new_content":{"body":"```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715936661970,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$fuqHUx61HlX3lwQ3JXEocu22i7xm7pUHb8Jk7d7dAeg"},
{"content":{"body":"> <@legendecas:matrix.org> ```\n> handleRequest((req, res) => {\n>   // ROOT SPAN0\n>   connection.query('SELECT 1 + 1 AS two') // SPAN1\n>     .then(a => {\n>       // PROPOSED CONTEXT: SPAN1.2\n>       // If the context.variable at this point is SPAN1.2, how do we determine\n>       // child-of or follow-from?\n>       // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n>       return connection.query('SELECT 2 + 2 AS four') // SPAN2\n>     })\n>     .then(b => {\n>       // PROPOSED CONTEXT: SPAN3.2\n>       res.writeHead(200, { 'Content-Type': 'text/plain' })\n>       res.end(a[0].two + b[0].four)\n>     })\n> })\n> \n> function connectionQuery(query) {\n>   // Current Context: SPANx\n>   return makeFirstRequest() // SPANx.1\n>     .then(() => {\n>       makeSecondRequest() // SPANx.2\n>     })\n> }\n> ```\n> \n> In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now\n\nWhat do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br><pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n</blockquote></mx-reply>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8"}},"msgtype":"m.text"},"ts":1715936681373,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c"},
{"content":{"body":"> <@littledan:matrix.org> Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy\n\nI'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. ðŸ˜…","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rx1tKRz1gsnZqo647tWhU6F5olyxdyTRcqLDIjFVxms?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy</blockquote></mx-reply>I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on <em>other</em> languages. ðŸ˜…","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$rx1tKRz1gsnZqo647tWhU6F5olyxdyTRcqLDIjFVxms"}},"msgtype":"m.text"},"ts":1715936745440,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$rF1kgLStcwRkaxXE-ARf7f04pE8w5xmQUMkicplrTRU"},
{"content":{"body":"> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.\n\nThe example is equivalent to async-await as:\n```\n\nhandleRequest(async (req, res) => {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n```\nIs this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.</blockquote></mx-reply><p>The example is equivalent to async-await as:</p>\n<pre><code>\nhandleRequest(async (req, res) =&gt; {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n</code></pre>\n<p>Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c"}},"msgtype":"m.text"},"ts":1715936834491,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Tk62V2S6Q5ESb45RNyI6de01_-btpKgrcHMIvMWmM8o"},
{"content":{"body":"> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.\n\n * The example is equivalent to async-await as:\n\n```\nhandleRequest(async (req, res) => {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n```\n\nIs this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.</blockquote></mx-reply> * <p>The example is equivalent to async-await as:</p>\n<pre><code>handleRequest(async (req, res) =&gt; {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n</code></pre>\n<p>Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?</p>\n","m.mentions":{},"m.new_content":{"body":"The example is equivalent to async-await as:\n\n```\nhandleRequest(async (req, res) => {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n```\n\nIs this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?","format":"org.matrix.custom.html","formatted_body":"<p>The example is equivalent to async-await as:</p>\n<pre><code>handleRequest(async (req, res) =&gt; {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n</code></pre>\n<p>Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Tk62V2S6Q5ESb45RNyI6de01_-btpKgrcHMIvMWmM8o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715936841304,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$qfqpocVGYYby-JwBsDAHCwj1LyAUox0A1R-zyoSSBFA"},
{"content":{"body":"Again, I'm unclear what the decimal point thing is about here?","m.mentions":{},"msgtype":"m.text"},"ts":1715937144538,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$v2uhYPZSjoY4Ti3TQNtAsMbXsppVoTZG13Xw4PBtma8"},
{"content":{"body":"> <@stephenbelanger:matrix.org> I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. ðŸ˜…\n\nSounds good, maybe we can all learn from this then","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24rF1kgLStcwRkaxXE-ARf7f04pE8w5xmQUMkicplrTRU\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on <em>other</em> languages. ðŸ˜…</blockquote></mx-reply>Sounds good, maybe we can all learn from this then","m.relates_to":{"m.in_reply_to":{"event_id":"$rF1kgLStcwRkaxXE-ARf7f04pE8w5xmQUMkicplrTRU"}},"msgtype":"m.text"},"ts":1715937238954,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$1D1G0nf1VF16GXaFTiq8J_N_0Y2UIeTGNKPzhkpMQP0"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Again, I'm unclear what the decimal point thing is about here?\n\nDecimal points represent child-of relations, increased number represets a follow-of relation.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$v2uhYPZSjoY4Ti3TQNtAsMbXsppVoTZG13Xw4PBtma8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Again, I&#39;m unclear what the decimal point thing is about here?</blockquote></mx-reply>Decimal points represent child-of relations, increased number represets a follow-of relation.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$v2uhYPZSjoY4Ti3TQNtAsMbXsppVoTZG13Xw4PBtma8"}},"msgtype":"m.text"},"ts":1715937288057,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$y0064xrnCzOVZ_8_be6KYtqhCzGZid0FjzuqsNn-17w"},
{"content":{"body":"Ah, no. Only the first is a child-of because it occurs within the sync initial part of the async function.","m.mentions":{},"msgtype":"m.text"},"ts":1715937404326,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$I6S1a4Ajm8E0HvDR3xfWIiy2yRk4h_3_sUfoO-LxA6Y"},
{"content":{"body":"The second should be follows-from.","m.mentions":{},"msgtype":"m.text"},"ts":1715937416623,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$snRKk8n7sM3Nr22JfTdXCTgs4_Ra1OgB1EUlNEesQJE"},
{"content":{"body":"The `connection.query(...)` expression is called before its result is awaited, and it's the calling of that which produces a span. That span is therefore within the synchronous scope of the http server request span.","format":"org.matrix.custom.html","formatted_body":"The <code>connection.query(...)</code> expression is called before its result is awaited, and it's the calling of that which produces a span. That span is therefore within the synchronous scope of the http server request span.","m.mentions":{},"msgtype":"m.text"},"ts":1715937486350,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kPOJ8azIcAX8kAf12iWYw0Gfy6mCZ7c9pckHS-T9Rno"},
{"content":{"body":"If there was some _other_ await before it, even one which did not produce a span, then it would be considered follows-from.","format":"org.matrix.custom.html","formatted_body":"If there was some <em>other</em> await before it, even one which did not produce a span, then it would be considered follows-from.","m.mentions":{},"msgtype":"m.text"},"ts":1715937515450,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zRPn6-e6usOz1TxaKsupNAopv86sPfk3GTsZV4R64VQ"},
{"content":{"body":"yeah, so in a promise chain, child-of is no longer effective and I'm curious about how you curate a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"ts":1715937577968,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y"},
{"content":{"body":" * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you curate a graph with nesting semantics.","m.mentions":{},"m.new_content":{"body":"yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you curate a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715937611114,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$XDGnWewK-OnpBBENV-pHrBox9F2WOSwGCRuUCxOokJI"}
]