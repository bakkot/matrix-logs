[
{"content":{"body":"> <@stephenhicks:matrix.org> Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).\n\nHow would noWrap work?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).</blockquote></mx-reply>How would noWrap work?","m.relates_to":{"m.in_reply_to":{"event_id":"$EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw"}},"msgtype":"m.text"},"ts":1715907220800,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$YGSwAvvDL09E7_tX0CQwAO_xL9R1U-3UvW_A-e5z16M"},
{"content":{"body":"Like it cancels out a wrap that happens around it?","msgtype":"m.text"},"ts":1715907292752,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uplQ9zEoK3Gu_qN5QFM8IZJRZccaeYGul0xwHvkvlyg"},
{"content":{"body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel _all_ wraps that happen around it?  not quite clear - it's just one option.","format":"org.matrix.custom.html","formatted_body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel <em>all</em> wraps that happen around it?  not quite clear - it's just one option.","m.mentions":{},"msgtype":"m.text"},"ts":1715910138145,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$fo9bNJpWvVkYyBLuA_TTB2aw53ue3_x5DHip2Gm5lYo"},
{"content":{"body":"It feels kinda vaguely non-compositional to cancel out wrap; maybe better to avoid wrapping in the first place. Weren’t we discussing options for that? (But then you run into the “no null context” issue also)","msgtype":"m.text"},"ts":1715912773343,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$PKy07SQDTP-xYyBrSjIWI6gnTIfLV_eh1j4vqgyMMt0"},
{"content":{"body":"I am not being very clear with noncompositional… I guess I mean, if you replace f with n => f(n), then noWrap stops working","format":"org.matrix.custom.html","formatted_body":"I am not being very clear with noncompositional… I guess I mean, if you replace f with n =&gt; f(n), then noWrap stops working","msgtype":"m.text"},"ts":1715912830280,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$CW0k7Q39o1t9xziXUZasl2c0i1y3VidrKGo0yigKQQ0"},
{"content":{"body":"not necessarily - it depends on how it's implemente.d","m.mentions":{},"msgtype":"m.text"},"ts":1715912861651,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc"},
{"content":{"body":" * not necessarily - it depends on how it's implemented.","m.mentions":{},"m.new_content":{"body":"not necessarily - it depends on how it's implemented.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715912869320,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$3VgL5DTrLBB7-jwRfgdf8VSxZOvAiMr_db9LKuRp5qQ"},
{"content":{"body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to `n => f(n)`, though it makes `wrap` no longer idempotent (i.e. `wrap(wrap(unwrap(f))) == wrap(f)`) and there's potentially weirdness around `unwrap(unwrap(f)) == f` or some such...","format":"org.matrix.custom.html","formatted_body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to <code>n =&gt; f(n)</code>, though it makes <code>wrap</code> no longer idempotent (i.e. <code>wrap(wrap(unwrap(f))) == wrap(f)</code>) and there's potentially weirdness around <code>unwrap(unwrap(f)) == f</code> or some such...","m.mentions":{},"msgtype":"m.text"},"ts":1715912973250,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wKTF6I0lWpbosIXMTo4FDdkbmekefYaJejvaNBpT3Hc"},
{"content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer","m.mentions":{},"msgtype":"m.text"},"ts":1715913011588,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI"},
{"content":{"body":" * or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"m.new_content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715913020611,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$FYgMsDLwJQrbZAhm14izw2ZZoktgRAI5IU1f2ZFxb5g"},
{"content":{"body":"but it would only work from the _inside_ - `unwrap(wrap(f)) == wrap(f)`, which is surprising","format":"org.matrix.custom.html","formatted_body":"but it would only work from the <em>inside</em> - <code>unwrap(wrap(f)) == wrap(f)</code>, which is surprising","m.mentions":{},"msgtype":"m.text"},"ts":1715913056643,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$nS6aLBYhrD7a5-MEY_Qee5EmvI9yoGmzC-o5lZNUeNc"},
{"content":{"body":"I don't love those properties... but I think any observability of `callingContext` probably breaks idempotency of `wrap`, so maybe there's no way to keep that one?","format":"org.matrix.custom.html","formatted_body":"I don't love those properties... but I think any observability of <code>callingContext</code> probably breaks idempotency of <code>wrap</code>, so maybe there's no way to keep that one?","m.mentions":{},"msgtype":"m.text"},"ts":1715913162489,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$akZY0WOEvY3nOCx-3AdUHGACfPDnFDsQnxNaDTpSCc0"},
{"content":{"body":"Huh, how would it figure out the previous one at runtime? Currently you can just use a single global variable for the current snapshot.","msgtype":"m.text"},"ts":1715933264279,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Ubc6S-24ylQdPdalM-MjqRn2FrSfCDFsd0kdQq7oaWA"},
{"content":{"body":"> <@legendecas:matrix.org> Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case\n\nThe resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.\n\n```js\nasync function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n```","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case</blockquote></mx-reply><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U"}},"msgtype":"m.text"},"ts":1715934967864,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg"},
{"content":{"body":"Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.","msgtype":"m.text"},"ts":1715935330060,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw"},
{"content":{"body":"> <@littledan:matrix.org> where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)\n\nThere's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically _guess_ what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which _could_ be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we _want_ is for the _correct_ context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$h_zhAigENlGCCHlTu8LV8JAy1-U9w9n7QrjlnenFFEI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)</blockquote></mx-reply>There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically <em>guess</em> what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which <em>could</em> be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we <em>want</em> is for the <em>correct</em> context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$h_zhAigENlGCCHlTu8LV8JAy1-U9w9n7QrjlnenFFEI"}},"msgtype":"m.text"},"ts":1715935361677,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7845b1Ylx3JkiWv6_8b0hC6-nGeUDFf8tFhq98KG9HU"},
{"content":{"body":"> <@littledan:matrix.org> I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)\n\nWe don't need the list of all context historically, only a way at any given snapshot restore to elect to keep the prior value which already flowed in and additionally to be able to have a way to configure stores to capture resolve time of promises rather than register time.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$dMLpRbSSuZA1rSMR4AGSCXfE2W0sNPwaPATL2edwOIU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)</blockquote></mx-reply>We don't need the list of all context historically, only a way at any given snapshot restore to elect to keep the prior value which already flowed in and additionally to be able to have a way to configure stores to capture resolve time of promises rather than register time.","m.mentions":{"user_ids":["@littledan:matrix.org","@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$dMLpRbSSuZA1rSMR4AGSCXfE2W0sNPwaPATL2edwOIU"}},"msgtype":"m.text"},"ts":1715935551918,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$nmHe_RGyhL8l9LamJChEU-_S2182izt6R4u-tPUQ8CE"},
{"content":{"body":"> <@stephenhicks:matrix.org> The \"don't bind around await\" case feels a lot like \"just use a global variable\" to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you're not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would \"just work\" since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn't actually have to wait - and maybe also when two independent jobs are running interleaved?\n> \n> So a global variable is obviously a bit too naive to work, but where I'm struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you're presumably not clobbering the actual container variable, then that part shouldn't need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it's important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.\n\nIt's not that we need _no_ binds for async/await, it's that we want it to bind at the resolve point of the promise being awaited rather than at registration time directly at the point the await occurs. This would mean context would flow _through_ promises rather than _around_ them. It would _also_ mean the restore which occurs _after_ the await resumes would be that resolve point value rather than what the value was before the await occurred.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$he4xZQ-PdgdKX904BDMhD42g2oD1ix0HioQEZHm1iJo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>The &quot;don&#39;t bind around await&quot; case feels a lot like &quot;just use a global variable&quot; to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you&#39;re not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would &quot;just work&quot; since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn&#39;t actually have to wait - and maybe also when two independent jobs are running interleaved?<br/><br/>So a global variable is obviously a bit too naive to work, but where I&#39;m struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you&#39;re presumably not clobbering the actual container variable, then that part shouldn&#39;t need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it&#39;s important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.</blockquote></mx-reply>It's not that we need <em>no</em> binds for async/await, it's that we want it to bind at the resolve point of the promise being awaited rather than at registration time directly at the point the await occurs. This would mean context would flow <em>through</em> promises rather than <em>around</em> them. It would <em>also</em> mean the restore which occurs <em>after</em> the await resumes would be that resolve point value rather than what the value was before the await occurred.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$he4xZQ-PdgdKX904BDMhD42g2oD1ix0HioQEZHm1iJo"}},"msgtype":"m.text"},"ts":1715935917954,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$r9w1iV0V6p9dgy8FqaFKuT6onyjAEZWn--y-PlIe2fU"},
{"content":{"body":"> <@stephenhicks:matrix.org> To Stephen's point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I'd argue that it's a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.\n\nIt's _intentional_ that it behaves that way with callbacks. That's how context management is _supposed_ to work as it's not useful for most cases if it doesn't flow into continuations. That's literally the _point_ of the \"async\" in AsyncLocalStorage.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$ixvqlJf4UxI_zT7HE3zHuzsSn-jlIEwdJ6_UKEUtcIA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>To Stephen&#39;s point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I&#39;d argue that it&#39;s a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.</blockquote></mx-reply>It's <em>intentional</em> that it behaves that way with callbacks. That's how context management is <em>supposed</em> to work as it's not useful for most cases if it doesn't flow into continuations. That's literally the <em>point</em> of the \"async\" in AsyncLocalStorage.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ixvqlJf4UxI_zT7HE3zHuzsSn-jlIEwdJ6_UKEUtcIA"}},"msgtype":"m.text"},"ts":1715936037976,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$XZQIAbcYyd_64GK2ySxnvS5WDhu0Oxfv1v9QOfo1tQQ"},
{"content":{"body":"I'm not even sure what use there _would_ be for the other way with callbacks. I don't see any use case for that flow. 🤔","format":"org.matrix.custom.html","formatted_body":"I'm not even sure what use there <em>would</em> be for the other way with callbacks. I don't see any use case for that flow. 🤔","m.mentions":{},"msgtype":"m.text"},"ts":1715936085906,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$DIF0Jy2Iy4Tv8XItMYRIJfLFTX_64LAZjWYKnM6JOGg"},
{"content":{"body":"> <@littledan:matrix.org> Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.\n\nYes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.</blockquote></mx-reply>Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw"}},"msgtype":"m.text"},"ts":1715936285980,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.\n\nOther languages work the way you are proposing we adopt for JS? That is great to know. Can you suggest a concrete one for us to look into?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.</blockquote></mx-reply>Other languages work the way you are proposing we adopt for JS? That is great to know. Can you suggest a concrete one for us to look into?","m.relates_to":{"m.in_reply_to":{"event_id":"$hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY"}},"msgtype":"m.text"},"ts":1715936327882,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$lOTrKs6K3U031OZlstw_udw5DCNpqOv2OHDEYcju86c"},
{"content":{"body":"Bytecode manipulation isn’t magic; I would be surprised if we can’t do what’s achieved with it","msgtype":"m.text"},"ts":1715936365166,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5c27WJNn3PFAgSaLA-PfMpQnKvaFOSmt5zEiTDl_6VQ"},
{"content":{"body":"Not sure. Like I said, most do this externally to the runtime itself so I'm unsure if any particular language is a good example of it.","m.mentions":{},"msgtype":"m.text"},"ts":1715936402350,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$o7J_9aDr6JHkxyYCJG8l6c0U-j39Lzp5P5sfGPQAorY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> The resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.\n> \n> ```js\n> async function foo() {\n>   console.log('1')\n>   await Promise.resolve()\n>   console.log('3')\n> }\n> foo()\n> console.log('2')\n> ```\n\n```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n</blockquote></mx-reply><pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg"}},"msgtype":"m.text"},"ts":1715936532623,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8"},
{"content":{"body":"That’s OK if it’s external, if it implements the right semantics I am still happy to have that as the reference point","msgtype":"m.text"},"ts":1715936545021,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$7HKpOGEjGOtNVQMRC8Wrdpx_2k8FNCsb4olu-xI2wSs"},
{"content":{"body":"> <@littledan:matrix.org> Bytecode manipulation isn’t magic; I would be surprised if we can’t do what’s achieved with it\n\nMuch of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$5c27WJNn3PFAgSaLA-PfMpQnKvaFOSmt5zEiTDl_6VQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Bytecode manipulation isn’t magic; I would be surprised if we can’t do what’s achieved with it</blockquote></mx-reply>Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$5c27WJNn3PFAgSaLA-PfMpQnKvaFOSmt5zEiTDl_6VQ"}},"msgtype":"m.text"},"ts":1715936552024,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$dUMTKiCoN678Wyf5pbK9TD3b0KMdfx3El18XlMCtA0E"},
{"content":{"body":" * ```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n</blockquote></mx-reply> * <pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{},"m.new_content":{"body":"```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715936590168,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Aer2fMndjp9NayGngicLDcbvp_oh6_i7Rl5oZnYdx-4"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.\n\nSounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24dUMTKiCoN678Wyf5pbK9TD3b0KMdfx3El18XlMCtA0E\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.</blockquote></mx-reply>Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy","m.relates_to":{"m.in_reply_to":{"event_id":"$dUMTKiCoN678Wyf5pbK9TD3b0KMdfx3El18XlMCtA0E"}},"msgtype":"m.text"},"ts":1715936613179,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$rx1tKRz1gsnZqo647tWhU6F5olyxdyTRcqLDIjFVxms"},
{"content":{"body":" * ```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":" * <pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{},"m.new_content":{"body":"```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715936661970,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$fuqHUx61HlX3lwQ3JXEocu22i7xm7pUHb8Jk7d7dAeg"},
{"content":{"body":"> <@legendecas:matrix.org> ```\n> handleRequest((req, res) => {\n>   // ROOT SPAN0\n>   connection.query('SELECT 1 + 1 AS two') // SPAN1\n>     .then(a => {\n>       // PROPOSED CONTEXT: SPAN1.2\n>       // If the context.variable at this point is SPAN1.2, how do we determine\n>       // child-of or follow-from?\n>       // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n>       return connection.query('SELECT 2 + 2 AS four') // SPAN2\n>     })\n>     .then(b => {\n>       // PROPOSED CONTEXT: SPAN3.2\n>       res.writeHead(200, { 'Content-Type': 'text/plain' })\n>       res.end(a[0].two + b[0].four)\n>     })\n> })\n> \n> function connectionQuery(query) {\n>   // Current Context: SPANx\n>   return makeFirstRequest() // SPANx.1\n>     .then(() => {\n>       makeSecondRequest() // SPANx.2\n>     })\n> }\n> ```\n> \n> In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now\n\nWhat do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br><pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n</blockquote></mx-reply>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8"}},"msgtype":"m.text"},"ts":1715936681373,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c"},
{"content":{"body":"> <@littledan:matrix.org> Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy\n\nI'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. 😅","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rx1tKRz1gsnZqo647tWhU6F5olyxdyTRcqLDIjFVxms?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy</blockquote></mx-reply>I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on <em>other</em> languages. 😅","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$rx1tKRz1gsnZqo647tWhU6F5olyxdyTRcqLDIjFVxms"}},"msgtype":"m.text"},"ts":1715936745440,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$rF1kgLStcwRkaxXE-ARf7f04pE8w5xmQUMkicplrTRU"},
{"content":{"body":"> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.\n\nThe example is equivalent to async-await as:\n```\n\nhandleRequest(async (req, res) => {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n```\nIs this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.</blockquote></mx-reply><p>The example is equivalent to async-await as:</p>\n<pre><code>\nhandleRequest(async (req, res) =&gt; {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n</code></pre>\n<p>Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c"}},"msgtype":"m.text"},"ts":1715936834491,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Tk62V2S6Q5ESb45RNyI6de01_-btpKgrcHMIvMWmM8o"},
{"content":{"body":"> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.\n\n * The example is equivalent to async-await as:\n\n```\nhandleRequest(async (req, res) => {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n```\n\nIs this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.</blockquote></mx-reply> * <p>The example is equivalent to async-await as:</p>\n<pre><code>handleRequest(async (req, res) =&gt; {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n</code></pre>\n<p>Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?</p>\n","m.mentions":{},"m.new_content":{"body":"The example is equivalent to async-await as:\n\n```\nhandleRequest(async (req, res) => {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n```\n\nIs this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?","format":"org.matrix.custom.html","formatted_body":"<p>The example is equivalent to async-await as:</p>\n<pre><code>handleRequest(async (req, res) =&gt; {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n</code></pre>\n<p>Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Tk62V2S6Q5ESb45RNyI6de01_-btpKgrcHMIvMWmM8o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715936841304,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$qfqpocVGYYby-JwBsDAHCwj1LyAUox0A1R-zyoSSBFA"},
{"content":{"body":"Again, I'm unclear what the decimal point thing is about here?","m.mentions":{},"msgtype":"m.text"},"ts":1715937144538,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$v2uhYPZSjoY4Ti3TQNtAsMbXsppVoTZG13Xw4PBtma8"},
{"content":{"body":"> <@stephenbelanger:matrix.org> I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. 😅\n\nSounds good, maybe we can all learn from this then","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24rF1kgLStcwRkaxXE-ARf7f04pE8w5xmQUMkicplrTRU\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on <em>other</em> languages. 😅</blockquote></mx-reply>Sounds good, maybe we can all learn from this then","m.relates_to":{"m.in_reply_to":{"event_id":"$rF1kgLStcwRkaxXE-ARf7f04pE8w5xmQUMkicplrTRU"}},"msgtype":"m.text"},"ts":1715937238954,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$1D1G0nf1VF16GXaFTiq8J_N_0Y2UIeTGNKPzhkpMQP0"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Again, I'm unclear what the decimal point thing is about here?\n\nDecimal points represent child-of relations, increased number represets a follow-of relation.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$v2uhYPZSjoY4Ti3TQNtAsMbXsppVoTZG13Xw4PBtma8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Again, I&#39;m unclear what the decimal point thing is about here?</blockquote></mx-reply>Decimal points represent child-of relations, increased number represets a follow-of relation.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$v2uhYPZSjoY4Ti3TQNtAsMbXsppVoTZG13Xw4PBtma8"}},"msgtype":"m.text"},"ts":1715937288057,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$y0064xrnCzOVZ_8_be6KYtqhCzGZid0FjzuqsNn-17w"},
{"content":{"body":"Ah, no. Only the first is a child-of because it occurs within the sync initial part of the async function.","m.mentions":{},"msgtype":"m.text"},"ts":1715937404326,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$I6S1a4Ajm8E0HvDR3xfWIiy2yRk4h_3_sUfoO-LxA6Y"},
{"content":{"body":"The second should be follows-from.","m.mentions":{},"msgtype":"m.text"},"ts":1715937416623,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$snRKk8n7sM3Nr22JfTdXCTgs4_Ra1OgB1EUlNEesQJE"},
{"content":{"body":"The `connection.query(...)` expression is called before its result is awaited, and it's the calling of that which produces a span. That span is therefore within the synchronous scope of the http server request span.","format":"org.matrix.custom.html","formatted_body":"The <code>connection.query(...)</code> expression is called before its result is awaited, and it's the calling of that which produces a span. That span is therefore within the synchronous scope of the http server request span.","m.mentions":{},"msgtype":"m.text"},"ts":1715937486350,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kPOJ8azIcAX8kAf12iWYw0Gfy6mCZ7c9pckHS-T9Rno"},
{"content":{"body":"If there was some _other_ await before it, even one which did not produce a span, then it would be considered follows-from.","format":"org.matrix.custom.html","formatted_body":"If there was some <em>other</em> await before it, even one which did not produce a span, then it would be considered follows-from.","m.mentions":{},"msgtype":"m.text"},"ts":1715937515450,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zRPn6-e6usOz1TxaKsupNAopv86sPfk3GTsZV4R64VQ"},
{"content":{"body":"yeah, so in a promise chain, child-of is no longer effective and I'm curious about how you curate a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"ts":1715937577968,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y"},
{"content":{"body":" * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you curate a graph with nesting semantics.","m.mentions":{},"m.new_content":{"body":"yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you curate a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715937611114,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$XDGnWewK-OnpBBENV-pHrBox9F2WOSwGCRuUCxOokJI"},
{"content":{"body":" * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you crate a graph with nesting semantics.","m.mentions":{},"m.new_content":{"body":"yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you crate a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715937652437,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$nfR4s5IotYtKFiPWgDnJWyqyZ1GEx7oVE1bhZC3PVOE"},
{"content":{"body":" * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.","m.mentions":{},"m.new_content":{"body":"yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715937656569,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$7poUhRkFmlxmNycq5Q1XvvNSU4xK2VHJe_DJUcsilxY"},
{"content":{"body":"That would look the same. The creation of that initial promise produces a sync/child-of span, and then anything in following `then(...)` continuations would be follows-from of whichever thing in the chain last produced a span.","format":"org.matrix.custom.html","formatted_body":"That would look the same. The creation of that initial promise produces a sync/child-of span, and then anything in following <code>then(...)</code> continuations would be follows-from of whichever thing in the chain last produced a span.","m.mentions":{},"msgtype":"m.text"},"ts":1715937683707,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$3e_8Ls2RuYDx5kMmb3ETy5-T88OKnQHmzHYKgTJHpos"},
{"content":{"body":"So from a user code behaviour perspective, callbacks, promises, and async/await would all produce the same graph.","m.mentions":{},"msgtype":"m.text"},"ts":1715937734625,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$eLlxiE-wyMXDrAW1uaSt9PMacUcBMM00C8t6sWJ1I8w"},
{"content":{"body":"And in the less common case where a continuation is attached far away from where the promise is created, a manual bind could be used where necessary to express that further away logical path, if it makes sense.","m.mentions":{},"msgtype":"m.text"},"ts":1715937794618,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$sr1tw1qeeLzL_PKGleGYJGp1nZyuah-agfwILF0xqtw"},
{"content":{"body":"But generally from APM perspective we basically _never_ want that further away path.","format":"org.matrix.custom.html","formatted_body":"But generally from APM perspective we basically <em>never</em> want that further away path.","m.mentions":{},"msgtype":"m.text"},"ts":1715937810365,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$EL5GIA5noCPPuqSTEhLm1_q1NoyfxepuQRCDMx16rMU"},
{"content":{"body":"Meaning register time of a promise continuation.","m.mentions":{},"msgtype":"m.text"},"ts":1715937834218,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kAQ-rbFYxnAp6a0iZ3bY6DGmRGGmSRdMAbeCYw1ot_w"},
{"content":{"body":"We want resolve time basically universally.","m.mentions":{},"msgtype":"m.text"},"ts":1715937846140,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7nXzK5wYBAp0lrmm566TRATfFbViHOR8liYeucX0TXI"},
{"content":{"body":"As do basically all userland context flow use cases I'm aware of. I'm very unclear what the actual use case is for register time binding. 😕","m.mentions":{},"msgtype":"m.text"},"ts":1715937881715,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$HGy7ZA1-tA0Z0R8MDmDpLPbwHGMnPZGcqEDgxcItOps"},
{"content":{"body":"Sometimes there is no particular resolve time context to apply, and we just need to fall back to register time","msgtype":"m.text"},"ts":1715937934703,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$6dofd0YL1LMpA8NTJIwwjphiaEZIXmTyWuMxzfiEUxA"},
{"content":{"body":"If it goes to a browser/os primitive","msgtype":"m.text"},"ts":1715937959306,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$KQ0wnnUNmv9-vW0LX81NwVrf7jYhePThNMkS_r93Uv4"},
{"content":{"body":"There’s the general connection pooling case, which generalizes this","msgtype":"m.text"},"ts":1715938021556,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$LPW3WH4SUYUYbcwJG1aHu2ZDjORvQAmmCez6geziFoQ"},
{"content":{"body":"Generally to get child-of edges, don’t you want restore after await? Sync is not enough.","msgtype":"m.text"},"ts":1715938136391,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$JqyAfPEehVXYA8gh86mXP-RgZrBIF5cuobo0Wc5dpNg"},
{"content":{"body":"Resolve time naturally flows out to eventually promise-creation time--the thing you called which created a promise.","m.mentions":{},"msgtype":"m.text"},"ts":1715938156851,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$RfjDMpUnfcgQAmJHQsor_sKpoGDGqHQrbWunoN7BuNQ"},
{"content":{"body":"What do you mean “flows out to”?","msgtype":"m.text"},"ts":1715938177829,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$g40keoDWVZAFl8CBhJ1Nf_FFgC3kgt9g0_a85ynP2So"},
{"content":{"body":"> <@littledan:matrix.org> Generally to get child-of edges, don’t you want restore after await? Sync is not enough.\n\nChild-of edges are easy. They are just things happening synchronously within the current scope, so we don't need anything for that. Not sure why restoring matters here? 🤔","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$JqyAfPEehVXYA8gh86mXP-RgZrBIF5cuobo0Wc5dpNg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Generally to get child-of edges, don’t you want restore after await? Sync is not enough.</blockquote></mx-reply>Child-of edges are easy. They are just things happening synchronously within the current scope, so we don't need anything for that. Not sure why restoring matters here? 🤔","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$JqyAfPEehVXYA8gh86mXP-RgZrBIF5cuobo0Wc5dpNg"}},"msgtype":"m.text"},"ts":1715938213748,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$85EwmYX_tId53eUiO2mB7ckUkkZS-gPhK02TqqBxybg"},
{"content":{"body":"> <@littledan:matrix.org> What do you mean “flows out to”?\n\nI mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is _done_. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that _was_ in JS, which is when the original call happened.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$g40keoDWVZAFl8CBhJ1Nf_FFgC3kgt9g0_a85ynP2So?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>What do you mean “flows out to”?</blockquote></mx-reply>I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is <em>done</em>. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that <em>was</em> in JS, which is when the original call happened.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$g40keoDWVZAFl8CBhJ1Nf_FFgC3kgt9g0_a85ynP2So"}},"msgtype":"m.text"},"ts":1715938325532,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$h3ZdDJy4WPz03u0oaQHjkzxL_gAPrBNN-MCB2qY8LAs"},
{"content":{"body":"> <@legendecas:matrix.org> yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.\n\nSo it seems like we have a disagreement in this chat about this statement. How can we look into it further? Maybe analyzing some concrete cases?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.</blockquote></mx-reply>So it seems like we have a disagreement in this chat about this statement. How can we look into it further? Maybe analyzing some concrete cases?","m.relates_to":{"m.in_reply_to":{"event_id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y"}},"msgtype":"m.text"},"ts":1715938392618,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$4IqDLhVeqSsgVxVNdj61HAujJ72CqnUJaIVvGD2AYks"},
{"content":{"body":"Creation of a promise is just an allocation. It's not controlling flow at that point. The actual _scheduling_ of a promise is the providing of a value to resolve it with.","format":"org.matrix.custom.html","formatted_body":"Creation of a promise is just an allocation. It's not controlling flow at that point. The actual <em>scheduling</em> of a promise is the providing of a value to resolve it with.","m.mentions":{},"msgtype":"m.text"},"ts":1715938406949,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$phNNX0-fTX6d3gIv64RV8l0VHOvD8Ot7JDMffrSmOeE"},
{"content":{"body":"> <@stephenbelanger:matrix.org> I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is _done_. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that _was_ in JS, which is when the original call happened.\n\nin JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no `AsyncContext.Snapshot.p.run` along the promise resolution path?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$h3ZdDJy4WPz03u0oaQHjkzxL_gAPrBNN-MCB2qY8LAs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is <em>done</em>. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that <em>was</em> in JS, which is when the original call happened.</blockquote></mx-reply>in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no <code>AsyncContext.Snapshot.p.run</code> along the promise resolution path?","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$h3ZdDJy4WPz03u0oaQHjkzxL_gAPrBNN-MCB2qY8LAs"}},"msgtype":"m.text"},"ts":1715938569883,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$9z-i1rmdJ_RqY4A0vypv6fk9dqWKRveoNDtlq_eGDqs"},
{"content":{"body":"> <@abotella:igalia.com> in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no `AsyncContext.Snapshot.p.run` along the promise resolution path?\n\nNot sure what you mean by that. Do you have an example?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$9z-i1rmdJ_RqY4A0vypv6fk9dqWKRveoNDtlq_eGDqs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no <code>AsyncContext.Snapshot.p.run</code> along the promise resolution path?</blockquote></mx-reply>Not sure what you mean by that. Do you have an example?","m.mentions":{"user_ids":["@abotella:igalia.com","@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$9z-i1rmdJ_RqY4A0vypv6fk9dqWKRveoNDtlq_eGDqs"}},"msgtype":"m.text"},"ts":1715938656873,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ZFR73FpokWSVwEmBEPcGJKYHVIkV8xnlv_Ub3zsl8Sw"},
{"content":{"body":"From _my_ perspective: context flows into the promise executor, it flows into anything that happens _within_ that executor, it then captures whenever the `resolve(...)` is called as _that_ is what actually schedules passing the value to continuations. If the context value is set outside the promise constructor it will use that context. If it gets set somewhere within the executor leading up to when it calls `resolve(...)` it will use that. It all flows naturally toward the resolve point where it schedules the value to pass to continuations.","format":"org.matrix.custom.html","formatted_body":"From <em>my</em> perspective: context flows into the promise executor, it flows into anything that happens <em>within</em> that executor, it then captures whenever the <code>resolve(...)</code> is called as <em>that</em> is what actually schedules passing the value to continuations. If the context value is set outside the promise constructor it will use that context. If it gets set somewhere within the executor leading up to when it calls <code>resolve(...)</code> it will use that. It all flows naturally toward the resolve point where it schedules the value to pass to continuations.","m.mentions":{},"msgtype":"m.text"},"ts":1715938786689,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ni61_VWmEBb8JKv7R8LtajUpS0p7aFIicAmzfAQj9II"},
{"content":{"body":"so IIUC, you're saying that in cases like `await someAPI()`, the resolve time is a child of the context before the await","format":"org.matrix.custom.html","formatted_body":"so IIUC, you're saying that in cases like <code>await someAPI()</code>, the resolve time is a child of the context before the await","m.mentions":{},"msgtype":"m.text"},"ts":1715938849340,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$LRIBpsFE-VYxxaIU_9mwfs04jvUFV6ALUY5vWH2j3iA"},
{"content":{"body":"but that is not the case with things like\n```js\nconst somePreviousSnapshot = new AsyncContext.Snapshot();\n\nfunction someAPI() {\n  return new Promise(resolve => {\n    // I don't know why someone might do this, but they *can* do it.\n    somePreviousSnapshot.run(resolve);\n  });\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>but that is not the case with things like</p>\n<pre><code class=\"language-js\">const somePreviousSnapshot = new AsyncContext.Snapshot();\n\nfunction someAPI() {\n  return new Promise(resolve =&gt; {\n    // I don't know why someone might do this, but they *can* do it.\n    somePreviousSnapshot.run(resolve);\n  });\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1715938850769,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$D88nGU3XPEUlshmobLc8zDw_SBq4oloO2-LrogbzpmE"},
{"content":{"body":"Now you _could_ look at it the other way of _attaching a continuation_ is the scheduling and the resolve is a fulfillment of that scheduling, but the fulfillment is not _triggered_ by that attaching of a continuation so I don't really feel like that's actually correct. Possibly a _useful_ path to follow in some cases, though I'm unclear _when_.","format":"org.matrix.custom.html","formatted_body":"Now you <em>could</em> look at it the other way of <em>attaching a continuation</em> is the scheduling and the resolve is a fulfillment of that scheduling, but the fulfillment is not <em>triggered</em> by that attaching of a continuation so I don't really feel like that's actually correct. Possibly a <em>useful</em> path to follow in some cases, though I'm unclear <em>when</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1715938896787,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$xbOxpzxOtFPJRQNx48xaCG1KYvFPOwYYKhMuuiZSevA"},
{"content":{"body":"> <@abotella:igalia.com> so IIUC, you're saying that in cases like `await someAPI()`, the resolve time is a child of the context before the await\n\nYeah, so the expression which produces the promises which _will_ be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise _resolves_ the following execution is then a _continuation_ of that resolution and should therefore flow the context which was captured at the point that path resolved.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$LRIBpsFE-VYxxaIU_9mwfs04jvUFV6ALUY5vWH2j3iA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>so IIUC, you're saying that in cases like <code>await someAPI()</code>, the resolve time is a child of the context before the await</blockquote></mx-reply>Yeah, so the expression which produces the promises which <em>will</em> be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise <em>resolves</em> the following execution is then a <em>continuation</em> of that resolution and should therefore flow the context which was captured at the point that path resolved.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$LRIBpsFE-VYxxaIU_9mwfs04jvUFV6ALUY5vWH2j3iA"}},"msgtype":"m.text"},"ts":1715939033634,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$wwfAYagbFg8TVhSBZe3kNzBIE8TphLlEXlsrNxgUnHo"},
{"content":{"body":"> <@abotella:igalia.com> so IIUC, you're saying that in cases like `await someAPI()`, the resolve time is a child of the context before the await\n\n * Yeah, so the expression which produces the promise which _will_ be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise _resolves_ the following execution is then a _continuation_ of that resolution and should therefore flow the context which was captured at the point that path resolved.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$LRIBpsFE-VYxxaIU_9mwfs04jvUFV6ALUY5vWH2j3iA?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>so IIUC, you're saying that in cases like <code>await someAPI()</code>, the resolve time is a child of the context before the await</blockquote></mx-reply> * Yeah, so the expression which produces the promise which <em>will</em> be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise <em>resolves</em> the following execution is then a <em>continuation</em> of that resolution and should therefore flow the context which was captured at the point that path resolved.","m.mentions":{},"m.new_content":{"body":"Yeah, so the expression which produces the promise which _will_ be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise _resolves_ the following execution is then a _continuation_ of that resolution and should therefore flow the context which was captured at the point that path resolved.","format":"org.matrix.custom.html","formatted_body":"Yeah, so the expression which produces the promise which <em>will</em> be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise <em>resolves</em> the following execution is then a <em>continuation</em> of that resolution and should therefore flow the context which was captured at the point that path resolved.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$wwfAYagbFg8TVhSBZe3kNzBIE8TphLlEXlsrNxgUnHo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715939044674,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$UbJvdqbqXTWQwGw7usV-PMpMwjvZd1BlzsO1TJlMwYY"},
{"content":{"body":"In your example there, you captured a snapshot and ran that around the resolve, so that changes the context which should come out of the await.","m.mentions":{},"msgtype":"m.text"},"ts":1715939099255,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$YRwKAPzw-PsPPmlE8VusgywSjzTdbMC6TfHclVBEllo"},
{"content":{"body":"This is why I feel flowing up to the resolve barrier makes a lot more sense, and then not binding around awaits at all, or maybe having some _secondary_ flow that could be captured for those. If you follow the resolve path you will naturally have the context from the start of the async function flow through all the awaits and continue to be available, only changing if something in that causal path changed the context around what led to their resolve.","format":"org.matrix.custom.html","formatted_body":"This is why I feel flowing up to the resolve barrier makes a lot more sense, and then not binding around awaits at all, or maybe having some <em>secondary</em> flow that could be captured for those. If you follow the resolve path you will naturally have the context from the start of the async function flow through all the awaits and continue to be available, only changing if something in that causal path changed the context around what led to their resolve.","m.mentions":{},"msgtype":"m.text"},"ts":1715939254479,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$DOCDP7J4liN08BYOVqMzbSIuwaJ9UbO0ArsbtYkWhfE"},
{"content":{"body":"Binding around awaits is chopping off branches of the execution graph, which I'm unclear why anyone would want to do that by default. 🤔","m.mentions":{},"msgtype":"m.text"},"ts":1715939325066,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$GltNCGII4JiGPaqpwmGr8MP8peK4MYY82Aw4OBV6Mno"},
{"content":{"body":"but in cases like this, wouldn't this mess up tracing?\n```js\nasync function someFunctionYouCareAboutTracing() {\n\tconst response1 = await fetch(...);\n\tawait someAPI();  // this empties out the context after the await!\n\tconst response2 = await fetch(...);\n\treturn await doSomethingWith(response1, response2);\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>but in cases like this, wouldn't this mess up tracing?</p>\n<pre><code class=\"language-js\">async function someFunctionYouCareAboutTracing() {\n\tconst response1 = await fetch(...);\n\tawait someAPI();  // this empties out the context after the await!\n\tconst response2 = await fetch(...);\n\treturn await doSomethingWith(response1, response2);\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1715939384174,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$s3Whkb5UtNfzylrlys2aUWTiyePbspIp_1YWTsvj-1I"},
{"content":{"body":"Like I get that there seems to be some use case people have in mind for _why_ it makes sense _for them_ to bind and restore around awaits, but I _still_ have not seen any adequate explanation on _why_ anyone would ever want that. 😕","format":"org.matrix.custom.html","formatted_body":"Like I get that there seems to be some use case people have in mind for <em>why</em> it makes sense <em>for them</em> to bind and restore around awaits, but I <em>still</em> have not seen any adequate explanation on <em>why</em> anyone would ever want that. 😕","m.mentions":{},"msgtype":"m.text"},"ts":1715939390237,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$XoNuxLHEyJ7rAmgGu8FL2Fncn0shIAvBcqSSN3bfrz0"},
{"content":{"body":"> <@abotella:igalia.com> but in cases like this, wouldn't this mess up tracing?\n> ```js\n> async function someFunctionYouCareAboutTracing() {\n> \tconst response1 = await fetch(...);\n> \tawait someAPI();  // this empties out the context after the await!\n> \tconst response2 = await fetch(...);\n> \treturn await doSomethingWith(response1, response2);\n> }\n> ```\n\nWhat about that would mess it up? Is `someApi()` _explicitly_ emptying the context for some reason?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$s3Whkb5UtNfzylrlys2aUWTiyePbspIp_1YWTsvj-1I?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br><p>but in cases like this, wouldn't this mess up tracing?</p>\n<pre><code class=\"language-js\">async function someFunctionYouCareAboutTracing() {\n\tconst response1 = await fetch(...);\n\tawait someAPI();  // this empties out the context after the await!\n\tconst response2 = await fetch(...);\n\treturn await doSomethingWith(response1, response2);\n}\n</code></pre>\n</blockquote></mx-reply>What about that would mess it up? Is <code>someApi()</code> <em>explicitly</em> emptying the context for some reason?","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$s3Whkb5UtNfzylrlys2aUWTiyePbspIp_1YWTsvj-1I"}},"msgtype":"m.text"},"ts":1715939441584,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$k6nDyPLaBqiFTrtFupSmCDAuSf2Gsdz__u9d2dV_Ha4"},
{"content":{"body":"I meant the definition of `someApi()` above, which *is*","format":"org.matrix.custom.html","formatted_body":"I meant the definition of <code>someApi()</code> above, which <em>is</em>","m.mentions":{},"msgtype":"m.text"},"ts":1715939483931,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$omlSZoxF3LtkFtmG5u9cu5iWdpVZP1UqVKJeLy-ZQO8"},
{"content":{"body":"Ah, you mean it's restoring the snapshot captured previously?","m.mentions":{},"msgtype":"m.text"},"ts":1715939514499,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$yVmY8eE_AYaHaf0CNT97PaS6RTm39KbtarMw3Ncogc0"},
{"content":{"body":"Yeah, that would return to whatever the context was which was captured in that snapshot.","m.mentions":{},"msgtype":"m.text"},"ts":1715939537557,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$HAxpM_0ShrHdxN8NfiVEZBwXcDs6T-tNK0USCyb_Rx8"},
{"content":{"body":"So if you're using a snapshot in that way then that is _expected_.","format":"org.matrix.custom.html","formatted_body":"So if you're using a snapshot in that way then that is <em>expected</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1715939550650,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$-n0V1n8-xkt8aQOmhaesGX-UptAdk2bl0IZZb43JZaQ"},
{"content":{"body":"And this is also why I would like to have per-instance bind because sometimes it makes sense globally like connection pools, but sometimes opinions may vary.","m.mentions":{},"msgtype":"m.text"},"ts":1715939598005,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$870bZgItz1cXabIuMF9yB5Cok0IHdaUBTnlJa1AzXyI"},
{"content":{"body":"maybe this isn't something worth worrying about, but someone might be using snapshots to do things around their `AsyncContext.Variable`s not realizing that that might affect the context in which their promise gets resolved, which would affect other use libraries that use AsyncContext","format":"org.matrix.custom.html","formatted_body":"maybe this isn't something worth worrying about, but someone might be using snapshots to do things around their <code>AsyncContext.Variable</code>s not realizing that that might affect the context in which their promise gets resolved, which would affect other use libraries that use AsyncContext","m.mentions":{},"msgtype":"m.text"},"ts":1715939601929,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$uSCTzgHo93-kaifp148sGlmKU3ZjBjl4hlJs5uoRdjQ"},
{"content":{"body":"also, if you have an interaction of various libraries that use AsyncContext for their separate goals, they might interact in unforeseen ways","m.mentions":{},"msgtype":"m.text"},"ts":1715939650271,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$LcqeCoPvIT19ePIvRoSGlWPsDx-VjVeOau36ZS8Np84"},
{"content":{"body":"But yes, I believe it is \"correct\" for that to break context. Or rather, it might be _incorrect_ that it is _doing_ that snapshot restore.","format":"org.matrix.custom.html","formatted_body":"But yes, I believe it is \"correct\" for that to break context. Or rather, it might be <em>incorrect</em> that it is <em>doing</em> that snapshot restore.","m.mentions":{},"msgtype":"m.text"},"ts":1715939652401,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$roqbvf7xQ-nL1cANv5xmyz2FSR1tjGw8HigZokERu9w"},
{"content":{"body":"> <@abotella:igalia.com> maybe this isn't something worth worrying about, but someone might be using snapshots to do things around their `AsyncContext.Variable`s not realizing that that might affect the context in which their promise gets resolved, which would affect other use libraries that use AsyncContext\n\nYep, this is why Node.js hates `AsyncResource`. 🙈","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$uSCTzgHo93-kaifp148sGlmKU3ZjBjl4hlJs5uoRdjQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>maybe this isn't something worth worrying about, but someone might be using snapshots to do things around their <code>AsyncContext.Variable</code>s not realizing that that might affect the context in which their promise gets resolved, which would affect other use libraries that use AsyncContext</blockquote></mx-reply>Yep, this is why Node.js hates <code>AsyncResource</code>. 🙈","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$uSCTzgHo93-kaifp148sGlmKU3ZjBjl4hlJs5uoRdjQ"}},"msgtype":"m.text"},"ts":1715939686296,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$0PE6KQA652708l1HiylhPIHAG4mqNkOjEghUpf9AYvY"},
{"content":{"body":"So in Node.js, async_hooks made the mistake of producing a _singular_ execution graph which is grafted with `AsyncResource` binds. AsyncLocalStorage is layered over it so it inherits that mistake. We want it to _not_ be layered over that so we can _fix_ that problem.","format":"org.matrix.custom.html","formatted_body":"So in Node.js, async_hooks made the mistake of producing a <em>singular</em> execution graph which is grafted with <code>AsyncResource</code> binds. AsyncLocalStorage is layered over it so it inherits that mistake. We want it to <em>not</em> be layered over that so we can <em>fix</em> that problem.","m.mentions":{},"msgtype":"m.text"},"ts":1715939802544,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$5RcryGbpENY1GJlZx0iemuxp9R44x4byHLolZmeIDAQ"},
{"content":{"body":"I'm not sure I understand. Even if we do have per-instance wrap, you would still need global wraps, right?","m.mentions":{},"msgtype":"m.text"},"ts":1715939862009,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$NQtFrWz7YbD6CnxxRc4Q0ORo8UL49QXJswxDWAldsV4"},
{"content":{"body":"APMs (unfortunately) fairly often use `AsyncResource` to \"fix\" context management flows, but then we break other vendors because we change the graph _they_ were expecting. 😬","format":"org.matrix.custom.html","formatted_body":"APMs (unfortunately) fairly often use <code>AsyncResource</code> to \"fix\" context management flows, but then we break other vendors because we change the graph <em>they</em> were expecting. 😬","m.mentions":{},"msgtype":"m.text"},"ts":1715939878592,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$f3egj7JPRmzNl2tjbg9yn4TxVSLrpp2C06MzE1DBh1E"},
{"content":{"body":"Yes, global is still needed.","m.mentions":{},"msgtype":"m.text"},"ts":1715939892324,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$u1aHucjZbZvuMe9-1yR1uDWPjEbnVlRhaxtD9SEIXmI"},
{"content":{"body":"Just not _always_.","format":"org.matrix.custom.html","formatted_body":"Just not <em>always</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1715939898625,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$nPCrsuXd0wi3n3Vebj2DDSrcsXm4Ia__d_bz0Cv9K5c"},
{"content":{"body":"And this is specifically why I created the WindowChannel concept. So different consumers could make different decisions in a reasonably user-friendly way.","m.mentions":{},"msgtype":"m.text"},"ts":1715939938651,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$szQmQTiWAVpy5RYW5L89CN2LFxrZAiKIWyNt4InHk6Y"},
{"content":{"body":"So my worry is about a (maybe small) library that might not realize they're supposed to be doing per-instance wrap rather than global wrap, since it works fine in their tests","m.mentions":{},"msgtype":"m.text"},"ts":1715939999376,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$SI2OhNllvsQfOVAAZftK3t5rRPL41Gtg_oyf7uIlujc"},
{"content":{"body":"Or cases where a library might have multiple variables and they use global wrap to handle all of them at once","m.mentions":{},"msgtype":"m.text"},"ts":1715940013224,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Yi2UJToD3IWpyfr8qCkX5YG7wXLdbKpRGHTomzekhDM"},
{"content":{"body":"I mean, that _will_ be a problem. But _without_ instance-scoped bind it's _still_ a problem, just without a solution.","format":"org.matrix.custom.html","formatted_body":"I mean, that <em>will</em> be a problem. But <em>without</em> instance-scoped bind it's <em>still</em> a problem, just without a solution.","m.mentions":{},"msgtype":"m.text"},"ts":1715940047863,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$PmHs_LuQ7m2OG_Eu1I6cXhI8A8758jOc-LDoDYZ3g-s"},
{"content":{"body":"right, I thought making it part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API","m.mentions":{},"msgtype":"m.text"},"ts":1715940085300,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$386_7FFNBhJO9qaS9LNzRw5bXc68PcXmNG2IapxOO0E"},
{"content":{"body":" * right, I thought making per-instance wrap part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API","m.mentions":{},"m.new_content":{"body":"right, I thought making per-instance wrap part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$386_7FFNBhJO9qaS9LNzRw5bXc68PcXmNG2IapxOO0E","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715940098524,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$bWz3EojcrNVDmsQ-wpKywH3TR0RGA2VAmOgGhHD2wX0"},
{"content":{"body":"People are _going_ to use APIs wrong. We can't stop that. At best we can _try_ to make it _clear_ when they're doing it wrong.","format":"org.matrix.custom.html","formatted_body":"People are <em>going</em> to use APIs wrong. We can't stop that. At best we can <em>try</em> to make it <em>clear</em> when they're doing it wrong.","m.mentions":{},"msgtype":"m.text"},"ts":1715940098591,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$8D1-iSLt2-XQyAaZ6c38khy8w1JxcXyx4X4YV3sWIFc"},
{"content":{"body":" * right, I thought making per-instance wrap part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API design","m.mentions":{},"m.new_content":{"body":"right, I thought making per-instance wrap part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API design","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$386_7FFNBhJO9qaS9LNzRw5bXc68PcXmNG2IapxOO0E","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715940115113,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$q3cduu7lAtpL9IIHdbH6MnJdAUBh_M9gIErVYqbU6GQ"},
{"content":{"body":"I mean, you _can_ just do it with a `store.get()` and a closure that does `store.run(...)` around the orignal function. So it's _easy enough_ to do externally. But I _personally_ feel it should be part of the actual API, for clarity.","format":"org.matrix.custom.html","formatted_body":"I mean, you <em>can</em> just do it with a <code>store.get()</code> and a closure that does <code>store.run(...)</code> around the orignal function. So it's <em>easy enough</em> to do externally. But I <em>personally</em> feel it should be part of the actual API, for clarity.","m.mentions":{},"msgtype":"m.text"},"ts":1715940158480,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$gAAUqBHGAvay_a5ZY3u9MW64nVi50OU7rKhxAYSvOeU"},
{"content":{"body":"yeah, I see that now","m.mentions":{},"msgtype":"m.text"},"ts":1715940170651,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$6R9jn1G9l5Rrj7bheBkAz7HX566K4eXXIDHWsSbvo2Q"},
{"content":{"body":"Well, that's not _completely_ true if we have the sync vs continuation differentiation, but that's another thing.","format":"org.matrix.custom.html","formatted_body":"Well, that's not <em>completely</em> true if we have the sync vs continuation differentiation, but that's another thing.","m.mentions":{},"msgtype":"m.text"},"ts":1715940205965,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kgX-wzmp8-6CZi4sxIUmy0euGk69wzAwQG3lmsKKpGg"},
{"content":{"body":"That's also why in my RFC I was explicitly defining separate windows.","m.mentions":{},"msgtype":"m.text"},"ts":1715940241599,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$G0KP3s_oYDyuHS-RghrMNCT37HpckGGtyEl4xnIaPr4"},
{"content":{"body":"With separate windows you could make the `store.run(...)` be a `continuationWindow.run(...)` instead and key the child-of versus follows-from decision off that.","format":"org.matrix.custom.html","formatted_body":"With separate windows you could make the <code>store.run(...)</code> be a <code>continuationWindow.run(...)</code> instead and key the child-of versus follows-from decision off that.","m.mentions":{},"msgtype":"m.text"},"ts":1715940427468,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$UsGMcUdsYsUDlx_xRz9ZVa2-kH8FXfC58rL7OQ19BDQ"},
{"content":{"body":"I think separating those concepts from user perspective might be a bit too much complication though. I'm definitely one that would advocate for making it actively _difficult_ to use APIs wrong. It can be challenging to do, but given a large enough pool of users you will _for sure_ encounter a bunch which find some way to use it wrong. 😅","format":"org.matrix.custom.html","formatted_body":"I think separating those concepts from user perspective might be a bit too much complication though. I'm definitely one that would advocate for making it actively <em>difficult</em> to use APIs wrong. It can be challenging to do, but given a large enough pool of users you will <em>for sure</em> encounter a bunch which find some way to use it wrong. 😅","m.mentions":{},"msgtype":"m.text"},"ts":1715940613860,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$LPiEaWgAzsDWWbdScQCJJW7hUuJWKfrRie_SQmixVfg"},
{"content":{"body":"The less footguns we can give users the better. 🙈","m.mentions":{},"msgtype":"m.text"},"ts":1715940670047,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$AYKoTRba6CDbtMAWxR6EUfy_hVqMLWotUPBwwPeDiss"},
{"content":{"body":"If we have instance-scoped bind, should we give the instance and global versions different but related names to make the intent a bit more clear? Something like `instance.bind(...)` and `Variable.bindAllVariables(...)` or something like that?","format":"org.matrix.custom.html","formatted_body":"If we have instance-scoped bind, should we give the instance and global versions different but related names to make the intent a bit more clear? Something like <code>instance.bind(...)</code> and <code>Variable.bindAllVariables(...)</code> or something like that?","m.mentions":{},"msgtype":"m.text"},"ts":1715948803742,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$foHzAEkIgjyLx7hQfGHea14vSE9EYCB9RL3VBrTN9mE"}
]