[
{"content":{"body":"> <@stephenhicks:matrix.org> Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).\n\nHow would noWrap work?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).</blockquote></mx-reply>How would noWrap work?","m.relates_to":{"m.in_reply_to":{"event_id":"$EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw"}},"msgtype":"m.text"},"ts":1715907220800,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$YGSwAvvDL09E7_tX0CQwAO_xL9R1U-3UvW_A-e5z16M"},
{"content":{"body":"Like it cancels out a wrap that happens around it?","msgtype":"m.text"},"ts":1715907292752,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uplQ9zEoK3Gu_qN5QFM8IZJRZccaeYGul0xwHvkvlyg"},
{"content":{"body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel _all_ wraps that happen around it?  not quite clear - it's just one option.","format":"org.matrix.custom.html","formatted_body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel <em>all</em> wraps that happen around it?  not quite clear - it's just one option.","m.mentions":{},"msgtype":"m.text"},"ts":1715910138145,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$fo9bNJpWvVkYyBLuA_TTB2aw53ue3_x5DHip2Gm5lYo"},
{"content":{"body":"It feels kinda vaguely non-compositional to cancel out wrap; maybe better to avoid wrapping in the first place. Werenâ€™t we discussing options for that? (But then you run into the â€œno null contextâ€ issue also)","msgtype":"m.text"},"ts":1715912773343,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$PKy07SQDTP-xYyBrSjIWI6gnTIfLV_eh1j4vqgyMMt0"},
{"content":{"body":"I am not being very clear with noncompositionalâ€¦ I guess I mean, if you replace f with n => f(n), then noWrap stops working","format":"org.matrix.custom.html","formatted_body":"I am not being very clear with noncompositionalâ€¦ I guess I mean, if you replace f with n =&gt; f(n), then noWrap stops working","msgtype":"m.text"},"ts":1715912830280,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$CW0k7Q39o1t9xziXUZasl2c0i1y3VidrKGo0yigKQQ0"},
{"content":{"body":"not necessarily - it depends on how it's implemente.d","m.mentions":{},"msgtype":"m.text"},"ts":1715912861651,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc"},
{"content":{"body":" * not necessarily - it depends on how it's implemented.","m.mentions":{},"m.new_content":{"body":"not necessarily - it depends on how it's implemented.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715912869320,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$3VgL5DTrLBB7-jwRfgdf8VSxZOvAiMr_db9LKuRp5qQ"},
{"content":{"body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to `n => f(n)`, though it makes `wrap` no longer idempotent (i.e. `wrap(wrap(unwrap(f))) == wrap(f)`) and there's potentially weirdness around `unwrap(unwrap(f)) == f` or some such...","format":"org.matrix.custom.html","formatted_body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to <code>n =&gt; f(n)</code>, though it makes <code>wrap</code> no longer idempotent (i.e. <code>wrap(wrap(unwrap(f))) == wrap(f)</code>) and there's potentially weirdness around <code>unwrap(unwrap(f)) == f</code> or some such...","m.mentions":{},"msgtype":"m.text"},"ts":1715912973250,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wKTF6I0lWpbosIXMTo4FDdkbmekefYaJejvaNBpT3Hc"},
{"content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer","m.mentions":{},"msgtype":"m.text"},"ts":1715913011588,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI"},
{"content":{"body":" * or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"m.new_content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715913020611,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$FYgMsDLwJQrbZAhm14izw2ZZoktgRAI5IU1f2ZFxb5g"},
{"content":{"body":"but it would only work from the _inside_ - `unwrap(wrap(f)) == wrap(f)`, which is surprising","format":"org.matrix.custom.html","formatted_body":"but it would only work from the <em>inside</em> - <code>unwrap(wrap(f)) == wrap(f)</code>, which is surprising","m.mentions":{},"msgtype":"m.text"},"ts":1715913056643,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$nS6aLBYhrD7a5-MEY_Qee5EmvI9yoGmzC-o5lZNUeNc"},
{"content":{"body":"I don't love those properties... but I think any observability of `callingContext` probably breaks idempotency of `wrap`, so maybe there's no way to keep that one?","format":"org.matrix.custom.html","formatted_body":"I don't love those properties... but I think any observability of <code>callingContext</code> probably breaks idempotency of <code>wrap</code>, so maybe there's no way to keep that one?","m.mentions":{},"msgtype":"m.text"},"ts":1715913162489,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$akZY0WOEvY3nOCx-3AdUHGACfPDnFDsQnxNaDTpSCc0"},
{"content":{"body":"Huh, how would it figure out the previous one at runtime? Currently you can just use a single global variable for the current snapshot.","msgtype":"m.text"},"ts":1715933264279,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Ubc6S-24ylQdPdalM-MjqRn2FrSfCDFsd0kdQq7oaWA"},
{"content":{"body":"> <@legendecas:matrix.org> Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case\n\nThe resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.\n\n```js\nasync function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n```","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case</blockquote></mx-reply><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U"}},"msgtype":"m.text"},"ts":1715934967864,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg"},
{"content":{"body":"Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.","msgtype":"m.text"},"ts":1715935330060,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw"},
{"content":{"body":"> <@littledan:matrix.org> where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)\n\nThere's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically _guess_ what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which _could_ be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we _want_ is for the _correct_ context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$h_zhAigENlGCCHlTu8LV8JAy1-U9w9n7QrjlnenFFEI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)</blockquote></mx-reply>There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically <em>guess</em> what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which <em>could</em> be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we <em>want</em> is for the <em>correct</em> context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$h_zhAigENlGCCHlTu8LV8JAy1-U9w9n7QrjlnenFFEI"}},"msgtype":"m.text"},"ts":1715935361677,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7845b1Ylx3JkiWv6_8b0hC6-nGeUDFf8tFhq98KG9HU"},
{"content":{"body":"> <@littledan:matrix.org> I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)\n\nWe don't need the list of all context historically, only a way at any given snapshot restore to elect to keep the prior value which already flowed in and additionally to be able to have a way to configure stores to capture resolve time of promises rather than register time.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$dMLpRbSSuZA1rSMR4AGSCXfE2W0sNPwaPATL2edwOIU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)</blockquote></mx-reply>We don't need the list of all context historically, only a way at any given snapshot restore to elect to keep the prior value which already flowed in and additionally to be able to have a way to configure stores to capture resolve time of promises rather than register time.","m.mentions":{"user_ids":["@littledan:matrix.org","@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$dMLpRbSSuZA1rSMR4AGSCXfE2W0sNPwaPATL2edwOIU"}},"msgtype":"m.text"},"ts":1715935551918,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$nmHe_RGyhL8l9LamJChEU-_S2182izt6R4u-tPUQ8CE"},
{"content":{"body":"> <@stephenhicks:matrix.org> The \"don't bind around await\" case feels a lot like \"just use a global variable\" to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you're not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would \"just work\" since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn't actually have to wait - and maybe also when two independent jobs are running interleaved?\n> \n> So a global variable is obviously a bit too naive to work, but where I'm struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you're presumably not clobbering the actual container variable, then that part shouldn't need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it's important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.\n\nIt's not that we need _no_ binds for async/await, it's that we want it to bind at the resolve point of the promise being awaited rather than at registration time directly at the point the await occurs. This would mean context would flow _through_ promises rather than _around_ them. It would _also_ mean the restore which occurs _after_ the await resumes would be that resolve point value rather than what the value was before the await occurred.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$he4xZQ-PdgdKX904BDMhD42g2oD1ix0HioQEZHm1iJo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>The &quot;don&#39;t bind around await&quot; case feels a lot like &quot;just use a global variable&quot; to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you&#39;re not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would &quot;just work&quot; since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn&#39;t actually have to wait - and maybe also when two independent jobs are running interleaved?<br/><br/>So a global variable is obviously a bit too naive to work, but where I&#39;m struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you&#39;re presumably not clobbering the actual container variable, then that part shouldn&#39;t need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it&#39;s important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.</blockquote></mx-reply>It's not that we need <em>no</em> binds for async/await, it's that we want it to bind at the resolve point of the promise being awaited rather than at registration time directly at the point the await occurs. This would mean context would flow <em>through</em> promises rather than <em>around</em> them. It would <em>also</em> mean the restore which occurs <em>after</em> the await resumes would be that resolve point value rather than what the value was before the await occurred.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$he4xZQ-PdgdKX904BDMhD42g2oD1ix0HioQEZHm1iJo"}},"msgtype":"m.text"},"ts":1715935917954,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$r9w1iV0V6p9dgy8FqaFKuT6onyjAEZWn--y-PlIe2fU"},
{"content":{"body":"> <@stephenhicks:matrix.org> To Stephen's point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I'd argue that it's a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.\n\nIt's _intentional_ that it behaves that way with callbacks. That's how context management is _supposed_ to work as it's not useful for most cases if it doesn't flow into continuations. That's literally the _point_ of the \"async\" in AsyncLocalStorage.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$ixvqlJf4UxI_zT7HE3zHuzsSn-jlIEwdJ6_UKEUtcIA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>To Stephen&#39;s point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I&#39;d argue that it&#39;s a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.</blockquote></mx-reply>It's <em>intentional</em> that it behaves that way with callbacks. That's how context management is <em>supposed</em> to work as it's not useful for most cases if it doesn't flow into continuations. That's literally the <em>point</em> of the \"async\" in AsyncLocalStorage.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ixvqlJf4UxI_zT7HE3zHuzsSn-jlIEwdJ6_UKEUtcIA"}},"msgtype":"m.text"},"ts":1715936037976,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$XZQIAbcYyd_64GK2ySxnvS5WDhu0Oxfv1v9QOfo1tQQ"},
{"content":{"body":"I'm not even sure what use there _would_ be for the other way with callbacks. I don't see any use case for that flow. ðŸ¤”","format":"org.matrix.custom.html","formatted_body":"I'm not even sure what use there <em>would</em> be for the other way with callbacks. I don't see any use case for that flow. ðŸ¤”","m.mentions":{},"msgtype":"m.text"},"ts":1715936085906,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$DIF0Jy2Iy4Tv8XItMYRIJfLFTX_64LAZjWYKnM6JOGg"},
{"content":{"body":"> <@littledan:matrix.org> Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.\n\nYes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.</blockquote></mx-reply>Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw"}},"msgtype":"m.text"},"ts":1715936285980,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.\n\nOther languages work the way you are proposing we adopt for JS? That is great to know. Can you suggest a concrete one for us to look into?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.</blockquote></mx-reply>Other languages work the way you are proposing we adopt for JS? That is great to know. Can you suggest a concrete one for us to look into?","m.relates_to":{"m.in_reply_to":{"event_id":"$hTQBdcqoPQTh-LwzDqsy2bE4tKxcTsQ4MrltEqFT8GY"}},"msgtype":"m.text"},"ts":1715936327882,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$lOTrKs6K3U031OZlstw_udw5DCNpqOv2OHDEYcju86c"},
{"content":{"body":"Bytecode manipulation isnâ€™t magic; I would be surprised if we canâ€™t do whatâ€™s achieved with it","msgtype":"m.text"},"ts":1715936365166,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5c27WJNn3PFAgSaLA-PfMpQnKvaFOSmt5zEiTDl_6VQ"},
{"content":{"body":"Not sure. Like I said, most do this externally to the runtime itself so I'm unsure if any particular language is a good example of it.","m.mentions":{},"msgtype":"m.text"},"ts":1715936402350,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$o7J_9aDr6JHkxyYCJG8l6c0U-j39Lzp5P5sfGPQAorY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> The resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.\n> \n> ```js\n> async function foo() {\n>   console.log('1')\n>   await Promise.resolve()\n>   console.log('3')\n> }\n> foo()\n> console.log('2')\n> ```\n\n```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n</blockquote></mx-reply><pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg"}},"msgtype":"m.text"},"ts":1715936532623,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8"},
{"content":{"body":"Thatâ€™s OK if itâ€™s external, if it implements the right semantics I am still happy to have that as the reference point","msgtype":"m.text"},"ts":1715936545021,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$7HKpOGEjGOtNVQMRC8Wrdpx_2k8FNCsb4olu-xI2wSs"},
{"content":{"body":"> <@littledan:matrix.org> Bytecode manipulation isnâ€™t magic; I would be surprised if we canâ€™t do whatâ€™s achieved with it\n\nMuch of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$5c27WJNn3PFAgSaLA-PfMpQnKvaFOSmt5zEiTDl_6VQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Bytecode manipulation isnâ€™t magic; I would be surprised if we canâ€™t do whatâ€™s achieved with it</blockquote></mx-reply>Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$5c27WJNn3PFAgSaLA-PfMpQnKvaFOSmt5zEiTDl_6VQ"}},"msgtype":"m.text"},"ts":1715936552024,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$dUMTKiCoN678Wyf5pbK9TD3b0KMdfx3El18XlMCtA0E"},
{"content":{"body":" * ```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n</blockquote></mx-reply> * <pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{},"m.new_content":{"body":"```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  // child-of context.variable: SPAN0\n  // await connection.query() SPAN1\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN2.2\n      // If the context.variable at this point is SPAN2.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3\n      return connection.query('SELECT 3 + 3 AS four') // SPAN3\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715936590168,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Aer2fMndjp9NayGngicLDcbvp_oh6_i7Rl5oZnYdx-4"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.\n\nSounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24dUMTKiCoN678Wyf5pbK9TD3b0KMdfx3El18XlMCtA0E\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.</blockquote></mx-reply>Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy","m.relates_to":{"m.in_reply_to":{"event_id":"$dUMTKiCoN678Wyf5pbK9TD3b0KMdfx3El18XlMCtA0E"}},"msgtype":"m.text"},"ts":1715936613179,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$rx1tKRz1gsnZqo647tWhU6F5olyxdyTRcqLDIjFVxms"},
{"content":{"body":" * ```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":" * <pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{},"m.new_content":{"body":"```\nhandleRequest((req, res) => {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a => {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b => {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() => {\n      makeSecondRequest() // SPANx.2\n    })\n}\n```\n\nIn the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now","format":"org.matrix.custom.html","formatted_body":"<pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715936661970,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$fuqHUx61HlX3lwQ3JXEocu22i7xm7pUHb8Jk7d7dAeg"},
{"content":{"body":"> <@legendecas:matrix.org> ```\n> handleRequest((req, res) => {\n>   // ROOT SPAN0\n>   connection.query('SELECT 1 + 1 AS two') // SPAN1\n>     .then(a => {\n>       // PROPOSED CONTEXT: SPAN1.2\n>       // If the context.variable at this point is SPAN1.2, how do we determine\n>       // child-of or follow-from?\n>       // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n>       return connection.query('SELECT 2 + 2 AS four') // SPAN2\n>     })\n>     .then(b => {\n>       // PROPOSED CONTEXT: SPAN3.2\n>       res.writeHead(200, { 'Content-Type': 'text/plain' })\n>       res.end(a[0].two + b[0].four)\n>     })\n> })\n> \n> function connectionQuery(query) {\n>   // Current Context: SPANx\n>   return makeFirstRequest() // SPANx.1\n>     .then(() => {\n>       makeSecondRequest() // SPANx.2\n>     })\n> }\n> ```\n> \n> In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now\n\nWhat do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br><pre><code>handleRequest((req, res) =&gt; {\n  // ROOT SPAN0\n  connection.query('SELECT 1 + 1 AS two') // SPAN1\n    .then(a =&gt; {\n      // PROPOSED CONTEXT: SPAN1.2\n      // If the context.variable at this point is SPAN1.2, how do we determine\n      // child-of or follow-from?\n      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2\n      return connection.query('SELECT 2 + 2 AS four') // SPAN2\n    })\n    .then(b =&gt; {\n      // PROPOSED CONTEXT: SPAN3.2\n      res.writeHead(200, { 'Content-Type': 'text/plain' })\n      res.end(a[0].two + b[0].four)\n    })\n})\n\nfunction connectionQuery(query) {\n  // Current Context: SPANx\n  return makeFirstRequest() // SPANx.1\n    .then(() =&gt; {\n      makeSecondRequest() // SPANx.2\n    })\n}\n</code></pre>\n<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>\n</blockquote></mx-reply>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$rps9AxcFX8NV88wREzF7SViLk6plbKbnv_3gq5EMip8"}},"msgtype":"m.text"},"ts":1715936681373,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c"},
{"content":{"body":"> <@littledan:matrix.org> Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy\n\nI'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. ðŸ˜…","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rx1tKRz1gsnZqo647tWhU6F5olyxdyTRcqLDIjFVxms?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy</blockquote></mx-reply>I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on <em>other</em> languages. ðŸ˜…","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$rx1tKRz1gsnZqo647tWhU6F5olyxdyTRcqLDIjFVxms"}},"msgtype":"m.text"},"ts":1715936745440,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$rF1kgLStcwRkaxXE-ARf7f04pE8w5xmQUMkicplrTRU"},
{"content":{"body":"> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.\n\nThe example is equivalent to async-await as:\n```\n\nhandleRequest(async (req, res) => {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n```\nIs this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.</blockquote></mx-reply><p>The example is equivalent to async-await as:</p>\n<pre><code>\nhandleRequest(async (req, res) =&gt; {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n</code></pre>\n<p>Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c"}},"msgtype":"m.text"},"ts":1715936834491,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Tk62V2S6Q5ESb45RNyI6de01_-btpKgrcHMIvMWmM8o"},
{"content":{"body":"> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.\n\n * The example is equivalent to async-await as:\n\n```\nhandleRequest(async (req, res) => {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n```\n\nIs this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$8Ixkw3hzWsU1hAPUEKNRSO9xWxFmJIUB9T3XwyBGe8c?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.</blockquote></mx-reply> * <p>The example is equivalent to async-await as:</p>\n<pre><code>handleRequest(async (req, res) =&gt; {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n</code></pre>\n<p>Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?</p>\n","m.mentions":{},"m.new_content":{"body":"The example is equivalent to async-await as:\n\n```\nhandleRequest(async (req, res) => {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n```\n\nIs this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?","format":"org.matrix.custom.html","formatted_body":"<p>The example is equivalent to async-await as:</p>\n<pre><code>handleRequest(async (req, res) =&gt; {\n  // ROOT SPAN0\n  await connection.query('SELECT 1 + 1 AS two') // SPAN1\n  // PROPOSED CONTEXT: SPAN1.2\n  await connection.query('SELECT 2 + 2 AS four') // SPAN2\n  // PROPOSED CONTEXT: SPAN2.2\n  res.writeHead(200, { 'Content-Type': 'text/plain' })\n  res.end(a[0].two + b[0].four)\n})\n</code></pre>\n<p>Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Tk62V2S6Q5ESb45RNyI6de01_-btpKgrcHMIvMWmM8o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715936841304,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$qfqpocVGYYby-JwBsDAHCwj1LyAUox0A1R-zyoSSBFA"},
{"content":{"body":"Again, I'm unclear what the decimal point thing is about here?","m.mentions":{},"msgtype":"m.text"},"ts":1715937144538,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$v2uhYPZSjoY4Ti3TQNtAsMbXsppVoTZG13Xw4PBtma8"},
{"content":{"body":"> <@stephenbelanger:matrix.org> I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. ðŸ˜…\n\nSounds good, maybe we can all learn from this then","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24rF1kgLStcwRkaxXE-ARf7f04pE8w5xmQUMkicplrTRU\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on <em>other</em> languages. ðŸ˜…</blockquote></mx-reply>Sounds good, maybe we can all learn from this then","m.relates_to":{"m.in_reply_to":{"event_id":"$rF1kgLStcwRkaxXE-ARf7f04pE8w5xmQUMkicplrTRU"}},"msgtype":"m.text"},"ts":1715937238954,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$1D1G0nf1VF16GXaFTiq8J_N_0Y2UIeTGNKPzhkpMQP0"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Again, I'm unclear what the decimal point thing is about here?\n\nDecimal points represent child-of relations, increased number represets a follow-of relation.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$v2uhYPZSjoY4Ti3TQNtAsMbXsppVoTZG13Xw4PBtma8?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Again, I&#39;m unclear what the decimal point thing is about here?</blockquote></mx-reply>Decimal points represent child-of relations, increased number represets a follow-of relation.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$v2uhYPZSjoY4Ti3TQNtAsMbXsppVoTZG13Xw4PBtma8"}},"msgtype":"m.text"},"ts":1715937288057,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$y0064xrnCzOVZ_8_be6KYtqhCzGZid0FjzuqsNn-17w"},
{"content":{"body":"Ah, no. Only the first is a child-of because it occurs within the sync initial part of the async function.","m.mentions":{},"msgtype":"m.text"},"ts":1715937404326,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$I6S1a4Ajm8E0HvDR3xfWIiy2yRk4h_3_sUfoO-LxA6Y"},
{"content":{"body":"The second should be follows-from.","m.mentions":{},"msgtype":"m.text"},"ts":1715937416623,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$snRKk8n7sM3Nr22JfTdXCTgs4_Ra1OgB1EUlNEesQJE"},
{"content":{"body":"The `connection.query(...)` expression is called before its result is awaited, and it's the calling of that which produces a span. That span is therefore within the synchronous scope of the http server request span.","format":"org.matrix.custom.html","formatted_body":"The <code>connection.query(...)</code> expression is called before its result is awaited, and it's the calling of that which produces a span. That span is therefore within the synchronous scope of the http server request span.","m.mentions":{},"msgtype":"m.text"},"ts":1715937486350,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kPOJ8azIcAX8kAf12iWYw0Gfy6mCZ7c9pckHS-T9Rno"},
{"content":{"body":"If there was some _other_ await before it, even one which did not produce a span, then it would be considered follows-from.","format":"org.matrix.custom.html","formatted_body":"If there was some <em>other</em> await before it, even one which did not produce a span, then it would be considered follows-from.","m.mentions":{},"msgtype":"m.text"},"ts":1715937515450,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zRPn6-e6usOz1TxaKsupNAopv86sPfk3GTsZV4R64VQ"},
{"content":{"body":"yeah, so in a promise chain, child-of is no longer effective and I'm curious about how you curate a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"ts":1715937577968,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y"},
{"content":{"body":" * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you curate a graph with nesting semantics.","m.mentions":{},"m.new_content":{"body":"yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you curate a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715937611114,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$XDGnWewK-OnpBBENV-pHrBox9F2WOSwGCRuUCxOokJI"},
{"content":{"body":" * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you crate a graph with nesting semantics.","m.mentions":{},"m.new_content":{"body":"yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you crate a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715937652437,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$nfR4s5IotYtKFiPWgDnJWyqyZ1GEx7oVE1bhZC3PVOE"},
{"content":{"body":" * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.","m.mentions":{},"m.new_content":{"body":"yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715937656569,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$7poUhRkFmlxmNycq5Q1XvvNSU4xK2VHJe_DJUcsilxY"},
{"content":{"body":"That would look the same. The creation of that initial promise produces a sync/child-of span, and then anything in following `then(...)` continuations would be follows-from of whichever thing in the chain last produced a span.","format":"org.matrix.custom.html","formatted_body":"That would look the same. The creation of that initial promise produces a sync/child-of span, and then anything in following <code>then(...)</code> continuations would be follows-from of whichever thing in the chain last produced a span.","m.mentions":{},"msgtype":"m.text"},"ts":1715937683707,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$3e_8Ls2RuYDx5kMmb3ETy5-T88OKnQHmzHYKgTJHpos"},
{"content":{"body":"So from a user code behaviour perspective, callbacks, promises, and async/await would all produce the same graph.","m.mentions":{},"msgtype":"m.text"},"ts":1715937734625,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$eLlxiE-wyMXDrAW1uaSt9PMacUcBMM00C8t6sWJ1I8w"},
{"content":{"body":"And in the less common case where a continuation is attached far away from where the promise is created, a manual bind could be used where necessary to express that further away logical path, if it makes sense.","m.mentions":{},"msgtype":"m.text"},"ts":1715937794618,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$sr1tw1qeeLzL_PKGleGYJGp1nZyuah-agfwILF0xqtw"},
{"content":{"body":"But generally from APM perspective we basically _never_ want that further away path.","format":"org.matrix.custom.html","formatted_body":"But generally from APM perspective we basically <em>never</em> want that further away path.","m.mentions":{},"msgtype":"m.text"},"ts":1715937810365,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$EL5GIA5noCPPuqSTEhLm1_q1NoyfxepuQRCDMx16rMU"},
{"content":{"body":"Meaning register time of a promise continuation.","m.mentions":{},"msgtype":"m.text"},"ts":1715937834218,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kAQ-rbFYxnAp6a0iZ3bY6DGmRGGmSRdMAbeCYw1ot_w"},
{"content":{"body":"We want resolve time basically universally.","m.mentions":{},"msgtype":"m.text"},"ts":1715937846140,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7nXzK5wYBAp0lrmm566TRATfFbViHOR8liYeucX0TXI"},
{"content":{"body":"As do basically all userland context flow use cases I'm aware of. I'm very unclear what the actual use case is for register time binding. ðŸ˜•","m.mentions":{},"msgtype":"m.text"},"ts":1715937881715,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$HGy7ZA1-tA0Z0R8MDmDpLPbwHGMnPZGcqEDgxcItOps"},
{"content":{"body":"Sometimes there is no particular resolve time context to apply, and we just need to fall back to register time","msgtype":"m.text"},"ts":1715937934703,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$6dofd0YL1LMpA8NTJIwwjphiaEZIXmTyWuMxzfiEUxA"},
{"content":{"body":"If it goes to a browser/os primitive","msgtype":"m.text"},"ts":1715937959306,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$KQ0wnnUNmv9-vW0LX81NwVrf7jYhePThNMkS_r93Uv4"},
{"content":{"body":"Thereâ€™s the general connection pooling case, which generalizes this","msgtype":"m.text"},"ts":1715938021556,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$LPW3WH4SUYUYbcwJG1aHu2ZDjORvQAmmCez6geziFoQ"},
{"content":{"body":"Generally to get child-of edges, donâ€™t you want restore after await? Sync is not enough.","msgtype":"m.text"},"ts":1715938136391,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$JqyAfPEehVXYA8gh86mXP-RgZrBIF5cuobo0Wc5dpNg"},
{"content":{"body":"Resolve time naturally flows out to eventually promise-creation time--the thing you called which created a promise.","m.mentions":{},"msgtype":"m.text"},"ts":1715938156851,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$RfjDMpUnfcgQAmJHQsor_sKpoGDGqHQrbWunoN7BuNQ"},
{"content":{"body":"What do you mean â€œflows out toâ€?","msgtype":"m.text"},"ts":1715938177829,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$g40keoDWVZAFl8CBhJ1Nf_FFgC3kgt9g0_a85ynP2So"},
{"content":{"body":"> <@littledan:matrix.org> Generally to get child-of edges, donâ€™t you want restore after await? Sync is not enough.\n\nChild-of edges are easy. They are just things happening synchronously within the current scope, so we don't need anything for that. Not sure why restoring matters here? ðŸ¤”","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$JqyAfPEehVXYA8gh86mXP-RgZrBIF5cuobo0Wc5dpNg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Generally to get child-of edges, donâ€™t you want restore after await? Sync is not enough.</blockquote></mx-reply>Child-of edges are easy. They are just things happening synchronously within the current scope, so we don't need anything for that. Not sure why restoring matters here? ðŸ¤”","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$JqyAfPEehVXYA8gh86mXP-RgZrBIF5cuobo0Wc5dpNg"}},"msgtype":"m.text"},"ts":1715938213748,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$85EwmYX_tId53eUiO2mB7ckUkkZS-gPhK02TqqBxybg"},
{"content":{"body":"> <@littledan:matrix.org> What do you mean â€œflows out toâ€?\n\nI mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is _done_. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that _was_ in JS, which is when the original call happened.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$g40keoDWVZAFl8CBhJ1Nf_FFgC3kgt9g0_a85ynP2So?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>What do you mean â€œflows out toâ€?</blockquote></mx-reply>I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is <em>done</em>. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that <em>was</em> in JS, which is when the original call happened.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$g40keoDWVZAFl8CBhJ1Nf_FFgC3kgt9g0_a85ynP2So"}},"msgtype":"m.text"},"ts":1715938325532,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$h3ZdDJy4WPz03u0oaQHjkzxL_gAPrBNN-MCB2qY8LAs"},
{"content":{"body":"> <@legendecas:matrix.org> yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.\n\nSo it seems like we have a disagreement in this chat about this statement. How can we look into it further? Maybe analyzing some concrete cases?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.</blockquote></mx-reply>So it seems like we have a disagreement in this chat about this statement. How can we look into it further? Maybe analyzing some concrete cases?","m.relates_to":{"m.in_reply_to":{"event_id":"$Fbl8Cs0xsaVrdCsqT1crewVfxkanMdAFTdbH-LmR26Y"}},"msgtype":"m.text"},"ts":1715938392618,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$4IqDLhVeqSsgVxVNdj61HAujJ72CqnUJaIVvGD2AYks"},
{"content":{"body":"Creation of a promise is just an allocation. It's not controlling flow at that point. The actual _scheduling_ of a promise is the providing of a value to resolve it with.","format":"org.matrix.custom.html","formatted_body":"Creation of a promise is just an allocation. It's not controlling flow at that point. The actual <em>scheduling</em> of a promise is the providing of a value to resolve it with.","m.mentions":{},"msgtype":"m.text"},"ts":1715938406949,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$phNNX0-fTX6d3gIv64RV8l0VHOvD8Ot7JDMffrSmOeE"},
{"content":{"body":"> <@stephenbelanger:matrix.org> I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is _done_. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that _was_ in JS, which is when the original call happened.\n\nin JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no `AsyncContext.Snapshot.p.run` along the promise resolution path?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$h3ZdDJy4WPz03u0oaQHjkzxL_gAPrBNN-MCB2qY8LAs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is <em>done</em>. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that <em>was</em> in JS, which is when the original call happened.</blockquote></mx-reply>in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no <code>AsyncContext.Snapshot.p.run</code> along the promise resolution path?","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$h3ZdDJy4WPz03u0oaQHjkzxL_gAPrBNN-MCB2qY8LAs"}},"msgtype":"m.text"},"ts":1715938569883,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$9z-i1rmdJ_RqY4A0vypv6fk9dqWKRveoNDtlq_eGDqs"},
{"content":{"body":"> <@abotella:igalia.com> in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no `AsyncContext.Snapshot.p.run` along the promise resolution path?\n\nNot sure what you mean by that. Do you have an example?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$9z-i1rmdJ_RqY4A0vypv6fk9dqWKRveoNDtlq_eGDqs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no <code>AsyncContext.Snapshot.p.run</code> along the promise resolution path?</blockquote></mx-reply>Not sure what you mean by that. Do you have an example?","m.mentions":{"user_ids":["@abotella:igalia.com","@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$9z-i1rmdJ_RqY4A0vypv6fk9dqWKRveoNDtlq_eGDqs"}},"msgtype":"m.text"},"ts":1715938656873,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ZFR73FpokWSVwEmBEPcGJKYHVIkV8xnlv_Ub3zsl8Sw"},
{"content":{"body":"From _my_ perspective: context flows into the promise executor, it flows into anything that happens _within_ that executor, it then captures whenever the `resolve(...)` is called as _that_ is what actually schedules passing the value to continuations. If the context value is set outside the promise constructor it will use that context. If it gets set somewhere within the executor leading up to when it calls `resolve(...)` it will use that. It all flows naturally toward the resolve point where it schedules the value to pass to continuations.","format":"org.matrix.custom.html","formatted_body":"From <em>my</em> perspective: context flows into the promise executor, it flows into anything that happens <em>within</em> that executor, it then captures whenever the <code>resolve(...)</code> is called as <em>that</em> is what actually schedules passing the value to continuations. If the context value is set outside the promise constructor it will use that context. If it gets set somewhere within the executor leading up to when it calls <code>resolve(...)</code> it will use that. It all flows naturally toward the resolve point where it schedules the value to pass to continuations.","m.mentions":{},"msgtype":"m.text"},"ts":1715938786689,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ni61_VWmEBb8JKv7R8LtajUpS0p7aFIicAmzfAQj9II"}
]