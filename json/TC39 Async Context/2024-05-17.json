[
{"content":{"body":"> <@stephenhicks:matrix.org> Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).\n\nHow would noWrap work?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).</blockquote></mx-reply>How would noWrap work?","m.relates_to":{"m.in_reply_to":{"event_id":"$EnoDfTZviK76WP6prhSD8VOrH_jf0sBrKxf-97Z8yxw"}},"msgtype":"m.text"},"ts":1715907220800,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$YGSwAvvDL09E7_tX0CQwAO_xL9R1U-3UvW_A-e5z16M"},
{"content":{"body":"Like it cancels out a wrap that happens around it?","msgtype":"m.text"},"ts":1715907292752,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uplQ9zEoK3Gu_qN5QFM8IZJRZccaeYGul0xwHvkvlyg"},
{"content":{"body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel _all_ wraps that happen around it?  not quite clear - it's just one option.","format":"org.matrix.custom.html","formatted_body":"yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel <em>all</em> wraps that happen around it?  not quite clear - it's just one option.","m.mentions":{},"msgtype":"m.text"},"ts":1715910138145,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$fo9bNJpWvVkYyBLuA_TTB2aw53ue3_x5DHip2Gm5lYo"},
{"content":{"body":"It feels kinda vaguely non-compositional to cancel out wrap; maybe better to avoid wrapping in the first place. Weren’t we discussing options for that? (But then you run into the “no null context” issue also)","msgtype":"m.text"},"ts":1715912773343,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$PKy07SQDTP-xYyBrSjIWI6gnTIfLV_eh1j4vqgyMMt0"},
{"content":{"body":"I am not being very clear with noncompositional… I guess I mean, if you replace f with n => f(n), then noWrap stops working","format":"org.matrix.custom.html","formatted_body":"I am not being very clear with noncompositional… I guess I mean, if you replace f with n =&gt; f(n), then noWrap stops working","msgtype":"m.text"},"ts":1715912830280,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$CW0k7Q39o1t9xziXUZasl2c0i1y3VidrKGo0yigKQQ0"},
{"content":{"body":"not necessarily - it depends on how it's implemente.d","m.mentions":{},"msgtype":"m.text"},"ts":1715912861651,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc"},
{"content":{"body":" * not necessarily - it depends on how it's implemented.","m.mentions":{},"m.new_content":{"body":"not necessarily - it depends on how it's implemented.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$JSq4BuMFaqfVj09SzgIqwAwwrWYk1lN8pDpirDnGtrc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715912869320,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$3VgL5DTrLBB7-jwRfgdf8VSxZOvAiMr_db9LKuRp5qQ"},
{"content":{"body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to `n => f(n)`, though it makes `wrap` no longer idempotent (i.e. `wrap(wrap(unwrap(f))) == wrap(f)`) and there's potentially weirdness around `unwrap(unwrap(f)) == f` or some such...","format":"org.matrix.custom.html","formatted_body":"If the implementation is to explicitly restore the previous snapshot, then it's robust to <code>n =&gt; f(n)</code>, though it makes <code>wrap</code> no longer idempotent (i.e. <code>wrap(wrap(unwrap(f))) == wrap(f)</code>) and there's potentially weirdness around <code>unwrap(unwrap(f)) == f</code> or some such...","m.mentions":{},"msgtype":"m.text"},"ts":1715912973250,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wKTF6I0lWpbosIXMTo4FDdkbmekefYaJejvaNBpT3Hc"},
{"content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer","m.mentions":{},"msgtype":"m.text"},"ts":1715913011588,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI"},
{"content":{"body":" * or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"m.new_content":{"body":"or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$PEl76MZEJEW3nRgoNlN_Oh_ygpGzk97gIVMp082HVsI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715913020611,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$FYgMsDLwJQrbZAhm14izw2ZZoktgRAI5IU1f2ZFxb5g"},
{"content":{"body":"but it would only work from the _inside_ - `unwrap(wrap(f)) == wrap(f)`, which is surprising","format":"org.matrix.custom.html","formatted_body":"but it would only work from the <em>inside</em> - <code>unwrap(wrap(f)) == wrap(f)</code>, which is surprising","m.mentions":{},"msgtype":"m.text"},"ts":1715913056643,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$nS6aLBYhrD7a5-MEY_Qee5EmvI9yoGmzC-o5lZNUeNc"},
{"content":{"body":"I don't love those properties... but I think any observability of `callingContext` probably breaks idempotency of `wrap`, so maybe there's no way to keep that one?","format":"org.matrix.custom.html","formatted_body":"I don't love those properties... but I think any observability of <code>callingContext</code> probably breaks idempotency of <code>wrap</code>, so maybe there's no way to keep that one?","m.mentions":{},"msgtype":"m.text"},"ts":1715913162489,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$akZY0WOEvY3nOCx-3AdUHGACfPDnFDsQnxNaDTpSCc0"},
{"content":{"body":"Huh, how would it figure out the previous one at runtime? Currently you can just use a single global variable for the current snapshot.","msgtype":"m.text"},"ts":1715933264279,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Ubc6S-24ylQdPdalM-MjqRn2FrSfCDFsd0kdQq7oaWA"},
{"content":{"body":"> <@legendecas:matrix.org> Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case\n\nThe resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.\n\n```js\nasync function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n```","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case \"child-of\" would be meaning-less in promise's case</blockquote></mx-reply><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>\n<pre><code class=\"language-js\">async function foo() {\n  console.log('1')\n  await Promise.resolve()\n  console.log('3')\n}\nfoo()\nconsole.log('2')\n</code></pre>\n","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$0Vlcr8v-IZyHykI2ycuYGmYwFJmmClYTfeVnPH0j56U"}},"msgtype":"m.text"},"ts":1715934967864,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$FH4Wk4zCkoonh-Hx0YpVyBPxs1NnB5FYlOD2Y8h4Fpg"},
{"content":{"body":"Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.","msgtype":"m.text"},"ts":1715935330060,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$EfOks1arhTLhKSa2TFJZUoBFQwUoezgT07lCugBrEkw"},
{"content":{"body":"> <@littledan:matrix.org> where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)\n\nThere's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically _guess_ what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which _could_ be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we _want_ is for the _correct_ context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$h_zhAigENlGCCHlTu8LV8JAy1-U9w9n7QrjlnenFFEI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)</blockquote></mx-reply>There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically <em>guess</em> what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which <em>could</em> be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we <em>want</em> is for the <em>correct</em> context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$h_zhAigENlGCCHlTu8LV8JAy1-U9w9n7QrjlnenFFEI"}},"msgtype":"m.text"},"ts":1715935361677,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7845b1Ylx3JkiWv6_8b0hC6-nGeUDFf8tFhq98KG9HU"}
]