[
{"content":{"body":"I had some personal issues come up this week and missed the session where we talked about yield*.  But I was remiss because I really wanted to use the opportunity to get a sense of how the broader committee might feel about extending this yield.  I don't know if there's any opportunity at this point, or if not, I suppose I could reach out individually to folks who we think might be most opposed?\n\nAt this point, I'm still convinced that dropping all the spec around generators (so that there's no context preservation around any yields, and yield just propagates through from the next() call) is the right thing to do - (1) 99% of the time it's irrelevant, (2) it's better performance to not need to do the extra swapping, (3) in the rare cases where it's not irrelevant, I'm pretty sure dispatch-context is the correct choice, (4) it's much less invasive to wrap it to get the other behavior, (5) generators are more like data than code - e.g. https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c","m.mentions":{},"msgtype":"m.text"},"ts":1758659473995,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$nEt4ovkWJXsH2LcypCm5ilwtm8gFPPcXRqW7slZTfD4"},
{"content":{"body":"* I had some personal issues come up this week and missed the session where we talked about yield\\*.  But I was remiss because I really wanted to use the opportunity to get a sense of how the broader committee might feel about extending this to also include ordinary yield.  I don't know if there's any opportunity at this point, or if not, I suppose I could reach out individually to folks who we think might be most opposed?\n\nAt this point, I'm still convinced that dropping all the spec around generators (so that there's no context preservation around any yields, and yield just propagates through from the next() call) is the right thing to do - (1) 99% of the time it's irrelevant, (2) it's better performance to not need to do the extra swapping, (3) in the rare cases where it's not irrelevant, I'm pretty sure dispatch-context is the correct choice, (4) it's much less invasive to wrap it to get the other behavior, (5) generators are more like data than code - e.g. https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c","format":"org.matrix.custom.html","formatted_body":"* I had some personal issues come up this week and missed the session where we talked about yield*.  But I was remiss because I really wanted to use the opportunity to get a sense of how the broader committee might feel about extending this to also include ordinary yield.  I don&#39;t know if there&#39;s any opportunity at this point, or if not, I suppose I could reach out individually to folks who we think might be most opposed?\n\nAt this point, I&#39;m still convinced that dropping all the spec around generators (so that there&#39;s no context preservation around any yields, and yield just propagates through from the next() call) is the right thing to do - (1) 99% of the time it&#39;s irrelevant, (2) it&#39;s better performance to not need to do the extra swapping, (3) in the rare cases where it&#39;s not irrelevant, I&#39;m pretty sure dispatch-context is the correct choice, (4) it&#39;s much less invasive to wrap it to get the other behavior, (5) generators are more like data than code - e.g. https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c","m.mentions":{},"m.new_content":{"body":"I had some personal issues come up this week and missed the session where we talked about yield\\*.  But I was remiss because I really wanted to use the opportunity to get a sense of how the broader committee might feel about extending this to also include ordinary yield.  I don't know if there's any opportunity at this point, or if not, I suppose I could reach out individually to folks who we think might be most opposed?\n\nAt this point, I'm still convinced that dropping all the spec around generators (so that there's no context preservation around any yields, and yield just propagates through from the next() call) is the right thing to do - (1) 99% of the time it's irrelevant, (2) it's better performance to not need to do the extra swapping, (3) in the rare cases where it's not irrelevant, I'm pretty sure dispatch-context is the correct choice, (4) it's much less invasive to wrap it to get the other behavior, (5) generators are more like data than code - e.g. https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c","format":"org.matrix.custom.html","formatted_body":"I had some personal issues come up this week and missed the session where we talked about yield*.  But I was remiss because I really wanted to use the opportunity to get a sense of how the broader committee might feel about extending this to also include ordinary yield.  I don&#39;t know if there&#39;s any opportunity at this point, or if not, I suppose I could reach out individually to folks who we think might be most opposed?\n\nAt this point, I&#39;m still convinced that dropping all the spec around generators (so that there&#39;s no context preservation around any yields, and yield just propagates through from the next() call) is the right thing to do - (1) 99% of the time it&#39;s irrelevant, (2) it&#39;s better performance to not need to do the extra swapping, (3) in the rare cases where it&#39;s not irrelevant, I&#39;m pretty sure dispatch-context is the correct choice, (4) it&#39;s much less invasive to wrap it to get the other behavior, (5) generators are more like data than code - e.g. https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$nEt4ovkWJXsH2LcypCm5ilwtm8gFPPcXRqW7slZTfD4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758659505945,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$eHl9ioS1khMlH6StEOMXJBHN-sRdTOdmvraC3ldfzGE"},
{"content":{"body":"* I had some personal issues come up this week and missed the session where we talked about yield\\*.  But I was remiss because I really wanted to use the opportunity to get a sense of how the broader committee might feel about extending this to also include ordinary yield.  I don't know if there's any opportunity to still bring it up in plenary at this point, or if not, I suppose I could reach out individually to folks who we think might be most opposed?\n\nAt this point, I'm still convinced that dropping all the spec around generators (so that there's no context preservation around any yields, and yield just propagates through from the next() call) is the right thing to do - (1) 99% of the time it's irrelevant, (2) it's better performance to not need to do the extra swapping, (3) in the rare cases where it's not irrelevant, I'm pretty sure dispatch-context is the correct choice, (4) it's much less invasive to wrap it to get the other behavior, (5) generators are more like data than code - e.g. https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c","format":"org.matrix.custom.html","formatted_body":"* I had some personal issues come up this week and missed the session where we talked about yield*.  But I was remiss because I really wanted to use the opportunity to get a sense of how the broader committee might feel about extending this to also include ordinary yield.  I don&#39;t know if there&#39;s any opportunity to still bring it up in plenary at this point, or if not, I suppose I could reach out individually to folks who we think might be most opposed?\n\nAt this point, I&#39;m still convinced that dropping all the spec around generators (so that there&#39;s no context preservation around any yields, and yield just propagates through from the next() call) is the right thing to do - (1) 99% of the time it&#39;s irrelevant, (2) it&#39;s better performance to not need to do the extra swapping, (3) in the rare cases where it&#39;s not irrelevant, I&#39;m pretty sure dispatch-context is the correct choice, (4) it&#39;s much less invasive to wrap it to get the other behavior, (5) generators are more like data than code - e.g. https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c","m.mentions":{},"m.new_content":{"body":"I had some personal issues come up this week and missed the session where we talked about yield\\*.  But I was remiss because I really wanted to use the opportunity to get a sense of how the broader committee might feel about extending this to also include ordinary yield.  I don't know if there's any opportunity to still bring it up in plenary at this point, or if not, I suppose I could reach out individually to folks who we think might be most opposed?\n\nAt this point, I'm still convinced that dropping all the spec around generators (so that there's no context preservation around any yields, and yield just propagates through from the next() call) is the right thing to do - (1) 99% of the time it's irrelevant, (2) it's better performance to not need to do the extra swapping, (3) in the rare cases where it's not irrelevant, I'm pretty sure dispatch-context is the correct choice, (4) it's much less invasive to wrap it to get the other behavior, (5) generators are more like data than code - e.g. https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c","format":"org.matrix.custom.html","formatted_body":"I had some personal issues come up this week and missed the session where we talked about yield*.  But I was remiss because I really wanted to use the opportunity to get a sense of how the broader committee might feel about extending this to also include ordinary yield.  I don&#39;t know if there&#39;s any opportunity to still bring it up in plenary at this point, or if not, I suppose I could reach out individually to folks who we think might be most opposed?\n\nAt this point, I&#39;m still convinced that dropping all the spec around generators (so that there&#39;s no context preservation around any yields, and yield just propagates through from the next() call) is the right thing to do - (1) 99% of the time it&#39;s irrelevant, (2) it&#39;s better performance to not need to do the extra swapping, (3) in the rare cases where it&#39;s not irrelevant, I&#39;m pretty sure dispatch-context is the correct choice, (4) it&#39;s much less invasive to wrap it to get the other behavior, (5) generators are more like data than code - e.g. https://gist.github.com/jkrems/04a2b34fb9893e4c2b5c","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$nEt4ovkWJXsH2LcypCm5ilwtm8gFPPcXRqW7slZTfD4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758659535496,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$1UhWwFAbL2rtKRHVhAFhHAl_awlEWSohpuDjw1TFwAI"},
{"content":{"body":"my understanding of the presentation is that it made `yield*` more like repeated `yield`, so I don't know what \"extending this to also include ordinary yield\" means","format":"org.matrix.custom.html","formatted_body":"my understanding of the presentation is that it made <code>yield*</code> more like repeated <code>yield</code>, so I don't know what \"extending this to also include ordinary yield\" means","m.mentions":{},"msgtype":"m.text"},"ts":1758660453569,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$VZBgzcoeIzA6hF0mDw3z3oZbPq5iPml8AI2-Mu7Uajk"},
{"content":{"body":"This is the opposite of my understanding.  As I understand it, the previous situation was that `yield*` was basically just repeated `yield`, but the discussion this morning was to make it so that `yield*` would _not_ restore the generator's internal/initial context but would instead pass on the next() calling context into the delegate.","format":"org.matrix.custom.html","formatted_body":"This is the opposite of my understanding.  As I understand it, the previous situation was that <code>yield*</code> was basically just repeated <code>yield</code>, but the discussion this morning was to make it so that <code>yield*</code> would <em>not</em> restore the generator's internal/initial context but would instead pass on the next() calling context into the delegate.","m.mentions":{},"msgtype":"m.text"},"ts":1758661551204,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Q4RYE4-UryfnDqzRFkduMeQQdOXTBZQsnRyMyOqgeys"},
{"content":{"body":"`for (const it of gen()) yield it` will now behave differently than `yield* gen()`","format":"org.matrix.custom.html","formatted_body":"<code>for (const it of gen()) yield it</code> will now behave differently than <code>yield* gen()</code>","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$VZBgzcoeIzA6hF0mDw3z3oZbPq5iPml8AI2-Mu7Uajk"}},"msgtype":"m.text"},"ts":1758661824593,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$CkbkLp_rlocXDB5MtCQZqnRABzuvwIijTwKJ4z8AB7Q"},
{"content":{"body":"oh, sorry, you're right, I'm wrong","m.mentions":{},"msgtype":"m.text"},"ts":1758661834733,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$BPzC3DYiQHcpAUFxOPsV_t3VCmzKHlMzNAxZdvg8EP0"},
{"content":{"body":"Only the inner `gen()` sees the difference, the wrapping generator does not.","format":"org.matrix.custom.html","formatted_body":"Only the inner <code>gen()</code> sees the difference, the wrapping generator does not.","m.mentions":{},"msgtype":"m.text"},"ts":1758661851432,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$cdR-LE0tYW7Hg4D63xwAObcc7267Zm4pJPKFWNlctgU"},
{"content":{"body":"Adding one more point to my earlier paragraph: (6) this would also restore consistency between `yield` and `yield*`","format":"org.matrix.custom.html","formatted_body":"Adding one more point to my earlier paragraph: (6) this would also restore consistency between <code>yield</code> and <code>yield*</code>","m.mentions":{},"msgtype":"m.text"},"ts":1758661885139,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$8a1jmOG1o55W0RNa85pydmVe4kgWseguVdGJli6Em-k"},
{"content":{"body":"I'm still not totally sure what \"extending this to also include ordinary yield\" means though","m.mentions":{},"msgtype":"m.text"},"ts":1758661976714,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$da9aIBiJt1ffhN9y9SVvuAdXHZWLLc3tTMvO_jh0qyw"},
{"content":{"body":"now both behave as, snapshot context before the expression, restore it after","m.mentions":{},"msgtype":"m.text"},"ts":1758661988361,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$nwAKLIw7gXjSEuDMoccSF48RDY8H0uhZUXc4CWzzTNM"},
{"content":{"body":"(or else I am still misunderstanding)","m.mentions":{},"msgtype":"m.text"},"ts":1758662028264,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$VshtgCt_2ylNe5R7_fEYaU617z6upvDruCVTpPqrSL4"},
{"content":{"body":"ah, I see what you're saying","m.mentions":{},"msgtype":"m.text"},"ts":1758662050756,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$uK4pzBTtbITjypR2xd5OsAGutnAidCctQcOxa_SmAkM"},
{"content":{"body":"Yes, that part hasn't changed - yield* and yield both snapshot and restore around them within the body of the generator","m.mentions":{},"msgtype":"m.text"},"ts":1758662106286,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$P1bwehnEtAklyvCtI7PRdcZn76S6hX9HgIWcKr0mt4E"},
{"content":{"body":"In that sense, it's less of an extension.  What I was referring to is that previously both versions prevented access to the next() calling context, whereas now yield* has access to it (if the delegate iterator is an ordinary object, rather than a generator), but yield doesn't expose that access at all (since there's no other next() call to delegate through).","m.mentions":{},"msgtype":"m.text"},"ts":1758662204213,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$VWpzXku1oibeWgyuJbsm8gAaPYDtiuXpEdFrnSJSKfE"},
{"content":{"body":"What I'm talking about is dropping the snapshot-and-restore before/after yield behavior, which _would_ expose the context next() was called in to the generator body directly","format":"org.matrix.custom.html","formatted_body":"What I'm talking about is dropping the snapshot-and-restore before/after yield behavior, which <em>would</em> expose the context next() was called in to the generator body directly","m.mentions":{},"msgtype":"m.text"},"ts":1758662257079,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$RIlIaX7ly_anVQzpSFttVxVCBjukRfSmjSeaQKLw4YE"},
{"content":{"body":"that seems very wrong to me","m.mentions":{},"msgtype":"m.text"},"ts":1758662301811,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$F05SlqhX-5c5tS2GUWdEqD-IlCWl5Z5xvQYScuDaM0A"},
{"content":{"body":"I guess I just don't buy the argument about generators being more data-like","m.mentions":{},"msgtype":"m.text"},"ts":1758662313711,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$VE0oLMbyEJ_t9jzdq29lbCoIyybVxnRYV0RL8KMMQTM"},
{"content":{"body":"Yeah I think the restore semantics inside generators are still the correct ones","msgtype":"m.text"},"ts":1758662396405,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$yQKCiALf95sNP3t4u1DQ5tBdQmvCLnonzSIBPVFkwAY"},
{"content":{"body":"There is still a general problem that some code is interested in the trigger context rather than the continuation context, but that's not specific to generators","msgtype":"m.text"},"ts":1758662467573,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$5b_AzOvmby9erf7ym3ZTJu21NNNG8uo6vQqXKhPEikM"},
{"content":{"body":"A question here would be: What are the situations where yield would meaningfully restore context that _isn't_ already restored by the scheduling mechanism that calls next?","format":"org.matrix.custom.html","formatted_body":"A question here would be: What are the situations where yield would meaningfully restore context that <em>isn't</em> already restored by the scheduling mechanism that calls next?","m.mentions":{},"msgtype":"m.text"},"ts":1758662538414,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$Qpb3lRPDC-NyM8Zk0dsItYhR2qcQHSN0CxthuhsYx6g"},
{"content":{"body":"This is definitely still a general problem.  My point is that generators will almost never actually observe any difference (since they're almost always iterated in the same context they're instantiated in) but in the cases when that's not the case, the simpler \"don't do anything with context\" behavior seems more likely to be correct - and as a bonus, it's a performance win in the vast majority of cases where it didn't matter in the first place.","m.mentions":{},"msgtype":"m.text"},"ts":1758662620146,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$8czCyqDp9OyuopxewGQPL0h7wGR_YwSDOtrz9A6WNI4"},
{"content":{"body":"Which is basically what Jan was saying.","m.mentions":{},"msgtype":"m.text"},"ts":1758662645321,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Rs2jupcpe2QChveu3Pff8iPKbKXRsha1bDXoCboNFcM"},
{"content":{"body":"* Which is basically what Jan just said, in a few more words.","m.mentions":{},"m.new_content":{"body":"Which is basically what Jan just said, in a few more words.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Rs2jupcpe2QChveu3Pff8iPKbKXRsha1bDXoCboNFcM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758662665900,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$3MCMRms1YnOoV_i6oHv8nPQrJ_kgVUY3pc8oMR2AQiE"},
{"content":{"body":"Basically any time you're doing anything more complicated than just iterating the whole thing in one shot, I would think","m.mentions":{"user_ids":["@jkrems:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Qpb3lRPDC-NyM8Zk0dsItYhR2qcQHSN0CxthuhsYx6g"}},"msgtype":"m.text"},"ts":1758665136233,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$-mulKIKJ2M704peRW3nji_DB7pAHDX-TODqHWbyxcLE"},
{"content":{"body":"I guess this is not all that common, but e.g. I have this helper where I want a function to be sync when passed a sync callback and async when passed an async callback\n\n```\nfunction split(genFn) {\n  function runSync(...args) {\n    const it = genFn(...args);\n    let next = it.next();\n    while (true) {\n      if (next.done) return next.value;\n      next = it.next(next.value);\n    }\n  }\n\n  async function runAsync(...args) {\n    const it = genFn(...args);\n    let next = it.next();\n    while (true) {\n      if (next.done) {\n        return await next.value;\n      }\n      try {\n        next = it.next(await next.value);\n      } catch (err) {\n        next = it.throw(err);\n      }\n    }\n  }\n\n  return { sync: runSync, async: runAsync };\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I guess this is not all that common, but e.g. I have this helper where I want a function to be sync when passed a sync callback and async when passed an async callback</p>\n<pre><code>function split(genFn) {\n  function runSync(...args) {\n    const it = genFn(...args);\n    let next = it.next();\n    while (true) {\n      if (next.done) return next.value;\n      next = it.next(next.value);\n    }\n  }\n\n  async function runAsync(...args) {\n    const it = genFn(...args);\n    let next = it.next();\n    while (true) {\n      if (next.done) {\n        return await next.value;\n      }\n      try {\n        next = it.next(await next.value);\n      } catch (err) {\n        next = it.throw(err);\n      }\n    }\n  }\n\n  return { sync: runSync, async: runAsync };\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1758665172169,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$CN4n-_wQhEbGSIEynmgIbrXNF-pGBBk_4VKsiIDRerQ"},
{"content":{"body":"and I think it would be pretty weird if the async output of this helper did not work like the equivalent async function","m.mentions":{},"msgtype":"m.text"},"ts":1758665200518,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$ph7PqEQ41jXPADBirsFOhcGMby51me7peGJWaVOpqmc"},
{"content":{"body":"They will be exactly equivalent in the current spec text, the new spec text, and with Steve's suggested change.","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ph7PqEQ41jXPADBirsFOhcGMby51me7peGJWaVOpqmc"}},"msgtype":"m.text"},"ts":1758665445566,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$JxVSd89cHVWeKLO-hGFhkk6uJkMkzeQ9iXr_Fjjy_I8"},
{"content":{"body":"Ah, because the async wrapper handles the state? Ok","msgtype":"m.text"},"ts":1758665491277,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$O0NRdkIbTlaM5Ij7RBmHLDStJkMx6kYrg_3p_D8FRK4"},
{"content":{"body":"The 1 edge case that would cause a difference is so niche that I don't want to write it, it will almost never come up","m.mentions":{},"msgtype":"m.text"},"ts":1758665494091,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$oQNUE17tamDcN6Or_n3XyOKvbILcJ3xkAz0PnbUujqQ"},
{"content":{"body":"Exactly","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$O0NRdkIbTlaM5Ij7RBmHLDStJkMx6kYrg_3p_D8FRK4"}},"msgtype":"m.text"},"ts":1758665502881,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$zwvl8Mo6kdDfZfzjhrrFI2LkUNiF_40sBcrr5GAjYtE"},
{"content":{"body":"The `await next.value` will do the capture for you","format":"org.matrix.custom.html","formatted_body":"The <code>await next.value</code> will do the capture for you","m.mentions":{},"msgtype":"m.text"},"ts":1758665512390,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ECUQ4XU9pDpZ4Z5yu8dEfSuzUmWqN5zhNXY40rlegBY"},
{"content":{"body":"Ok I'm a bit less worried about the proposed change then","msgtype":"m.text"},"ts":1758665527120,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$kZN7fxpmoaer3-49GJr_RGpdcoA8F_PErZLsmTWN4P4"},
{"content":{"body":"I can imagine e.g. having multiple async \"workers\" which are pulling from a generator as a source of tasks, where the generator wants to use the state when it was created not the state in each worker","m.mentions":{},"msgtype":"m.text"},"ts":1758665611793,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$WVIOED5roKTm94U_bPBXuRLnZzZuW2_6eq8mJ22MvLc"},
{"content":{"body":"but that's also pretty niche","m.mentions":{},"msgtype":"m.text"},"ts":1758665619405,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$cyBZWqLZiqDZE2cudm3Bqoj1hI80oJA6uvwT_Mc33Fo"},
{"content":{"body":"That can be handled very easily with `Snapshot`","format":"org.matrix.custom.html","formatted_body":"That can be handled very easily with <code>Snapshot</code>","m.mentions":{},"msgtype":"m.text"},"ts":1758665698008,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$F1jmiVaJ1i1Vss2HE8_dZM8FXrt-P9x6HIBlQhqHZq4"},
{"content":{"body":"And whether you would need that depends on if the workers are created outside the snaphot you want to propagate anyways","m.mentions":{},"msgtype":"m.text"},"ts":1758665733679,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$VNYBhop_BdtTMZiRB0Qs8XfSBRoUaJjrJliFcUWwgdo"},
{"content":{"body":"I mean, sure, you can always snapshot and restore around each `yield` manually, right? ","format":"org.matrix.custom.html","formatted_body":"I mean, sure, you can always snapshot and restore around each <code>yield</code> manually, right?","m.mentions":{},"msgtype":"m.text"},"ts":1758665740996,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Dz-QI4wZqUuj89w3IO9aUuC5i3HLivKCfpNwt_OBZAo"},
{"content":{"body":"* And whether you would need that depends on if the workers are created outside the context you want to propagate anyways","m.mentions":{},"m.new_content":{"body":"And whether you would need that depends on if the workers are created outside the context you want to propagate anyways","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$VNYBhop_BdtTMZiRB0Qs8XfSBRoUaJjrJliFcUWwgdo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758665752470,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$bJh4yzX1HoApfIbPanL6M0M3Va0zQgeVzxxdu-HAScA"},
{"content":{"body":"Fwiw I'm not against what Steve is proposing -- what I presented today is not my preferred solution but a compromise to push very slightly towards that direction.","m.mentions":{},"msgtype":"m.text"},"ts":1758665762709,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$xZkyItyZnyRSuv9R7L45qGw_syMw3rJge3exXpc3ST8"},
{"content":{"body":"No, not without accepting a snapshot as part of the gen's parameters","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Dz-QI4wZqUuj89w3IO9aUuC5i3HLivKCfpNwt_OBZAo"}},"msgtype":"m.text"},"ts":1758665795560,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$maECNA9zmPfNFlkfMsC6WNgLuic8zHr-VRupzkIhUaM"},
{"content":{"body":"Because the generator body already runs after the first .next() and not in the function call, right?","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$maECNA9zmPfNFlkfMsC6WNgLuic8zHr-VRupzkIhUaM"}},"msgtype":"m.text"},"ts":1758665829825,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Hn2dq_6w_S-Z2RD_LZ3ftwmbo8y8Esb2plWEwVuY9MM"},
{"content":{"body":"* Because the generator body already runs after the first .next() and not in the gen function call, right?","m.mentions":{},"m.new_content":{"body":"Because the generator body already runs after the first .next() and not in the gen function call, right?","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Hn2dq_6w_S-Z2RD_LZ3ftwmbo8y8Esb2plWEwVuY9MM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758665835858,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$MyV2W0Uqif2Sr2ZpLAFE8ibx8jSq5wMvz1LJksAjRSs"},
{"content":{"body":"IIRC parameter expressions run at the time the generator is called so you can do `, snapshot = AsyncContext.snapshot()` and not require the caller to pass it explicitly","format":"org.matrix.custom.html","formatted_body":"IIRC parameter expressions run at the time the generator is called so you can do <code>, snapshot = AsyncContext.snapshot()</code> and not require the caller to pass it explicitly","m.mentions":{},"msgtype":"m.text"},"ts":1758665844956,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$t36u6hOsUJ1hAHaoFT5pdiiVh1bLQBqklYTZIIFxrwo"},
{"content":{"body":"but that is kind of weird yes","m.mentions":{},"msgtype":"m.text"},"ts":1758665849917,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$3p9a-nWhnie05r12U7H7ZeGmBeXgHZBcgt2uBqZ9A7o"},
{"content":{"body":"Also because you can't wrap `yield` or `await`","format":"org.matrix.custom.html","formatted_body":"Also because you can't wrap <code>yield</code> or <code>await</code>","m.mentions":{},"msgtype":"m.text"},"ts":1758665850149,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$B2sa_sQtT3_s--WYM5P6i-P5Fl5ZpeSND8CDSgo3YdU"},
{"content":{"body":"* Also because you can't wrap `yield` or `await` in a closure","format":"org.matrix.custom.html","formatted_body":"* Also because you can't wrap <code>yield</code> or <code>await</code> in a closure","m.mentions":{},"m.new_content":{"body":"Also because you can't wrap `yield` or `await` in a closure","format":"org.matrix.custom.html","formatted_body":"Also because you can't wrap <code>yield</code> or <code>await</code> in a closure","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$B2sa_sQtT3_s--WYM5P6i-P5Fl5ZpeSND8CDSgo3YdU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758665855509,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$AZ-Zy-vaJzIeIYxpFuvLHy7LOPbzbM4AEClSaIdM__8"},
{"content":{"body":"You'd have to wrap the code before and after the `yield`/`await`, and break out of your snapshots everytime out wanted to yield/await a new value.","format":"org.matrix.custom.html","formatted_body":"You'd have to wrap the code before and after the <code>yield</code>/<code>await</code>, and break out of your snapshots everytime out wanted to yield/await a new value.","m.mentions":{},"msgtype":"m.text"},"ts":1758665911782,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$2bwXik0u8dfg_ai0Ukr4TVBV84HBslplYuZleSCSnc0"},
{"content":{"body":"It's sooo cumbersome","m.mentions":{},"msgtype":"m.text"},"ts":1758665923493,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5WigkLoDKt8Z0yZaJIV3zzvU7NkweysQ0RtUTzoi5hw"},
{"content":{"body":"This sounds to me like the same issue you'd have if you had a \"task factory function\". And you could also argue for the exact opposite - that if it needs to do work in the context of the worker task, you maybe _want_ that work to be tracked in that context. Definitely all very speculative and niche but it seems like that would be even harder if yield \"forces\" a context restore?","format":"org.matrix.custom.html","formatted_body":"This sounds to me like the same issue you'd have if you had a \"task factory function\". And you could also argue for the exact opposite - that if it needs to do work in the context of the worker task, you maybe <em>want</em> that work to be tracked in that context. Definitely all very speculative and niche but it seems like that would be even harder if yield \"forces\" a context restore?","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$WVIOED5roKTm94U_bPBXuRLnZzZuW2_6eq8mJ22MvLc"}},"msgtype":"m.text"},"ts":1758666502749,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$KvXN7BAjU_Bp7EnUmEPKqbWG3KkSf34ZUkCQdHF_Axs"},
{"content":{"body":"I have a hard time imagining a case where a generator is the natural way to express the production of work but you want the body of the generator to be evaluated in the context of the worker tasks","m.mentions":{},"msgtype":"m.text"},"ts":1758666558613,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$w7wrnWNKmPJyrx_8rKCidfPZ0A--2B111mKNDEM3qyE"},
{"content":{"body":"An easy one is storing `workerId` in an `Async.Variable`","format":"org.matrix.custom.html","formatted_body":"An easy one is storing <code>workerId</code> in an <code>Async.Variable</code>","m.mentions":{},"msgtype":"m.text"},"ts":1758666616631,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$xQe7RcCdAMW4daVCxnVQqdj5nllsUWdQNDkXBPtLiqg"},
{"content":{"body":"and the produced work might want to close over a trace or span id","m.mentions":{},"msgtype":"m.text"},"ts":1758666641396,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$4BVUGEf-sGMjldqTwf3urOOGSAGZFgdti9OHcrbqH9w"},
{"content":{"body":"The producer could then read the worker's id (or trace/span/etc)","m.mentions":{},"msgtype":"m.text"},"ts":1758666657902,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$gGz1LoDAdlafNZ6M8Y1sHwrcxcnc7MT6nWrL_JLp7qI"},
{"content":{"body":"and it should close over the trace of the worker task, not the creation of the queue/generator","m.mentions":{},"msgtype":"m.text"},"ts":1758666658340,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$qiIdSZOJQYk2WqWuyi4bsauYQ4aJgM6wNxCxEwDh2Uw"},
{"content":{"body":"tbh, that _feels_ more likely than the case where it needs to close over context from the generator creation. again, in the unlikely scenario that we're already in","format":"org.matrix.custom.html","formatted_body":"tbh, that <em>feels</em> more likely than the case where it needs to close over context from the generator creation. again, in the unlikely scenario that we're already in","m.mentions":{},"msgtype":"m.text"},"ts":1758666707364,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$Z3XGyMANCN5-QMvKasTTcBcUScBAE6CVTqDegkmU6hU"},
{"content":{"body":"Why would the generator want the `workerId`?","format":"org.matrix.custom.html","formatted_body":"Why would the generator want the <code>workerId</code>?","m.mentions":{},"msgtype":"m.text"},"ts":1758666716352,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$wpPNpTdM5NQfV63s_dh--nlmqIQBRHUM_OPBPx7dW10"},
{"content":{"body":"I would really naturally expect it to close over the creation of the queue","m.mentions":{},"msgtype":"m.text"},"ts":1758666731992,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$6Ac4xCF8KuCCq7vCoi3vm3Oigv4nPuBO4tL3ivhP9ww"},
{"content":{"body":"because it might create values that do async work (e.g. run async functions and yield promises)","m.mentions":{},"msgtype":"m.text"},"ts":1758666736625,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$F-cQN2k1nfGAN3u5Y3DhLfSGCCH1MAoK5hLG8M-A9Po"},
{"content":{"body":"but again why would those things want the context of the workers?","m.mentions":{},"msgtype":"m.text"},"ts":1758666765633,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$uu0VexHPpxAoRlSKtiz2dj89XT0ycmjbUH6SwZFtWmo"},
{"content":{"body":"the workers are not the thing which caused the work to be done","m.mentions":{},"msgtype":"m.text"},"ts":1758666776744,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$w42oZkeBJP4afXNhCL7MppiBVPZk7_12Lh2mPEMznlI"},
{"content":{"body":"because otherwise you wouldn't be able to trace IO to the worker task?","m.mentions":{},"msgtype":"m.text"},"ts":1758666780701,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$P8aP3VYAdoQQGR_yM5I3_I7aDHNDkdHZGGO8sG3yXEs"},
{"content":{"body":"the thing which made the generator is that thing","m.mentions":{},"msgtype":"m.text"},"ts":1758666780840,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$Z2jUJsiDDS3KI_tFS7RM4DfKjNLqDznpJD2IXFyhLoY"},
{"content":{"body":"... why would you want to trace IO to the worker task?","m.mentions":{},"msgtype":"m.text"},"ts":1758666796945,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$xIy3ck_tEQS4agaEK8RahC8aPcTj__NLSK_Uiqqv76A"},
{"content":{"body":"Maybe you are imagining a different thing than I am?","m.mentions":{},"msgtype":"m.text"},"ts":1758666804210,"senderName":"bakkot","senderId":"@bakkot:matrix.org","id":"$6YMaL7t048bQVMQblibGIGw8KxuXTpjxR8SoIhhuzRM"},
{"content":{"body":"We're just making hypotheticals, but I often deal with async logging that I'd like match","m.mentions":{},"msgtype":"m.text"},"ts":1758666847271,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$xd0v_GlxklSr41Aw3iWDeb3llcNrGmaktqoKvTTIXfA"},
{"content":{"body":"Eg, concurrent calls from worker1 and worker2, which are executing producer code with `await`s in it","format":"org.matrix.custom.html","formatted_body":"Eg, concurrent calls from worker1 and worker2, which are executing producer code with <code>await</code>s in it","m.mentions":{},"msgtype":"m.text"},"ts":1758666876589,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$_gH6solqWaWY2cXYLO-iiB1_GMiWohMaeFSEhnS2fI0"},
{"content":{"body":"Without `workerId.get()`, the logs will appear jumbled","format":"org.matrix.custom.html","formatted_body":"Without <code>workerId.get()</code>, the logs will appear jumbled","m.mentions":{},"msgtype":"m.text"},"ts":1758666899957,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$C4OnvYB_DsJ5k0-sYvPe5xxT0bqMiSbJkCe5RknHq3g"},
{"content":{"body":"With consumer side propagation, we could do `console.log(workerId.get(), …)` and match the sequential execution of both","format":"org.matrix.custom.html","formatted_body":"With consumer side propagation, we could do <code>console.log(workerId.get(), …)</code> and match the sequential execution of both","m.mentions":{},"msgtype":"m.text"},"ts":1758666938270,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$CFmX9CmY9pmvYB-dP1xpztaFDZPm9zu61E29fhAvOrE"},
{"content":{"body":"* Without `workerId.get()`, the logs will appear jumbled `start start end end`","format":"org.matrix.custom.html","formatted_body":"* Without <code>workerId.get()</code>, the logs will appear jumbled <code>start start end end</code>","m.mentions":{},"m.new_content":{"body":"Without `workerId.get()`, the logs will appear jumbled `start start end end`","format":"org.matrix.custom.html","formatted_body":"Without <code>workerId.get()</code>, the logs will appear jumbled <code>start start end end</code>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$C4OnvYB_DsJ5k0-sYvPe5xxT0bqMiSbJkCe5RknHq3g","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758667087086,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$jmSQyvlbmcCARecKDDeCkjfm9_MeeDIiDcV71p9cW2o"},
{"content":{"body":"* With consumer side propagation, we could do `console.log(workerId.get(), …)` and match the sequential execution of both: `w1:start w2:start w1:end w2:end`","format":"org.matrix.custom.html","formatted_body":"* With consumer side propagation, we could do <code>console.log(workerId.get(), …)</code> and match the sequential execution of both: <code>w1:start w2:start w1:end w2:end</code>","m.mentions":{},"m.new_content":{"body":"With consumer side propagation, we could do `console.log(workerId.get(), …)` and match the sequential execution of both: `w1:start w2:start w1:end w2:end`","format":"org.matrix.custom.html","formatted_body":"With consumer side propagation, we could do <code>console.log(workerId.get(), …)</code> and match the sequential execution of both: <code>w1:start w2:start w1:end w2:end</code>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CFmX9CmY9pmvYB-dP1xpztaFDZPm9zu61E29fhAvOrE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758667113461,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$KHjvyEbE-J__qwCXnolEGpGe3w7M9nrCGx5IlJrWWiY"},
{"content":{"body":"* Without `workerId.get()`, the logs will appear jumbled: `start start end end`","format":"org.matrix.custom.html","formatted_body":"* Without <code>workerId.get()</code>, the logs will appear jumbled: <code>start start end end</code>","m.mentions":{},"m.new_content":{"body":"Without `workerId.get()`, the logs will appear jumbled: `start start end end`","format":"org.matrix.custom.html","formatted_body":"Without <code>workerId.get()</code>, the logs will appear jumbled: <code>start start end end</code>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$C4OnvYB_DsJ5k0-sYvPe5xxT0bqMiSbJkCe5RknHq3g","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758667119646,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Q4KTW6ve8-FjnFz5TcR2Z5OZMuW4hx5dD3n6u0r617A"},
{"content":{"body":"Quick and dirty attempt from my side, very similar id: https://gist.github.com/jkrems/9fa7fe92bdc2b8a4b1964c971882c6bd","m.mentions":{},"msgtype":"m.text"},"ts":1758667128345,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$LvGb2EIKsRVqXbQ3bjHnbwFKomtAGcAyJhG8qQFsSx4"},
{"content":{"body":"* Quick and dirty attempt from my side, very similar idea to what Justin described: https://gist.github.com/jkrems/9fa7fe92bdc2b8a4b1964c971882c6bd","m.mentions":{},"m.new_content":{"body":"Quick and dirty attempt from my side, very similar idea to what Justin described: https://gist.github.com/jkrems/9fa7fe92bdc2b8a4b1964c971882c6bd","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$LvGb2EIKsRVqXbQ3bjHnbwFKomtAGcAyJhG8qQFsSx4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758667213123,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$kGYLdMywk375fzDlqIEhiLMCpAwaWZuk4o7TWljDutU"},
{"content":{"body":"bakkot: Did you have an example on your end of when the context when entering the generator would be the more useful one (in a case where the two are actively different)? That might complete the picture :)","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a>: Did you have an example on your end of when the context when entering the generator would be the more useful one (in a case where the two are actively different)? That might complete the picture :)","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"msgtype":"m.text"},"ts":1758667379637,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$WyDD4QZ7Ul2JLvvjxGxztu_MnUJPfsWwxl__FLPIoaw"},
{"content":{"body":"* Quick and dirty attempt from my side, very similar idea: https://gist.github.com/jkrems/9fa7fe92bdc2b8a4b1964c971882c6bd","m.new_content":{"body":"Quick and dirty attempt from my side, very similar idea: https://gist.github.com/jkrems/9fa7fe92bdc2b8a4b1964c971882c6bd","msgtype":"m.text"},"m.relates_to":{"event_id":"$LvGb2EIKsRVqXbQ3bjHnbwFKomtAGcAyJhG8qQFsSx4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758667549631,"senderName":"Jan Olaf Martin","senderId":"@jkrems:matrix.org","id":"$fdcHaQpSz-1hHQ4M2iFFd6pAqYbznKy8Br3npzSTegI"}
]