[
{"content":{"body":"> <@stephenhicks:matrix.org> I think that's tricky due to races - for example, the exact ordering of a promise resolving vs. the promise.then call would make one or the other context more recent.  But I think we probably want to run in the same context (resolution vs registration) regardless of the order.\n\nHuh, what do you mean? I wasn’t imagining this kind of case, I was imagining that a particular cause would lead to a particular snapshot context being restored. Could you give an example of the race you are concerned about?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24GOsiQHXLOAVuxVSk3L2-nYT14Mp5wXYOZMMzh2wk8PQ\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I think that's tricky due to races - for example, the exact ordering of a promise resolving vs. the promise.then call would make one or the other context more recent.  But I think we probably want to run in the same context (resolution vs registration) regardless of the order.</blockquote></mx-reply>Huh, what do you mean? I wasn’t imagining this kind of case, I was imagining that a particular cause would lead to a particular snapshot context being restored. Could you give an example of the race you are concerned about?","m.relates_to":{"m.in_reply_to":{"event_id":"$GOsiQHXLOAVuxVSk3L2-nYT14Mp5wXYOZMMzh2wk8PQ"}},"msgtype":"m.text"},"ts":1717043517813,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$M2REgtWkpUK4pvR6wYY6tth4DMPUZsIDj4C_eIrUZBU"},
{"content":{"body":"it's a little pedantic, but if you have something like\n```\nconst p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get()));\n```\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get()));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1717086945578,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo"},
{"content":{"body":" * it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":" * <p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"m.new_content":{"body":"it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717086956630,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wAgiJ9aHDasyazMXcLwRwxsVD1HGgP13fx997jh7Ojw"},
{"content":{"body":" * it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":" * <p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"m.new_content":{"body":"it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717086966919,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wmxKtdVykiQQPyie0QRbRjDHS0GZHvV-eH6-8q-xwUk"},
{"content":{"body":" * it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.  Without the `await`, it would be 1.","format":"org.matrix.custom.html","formatted_body":" * <p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.  Without the <code>await</code>, it would be 1.</p>\n","m.mentions":{},"m.new_content":{"body":"it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.  Without the `await`, it would be 1.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.  Without the <code>await</code>, it would be 1.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717087011386,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$kDOl4EGTUIRrTKXl02Q4VMQwIFWbiQsUsoTqXWCxzwg"},
{"content":{"body":" * it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the `await`, it would be 1.","format":"org.matrix.custom.html","formatted_body":" * <p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the <code>await</code>, it would be 1.</p>\n","m.mentions":{},"m.new_content":{"body":"it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the `await`, it would be 1.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the <code>await</code>, it would be 1.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717087025837,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$fkVy0L33PRw95wO4vD8BOO3hTArxA0BR_vRx9Un1vAI"},
{"content":{"body":"this smells like zalgo -- it depends on how the handlers are called","m.mentions":{},"msgtype":"m.text"},"ts":1717087333556,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$ICzCH8_Yb0v_SKtMK2YeEolZXXY_b-nityErd6BklTQ"},
{"content":{"body":"@stephenbelanger:matrix.org pointed out that if we were to have an flows-through `ExecutionVariable` and implement scoped `using` mutations, we’d have a problem with propogating the execution state through the resolve\n```js\nasync function foo() {\n  using _ = v.scope(1);\n  return 2;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@Stephen Belanger</a> pointed out that if we were to have an flows-through <code data-md=\"`\">ExecutionVariable</code> and implement scoped <code data-md=\"`\">using</code> mutations, we’d have a problem with propogating the execution state through the resolve<br/><pre data-md=\"```\"><code class=\"language-js\">async function foo() {\n  using _ = v.scope(1);\n  return 2;\n}\n</code></pre>","msgtype":"m.text"},"ts":1717091384088,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$WnWbe1NG6H9T9QQcUq34CTUfFNYZbHi97BNzf1NrzS4"},
{"content":{"body":"Because the scoped mutation is disposed in the `StatementList` evaluation of the function, and the outer promise is resolved in the `AsyncFunctionBody` execution _after_ `StatementList` is evaluated","format":"org.matrix.custom.html","formatted_body":"Because the scoped mutation is disposed in the <code data-md=\"`\">StatementList</code> evaluation of the function, and the outer promise is resolved in the <code data-md=\"`\">AsyncFunctionBody</code> execution <i data-md=\"_\">after</i> <code data-md=\"`\">StatementList</code> is evaluated","msgtype":"m.text"},"ts":1717091426743,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$_j7R1PpyNul9j3dNRybeUGWr4Kjli-DJzJiHXpVL0vI"},
{"content":{"body":"* Because the scoped mutation is disposed in the `FunctionStatementList` evaluation of the function, and the outer promise is resolved in the `AsyncFunctionBody` execution _after_ `StatementList` is evaluated","format":"org.matrix.custom.html","formatted_body":"Because the scoped mutation is disposed in the <code data-md=\"`\">FunctionStatementList</code> evaluation of the function, and the outer promise is resolved in the <code data-md=\"`\">AsyncFunctionBody</code> execution <i data-md=\"_\">after</i> <code data-md=\"`\">StatementList</code> is evaluated","m.new_content":{"body":"Because the scoped mutation is disposed in the `FunctionStatementList` evaluation of the function, and the outer promise is resolved in the `AsyncFunctionBody` execution _after_ `StatementList` is evaluated","format":"org.matrix.custom.html","formatted_body":"Because the scoped mutation is disposed in the <code data-md=\"`\">FunctionStatementList</code> evaluation of the function, and the outer promise is resolved in the <code data-md=\"`\">AsyncFunctionBody</code> execution <i data-md=\"_\">after</i> <code data-md=\"`\">StatementList</code> is evaluated","msgtype":"m.text"},"m.relates_to":{"event_id":"$_j7R1PpyNul9j3dNRybeUGWr4Kjli-DJzJiHXpVL0vI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717091459310,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$RLzOFhCgI9v1odjVNSiDmXRbMEEpzT4qyH4CcBHP3ww"},
{"content":{"body":"Then there’s weird interactions with how you’re supposed to resolve the promise, and what if the disposals caused an exeception","msgtype":"m.text"},"ts":1717091511250,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$uyDAH83bMcSkOMOrLKRpboIPvpW3y4x2lvAsxelGe9A"},
{"content":{"body":"> <@legendecas:matrix.org> this smells like zalgo -- it depends on how the handlers are called\n\nRight, that's why I'm saying that \"using the most specific (i.e. causally recent) relevant context\" is probably a bad specification.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$ICzCH8_Yb0v_SKtMK2YeEolZXXY_b-nityErd6BklTQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>this smells like zalgo -- it depends on how the handlers are called</blockquote></mx-reply>Right, that's why I'm saying that \"using the most specific (i.e. causally recent) relevant context\" is probably a bad specification.","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ICzCH8_Yb0v_SKtMK2YeEolZXXY_b-nityErd6BklTQ"}},"msgtype":"m.text"},"ts":1717091531859,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$5PDSExaB8Mu7oZ4v7LauoMmWYHXf9nKOcn4pHA0YaGY"},
{"content":{"body":"> <@jridgewell:matrix.org> Because the scoped mutation is disposed in the `FunctionStatementList` evaluation of the function, and the outer promise is resolved in the `AsyncFunctionBody` execution _after_ `StatementList` is evaluated\n\nI asked Tuesday whether scoping mutations would somehow prevent escaping the value and he suggested that there's still ways to extract the data.  But I never got a good sense of what those ways were.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$_j7R1PpyNul9j3dNRybeUGWr4Kjli-DJzJiHXpVL0vI?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Because the scoped mutation is disposed in the <code data-md=\"`\">FunctionStatementList</code> evaluation of the function, and the outer promise is resolved in the <code data-md=\"`\">AsyncFunctionBody</code> execution <i data-md=\"_\">after</i> <code data-md=\"`\">StatementList</code> is evaluated</blockquote></mx-reply>I asked Tuesday whether scoping mutations would somehow prevent escaping the value and he suggested that there's still ways to extract the data.  But I never got a good sense of what those ways were.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$_j7R1PpyNul9j3dNRybeUGWr4Kjli-DJzJiHXpVL0vI"}},"msgtype":"m.text"},"ts":1717091703309,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$m8NFHEYG6IU7igZ843xz3G9ed3dHKrbYZ7bKvGAv9RE"},
{"content":{"body":"We’d have to redefine the `using` methods to perform `DisposeResources` in each of the `*FunctionBody` node types","format":"org.matrix.custom.html","formatted_body":"We’d have to redefine the <code data-md=\"`\">using</code> methods to perform <code data-md=\"`\">DisposeResources</code> in each of the <code data-md=\"`\">*FunctionBody</code> node types","msgtype":"m.text"},"ts":1717091871287,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$OkmpgtTQ3mmNeMHMXudrbvNWgVTVnEAKhqvMicKbj3E"},
{"content":{"body":"Instead of using the `FunctionStatementList` node","format":"org.matrix.custom.html","formatted_body":"Instead of using the <code data-md=\"`\">FunctionStatementList</code> node","msgtype":"m.text"},"ts":1717091885789,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$nZnb68BofQl52q0uJ5BRElxyI7-0uo_PhIGP_Zl4PQ0"},
{"content":{"body":"That way we’d dispose the variables after resolving","msgtype":"m.text"},"ts":1717091900311,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$PXC3Lqt6UgtDnoH6HosDx09llRCMZL1cDCKDUgsHsF0"},
{"content":{"body":"But `using` needs to work with block scopes too, right? So it'd need to be conditional on if the block _is_ the function body or if it is nested.","format":"org.matrix.custom.html","formatted_body":"But <code>using</code> needs to work with block scopes too, right? So it'd need to be conditional on if the block <em>is</em> the function body or if it is nested.","m.mentions":{},"msgtype":"m.text"},"ts":1717093840288,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$J4kardstGeby5zzluM_KtIjhJTKBM4elfjG5PGektu8"},
{"content":{"body":"It'd add a bit of complexity.","m.mentions":{},"msgtype":"m.text"},"ts":1717093867366,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$QtFzugKj2ZVQRwOSta2f1r_8vQybXMqe2KBBQOR-Qrk"},
{"content":{"body":"This is _why_ other languages like .NET went for just doing set/get and persisting until the context would _change_.","format":"org.matrix.custom.html","formatted_body":"This is <em>why</em> other languages like .NET went for just doing set/get and persisting until the context would <em>change</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1717093895261,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Vzasa0scd2SQ5TaJs-HSM_e4cV9I7b0ZMe4QH_x-_hU"},
{"content":{"body":"> <@stephenhicks:matrix.org> it's a little pedantic, but if you have something like\n> \n> ```\n> const p = v.run(1, () => Promise.resolve());\n> await p;\n> // p is now fully resolved\n> v.run(2, p.then(() => console.log(v.get())));\n> ```\n> \n> Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the `await`, it would be 1.\n\nyeah I have been assuming that .then would always use the registration context, and that we were only talking about web APIs.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the <code>await</code>, it would be 1.</p>\n</blockquote></mx-reply>yeah I have been assuming that .then would always use the registration context, and that we were only talking about web APIs.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo"}},"msgtype":"m.text"},"ts":1717093939000,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$RoWXId1dMq_VgyND8EGStQl6610PhK79JEZZqgR_4bA"},
{"content":{"body":"(so there is no await vs .then mismatch)","m.mentions":{},"msgtype":"m.text"},"ts":1717093951624,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$xRfaG7-oOBYThYpbPGJFf7D51EHdqhm9TqaWmhygF5I"},
{"content":{"body":"> <@stephenhicks:matrix.org> it's a little pedantic, but if you have something like\n> \n> ```\n> const p = v.run(1, () => Promise.resolve());\n> await p;\n> // p is now fully resolved\n> v.run(2, p.then(() => console.log(v.get())));\n> ```\n> \n> Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the `await`, it would be 1.\n\nIn flow-through model that should _always_ be 1, as that is what was set when the _resolve_ happened. We don't much _care_ about where a continuation is attached.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the <code>await</code>, it would be 1.</p>\n</blockquote></mx-reply>In flow-through model that should <em>always</em> be 1, as that is what was set when the <em>resolve</em> happened. We don't much <em>care</em> about where a continuation is attached.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo"}},"msgtype":"m.text"},"ts":1717094068666,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$_p3HBiGzGNWJCEPbckvmhmC_fkRBITMpXSmWNspwrKY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> This is _why_ other languages like .NET went for just doing set/get and persisting until the context would _change_.\n\nIs there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value _out_ of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$Vzasa0scd2SQ5TaJs-HSM_e4cV9I7b0ZMe4QH_x-_hU?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>This is <em>why</em> other languages like .NET went for just doing set/get and persisting until the context would <em>change</em>.</blockquote></mx-reply>Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value <em>out</em> of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Vzasa0scd2SQ5TaJs-HSM_e4cV9I7b0ZMe4QH_x-_hU"}},"msgtype":"m.text"},"ts":1717094085060,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ"},
{"content":{"body":"> <@stephenhicks:matrix.org> Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value _out_ of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.\n\nI think this comes up with block scopes *within* a function, where you'd restore the previous value in the latter case and not the former","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value <em>out</em> of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.</blockquote></mx-reply>I think this comes up with block scopes <em>within</em> a function, where you'd restore the previous value in the latter case and not the former","m.mentions":{"user_ids":["@stephenhicks:matrix.org","@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ"}},"msgtype":"m.text"},"ts":1717094144981,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$rcXIdKjWyIkay59Tkll61C8HpUpW7WY2JV3DzX-z044"},
{"content":{"body":"so this is the difference between using and .set","m.mentions":{},"msgtype":"m.text"},"ts":1717094152982,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ByIhyrymZ0G-KDL0g8JjkzTnHNppd115WU4YJo5d_vI"},
{"content":{"body":"> <@stephenbelanger:matrix.org> In flow-through model that should _always_ be 1, as that is what was set when the _resolve_ happened. We don't much _care_ about where a continuation is attached.\n\nRight, but I'm imagining a world where `await` is flow-around, but `then` restores the resolution context, since that would still allow accessing all the flow-through causes as needed.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$_p3HBiGzGNWJCEPbckvmhmC_fkRBITMpXSmWNspwrKY?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>In flow-through model that should <em>always</em> be 1, as that is what was set when the <em>resolve</em> happened. We don't much <em>care</em> about where a continuation is attached.</blockquote></mx-reply>Right, but I'm imagining a world where <code>await</code> is flow-around, but <code>then</code> restores the resolution context, since that would still allow accessing all the flow-through causes as needed.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$_p3HBiGzGNWJCEPbckvmhmC_fkRBITMpXSmWNspwrKY"}},"msgtype":"m.text"},"ts":1717094154432,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$rWXubcV9t3jmRp7yN5T1Vyt-iHcXOqdTKuvErvw0-ww"},
{"content":{"body":"> <@stephenhicks:matrix.org> Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value _out_ of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.\n\nIn flow-through model you capture _both_ at call _and_ at return. So when an async function or a promise resolves you capture and when the continuation of that begins you restore.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value <em>out</em> of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.</blockquote></mx-reply>In flow-through model you capture <em>both</em> at call <em>and</em> at return. So when an async function or a promise resolves you capture and when the continuation of that begins you restore.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ"}},"msgtype":"m.text"},"ts":1717094168491,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7hVfNA_K_cUB1zELheDkbUNAh22fnCLjMgB6ohT8pbk"},
{"content":{"body":"> <@stephenhicks:matrix.org> Right, but I'm imagining a world where `await` is flow-around, but `then` restores the resolution context, since that would still allow accessing all the flow-through causes as needed.\n\nYes, restoring the orphaned branch is what I was thinking `callingContext` would be helpful for there.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rWXubcV9t3jmRp7yN5T1Vyt-iHcXOqdTKuvErvw0-ww?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Right, but I'm imagining a world where <code>await</code> is flow-around, but <code>then</code> restores the resolution context, since that would still allow accessing all the flow-through causes as needed.</blockquote></mx-reply>Yes, restoring the orphaned branch is what I was thinking <code>callingContext</code> would be helpful for there.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$rWXubcV9t3jmRp7yN5T1Vyt-iHcXOqdTKuvErvw0-ww"}},"msgtype":"m.text"},"ts":1717094232390,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kjNnv_kRZxKj-0FkwGhZzyKNKDmcgkO8rrm8EfwpE4A"},
{"content":{"body":"It's a bit awkward though.","m.mentions":{},"msgtype":"m.text"},"ts":1717094236978,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$8tzxHGsXUDBpXhm58ADhVHIsDumNJEJ90J0TRzXzHcg"},
{"content":{"body":"And probably would have terrible performance for APMs which would need to be doing that basically _always_.","format":"org.matrix.custom.html","formatted_body":"And probably would have terrible performance for APMs which would need to be doing that basically <em>always</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1717094257284,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zvAyGTsR4jhKyMxxQDtm2b6Acw7_g3qTWVbysHrpzLE"},
{"content":{"body":"> <@stephenbelanger:matrix.org> And probably would have terrible performance for APMs which would need to be doing that basically _always_.\n\nYes, I expected the performance to be bad, but I was wondering if we could spec out the semantics such that it's all self-consistent, and then potentially provide a builtin alternative that exposes that common operation (which can now be emulated inefficiently) in a more efficient way.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$zvAyGTsR4jhKyMxxQDtm2b6Acw7_g3qTWVbysHrpzLE?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>And probably would have terrible performance for APMs which would need to be doing that basically <em>always</em>.</blockquote></mx-reply>Yes, I expected the performance to be bad, but I was wondering if we could spec out the semantics such that it's all self-consistent, and then potentially provide a builtin alternative that exposes that common operation (which can now be emulated inefficiently) in a more efficient way.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zvAyGTsR4jhKyMxxQDtm2b6Acw7_g3qTWVbysHrpzLE"}},"msgtype":"m.text"},"ts":1717094396081,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$96PmkixKlotu_BkH3v1GQ-i0FF0Bil7SNqKYb1RwQrg"},
{"content":{"body":"Not sure if that made any sense... basically, you could explain the semantics of `callingContext` as if were a userland implementation, but it could be implemented internally in a more efficient way.","format":"org.matrix.custom.html","formatted_body":"Not sure if that made any sense... basically, you could explain the semantics of <code>callingContext</code> as if were a userland implementation, but it could be implemented internally in a more efficient way.","m.mentions":{},"msgtype":"m.text"},"ts":1717094441168,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$K2qUtCnYIxP4FeR8AE0WaxRrdytIsyhax-1HWhD3lb8"},
{"content":{"body":"If we have to actually do that explicitly on every await though it doesn't matter how much we optimize it, it will _always_ have significant overhead. We need a type that has the appropriate flow by default or we're basically _doubling_ all the context state modifications.","format":"org.matrix.custom.html","formatted_body":"If we have to actually do that explicitly on every await though it doesn't matter how much we optimize it, it will <em>always</em> have significant overhead. We need a type that has the appropriate flow by default or we're basically <em>doubling</em> all the context state modifications.","m.mentions":{},"msgtype":"m.text"},"ts":1717094537372,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$VL8zuhc-iPzvYqBB3Kqy_B-GX5D5KrxOibZD9M8Pwkw"},
{"content":{"body":"This is why I was suggesting either having a separate type for the different flow, or having a per-store configuration to pick the different flow.","m.mentions":{},"msgtype":"m.text"},"ts":1717094601254,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$2ROK90pAybWztoAVS9oDA-ydek0Qckm1CvzSMbap0c4"}
]