[
{"content":{"body":"> <@stephenhicks:matrix.org> I think that's tricky due to races - for example, the exact ordering of a promise resolving vs. the promise.then call would make one or the other context more recent.  But I think we probably want to run in the same context (resolution vs registration) regardless of the order.\n\nHuh, what do you mean? I wasn’t imagining this kind of case, I was imagining that a particular cause would lead to a particular snapshot context being restored. Could you give an example of the race you are concerned about?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24GOsiQHXLOAVuxVSk3L2-nYT14Mp5wXYOZMMzh2wk8PQ\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I think that's tricky due to races - for example, the exact ordering of a promise resolving vs. the promise.then call would make one or the other context more recent.  But I think we probably want to run in the same context (resolution vs registration) regardless of the order.</blockquote></mx-reply>Huh, what do you mean? I wasn’t imagining this kind of case, I was imagining that a particular cause would lead to a particular snapshot context being restored. Could you give an example of the race you are concerned about?","m.relates_to":{"m.in_reply_to":{"event_id":"$GOsiQHXLOAVuxVSk3L2-nYT14Mp5wXYOZMMzh2wk8PQ"}},"msgtype":"m.text"},"ts":1717043517813,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$M2REgtWkpUK4pvR6wYY6tth4DMPUZsIDj4C_eIrUZBU"},
{"content":{"body":"it's a little pedantic, but if you have something like\n```\nconst p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get()));\n```\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get()));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1717086945578,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo"},
{"content":{"body":" * it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":" * <p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"m.new_content":{"body":"it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717086956630,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wAgiJ9aHDasyazMXcLwRwxsVD1HGgP13fx997jh7Ojw"},
{"content":{"body":" * it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":" * <p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"m.new_content":{"body":"it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717086966919,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wmxKtdVykiQQPyie0QRbRjDHS0GZHvV-eH6-8q-xwUk"},
{"content":{"body":" * it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.  Without the `await`, it would be 1.","format":"org.matrix.custom.html","formatted_body":" * <p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.  Without the <code>await</code>, it would be 1.</p>\n","m.mentions":{},"m.new_content":{"body":"it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.  Without the `await`, it would be 1.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  What I'm saying is that it's not clear that \"specific\" or \"recent\" is quite the right specification.  Without the <code>await</code>, it would be 1.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717087011386,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$kDOl4EGTUIRrTKXl02Q4VMQwIFWbiQsUsoTqXWCxzwg"},
{"content":{"body":" * it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the `await`, it would be 1.","format":"org.matrix.custom.html","formatted_body":" * <p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the <code>await</code>, it would be 1.</p>\n","m.mentions":{},"m.new_content":{"body":"it's a little pedantic, but if you have something like\n\n```\nconst p = v.run(1, () => Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() => console.log(v.get())));\n```\n\nThen \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the `await`, it would be 1.","format":"org.matrix.custom.html","formatted_body":"<p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the <code>await</code>, it would be 1.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717087025837,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$fkVy0L33PRw95wO4vD8BOO3hTArxA0BR_vRx9Un1vAI"},
{"content":{"body":"this smells like zalgo -- it depends on how the handlers are called","m.mentions":{},"msgtype":"m.text"},"ts":1717087333556,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$ICzCH8_Yb0v_SKtMK2YeEolZXXY_b-nityErd6BklTQ"},
{"content":{"body":"@stephenbelanger:matrix.org pointed out that if we were to have an flows-through `ExecutionVariable` and implement scoped `using` mutations, we’d have a problem with propogating the execution state through the resolve\n```js\nasync function foo() {\n  using _ = v.scope(1);\n  return 2;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@Stephen Belanger</a> pointed out that if we were to have an flows-through <code data-md=\"`\">ExecutionVariable</code> and implement scoped <code data-md=\"`\">using</code> mutations, we’d have a problem with propogating the execution state through the resolve<br/><pre data-md=\"```\"><code class=\"language-js\">async function foo() {\n  using _ = v.scope(1);\n  return 2;\n}\n</code></pre>","msgtype":"m.text"},"ts":1717091384088,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$WnWbe1NG6H9T9QQcUq34CTUfFNYZbHi97BNzf1NrzS4"},
{"content":{"body":"Because the scoped mutation is disposed in the `StatementList` evaluation of the function, and the outer promise is resolved in the `AsyncFunctionBody` execution _after_ `StatementList` is evaluated","format":"org.matrix.custom.html","formatted_body":"Because the scoped mutation is disposed in the <code data-md=\"`\">StatementList</code> evaluation of the function, and the outer promise is resolved in the <code data-md=\"`\">AsyncFunctionBody</code> execution <i data-md=\"_\">after</i> <code data-md=\"`\">StatementList</code> is evaluated","msgtype":"m.text"},"ts":1717091426743,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$_j7R1PpyNul9j3dNRybeUGWr4Kjli-DJzJiHXpVL0vI"},
{"content":{"body":"* Because the scoped mutation is disposed in the `FunctionStatementList` evaluation of the function, and the outer promise is resolved in the `AsyncFunctionBody` execution _after_ `StatementList` is evaluated","format":"org.matrix.custom.html","formatted_body":"Because the scoped mutation is disposed in the <code data-md=\"`\">FunctionStatementList</code> evaluation of the function, and the outer promise is resolved in the <code data-md=\"`\">AsyncFunctionBody</code> execution <i data-md=\"_\">after</i> <code data-md=\"`\">StatementList</code> is evaluated","m.new_content":{"body":"Because the scoped mutation is disposed in the `FunctionStatementList` evaluation of the function, and the outer promise is resolved in the `AsyncFunctionBody` execution _after_ `StatementList` is evaluated","format":"org.matrix.custom.html","formatted_body":"Because the scoped mutation is disposed in the <code data-md=\"`\">FunctionStatementList</code> evaluation of the function, and the outer promise is resolved in the <code data-md=\"`\">AsyncFunctionBody</code> execution <i data-md=\"_\">after</i> <code data-md=\"`\">StatementList</code> is evaluated","msgtype":"m.text"},"m.relates_to":{"event_id":"$_j7R1PpyNul9j3dNRybeUGWr4Kjli-DJzJiHXpVL0vI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717091459310,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$RLzOFhCgI9v1odjVNSiDmXRbMEEpzT4qyH4CcBHP3ww"},
{"content":{"body":"Then there’s weird interactions with how you’re supposed to resolve the promise, and what if the disposals caused an exeception","msgtype":"m.text"},"ts":1717091511250,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$uyDAH83bMcSkOMOrLKRpboIPvpW3y4x2lvAsxelGe9A"},
{"content":{"body":"> <@legendecas:matrix.org> this smells like zalgo -- it depends on how the handlers are called\n\nRight, that's why I'm saying that \"using the most specific (i.e. causally recent) relevant context\" is probably a bad specification.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$ICzCH8_Yb0v_SKtMK2YeEolZXXY_b-nityErd6BklTQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>this smells like zalgo -- it depends on how the handlers are called</blockquote></mx-reply>Right, that's why I'm saying that \"using the most specific (i.e. causally recent) relevant context\" is probably a bad specification.","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ICzCH8_Yb0v_SKtMK2YeEolZXXY_b-nityErd6BklTQ"}},"msgtype":"m.text"},"ts":1717091531859,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$5PDSExaB8Mu7oZ4v7LauoMmWYHXf9nKOcn4pHA0YaGY"},
{"content":{"body":"> <@jridgewell:matrix.org> Because the scoped mutation is disposed in the `FunctionStatementList` evaluation of the function, and the outer promise is resolved in the `AsyncFunctionBody` execution _after_ `StatementList` is evaluated\n\nI asked Tuesday whether scoping mutations would somehow prevent escaping the value and he suggested that there's still ways to extract the data.  But I never got a good sense of what those ways were.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$_j7R1PpyNul9j3dNRybeUGWr4Kjli-DJzJiHXpVL0vI?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Because the scoped mutation is disposed in the <code data-md=\"`\">FunctionStatementList</code> evaluation of the function, and the outer promise is resolved in the <code data-md=\"`\">AsyncFunctionBody</code> execution <i data-md=\"_\">after</i> <code data-md=\"`\">StatementList</code> is evaluated</blockquote></mx-reply>I asked Tuesday whether scoping mutations would somehow prevent escaping the value and he suggested that there's still ways to extract the data.  But I never got a good sense of what those ways were.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$_j7R1PpyNul9j3dNRybeUGWr4Kjli-DJzJiHXpVL0vI"}},"msgtype":"m.text"},"ts":1717091703309,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$m8NFHEYG6IU7igZ843xz3G9ed3dHKrbYZ7bKvGAv9RE"},
{"content":{"body":"We’d have to redefine the `using` methods to perform `DisposeResources` in each of the `*FunctionBody` node types","format":"org.matrix.custom.html","formatted_body":"We’d have to redefine the <code data-md=\"`\">using</code> methods to perform <code data-md=\"`\">DisposeResources</code> in each of the <code data-md=\"`\">*FunctionBody</code> node types","msgtype":"m.text"},"ts":1717091871287,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$OkmpgtTQ3mmNeMHMXudrbvNWgVTVnEAKhqvMicKbj3E"},
{"content":{"body":"Instead of using the `FunctionStatementList` node","format":"org.matrix.custom.html","formatted_body":"Instead of using the <code data-md=\"`\">FunctionStatementList</code> node","msgtype":"m.text"},"ts":1717091885789,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$nZnb68BofQl52q0uJ5BRElxyI7-0uo_PhIGP_Zl4PQ0"},
{"content":{"body":"That way we’d dispose the variables after resolving","msgtype":"m.text"},"ts":1717091900311,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$PXC3Lqt6UgtDnoH6HosDx09llRCMZL1cDCKDUgsHsF0"},
{"content":{"body":"But `using` needs to work with block scopes too, right? So it'd need to be conditional on if the block _is_ the function body or if it is nested.","format":"org.matrix.custom.html","formatted_body":"But <code>using</code> needs to work with block scopes too, right? So it'd need to be conditional on if the block <em>is</em> the function body or if it is nested.","m.mentions":{},"msgtype":"m.text"},"ts":1717093840288,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$J4kardstGeby5zzluM_KtIjhJTKBM4elfjG5PGektu8"},
{"content":{"body":"It'd add a bit of complexity.","m.mentions":{},"msgtype":"m.text"},"ts":1717093867366,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$QtFzugKj2ZVQRwOSta2f1r_8vQybXMqe2KBBQOR-Qrk"},
{"content":{"body":"This is _why_ other languages like .NET went for just doing set/get and persisting until the context would _change_.","format":"org.matrix.custom.html","formatted_body":"This is <em>why</em> other languages like .NET went for just doing set/get and persisting until the context would <em>change</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1717093895261,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Vzasa0scd2SQ5TaJs-HSM_e4cV9I7b0ZMe4QH_x-_hU"},
{"content":{"body":"> <@stephenhicks:matrix.org> it's a little pedantic, but if you have something like\n> \n> ```\n> const p = v.run(1, () => Promise.resolve());\n> await p;\n> // p is now fully resolved\n> v.run(2, p.then(() => console.log(v.get())));\n> ```\n> \n> Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the `await`, it would be 1.\n\nyeah I have been assuming that .then would always use the registration context, and that we were only talking about web APIs.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the <code>await</code>, it would be 1.</p>\n</blockquote></mx-reply>yeah I have been assuming that .then would always use the registration context, and that we were only talking about web APIs.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo"}},"msgtype":"m.text"},"ts":1717093939000,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$RoWXId1dMq_VgyND8EGStQl6610PhK79JEZZqgR_4bA"},
{"content":{"body":"(so there is no await vs .then mismatch)","m.mentions":{},"msgtype":"m.text"},"ts":1717093951624,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$xRfaG7-oOBYThYpbPGJFf7D51EHdqhm9TqaWmhygF5I"},
{"content":{"body":"> <@stephenhicks:matrix.org> it's a little pedantic, but if you have something like\n> \n> ```\n> const p = v.run(1, () => Promise.resolve());\n> await p;\n> // p is now fully resolved\n> v.run(2, p.then(() => console.log(v.get())));\n> ```\n> \n> Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the `await`, it would be 1.\n\nIn flow-through model that should _always_ be 1, as that is what was set when the _resolve_ happened. We don't much _care_ about where a continuation is attached.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>it's a little pedantic, but if you have something like</p>\n<pre><code>const p = v.run(1, () =&gt; Promise.resolve());\nawait p;\n// p is now fully resolved\nv.run(2, p.then(() =&gt; console.log(v.get())));\n</code></pre>\n<p>Then \"the most specific (i.e. causally recent) relevant context\" would presumably be the 2, since the callback was registered after the promise resolved.  Without the <code>await</code>, it would be 1.</p>\n</blockquote></mx-reply>In flow-through model that should <em>always</em> be 1, as that is what was set when the <em>resolve</em> happened. We don't much <em>care</em> about where a continuation is attached.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$CkT2s6YEGT3MY51f3I__hgbJ5-OILdaLMbjvoH1TaRo"}},"msgtype":"m.text"},"ts":1717094068666,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$_p3HBiGzGNWJCEPbckvmhmC_fkRBITMpXSmWNspwrKY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> This is _why_ other languages like .NET went for just doing set/get and persisting until the context would _change_.\n\nIs there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value _out_ of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$Vzasa0scd2SQ5TaJs-HSM_e4cV9I7b0ZMe4QH_x-_hU?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>This is <em>why</em> other languages like .NET went for just doing set/get and persisting until the context would <em>change</em>.</blockquote></mx-reply>Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value <em>out</em> of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Vzasa0scd2SQ5TaJs-HSM_e4cV9I7b0ZMe4QH_x-_hU"}},"msgtype":"m.text"},"ts":1717094085060,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ"},
{"content":{"body":"> <@stephenhicks:matrix.org> Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value _out_ of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.\n\nI think this comes up with block scopes *within* a function, where you'd restore the previous value in the latter case and not the former","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value <em>out</em> of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.</blockquote></mx-reply>I think this comes up with block scopes <em>within</em> a function, where you'd restore the previous value in the latter case and not the former","m.mentions":{"user_ids":["@stephenhicks:matrix.org","@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ"}},"msgtype":"m.text"},"ts":1717094144981,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$rcXIdKjWyIkay59Tkll61C8HpUpW7WY2JV3DzX-z044"},
{"content":{"body":"so this is the difference between using and .set","m.mentions":{},"msgtype":"m.text"},"ts":1717094152982,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ByIhyrymZ0G-KDL0g8JjkzTnHNppd115WU4YJo5d_vI"},
{"content":{"body":"> <@stephenbelanger:matrix.org> In flow-through model that should _always_ be 1, as that is what was set when the _resolve_ happened. We don't much _care_ about where a continuation is attached.\n\nRight, but I'm imagining a world where `await` is flow-around, but `then` restores the resolution context, since that would still allow accessing all the flow-through causes as needed.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$_p3HBiGzGNWJCEPbckvmhmC_fkRBITMpXSmWNspwrKY?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>In flow-through model that should <em>always</em> be 1, as that is what was set when the <em>resolve</em> happened. We don't much <em>care</em> about where a continuation is attached.</blockquote></mx-reply>Right, but I'm imagining a world where <code>await</code> is flow-around, but <code>then</code> restores the resolution context, since that would still allow accessing all the flow-through causes as needed.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$_p3HBiGzGNWJCEPbckvmhmC_fkRBITMpXSmWNspwrKY"}},"msgtype":"m.text"},"ts":1717094154432,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$rWXubcV9t3jmRp7yN5T1Vyt-iHcXOqdTKuvErvw0-ww"},
{"content":{"body":"> <@stephenhicks:matrix.org> Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value _out_ of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.\n\nIn flow-through model you capture _both_ at call _and_ at return. So when an async function or a promise resolves you capture and when the continuation of that begins you restore.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Is there some nuance here between persisting until the context would change vs. persisting until the end of a scope?  Does the former somehow allow escaping a changed value <em>out</em> of a scope where the latter doesn't?  I'm still trying to wrap my mind around how you can actually observe a changed value in a child scope if the change gets reverted before you resume.</blockquote></mx-reply>In flow-through model you capture <em>both</em> at call <em>and</em> at return. So when an async function or a promise resolves you capture and when the continuation of that begins you restore.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$BYI5Zl1OtP_wF5eHj1o82NeZUmmN-LOAzqsyYykJedQ"}},"msgtype":"m.text"},"ts":1717094168491,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7hVfNA_K_cUB1zELheDkbUNAh22fnCLjMgB6ohT8pbk"},
{"content":{"body":"> <@stephenhicks:matrix.org> Right, but I'm imagining a world where `await` is flow-around, but `then` restores the resolution context, since that would still allow accessing all the flow-through causes as needed.\n\nYes, restoring the orphaned branch is what I was thinking `callingContext` would be helpful for there.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$rWXubcV9t3jmRp7yN5T1Vyt-iHcXOqdTKuvErvw0-ww?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Right, but I'm imagining a world where <code>await</code> is flow-around, but <code>then</code> restores the resolution context, since that would still allow accessing all the flow-through causes as needed.</blockquote></mx-reply>Yes, restoring the orphaned branch is what I was thinking <code>callingContext</code> would be helpful for there.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$rWXubcV9t3jmRp7yN5T1Vyt-iHcXOqdTKuvErvw0-ww"}},"msgtype":"m.text"},"ts":1717094232390,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kjNnv_kRZxKj-0FkwGhZzyKNKDmcgkO8rrm8EfwpE4A"},
{"content":{"body":"It's a bit awkward though.","m.mentions":{},"msgtype":"m.text"},"ts":1717094236978,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$8tzxHGsXUDBpXhm58ADhVHIsDumNJEJ90J0TRzXzHcg"},
{"content":{"body":"And probably would have terrible performance for APMs which would need to be doing that basically _always_.","format":"org.matrix.custom.html","formatted_body":"And probably would have terrible performance for APMs which would need to be doing that basically <em>always</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1717094257284,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zvAyGTsR4jhKyMxxQDtm2b6Acw7_g3qTWVbysHrpzLE"},
{"content":{"body":"> <@stephenbelanger:matrix.org> And probably would have terrible performance for APMs which would need to be doing that basically _always_.\n\nYes, I expected the performance to be bad, but I was wondering if we could spec out the semantics such that it's all self-consistent, and then potentially provide a builtin alternative that exposes that common operation (which can now be emulated inefficiently) in a more efficient way.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$zvAyGTsR4jhKyMxxQDtm2b6Acw7_g3qTWVbysHrpzLE?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>And probably would have terrible performance for APMs which would need to be doing that basically <em>always</em>.</blockquote></mx-reply>Yes, I expected the performance to be bad, but I was wondering if we could spec out the semantics such that it's all self-consistent, and then potentially provide a builtin alternative that exposes that common operation (which can now be emulated inefficiently) in a more efficient way.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zvAyGTsR4jhKyMxxQDtm2b6Acw7_g3qTWVbysHrpzLE"}},"msgtype":"m.text"},"ts":1717094396081,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$96PmkixKlotu_BkH3v1GQ-i0FF0Bil7SNqKYb1RwQrg"},
{"content":{"body":"Not sure if that made any sense... basically, you could explain the semantics of `callingContext` as if were a userland implementation, but it could be implemented internally in a more efficient way.","format":"org.matrix.custom.html","formatted_body":"Not sure if that made any sense... basically, you could explain the semantics of <code>callingContext</code> as if were a userland implementation, but it could be implemented internally in a more efficient way.","m.mentions":{},"msgtype":"m.text"},"ts":1717094441168,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$K2qUtCnYIxP4FeR8AE0WaxRrdytIsyhax-1HWhD3lb8"},
{"content":{"body":"If we have to actually do that explicitly on every await though it doesn't matter how much we optimize it, it will _always_ have significant overhead. We need a type that has the appropriate flow by default or we're basically _doubling_ all the context state modifications.","format":"org.matrix.custom.html","formatted_body":"If we have to actually do that explicitly on every await though it doesn't matter how much we optimize it, it will <em>always</em> have significant overhead. We need a type that has the appropriate flow by default or we're basically <em>doubling</em> all the context state modifications.","m.mentions":{},"msgtype":"m.text"},"ts":1717094537372,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$VL8zuhc-iPzvYqBB3Kqy_B-GX5D5KrxOibZD9M8Pwkw"},
{"content":{"body":"This is why I was suggesting either having a separate type for the different flow, or having a per-store configuration to pick the different flow.","m.mentions":{},"msgtype":"m.text"},"ts":1717094601254,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$2ROK90pAybWztoAVS9oDA-ydek0Qckm1CvzSMbap0c4"},
{"content":{"body":"Requiring that users manually manage snapshots all over the place is going to get expensive fast. This is why I had _previously_ suggested flow-through by default and then a per-store config to _additionally_ snapshot around awaits as the functionality for _that_ binding layer is quite discrete and could be handled fairly performantly by just keeping a separate list of variables which want to snapshot there.","format":"org.matrix.custom.html","formatted_body":"Requiring that users manually manage snapshots all over the place is going to get expensive fast. This is why I had <em>previously</em> suggested flow-through by default and then a per-store config to <em>additionally</em> snapshot around awaits as the functionality for <em>that</em> binding layer is quite discrete and could be handled fairly performantly by just keeping a separate list of variables which want to snapshot there.","m.mentions":{},"msgtype":"m.text"},"ts":1717094758154,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ZmT4cAa0KZPKDt30L6kcU6POi2oYgdhDNiiyQztjoZg"},
{"content":{"body":"But it seems some are of the opinion that flow-around should be the default, even though it's the more costly option to escape from.","m.mentions":{},"msgtype":"m.text"},"ts":1717094840566,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$RTJp6fcLbjkElKQXjPze6mpFUSaATONOLRGGbgUDSD0"},
{"content":{"body":"I think it's a sticky situation.  The default is less relevant - even if flow-around is the user-facing default, I don't see why it couldn't be implemented internally as the option that adds additional processing on top of the flow-through codepath.  What's not clear to me is whether flow-through is viable _at all_, even as an option.  My understanding is that SES would block it outright, so even if we want it we can't really have it.","format":"org.matrix.custom.html","formatted_body":"I think it's a sticky situation.  The default is less relevant - even if flow-around is the user-facing default, I don't see why it couldn't be implemented internally as the option that adds additional processing on top of the flow-through codepath.  What's not clear to me is whether flow-through is viable <em>at all</em>, even as an option.  My understanding is that SES would block it outright, so even if we want it we can't really have it.","m.mentions":{},"msgtype":"m.text"},"ts":1717095181737,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$QwZYl-l6DAu2y0vYbeSjG4A50ji0-iT48dqtU_LWiTM"},
{"content":{"body":"> <@littledan:matrix.org> yeah I have been assuming that .then would always use the registration context, and that we were only talking about web APIs.\n\nSteve Hicks: Thoughts on this?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$RoWXId1dMq_VgyND8EGStQl6610PhK79JEZZqgR_4bA?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>yeah I have been assuming that .then would always use the registration context, and that we were only talking about web APIs.</blockquote></mx-reply><a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">Steve Hicks</a>: Thoughts on this?","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$RoWXId1dMq_VgyND8EGStQl6610PhK79JEZZqgR_4bA"}},"msgtype":"m.text"},"ts":1717095234090,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$vJS65rlsRySt572_7teH6riywZxFRuEGGgKM_3g5vgQ"},
{"content":{"body":"> <@littledan:matrix.org> Steve Hicks: Thoughts on this?\n\nAssuming we have flow-around for `await`, there will always be fundamental disagreement between the context propagation of callbacks and async-await.  Promises has to choose one or the other.  Registration aligns it with async-await, resolution aligns it with callbacks.  It's not clear to me that one is fundamentally better than the other, but the latter opens up a possibility to access semantics that are impossible with the former.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$vJS65rlsRySt572_7teH6riywZxFRuEGGgKM_3g5vgQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br><a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">Steve Hicks</a>: Thoughts on this?</blockquote></mx-reply>Assuming we have flow-around for <code>await</code>, there will always be fundamental disagreement between the context propagation of callbacks and async-await.  Promises has to choose one or the other.  Registration aligns it with async-await, resolution aligns it with callbacks.  It's not clear to me that one is fundamentally better than the other, but the latter opens up a possibility to access semantics that are impossible with the former.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$vJS65rlsRySt572_7teH6riywZxFRuEGGgKM_3g5vgQ"}},"msgtype":"m.text"},"ts":1717095481745,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$gO9xcrXaVUnOFEWfXfndc8ucYpIFo1pLU75CzDyP3Ms"},
{"content":{"body":"> <@stephenhicks:matrix.org> I think it's a sticky situation.  The default is less relevant - even if flow-around is the user-facing default, I don't see why it couldn't be implemented internally as the option that adds additional processing on top of the flow-through codepath.  What's not clear to me is whether flow-through is viable _at all_, even as an option.  My understanding is that SES would block it outright, so even if we want it we can't really have it.\n\nI don't see _why_ it'd get blocked. It has the same trait that accessing the value is impossible without having access to the variable store to begin with, so any argument about it influencing other code is no more valid with flow-through than it is with event emitters.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$QwZYl-l6DAu2y0vYbeSjG4A50ji0-iT48dqtU_LWiTM?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I think it's a sticky situation.  The default is less relevant - even if flow-around is the user-facing default, I don't see why it couldn't be implemented internally as the option that adds additional processing on top of the flow-through codepath.  What's not clear to me is whether flow-through is viable <em>at all</em>, even as an option.  My understanding is that SES would block it outright, so even if we want it we can't really have it.</blockquote></mx-reply>I don't see <em>why</em> it'd get blocked. It has the same trait that accessing the value is impossible without having access to the variable store to begin with, so any argument about it influencing other code is no more valid with flow-through than it is with event emitters.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$QwZYl-l6DAu2y0vYbeSjG4A50ji0-iT48dqtU_LWiTM"}},"msgtype":"m.text"},"ts":1717095669310,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$rKRoykQa5KpuVH7_mB0z8dpcHKor90FN6geQSpYeSIg"},
{"content":{"body":"(of course, maybe that already makes it problematic for SES anyway)","m.mentions":{},"msgtype":"m.text"},"ts":1717095676254,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$h8J0swZyVJt_Jr6TvgAhzk44TboOKoZdebhUzfrgtho"},
{"content":{"body":"I wasn't part of those earlier conversations, so I don't really understand the reasoning here","m.mentions":{},"msgtype":"m.text"},"ts":1717095721175,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$WhYcy4pcef8cprqH8roWRMEEdGJH51xJ6ZAWbxxxRpY"},
{"content":{"body":"They've got some super-theoretical framework where they transformed SyncContext to AsyncContext and reasoned that nothing dangerous happened at any step...","m.mentions":{},"msgtype":"m.text"},"ts":1717095774390,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$W0jwYS2tZJRIpU0TPYhdZnzie2ZXLhoxavaH7pNieZI"},
{"content":{"body":"But IIUC the concern was less about passing a value directly and more about causing an observable side effect in a variable (by controlling the _global_ snapshotting) without actually having access to that variable.","format":"org.matrix.custom.html","formatted_body":"But IIUC the concern was less about passing a value directly and more about causing an observable side effect in a variable (by controlling the <em>global</em> snapshotting) without actually having access to that variable.","m.mentions":{},"msgtype":"m.text"},"ts":1717095873152,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$R3be32aDK0GOM-oSiAmIZ4Xcnfndvpkbabm93_LI67c"},
{"content":{"body":" * They've got some super-theoretical framework where they transformed SyncContext to AsyncContext and transposed the ownership and reasoned that nothing dangerous happened at any step...","m.mentions":{},"m.new_content":{"body":"They've got some super-theoretical framework where they transformed SyncContext to AsyncContext and transposed the ownership and reasoned that nothing dangerous happened at any step...","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$W0jwYS2tZJRIpU0TPYhdZnzie2ZXLhoxavaH7pNieZI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717095909357,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$hwbzA8RzgNi-XUCLjqpOMkD9dDbC3KfcZnWr7BWV8Ms"},
{"content":{"body":"> <@stephenhicks:matrix.org> Assuming we have flow-around for `await`, there will always be fundamental disagreement between the context propagation of callbacks and async-await.  Promises has to choose one or the other.  Registration aligns it with async-await, resolution aligns it with callbacks.  It's not clear to me that one is fundamentally better than the other, but the latter opens up a possibility to access semantics that are impossible with the former.\n\nyes, well, within the registration world, what do you think about the web platform giving some event handlers a \"more specific\" context? I don't think that's racy, it would just depend on the cause of the event being triggered.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$gO9xcrXaVUnOFEWfXfndc8ucYpIFo1pLU75CzDyP3Ms?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Assuming we have flow-around for <code>await</code>, there will always be fundamental disagreement between the context propagation of callbacks and async-await.  Promises has to choose one or the other.  Registration aligns it with async-await, resolution aligns it with callbacks.  It's not clear to me that one is fundamentally better than the other, but the latter opens up a possibility to access semantics that are impossible with the former.</blockquote></mx-reply>yes, well, within the registration world, what do you think about the web platform giving some event handlers a \"more specific\" context? I don't think that's racy, it would just depend on the cause of the event being triggered.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$gO9xcrXaVUnOFEWfXfndc8ucYpIFo1pLU75CzDyP3Ms"}},"msgtype":"m.text"},"ts":1717098711663,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$D12hz8gEc4UDYXT0YVglSm1bZYbInSw9vTjBFx7c8no"},
{"content":{"body":"> <@stephenhicks:matrix.org> But IIUC the concern was less about passing a value directly and more about causing an observable side effect in a variable (by controlling the _global_ snapshotting) without actually having access to that variable.\n\nthat was one concern, but I think we're good about variables being a necessary thing to have access to either way, even if we go with flow-through. I think they were also concerned about, *once you already have a variable*, for dataflow to be \"well-behaved\" (whatever that means--it's a vibe)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$R3be32aDK0GOM-oSiAmIZ4Xcnfndvpkbabm93_LI67c?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>But IIUC the concern was less about passing a value directly and more about causing an observable side effect in a variable (by controlling the <em>global</em> snapshotting) without actually having access to that variable.</blockquote></mx-reply>that was one concern, but I think we're good about variables being a necessary thing to have access to either way, even if we go with flow-through. I think they were also concerned about, <em>once you already have a variable</em>, for dataflow to be \"well-behaved\" (whatever that means--it's a vibe)","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$R3be32aDK0GOM-oSiAmIZ4Xcnfndvpkbabm93_LI67c"}},"msgtype":"m.text"},"ts":1717098805049,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$t9lP58iPPr2UH0RKOvwzC8wqZ07EjJ1THe8Fc4MTKWY"},
{"content":{"body":"aesthetically, I do like keeping things well-behaved, all else being equal!","m.mentions":{},"msgtype":"m.text"},"ts":1717098833371,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$AyEhl9Ys4MuPU-XVxqd75PrHhwHjJka5oBrs4wUUdR4"},
{"content":{"body":"Being \"well-behaved\" is deeply dependant on what behaviour is _expected_. And as I expressed with my examples about confusion in regard to differences between callback and promise flows, flow-through semantic seem to be _more_ well-behaved in this regard that if flow-through is what you _expect_ then there is rarely, if ever, a need to patch things with snapshotting.","format":"org.matrix.custom.html","formatted_body":"Being \"well-behaved\" is deeply dependant on what behaviour is <em>expected</em>. And as I expressed with my examples about confusion in regard to differences between callback and promise flows, flow-through semantic seem to be <em>more</em> well-behaved in this regard that if flow-through is what you <em>expect</em> then there is rarely, if ever, a need to patch things with snapshotting.","m.mentions":{},"msgtype":"m.text"},"ts":1717101931789,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Dq8TJ6rFjf8aw8IJVIH8ii9QtmqT502eksKdtfrJWho"},
{"content":{"body":"Once you start trying to carve out sub-graphs it becomes a matter of opinion which sub-graphs are correct.","m.mentions":{},"msgtype":"m.text"},"ts":1717102019301,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$dLEpSHgYIwUYl09wMEd7OzNbWQ31iiJgiZwFpz5crSQ"},
{"content":{"body":"things \"nesting\" and \"not accidentally escaping\" feels well-behaved to someone without background in the domain. We'll need to be able to explain the argument for the other semantics in a clear way to get through to them.","m.mentions":{},"msgtype":"m.text"},"ts":1717102159982,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$fJDhbeCXd9DWKvFPSY3REIL1a8MvOdQKrIL6SG7Nd4o"},
{"content":{"body":"I expressed this in the doc and slides I shared previously, but to repeat that: there are many layers of execution rearrangement occurring in JS. The base level of the microtask scheduler is fairly _obvious_ to bind around, but as you raise further and further out into layers closer to user code it becomes less and less obvious what the \"correct\" path is when flowing around.","format":"org.matrix.custom.html","formatted_body":"I expressed this in the doc and slides I shared previously, but to repeat that: there are many layers of execution rearrangement occurring in JS. The base level of the microtask scheduler is fairly <em>obvious</em> to bind around, but as you raise further and further out into layers closer to user code it becomes less and less obvious what the \"correct\" path is when flowing around.","m.mentions":{},"msgtype":"m.text"},"ts":1717102163900,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$XSi_4qDxTrYyGkbBR7DJZ6LKh22wCcjk5jQFzAbfJgQ"},
{"content":{"body":"BTW I mentioned in the previous TG3 (SES) meeting that this is under discussion","m.mentions":{},"msgtype":"m.text"},"ts":1717102178228,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$cOum3MpTL-fOIQ_UEpD0sJpe9D2P9ZgEchSYBpkmBHE"},
{"content":{"body":"Not _accidentally_ escaping. _Intentionally_ escaping.","format":"org.matrix.custom.html","formatted_body":"Not <em>accidentally</em> escaping. <em>Intentionally</em> escaping.","m.mentions":{},"msgtype":"m.text"},"ts":1717102207285,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$liPf9NiP3vWT7GwffEySebDqK0ZOGzV6OFK-4DLfcCc"},
{"content":{"body":"> <@stephenbelanger:matrix.org> I expressed this in the doc and slides I shared previously, but to repeat that: there are many layers of execution rearrangement occurring in JS. The base level of the microtask scheduler is fairly _obvious_ to bind around, but as you raise further and further out into layers closer to user code it becomes less and less obvious what the \"correct\" path is when flowing around.\n\nlol I think we're all getting on the same page about how it's less and less obvious what the correct path is!","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$XSi_4qDxTrYyGkbBR7DJZ6LKh22wCcjk5jQFzAbfJgQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>I expressed this in the doc and slides I shared previously, but to repeat that: there are many layers of execution rearrangement occurring in JS. The base level of the microtask scheduler is fairly <em>obvious</em> to bind around, but as you raise further and further out into layers closer to user code it becomes less and less obvious what the \"correct\" path is when flowing around.</blockquote></mx-reply>lol I think we're all getting on the same page about how it's less and less obvious what the correct path is!","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$XSi_4qDxTrYyGkbBR7DJZ6LKh22wCcjk5jQFzAbfJgQ"}},"msgtype":"m.text"},"ts":1717102207670,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_IQzyZVjExg-0pG8mQujkmrWRaSGsOt6zNRu5BC1pqY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Not _accidentally_ escaping. _Intentionally_ escaping.\n\nsure, well, that explanation will have to be clear and explained in a self-contained way. They will be concerned about users who will not be expecting the escaping, even if you're doing it on purpose.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$liPf9NiP3vWT7GwffEySebDqK0ZOGzV6OFK-4DLfcCc?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Not <em>accidentally</em> escaping. <em>Intentionally</em> escaping.</blockquote></mx-reply>sure, well, that explanation will have to be clear and explained in a self-contained way. They will be concerned about users who will not be expecting the escaping, even if you're doing it on purpose.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$liPf9NiP3vWT7GwffEySebDqK0ZOGzV6OFK-4DLfcCc"}},"msgtype":"m.text"},"ts":1717102254942,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$35LUGQ-ieABYSCl5Ly6odKjZXLTRGkvDs6ExuIPK8JI"},
{"content":{"body":"Yep, that's why I aimed for through path first in _my own_ RFC and provide tools for reducing the graph as-needed. My experience has been that it's a lot easier to _reduce_ the graph than to _expand_ it.","format":"org.matrix.custom.html","formatted_body":"Yep, that's why I aimed for through path first in <em>my own</em> RFC and provide tools for reducing the graph as-needed. My experience has been that it's a lot easier to <em>reduce</em> the graph than to <em>expand</em> it.","m.mentions":{},"msgtype":"m.text"},"ts":1717102282642,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$-k0DYvMmyiBU7_Ps_PIBoOOvQ9UaL7TjYWz26j_GIYY"},
{"content":{"body":"but the through path doesn't provide more information, it just provides different information; it still loses stuff that the around path had","m.mentions":{},"msgtype":"m.text"},"ts":1717102310314,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$MMzoEtIHk_FmR6eNvP5PjjDNvABJ96qXNa00E6PX0T0"},
{"content":{"body":"Admittedly though, ALS never _had_ a way to _expand_ the graph, so that experience is _possibly_ incomplete.","format":"org.matrix.custom.html","formatted_body":"Admittedly though, ALS never <em>had</em> a way to <em>expand</em> the graph, so that experience is <em>possibly</em> incomplete.","m.mentions":{},"msgtype":"m.text"},"ts":1717102330244,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Xs4RIMk5qRskGOmDcypSyqepfwvEVDlj-Ohvisf-uZU"},
{"content":{"body":"The through path can represent the around path if you don't change the value in the branches.","m.mentions":{},"msgtype":"m.text"},"ts":1717102363265,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$YqPYe-9cQZx3Q0Y4HgqKt2DP2tf5rJPO-E_ObeJCmyM"},
{"content":{"body":"The reverse is _not_ true though.","format":"org.matrix.custom.html","formatted_body":"The reverse is <em>not</em> true though.","m.mentions":{},"msgtype":"m.text"},"ts":1717102373095,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$LpWokS5gyLMCEEB6mV6EtHJpt9e3E6vVduc9Kmt1SCI"},
{"content":{"body":"So you _can_ get the same behaviour as flow-around if you use the variables carefully.","format":"org.matrix.custom.html","formatted_body":"So you <em>can</em> get the same behaviour as flow-around if you use the variables carefully.","m.mentions":{},"msgtype":"m.text"},"ts":1717102396159,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$dmFan1nBjv9TIHcaFPKoasihy0geUpyNHVT-nnYvJ58"},
{"content":{"body":"And the bind tools let you reduce graphs to flow-around easily to prevent internal branch modifications from flowing out.","m.mentions":{},"msgtype":"m.text"},"ts":1717102447433,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zOBwoL3A-X9pjIOu2BnhNSqTYW9B4CfQPPSXR38P2j4"},
{"content":{"body":"Something like `await bindPromise(promise)` which would just capture context at the point `bindPromise(...)` is called and restore it when the given promise calls its continuation let you trivially restore around flow.","format":"org.matrix.custom.html","formatted_body":"Something like <code>await bindPromise(promise)</code> which would just capture context at the point <code>bindPromise(...)</code> is called and restore it when the given promise calls its continuation let you trivially restore around flow.","m.mentions":{},"msgtype":"m.text"},"ts":1717102508091,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$K1Z2bgE3L4BLPV5avn_gGR9WCRgA8DHXaED_-KFyK3w"},
{"content":{"body":"> <@stephenbelanger:matrix.org> So you _can_ get the same behaviour as flow-around if you use the variables carefully.\n\ncould you explain further what you mean? I wonder if we can encourage/enforce \"careful\" usage, but I don't know what property you want to maintain.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$dmFan1nBjv9TIHcaFPKoasihy0geUpyNHVT-nnYvJ58?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>So you <em>can</em> get the same behaviour as flow-around if you use the variables carefully.</blockquote></mx-reply>could you explain further what you mean? I wonder if we can encourage/enforce \"careful\" usage, but I don't know what property you want to maintain.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$dmFan1nBjv9TIHcaFPKoasihy0geUpyNHVT-nnYvJ58"}},"msgtype":"m.text"},"ts":1717102516466,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$pr1xoxRP5Uj8NDCx7K6_-hwEPDy5-Bqk1LOk8CyK_tA"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Something like `await bindPromise(promise)` which would just capture context at the point `bindPromise(...)` is called and restore it when the given promise calls its continuation let you trivially restore around flow.\n\nyep we have come to the conclusion that they can each be defined in terms of the other with explicit opt-in at the propagation sites","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$K1Z2bgE3L4BLPV5avn_gGR9WCRgA8DHXaED_-KFyK3w?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Something like <code>await bindPromise(promise)</code> which would just capture context at the point <code>bindPromise(...)</code> is called and restore it when the given promise calls its continuation let you trivially restore around flow.</blockquote></mx-reply>yep we have come to the conclusion that they can each be defined in terms of the other with explicit opt-in at the propagation sites","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$K1Z2bgE3L4BLPV5avn_gGR9WCRgA8DHXaED_-KFyK3w"}},"msgtype":"m.text"},"ts":1717102553102,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$6nIVol6WQ4trdeYfZMUtZLVC9AFsWBWrWYcIhaa1Q-8"},
{"content":{"body":"So if you do an `await doSomething()` and then don't change the value anywhere in the through flow of `doSomething()` then what comes out the other side will be exactly the same as what was present when the await first started.","format":"org.matrix.custom.html","formatted_body":"So if you do an <code>await doSomething()</code> and then don't change the value anywhere in the through flow of <code>doSomething()</code> then what comes out the other side will be exactly the same as what was present when the await first started.","m.mentions":{},"msgtype":"m.text"},"ts":1717102585140,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$34knN-HX2QH27170z6DhTQfyrOEN-g92XN8foifDl5w"},
{"content":{"body":"The only exception being if you do `await existingPromise`, which is what bind was created for in the first place for the callback equivalent, and the `bindPromise(...)` can equally solve by binding to the correct place directly at the await.","format":"org.matrix.custom.html","formatted_body":"The only exception being if you do <code>await existingPromise</code>, which is what bind was created for in the first place for the callback equivalent, and the <code>bindPromise(...)</code> can equally solve by binding to the correct place directly at the await.","m.mentions":{},"msgtype":"m.text"},"ts":1717102689854,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$E8rIg81wgGqi-ovALrVpAvDM_ChDo_K3_E2Gb9_X-Yo"},
{"content":{"body":"It just happens to be a bit annoying to need to do `bindPromise(...)` everywhere, so it _makes sense_ to have some separate optimization to be able to inform the system that you want _every_ await to apply a particular bind, which is what the around flow is essentially actually _doing_...it just doesn't give you a _choice_ in the matter.","format":"org.matrix.custom.html","formatted_body":"It just happens to be a bit annoying to need to do <code>bindPromise(...)</code> everywhere, so it <em>makes sense</em> to have some separate optimization to be able to inform the system that you want <em>every</em> await to apply a particular bind, which is what the around flow is essentially actually <em>doing</em>...it just doesn't give you a <em>choice</em> in the matter.","m.mentions":{},"msgtype":"m.text"},"ts":1717102781138,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$_ycTqNBsbJJpmEQWt22C8dgceDIw8ruYT6KqGQrOoIM"},
{"content":{"body":"Flow-around semantics are _always_ a subset of flow-through semantics. They just look different because flow-around often orphans branches which would have _otherwise_ flowed through so it appears like flow-through has return-based semantics when really it's just that _flow-around_ decided to _cut off_ the natural through flow to restore a snapshot captured before a given await. The flow is otherwise _completely identical_, apart from the single additional step of _also_ capturing at resolve and restoring _that_ unless a _different_ link point has been established.","format":"org.matrix.custom.html","formatted_body":"Flow-around semantics are <em>always</em> a subset of flow-through semantics. They just look different because flow-around often orphans branches which would have <em>otherwise</em> flowed through so it appears like flow-through has return-based semantics when really it's just that <em>flow-around</em> decided to <em>cut off</em> the natural through flow to restore a snapshot captured before a given await. The flow is otherwise <em>completely identical</em>, apart from the single additional step of <em>also</em> capturing at resolve and restoring <em>that</em> unless a <em>different</em> link point has been established.","m.mentions":{},"msgtype":"m.text"},"ts":1717103006591,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$EEHXyPynw5prP1433Pq0XkMY3mjzp-pdkTzqF0OprFA"},
{"content":{"body":"With flow-around, the context still flows through the entire branch _up to_ the point where a snapshot clobbers the value that had otherwise flowed through all the way to the resolve edge.","format":"org.matrix.custom.html","formatted_body":"With flow-around, the context still flows through the entire branch <em>up to</em> the point where a snapshot clobbers the value that had otherwise flowed through all the way to the resolve edge.","m.mentions":{},"msgtype":"m.text"},"ts":1717103057422,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$EjQd9UxFNnaK9eypSWdonMfA5vd-iGk0eUoqCGSHl74"}
]