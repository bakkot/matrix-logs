[
{"content":{"body":"* We have a similar thing in https://www.npmjs.com/package/@endo/trampoline","m.new_content":{"body":"> <@bakkot:matrix.org> I guess this is not all that common, but e.g. I have this helper where I want a function to be sync when passed a sync callback and async when passed an async callback\n> \n> ```\n> function split(genFn) {\n>   function runSync(...args) {\n>     const it = genFn(...args);\n>     let next = it.next();\n>     while (true) {\n>       if (next.done) return next.value;\n>       next = it.next(next.value);\n>     }\n>   }\n> \n>   async function runAsync(...args) {\n>     const it = genFn(...args);\n>     let next = it.next();\n>     while (true) {\n>       if (next.done) {\n>         return await next.value;\n>       }\n>       try {\n>         next = it.next(await next.value);\n>       } catch (err) {\n>         next = it.throw(err);\n>       }\n>     }\n>   }\n> \n>   return { sync: runSync, async: runAsync };\n> }\n> ```\n\nWe have a similar thing in https://www.npmjs.com/package/@endo/trampoline","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$CN4n-_wQhEbGSIEynmgIbrXNF-pGBBk_4VKsiIDRerQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@bakkot:matrix.org\">bakkot</a><br /><p>I guess this is not all that common, but e.g. I have this helper where I want a function to be sync when passed a sync callback and async when passed an async callback</p>\n<pre><code>function split(genFn) {\n  function runSync(...args) {\n    const it = genFn(...args);\n    let next = it.next();\n    while (true) {\n      if (next.done) return next.value;\n      next = it.next(next.value);\n    }\n  }\n\n  async function runAsync(...args) {\n    const it = genFn(...args);\n    let next = it.next();\n    while (true) {\n      if (next.done) {\n        return await next.value;\n      }\n      try {\n        next = it.next(await next.value);\n      } catch (err) {\n        next = it.throw(err);\n      }\n    }\n  }\n\n  return { sync: runSync, async: runAsync };\n}\n</code></pre>\n</blockquote></mx-reply>We have a similar thing in https://www.npmjs.com/package/@endo/trampoline","msgtype":"m.text"},"m.relates_to":{"event_id":"$FDr7aGqYWkLgf23MwJ25bqqfeYlNwirCRvafKB2BRR8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758672105045,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$g89kfNnbg_oxmCBS5VINqEZbLJwa1PBn4HabjLHTBfk"},
{"content":{"body":"Importantly, the TaskRunner's `promise.then()` (or `await`s) would automatically propagate the context that you started the walk from","format":"org.matrix.custom.html","formatted_body":"Importantly, the TaskRunner's <code>promise.then()</code> (or <code>await</code>s) would automatically propagate the context that you started the walk from","m.mentions":{"user_ids":["@bakkot:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$NMP_wdebKFvrzfhNcHFI_2F8cDKl6wPZzHhJYOEnAFo"}},"msgtype":"m.text"},"ts":1758674045066,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$34gWZ958lnsNW6atTQBnng2VFsTI7-2P4olMQPn4-Oo"},
{"content":{"body":"You could code `TaskRunner` in a way where this breaks, eg, queueing multiple promises but not calling `.then()` until a much later flush call","format":"org.matrix.custom.html","formatted_body":"You could code <code>TaskRunner</code> in a way where this breaks, eg, queueing multiple promises but not calling <code>.then()</code> until a much later flush call","m.mentions":{},"msgtype":"m.text"},"ts":1758674095965,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$M34-uO2e2Exju5Wi1aLzWSWH_FgAv2V422c-CNn1-LE"},
{"content":{"body":"But that's the reason we have `Snapshot`, to support that kind of usecase","format":"org.matrix.custom.html","formatted_body":"But that's the reason we have <code>Snapshot</code>, to support that kind of usecase","m.mentions":{},"msgtype":"m.text"},"ts":1758674120242,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$rCX1C2htwfLqphQ4253GLZnuSwHrDruwNUJtI4CWdQA"},
{"content":{"body":"I'd liken it more to doing\n```\n  const cb = () => {…}\n  treeId.run(file.name, cb);\n```","format":"org.matrix.custom.html","formatted_body":"<p>I'd liken it more to doing</p>\n<pre><code>  const cb = () =&gt; {…}\n  treeId.run(file.name, cb);\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1758674189721,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$W0MOJ9lZi8pwny0GOxnlwYqsX0sFDKpNLyoCrCkDFe4"},
{"content":{"body":"That `cb` isn't going to propagate a the registration context automatically","format":"org.matrix.custom.html","formatted_body":"That <code>cb</code> isn't going to propagate a the registration context automatically","m.mentions":{},"msgtype":"m.text"},"ts":1758674214922,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$w-ReqDDLQsRjVWUAgk067wRebfZjPmjqqRav-Rv4Aog"},
{"content":{"body":"* That `cb` isn't going to propagate a the creation context automatically","format":"org.matrix.custom.html","formatted_body":"* That <code>cb</code> isn't going to propagate a the creation context automatically","m.mentions":{},"m.new_content":{"body":"That `cb` isn't going to propagate a the creation context automatically","format":"org.matrix.custom.html","formatted_body":"That <code>cb</code> isn't going to propagate a the creation context automatically","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$w-ReqDDLQsRjVWUAgk067wRebfZjPmjqqRav-Rv4Aog","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1758674230630,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$MDeU_C91Qfw106qtaLDV8UuQTid5uY5leswLEZAioPQ"},
{"content":{"body":"That's exactly right - in most cases where you actually want to retain that initial context, you've already got something else that's seeing to it that it will happen.  But for cases where the calls to next() are happening from entirely different contexts, the tracing use case is very often interested in the most recent/immediate cause for the work being done, and other use cases may be as well.  For instance, an implicit abort signal could be attached to a request - if the request is doing a small increment of work in a generator, it's reasonable to want that abort signal to control that chunk of work (and if you want the \"initialization\" signal, you can capture it via a parameter initializer - I agree that's a little non-idiomatic, but it's a lot _less_ non-idiomatic than the `yield*` helper function NRO showed this morning, which (FWIW) doesn't even work for code before the first yield.","format":"org.matrix.custom.html","formatted_body":"That's exactly right - in most cases where you actually want to retain that initial context, you've already got something else that's seeing to it that it will happen.  But for cases where the calls to next() are happening from entirely different contexts, the tracing use case is very often interested in the most recent/immediate cause for the work being done, and other use cases may be as well.  For instance, an implicit abort signal could be attached to a request - if the request is doing a small increment of work in a generator, it's reasonable to want that abort signal to control that chunk of work (and if you want the \"initialization\" signal, you can capture it via a parameter initializer - I agree that's a little non-idiomatic, but it's a lot <em>less</em> non-idiomatic than the <code>yield*</code> helper function NRO showed this morning, which (FWIW) doesn't even work for code before the first yield.","m.mentions":{},"msgtype":"m.text"},"ts":1758677644934,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$e5fb9BPLwNKYJLhMXArkPdh5W_IBTmNg2gC3arcXvyo"}
]