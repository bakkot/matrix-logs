[
{"content":{"body":"> <@jiali.passion:matrix.org> So there are two cases.\n> 1. User registered the click event handler in zone1, and user click the button with mouse, the click behavior happens in a noop zone (the default zone), and the handler should run in the registered zone.\n> 2. User registered the click event handler in zone1, and user trigger the zone programmatically with something like dispatchEvent in zone2, so in this case, it is confusing that which zone should the handler run into, from the zone.js unified policy perspective, it should be zone1, otherwise in the 1st usecase, the handler should run in the noop zone,  but some user may want to see zone2 in some scenario.\n> I still belive the current policy (run callback in the register zone) make more senses, and maybe in some cases let use can also access both the register zone and the trigger zone will be better.\n\nI agree that the inconsistency of falling back is troubling. But I guess I don't see what the problem is with having interactions trigger in the null zone? Out of the three options (fall back with inconsistency, always registration but no reasonable way to access the trigger, or always trigger but sometimes/often that's the null zone) I'm happiest with the trade-off of sometimes exposing the null zone.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$G-Lsfeqtn7UXEUhZ9aX90W5l8f4bKlDrUXRZGUUXVMI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jiali.passion:matrix.org\">@jiali.passion:matrix.org</a><br /><p>So there are two cases.</p>\n<ol>\n<li>User registered the click event handler in zone1, and user click the button with mouse, the click behavior happens in a noop zone (the default zone), and the handler should run in the registered zone.</li>\n<li>User registered the click event handler in zone1, and user trigger the zone programmatically with something like dispatchEvent in zone2, so in this case, it is confusing that which zone should the handler run into, from the zone.js unified policy perspective, it should be zone1, otherwise in the 1st usecase, the handler should run in the noop zone,  but some user may want to see zone2 in some scenario.</li>\n</ol>\n<p>I still belive the current policy (run callback in the register zone) make more senses, and maybe in some cases let use can also access both the register zone and the trigger zone will be better.</p></blockquote></mx-reply>I agree that the inconsistency of falling back is troubling. But I guess I don't see what the problem is with having interactions trigger in the null zone? Out of the three options (fall back with inconsistency, always registration but no reasonable way to access the trigger, or always trigger but sometimes/often that's the null zone) I'm happiest with the trade-off of sometimes exposing the null zone.","m.relates_to":{"m.in_reply_to":{"event_id":"$G-Lsfeqtn7UXEUhZ9aX90W5l8f4bKlDrUXRZGUUXVMI"}},"msgtype":"m.text"},"ts":1716515829254,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$GqF7ammevyKUiAcNjmuHCJja1POMJjC9aOwrlHW_YKw"},
{"content":{"body":"When is the null zone what you want?","msgtype":"m.text"},"ts":1716518229347,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_v6j-GL2JVgKo7_oVMHNuDYDDszW9fnvRaZHbURhcCI"},
{"content":{"body":"The registration time zone is often what you want, on the other hand, eg for onload, setTimeout, etc. I don’t see how we could have any sort of consistent principle that you never get the registration context.","msgtype":"m.text"},"ts":1716518277054,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$dhRGS8kp0RvgHGl1UlLvlzGyLqP5gfnBv_dzyI2W5LA"},
{"content":{"body":"It's a spectrum. \"Never registration\" is one extreme end, and I don't think it's tenable. But for any _given_ API (e.g. events as a whole, or possibly split-out per event emitter/type) I'm very wary of a zalgoesque situation where the callback might run in one of two different contexts depending on unpredictable future conditions. I think that in the same way that it's important to know precisely whether a callback will run synchronously or not, it's similarly important to know ahead of time which context it will run in, and having a fallback muddies it and is (in my view) a worse trade-off than running in a \"useless\" context by default.","msgtype":"m.text"},"ts":1716519746483,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$1Vz8Atz0BJSsYX1qfZHPJGKQDbTsPhkMDXc6MbV3czw"},
{"content":{"body":"For something like onclick, the normal case is that it was triggered by the mouse, and the exceptional case is where JS dispatched the event. What should happen for that?","msgtype":"m.text"},"ts":1716519998819,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$j10Ss4fG-N15QdwHuWW04RafEkpkXvo1V2pTzY6xonY"},
{"content":{"body":"I would prefer to never expose a null context. If we can avoid that, then the value of all of your variables is always derived from previous code which triggered this one. Sorry, that is a theoretical argument and not a use-case-driven one, but it feels like an important property to preserve.","msgtype":"m.text"},"ts":1716520088567,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uKvdFUPa4s1soUchNLP3EFTHxXDk-bIFXG3kzgPsLSM"},
{"content":{"body":"I can relate to the vague Zalgo concern but am not sure if that is the overriding, most important thing to drive the decision ","format":"org.matrix.custom.html","formatted_body":"I can relate to the vague Zalgo concern but am not sure if that is the overriding, most important thing to drive the decision","msgtype":"m.text"},"ts":1716520136270,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$xLA4gw7OgaxofPeJa7ezFbyTOB2gSBYRn1j_yjYyceA"},
{"content":{"body":"Hello! Chengzhong Wu told me to join here :D","format":"org.matrix.custom.html","formatted_body":"Hello! <a href=\"https://matrix.to/#/@legendecas:matrix.org\">Chengzhong Wu</a> told me to join here :D","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"msgtype":"m.text"},"ts":1716544521981,"senderName":"Matteo Collina","senderId":"@mcollina:matrix.org","id":"$Nhn-33o0XgiL01nN3bsO2sm-uyuB41akpsMiyUE6rOM"},
{"content":{"body":"> <@jridgewell:matrix.org> > The exit is the end of the scope function\n> \n> Which means there’s a leak until the end of the function. https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d\n\n`enterWith(...)` is _not_ the same thing as a _correctly formed_ `set`/`get` interface. The `enterWith(...)` API is a hack and the docs explicitly advise people _not to use it_ as it _does not_ have any any scope end and context is not guaranteed to derive from any sort of root context, so it's an incorrect interface. It only exists because _sometimes_ it's the only way to do something in certain cases, but you need to _really_ understand the implications. It basically only exists as a tool for APM vendors that needed the capability even if it was unsafe.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$V1srDZi8bC0xms9qB7ms384I43uGU-g6M2arxxY8-Vg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br><blockquote data-md=\"&gt;\">The exit is the end of the scope function<br /></blockquote><br />Which means there’s a leak until the end of the function. https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d</blockquote></mx-reply><code>enterWith(...)</code> is <em>not</em> the same thing as a <em>correctly formed</em> <code>set</code>/<code>get</code> interface. The <code>enterWith(...)</code> API is a hack and the docs explicitly advise people <em>not to use it</em> as it <em>does not</em> have any any scope end and context is not guaranteed to derive from any sort of root context, so it's an incorrect interface. It only exists because <em>sometimes</em> it's the only way to do something in certain cases, but you need to <em>really</em> understand the implications. It basically only exists as a tool for APM vendors that needed the capability even if it was unsafe.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$V1srDZi8bC0xms9qB7ms384I43uGU-g6M2arxxY8-Vg"}},"msgtype":"m.text"},"ts":1716552687861,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$jIMKGuref64fsDdWxINi8X7znoXuEPqoxeWNWFpLf7c"},
{"content":{"body":"> <@jridgewell:matrix.org> > And yes, there most certainly is a way to know when execution ends: any time the runtime would become idle and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. \n> \n> How do you propose expsoing this API to libraries?\n\nWe can have the same sort of scoping mechanism we have already, just remove the value setting part from it. So users can use exactly the example I shared above:\n\n```js\nstore.defineScope(() => {\n  store.setForCurrentScope('foo')\n})\n```","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$j1znNwTMa11USfl_0niSVnBCsvoA4ITN2v9eKYZlZ3U?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br><blockquote data-md=\"&gt;\">And yes, there most certainly is a way to know when execution ends: any time the runtime would become idle and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. <br /></blockquote><br />How do you propose expsoing this API to libraries?</blockquote></mx-reply><p>We can have the same sort of scoping mechanism we have already, just remove the value setting part from it. So users can use exactly the example I shared above:</p>\n<pre><code class=\"language-js\">store.defineScope(() =&gt; {\n  store.setForCurrentScope('foo')\n})\n</code></pre>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$j1znNwTMa11USfl_0niSVnBCsvoA4ITN2v9eKYZlZ3U"}},"msgtype":"m.text"},"ts":1716552767444,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$_7Nm1psym9dQTlS8AD1Cr39KuK0pz4k4MvaAttGBX4U"},
{"content":{"body":"> <@jridgewell:matrix.org> > However, you don't actually need to know when an end occurs if all execution descends from a root at the beginning of execution as then the start of any execution would be propagating and therefore swapping out the context value anyway\n> \n> This doesn’t fully remove the need for the above end of task detection, becuase the last object placed there can’t be freed until the event loops replaces the context. It also means that Jobs would place an empty context when they return, which is OK I guess.\n\nYou can know synchronously if the value still needs to be held. If an async task is scheduled in a sync tick where that context is set then it is captured to be propagated. This creates a GC reference that holds it open. If a sync tick _doesn't_ create any further async tasks then it knows at the end of that sync tick that it created no new references.\n\nIn branching scenarios you would get each branch flowing up to exactly where it stops directly _causing_ async code and then would have no more references. Each sync tick would only hold the reference while running, and then each async task would hold a reference until it would run. After the task runs it can discard _its_ reference, but that would happen after new references were created for any children. Thus the GC would just function as-normal.\n\nNow it _is_ the case that data might live _quite a long time_ sometimes, but this is _intentional_ as it will only live long if descending execution of that point in context continues for long so it _should_ be holding that value as anywhere in that descending code should be able to retrieve that data.\n\nThe risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to `undefined` when you've decided you're done with it.\n\nMy point is that in a _correctly formed_ `set`/`get` system with clearly defined execution boundaries you would get a context flow that is perfectly safe from a memory usage perspective, have equivalent security characteristics to what is being proposed now (especially if a user-usable scope definition interface is added, and _most_ importantly would actually match the behaviour which basically every user of AsyncLocalStorage (which is _a lot_--literally every single Fortune 500) is _expecting_ from it.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$wMyzIY9ctegfxX20E_74Gjt8qU9_lxJMcbpM4JI3Tmg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br><blockquote data-md=\"&gt;\">However, you don't actually need to know when an end occurs if all execution descends from a root at the beginning of execution as then the start of any execution would be propagating and therefore swapping out the context value anyway<br /></blockquote><br />This doesn’t fully remove the need for the above end of task detection, becuase the last object placed there can’t be freed until the event loops replaces the context. It also means that Jobs would place an empty context when they return, which is OK I guess.</blockquote></mx-reply><p>You can know synchronously if the value still needs to be held. If an async task is scheduled in a sync tick where that context is set then it is captured to be propagated. This creates a GC reference that holds it open. If a sync tick <em>doesn't</em> create any further async tasks then it knows at the end of that sync tick that it created no new references.</p>\n<p>In branching scenarios you would get each branch flowing up to exactly where it stops directly <em>causing</em> async code and then would have no more references. Each sync tick would only hold the reference while running, and then each async task would hold a reference until it would run. After the task runs it can discard <em>its</em> reference, but that would happen after new references were created for any children. Thus the GC would just function as-normal.</p>\n<p>Now it <em>is</em> the case that data might live <em>quite a long time</em> sometimes, but this is <em>intentional</em> as it will only live long if descending execution of that point in context continues for long so it <em>should</em> be holding that value as anywhere in that descending code should be able to retrieve that data.</p>\n<p>The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to <code>undefined</code> when you've decided you're done with it.</p>\n<p>My point is that in a <em>correctly formed</em> <code>set</code>/<code>get</code> system with clearly defined execution boundaries you would get a context flow that is perfectly safe from a memory usage perspective, have equivalent security characteristics to what is being proposed now (especially if a user-usable scope definition interface is added, and <em>most</em> importantly would actually match the behaviour which basically every user of AsyncLocalStorage (which is <em>a lot</em>--literally every single Fortune 500) is <em>expecting</em> from it.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$wMyzIY9ctegfxX20E_74Gjt8qU9_lxJMcbpM4JI3Tmg"}},"msgtype":"m.text"},"ts":1716553506632,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$tMcLIyDZfJq6NOfYDTTWdsq07Vq03eTFtlHZl9Eqv7U"},
{"content":{"body":"> <@mcollina:matrix.org> Hello! Chengzhong Wu told me to join here :D\n\nSo… what do you think about the big question, of what the context should be after await? The main thing I am wondering is, how bad is AsyncLocalStorage’s behavior, and what would the practical benefits be of the change ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24Nhn-33o0XgiL01nN3bsO2sm-uyuB41akpsMiyUE6rOM\">In reply to</a> <a href=\"https://matrix.to/#/@mcollina:matrix.org\">@mcollina:matrix.org</a><br>Hello! <a href=\"https://matrix.to/#/@legendecas:matrix.org\">Chengzhong Wu</a> told me to join here :D</blockquote></mx-reply>So… what do you think about the big question, of what the context should be after await? The main thing I am wondering is, how bad is AsyncLocalStorage’s behavior, and what would the practical benefits be of the change","m.relates_to":{"m.in_reply_to":{"event_id":"$Nhn-33o0XgiL01nN3bsO2sm-uyuB41akpsMiyUE6rOM"}},"msgtype":"m.text"},"ts":1716581153390,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Ry5URcYJWNx27PwDZYF3yMQedsIQiUw4V8pI8Oy607w"},
{"content":{"body":"> <@stephenbelanger:matrix.org> We can have the same sort of scoping mechanism we have already, just remove the value setting part from it. So users can use exactly the example I shared above:\n> \n> ```js\n> store.defineScope(() => {\n>   store.setForCurrentScope('foo')\n> })\n> ```\n\nThis seems funcionally equivalent to https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550, which solves the global leak issue by having a wrapping try-catch reset the vaules after exiting the closure. It’s still not my favorite implementation becuase of mutability and odering of async functions causing unrelated breakages, eg if [main](https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d) started with an `await 0` before entering `’bar’`, the outside caller sees different behavior. It feels like Zalgo-lite.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24_7Nm1psym9dQTlS8AD1Cr39KuK0pz4k4MvaAttGBX4U\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br /><p>We can have the same sort of scoping mechanism we have already, just remove the value setting part from it. So users can use exactly the example I shared above:</p>\n<pre><code class=\"language-js\">store.defineScope(() =&gt; {\n  store.setForCurrentScope('foo')\n})\n</code></pre>\n</blockquote></mx-reply>This seems funcionally equivalent to https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550, which solves the global leak issue by having a wrapping try-catch reset the vaules after exiting the closure. It’s still not my favorite implementation becuase of mutability and odering of async functions causing unrelated breakages, eg if <a data-md href=\"https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d\">main</a> started with an <code data-md=\"`\">await 0</code> before entering <code data-md=\"`\">’bar’</code>, the outside caller sees different behavior. It feels like Zalgo-lite.","m.relates_to":{"m.in_reply_to":{"event_id":"$_7Nm1psym9dQTlS8AD1Cr39KuK0pz4k4MvaAttGBX4U"}},"msgtype":"m.text"},"ts":1716584975492,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$fiVwqndboo6mXJ01igGxVo4jk0tyfJH4g8mNKB2pcmU"},
{"content":{"body":"> <@stephenbelanger:matrix.org> You can know synchronously if the value still needs to be held. If an async task is scheduled in a sync tick where that context is set then it is captured to be propagated. This creates a GC reference that holds it open. If a sync tick _doesn't_ create any further async tasks then it knows at the end of that sync tick that it created no new references.\n> \n> In branching scenarios you would get each branch flowing up to exactly where it stops directly _causing_ async code and then would have no more references. Each sync tick would only hold the reference while running, and then each async task would hold a reference until it would run. After the task runs it can discard _its_ reference, but that would happen after new references were created for any children. Thus the GC would just function as-normal.\n> \n> Now it _is_ the case that data might live _quite a long time_ sometimes, but this is _intentional_ as it will only live long if descending execution of that point in context continues for long so it _should_ be holding that value as anywhere in that descending code should be able to retrieve that data.\n> \n> The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to `undefined` when you've decided you're done with it.\n> \n> My point is that in a _correctly formed_ `set`/`get` system with clearly defined execution boundaries you would get a context flow that is perfectly safe from a memory usage perspective, have equivalent security characteristics to what is being proposed now (especially if a user-usable scope definition interface is added, and _most_ importantly would actually match the behaviour which basically every user of AsyncLocalStorage (which is _a lot_--literally every single Fortune 500) is _expecting_ from it.\n\nEverywhere except if it’s set within the global context, which persists beyond just the current sync execution. Your above `defineScope(() => {})` solves this by definining an exit point that cleans the global context.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24tMcLIyDZfJq6NOfYDTTWdsq07Vq03eTFtlHZl9Eqv7U\">In reply to</a><a href=\"https://matrix.to/#/%40stephenbelanger%3Amatrix.org\">@stephenbelanger:matrix.org</a><br /><p>You can know synchronously if the value still needs to be held. If an async task is scheduled in a sync tick where that context is set then it is captured to be propagated. This creates a GC reference that holds it open. If a sync tick <em>doesn't</em> create any further async tasks then it knows at the end of that sync tick that it created no new references.</p>\n<p>In branching scenarios you would get each branch flowing up to exactly where it stops directly <em>causing</em> async code and then would have no more references. Each sync tick would only hold the reference while running, and then each async task would hold a reference until it would run. After the task runs it can discard <em>its</em> reference, but that would happen after new references were created for any children. Thus the GC would just function as-normal.</p>\n<p>Now it <em>is</em> the case that data might live <em>quite a long time</em> sometimes, but this is <em>intentional</em> as it will only live long if descending execution of that point in context continues for long so it <em>should</em> be holding that value as anywhere in that descending code should be able to retrieve that data.</p>\n<p>The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to <code>undefined</code> when you've decided you're done with it.</p>\n<p>My point is that in a <em>correctly formed</em> <code>set</code>/<code>get</code> system with clearly defined execution boundaries you would get a context flow that is perfectly safe from a memory usage perspective, have equivalent security characteristics to what is being proposed now (especially if a user-usable scope definition interface is added, and <em>most</em> importantly would actually match the behaviour which basically every user of AsyncLocalStorage (which is <em>a lot</em>--literally every single Fortune 500) is <em>expecting</em> from it.</p>\n</blockquote></mx-reply>Everywhere except if it’s set within the global context, which persists beyond just the current sync execution. Your above <code data-md=\"`\">defineScope(() =&gt; {})</code> solves this by definining an exit point that cleans the global context.","m.relates_to":{"m.in_reply_to":{"event_id":"$tMcLIyDZfJq6NOfYDTTWdsq07Vq03eTFtlHZl9Eqv7U"}},"msgtype":"m.text"},"ts":1716585149784,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$zsPTxqj7WoePgXeX44i9rQHqlcqmsUWD_TIX9gMWqHo"}
]