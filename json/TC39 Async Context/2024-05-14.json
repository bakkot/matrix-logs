[
{"content":{"body":"So if context _always_ flows into _all_ branches, all we _actually_ need is the context as it was when it reached a merge barrier. For example, context flows into each of the promise-returning functions passed into a `Promise.all(...)`. Each of these branches can change their context along the path but will only ever have one value. When the value eventually reaches the merge barrier where it would get placed in the array the `Promise.all(...)` call resolves to it would capture the single context value in that branch and store it in a merge context array of equal length to the `Promise.all(...)` input and output size.\n\nThe resulting merge context makes the most sense though if the resolve path is followed rather than the register path. If the register path is followed it just flattens same as the async/await issue I brought up, which means none of that merge context would reach anywhere useful if the register on the `Promise.all(...)` discards all that inner behaviour by binding around it. This is the sort of scenario why I want to have a way to get at calling context whenever a snapshot is restored. Either that or have a way to, on a per-store basis, reject the snapshot restore decision and keep using the value that propagated through the internal branch.\n\nMerge contexts are a bit weird though as it transforms a single value into an array of values, so I think it still makes sense to \"pick a winner\" for the default behaviour and just provide power users an additional power tool there, which might require a bit more manual intervention, to get at the full merge context list.","format":"org.matrix.custom.html","formatted_body":"<p>So if context <em>always</em> flows into <em>all</em> branches, all we <em>actually</em> need is the context as it was when it reached a merge barrier. For example, context flows into each of the promise-returning functions passed into a <code>Promise.all(...)</code>. Each of these branches can change their context along the path but will only ever have one value. When the value eventually reaches the merge barrier where it would get placed in the array the <code>Promise.all(...)</code> call resolves to it would capture the single context value in that branch and store it in a merge context array of equal length to the <code>Promise.all(...)</code> input and output size.</p>\n<p>The resulting merge context makes the most sense though if the resolve path is followed rather than the register path. If the register path is followed it just flattens same as the async/await issue I brought up, which means none of that merge context would reach anywhere useful if the register on the <code>Promise.all(...)</code> discards all that inner behaviour by binding around it. This is the sort of scenario why I want to have a way to get at calling context whenever a snapshot is restored. Either that or have a way to, on a per-store basis, reject the snapshot restore decision and keep using the value that propagated through the internal branch.</p>\n<p>Merge contexts are a bit weird though as it transforms a single value into an array of values, so I think it still makes sense to \"pick a winner\" for the default behaviour and just provide power users an additional power tool there, which might require a bit more manual intervention, to get at the full merge context list.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1715675131956,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$GvfsOjb1LGxx7bn37S73tGsfoWHrgflAyDJOpOOZYnQ"},
{"content":{"body":"While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the rejection context even if you explicitly want to:\n```js\nasyncCb().catch(err => {\n    if (something(err)) {\n        return someValue;\n    } else {\n        throw err;\n    }\n});\n```","format":"org.matrix.custom.html","formatted_body":"<p>While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the rejection context even if you explicitly want to:</p>\n<pre><code class=\"language-js\">asyncCb().catch(err =&gt; {\n    if (something(err)) {\n        return someValue;\n    } else {\n        throw err;\n    }\n});\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1715686187480,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Tp6zxdFyaTT0kiZ92W85fPdti_wERLALyyfaVbOahXg"},
{"content":{"body":"at least that would be in the current spec text","m.mentions":{},"msgtype":"m.text"},"ts":1715686210897,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$rT0sBaDIeCDmecjjjXcKYVFLI9HwP80LVSK0q2B5Tgo"},
{"content":{"body":"in Stephen's version it would work as expected","m.mentions":{},"msgtype":"m.text"},"ts":1715686222563,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$po5yAWV90QP-LPVT0OxocGmSFF2tvjg0k5iVamGK65E"},
{"content":{"body":" * While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the original rejection context even if you explicitly want to:\n\n```js\nasyncCb().catch(err => {\n    if (something(err)) {\n        return someValue;\n    } else {\n        throw err;\n    }\n});\n```","format":"org.matrix.custom.html","formatted_body":" * <p>While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the original rejection context even if you explicitly want to:</p>\n<pre><code class=\"language-js\">asyncCb().catch(err =&gt; {\n    if (something(err)) {\n        return someValue;\n    } else {\n        throw err;\n    }\n});\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the original rejection context even if you explicitly want to:\n\n```js\nasyncCb().catch(err => {\n    if (something(err)) {\n        return someValue;\n    } else {\n        throw err;\n    }\n});\n```","format":"org.matrix.custom.html","formatted_body":"<p>While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the original rejection context even if you explicitly want to:</p>\n<pre><code class=\"language-js\">asyncCb().catch(err =&gt; {\n    if (something(err)) {\n        return someValue;\n    } else {\n        throw err;\n    }\n});\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Tp6zxdFyaTT0kiZ92W85fPdti_wERLALyyfaVbOahXg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715686243910,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$rbHCBxtW1Qx5snC5f-eJ5iFuSrjs5z_TYeiPaQMvu-c"},
{"content":{"body":"fulfillment contexts aren't observable, but rejection contexts are with `unhandledrejection`","format":"org.matrix.custom.html","formatted_body":"fulfillment contexts aren't observable, but rejection contexts are with <code>unhandledrejection</code>","m.mentions":{},"msgtype":"m.text"},"ts":1715686308717,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$ar3-uVnk1fm-vYHlUvOGx_OyCgMtd-Ml4mlF5uw23oQ"},
{"content":{"body":"ICYMI notes are here https://docs.google.com/document/d/1pi-NMbqVhg2UuxQAZ4jOGDeHLlZGD_DJ7fyxHt_C2hs/edit and please feel free to correct it","m.mentions":{},"msgtype":"m.text"},"ts":1715706490040,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$csbUcLYw6Ge-McQeHWMUiZgz8xgUBwHZD-sUFVAPSXU"}
]