[
{"content":{"body":"> <@littledan:matrix.org> Huh, could you elaborate on this? I thought computeds would store their registration context. If you want to traverse the dependency graph to determine causation, there is an introspection API for that\n\nA computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add teaching to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up from the effect when the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$h5sxPPo9UGxJLz3bWIki0-ZdYfyFW-tKI90Sgu00OOE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />Huh, could you elaborate on this? I thought computeds would store their registration context. If you want to traverse the dependency graph to determine causation, there is an introspection API for that</blockquote></mx-reply>A computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add teaching to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up from the effect when the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).","m.relates_to":{"m.in_reply_to":{"event_id":"$h5sxPPo9UGxJLz3bWIki0-ZdYfyFW-tKI90Sgu00OOE"}},"msgtype":"m.text"},"ts":1712217372641,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$79mNZAWAldyB6LdxDBQDqgnF0SCSlWUn2kBFkxLO74I"},
{"content":{"body":"* A computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add tracing to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up from the effect when the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).","m.new_content":{"body":"> <@littledan:matrix.org> Huh, could you elaborate on this? I thought computeds would store their registration context. If you want to traverse the dependency graph to determine causation, there is an introspection API for that\n\nA computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add tracing to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up from the effect when the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$h5sxPPo9UGxJLz3bWIki0-ZdYfyFW-tKI90Sgu00OOE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a><br />Huh, could you elaborate on this? I thought computeds would store their registration context. If you want to traverse the dependency graph to determine causation, there is an introspection API for that</blockquote></mx-reply>A computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add tracing to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up from the effect when the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).","msgtype":"m.text"},"m.relates_to":{"event_id":"$79mNZAWAldyB6LdxDBQDqgnF0SCSlWUn2kBFkxLO74I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712217413809,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$GIVyKaT13yzWH6fRamYdYb725TwgZFMvBaaXf3I3vzE"},
{"content":{"body":"* A computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add tracing to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up in the effect where the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).","m.new_content":{"body":"> <@littledan:matrix.org> Huh, could you elaborate on this? I thought computeds would store their registration context. If you want to traverse the dependency graph to determine causation, there is an introspection API for that\n\nA computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add tracing to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up in the effect where the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$h5sxPPo9UGxJLz3bWIki0-ZdYfyFW-tKI90Sgu00OOE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a><br />Huh, could you elaborate on this? I thought computeds would store their registration context. If you want to traverse the dependency graph to determine causation, there is an introspection API for that</blockquote></mx-reply>A computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add tracing to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up in the effect where the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).","msgtype":"m.text"},"m.relates_to":{"event_id":"$79mNZAWAldyB6LdxDBQDqgnF0SCSlWUn2kBFkxLO74I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1712217438641,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$PsQ921SzUTgzLGVwvQMrZWW0-LXnS1WDmmV5BYgKrjU"}
]