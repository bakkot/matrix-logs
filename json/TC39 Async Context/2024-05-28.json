[
{"content":{"body":"> <@legendecas:matrix.org> A single promise could be branched multiple times, and `unhandledrejection` events are dispatched for each \"unhandled\" promise, rather than a single source of rejection\n\nI don't think this is a problem. Context splits are not problematic, only merges are. If you only care about one of the branched promises but not the rest, you could still want to know the source of rejection","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$pIoArlB7iStSTX2stB0iT1d_12g3KVXS5kwtKd6IH-E?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>A single promise could be branched multiple times, and <code>unhandledrejection</code> events are dispatched for each \"unhandled\" promise, rather than a single source of rejection</blockquote></mx-reply>I don't think this is a problem. Context splits are not problematic, only merges are. If you only care about one of the branched promises but not the rest, you could still want to know the source of rejection","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$pIoArlB7iStSTX2stB0iT1d_12g3KVXS5kwtKd6IH-E"}},"msgtype":"m.text"},"ts":1716889580565,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$1mqQCfXy_y1pE6Z-rwnlTCISZXLfqFduA1PytYgAxQw"},
{"content":{"body":"the way I think of it, if an exception (or promise rejection) is \"automatically rethrown\" (as might happen conceptually in `run`), then if you have a way to act on that error, then that context shouldn't be lost without a trace","format":"org.matrix.custom.html","formatted_body":"the way I think of it, if an exception (or promise rejection) is \"automatically rethrown\" (as might happen conceptually in <code>run</code>), then if you have a way to act on that error, then that context shouldn't be lost without a trace","m.mentions":{},"msgtype":"m.text"},"ts":1716889661496,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$T1HyOQBcUQYLTm-G9YZYLaXKM3Z2QLmg11WIa00S_MM"},
{"content":{"body":"if you choose to catch an exception/rejection and rethrow it, then you might choose to use the original throw context, or switch it depending on your use case","m.mentions":{},"msgtype":"m.text"},"ts":1716889700014,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$8fjICjPidpZpdqdU1hM76BwUwM21rPIv3sCN6w4jL4s"},
{"content":{"body":"the same way you'd expose a higher-level exception at API boundaries","m.mentions":{},"msgtype":"m.text"},"ts":1716889723119,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$XlCojJWvHQ1UESFNtnJyQHoOAgjkTinL3MmVr4YPFQg"},
{"content":{"body":" * the same way you'd wrap with a higher-level exception at API boundaries","m.mentions":{},"m.new_content":{"body":"the same way you'd wrap with a higher-level exception at API boundaries","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$XlCojJWvHQ1UESFNtnJyQHoOAgjkTinL3MmVr4YPFQg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716889730769,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$QQiQX4vbphSXIBG2mC2k-oly-uBfHZupIF6JnTZPh8o"},
{"content":{"body":"the inner throw context would be an implementation detail","m.mentions":{},"msgtype":"m.text"},"ts":1716889738237,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$mkhSi8cAfuahbJwT1E_c2ztab786mqhZK7GaPnWR6KM"},
{"content":{"body":"am I making sense?","m.mentions":{},"msgtype":"m.text"},"ts":1716889746056,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$QNLEmoK3R5l9gkrZkYDW1b2hF9JFmNxqARZbObb2ZAU"},
{"content":{"body":"> <@abotella:igalia.com> the way I think of it, if an exception (or promise rejection) is \"automatically rethrown\" (as might happen conceptually in `run`), then if you have a way to act on that error, then that context shouldn't be lost without a trace\n\nWhat's an \"automatical rethrown\"?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$T1HyOQBcUQYLTm-G9YZYLaXKM3Z2QLmg11WIa00S_MM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>the way I think of it, if an exception (or promise rejection) is \"automatically rethrown\" (as might happen conceptually in <code>run</code>), then if you have a way to act on that error, then that context shouldn't be lost without a trace</blockquote></mx-reply>What's an \"automatical rethrown\"?","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$T1HyOQBcUQYLTm-G9YZYLaXKM3Z2QLmg11WIa00S_MM"}},"msgtype":"m.text"},"ts":1716890023048,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$lkNzebktxRHB93KZMDgOP2NGypTZ8hjDzh2-qUG3DtU"},
{"content":{"body":"well, I was thinking of how `run()` essentially rethrows a thrown exception, or how a `.then()` essentially rethrows a promise rejection, without any user code","format":"org.matrix.custom.html","formatted_body":"well, I was thinking of how <code>run()</code> essentially rethrows a thrown exception, or how a <code>.then()</code> essentially rethrows a promise rejection, without any user code","m.mentions":{},"msgtype":"m.text"},"ts":1716890103263,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$37XTrNJnMu69DhqOskJ7VBjt2TEtQfL7bbvatYcKpSI"},
{"content":{"body":" * well, I was thinking of how `run()` essentially rethrows a thrown exception, or how a `.then()` without a catch handler essentially rethrows a promise rejection, without any user code","format":"org.matrix.custom.html","formatted_body":" * well, I was thinking of how <code>run()</code> essentially rethrows a thrown exception, or how a <code>.then()</code> without a catch handler essentially rethrows a promise rejection, without any user code","m.mentions":{},"m.new_content":{"body":"well, I was thinking of how `run()` essentially rethrows a thrown exception, or how a `.then()` without a catch handler essentially rethrows a promise rejection, without any user code","format":"org.matrix.custom.html","formatted_body":"well, I was thinking of how <code>run()</code> essentially rethrows a thrown exception, or how a <code>.then()</code> without a catch handler essentially rethrows a promise rejection, without any user code","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$37XTrNJnMu69DhqOskJ7VBjt2TEtQfL7bbvatYcKpSI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716890119432,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$BQlrkErVZq6lrqgwkgYwuVBhWu_yqEfB4U5liRm5bps"},
{"content":{"body":"A handled promise could be `await`-ed or add a new branch with `.then`, and an `unhandledrejection` is dispatched for the promise that has no handler instead of the handled promise.\n\n```js\nconst p1 = asyncVar.run(\"p1\", () => new Promise((resolve, reject) => {\n  reject('rejection')\n}))\np1.then(() => {}, () => {}) // handle this promise\n\nconst p2 = asyncVar.run(\"p2\", async () => {\n  await p1\n})\n\nwindow.addEventListener(\"unhandledrejection\", event => {\n  event.promise // => p2\n  asyncVar.get() // => ?\n})\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>A handled promise could be <code>await</code>-ed or add a new branch with <code>.then</code>, and an <code>unhandledrejection</code> is dispatched for the promise that has no handler instead of the handled promise.</p>\n<pre><code class=\"language-js\">const p1 = asyncVar.run(\"p1\", () =&gt; new Promise((resolve, reject) =&gt; {\n  reject('rejection')\n}))\np1.then(() =&gt; {}, () =&gt; {}) // handle this promise\n\nconst p2 = asyncVar.run(\"p2\", async () =&gt; {\n  await p1\n})\n\nwindow.addEventListener(\"unhandledrejection\", event =&gt; {\n  event.promise // =&gt; p2\n  asyncVar.get() // =&gt; ?\n})\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716891247868,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$bj68j4dHkI_KckyRWB8xEi94L2JGadrkUE5nYudasYI"},
{"content":{"body":" * A handled promise could be `await`-ed or add a new branch with `.then`, and an `unhandledrejection` is dispatched for the promise that has no handler instead of the handled rejection source promise.\n\n```js\nconst p1 = asyncVar.run(\"p1\", () => new Promise((resolve, reject) => {\n  reject('rejection')\n}))\np1.then(() => {}, () => {}) // handle this promise\n\nconst p2 = asyncVar.run(\"p2\", async () => {\n  await p1\n})\n\nwindow.addEventListener(\"unhandledrejection\", event => {\n  event.promise // => p2\n  asyncVar.get() // => ?\n})\n```","format":"org.matrix.custom.html","formatted_body":" * <p>A handled promise could be <code>await</code>-ed or add a new branch with <code>.then</code>, and an <code>unhandledrejection</code> is dispatched for the promise that has no handler instead of the handled rejection source promise.</p>\n<pre><code class=\"language-js\">const p1 = asyncVar.run(\"p1\", () =&gt; new Promise((resolve, reject) =&gt; {\n  reject('rejection')\n}))\np1.then(() =&gt; {}, () =&gt; {}) // handle this promise\n\nconst p2 = asyncVar.run(\"p2\", async () =&gt; {\n  await p1\n})\n\nwindow.addEventListener(\"unhandledrejection\", event =&gt; {\n  event.promise // =&gt; p2\n  asyncVar.get() // =&gt; ?\n})\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"A handled promise could be `await`-ed or add a new branch with `.then`, and an `unhandledrejection` is dispatched for the promise that has no handler instead of the handled rejection source promise.\n\n```js\nconst p1 = asyncVar.run(\"p1\", () => new Promise((resolve, reject) => {\n  reject('rejection')\n}))\np1.then(() => {}, () => {}) // handle this promise\n\nconst p2 = asyncVar.run(\"p2\", async () => {\n  await p1\n})\n\nwindow.addEventListener(\"unhandledrejection\", event => {\n  event.promise // => p2\n  asyncVar.get() // => ?\n})\n```","format":"org.matrix.custom.html","formatted_body":"<p>A handled promise could be <code>await</code>-ed or add a new branch with <code>.then</code>, and an <code>unhandledrejection</code> is dispatched for the promise that has no handler instead of the handled rejection source promise.</p>\n<pre><code class=\"language-js\">const p1 = asyncVar.run(\"p1\", () =&gt; new Promise((resolve, reject) =&gt; {\n  reject('rejection')\n}))\np1.then(() =&gt; {}, () =&gt; {}) // handle this promise\n\nconst p2 = asyncVar.run(\"p2\", async () =&gt; {\n  await p1\n})\n\nwindow.addEventListener(\"unhandledrejection\", event =&gt; {\n  event.promise // =&gt; p2\n  asyncVar.get() // =&gt; ?\n})\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$bj68j4dHkI_KckyRWB8xEi94L2JGadrkUE5nYudasYI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716891327532,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$uawureYHJCLoQPJy5jTxVmorGItD650MuYdSDkSqW5w"},
{"content":{"body":"> <@abotella:igalia.com> I don't think this is a problem. Context splits are not problematic, only merges are. If you only care about one of the branched promises but not the rest, you could still want to know the source of rejection\n\nLike the example above, awaiting a promise of a different context is a merge operation in flow-through","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$1mqQCfXy_y1pE6Z-rwnlTCISZXLfqFduA1PytYgAxQw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>I don't think this is a problem. Context splits are not problematic, only merges are. If you only care about one of the branched promises but not the rest, you could still want to know the source of rejection</blockquote></mx-reply>Like the example above, awaiting a promise of a different context is a merge operation in flow-through","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$1mqQCfXy_y1pE6Z-rwnlTCISZXLfqFduA1PytYgAxQw"}},"msgtype":"m.text"},"ts":1716892609772,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$I3iHcgW-Bjcab7HQpXxgykNJwckLK32BlBHNOxousxQ"},
{"content":{"body":"I guess both p1 and p2 could be contexts you might want, it's the same pass-around vs pass-through distinction","msgtype":"m.text"},"ts":1716892647284,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$cqRwW7bzh_4WxB1vVdc2eZmQKgEzCD08UyncAd_x6qI"},
{"content":{"body":"yeah, it could be. I'm saying that the flow-around is not something that is not desired.","m.mentions":{},"msgtype":"m.text"},"ts":1716892722358,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$s8-TueAqV0n2yOcgq3VWe-X1OpWvNwAuz6kyRfl7M4k"},
{"content":{"body":"> <@legendecas:matrix.org> I think the flow-through pattern doesn't answer the similar problem of https://github.com/tc39/proposal-async-context/issues/90.\n> \n> The originating context could be a stack of contexts and use inner-most context would discard all outer contexts. Each `await` creates resolution handler on a potentially rejected promise, use the inner-most context would lose the context when the rejection was handled multiple times.\n> \n> ```js\n> let aGlobalPromise = asyncVar.run('global', () => {\n>   return Promise.reject()\n> })\n> \n> async function someAsyncApi() {\n>   await asyncVar.run('async-inner', async () => {\n>     try {\n>       await aGlobalPromise\n>     } catch (e) {\n>       throw e\n>     }\n>   })\n> }\n> \n> asyncVar.run(\"foo\", async () => {\n>   await someAsyncApi()\n> });\n> asyncVar.run(\"bar\", async () => {\n>   await someAsyncApi()\n> });\n> \n> window.addEventListener(\"unhandledrejection\", () => {\n>   console.log(asyncVar.get());  // 'foo' or 'bar' or 'global' or 'async-inner'?\n> });\n> ```\n\nthe problem is actually worse than this looks: with any stack of async functions, the unhandled rejection will be credited as throwing from the outermost one, even if there's no catch/finally clause.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$M5hP9IZMaKTNM1vL74GhYbid25b_4VKdhHiB783Y55o?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br><p>I think the flow-through pattern doesn't answer the similar problem of https://github.com/tc39/proposal-async-context/issues/90.</p>\n<p>The originating context could be a stack of contexts and use inner-most context would discard all outer contexts. Each <code>await</code> creates resolution handler on a potentially rejected promise, use the inner-most context would lose the context when the rejection was handled multiple times.</p>\n<pre><code class=\"language-js\">let aGlobalPromise = asyncVar.run('global', () =&gt; {\n  return Promise.reject()\n})\n\nasync function someAsyncApi() {\n  await asyncVar.run('async-inner', async () =&gt; {\n    try {\n      await aGlobalPromise\n    } catch (e) {\n      throw e\n    }\n  })\n}\n\nasyncVar.run(\"foo\", async () =&gt; {\n  await someAsyncApi()\n});\nasyncVar.run(\"bar\", async () =&gt; {\n  await someAsyncApi()\n});\n\nwindow.addEventListener(\"unhandledrejection\", () =&gt; {\n  console.log(asyncVar.get());  // 'foo' or 'bar' or 'global' or 'async-inner'?\n});\n</code></pre>\n</blockquote></mx-reply>the problem is actually worse than this looks: with any stack of async functions, the unhandled rejection will be credited as throwing from the outermost one, even if there's no catch/finally clause.","m.mentions":{"user_ids":["@legendecas:matrix.org","@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$M5hP9IZMaKTNM1vL74GhYbid25b_4VKdhHiB783Y55o"}},"msgtype":"m.text"},"ts":1716903414557,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$B_OSKwLV0we0G63O9gZg0y53olHgpaWYe99JaHRSDO4"},
{"content":{"body":"I'm not sure whether the resolve context change would address this; my initial intuition is that it wouldn't","m.mentions":{},"msgtype":"m.text"},"ts":1716903465969,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$r4s-r8PUSOWboIP-Jf0WW0dT3hP5aHpTcC_g5n3P0-o"},
{"content":{"body":"but maybe the context would be propagated properly through the chain of rejections?","m.mentions":{},"msgtype":"m.text"},"ts":1716903496087,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_F0U4lzilnQISSECQ62IwJ774TKEsDBWxqgC_Tts_00"}
]