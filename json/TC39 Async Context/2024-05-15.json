[
{"content":{"body":"One of my AI's was to go through Stephen's docs and try to figure out what the gist of it was.  I think Stephen was also going to try to distill it down a bit further, though it was late for him by the end of the meeting.  Variable.prototype.wrap is a convenience function and I think we agreed to more or less table it for now.  But there's also a question of per-instance propagation configuration that is impossible to do in userland (i.e. some vars propagate via init/registration context, while others propagate via causal/calling context).  Per a discussion today with Scott Haseley, it sounds like there's already some precedent for this in how v8 handles yield vs. normal CPED/attribution, in that the latter propagates over setTimeout while the former is dropped.  In the case of multiple variable configs, I think it would boil down to having effectively two separate variable linked lists instead of one, and they're treated differently by snapshot swapping.  This may not be infeasible, so it's maybe worth considering whether it leads to a good solution.\n\nWe didn't get a chance to discuss callingContext, though (tbh) it's still my preferred option for ensuring the APM use case is viable - but we still need to figure out Promise.all.  One (totally off-the-cuff) possibility would be to just stack up all the causal contexts, first-to-last.  You know how many promises were merged, so you can pop that many contexts off the stack if you need them all.\n\nUpshot from discussion with Jatin was that he agreed that calling context is crucial, and figured that most userland schedulers (at least the ones he owns) would probably need to go with that default.  Registration context is useless for our use of computed signals and effects (and he was particularly concerned about losing the ability to see causal context if/when Signals land in the standard), and we'd need to propagate causal context throughout all the stages of (user interaction) -> (lazy load, controller instantiation) -> (rpc fetch) -> (model cache update) -> (component rerender) in order to ensure tracing works correctly.  These are all (currently) userland schedulers, at least, so it's possible, but ultimately the hope is to replace the model cache with signals.","m.mentions":{},"msgtype":"m.text"},"ts":1715747331748,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$EnzHypgXAmfMSFa9x4fIX-7W0sWohuCcqsKnMJteC_E"},
{"content":{"body":" * One of my AI's was to go through Stephen's docs and try to figure out what the gist of it was.  I think Stephen was also going to try to distill it down a bit further, though it was late for him by the end of the meeting.  Variable.prototype.wrap is a convenience function and I think we agreed to more or less table it for now.  But there's also a question of per-instance propagation configuration that is impossible to do in userland (i.e. some vars propagate via init/registration context, while others propagate via causal/calling context).  Per a discussion today with Scott Haseley, it sounds like there's already some precedent for this in how v8 handles yield vs. normal CPED/attribution, in that the latter propagates over setTimeout while the former is dropped.  In the case of multiple variable configs, I think it would boil down to having effectively two separate variable linked lists instead of one, and they're treated differently by snapshot swapping.  This may not be infeasible, so it's maybe worth considering whether it leads to a good solution.\n\nWe didn't get a chance to discuss callingContext, though (tbh) it's still my preferred option for ensuring the APM use case is viable, due to balancing the extra complexity and feasibility of ever actually landing this proposal, vs stalling out from trying to do too much - but we do still need to figure out Promise.all.  One (totally off-the-cuff) possibility would be to just stack up all the causal contexts, first-to-last.  You know how many promises were merged, so you can pop that many contexts off the stack if you need them all.\n\nUpshot from discussion with Jatin was that he agreed that calling context is crucial, and figured that most userland schedulers (at least the ones he owns) would probably need to go with that default.  Registration context is useless for our use of computed signals and effects (and he was particularly concerned about losing the ability to see causal context if/when Signals land in the standard), and we'd need to propagate causal context throughout all the stages of (user interaction) -> (lazy load, controller instantiation) -> (rpc fetch) -> (model cache update) -> (component rerender) in order to ensure tracing works correctly.  These are all (currently) userland schedulers, at least, so it's possible, but ultimately the hope is to replace the model cache with signals.","m.mentions":{},"m.new_content":{"body":"One of my AI's was to go through Stephen's docs and try to figure out what the gist of it was.  I think Stephen was also going to try to distill it down a bit further, though it was late for him by the end of the meeting.  Variable.prototype.wrap is a convenience function and I think we agreed to more or less table it for now.  But there's also a question of per-instance propagation configuration that is impossible to do in userland (i.e. some vars propagate via init/registration context, while others propagate via causal/calling context).  Per a discussion today with Scott Haseley, it sounds like there's already some precedent for this in how v8 handles yield vs. normal CPED/attribution, in that the latter propagates over setTimeout while the former is dropped.  In the case of multiple variable configs, I think it would boil down to having effectively two separate variable linked lists instead of one, and they're treated differently by snapshot swapping.  This may not be infeasible, so it's maybe worth considering whether it leads to a good solution.\n\nWe didn't get a chance to discuss callingContext, though (tbh) it's still my preferred option for ensuring the APM use case is viable, due to balancing the extra complexity and feasibility of ever actually landing this proposal, vs stalling out from trying to do too much - but we do still need to figure out Promise.all.  One (totally off-the-cuff) possibility would be to just stack up all the causal contexts, first-to-last.  You know how many promises were merged, so you can pop that many contexts off the stack if you need them all.\n\nUpshot from discussion with Jatin was that he agreed that calling context is crucial, and figured that most userland schedulers (at least the ones he owns) would probably need to go with that default.  Registration context is useless for our use of computed signals and effects (and he was particularly concerned about losing the ability to see causal context if/when Signals land in the standard), and we'd need to propagate causal context throughout all the stages of (user interaction) -> (lazy load, controller instantiation) -> (rpc fetch) -> (model cache update) -> (component rerender) in order to ensure tracing works correctly.  These are all (currently) userland schedulers, at least, so it's possible, but ultimately the hope is to replace the model cache with signals.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$EnzHypgXAmfMSFa9x4fIX-7W0sWohuCcqsKnMJteC_E","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715747446510,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$-m55UawwCczLqyXnoFgHTtUTOURnzohkNG-ifAmuirY"},
{"content":{"body":"I took a stap at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA","m.mentions":{},"msgtype":"m.text"},"ts":1715748523463,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$DTLBd7W-uRFkBUC89H9ar_ay1OEb1lwWkkWZJhk1cYU"},
{"content":{"body":" * I took a stap at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: [playground](https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA)","format":"org.matrix.custom.html","formatted_body":" * I took a stap at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: <a href=\"https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA\">playground</a>","m.mentions":{},"m.new_content":{"body":"I took a stap at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: [playground](https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA)","format":"org.matrix.custom.html","formatted_body":"I took a stap at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: <a href=\"https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA\">playground</a>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$DTLBd7W-uRFkBUC89H9ar_ay1OEb1lwWkkWZJhk1cYU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715748552666,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$M2E4rJkeQow1YZNkW62mG52vJCueE6Xy6U0OpFCXgwQ"},
{"content":{"body":" * I took a stab at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: [playground](https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA)","format":"org.matrix.custom.html","formatted_body":" * I took a stab at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: <a href=\"https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA\">playground</a>","m.mentions":{},"m.new_content":{"body":"I took a stab at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: [playground](https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA)","format":"org.matrix.custom.html","formatted_body":"I took a stab at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: <a href=\"https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA\">playground</a>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$DTLBd7W-uRFkBUC89H9ar_ay1OEb1lwWkkWZJhk1cYU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715748565424,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$H0cKsYwVHpT7B7b1nUL61yDz0sOEV67qZPPQftkErPg"},
{"content":{"body":"I can see a few variants on callingContext: (1) it just puts the previous frame directly on top of the current one (i.e. behaves identical to Snapshot.run) - in this case, one could just _make_ it a snapshot?  This makes it impossible to access deeper-nested ones, since `callingContext()` will just get you back to the previous (registration?) context.  Unless maybe it takes a depth argument.  In that case, the stacking might _just_ be possible.  Or (2) it restores the entire context stack to whatever it looked like in the calling environment, such that a second `callingContext`would go back further in causation history.","format":"org.matrix.custom.html","formatted_body":"I can see a few variants on callingContext: (1) it just puts the previous frame directly on top of the current one (i.e. behaves identical to Snapshot.run) - in this case, one could just <em>make</em> it a snapshot?  This makes it impossible to access deeper-nested ones, since <code>callingContext()</code> will just get you back to the previous (registration?) context.  Unless maybe it takes a depth argument.  In that case, the stacking might <em>just</em> be possible.  Or (2) it restores the entire context stack to whatever it looked like in the calling environment, such that a second <code>callingContext</code>would go back further in causation history.","m.mentions":{},"msgtype":"m.text"},"ts":1715748802968,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$3RlFHbHWiq7N9hUrmmyQvBYcQ2a4Xlz3xLan8Ofd34g"},
{"content":{"body":"I made this small (-ish) example of how we're doing that differentiation between child-of and follows-from relationships and what we're trying to do with holding the minimum possible data in the store (just the ID). https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e","m.mentions":{},"msgtype":"m.text"},"ts":1715771259392,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ospSxB-4gtYM-mSEdbOhQWjFJ79mvIHGjbNmWHIsz0w"},
{"content":{"body":"In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure. But we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.","format":"org.matrix.custom.html","formatted_body":"In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not <em>too</em> terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not <em>too</em> terribly important as we at least get <em>one</em> of the branches so we can still <em>mostly</em> understand the execution structure. But we <em>do</em> need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically <em>continues</em> from a particular point is expected to be able to attribute itself from that. Whereas what we get <em>currently</em> with both async/await and promises is a flat structure where all the <code>mysql.query</code> spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.","m.mentions":{},"msgtype":"m.text"},"ts":1715773037878,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$6xsFYNVKZ8KYQ_yvESghJtHt7egBAQ9-2X9WlSfsNUo"},
{"content":{"body":" * In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.\n\nBut we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.","format":"org.matrix.custom.html","formatted_body":" * <p>In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not <em>too</em> terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not <em>too</em> terribly important as we at least get <em>one</em> of the branches so we can still <em>mostly</em> understand the execution structure.</p>\n<p>But we <em>do</em> need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically <em>continues</em> from a particular point is expected to be able to attribute itself from that. Whereas what we get <em>currently</em> with both async/await and promises is a flat structure where all the <code>mysql.query</code> spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.</p>\n","m.mentions":{},"m.new_content":{"body":"In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.\n\nBut we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.","format":"org.matrix.custom.html","formatted_body":"<p>In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not <em>too</em> terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not <em>too</em> terribly important as we at least get <em>one</em> of the branches so we can still <em>mostly</em> understand the execution structure.</p>\n<p>But we <em>do</em> need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically <em>continues</em> from a particular point is expected to be able to attribute itself from that. Whereas what we get <em>currently</em> with both async/await and promises is a flat structure where all the <code>mysql.query</code> spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$6xsFYNVKZ8KYQ_yvESghJtHt7egBAQ9-2X9WlSfsNUo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715773062630,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$v0jvx9vGTbk9YY4nyhmZjcCRPhaQy21L7OoovYnYcsk"},
{"content":{"body":" * In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.\n\nBut we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.","format":"org.matrix.custom.html","formatted_body":" * <p>In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not <em>too</em> terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not <em>too</em> terribly important as we at least get <em>one</em> of the branches so we can still <em>mostly</em> understand the execution structure.</p>\n<p>But we <em>do</em> need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically <em>continues</em> from a particular point is expected to be able to attribute itself from that. Whereas what we get <em>currently</em> with both async/await and promises is a flat structure where all the <code>mysql.query</code> spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.</p>\n","m.mentions":{},"m.new_content":{"body":"In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.\n\nBut we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.","format":"org.matrix.custom.html","formatted_body":"<p>In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not <em>too</em> terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not <em>too</em> terribly important as we at least get <em>one</em> of the branches so we can still <em>mostly</em> understand the execution structure.</p>\n<p>But we <em>do</em> need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically <em>continues</em> from a particular point is expected to be able to attribute itself from that. Whereas what we get <em>currently</em> with both async/await and promises is a flat structure where all the <code>mysql.query</code> spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$6xsFYNVKZ8KYQ_yvESghJtHt7egBAQ9-2X9WlSfsNUo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715773078257,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$9XmvK_y8AAq-ShHMwLrfS3hdATj21KsM3rnhzeXbpyA"},
{"content":{"body":" * In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.\n\nBut we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself to that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.","format":"org.matrix.custom.html","formatted_body":" * <p>In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not <em>too</em> terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not <em>too</em> terribly important as we at least get <em>one</em> of the branches so we can still <em>mostly</em> understand the execution structure.</p>\n<p>But we <em>do</em> need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically <em>continues</em> from a particular point is expected to be able to attribute itself to that. Whereas what we get <em>currently</em> with both async/await and promises is a flat structure where all the <code>mysql.query</code> spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.</p>\n","m.mentions":{},"m.new_content":{"body":"In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.\n\nBut we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself to that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.","format":"org.matrix.custom.html","formatted_body":"<p>In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not <em>too</em> terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not <em>too</em> terribly important as we at least get <em>one</em> of the branches so we can still <em>mostly</em> understand the execution structure.</p>\n<p>But we <em>do</em> need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically <em>continues</em> from a particular point is expected to be able to attribute itself to that. Whereas what we get <em>currently</em> with both async/await and promises is a flat structure where all the <code>mysql.query</code> spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$6xsFYNVKZ8KYQ_yvESghJtHt7egBAQ9-2X9WlSfsNUo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715773094551,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zUuYOHFOxHF-__wMzvfs7JFm1Z4Y3qJeQPDHj_H-Jlo"},
{"content":{"body":"I am confused by general comments on registration time vs call time. Can we do more to dig into the detailed cases? (Am chatting with Jatin about this now too)","msgtype":"m.text"},"ts":1715783837513,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$4zYf717ud8bFex1N9ibHXcFjjlvx0nOezuKGU9XYMwI"},
{"content":{"body":"Andreu had some sort of point by point analysis. What if we made that a Google Doc and then we could comment together on which things could/should be different for which use cases?","msgtype":"m.text"},"ts":1715783882412,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Q_zPGqBC4ZYCoFxlHdSss4_qHpkkiFDuzjQbYRTH_Fo"},
{"content":{"body":"In reality there will be a mix of both registration time and call time, so I have trouble understanding conversations which are phrases like ‚Äúvs‚Äù","msgtype":"m.text"},"ts":1715784544939,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$LIm5fdH3MOV10BheVYWQIBu7OAXy2QL3SaneftV_pz4"},
{"content":{"body":"A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. <button on click=\"...\"> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","msgtype":"m.text"},"ts":1715786873387,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$AS9hFcLT9M4DpzR-hxYCmDoeu8XTbl9x5P1KOMJ0kIs"},
{"content":{"body":" * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \\<buttonon click=\"...\"> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need \\_some\\_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","format":"org.matrix.custom.html","formatted_body":" * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. &lt;buttonon click=&quot;...&quot;&gt; with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","m.mentions":{},"m.new_content":{"body":"A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \\<buttonon click=\"...\"> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need \\_some\\_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","format":"org.matrix.custom.html","formatted_body":"A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. &lt;buttonon click=&quot;...&quot;&gt; with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$AS9hFcLT9M4DpzR-hxYCmDoeu8XTbl9x5P1KOMJ0kIs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715788204717,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$KANB_NFy2boCSROgU1621HNPpTom14HE_XXqdx0keO4"},
{"content":{"body":" * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \\<buttonon click=\"...\"> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","format":"org.matrix.custom.html","formatted_body":" * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. &lt;buttonon click=\"...\"&gt; with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need <em>some</em> option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","m.mentions":{},"m.new_content":{"body":"A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \\<buttonon click=\"...\"> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","format":"org.matrix.custom.html","formatted_body":"A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. &lt;buttonon click=\"...\"&gt; with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need <em>some</em> option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$AS9hFcLT9M4DpzR-hxYCmDoeu8XTbl9x5P1KOMJ0kIs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715788217220,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$IEX7-0Kii0KQ81mWxAEpuDj9G2PazkvgsERz6n02kPc"},
{"content":{"body":" * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \\<button onclick=\"...\"> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","format":"org.matrix.custom.html","formatted_body":" * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. &lt;button onclick=\"...\"&gt; with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need <em>some</em> option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","m.mentions":{},"m.new_content":{"body":"A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \\<button onclick=\"...\"> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","format":"org.matrix.custom.html","formatted_body":"A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. &lt;button onclick=\"...\"&gt; with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need <em>some</em> option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$AS9hFcLT9M4DpzR-hxYCmDoeu8XTbl9x5P1KOMJ0kIs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715788235814,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$nxZgpGGCQ1wJwGn8aMEN91GTcnDYZXBgMD_EzsAVFUU"},
{"content":{"body":"I'm wondering if await/yield/then binding should just be a config per-store and we can just hold two sets of stores so ones that _do_ have that turned on do those binds and ones that have it turned off don't get tracked in that list at all. Just a random idea. And to be clear, I don't care which way is the default. If we have the capability to switch to the other on our stores then that's basically the one single major blocker for APM vendors right now, as far as I can tell. ü§î","format":"org.matrix.custom.html","formatted_body":"I'm wondering if await/yield/then binding should just be a config per-store and we can just hold two sets of stores so ones that <em>do</em> have that turned on do those binds and ones that have it turned off don't get tracked in that list at all. Just a random idea. And to be clear, I don't care which way is the default. If we have the capability to switch to the other on our stores then that's basically the one single major blocker for APM vendors right now, as far as I can tell. ü§î","m.mentions":{},"msgtype":"m.text"},"ts":1715788729527,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$WJXeKUdvFi0i3tLaxsQGmJ4td3og3MP2qClBOPRCBJU"},
{"content":{"body":"I think if we had that option then it would end up needing to be _three_ different sets in the long run, since `scheduler.yield` (and/or `scheduler.currentTaskSignal`) would need yet a different propagation, where it _does_ propagate across `await`, but +not_ through `setTimeout`.","format":"org.matrix.custom.html","formatted_body":"I think if we had that option then it would end up needing to be <em>three</em> different sets in the long run, since <code>scheduler.yield</code> (and/or <code>scheduler.currentTaskSignal</code>) would need yet a different propagation, where it <em>does</em> propagate across <code>await</code>, but +not_ through <code>setTimeout</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1715790162347,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$_u7L-bCxX2_DP7u1vxYEalEIT75eZFrlXXpBomhqwXg"},
{"content":{"body":" * I think if we had that option then it would end up needing to be _three_ different sets in the long run, since `scheduler.yield` (and/or `scheduler.currentTaskSignal`) would need yet a different propagation, where it _does_ propagate across `await`, but _not_ through `setTimeout`.","format":"org.matrix.custom.html","formatted_body":" * I think if we had that option then it would end up needing to be <em>three</em> different sets in the long run, since <code>scheduler.yield</code> (and/or <code>scheduler.currentTaskSignal</code>) would need yet a different propagation, where it <em>does</em> propagate across <code>await</code>, but <em>not</em> through <code>setTimeout</code>.","m.mentions":{},"m.new_content":{"body":"I think if we had that option then it would end up needing to be _three_ different sets in the long run, since `scheduler.yield` (and/or `scheduler.currentTaskSignal`) would need yet a different propagation, where it _does_ propagate across `await`, but _not_ through `setTimeout`.","format":"org.matrix.custom.html","formatted_body":"I think if we had that option then it would end up needing to be <em>three</em> different sets in the long run, since <code>scheduler.yield</code> (and/or <code>scheduler.currentTaskSignal</code>) would need yet a different propagation, where it <em>does</em> propagate across <code>await</code>, but <em>not</em> through <code>setTimeout</code>.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_u7L-bCxX2_DP7u1vxYEalEIT75eZFrlXXpBomhqwXg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1715790179662,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$aa6LC1ufZJKBWDkbOkgp_xL0ZTz_oj72h4-qihrWRa4"}
]