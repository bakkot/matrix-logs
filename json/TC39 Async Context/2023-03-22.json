[
{"content":{"body":"I had some quick chats today at TC39 with dminor and bakkot, everyone seemed cautiously positive though a little uncertain about use cases. I am optimistic about the presentation but we might consider adding bonus slides that go in more depth there (eg just taking what was in legendecas’s webperf wg slides)","msgtype":"m.text"},"ts":1679445053389,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Yxvfy8w3YSGiIc_DdrS6kGxHpvJPwjInSAG_covkMpI"},
{"content":{"body":"I didn’t get the feeling that the complexity around what things are wrapped was considered a very bad issue for either (just something to work out) but maybe I misunderstood them","msgtype":"m.text"},"ts":1679445110503,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$rQZ4SGbPdgLagMyfPgeA9AtEG-GQaEK081ULM0xmdmE"},
{"content":{"body":"Good luck this week on proposing for Stage 2!","msgtype":"m.text"},"ts":1679445122818,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$AdhWFPmEgwRAIoSxF99ccKYIu-267vz_PPzYGjLEoVE"},
{"content":{"body":"So, here's a question. fetch has the `Response` object. This can be created using a `ReadableStream` object, which uses a number of internal promises to manage state. In workerd, we have a method that handles received requests and can return a `Response` object specifying the response to an http request. So, imagine a case like:\n\n```\nconst als = new AsyncLocalStorage(); // or AsyncContext\nexport default {\n  async fetch(req) {\n    const readable = als.run('abc', () => new ReadableStream({\n      pull(c) {\n        c.error(new Error(`boom ${als.getStore()}`));\n      }\n    }));\n    return als.run(123, () => new Response(readable));\n  }\n}\n```\n\nThe actual pipe from the readable happens by the code that calls the `fetch` function handler here, which is running in the root async context where `als` store will be `undefined`.\n\nWhat value would you expect `als.getStore()` to return when the error is constructed?","format":"org.matrix.custom.html","formatted_body":"<p>So, here's a question. fetch has the <code>Response</code> object. This can be created using a <code>ReadableStream</code> object, which uses a number of internal promises to manage state. In workerd, we have a method that handles received requests and can return a <code>Response</code> object specifying the response to an http request. So, imagine a case like:</p>\n<pre><code>const als = new AsyncLocalStorage(); // or AsyncContext\nexport default {\n  async fetch(req) {\n    const readable = als.run('abc', () =&gt; new ReadableStream({\n      pull(c) {\n        c.error(new Error(`boom ${als.getStore()}`));\n      }\n    }));\n    return als.run(123, () =&gt; new Response(readable));\n  }\n}\n</code></pre>\n<p>The actual pipe from the readable happens by the code that calls the <code>fetch</code> function handler here, which is running in the root async context where <code>als</code> store will be <code>undefined</code>.</p>\n<p>What value would you expect <code>als.getStore()</code> to return when the error is constructed?</p>\n","msgtype":"m.text"},"ts":1679498186038,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$nQAhTeyRKcK0qB6P707zCamdJ_dA9CkWMCRsdnEidok"},
{"content":{"body":"Keep in mind that the pull function can be called at different times depending on the value of the `highWaterMark` configured for the readablestream","format":"org.matrix.custom.html","formatted_body":"Keep in mind that the pull function can be called at different times depending on the value of the <code>highWaterMark</code> configured for the readablestream","msgtype":"m.text"},"ts":1679498257762,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$UL02gc_alRTatl78cGHpchLwj1OwM-euX3oHWZwC8Ro"},
{"content":{"body":"specifically, pull might be called when the ReadableStream is created, and any time after while it is being read","msgtype":"m.text"},"ts":1679498598220,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$xB-zJT3Ozw-gKGyyeBEuCuvdZbCAfxeiLMcXDeeyuXc"},
{"content":{"body":"I don't have a good answer. Just from the use case I recognize that it must be one of the two (and not `undefined` just because the `Response` object is leaked out of the fetch), but I don't have a good idea of which one of these contexts is the \"registration\" context","format":"org.matrix.custom.html","formatted_body":"I don't have a good answer. Just from the use case I recognize that it must be one of the two (and not <code>undefined</code> just because the <code>Response</code> object is leaked out of the fetch), but I don't have a good idea of which one of these contexts is the &quot;registration&quot; context","msgtype":"m.text"},"ts":1679500335163,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$S7IWXre8FNFlTbas966Qbs-7OktIL5uL_qGe9-_3MWs"},
{"content":{"body":"In my experience, the contexts are the same. I create the readable and the response in the same overall context, so the distinction doesn't matter","msgtype":"m.text"},"ts":1679500439839,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$MjYLOfQmdeGFX5V4Eesht0qdblGHZlnvdIPcGdOExR4"},
{"content":{"body":"That's fair. What I suspect is that for web apis, once AsyncContext is integrated, we'll need a way of identifying in webidl which types are expected to capture and propagate the async context","msgtype":"m.text"},"ts":1679500562429,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$u07eXgiRQmUPLNc1X4RyRLdAy6MYIWjr-5zwUNocJ10"},
{"content":{"body":"It's going to be needed regardless of where AsyncContext ultimately gets defined (tc39 or whatwg, etc)","msgtype":"m.text"},"ts":1679500598210,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$juKuSHIQdPNIa6cQRkqXJseWPQF6dbWAOhxHBSKeEL0"},
{"content":{"body":"Here’s my take: if/once `AsyncContext` becomes an official part of the language, utilities like `ReadableStream` could (backwards compatibly!) begin to support a contract whereby the context in effect at `ReadableStream` construction time is automatically restored each time `pull` and other callbacks are called","format":"org.matrix.custom.html","formatted_body":"Here’s my take: if/once <code>AsyncContext</code> becomes an official part of the language, utilities like <code>ReadableStream</code> could (backwards compatibly!) begin to support a contract whereby the context in effect at <code>ReadableStream</code> construction time is automatically restored each time <code>pull</code> and other callbacks are called","msgtype":"m.text"},"ts":1679507460200,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$c17C-uwu2VKmB0zFkEQ2JzPt93ii5qW4AC3bYoofR8g"},
{"content":{"body":"In the meantime (potentially for a long time), you might need to take matters into your own hands using `AsyncContext.wrap`:","format":"org.matrix.custom.html","formatted_body":"In the meantime (potentially for a long time), you might need to take matters into your own hands using <code>AsyncContext.wrap</code>:","msgtype":"m.text"},"ts":1679507480626,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$7tYVfUfI3TxKGGBa9iD9CLHasx8WMLi7wbL-yCSE1qc"},
{"content":{"body":"``` export default {\n  async fetch(req) {\n    const readable = als.run('abc', () => new ReadableStream({\n      pull: AsyncContext.wrap((c) => {\n        c.error(new Error(`boom ${als.getStore()}`));\n      }),\n    }));\n    return als.run(123, () => new Response(readable));\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-export\">  async fetch(req) {\n    const readable = als.run('abc', () =&gt; new ReadableStream({\n      pull: AsyncContext.wrap((c) =&gt; {\n        c.error(new Error(`boom ${als.getStore()}`));\n      }),\n    }));\n    return als.run(123, () =&gt; new Response(readable));\n  }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1679507486955,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$M4hEKna7i3oL32D7W4VkLvoGANu49rJNYs6sdFODCR8"},
{"content":{"body":"With this code, the `als` with `abc` is bound to the `pull` callback function so `als.getStore()` can return `abc` instead of undefined for the Error","format":"org.matrix.custom.html","formatted_body":"With this code, the <code>als</code> with <code>abc</code> is bound to the <code>pull</code> callback function so <code>als.getStore()</code> can return <code>abc</code> instead of undefined for the Error","msgtype":"m.text"},"ts":1679507511207,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$MssD7dKFhe6G7tr0aHx1wskf9F7uYf-mRLIiAUDeE5w"},
{"content":{"body":"Of course, this `AsyncContext.wrap` binding means any other `AsyncContext` values coming from the caller of the `pull` callback (some code in the `ReadableStream` implementation) will now be ignored, but that’s probably safe as long as you don’t expect/care `ReadableStream` to be manipulating `AsyncContext`","format":"org.matrix.custom.html","formatted_body":"Of course, this <code>AsyncContext.wrap</code> binding means any other <code>AsyncContext</code> values coming from the caller of the <code>pull</code> callback (some code in the <code>ReadableStream</code> implementation) will now be ignored, but that’s probably safe as long as you don’t expect/care <code>ReadableStream</code> to be manipulating <code>AsyncContext</code>","msgtype":"m.text"},"ts":1679507541500,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$bewngEyFgMIygnR8Be0V15kBIJ21F7VTbayuYi7Ib0g"},
{"content":{"body":" * Of course, this `AsyncContext.wrap` binding means any other `AsyncContext` values coming from the caller of the `pull` callback (some code in the `ReadableStream` implementation) will now be ignored, but that’s probably safe as long as you don’t expect `ReadableStream` to be manipulating `AsyncContext`","format":"org.matrix.custom.html","formatted_body":" * Of course, this <code>AsyncContext.wrap</code> binding means any other <code>AsyncContext</code> values coming from the caller of the <code>pull</code> callback (some code in the <code>ReadableStream</code> implementation) will now be ignored, but that’s probably safe as long as you don’t expect <code>ReadableStream</code> to be manipulating <code>AsyncContext</code>","m.new_content":{"body":"Of course, this `AsyncContext.wrap` binding means any other `AsyncContext` values coming from the caller of the `pull` callback (some code in the `ReadableStream` implementation) will now be ignored, but that’s probably safe as long as you don’t expect `ReadableStream` to be manipulating `AsyncContext`","format":"org.matrix.custom.html","formatted_body":"Of course, this <code>AsyncContext.wrap</code> binding means any other <code>AsyncContext</code> values coming from the caller of the <code>pull</code> callback (some code in the <code>ReadableStream</code> implementation) will now be ignored, but that’s probably safe as long as you don’t expect <code>ReadableStream</code> to be manipulating <code>AsyncContext</code>","msgtype":"m.text"},"m.relates_to":{"event_id":"$bewngEyFgMIygnR8Be0V15kBIJ21F7VTbayuYi7Ib0g","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1679507545332,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$f94Z9p8lxp956c8N1yRfZjWkjjFBd96JLKged8TorgI"},
{"content":{"body":"Is that helpful?","msgtype":"m.text"},"ts":1679507563903,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$Gffh440hiLt_TPuwpwFGqNC568QpIRcWJHSQepxFOCE"}
]