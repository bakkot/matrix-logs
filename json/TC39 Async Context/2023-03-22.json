[
{"content":{"body":"I had some quick chats today at TC39 with dminor and bakkot, everyone seemed cautiously positive though a little uncertain about use cases. I am optimistic about the presentation but we might consider adding bonus slides that go in more depth there (eg just taking what was in legendecas’s webperf wg slides)","msgtype":"m.text"},"ts":1679445053389,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Yxvfy8w3YSGiIc_DdrS6kGxHpvJPwjInSAG_covkMpI"},
{"content":{"body":"I didn’t get the feeling that the complexity around what things are wrapped was considered a very bad issue for either (just something to work out) but maybe I misunderstood them","msgtype":"m.text"},"ts":1679445110503,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$rQZ4SGbPdgLagMyfPgeA9AtEG-GQaEK081ULM0xmdmE"},
{"content":{"body":"Good luck this week on proposing for Stage 2!","msgtype":"m.text"},"ts":1679445122818,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$AdhWFPmEgwRAIoSxF99ccKYIu-267vz_PPzYGjLEoVE"},
{"content":{"body":"So, here's a question. fetch has the `Response` object. This can be created using a `ReadableStream` object, which uses a number of internal promises to manage state. In workerd, we have a method that handles received requests and can return a `Response` object specifying the response to an http request. So, imagine a case like:\n\n```\nconst als = new AsyncLocalStorage(); // or AsyncContext\nexport default {\n  async fetch(req) {\n    const readable = als.run('abc', () => new ReadableStream({\n      pull(c) {\n        c.error(new Error(`boom ${als.getStore()}`));\n      }\n    }));\n    return als.run(123, () => new Response(readable));\n  }\n}\n```\n\nThe actual pipe from the readable happens by the code that calls the `fetch` function handler here, which is running in the root async context where `als` store will be `undefined`.\n\nWhat value would you expect `als.getStore()` to return when the error is constructed?","format":"org.matrix.custom.html","formatted_body":"<p>So, here's a question. fetch has the <code>Response</code> object. This can be created using a <code>ReadableStream</code> object, which uses a number of internal promises to manage state. In workerd, we have a method that handles received requests and can return a <code>Response</code> object specifying the response to an http request. So, imagine a case like:</p>\n<pre><code>const als = new AsyncLocalStorage(); // or AsyncContext\nexport default {\n  async fetch(req) {\n    const readable = als.run('abc', () =&gt; new ReadableStream({\n      pull(c) {\n        c.error(new Error(`boom ${als.getStore()}`));\n      }\n    }));\n    return als.run(123, () =&gt; new Response(readable));\n  }\n}\n</code></pre>\n<p>The actual pipe from the readable happens by the code that calls the <code>fetch</code> function handler here, which is running in the root async context where <code>als</code> store will be <code>undefined</code>.</p>\n<p>What value would you expect <code>als.getStore()</code> to return when the error is constructed?</p>\n","msgtype":"m.text"},"ts":1679498186038,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$nQAhTeyRKcK0qB6P707zCamdJ_dA9CkWMCRsdnEidok"},
{"content":{"body":"Keep in mind that the pull function can be called at different times depending on the value of the `highWaterMark` configured for the readablestream","format":"org.matrix.custom.html","formatted_body":"Keep in mind that the pull function can be called at different times depending on the value of the <code>highWaterMark</code> configured for the readablestream","msgtype":"m.text"},"ts":1679498257762,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$UL02gc_alRTatl78cGHpchLwj1OwM-euX3oHWZwC8Ro"},
{"content":{"body":"specifically, pull might be called when the ReadableStream is created, and any time after while it is being read","msgtype":"m.text"},"ts":1679498598220,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$xB-zJT3Ozw-gKGyyeBEuCuvdZbCAfxeiLMcXDeeyuXc"},
{"content":{"body":"I don't have a good answer. Just from the use case I recognize that it must be one of the two (and not `undefined` just because the `Response` object is leaked out of the fetch), but I don't have a good idea of which one of these contexts is the \"registration\" context","format":"org.matrix.custom.html","formatted_body":"I don't have a good answer. Just from the use case I recognize that it must be one of the two (and not <code>undefined</code> just because the <code>Response</code> object is leaked out of the fetch), but I don't have a good idea of which one of these contexts is the &quot;registration&quot; context","msgtype":"m.text"},"ts":1679500335163,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$S7IWXre8FNFlTbas966Qbs-7OktIL5uL_qGe9-_3MWs"},
{"content":{"body":"In my experience, the contexts are the same. I create the readable and the response in the same overall context, so the distinction doesn't matter","msgtype":"m.text"},"ts":1679500439839,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$MjYLOfQmdeGFX5V4Eesht0qdblGHZlnvdIPcGdOExR4"},
{"content":{"body":"That's fair. What I suspect is that for web apis, once AsyncContext is integrated, we'll need a way of identifying in webidl which types are expected to capture and propagate the async context","msgtype":"m.text"},"ts":1679500562429,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$u07eXgiRQmUPLNc1X4RyRLdAy6MYIWjr-5zwUNocJ10"},
{"content":{"body":"It's going to be needed regardless of where AsyncContext ultimately gets defined (tc39 or whatwg, etc)","msgtype":"m.text"},"ts":1679500598210,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$juKuSHIQdPNIa6cQRkqXJseWPQF6dbWAOhxHBSKeEL0"},
{"content":{"body":"Here’s my take: if/once `AsyncContext` becomes an official part of the language, utilities like `ReadableStream` could (backwards compatibly!) begin to support a contract whereby the context in effect at `ReadableStream` construction time is automatically restored each time `pull` and other callbacks are called","format":"org.matrix.custom.html","formatted_body":"Here’s my take: if/once <code>AsyncContext</code> becomes an official part of the language, utilities like <code>ReadableStream</code> could (backwards compatibly!) begin to support a contract whereby the context in effect at <code>ReadableStream</code> construction time is automatically restored each time <code>pull</code> and other callbacks are called","msgtype":"m.text"},"ts":1679507460200,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$c17C-uwu2VKmB0zFkEQ2JzPt93ii5qW4AC3bYoofR8g"},
{"content":{"body":"In the meantime (potentially for a long time), you might need to take matters into your own hands using `AsyncContext.wrap`:","format":"org.matrix.custom.html","formatted_body":"In the meantime (potentially for a long time), you might need to take matters into your own hands using <code>AsyncContext.wrap</code>:","msgtype":"m.text"},"ts":1679507480626,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$7tYVfUfI3TxKGGBa9iD9CLHasx8WMLi7wbL-yCSE1qc"},
{"content":{"body":"``` export default {\n  async fetch(req) {\n    const readable = als.run('abc', () => new ReadableStream({\n      pull: AsyncContext.wrap((c) => {\n        c.error(new Error(`boom ${als.getStore()}`));\n      }),\n    }));\n    return als.run(123, () => new Response(readable));\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-export\">  async fetch(req) {\n    const readable = als.run('abc', () =&gt; new ReadableStream({\n      pull: AsyncContext.wrap((c) =&gt; {\n        c.error(new Error(`boom ${als.getStore()}`));\n      }),\n    }));\n    return als.run(123, () =&gt; new Response(readable));\n  }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1679507486955,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$M4hEKna7i3oL32D7W4VkLvoGANu49rJNYs6sdFODCR8"},
{"content":{"body":"With this code, the `als` with `abc` is bound to the `pull` callback function so `als.getStore()` can return `abc` instead of undefined for the Error","format":"org.matrix.custom.html","formatted_body":"With this code, the <code>als</code> with <code>abc</code> is bound to the <code>pull</code> callback function so <code>als.getStore()</code> can return <code>abc</code> instead of undefined for the Error","msgtype":"m.text"},"ts":1679507511207,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$MssD7dKFhe6G7tr0aHx1wskf9F7uYf-mRLIiAUDeE5w"},
{"content":{"body":"Of course, this `AsyncContext.wrap` binding means any other `AsyncContext` values coming from the caller of the `pull` callback (some code in the `ReadableStream` implementation) will now be ignored, but that’s probably safe as long as you don’t expect/care `ReadableStream` to be manipulating `AsyncContext`","format":"org.matrix.custom.html","formatted_body":"Of course, this <code>AsyncContext.wrap</code> binding means any other <code>AsyncContext</code> values coming from the caller of the <code>pull</code> callback (some code in the <code>ReadableStream</code> implementation) will now be ignored, but that’s probably safe as long as you don’t expect/care <code>ReadableStream</code> to be manipulating <code>AsyncContext</code>","msgtype":"m.text"},"ts":1679507541500,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$bewngEyFgMIygnR8Be0V15kBIJ21F7VTbayuYi7Ib0g"},
{"content":{"body":" * Of course, this `AsyncContext.wrap` binding means any other `AsyncContext` values coming from the caller of the `pull` callback (some code in the `ReadableStream` implementation) will now be ignored, but that’s probably safe as long as you don’t expect `ReadableStream` to be manipulating `AsyncContext`","format":"org.matrix.custom.html","formatted_body":" * Of course, this <code>AsyncContext.wrap</code> binding means any other <code>AsyncContext</code> values coming from the caller of the <code>pull</code> callback (some code in the <code>ReadableStream</code> implementation) will now be ignored, but that’s probably safe as long as you don’t expect <code>ReadableStream</code> to be manipulating <code>AsyncContext</code>","m.new_content":{"body":"Of course, this `AsyncContext.wrap` binding means any other `AsyncContext` values coming from the caller of the `pull` callback (some code in the `ReadableStream` implementation) will now be ignored, but that’s probably safe as long as you don’t expect `ReadableStream` to be manipulating `AsyncContext`","format":"org.matrix.custom.html","formatted_body":"Of course, this <code>AsyncContext.wrap</code> binding means any other <code>AsyncContext</code> values coming from the caller of the <code>pull</code> callback (some code in the <code>ReadableStream</code> implementation) will now be ignored, but that’s probably safe as long as you don’t expect <code>ReadableStream</code> to be manipulating <code>AsyncContext</code>","msgtype":"m.text"},"m.relates_to":{"event_id":"$bewngEyFgMIygnR8Be0V15kBIJ21F7VTbayuYi7Ib0g","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1679507545332,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$f94Z9p8lxp956c8N1yRfZjWkjjFBd96JLKged8TorgI"},
{"content":{"body":"Is that helpful?","msgtype":"m.text"},"ts":1679507563903,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$Gffh440hiLt_TPuwpwFGqNC568QpIRcWJHSQepxFOCE"},
{"content":{"body":"Unfortunately it doesn't exactly help. If I call c.error() within the pull, and there's a queued read, that queued read is likely not necessarily going to be rejected immediately when the `c.error` is called. It might end up getting processed from a different async scope, which means if it results in an unhandledrejection event, it will propagate the wrong context","format":"org.matrix.custom.html","formatted_body":"Unfortunately it doesn't exactly help. If I call c.error() within the pull, and there's a queued read, that queued read is likely not necessarily going to be rejected immediately when the <code>c.error</code> is called. It might end up getting processed from a different async scope, which means if it results in an unhandledrejection event, it will propagate the wrong context","msgtype":"m.text"},"ts":1679507727151,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$fFdyrsL_q83KNxKhlwkg_ADyQX7SfqJuhxuDl8CLcYc"},
{"content":{"body":"going to have to play with this case a bit more to really tease out all the various cases","msgtype":"m.text"},"ts":1679507782432,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$wNtlcfJbDCHhFpdfplxl_v52JNmbeCTtI-3qUwayfi8"},
{"content":{"body":"There are a variety of situations that make this complicated.","msgtype":"m.text"},"ts":1679507830760,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$NNmUchMl3CnipeqWzxlonTjo5DBLxRtFED5EQTTEdTA"},
{"content":{"body":"whatever code is scheduling/queueing those read jobs needs to be using something like `AsyncContext.wrap` to preserve the context from one job to the next, I think?","format":"org.matrix.custom.html","formatted_body":"whatever code is scheduling/queueing those read jobs needs to be using something like <code>AsyncContext.wrap</code> to preserve the context from one job to the next, I think?","msgtype":"m.text"},"ts":1679507869983,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$L_GFdhcWoW458MBNtlAB8zhaWSYvNmGxlCVFACAqO7c"},
{"content":{"body":"are you trying to get this to work without modifying library code that does this kind of scheduling? (seems hard)","msgtype":"m.text"},"ts":1679507884171,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$tgqVbC_9Hra3RT0S6bv6Jlw4IcRv5Bg1Pl77WtoMNSY"},
{"content":{"body":"for instance, I may have multiple reads queued, all called from separate async contexts, but a mismatched number of pulls, where one pull triggered by one context fulfills multiple reads","msgtype":"m.text"},"ts":1679507886394,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$wYhh2LpGi1BdRNHVHzJcSfzpIoWe4bNWyoWPM9gw6Bg"},
{"content":{"body":"yeah, we're not in control of the ReadableStream implementations","msgtype":"m.text"},"ts":1679507902268,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$qErhjgKMSoL6YDqcY2Cdhw3pwbgPvxZ-G-vMhzmS0m0"},
{"content":{"body":"ok I think I see the rub you were pointing out","msgtype":"m.text"},"ts":1679507927300,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$taF6TL-7OOPDqvJY_QlClE7EfRFMVEYm3qkTb3RQT_Y"},
{"content":{"body":"a single invocation of `pull` can represent multiple different contextual branches","format":"org.matrix.custom.html","formatted_body":"a single invocation of <code>pull</code> can represent multiple different contextual branches","msgtype":"m.text"},"ts":1679508006090,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$anZ0I9Vu8-npHqXdThYRw54-obC9MKXvWhT3jPw0Cao"},
{"content":{"body":" * a single invocation of `pull` can handle/inherit multiple different contextual branches","format":"org.matrix.custom.html","formatted_body":" * a single invocation of <code>pull</code> can handle/inherit multiple different contextual branches","m.new_content":{"body":"a single invocation of `pull` can handle/inherit multiple different contextual branches","format":"org.matrix.custom.html","formatted_body":"a single invocation of <code>pull</code> can handle/inherit multiple different contextual branches","msgtype":"m.text"},"m.relates_to":{"event_id":"$anZ0I9Vu8-npHqXdThYRw54-obC9MKXvWhT3jPw0Cao","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1679508040716,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$NwlEZGQY_xWItu9mhi0g3iYZ46u0OMLxgv6r-ZtAEIc"},
{"content":{"body":"do you think the solution is somehow to merge the branches into one context, or to keep the different branches distinct so `pull` can create the errors with their correct (not merged) contexts?","format":"org.matrix.custom.html","formatted_body":"do you think the solution is somehow to merge the branches into one context, or to keep the different branches distinct so <code>pull</code> can create the errors with their correct (not merged) contexts?","msgtype":"m.text"},"ts":1679508146654,"senderName":"Ben Newman (Apollo, @benjamn on GH)","senderId":"@benjamn:matrix.org","id":"$PBe6OUvI7_FXOpfoGGbM0wMp_4hKKrqaZ-A0zRusMCs"},
{"content":{"body":"> <@jasnell:matrix.org> That's fair. What I suspect is that for web apis, once AsyncContext is integrated, we'll need a way of identifying in webidl which types are expected to capture and propagate the async context\n\nThis differs from how Yoav ended up implementing a similar feature in Blink. It turned out that the WebIDL layer approach was too slow.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$u07eXgiRQmUPLNc1X4RyRLdAy6MYIWjr-5zwUNocJ10?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jasnell:matrix.org\">@jasnell:matrix.org</a><br>That&#39;s fair. What I suspect is that for web apis, once AsyncContext is integrated, we&#39;ll need a way of identifying in webidl which types are expected to capture and propagate the async context</blockquote></mx-reply>This differs from how Yoav ended up implementing a similar feature in Blink. It turned out that the WebIDL layer approach was too slow.","m.relates_to":{"m.in_reply_to":{"event_id":"$u07eXgiRQmUPLNc1X4RyRLdAy6MYIWjr-5zwUNocJ10"}},"msgtype":"m.text"},"ts":1679508197428,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$EVovayXPxuTwbosSmhjVP9fQNbT_Jh0qp7vvsgcC4C4"},
{"content":{"body":"instead, it's more like, you propagate the context when queueing a task","msgtype":"m.text"},"ts":1679508212329,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$EFAqs0NgdJQwY7uGfnt6hQm5fwgZi6UHo9lh4K3xrgw"}
]