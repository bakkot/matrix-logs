[
{"content":{"body":"> <@stephenbelanger:matrix.org> That's not necessarily true with implicit scopes. If any function call is made an implicit scope then breaking out would be impossible.\n\nMy understanding is that this would add an unacceptable amount of overhead to _every_ function call, rather than just async functions, so it's basically a non-starter.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$og34FgWr-EciHnQsj2scF2NsXz2QK2SUv7Xbq_-Ih8Y?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>That's not necessarily true with implicit scopes. If any function call is made an implicit scope then breaking out would be impossible.</blockquote></mx-reply>My understanding is that this would add an unacceptable amount of overhead to <em>every</em> function call, rather than just async functions, so it's basically a non-starter.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@devsnek:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$og34FgWr-EciHnQsj2scF2NsXz2QK2SUv7Xbq_-Ih8Y"}},"msgtype":"m.text"},"ts":1720570699803,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$g7__ciXOzUN743m3-QquguVi3dA9Od3KH2ZHjJCAing"},
{"content":{"body":"(but I could be wrong about that)","m.mentions":{},"msgtype":"m.text"},"ts":1720570713575,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$esbW2_Ha2VGeoJjDv8QyIRS2htm5-u-QotqSFvU_J0U"},
{"content":{"body":"i'm a little more confident that it's an unacceptable overhead for polyfilling/transpilation","m.mentions":{},"msgtype":"m.text"},"ts":1720570800245,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$KaGRE5OsIcr-uNaN9-KWn1zQZ06YZk4HOIacYSyttPQ"},
{"content":{"body":"(which, admittedly isn't a reason not to do it... but it would probably cause us to give up on using AsyncContext any time in the foreseeable future)","m.mentions":{},"msgtype":"m.text"},"ts":1720570858956,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$BbwYUzmF0axfIUJ34Cl2dHV6Tn05PuAyEqkpudTVM-4"},
{"content":{"body":"It actually shouldn't because then your \"scope\" can be held as a stack variable and just rely on stack semantics to manage where sets/gets route to.","m.mentions":{},"msgtype":"m.text"},"ts":1720570893006,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Fn0LA4P-sQF2uQwKIvjQGYWGv4DRjAXo6s8Y1_mnrJY"},
{"content":{"body":"It's actually _faster_ to put it in the function header as otherwise you're _always_ doing heap operations whereas treating it as a stack variable lets you both locate the stack slot to modify it and also do captures on async tasks or nested scopes as stack operations.","format":"org.matrix.custom.html","formatted_body":"It's actually <em>faster</em> to put it in the function header as otherwise you're <em>always</em> doing heap operations whereas treating it as a stack variable lets you both locate the stack slot to modify it and also do captures on async tasks or nested scopes as stack operations.","m.mentions":{},"msgtype":"m.text"},"ts":1720571076004,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$IAD2__7_ML5P6J42AXri6qgqSqYFqOaX5rwmRoNtUzE"},
{"content":{"body":"polyfilling would require adding wrapping every function body (or every function call), which is just too expensive.  Also, this wouldn't help with the `beforeEach` situation, nor would it help achieve flow-through semantics.  So it's just a (dubious) ergonomics win.","format":"org.matrix.custom.html","formatted_body":"polyfilling would require adding wrapping every function body (or every function call), which is just too expensive.  Also, this wouldn't help with the <code>beforeEach</code> situation, nor would it help achieve flow-through semantics.  So it's just a (dubious) ergonomics win.","m.mentions":{},"msgtype":"m.text"},"ts":1720571459735,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$8uD2E41S6Fz4DgzUK1Ev7l2LhzeihR0c8G5c5LggtBY"},
{"content":{"body":"It doesn't help `beforeEach` on its _own_. It _does_ help with flow-through semantics though.","format":"org.matrix.custom.html","formatted_body":"It doesn't help <code>beforeEach</code> on its <em>own</em>. It <em>does</em> help with flow-through semantics though.","m.mentions":{},"msgtype":"m.text"},"ts":1720575913863,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$x-oeWGhQFb28gts-yyINJpAxhZ_4iyIf7iD5KZDgqeo"},
{"content":{"body":"> <@stephenbelanger:matrix.org> It doesn't help `beforeEach` on its _own_. It _does_ help with flow-through semantics though.\n\nHow? If the child function binds its own scope, then the calling scope won't observe any changes to it.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$x-oeWGhQFb28gts-yyINJpAxhZ_4iyIf7iD5KZDgqeo?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>It doesn't help <code>beforeEach</code> on its <em>own</em>. It <em>does</em> help with flow-through semantics though.</blockquote></mx-reply>How? If the child function binds its own scope, then the calling scope won't observe any changes to it.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$x-oeWGhQFb28gts-yyINJpAxhZ_4iyIf7iD5KZDgqeo"}},"msgtype":"m.text"},"ts":1720575969368,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$dHauYdRjtkqbfrwwBYx29A_OnDCtwOqmU4AGzwoLi5s"},
{"content":{"body":"By linking the scopes to propagate between them. That's the whole _point_ of raising out the scopes like that--you have both something you can propagate _from_ but also something to propagate _to_ using the same construct.","format":"org.matrix.custom.html","formatted_body":"By linking the scopes to propagate between them. That's the whole <em>point</em> of raising out the scopes like that--you have both something you can propagate <em>from</em> but also something to propagate <em>to</em> using the same construct.","m.mentions":{},"msgtype":"m.text"},"ts":1720576044441,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$b8IUGOeapVkg8FJyi7E0GZqoEvnt_gdjaasdSF6eZoA"},
{"content":{"body":"It's not exactly a boundary around the _function_ though, it's a boundary around a sync segment of code. As with async/await boundaries, you need to produce a graph around _calls_ just as you would with _awaits_.","format":"org.matrix.custom.html","formatted_body":"It's not exactly a boundary around the <em>function</em> though, it's a boundary around a sync segment of code. As with async/await boundaries, you need to produce a graph around <em>calls</em> just as you would with <em>awaits</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1720576112712,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$erYuJRgj4yb0hdYgmRDwFJQ-NEfDtYNLljrxOysX7Yw"},
{"content":{"body":"Which, again, _also_ benefits from happening on the stack.","format":"org.matrix.custom.html","formatted_body":"Which, again, <em>also</em> benefits from happening on the stack.","m.mentions":{},"msgtype":"m.text"},"ts":1720576144266,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$mJBWq0shbdr7-gfYyDkLO-of0RyhsD8PjfJnuf7h1qI"},
{"content":{"body":"When a call would be made, you can capture the current state, inside the function you can continue that context. On exiting a function you can allow the context to flow out to the caller and then the caller stack can decide if it wants to retain that context or restore what it captured before the call.","m.mentions":{},"msgtype":"m.text"},"ts":1720576234982,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ORlOddXWnqtJuTs5RaXTX5hpHmkr0lZt5LZFgOzKCmY"},
{"content":{"body":"And you can do all that with the stack frames.","m.mentions":{},"msgtype":"m.text"},"ts":1720576258798,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kE1csuoBIZeKHXBOIIvB9pxfWFPhwnMWlEZ-UUGxfYM"},
{"content":{"body":"how is that decision expressed?","m.mentions":{},"msgtype":"m.text"},"ts":1720576282283,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$hy-Nw2gW--FlAiQRZyeWK3rODvIZTFWTLN1ZSEN3Utg"},
{"content":{"body":"We can generate additional code around any `call` instruction to do the capture before and after it can decide what to do with the context value as it is at the time of that call exiting--that could be to _keep_ that value if we want flow-through, or it could be to grab the reference out of the stack from _before_ the call and restore that.","format":"org.matrix.custom.html","formatted_body":"We can generate additional code around any <code>call</code> instruction to do the capture before and after it can decide what to do with the context value as it is at the time of that call exiting--that could be to <em>keep</em> that value if we want flow-through, or it could be to grab the reference out of the stack from <em>before</em> the call and restore that.","m.mentions":{},"msgtype":"m.text"},"ts":1720576387878,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$-4Lke6LA2Y00mevQ0sig7E2eMoHcXg-3p4e6OOF-EMw"},
{"content":{"body":"To be clear, I mean putting all that in the generated bytecode, not user-controllable code.","m.mentions":{},"msgtype":"m.text"},"ts":1720576414158,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$KWrt3nlEUeDaVpXBt6qHPjHmNLI8zQm_oLxn2nddPE4"},
{"content":{"body":"What I'm unclear on is _what_ determines whether it flows through or restores?  Is it something about the call?  Something about the variable?","format":"org.matrix.custom.html","formatted_body":"What I'm unclear on is <em>what</em> determines whether it flows through or restores?  Is it something about the call?  Something about the variable?","m.mentions":{},"msgtype":"m.text"},"ts":1720576463042,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$7VviYU9TqwzEv7d6O1cZyYHLXtOl7jDP6VteGP6JsEk"},
{"content":{"body":"A snapshot is stored in the captured before the call, and the current state just gets left as-is when the nested function exits. We can then send that current state to some API to tell it if we want to continue flowing that forward, and we can send the snapshot to another API for anything that wants to flow _around_. We can also have some logic to detect if there even _is_ any active stores to delete the code that does that unless there actually _is_ a store.","format":"org.matrix.custom.html","formatted_body":"A snapshot is stored in the captured before the call, and the current state just gets left as-is when the nested function exits. We can then send that current state to some API to tell it if we want to continue flowing that forward, and we can send the snapshot to another API for anything that wants to flow <em>around</em>. We can also have some logic to detect if there even <em>is</em> any active stores to delete the code that does that unless there actually <em>is</em> a store.","m.mentions":{},"msgtype":"m.text"},"ts":1720576609717,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$OEy4-AewLH9yFYN_zp6isa0cHtaY0yO46pgZGkD3rPM"},
{"content":{"body":"That's already done for PromiseHooks--it only injects the lifecycle event code if there's actually registered hooks.","m.mentions":{},"msgtype":"m.text"},"ts":1720576634514,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$0qd4LSNBPxuiCcbnWojd-Kylxz0ZNJpQaY9VKXQBZdk"}
]