[
{"content":{"body":"> <@stephenbelanger:matrix.org> That's not necessarily true with implicit scopes. If any function call is made an implicit scope then breaking out would be impossible.\n\nMy understanding is that this would add an unacceptable amount of overhead to _every_ function call, rather than just async functions, so it's basically a non-starter.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$og34FgWr-EciHnQsj2scF2NsXz2QK2SUv7Xbq_-Ih8Y?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>That's not necessarily true with implicit scopes. If any function call is made an implicit scope then breaking out would be impossible.</blockquote></mx-reply>My understanding is that this would add an unacceptable amount of overhead to <em>every</em> function call, rather than just async functions, so it's basically a non-starter.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@devsnek:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$og34FgWr-EciHnQsj2scF2NsXz2QK2SUv7Xbq_-Ih8Y"}},"msgtype":"m.text"},"ts":1720570699803,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$g7__ciXOzUN743m3-QquguVi3dA9Od3KH2ZHjJCAing"},
{"content":{"body":"(but I could be wrong about that)","m.mentions":{},"msgtype":"m.text"},"ts":1720570713575,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$esbW2_Ha2VGeoJjDv8QyIRS2htm5-u-QotqSFvU_J0U"},
{"content":{"body":"i'm a little more confident that it's an unacceptable overhead for polyfilling/transpilation","m.mentions":{},"msgtype":"m.text"},"ts":1720570800245,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$KaGRE5OsIcr-uNaN9-KWn1zQZ06YZk4HOIacYSyttPQ"},
{"content":{"body":"(which, admittedly isn't a reason not to do it... but it would probably cause us to give up on using AsyncContext any time in the foreseeable future)","m.mentions":{},"msgtype":"m.text"},"ts":1720570858956,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$BbwYUzmF0axfIUJ34Cl2dHV6Tn05PuAyEqkpudTVM-4"},
{"content":{"body":"It actually shouldn't because then your \"scope\" can be held as a stack variable and just rely on stack semantics to manage where sets/gets route to.","m.mentions":{},"msgtype":"m.text"},"ts":1720570893006,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Fn0LA4P-sQF2uQwKIvjQGYWGv4DRjAXo6s8Y1_mnrJY"},
{"content":{"body":"It's actually _faster_ to put it in the function header as otherwise you're _always_ doing heap operations whereas treating it as a stack variable lets you both locate the stack slot to modify it and also do captures on async tasks or nested scopes as stack operations.","format":"org.matrix.custom.html","formatted_body":"It's actually <em>faster</em> to put it in the function header as otherwise you're <em>always</em> doing heap operations whereas treating it as a stack variable lets you both locate the stack slot to modify it and also do captures on async tasks or nested scopes as stack operations.","m.mentions":{},"msgtype":"m.text"},"ts":1720571076004,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$IAD2__7_ML5P6J42AXri6qgqSqYFqOaX5rwmRoNtUzE"},
{"content":{"body":"polyfilling would require adding wrapping every function body (or every function call), which is just too expensive.  Also, this wouldn't help with the `beforeEach` situation, nor would it help achieve flow-through semantics.  So it's just a (dubious) ergonomics win.","format":"org.matrix.custom.html","formatted_body":"polyfilling would require adding wrapping every function body (or every function call), which is just too expensive.  Also, this wouldn't help with the <code>beforeEach</code> situation, nor would it help achieve flow-through semantics.  So it's just a (dubious) ergonomics win.","m.mentions":{},"msgtype":"m.text"},"ts":1720571459735,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$8uD2E41S6Fz4DgzUK1Ev7l2LhzeihR0c8G5c5LggtBY"},
{"content":{"body":"It doesn't help `beforeEach` on its _own_. It _does_ help with flow-through semantics though.","format":"org.matrix.custom.html","formatted_body":"It doesn't help <code>beforeEach</code> on its <em>own</em>. It <em>does</em> help with flow-through semantics though.","m.mentions":{},"msgtype":"m.text"},"ts":1720575913863,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$x-oeWGhQFb28gts-yyINJpAxhZ_4iyIf7iD5KZDgqeo"},
{"content":{"body":"> <@stephenbelanger:matrix.org> It doesn't help `beforeEach` on its _own_. It _does_ help with flow-through semantics though.\n\nHow? If the child function binds its own scope, then the calling scope won't observe any changes to it.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$x-oeWGhQFb28gts-yyINJpAxhZ_4iyIf7iD5KZDgqeo?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>It doesn't help <code>beforeEach</code> on its <em>own</em>. It <em>does</em> help with flow-through semantics though.</blockquote></mx-reply>How? If the child function binds its own scope, then the calling scope won't observe any changes to it.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$x-oeWGhQFb28gts-yyINJpAxhZ_4iyIf7iD5KZDgqeo"}},"msgtype":"m.text"},"ts":1720575969368,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$dHauYdRjtkqbfrwwBYx29A_OnDCtwOqmU4AGzwoLi5s"},
{"content":{"body":"By linking the scopes to propagate between them. That's the whole _point_ of raising out the scopes like that--you have both something you can propagate _from_ but also something to propagate _to_ using the same construct.","format":"org.matrix.custom.html","formatted_body":"By linking the scopes to propagate between them. That's the whole <em>point</em> of raising out the scopes like that--you have both something you can propagate <em>from</em> but also something to propagate <em>to</em> using the same construct.","m.mentions":{},"msgtype":"m.text"},"ts":1720576044441,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$b8IUGOeapVkg8FJyi7E0GZqoEvnt_gdjaasdSF6eZoA"},
{"content":{"body":"It's not exactly a boundary around the _function_ though, it's a boundary around a sync segment of code. As with async/await boundaries, you need to produce a graph around _calls_ just as you would with _awaits_.","format":"org.matrix.custom.html","formatted_body":"It's not exactly a boundary around the <em>function</em> though, it's a boundary around a sync segment of code. As with async/await boundaries, you need to produce a graph around <em>calls</em> just as you would with <em>awaits</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1720576112712,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$erYuJRgj4yb0hdYgmRDwFJQ-NEfDtYNLljrxOysX7Yw"},
{"content":{"body":"Which, again, _also_ benefits from happening on the stack.","format":"org.matrix.custom.html","formatted_body":"Which, again, <em>also</em> benefits from happening on the stack.","m.mentions":{},"msgtype":"m.text"},"ts":1720576144266,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$mJBWq0shbdr7-gfYyDkLO-of0RyhsD8PjfJnuf7h1qI"},
{"content":{"body":"When a call would be made, you can capture the current state, inside the function you can continue that context. On exiting a function you can allow the context to flow out to the caller and then the caller stack can decide if it wants to retain that context or restore what it captured before the call.","m.mentions":{},"msgtype":"m.text"},"ts":1720576234982,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ORlOddXWnqtJuTs5RaXTX5hpHmkr0lZt5LZFgOzKCmY"},
{"content":{"body":"And you can do all that with the stack frames.","m.mentions":{},"msgtype":"m.text"},"ts":1720576258798,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kE1csuoBIZeKHXBOIIvB9pxfWFPhwnMWlEZ-UUGxfYM"},
{"content":{"body":"how is that decision expressed?","m.mentions":{},"msgtype":"m.text"},"ts":1720576282283,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$hy-Nw2gW--FlAiQRZyeWK3rODvIZTFWTLN1ZSEN3Utg"},
{"content":{"body":"We can generate additional code around any `call` instruction to do the capture before and after it can decide what to do with the context value as it is at the time of that call exiting--that could be to _keep_ that value if we want flow-through, or it could be to grab the reference out of the stack from _before_ the call and restore that.","format":"org.matrix.custom.html","formatted_body":"We can generate additional code around any <code>call</code> instruction to do the capture before and after it can decide what to do with the context value as it is at the time of that call exiting--that could be to <em>keep</em> that value if we want flow-through, or it could be to grab the reference out of the stack from <em>before</em> the call and restore that.","m.mentions":{},"msgtype":"m.text"},"ts":1720576387878,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$-4Lke6LA2Y00mevQ0sig7E2eMoHcXg-3p4e6OOF-EMw"},
{"content":{"body":"To be clear, I mean putting all that in the generated bytecode, not user-controllable code.","m.mentions":{},"msgtype":"m.text"},"ts":1720576414158,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$KWrt3nlEUeDaVpXBt6qHPjHmNLI8zQm_oLxn2nddPE4"},
{"content":{"body":"What I'm unclear on is _what_ determines whether it flows through or restores?  Is it something about the call?  Something about the variable?","format":"org.matrix.custom.html","formatted_body":"What I'm unclear on is <em>what</em> determines whether it flows through or restores?  Is it something about the call?  Something about the variable?","m.mentions":{},"msgtype":"m.text"},"ts":1720576463042,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$7VviYU9TqwzEv7d6O1cZyYHLXtOl7jDP6VteGP6JsEk"},
{"content":{"body":"A snapshot is stored in the captured before the call, and the current state just gets left as-is when the nested function exits. We can then send that current state to some API to tell it if we want to continue flowing that forward, and we can send the snapshot to another API for anything that wants to flow _around_. We can also have some logic to detect if there even _is_ any active stores to delete the code that does that unless there actually _is_ a store.","format":"org.matrix.custom.html","formatted_body":"A snapshot is stored in the captured before the call, and the current state just gets left as-is when the nested function exits. We can then send that current state to some API to tell it if we want to continue flowing that forward, and we can send the snapshot to another API for anything that wants to flow <em>around</em>. We can also have some logic to detect if there even <em>is</em> any active stores to delete the code that does that unless there actually <em>is</em> a store.","m.mentions":{},"msgtype":"m.text"},"ts":1720576609717,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$OEy4-AewLH9yFYN_zp6isa0cHtaY0yO46pgZGkD3rPM"},
{"content":{"body":"That's already done for PromiseHooks--it only injects the lifecycle event code if there's actually registered hooks.","m.mentions":{},"msgtype":"m.text"},"ts":1720576634514,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$0qd4LSNBPxuiCcbnWojd-Kylxz0ZNJpQaY9VKXQBZdk"},
{"content":{"body":"But _who_ decides?  Is it user code that runs somewhere (which is a non-starter performance-wise)?  I'm trying to understand concretely what you're suggesting, so I'll give a (wrong) concrete example.\n\n```\nconst result1 = await func1(param);\nconst result2 = await func2(result1);\n```\n\nSuppose the first one should flow through and the second call should flow around.  Then there's gotta be something different somewhere - can you give a mock-up of what that difference might look like?","format":"org.matrix.custom.html","formatted_body":"<p>But <em>who</em> decides?  Is it user code that runs somewhere (which is a non-starter performance-wise)?  I'm trying to understand concretely what you're suggesting, so I'll give a (wrong) concrete example.</p>\n<pre><code>const result1 = await func1(param);\nconst result2 = await func2(result1);\n</code></pre>\n<p>Suppose the first one should flow through and the second call should flow around.  Then there's gotta be something different somewhere - can you give a mock-up of what that difference might look like?</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1720577096009,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$JtPVagAz-Hic9wPwGMkVCSmRZx7XQWeNQ_5NfFZk_KM"},
{"content":{"body":"No, this is all purely runtime code. If we have two variables, as has been suggested, the snapshot and the current state can get passed to the machinery that handles the flows for those two variables and does whatever it needs to do--which is generally just a pointer-copy.","m.mentions":{},"msgtype":"m.text"},"ts":1720577173103,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$eZ3-5_AjqDYnBf7Pv8xK1cRiBj6t_1fecrSJZEH4exY"},
{"content":{"body":"This is all generated code I'm talking about. Nothing user-facing. We'd still be applying our own flow semantics, whatever those happen to be. Just we could do that on the stack generally, if we design the system carefully.","m.mentions":{},"msgtype":"m.text"},"ts":1720577270218,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$O4jSDdeNcc5mR1SCEcMbAc9raE6HrNdhqrXdipA9kGo"},
{"content":{"body":"ok so now I think you're saying there's two different types of variables that have built-in different propagation strategies.  IIUC merges need to be O(1) in the number of variables.","m.mentions":{},"msgtype":"m.text"},"ts":1720577271903,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$QrhxYwfbeLlu0BQfvqwuGL6CviTm3iRp9tRJMK9SSm8"},
{"content":{"body":"which means O(1) different semantics","m.mentions":{},"msgtype":"m.text"},"ts":1720577297915,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$d3oY3mrzlRRqhI016eiR4VoO9cvm8aTDK4gisHcduug"},
{"content":{"body":"Merges are a separate problem, which I don't think is _actually_ all that important. We just need _a_ correct branch to link back to. Building merge contexts would be the ideal for APMs, but we can work around their absence well enough. We _can't_ work around having _no_ branch to link to though.","format":"org.matrix.custom.html","formatted_body":"Merges are a separate problem, which I don't think is <em>actually</em> all that important. We just need <em>a</em> correct branch to link back to. Building merge contexts would be the ideal for APMs, but we can work around their absence well enough. We <em>can't</em> work around having <em>no</em> branch to link to though.","m.mentions":{},"msgtype":"m.text"},"ts":1720577398508,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$mYK2xa0NTg69JAEfHlriwERRJcfvnSmmg5q_lTouW20"},
{"content":{"body":"Ideally merges would be solved too, but that's much lower priority to me.","m.mentions":{},"msgtype":"m.text"},"ts":1720577442550,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$vRIkiL8m68Amr1_1hhRZFINBI0LBhy6kNe4pDX2q1Tw"},
{"content":{"body":"> <@stephenhicks:matrix.org> The reason is that it breaks encapsulation.  The current proposal means that you have strong guarantees that a variable won't change during the course of a function, but if a child task can `enterWith` a new value, then it can affect the parent task in unexpected ways.  It also runs afoul of the requirements imposed by SES, and is unlikely to be accepted by the committee.\n> \n> That said, if you want to make your own `enterWith`able variable, it's easy enough:\n> \n> ```\n> class EnterableVar<T> {\n>   private readonly internal: AsyncContext.Variable<[T]>;\n>   constructor(opts = {}) {\n>     this.internal = new AsyncContext.Variable({...opts, defaultValue: [opts.defaultValue]});\n>   }\n>   run(val, fn) {\n>     return this.internal.run([val], fn);\n>   }\n>   get() {\n>     return this.internal.get()[0];\n>   }\n>   enterWith(val) {\n>     this.internal.get()[0] = val;\n>   }\n> }\n> ```\n\nUnfortunately that does not work to \"fix\" the use case. I don't see how you can think it would. You lose any sense of \"globality\" of the variable.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$giUlDnPThCSKd1ornsi4zdej_2ulPNiQ_xQgW6ndlsw?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>The reason is that it breaks encapsulation.  The current proposal means that you have strong guarantees that a variable won't change during the course of a function, but if a child task can <code>enterWith</code> a new value, then it can affect the parent task in unexpected ways.  It also runs afoul of the requirements imposed by SES, and is unlikely to be accepted by the committee.</p>\n<p>That said, if you want to make your own <code>enterWith</code>able variable, it's easy enough:</p>\n<pre><code>class EnterableVar&lt;T&gt; {\n  private readonly internal: AsyncContext.Variable&lt;[T]&gt;;\n  constructor(opts = {}) {\n    this.internal = new AsyncContext.Variable({...opts, defaultValue: [opts.defaultValue]});\n  }\n  run(val, fn) {\n    return this.internal.run([val], fn);\n  }\n  get() {\n    return this.internal.get()[0];\n  }\n  enterWith(val) {\n    this.internal.get()[0] = val;\n  }\n}\n</code></pre>\n</blockquote></mx-reply>Unfortunately that does not work to \"fix\" the use case. I don't see how you can think it would. You lose any sense of \"globality\" of the variable.","m.mentions":{"user_ids":["@stephenhicks:matrix.org","@devsnek:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$giUlDnPThCSKd1ornsi4zdej_2ulPNiQ_xQgW6ndlsw"}},"msgtype":"m.text"},"ts":1720621153002,"senderName":"Matteo Collina","senderId":"@mcollina:matrix.org","id":"$cplyr04-nNnqnEdcItC3W2sYFiF3D2xOgiEpRr0KOPU"},
{"content":{"body":"Now that I think some more about the web needs for cross-realm keys in the mapping, I think those keys would always be mapped to values which aren't JS values but spec-internal records ðŸ¤”","m.mentions":{},"msgtype":"m.text"},"ts":1720626926888,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$u-Bz-RDTjRaldmdWTQSoYdj58eH8g96q4ArY2U9n_AE"},
{"content":{"body":" * Now that I think some more about the web needs for cross-realm keys in the mapping, I think those keys could be mapped to values which aren't JS values but spec-internal records ðŸ¤”","m.mentions":{},"m.new_content":{"body":"Now that I think some more about the web needs for cross-realm keys in the mapping, I think those keys could be mapped to values which aren't JS values but spec-internal records ðŸ¤”","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$u-Bz-RDTjRaldmdWTQSoYdj58eH8g96q4ArY2U9n_AE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720626939176,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Bwfu2d-Q-8UbeWSvpi56ZcbrEdKGfeAEphbSn9fnAHA"},
{"content":{"body":"how do we encode that into the spec?","m.mentions":{},"msgtype":"m.text"},"ts":1720626945331,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$g1MbhZ2pykhuIT2XyPxqdH2RegaFIm1G4gyvQRXJDD8"},
{"content":{"body":"I guess we could just assert on `.get()` that the value is a JS value","format":"org.matrix.custom.html","formatted_body":"I guess we could just assert on <code>.get()</code> that the value is a JS value","m.mentions":{},"msgtype":"m.text"},"ts":1720627018924,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$9GlKiRedVyMi9IO-GY9YqvDvgLVXANMV2TgWu4h-F48"},
{"content":{"body":"> <@mcollina:matrix.org> Unfortunately that does not work to \"fix\" the use case. I don't see how you can think it would. You lose any sense of \"globality\" of the variable.\n\nI don't understand - can you give a concrete example where it behaves differently/non-globally?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$cplyr04-nNnqnEdcItC3W2sYFiF3D2xOgiEpRr0KOPU?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mcollina:matrix.org\">@mcollina:matrix.org</a><br>Unfortunately that does not work to \"fix\" the use case. I don't see how you can think it would. You lose any sense of \"globality\" of the variable.</blockquote></mx-reply>I don't understand - can you give a concrete example where it behaves differently/non-globally?","m.mentions":{"user_ids":["@mcollina:matrix.org","@devsnek:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$cplyr04-nNnqnEdcItC3W2sYFiF3D2xOgiEpRr0KOPU"}},"msgtype":"m.text"},"ts":1720627419050,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$MaXHYLeNyXs-j783qfqNUzhKkswRcOK-bM9L2ho06Gw"},
{"content":{"body":"> <@abotella:igalia.com> I guess we could just assert on `.get()` that the value is a JS value\n\nAre you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.[[AsyncContextKey]], _asyncVariable_) is true, ...\"?  As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$9GlKiRedVyMi9IO-GY9YqvDvgLVXANMV2TgWu4h-F48?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>I guess we could just assert on <code>.get()</code> that the value is a JS value</blockquote></mx-reply>Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.[[AsyncContextKey]], <em>asyncVariable</em>) is true, ...\"?  As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$9GlKiRedVyMi9IO-GY9YqvDvgLVXANMV2TgWu4h-F48"}},"msgtype":"m.text"},"ts":1720627952018,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$CsVOyXtQUHt0Mi8OITURgqZ5TgEaG2LJ902bIBfZ8dA"},
{"content":{"body":"I was thinking on the *values* being records, the comparison on keys would not change","format":"org.matrix.custom.html","formatted_body":"I was thinking on the <em>values</em> being records, the comparison on keys would not change","m.mentions":{},"msgtype":"m.text"},"ts":1720628016328,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$5pf2ligiHUkirFweFo4ElC002VhDrjfp04-k9xzJnq4"},
{"content":{"body":"maybe PrivateName does something like that, though?","m.mentions":{},"msgtype":"m.text"},"ts":1720628022136,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$EnW0JK1E8HsCCzmUP-cCgl3WcWaM-BBPlZbo4jAuJJA"},
{"content":{"body":"it'd be an assertion after that line, checking that the value is an ECMAScript language value","m.mentions":{},"msgtype":"m.text"},"ts":1720628035960,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$vBg7XU6D77oNX2Q2lbTJ5M5V4Ar7rqyguI5azvbodH4"},
{"content":{"body":"well, it'd be turning that line into a multiline if","m.mentions":{},"msgtype":"m.text"},"ts":1720628136009,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$digGrBu4_y2YxpDvcB-XBVOAaFWVuvn8QeP2TWevUfo"},
{"content":{"body":"and having the assertion inside the if, before returning","m.mentions":{},"msgtype":"m.text"},"ts":1720628145048,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$XSgGJa_Np4CBih-DzoAO2c2M0H5ud0IbSe2S2GA_Rfc"},
{"content":{"body":" * and having the assertion inside the then, before returning","m.mentions":{},"m.new_content":{"body":"and having the assertion inside the then, before returning","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$XSgGJa_Np4CBih-DzoAO2c2M0H5ud0IbSe2S2GA_Rfc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720628157022,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Ry9YeWfnNGUOw272fhW9m9gsn1T9Dn5thkseKf8GlgI"},
{"content":{"body":"I just checked and PrivateName is indeed a record that's compared by reference, e.g. https://tc39.es/ecma262/#sec-privateelementfind","m.mentions":{},"msgtype":"m.text"},"ts":1720628160355,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$plAGEn6dX6OSxmeWxk36f9kv_RWxgyZUHDxHVE_xmSk"},
{"content":{"body":"(but maybe I'm a step or two behind you here)","m.mentions":{},"msgtype":"m.text"},"ts":1720628203267,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$RUEEthOqZ18nt9rvbqftEWvG01lE4ZnsnMJWDMM9AmM"},
{"content":{"body":"what does mapping _to_ records do to help with crloss-realm keys?","format":"org.matrix.custom.html","formatted_body":"what does mapping <em>to</em> records do to help with crloss-realm keys?","m.mentions":{},"msgtype":"m.text"},"ts":1720628231518,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$gCssX-_VgqaRBGK3-5SpNN30kk7oM_3R0PhWNXwrZsM"},
{"content":{"body":" * what does mapping _to_ records do to help with cross-realm keys?","format":"org.matrix.custom.html","formatted_body":" * what does mapping <em>to</em> records do to help with cross-realm keys?","m.mentions":{},"m.new_content":{"body":"what does mapping _to_ records do to help with cross-realm keys?","format":"org.matrix.custom.html","formatted_body":"what does mapping <em>to</em> records do to help with cross-realm keys?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$gCssX-_VgqaRBGK3-5SpNN30kk7oM_3R0PhWNXwrZsM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720628245426,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$VyaTVFXdNs_CICC_x8KJ9qhJPTtJ-6fptRFTHPbpsJ0"},
{"content":{"body":"> <@abotella:igalia.com> I guess we could just assert on `.get()` that the value is a JS value\n\n * Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.\\[\\[AsyncContextKey\\]\\], _asyncVariable_) is true, ...\"?  ~~As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.~~","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$9GlKiRedVyMi9IO-GY9YqvDvgLVXANMV2TgWu4h-F48?via=igalia.com&amp;via=matrix.org&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>I guess we could just assert on <code>.get()</code> that the value is a JS value</blockquote></mx-reply> * Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.[[AsyncContextKey]], <em>asyncVariable</em>) is true, ...\"?  ~~As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.~~","m.mentions":{},"m.new_content":{"body":"Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.\\[\\[AsyncContextKey\\]\\], _asyncVariable_) is true, ...\"?  ~~As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.~~","format":"org.matrix.custom.html","formatted_body":"Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.[[AsyncContextKey]], <em>asyncVariable</em>) is true, ...\"?  ~~As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.~~","m.mentions":{"user_ids":["@abotella:igalia.com"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CsVOyXtQUHt0Mi8OITURgqZ5TgEaG2LJ902bIBfZ8dA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720628275536,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$wzwSED7maa1cngGuR-ZR5NP1caEfM28u1FcIeyHWFYY"},
{"content":{"body":" * Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.\\[\\[AsyncContextKey\\]\\], _asyncVariable_) is true, ...\"?  ~As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.~","format":"org.matrix.custom.html","formatted_body":" * Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.[[AsyncContextKey]], <em>asyncVariable</em>) is true, ...\"?  ~As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.~","m.mentions":{},"m.new_content":{"body":"Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.\\[\\[AsyncContextKey\\]\\], _asyncVariable_) is true, ...\"?  ~As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.~","format":"org.matrix.custom.html","formatted_body":"Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.[[AsyncContextKey]], <em>asyncVariable</em>) is true, ...\"?  ~As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.~","m.mentions":{"user_ids":["@abotella:igalia.com"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CsVOyXtQUHt0Mi8OITURgqZ5TgEaG2LJ902bIBfZ8dA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720628282317,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$UkxUZi92zOQZ4WYlL475kaDqBzObdaN9nOoj-qlt0e4"},
{"content":{"body":" * Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.\\[\\[AsyncContextKey\\]\\], _asyncVariable_) is true, ...\"?  As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.","format":"org.matrix.custom.html","formatted_body":" * Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.[[AsyncContextKey]], <em>asyncVariable</em>) is true, ...\"?  As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.","m.mentions":{},"m.new_content":{"body":"Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.\\[\\[AsyncContextKey\\]\\], _asyncVariable_) is true, ...\"?  As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.","format":"org.matrix.custom.html","formatted_body":"Are you thinking about 5.6.3.4-5.a where it says \"if SameValueZero(p.[[AsyncContextKey]], <em>asyncVariable</em>) is true, ...\"?  As far as I'm aware, there's no idea of reference equality for records anywhere else in the spec, so that might be a new concept that we probably don't want to have to define.","m.mentions":{"user_ids":["@abotella:igalia.com"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CsVOyXtQUHt0Mi8OITURgqZ5TgEaG2LJ902bIBfZ8dA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720628289415,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$5SmDqTIF5ny_mt-FvAc84ZAiCcFleyHg1_eEtOyCAc4"},
{"content":{"body":"well, the reason I was thinking of cross-realm keys was because of web specs using AsyncContext internally, and their keys might need to be cross-realm","m.mentions":{},"msgtype":"m.text"},"ts":1720628394929,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$zwPtoRHr52Ud8_QtB6QK351Ivxa1KBPW07ttYFchuHY"},
{"content":{"body":"but the same kind of use case might also need records as values, since those keys would not ever be exposed to JS","m.mentions":{},"msgtype":"m.text"},"ts":1720628417344,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$_0H5m5PTUAmOnJuU8v7etlXNEq-3yWP7F2lNEP8kBZY"},
{"content":{"body":"it's not directly to help with cross-realm keys, it's to help with the problem *that* solves","format":"org.matrix.custom.html","formatted_body":"it's not directly to help with cross-realm keys, it's to help with the problem <em>that</em> solves","m.mentions":{},"msgtype":"m.text"},"ts":1720628439900,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$4tHeRJ2EpEQRShfxHo3TUQAw02QRZaR3dqeCFu_3MLI"},
{"content":{"body":"it's better than having to wrap those records on a JS object","m.mentions":{},"msgtype":"m.text"},"ts":1720628461725,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$mVOvXp3A6018CvUUF5R7ePseaZFMJNAjwD9uvzFK4hg"},
{"content":{"body":" * it's better than having to wrap those records into a JS object somehow","m.mentions":{},"m.new_content":{"body":"it's better than having to wrap those records into a JS object somehow","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$mVOvXp3A6018CvUUF5R7ePseaZFMJNAjwD9uvzFK4hg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720628470483,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$FJv3JIq-O40GU9YQ8OZrZP7Hn6XzYVKQdfDh-Sizcuo"},
{"content":{"body":"ah gotcha, so if the web spec isn't exposing the AsyncContext at all but just storing a random record as the value type - that makes sense","m.mentions":{},"msgtype":"m.text"},"ts":1720628510565,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$c0XSuVcksvjNlS1qTAKpTOMfM0RapLhV_x3QYSs8nNg"},
{"content":{"body":"That seems worth a textual note somewhere","m.mentions":{},"msgtype":"m.text"},"ts":1720628537748,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$oS-pdXWHPdQAuptyfYfay4grWIoW_wr4UFW5wG-Y_g8"},
{"content":{"body":"since otherwise just reading the ES spec would make it very confusing why the assertion is there","m.mentions":{},"msgtype":"m.text"},"ts":1720628557660,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$WDfzuJyb5B1Q6W1AJVQA9YW8PjYjxPkFft0JWVdnl7c"},
{"content":{"body":"definitely","m.mentions":{},"msgtype":"m.text"},"ts":1720628567766,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$kBDcBcTo9Et3u6ef-q-oFgJvTjUI_x4zxJvv6KaKyEE"},
{"content":{"body":" * ah gotcha, so if the web spec isn't exposing the AsyncContext.Variable at all but just storing a random record as the value type - that makes sense","m.mentions":{},"m.new_content":{"body":"ah gotcha, so if the web spec isn't exposing the AsyncContext.Variable at all but just storing a random record as the value type - that makes sense","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$c0XSuVcksvjNlS1qTAKpTOMfM0RapLhV_x3QYSs8nNg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720628714774,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$LIOWzdcDZKC4-PfUC0LfNNOSMyu-jfvgqqiLM6-OjXI"},
{"content":{"body":"> <@abotella:igalia.com> it's better than having to wrap those records into a JS object somehow\n\nWhat is the problem with doing this?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$mVOvXp3A6018CvUUF5R7ePseaZFMJNAjwD9uvzFK4hg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br />it's better than having to wrap those records into a JS object somehow</blockquote></mx-reply>What is the problem with doing this?","m.relates_to":{"m.in_reply_to":{"event_id":"$mVOvXp3A6018CvUUF5R7ePseaZFMJNAjwD9uvzFK4hg"}},"msgtype":"m.text"},"ts":1720629939735,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$6xgrWVRAtsc8s9LQ53ftuXtJq43bTSyUe4a3vWxoFXU"},
{"content":{"body":"An object with an internal slot holding the record","msgtype":"m.text"},"ts":1720629960741,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Jnvn4Bvc6VxENDQrE-o7NLJTwAmVcY_sZhiV-cv4zOY"},
{"content":{"body":"> <@nicolo-ribaudo:matrix.org> What is the problem with doing this?\n\nit's less ergonomic, especially for web specs, and if implemented literally it might keep a reference to the realm the object is created when there's no need for it","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$6xgrWVRAtsc8s9LQ53ftuXtJq43bTSyUe4a3vWxoFXU?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">@nicolo-ribaudo:matrix.org</a><br>What is the problem with doing this?</blockquote></mx-reply>it's less ergonomic, especially for web specs, and if implemented literally it might keep a reference to the realm the object is created when there's no need for it","m.mentions":{"user_ids":["@nicolo-ribaudo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$6xgrWVRAtsc8s9LQ53ftuXtJq43bTSyUe4a3vWxoFXU"}},"msgtype":"m.text"},"ts":1720630097342,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$RlBbys2x7LjkKqp1_nud7zBvgbCKJodaiVgdpt7katU"},
{"content":{"body":"I don't expect a lot of specs to use this, but it wouldn't only be used by, say, HTML","m.mentions":{},"msgtype":"m.text"},"ts":1720630145433,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$6SVVKu1JD14Bcwr4BCCAHhLdtmHEw-upupOZPCWwYyc"},
{"content":{"body":"`scheduler.yield()` does seem to have a clear use case for it","format":"org.matrix.custom.html","formatted_body":"<code>scheduler.yield()</code> does seem to have a clear use case for it","m.mentions":{},"msgtype":"m.text"},"ts":1720630159160,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$RN98jT-OzW9oxOZ3j3-yoSnKyVSm5OTK9YBOuzSzKFI"},
{"content":{"body":"but maybe that's niche enough that specs that use it can do the extra work","m.mentions":{},"msgtype":"m.text"},"ts":1720630243051,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$vOD2QFAM8kpM6RhFnm3-9BWcEMqehkTsHB5Dkr8HmP0"},
{"content":{"body":"For specs there could be an AO StoreRecordInAsyncContext and GetRecordFromAsyncContext, that abstracts away the wrapping ","msgtype":"m.text"},"ts":1720630378669,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$f7nlWw32u2JGTnqNQKOjXjxB52E_CjR0dDX27cmHJHM"},
{"content":{"body":"This is more of a decision for the spec editor though, let's discuss it during the editors stage 2.7 reviews :)","msgtype":"m.text"},"ts":1720630410524,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$lc3E_Y-fS7XyR3zG-NkF0G0oWe0Zkl01SiY5c7CmpCw"},
{"content":{"body":"I'm currently working on an explainer that would describe how web specs would have to deal with AsyncContext","m.mentions":{},"msgtype":"m.text"},"ts":1720632879568,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$CENfTlgP7BMVZ3eZVChs8nUG0I4PepZzNprFa1XPkGk"},
{"content":{"body":"I'll go with \"this is the complicated way that you have to do this currently, but we expect to add AOs to make things more ergonomic in the futuure\"","m.mentions":{},"msgtype":"m.text"},"ts":1720632930022,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Punpx57k2E48L1Tve6ve6D6ypw7IuBdzXKQV8Gs1Gjs"},
{"content":{"body":"> <@littledan:matrix.org> I donâ€™t get it; isnâ€™t this what AsyncContext.Snapshot is for?\n\nHow would you capture it? Components return VDOM, not snapshots. Even ignoring that, the way React implements Context via special handling of the VDOM structure, it would require invoking the batched queue within new function calls, breaking the purpose of the batching code (to avoid recursion)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24bIZZzqlxwDWESpvur9qv8VrUNWjLyMx2rB0yHb-ndQ4\">In reply to</a><a href=\"https://matrix.to/#/%40littledan%3Amatrix.org\">@littledan:matrix.org</a><br />I donâ€™t get it; isnâ€™t this what AsyncContext.Snapshot is for?</blockquote></mx-reply>How would you capture it? Components return VDOM, not snapshots. Even ignoring that, the way React implements Context via special handling of the VDOM structure, it would require invoking the batched queue within new function calls, breaking the purpose of the batching code (to avoid recursion)","m.relates_to":{"m.in_reply_to":{"event_id":"$bIZZzqlxwDWESpvur9qv8VrUNWjLyMx2rB0yHb-ndQ4"}},"msgtype":"m.text"},"ts":1720647635642,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$HeTYkxpVpBmZp-O7GXN7oRkjdlW4PkgxJTsGUgIT9eQ"}
]