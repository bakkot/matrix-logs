[
{"content":{"body":"Justin Ridgewell As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.\n\n```js\nconst appID = new AsyncContext.Variable();\n\nappID.run(\"Red\", () => Event.captureFallbackContext(red));\nappID.run(\"Blue\", () => Event.captureFallbackContext(blue));\n\naddEventListener('unhandledrejection', () => {\n  console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n});\n```\n\nwhere `red` is defined as\n\n```js\nexport function red() {\n  document.addEventListener(\"click\", () => { Promise.reject() });\n}\n```\n\nwhen the user clicks on the document, this logs `There has been an unhandled promise rejection in app Red`.\n\nIf instead `Blue` runs `document.click()`:\n- with the current proposal, it would log `There has been an unhandled promise rejection in app Red`\n- if we don't save the stack and just use the fallback when the event comes from the browser, it would log `There has been an unhandled promise rejection in app Blue`","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.</p>\n<pre><code class=\"language-js\">const appID = new AsyncContext.Variable();\n\nappID.run(\"Red\", () =&gt; Event.captureFallbackContext(red));\nappID.run(\"Blue\", () =&gt; Event.captureFallbackContext(blue));\n\naddEventListener('unhandledrejection', () =&gt; {\n  console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n});\n</code></pre>\n<p>where <code>red</code> is defined as</p>\n<pre><code class=\"language-js\">export function red() {\n  document.addEventListener(\"click\", () =&gt; { Promise.reject() });\n}\n</code></pre>\n<p>when the user clicks on the document, this logs <code>There has been an unhandled promise rejection in app Red</code>.</p>\n<p>If instead <code>Blue</code> runs <code>document.click()</code>:</p>\n<ul>\n<li>with the current proposal, it would log <code>There has been an unhandled promise rejection in app Red</code></li>\n<li>if we don't save the stack and just use the fallback when the event comes from the browser, it would log <code>There has been an unhandled promise rejection in app Blue</code></li>\n</ul>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"msgtype":"m.text"},"ts":1729775506655,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Ns7LYCmaPUK93oxqne3oUfqj_HIG5kOHfeqOMKd8DLo"},
{"content":{"body":"Also, I'm seeing in the notes a question about how long the bootstrap context lives.\n\nThe effects on that of\n```js\nEvent.captureFallbackContext(() => { addEventListener(\"foo\", () => {}); });\n```\nare the same as\n```js\naddEventListener(\"foo\", AsyncContext.Snapshot.wrap(() => {}));\n```\n\n- `Event.captureFallbackContext` only holds the context alive if there are event listeners registered inside it\n- differently from the other \"let's always go with the registration context\" approach, this only captures the context when explicitly asked to (through the `.captureFallbackContext` API)","format":"org.matrix.custom.html","formatted_body":"<p>Also, I'm seeing in the notes a question about how long the bootstrap context lives.</p>\n<p>The effects on that of</p>\n<pre><code class=\"language-js\">Event.captureFallbackContext(() =&gt; { addEventListener(\"foo\", () =&gt; {}); });\n</code></pre>\n<p>are the same as</p>\n<pre><code class=\"language-js\">addEventListener(\"foo\", AsyncContext.Snapshot.wrap(() =&gt; {}));\n</code></pre>\n<ul>\n<li><code>Event.captureFallbackContext</code> only holds the context alive if there are event listeners registered inside it</li>\n<li>differently from the other \"let's always go with the registration context\" approach, this only captures the context when explicitly asked to (through the <code>.captureFallbackContext</code> API)</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1729775689554,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$UHmM5k7fAI-6ovwm2WpsFRH7Nf2It7QFtikO1BjlSdU"},
{"content":{"body":"> <@nicolo-ribaudo:matrix.org> Also, I'm seeing in the notes a question about how long the bootstrap context lives.\n> \n> The effects on that of\n> ```js\n> Event.captureFallbackContext(() => { addEventListener(\"foo\", () => {}); });\n> ```\n> are the same as\n> ```js\n> addEventListener(\"foo\", AsyncContext.Snapshot.wrap(() => {}));\n> ```\n> \n> - `Event.captureFallbackContext` only holds the context alive if there are event listeners registered inside it\n> - differently from the other \"let's always go with the registration context\" approach, this only captures the context when explicitly asked to (through the `.captureFallbackContext` API)\n\nAlso, a big difference is that the use case of `captureFallbackContext` is to call it \"a few times\" and \"close to the top-level\", while event listeners are used all over the place. So the number of different snapshots captured is in general significantly smaller. Example:\n\n```js\nEvent.captureFallbackContext(() => {\n  varOne.run(1, () => addEventListener(\"foo\", () => {}));\n  varTwo.run(2, () => addEventListener(\"foo\", () => {}));\n});\n```\nonly captures one context, while the approach where we use the registration context by default would capture two different contexts","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$UHmM5k7fAI-6ovwm2WpsFRH7Nf2It7QFtikO1BjlSdU?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">@nicolo-ribaudo:matrix.org</a><br><p>Also, I'm seeing in the notes a question about how long the bootstrap context lives.</p>\n<p>The effects on that of</p>\n<pre><code class=\"language-js\">Event.captureFallbackContext(() =&gt; { addEventListener(\"foo\", () =&gt; {}); });\n</code></pre>\n<p>are the same as</p>\n<pre><code class=\"language-js\">addEventListener(\"foo\", AsyncContext.Snapshot.wrap(() =&gt; {}));\n</code></pre>\n<ul>\n<li><code>Event.captureFallbackContext</code> only holds the context alive if there are event listeners registered inside it</li>\n<li>differently from the other \"let's always go with the registration context\" approach, this only captures the context when explicitly asked to (through the <code>.captureFallbackContext</code> API)</li>\n</ul>\n</blockquote></mx-reply><p>Also, a big difference is that the use case of <code>captureFallbackContext</code> is to call it \"a few times\" and \"close to the top-level\", while event listeners are used all over the place. So the number of different snapshots captured is in general significantly smaller. Example:</p>\n<pre><code class=\"language-js\">Event.captureFallbackContext(() =&gt; {\n  varOne.run(1, () =&gt; addEventListener(\"foo\", () =&gt; {}));\n  varTwo.run(2, () =&gt; addEventListener(\"foo\", () =&gt; {}));\n});\n</code></pre>\n<p>only captures one context, while the approach where we use the registration context by default would capture two different contexts</p>\n","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$UHmM5k7fAI-6ovwm2WpsFRH7Nf2It7QFtikO1BjlSdU"}},"msgtype":"m.text"},"ts":1729776085879,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$ZAZxhHj5ng5CWecW7kl-2aS56iAZwbHrA-CJVCOsfpo"},
{"content":{"body":" * Justin Ridgewell As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.\n\n```js\nEvent.captureFallbackContext(() => { // this establishes the \"root context\", which is actually implicitly done by the browser\n\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () => Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () => Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () => {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n```\n\nwhere `red` is defined as\n\n```js\nexport function red() {\n  document.addEventListener(\"click\", () => { Promise.reject() });\n}\n```\n\n**With the current \"stack\" proposal**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Red`.\n\n**Without the stack, only using the fallback for browser-dispatched events**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Blue`.\n\n**Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app undefined`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app undefined`.","format":"org.matrix.custom.html","formatted_body":" * <p><a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.</p>\n<pre><code class=\"language-js\">Event.captureFallbackContext(() =&gt; { // this establishes the \"root context\", which is actually implicitly done by the browser\n\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () =&gt; Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () =&gt; Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () =&gt; {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n</code></pre>\n<p>where <code>red</code> is defined as</p>\n<pre><code class=\"language-js\">export function red() {\n  document.addEventListener(\"click\", () =&gt; { Promise.reject() });\n}\n</code></pre>\n<p><strong>With the current \"stack\" proposal</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n</ul>\n<p><strong>Without the stack, only using the fallback for browser-dispatched events</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Blue</code>.</li>\n</ul>\n<p><strong>Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"Justin Ridgewell As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.\n\n```js\nEvent.captureFallbackContext(() => { // this establishes the \"root context\", which is actually implicitly done by the browser\n\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () => Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () => Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () => {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n```\n\nwhere `red` is defined as\n\n```js\nexport function red() {\n  document.addEventListener(\"click\", () => { Promise.reject() });\n}\n```\n\n**With the current \"stack\" proposal**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Red`.\n\n**Without the stack, only using the fallback for browser-dispatched events**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Blue`.\n\n**Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app undefined`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app undefined`.","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.</p>\n<pre><code class=\"language-js\">Event.captureFallbackContext(() =&gt; { // this establishes the \"root context\", which is actually implicitly done by the browser\n\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () =&gt; Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () =&gt; Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () =&gt; {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n</code></pre>\n<p>where <code>red</code> is defined as</p>\n<pre><code class=\"language-js\">export function red() {\n  document.addEventListener(\"click\", () =&gt; { Promise.reject() });\n}\n</code></pre>\n<p><strong>With the current \"stack\" proposal</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n</ul>\n<p><strong>Without the stack, only using the fallback for browser-dispatched events</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Blue</code>.</li>\n</ul>\n<p><strong>Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n</ul>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Ns7LYCmaPUK93oxqne3oUfqj_HIG5kOHfeqOMKd8DLo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1729776632278,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$ll-CufDpJeFZ98fmVCY8Y_HP1z5lvAnNr-X6RXyqfDQ"},
{"content":{"body":" * Justin Ridgewell As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.\n\n```js\nEvent.captureFallbackContext(() => { // this establishes the \"root context\",\n                                     // which is actually implicitly done by the\n                                     // browser. This call is just to show it\n                                     // explicitly.\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () => Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () => Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () => {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n```\n\nwhere `red` is defined as\n\n```js\nexport function red() {\n  document.addEventListener(\"click\", () => { Promise.reject() });\n}\n```\n\n**With the current \"stack\" proposal**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Red`.\n\n**Without the stack, only using the fallback for browser-dispatched events**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Blue`.\n\n**Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app undefined`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app undefined`.","format":"org.matrix.custom.html","formatted_body":" * <p><a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.</p>\n<pre><code class=\"language-js\">Event.captureFallbackContext(() =&gt; { // this establishes the \"root context\",\n                                     // which is actually implicitly done by the\n                                     // browser. This call is just to show it\n                                     // explicitly.\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () =&gt; Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () =&gt; Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () =&gt; {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n</code></pre>\n<p>where <code>red</code> is defined as</p>\n<pre><code class=\"language-js\">export function red() {\n  document.addEventListener(\"click\", () =&gt; { Promise.reject() });\n}\n</code></pre>\n<p><strong>With the current \"stack\" proposal</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n</ul>\n<p><strong>Without the stack, only using the fallback for browser-dispatched events</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Blue</code>.</li>\n</ul>\n<p><strong>Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"Justin Ridgewell As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.\n\n```js\nEvent.captureFallbackContext(() => { // this establishes the \"root context\",\n                                     // which is actually implicitly done by the\n                                     // browser. This call is just to show it\n                                     // explicitly.\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () => Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () => Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () => {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n```\n\nwhere `red` is defined as\n\n```js\nexport function red() {\n  document.addEventListener(\"click\", () => { Promise.reject() });\n}\n```\n\n**With the current \"stack\" proposal**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Red`.\n\n**Without the stack, only using the fallback for browser-dispatched events**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Blue`.\n\n**Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app undefined`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app undefined`.","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.</p>\n<pre><code class=\"language-js\">Event.captureFallbackContext(() =&gt; { // this establishes the \"root context\",\n                                     // which is actually implicitly done by the\n                                     // browser. This call is just to show it\n                                     // explicitly.\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () =&gt; Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () =&gt; Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () =&gt; {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n</code></pre>\n<p>where <code>red</code> is defined as</p>\n<pre><code class=\"language-js\">export function red() {\n  document.addEventListener(\"click\", () =&gt; { Promise.reject() });\n}\n</code></pre>\n<p><strong>With the current \"stack\" proposal</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n</ul>\n<p><strong>Without the stack, only using the fallback for browser-dispatched events</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Blue</code>.</li>\n</ul>\n<p><strong>Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n</ul>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Ns7LYCmaPUK93oxqne3oUfqj_HIG5kOHfeqOMKd8DLo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1729776679552,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$_60CAd9FOnBbqCN_cqfTKFldNyULM9VhzkPPn9J_5sQ"},
{"content":{"body":" * Justin Ridgewell As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.\n\n```js\nEvent.captureFallbackContext(() => { // this establishes the \"root context\",\n                                     // which is actually implicitly done by the\n                                     // browser. This call is just to show it\n                                     // explicitly.\n\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () => Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () => Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () => {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n```\n\nwhere `red` is defined as\n\n```js\nexport function red() {\n  document.addEventListener(\"click\", () => { Promise.reject() });\n}\n```\n\n**With the current \"stack\" proposal**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Red`.\n\n**Without the stack, only using the fallback for browser-dispatched events**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Blue`.\n\n**Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app undefined`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app undefined`.","format":"org.matrix.custom.html","formatted_body":" * <p><a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.</p>\n<pre><code class=\"language-js\">Event.captureFallbackContext(() =&gt; { // this establishes the \"root context\",\n                                     // which is actually implicitly done by the\n                                     // browser. This call is just to show it\n                                     // explicitly.\n\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () =&gt; Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () =&gt; Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () =&gt; {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n</code></pre>\n<p>where <code>red</code> is defined as</p>\n<pre><code class=\"language-js\">export function red() {\n  document.addEventListener(\"click\", () =&gt; { Promise.reject() });\n}\n</code></pre>\n<p><strong>With the current \"stack\" proposal</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n</ul>\n<p><strong>Without the stack, only using the fallback for browser-dispatched events</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Blue</code>.</li>\n</ul>\n<p><strong>Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"Justin Ridgewell As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.\n\n```js\nEvent.captureFallbackContext(() => { // this establishes the \"root context\",\n                                     // which is actually implicitly done by the\n                                     // browser. This call is just to show it\n                                     // explicitly.\n\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () => Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () => Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () => {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n```\n\nwhere `red` is defined as\n\n```js\nexport function red() {\n  document.addEventListener(\"click\", () => { Promise.reject() });\n}\n```\n\n**With the current \"stack\" proposal**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Red`.\n\n**Without the stack, only using the fallback for browser-dispatched events**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app Red`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app Blue`.\n\n**Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"**\n\n- when the user clicks on the document, it logs `There has been an unhandled promise rejection in app undefined`.\n- if Blue runs `document.click()`, it logs `There has been an unhandled promise rejection in app undefined`.","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a> As you asked last time, here is an example where there is a significant difference between keeping the fallback stack and not doing it.</p>\n<pre><code class=\"language-js\">Event.captureFallbackContext(() =&gt; { // this establishes the \"root context\",\n                                     // which is actually implicitly done by the\n                                     // browser. This call is just to show it\n                                     // explicitly.\n\n  const appID = new AsyncContext.Variable();\n\n  appID.run(\"Red\", () =&gt; Event.captureFallbackContext(red));\n  appID.run(\"Blue\", () =&gt; Event.captureFallbackContext(blue));\n\n  addEventListener('unhandledrejection', () =&gt; {\n    console.log(`There has been an unhandled promise rejection in app ${appID.get()}`);\n  });\n});\n</code></pre>\n<p>where <code>red</code> is defined as</p>\n<pre><code class=\"language-js\">export function red() {\n  document.addEventListener(\"click\", () =&gt; { Promise.reject() });\n}\n</code></pre>\n<p><strong>With the current \"stack\" proposal</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n</ul>\n<p><strong>Without the stack, only using the fallback for browser-dispatched events</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app Red</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app Blue</code>.</li>\n</ul>\n<p><strong>Without the stack, using the fallback when the event not dispatched from within the same \"fallback zone\"</strong></p>\n<ul>\n<li>when the user clicks on the document, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n<li>if Blue runs <code>document.click()</code>, it logs <code>There has been an unhandled promise rejection in app undefined</code>.</li>\n</ul>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Ns7LYCmaPUK93oxqne3oUfqj_HIG5kOHfeqOMKd8DLo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1729776685396,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$wsF8luKgNaFf9zPppGOEUvTJSfejKegV-Cu1ubM1JFk"},
{"content":{"body":"I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting `Event.captureFallbackContext(() => Framework.captureFallbackContext(() => ...))`?  Or does it make sense to generalize via (strawman)\n\n```\nnamespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () => savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n```\n\nand then frameworks can piggyback on the same boundaries?","format":"org.matrix.custom.html","formatted_body":"<p>I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting <code>Event.captureFallbackContext(() =&gt; Framework.captureFallbackContext(() =&gt; ...))</code>?  Or does it make sense to generalize via (strawman)</p>\n<pre><code>namespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () =&gt; savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n</code></pre>\n<p>and then frameworks can piggyback on the same boundaries?</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1729805505241,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$4soncAZHrNDaJLj05BrxUWh5A9-inbJlOsmUnW2QVJs"},
{"content":{"body":" * I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting `Event.captureFallbackContext(() => Framework.captureFallbackContext(() => ...))`?  Or does it make sense to generalize via (strawman)\n\n```javascript\nnamespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () => savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n```\n\nand then frameworks can piggyback on the same boundaries?","format":"org.matrix.custom.html","formatted_body":" * <p>I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting <code>Event.captureFallbackContext(() =&gt; Framework.captureFallbackContext(() =&gt; ...))</code>?  Or does it make sense to generalize via (strawman)</p>\n<pre><code class=\"language-javascript\">namespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () =&gt; savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n</code></pre>\n<p>and then frameworks can piggyback on the same boundaries?</p>\n","m.mentions":{},"m.new_content":{"body":"I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting `Event.captureFallbackContext(() => Framework.captureFallbackContext(() => ...))`?  Or does it make sense to generalize via (strawman)\n\n```javascript\nnamespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () => savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n```\n\nand then frameworks can piggyback on the same boundaries?","format":"org.matrix.custom.html","formatted_body":"<p>I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting <code>Event.captureFallbackContext(() =&gt; Framework.captureFallbackContext(() =&gt; ...))</code>?  Or does it make sense to generalize via (strawman)</p>\n<pre><code class=\"language-javascript\">namespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () =&gt; savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n</code></pre>\n<p>and then frameworks can piggyback on the same boundaries?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$4soncAZHrNDaJLj05BrxUWh5A9-inbJlOsmUnW2QVJs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1729805514384,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Jmg9u8rJ0XKpWbLLYDilozlrBAk7Uh2E_op_hyboPrw"},
{"content":{"body":" * I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting `Event.captureFallbackContext(() => Framework.captureFallbackContext(() => ...))`?  Or does it make sense to generalize via (strawman)\n\n```javascript\nnamespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () => savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n```\n\nand then frameworks (or other specs) can piggyback on the same boundaries?","format":"org.matrix.custom.html","formatted_body":" * <p>I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting <code>Event.captureFallbackContext(() =&gt; Framework.captureFallbackContext(() =&gt; ...))</code>?  Or does it make sense to generalize via (strawman)</p>\n<pre><code class=\"language-javascript\">namespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () =&gt; savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n</code></pre>\n<p>and then frameworks (or other specs) can piggyback on the same boundaries?</p>\n","m.mentions":{},"m.new_content":{"body":"I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting `Event.captureFallbackContext(() => Framework.captureFallbackContext(() => ...))`?  Or does it make sense to generalize via (strawman)\n\n```javascript\nnamespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () => savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n```\n\nand then frameworks (or other specs) can piggyback on the same boundaries?","format":"org.matrix.custom.html","formatted_body":"<p>I had a question about the interaction between this and other non-event systems - suppose a framework provides lifecycle callbacks and it makes sense to have a similar treatment - do we end up nesting <code>Event.captureFallbackContext(() =&gt; Framework.captureFallbackContext(() =&gt; ...))</code>?  Or does it make sense to generalize via (strawman)</p>\n<pre><code class=\"language-javascript\">namespace AsyncContext {\n  const fallbackSnapshot = new Variable({defaultValue: new Snapshot()});\n  export function captureFallback(fn) {\n    return fallbackSnapshot.run(new Snapshot(), fn);\n  }\n  export function wrapFallback(fn) {\n    const savedFallback = fallbackSnapshot.get();\n    return () =&gt; savedFallback.isParentOfCurrentContext() ? fn() : savedFallback.run(fn);\n  }\n}\n</code></pre>\n<p>and then frameworks (or other specs) can piggyback on the same boundaries?</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$4soncAZHrNDaJLj05BrxUWh5A9-inbJlOsmUnW2QVJs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1729805556079,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$9aCKogKBQB1k4v8v1H-GAKZlQDvOOWfQKTSjoisbHqk"}
]