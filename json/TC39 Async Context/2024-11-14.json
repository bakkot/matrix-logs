[
{"content":{"body":"If it's limited to scoped `using` and not general mutability, I think you can polyfill on top of `AsyncContext` and only instrument `await` and `yield` statements.","format":"org.matrix.custom.html","formatted_body":"If it's limited to scoped <code>using</code> and not general mutability, I think you can polyfill on top of <code>AsyncContext</code> and only instrument <code>await</code> and <code>yield</code> statements.","m.mentions":{},"msgtype":"m.text"},"ts":1731545289380,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5FFjaRYOlqrM_TGdG-s2UhuAAeaZD5zGySU7REbq2GA"},
{"content":{"body":"I know we talked about this before and I said otherwise, but I can't remember why I said it wasn't possible before.","m.mentions":{},"msgtype":"m.text"},"ts":1731545373024,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$WNX6R9dS-7uRHHYe3MvJ0ThVAIpbdoTvGQb21PoaOTA"},
{"content":{"body":"But I think that's the problem - it can't be limited to scoped `using` because of composability: you need to be able to write\n```javascript\nfunction enterSpan(id) {\n  const span = new Span({id, parent: currentSpan.get()});\n  span[Symbol.dispose] = currentSpan.enter(span)[Symbol.dispose];\n  log('new span', currentSpan.get());\n  return span;\n}\n```\nThat function gives no syntactic indication that it needs any extra transpilation... in fact, thinking about it further, it violates the principle that functions you call shouldn't be able to change your context.","format":"org.matrix.custom.html","formatted_body":"<p>But I think that's the problem - it can't be limited to scoped <code>using</code> because of composability: you need to be able to write</p>\n<pre><code class=\"language-javascript\">function enterSpan(id) {\n  const span = new Span({id, parent: currentSpan.get()});\n  span[Symbol.dispose] = currentSpan.enter(span)[Symbol.dispose];\n  log('new span', currentSpan.get());\n  return span;\n}\n</code></pre>\n<p>That function gives no syntactic indication that it needs any extra transpilation... in fact, thinking about it further, it violates the principle that functions you call shouldn't be able to change your context.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731557891411,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$h0_UTBu_6Elms7SP15kP3kGx_7D3dz3Nzg0sWaVClt0"},
{"content":{"body":"That example wouldn't be possible, but using `using span = enterSpan(…)` could be","format":"org.matrix.custom.html","formatted_body":"That example wouldn't be possible, but using <code>using span = enterSpan(…)</code> could be","m.mentions":{},"msgtype":"m.text"},"ts":1731558223628,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5dRj2yFit3G5DyDCY24ueWaG5FD9Uhbfzw_BDnI0glg"},
{"content":{"body":"how would you define `enterSpan` in that case?","format":"org.matrix.custom.html","formatted_body":"how would you define <code>enterSpan</code> in that case?","m.mentions":{},"msgtype":"m.text"},"ts":1731558244462,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$yiAV-UJEqBZa0Kka2fKkYfuxcaC7PvoqSnf-SdqEEpE"},
{"content":{"body":"The same?","m.mentions":{},"msgtype":"m.text"},"ts":1731558900339,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5MHXpoW8cvCI9q8cfj-Kq6LV0jGvNPPBv3PkFgmexbs"},
{"content":{"body":"The difference is you expected `enterSpan` to cause the mutation, and I'm expecting the `using span …` to do it","format":"org.matrix.custom.html","formatted_body":"The difference is you expected <code>enterSpan</code> to cause the mutation, and I'm expecting the <code>using span …</code> to do it","m.mentions":{},"msgtype":"m.text"},"ts":1731558956630,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$c0VS9APiCrFRuVR8iGyEuIacZurWxuyHL1S9kOt7OF4"},
{"content":{"body":"This is the `disposable[Symbol.enter]()` idea, but AIUI, it's a non-starter if it only works syntactically - i.e. you still need to be able to call it reflectively for composability.","format":"org.matrix.custom.html","formatted_body":"This is the <code>disposable[Symbol.enter]()</code> idea, but AIUI, it's a non-starter if it only works syntactically - i.e. you still need to be able to call it reflectively for composability.","m.mentions":{},"msgtype":"m.text"},"ts":1731603968737,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$21oKocjT9TwiFHJCESNAptqN5yGCEd3HwKEjrae9pZU"},
{"content":{"body":"Case in point: `Span[Symbol.enter]` would need to call `AsyncContext.Mutation[Symbol.enter]` transitively.","format":"org.matrix.custom.html","formatted_body":"Case in point: <code>Span[Symbol.enter]</code> would need to call <code>AsyncContext.Mutation[Symbol.enter]</code> transitively.","m.mentions":{},"msgtype":"m.text"},"ts":1731604032223,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$7RjfNtecBqVlD3YjGQuVuUvs1JmFcVhJEDcVApFZwe8"},
{"content":{"body":"and it couldn't use `using` syntax for that.","format":"org.matrix.custom.html","formatted_body":"and it couldn't use <code>using</code> syntax for that.","m.mentions":{},"msgtype":"m.text"},"ts":1731604040482,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Nr26RuIgg6inZixi0ZD6Kd12MVvdV6EShZH6TU2zB2I"},
{"content":{"body":" * Case in point: `Span.prototype[Symbol.enter]` would need to call `AsyncContext.Mutation.prototype[Symbol.enter]` transitively.","format":"org.matrix.custom.html","formatted_body":" * Case in point: <code>Span.prototype[Symbol.enter]</code> would need to call <code>AsyncContext.Mutation.prototype[Symbol.enter]</code> transitively.","m.mentions":{},"m.new_content":{"body":"Case in point: `Span.prototype[Symbol.enter]` would need to call `AsyncContext.Mutation.prototype[Symbol.enter]` transitively.","format":"org.matrix.custom.html","formatted_body":"Case in point: <code>Span.prototype[Symbol.enter]</code> would need to call <code>AsyncContext.Mutation.prototype[Symbol.enter]</code> transitively.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$7RjfNtecBqVlD3YjGQuVuUvs1JmFcVhJEDcVApFZwe8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731604066146,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$CQLEzQUG-xm0Lwqxp4KLWTfMzteOIf99T7rB6Jccbz8"},
{"content":{"body":"For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731605276589,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$_mfTilozkk-_vr46mZPk9scM8KDKfQUUjsNlTyYH6oM"},
{"content":{"body":" * For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_mfTilozkk-_vr46mZPk9scM8KDKfQUUjsNlTyYH6oM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731605542352,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$b-7zMmGFQWxb1kLUQP3W4k4fozntx-87SaJGc4Si2ZI"},
{"content":{"body":"And you can still leak _a little bit_, but:\n- `.run` is a hard boundary you cannot leak accross\n- if you leak, basically as soon as some other context ends you'll get an error","format":"org.matrix.custom.html","formatted_body":"<p>And you can still leak <em>a little bit</em>, but:</p>\n<ul>\n<li><code>.run</code> is a hard boundary you cannot leak accross</li>\n<li>if you leak, basically as soon as some other context ends you'll get an error</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731605590763,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$bbAIKKJGweotZXOHMncGpRK_ej8968iBoKEn173b0T4"},
{"content":{"body":"And the error could point to the stack trace of where you did `enter` without then disposing it","format":"org.matrix.custom.html","formatted_body":"And the error could point to the stack trace of where you did <code>enter</code> without then disposing it","m.mentions":{},"msgtype":"m.text"},"ts":1731605619991,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$i5_N32PJSNGr4nO7x5mB-2fAgEo1nNWIvrVbzMy4E4s"},
{"content":{"body":"I think you need to store two locals - one for `oldContext` and one for `updatedContext` and then line 15 wants to compare `current !== updatedContext`","format":"org.matrix.custom.html","formatted_body":"I think you need to store two locals - one for <code>oldContext</code> and one for <code>updatedContext</code> and then line 15 wants to compare <code>current !== updatedContext</code>","m.mentions":{},"msgtype":"m.text"},"ts":1731605657835,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$RovyKn93XqLwePGMTt6TpIyicFsyze6p3f-wlDw-7MQ"},
{"content":{"body":"True, right","m.mentions":{},"msgtype":"m.text"},"ts":1731605680577,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$N6SPfD00ZZC0x_aFncp9v9XV2ZkOAuJdJ3pP3S7o0RI"},
{"content":{"body":" * For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_mfTilozkk-_vr46mZPk9scM8KDKfQUUjsNlTyYH6oM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731605716663,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$M5kLwZ1CooB_WfTOK7zGji4gcx9QagAU1bVo6OSHt78"}
]