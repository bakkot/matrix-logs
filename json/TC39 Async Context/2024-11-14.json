[
{"content":{"body":"If it's limited to scoped `using` and not general mutability, I think you can polyfill on top of `AsyncContext` and only instrument `await` and `yield` statements.","format":"org.matrix.custom.html","formatted_body":"If it's limited to scoped <code>using</code> and not general mutability, I think you can polyfill on top of <code>AsyncContext</code> and only instrument <code>await</code> and <code>yield</code> statements.","m.mentions":{},"msgtype":"m.text"},"ts":1731545289380,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5FFjaRYOlqrM_TGdG-s2UhuAAeaZD5zGySU7REbq2GA"},
{"content":{"body":"I know we talked about this before and I said otherwise, but I can't remember why I said it wasn't possible before.","m.mentions":{},"msgtype":"m.text"},"ts":1731545373024,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$WNX6R9dS-7uRHHYe3MvJ0ThVAIpbdoTvGQb21PoaOTA"},
{"content":{"body":"But I think that's the problem - it can't be limited to scoped `using` because of composability: you need to be able to write\n```javascript\nfunction enterSpan(id) {\n  const span = new Span({id, parent: currentSpan.get()});\n  span[Symbol.dispose] = currentSpan.enter(span)[Symbol.dispose];\n  log('new span', currentSpan.get());\n  return span;\n}\n```\nThat function gives no syntactic indication that it needs any extra transpilation... in fact, thinking about it further, it violates the principle that functions you call shouldn't be able to change your context.","format":"org.matrix.custom.html","formatted_body":"<p>But I think that's the problem - it can't be limited to scoped <code>using</code> because of composability: you need to be able to write</p>\n<pre><code class=\"language-javascript\">function enterSpan(id) {\n  const span = new Span({id, parent: currentSpan.get()});\n  span[Symbol.dispose] = currentSpan.enter(span)[Symbol.dispose];\n  log('new span', currentSpan.get());\n  return span;\n}\n</code></pre>\n<p>That function gives no syntactic indication that it needs any extra transpilation... in fact, thinking about it further, it violates the principle that functions you call shouldn't be able to change your context.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731557891411,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$h0_UTBu_6Elms7SP15kP3kGx_7D3dz3Nzg0sWaVClt0"},
{"content":{"body":"That example wouldn't be possible, but using `using span = enterSpan(…)` could be","format":"org.matrix.custom.html","formatted_body":"That example wouldn't be possible, but using <code>using span = enterSpan(…)</code> could be","m.mentions":{},"msgtype":"m.text"},"ts":1731558223628,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5dRj2yFit3G5DyDCY24ueWaG5FD9Uhbfzw_BDnI0glg"},
{"content":{"body":"how would you define `enterSpan` in that case?","format":"org.matrix.custom.html","formatted_body":"how would you define <code>enterSpan</code> in that case?","m.mentions":{},"msgtype":"m.text"},"ts":1731558244462,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$yiAV-UJEqBZa0Kka2fKkYfuxcaC7PvoqSnf-SdqEEpE"},
{"content":{"body":"The same?","m.mentions":{},"msgtype":"m.text"},"ts":1731558900339,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5MHXpoW8cvCI9q8cfj-Kq6LV0jGvNPPBv3PkFgmexbs"},
{"content":{"body":"The difference is you expected `enterSpan` to cause the mutation, and I'm expecting the `using span …` to do it","format":"org.matrix.custom.html","formatted_body":"The difference is you expected <code>enterSpan</code> to cause the mutation, and I'm expecting the <code>using span …</code> to do it","m.mentions":{},"msgtype":"m.text"},"ts":1731558956630,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$c0VS9APiCrFRuVR8iGyEuIacZurWxuyHL1S9kOt7OF4"},
{"content":{"body":"This is the `disposable[Symbol.enter]()` idea, but AIUI, it's a non-starter if it only works syntactically - i.e. you still need to be able to call it reflectively for composability.","format":"org.matrix.custom.html","formatted_body":"This is the <code>disposable[Symbol.enter]()</code> idea, but AIUI, it's a non-starter if it only works syntactically - i.e. you still need to be able to call it reflectively for composability.","m.mentions":{},"msgtype":"m.text"},"ts":1731603968737,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$21oKocjT9TwiFHJCESNAptqN5yGCEd3HwKEjrae9pZU"},
{"content":{"body":"Case in point: `Span[Symbol.enter]` would need to call `AsyncContext.Mutation[Symbol.enter]` transitively.","format":"org.matrix.custom.html","formatted_body":"Case in point: <code>Span[Symbol.enter]</code> would need to call <code>AsyncContext.Mutation[Symbol.enter]</code> transitively.","m.mentions":{},"msgtype":"m.text"},"ts":1731604032223,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$7RjfNtecBqVlD3YjGQuVuUvs1JmFcVhJEDcVApFZwe8"},
{"content":{"body":"and it couldn't use `using` syntax for that.","format":"org.matrix.custom.html","formatted_body":"and it couldn't use <code>using</code> syntax for that.","m.mentions":{},"msgtype":"m.text"},"ts":1731604040482,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Nr26RuIgg6inZixi0ZD6Kd12MVvdV6EShZH6TU2zB2I"},
{"content":{"body":" * Case in point: `Span.prototype[Symbol.enter]` would need to call `AsyncContext.Mutation.prototype[Symbol.enter]` transitively.","format":"org.matrix.custom.html","formatted_body":" * Case in point: <code>Span.prototype[Symbol.enter]</code> would need to call <code>AsyncContext.Mutation.prototype[Symbol.enter]</code> transitively.","m.mentions":{},"m.new_content":{"body":"Case in point: `Span.prototype[Symbol.enter]` would need to call `AsyncContext.Mutation.prototype[Symbol.enter]` transitively.","format":"org.matrix.custom.html","formatted_body":"Case in point: <code>Span.prototype[Symbol.enter]</code> would need to call <code>AsyncContext.Mutation.prototype[Symbol.enter]</code> transitively.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$7RjfNtecBqVlD3YjGQuVuUvs1JmFcVhJEDcVApFZwe8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731604066146,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$CQLEzQUG-xm0Lwqxp4KLWTfMzteOIf99T7rB6Jccbz8"},
{"content":{"body":"For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731605276589,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$_mfTilozkk-_vr46mZPk9scM8KDKfQUUjsNlTyYH6oM"},
{"content":{"body":" * For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext;\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n\n      AsyncContextSwap({ ...oldContext, [variable]: value });\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== oldContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_mfTilozkk-_vr46mZPk9scM8KDKfQUUjsNlTyYH6oM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731605542352,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$b-7zMmGFQWxb1kLUQP3W4k4fozntx-87SaJGc4Si2ZI"},
{"content":{"body":"And you can still leak _a little bit_, but:\n- `.run` is a hard boundary you cannot leak accross\n- if you leak, basically as soon as some other context ends you'll get an error","format":"org.matrix.custom.html","formatted_body":"<p>And you can still leak <em>a little bit</em>, but:</p>\n<ul>\n<li><code>.run</code> is a hard boundary you cannot leak accross</li>\n<li>if you leak, basically as soon as some other context ends you'll get an error</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731605590763,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$bbAIKKJGweotZXOHMncGpRK_ej8968iBoKEn173b0T4"},
{"content":{"body":"And the error could point to the stack trace of where you did `enter` without then disposing it","format":"org.matrix.custom.html","formatted_body":"And the error could point to the stack trace of where you did <code>enter</code> without then disposing it","m.mentions":{},"msgtype":"m.text"},"ts":1731605619991,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$i5_N32PJSNGr4nO7x5mB-2fAgEo1nNWIvrVbzMy4E4s"},
{"content":{"body":"I think you need to store two locals - one for `oldContext` and one for `updatedContext` and then line 15 wants to compare `current !== updatedContext`","format":"org.matrix.custom.html","formatted_body":"I think you need to store two locals - one for <code>oldContext</code> and one for <code>updatedContext</code> and then line 15 wants to compare <code>current !== updatedContext</code>","m.mentions":{},"msgtype":"m.text"},"ts":1731605657835,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$RovyKn93XqLwePGMTt6TpIyicFsyze6p3f-wlDw-7MQ"},
{"content":{"body":"True, right","m.mentions":{},"msgtype":"m.text"},"ts":1731605680577,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$N6SPfD00ZZC0x_aFncp9v9XV2ZkOAuJdJ3pP3S7o0RI"},
{"content":{"body":" * For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n\n  AsyncContextSwap({ ...oldContext, [this]: value });\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== oldContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_mfTilozkk-_vr46mZPk9scM8KDKfQUUjsNlTyYH6oM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731605716663,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$M5kLwZ1CooB_WfTOK7zGji4gcx9QagAU1bVo6OSHt78"},
{"content":{"body":" * True, right (updated)","m.mentions":{},"m.new_content":{"body":"True, right (updated)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$N6SPfD00ZZC0x_aFncp9v9XV2ZkOAuJdJ3pP3S7o0RI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731605820175,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$iIS2ngKbqNM8zlkFhTKG-rjvv7_Z91Zgf2y5x7yIlm0"},
{"content":{"body":" * For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n  const updatedContext = { ...oldContext, [this]: value };\n\n  AsyncContextSwap(updatedContext);\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== updatedContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n  const updatedContext = { ...oldContext, [this]: value };\n\n  AsyncContextSwap(updatedContext);\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== updatedContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"For `using` with `Symbol.enter`/`Symbol.dispose`, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?\n\n```js\nfunction enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n  const updatedContext = { ...oldContext, [this]: value };\n\n  AsyncContextSwap(updatedContext);\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== updatedContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () => {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>For <code>using</code> with <code>Symbol.enter</code>/<code>Symbol.dispose</code>, I don't think we need to enforce it syntactically. Does this provide enough guarantees, or are there still ways to mess up the context and not get an explicit error about it?</p>\n<pre><code class=\"language-js\">function enterWith(variable, value) {\n  let oldContext, updatedContext\n\n  return {\n    [Symbol.enter]() {\n      if (oldContext) throw new Error(\"Cannot enter twice\");\n      oldContext = AsyncContextSnapshot();\n      updatedContext = { ...oldContext, [variable]: value };\n\n      AsyncContextSwap(updatedContext);\n    },\n    [Symbol.dispose]() {\n      if (!oldContext) throw new Error(\"Cannot dispose before entering\");\n\n      const current = AsyncContextSnapshot();\n      if (current !== updatedContext) {\n        throw new Error(\"Cannot dispose, as it's not the current context\");\n      }\n\n      AsyncContextSwap(oldContext);\n    }\n  }\n}\n\nAsyncContext.Variable.prototype.run = function (value, callback) {\n  const oldContext = AsyncContextSnapshot();\n  const updatedContext = { ...oldContext, [this]: value };\n\n  AsyncContextSwap(updatedContext);\n  try {\n    return callback();\n  } finally {\n    const current = AsyncContextSnapshot();\n    AsyncContextSwap(oldContext);\n\n    if (current !== updatedContext) {\n      throw new Error(\".run ended before that its context was restored\");\n    }\n  }\n}\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  x2[Symbol.enter]();\n  // context: x2\n\n  x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n}\n\n\n{\n  // context: root\n\n  x1[Symbol.enter]();\n  // context: x1\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.dispose](); // error: \"Cannot dispose, as it's not the current context\"\n  })\n}\n\n{\n  // context: root\n\n  myVar.run(\"foo\", () =&gt; {\n    // context: foo\n\n    x1[Symbol.enter]();\n    // context: x1\n  }); // closes the foo context, then error: \".run ended before that its context was restored\"\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_mfTilozkk-_vr46mZPk9scM8KDKfQUUjsNlTyYH6oM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731605858040,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$9rrH2tkeN9XTi8BqekdsDxCGS2-me49uG65AZYMYWTg"},
{"content":{"body":"And then the idea is that\n```javascript\nasync function f() {\n  using _ = enterWith(v, 2);\n  await 1;\n}\n{\n  using _ = enterWith(v, 1);\n  f();\n}\n```\nwould work because the suspension would restore the entry context?  But if `f` were an ordinary function that leaked then the dispose after `f()` would fail.","format":"org.matrix.custom.html","formatted_body":"<p>And then the idea is that</p>\n<pre><code class=\"language-javascript\">async function f() {\n  using _ = enterWith(v, 2);\n  await 1;\n}\n{\n  using _ = enterWith(v, 1);\n  f();\n}\n</code></pre>\n<p>would work because the suspension would restore the entry context?  But if <code>f</code> were an ordinary function that leaked then the dispose after <code>f()</code> would fail.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1731605877551,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$2dnWZGrdzOICtRzcl0EFc-jajpNkg1t__aKZx63_XJA"},
{"content":{"body":"Yes and yes","m.mentions":{},"msgtype":"m.text"},"ts":1731605923663,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$zvWu3u9UPdNZbqm0VSBv6322y-BuTSl2Jj6-odH7IOk"},
{"content":{"body":"And any non-syntactic access to the protocol _should_ still at least be sound","format":"org.matrix.custom.html","formatted_body":"And any non-syntactic access to the protocol <em>should</em> still at least be sound","m.mentions":{},"msgtype":"m.text"},"ts":1731605930631,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$0u_0RRkDt9O8RltuLPg9V2dV8DHhrfGiK5uNUoogn1c"},
{"content":{"body":"And the whole program should also have a check at the end that checks you didn't forget to close anything","m.mentions":{},"msgtype":"m.text"},"ts":1731605954439,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$60sW9eXj4Wn3DGs0R9out_13ujM7EO5CWTOKphh_e9c"},
{"content":{"body":"I don't think you strictly need `Symbol.enter` for these checks.","format":"org.matrix.custom.html","formatted_body":"I don't think you strictly need <code>Symbol.enter</code> for these checks.","m.mentions":{},"msgtype":"m.text"},"ts":1731605956891,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$-xruXs8cEvGUGCNYZ7chgczUvm5nBSXIXunqXhTOV9I"},
{"content":{"body":"So that even a program that just does `x1[Symbol.enter]()` throws when it ends","format":"org.matrix.custom.html","formatted_body":"So that even a program that just does <code>x1[Symbol.enter]()</code> throws when it ends","m.mentions":{},"msgtype":"m.text"},"ts":1731605969648,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$b55rd5Y8Ecfd-ROV8paaIg9pBQegwKQ9ofYY1-udPqY"},
{"content":{"body":"though it would certainly be nicer to have","m.mentions":{},"msgtype":"m.text"},"ts":1731605989027,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$_P0BgY7YYlwghWLU-3LXEVKViXMeKN1sRkotnVyI-10"},
{"content":{"body":"> <@stephenhicks:matrix.org> I don't think you strictly need `Symbol.enter` for these checks.\n\nYeah, you can also just have two functions that you call to activate and deactivate the context","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$-xruXs8cEvGUGCNYZ7chgczUvm5nBSXIXunqXhTOV9I?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I don't think you strictly need <code>Symbol.enter</code> for these checks.</blockquote></mx-reply>Yeah, you can also just have two functions that you call to activate and deactivate the context","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$-xruXs8cEvGUGCNYZ7chgczUvm5nBSXIXunqXhTOV9I"}},"msgtype":"m.text"},"ts":1731605992019,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$Bdt-XLZqvjUKy5AemRc2D7n1JyTc0R1Wb-WB3j1IvD8"},
{"content":{"body":"So does `run` also verify that the \"outgoing\" context hasn't changed?","format":"org.matrix.custom.html","formatted_body":"So does <code>run</code> also verify that the \"outgoing\" context hasn't changed?","m.mentions":{},"msgtype":"m.text"},"ts":1731606219105,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$5Iq7qmxB5gYlJdkVIyNzbOutBPc_OiviwNbhN2mR5FU"},
{"content":{"body":"And is there any precedent for this sort of behavior where we allow the unsound thing to happen, but only throw an error later after it becomes more obvious?","m.mentions":{},"msgtype":"m.text"},"ts":1731606270690,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$S3_z83AZlqVPnIJ8itA-vs93a3r5MgplEZ8gFzaZAJ8"},
{"content":{"body":"> <@stephenhicks:matrix.org> So does `run` also verify that the \"outgoing\" context hasn't changed?\n\nYes, but still restores the correct one before throwing, so that try/catch+run always guarantees that a bad function can be run properly without it messing anything up","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$5Iq7qmxB5gYlJdkVIyNzbOutBPc_OiviwNbhN2mR5FU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br />So does <code>run</code> also verify that the \"outgoing\" context hasn't changed?</blockquote></mx-reply>Yes, but still restores the correct one before throwing, so that try/catch+run always guarantees that a bad function can be run properly without it messing anything up","m.relates_to":{"m.in_reply_to":{"event_id":"$5Iq7qmxB5gYlJdkVIyNzbOutBPc_OiviwNbhN2mR5FU"}},"msgtype":"m.text"},"ts":1731606314096,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$9cZjz9W7k_LOmWXw4-8e5uAFotl-CrUMyj0aEMo4g-8"},
{"content":{"body":"This would work fine with generators if `yield` had the same behavior as `await`; otherwise, it would effectively make a `yield` within an `enterWith` block be an error.","format":"org.matrix.custom.html","formatted_body":"This would work fine with generators if <code>yield</code> had the same behavior as <code>await</code>; otherwise, it would effectively make a <code>yield</code> within an <code>enterWith</code> block be an error.","m.mentions":{},"msgtype":"m.text"},"ts":1731606592680,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$mFE2PnIgFO2kyklP21P5nag4ifyksu4DcDISOiNuTiM"},
{"content":{"body":"unless the generator was fully iterated in a single outer context","m.mentions":{},"msgtype":"m.text"},"ts":1731606626234,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$NXWt4-2o7aclq9BNVkxqYi-fb9b27Z_Tb5pU2KJSNw0"},
{"content":{"body":"one could imagine a weird mode where the `yield` would somehow capture the mutations and replay them on top of the new re-entered context, but that doesn't seem reasonable","format":"org.matrix.custom.html","formatted_body":"one could imagine a weird mode where the <code>yield</code> would somehow capture the mutations and replay them on top of the new re-entered context, but that doesn't seem reasonable","m.mentions":{},"msgtype":"m.text"},"ts":1731606770552,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$-wmLvU7M-PsniaQDbO_V5mOQVIWsUE85CZlKK7AtNQU"},
{"content":{"body":" * one could imagine a weird solution where the `yield` would somehow capture the mutations and replay them on top of the new re-entered context, but that doesn't seem reasonable","format":"org.matrix.custom.html","formatted_body":" * one could imagine a weird solution where the <code>yield</code> would somehow capture the mutations and replay them on top of the new re-entered context, but that doesn't seem reasonable","m.mentions":{},"m.new_content":{"body":"one could imagine a weird solution where the `yield` would somehow capture the mutations and replay them on top of the new re-entered context, but that doesn't seem reasonable","format":"org.matrix.custom.html","formatted_body":"one could imagine a weird solution where the <code>yield</code> would somehow capture the mutations and replay them on top of the new re-entered context, but that doesn't seem reasonable","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$-wmLvU7M-PsniaQDbO_V5mOQVIWsUE85CZlKK7AtNQU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731606782804,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$uuwk3wBydrHg33e7zzxr8prM5VsMN7XT6iRKyP8yAyc"},
{"content":{"body":"Agree — I think we need to make yield capture/restore if we don't want to prevent enterWith from happening in the future ","msgtype":"m.text"},"ts":1731606911845,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$z9GvjRdDv_UZXiTPhV4b7AkS_DXwGLjmlOu9opURnP0"},
{"content":{"body":"This makes it impossible to implement dispatch-context iterator helpers as generators","m.mentions":{},"msgtype":"m.text"},"ts":1731606944104,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$_20K1s_nhJrL_XX5mBodqS-ZzrAp15bsaPEFJLQ1SMQ"},
{"content":{"body":" * This makes it impossible to implement dispatch-context iterator helpers (in userland) as generators","m.mentions":{},"m.new_content":{"body":"This makes it impossible to implement dispatch-context iterator helpers (in userland) as generators","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_20K1s_nhJrL_XX5mBodqS-ZzrAp15bsaPEFJLQ1SMQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731606999332,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$64vgiBBA28RCblZL6AoFP1v69nGTiQctGBqTEzTu7-o"},
{"content":{"body":"In a world with enterWith, could we do something like this with a metaproperty?\n\n```\nlet x = yield foo;\nusing _ = yield.nextCallerContext\n```","msgtype":"m.text"},"ts":1731607008813,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$H1pudCAXuej_QOy8d6LNY9ah1hPDKJ5pXx0ZZ1x8CD4"},
{"content":{"body":"Where yield.nextCallerContext gives you the context of the .next call","msgtype":"m.text"},"ts":1731607034078,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$gJ_IJyKmXHXz83AsCwKHYX2tceML_Se-JZUEKWLnRic"},
{"content":{"body":"And you can \"enter a snapshot\"","msgtype":"m.text"},"ts":1731607039623,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$lQfcKcRoi1XQsj6h4TkPPuqmB7BAQD-YvbwjShCUpik"},
{"content":{"body":"that seems feasible","m.mentions":{},"msgtype":"m.text"},"ts":1731607135680,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$pR_GQiPw7tnU7WQ9EDm02pdQVLmteW8Xw4ePfvJbY5w"},
{"content":{"body":"> <@stephenhicks:matrix.org> And is there any precedent for this sort of behavior where we allow the unsound thing to happen, but only throw an error later after it becomes more obvious?\n\nSo I guess that leaves ^ as my main concern?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$S3_z83AZlqVPnIJ8itA-vs93a3r5MgplEZ8gFzaZAJ8?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>And is there any precedent for this sort of behavior where we allow the unsound thing to happen, but only throw an error later after it becomes more obvious?</blockquote></mx-reply>So I guess that leaves ^ as my main concern?","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$S3_z83AZlqVPnIJ8itA-vs93a3r5MgplEZ8gFzaZAJ8"}},"msgtype":"m.text"},"ts":1731607931702,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$OvVLJT4V1nEVtKGyP3a8b048a0dbPvKnmV7V6fgZERA"},
{"content":{"body":"> <@stephenhicks:matrix.org> And is there any precedent for this sort of behavior where we allow the unsound thing to happen, but only throw an error later after it becomes more obvious?\n\n * So I guess that leaves ^ as my main concern - do we think this sort of thing could actually land?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$S3_z83AZlqVPnIJ8itA-vs93a3r5MgplEZ8gFzaZAJ8?via=igalia.com&amp;via=matrix.org&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>And is there any precedent for this sort of behavior where we allow the unsound thing to happen, but only throw an error later after it becomes more obvious?</blockquote></mx-reply> * So I guess that leaves ^ as my main concern - do we think this sort of thing could actually land?","m.mentions":{},"m.new_content":{"body":"So I guess that leaves ^ as my main concern - do we think this sort of thing could actually land?","format":"org.matrix.custom.html","formatted_body":"So I guess that leaves ^ as my main concern - do we think this sort of thing could actually land?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$OvVLJT4V1nEVtKGyP3a8b048a0dbPvKnmV7V6fgZERA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1731607957581,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$zM16ZHFGoR2SbPhU0uEfQpHdxQY5sSVLNP5-gdJMsQw"},
{"content":{"body":"I don't know, nothing comes immediately to my mind ","msgtype":"m.text"},"ts":1731607987984,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$SQ0zRSjbBECzxC2Ng4tEPWySvii-XzGyGJ4GqVrl-vg"},
{"content":{"body":"I'll look around ","msgtype":"m.text"},"ts":1731607992382,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$A2rgkmgY1QxNC5L4hHuwoH8IIJf8_-Ren0svNu7Z1No"},
{"content":{"body":"(and aside, I'm a little sad that I won't be able to rip out the over-complicated transpilation for generators)","m.mentions":{},"msgtype":"m.text"},"ts":1731608017777,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$xHicxRE12sO1YVTynza5udD36TDBVcNhSQCbqFl2x_k"},
{"content":{"body":"Instead of transpiling the generator, could you wrap it in a function that calls .next setting the original generator  context first?","msgtype":"m.text"},"ts":1731608304423,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$uiMvR73dtDJ0AGpz264E14VJK30AqLyR6fz8xU-MnBk"},
{"content":{"body":"That's an interesting idea, I'll need to look into that.","m.mentions":{},"msgtype":"m.text"},"ts":1731613768906,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$ELVKTS-CMafvggJINs77lcRMOV6hQ19aSwBIZdIOxmQ"},
{"content":{"body":"it's a little awkward for class methods, but I think we do something similar when downleveling async methods","m.mentions":{},"msgtype":"m.text"},"ts":1731613880524,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$QVVygEMLcquJIYrwkO1njceLRagrDE38ELZ3UYqdcC8"},
{"content":{"body":"I prototyped a quick proof-of-concept that it's possible to leverage most of an existing implementation and add a disposable `enterWith` by just replacing `AsyncContext.Variable` with a new implementation that indirects through a single \"real\" variable: https://gist.github.com/shicks/0cd7e9b06535793c137934cc52ed12ce","format":"org.matrix.custom.html","formatted_body":"I prototyped a quick proof-of-concept that it's possible to leverage most of an existing implementation and add a disposable <code>enterWith</code> by just replacing <code>AsyncContext.Variable</code> with a new implementation that indirects through a single \"real\" variable: https://gist.github.com/shicks/0cd7e9b06535793c137934cc52ed12ce","m.mentions":{},"msgtype":"m.text"},"ts":1731622791275,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$n5Z0m3EHwf5LidaxarAAzTyv5QOOt9_Syh5147rsv6k"}
]