[
{"content":{"body":"> <@stephenbelanger:matrix.org> The bad actor changing your value is only a problem if you explicitly give them the store and let them _do_ that. If you just keep your stores private this is not a real problem.\n\nI don't think that's right. Simply restoring a global snapshot is enough. If the subtask you're awaiting resolves its promise in a context that didn't derive from the one that was active when you called it, then you've lost your state even though it didn't have access to your variable.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$2cRrAvquMAjDmp8f8Qtw8XsCNtTKDdPBZxLsIJopl5g?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br />The bad actor changing your value is only a problem if you explicitly give them the store and let them <em>do</em> that. If you just keep your stores private this is not a real problem.</blockquote></mx-reply>I don't think that's right. Simply restoring a global snapshot is enough. If the subtask you're awaiting resolves its promise in a context that didn't derive from the one that was active when you called it, then you've lost your state even though it didn't have access to your variable.","m.relates_to":{"m.in_reply_to":{"event_id":"$2cRrAvquMAjDmp8f8Qtw8XsCNtTKDdPBZxLsIJopl5g"}},"msgtype":"m.text"},"ts":1716182073062,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$QLTat4mfRLndFhUeSBCQeEleVs8MbSKHOf1G2zI8vGE"},
{"content":{"body":"> <@stephenbelanger:matrix.org> So I would say the generally _encouraged_ way to do binds should be instance-scoped by default and global bind should only ever be a \"Are you _sure_ you know what you're doing?\" type of API for the power-user cases like module authors making sure their resource pool will not leak implementation details that would never be relevant to user code execution flow. Pool mechanisms I would say are almost universally okay to bind globally, but almost _every_ other scenario is a matter of opinion and should (at least in my opinion) probably not bind at all by default and always follow that path through internals because otherwise you end up with these strange flows like with async/await not flowing _through_ awaits the way most users seem to expect.\n\nI found this initially surprising, but I'm wondering if this actually makes more sense under the \"flow through await\" scenario. With preserve-around-await semantics and default registration-time binding, you end up needing a bunch of global binds just to get reasonable behavior. Again, my axiom here is that application code and library/framework code shouldn't need to be aware of each other's variables in order to do the right thing. With preserve-around-await, global binds seems like generally the thing you need to uphold that axiom. But with flow-through-await, I can imagine that maybe that's no longer required, provided you're not somehow picking up promises that came from vastly different contexts, which seems generally unlikely to happen in most common situations.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$SxFLvlchWjUPBQd5zSPM1Q9dG1DvgczqI68fWeUoA4Y?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br />So I would say the generally <em>encouraged</em> way to do binds should be instance-scoped by default and global bind should only ever be a \"Are you <em>sure</em> you know what you're doing?\" type of API for the power-user cases like module authors making sure their resource pool will not leak implementation details that would never be relevant to user code execution flow. Pool mechanisms I would say are almost universally okay to bind globally, but almost <em>every</em> other scenario is a matter of opinion and should (at least in my opinion) probably not bind at all by default and always follow that path through internals because otherwise you end up with these strange flows like with async/await not flowing <em>through</em> awaits the way most users seem to expect.</blockquote></mx-reply>I found this initially surprising, but I'm wondering if this actually makes more sense under the &quot;flow through await&quot; scenario. With preserve-around-await semantics and default registration-time binding, you end up needing a bunch of global binds just to get reasonable behavior. Again, my axiom here is that application code and library/framework code shouldn't need to be aware of each other's variables in order to do the right thing. With preserve-around-await, global binds seems like generally the thing you need to uphold that axiom. But with flow-through-await, I can imagine that maybe that's no longer required, provided you're not somehow picking up promises that came from vastly different contexts, which seems generally unlikely to happen in most common situations.","m.relates_to":{"m.in_reply_to":{"event_id":"$SxFLvlchWjUPBQd5zSPM1Q9dG1DvgczqI68fWeUoA4Y"}},"msgtype":"m.text"},"ts":1716182654023,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$jxiwguZQynsjlW7akUZE-LQPl7pHTv04qEgXEUxxEaI"},
{"content":{"body":"> <@stephenhicks:matrix.org> I don't think that's right. Simply restoring a global snapshot is enough. If the subtask you're awaiting resolves its promise in a context that didn't derive from the one that was active when you called it, then you've lost your state even though it didn't have access to your variable.\n\nWell, yes, global snapshots are bad, which is why they should be discouraged except when absolutely necessary. If you flow _through_ rather than _around_ things then it's _generally_ most advisable to actually bind-per store to only do graph reductions where needed whereas trying to bind _around_ things all over the place takes way more binds and is often inescapable.\n\nIt's a lot better to just let things flow _through_ by default and then provide some additional tools to reduce the graph where necessary. In general cases this is just the bind method, but for awaits it might make sense to have a store option to make it auto-bind on awaits or something like that. I _personally_ feel it makes a lot more sense for await binds to be an option rather than a default we need to find a way out of, but I don't care _too_ much either way, so long as the tools can do what is needed in a reasonable way.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$QLTat4mfRLndFhUeSBCQeEleVs8MbSKHOf1G2zI8vGE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I don't think that's right. Simply restoring a global snapshot is enough. If the subtask you're awaiting resolves its promise in a context that didn't derive from the one that was active when you called it, then you've lost your state even though it didn't have access to your variable.</blockquote></mx-reply><p>Well, yes, global snapshots are bad, which is why they should be discouraged except when absolutely necessary. If you flow <em>through</em> rather than <em>around</em> things then it's <em>generally</em> most advisable to actually bind-per store to only do graph reductions where needed whereas trying to bind <em>around</em> things all over the place takes way more binds and is often inescapable.</p>\n<p>It's a lot better to just let things flow <em>through</em> by default and then provide some additional tools to reduce the graph where necessary. In general cases this is just the bind method, but for awaits it might make sense to have a store option to make it auto-bind on awaits or something like that. I <em>personally</em> feel it makes a lot more sense for await binds to be an option rather than a default we need to find a way out of, but I don't care <em>too</em> much either way, so long as the tools can do what is needed in a reasonable way.</p>\n","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$QLTat4mfRLndFhUeSBCQeEleVs8MbSKHOf1G2zI8vGE"}},"msgtype":"m.text"},"ts":1716192904735,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$zo2q63z5s-5nDO2q0ccqU6T34VVmMj_sX5tvRNoMqRQ"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up _a lot_. https://github.com/nodejs/node/issues/53037\n\nI think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$SdyIZ6r2_ihXcnzN_x41LggncfjgfchOSA519QbiKII?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up <em>a lot</em>. https://github.com/nodejs/node/issues/53037</blockquote></mx-reply>I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$SdyIZ6r2_ihXcnzN_x41LggncfjgfchOSA519QbiKII"}},"msgtype":"m.text"},"ts":1716202721788,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$HLrN_aaBfCeoG8oX9S27Lwv_rmLpgDcdmpphBkO10q8"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up _a lot_. https://github.com/nodejs/node/issues/53037\n\n * I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$SdyIZ6r2_ihXcnzN_x41LggncfjgfchOSA519QbiKII?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up <em>a lot</em>. https://github.com/nodejs/node/issues/53037</blockquote></mx-reply> * I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem.","m.mentions":{},"m.new_content":{"body":"I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem.","format":"org.matrix.custom.html","formatted_body":"I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$HLrN_aaBfCeoG8oX9S27Lwv_rmLpgDcdmpphBkO10q8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716202799592,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$JYMuZ5Z1Y1siIYVMLKgZxLD1Bk_MhzinJOFj_sLeRqE"},
{"content":{"body":" * I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem on either semantics.","format":"org.matrix.custom.html","formatted_body":" * I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem on either semantics.","m.mentions":{},"m.new_content":{"body":"I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem on either semantics.","format":"org.matrix.custom.html","formatted_body":"I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem on either semantics.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$HLrN_aaBfCeoG8oX9S27Lwv_rmLpgDcdmpphBkO10q8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716202820115,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$R6LPOcd_7pwdp-dKG9gwL7FW4TsmQ3FI_su81p8cZE4"},
{"content":{"body":"It's not _just_ the timing of enabling PromiseHook. It is that the portion of an async function _before_ the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.","format":"org.matrix.custom.html","formatted_body":"It's not <em>just</em> the timing of enabling PromiseHook. It is that the portion of an async function <em>before</em> the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.","m.mentions":{},"msgtype":"m.text"},"ts":1716204508964,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$e81Db5rUOuJqELJkBTIAC6zEjDm0KHxPZuBX11_DxBM"},
{"content":{"body":"Regardless of timing inconsistencies, the user is clearly _expecting_ that they should be able to retrieve the context set after an await within the async function.","format":"org.matrix.custom.html","formatted_body":"Regardless of timing inconsistencies, the user is clearly <em>expecting</em> that they should be able to retrieve the context set after an await within the async function.","m.mentions":{},"msgtype":"m.text"},"ts":1716204552223,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$h2KaIsLwE4Hl6qB29VOYEBcQ035TNaMQ24coMP7Nokw"},
{"content":{"body":" * Regardless of timing inconsistencies, the user is clearly _expecting_ that they should be able to retrieve the context set after an await within the inner async function from the outer async function.","format":"org.matrix.custom.html","formatted_body":" * Regardless of timing inconsistencies, the user is clearly <em>expecting</em> that they should be able to retrieve the context set after an await within the inner async function from the outer async function.","m.mentions":{},"m.new_content":{"body":"Regardless of timing inconsistencies, the user is clearly _expecting_ that they should be able to retrieve the context set after an await within the inner async function from the outer async function.","format":"org.matrix.custom.html","formatted_body":"Regardless of timing inconsistencies, the user is clearly <em>expecting</em> that they should be able to retrieve the context set after an await within the inner async function from the outer async function.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$h2KaIsLwE4Hl6qB29VOYEBcQ035TNaMQ24coMP7Nokw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716204575571,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$kVDOwXdQEJRg1lzlaqhPNG7E91j813BUzHnDk3Wjdsk"},
{"content":{"body":" * Regardless of timing inconsistencies, the user is clearly _expecting_ that they should be able to retrieve the context set after an await within the inner async function from the outer async function (or module scope, in this case).","format":"org.matrix.custom.html","formatted_body":" * Regardless of timing inconsistencies, the user is clearly <em>expecting</em> that they should be able to retrieve the context set after an await within the inner async function from the outer async function (or module scope, in this case).","m.mentions":{},"m.new_content":{"body":"Regardless of timing inconsistencies, the user is clearly _expecting_ that they should be able to retrieve the context set after an await within the inner async function from the outer async function (or module scope, in this case).","format":"org.matrix.custom.html","formatted_body":"Regardless of timing inconsistencies, the user is clearly <em>expecting</em> that they should be able to retrieve the context set after an await within the inner async function from the outer async function (or module scope, in this case).","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$h2KaIsLwE4Hl6qB29VOYEBcQ035TNaMQ24coMP7Nokw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716204586420,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$HpjYwq6wn-LI0OTtF78tqt-oYyNu-N2WxuEzToIqXX4"},
{"content":{"body":"Wait, the init hook isn’t flowing out, it  is a third thing","msgtype":"m.text"},"ts":1716205494998,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$475vP7CEIpMywvJCxxlVVTWyyEPejjOGP99gd2sL7wA"},
{"content":{"body":"why are global snapshots bad?","m.mentions":{},"msgtype":"m.text"},"ts":1716206813609,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$JecVKy7Hc84-Jwa00K5xGM1jUrWUyMQ3DOn379Gymhs"},
{"content":{"body":"> <@stephenbelanger:matrix.org> It's not _just_ the timing of enabling PromiseHook. It is that the portion of an async function _before_ the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.\n\nThe proposal as it current stands is maintaining the lexical consistent value inside a async function body across `await` for `AsyncContext.Variable`, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$e81Db5rUOuJqELJkBTIAC6zEjDm0KHxPZuBX11_DxBM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>It's not <em>just</em> the timing of enabling PromiseHook. It is that the portion of an async function <em>before</em> the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.</blockquote></mx-reply>The proposal as it current stands is maintaining the lexical consistent value inside a async function body across <code>await</code> for <code>AsyncContext.Variable</code>, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$e81Db5rUOuJqELJkBTIAC6zEjDm0KHxPZuBX11_DxBM"}},"msgtype":"m.text"},"ts":1716206818230,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$S4OmJohIvXsYjwtstNmKt2U08TnljgtYw_7a4nhaKvQ"},
{"content":{"body":"> <@stephenbelanger:matrix.org> It happens to use `enterWith(...)` rather than `run(...)`, but the confusion around expected flow is effectively the same.\n\nWhat? I think \"restore after await\" would equally fix that bug (though agree that flows-out works here as well)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$34T1U8SBPGAPyFFzrz_w5rghdqi09MkQ55NAmD2aB2U?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>It happens to use <code>enterWith(...)</code> rather than <code>run(...)</code>, but the confusion around expected flow is effectively the same.</blockquote></mx-reply>What? I think \"restore after await\" would equally fix that bug (though agree that flows-out works here as well)","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$34T1U8SBPGAPyFFzrz_w5rghdqi09MkQ55NAmD2aB2U"}},"msgtype":"m.text"},"ts":1716207018862,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$apZZkW_2gYjA-4m32Y-6-uIBt1F2FXU8jHvIsDn4sDI"},
{"content":{"body":"> <@littledan:matrix.org> why are global snapshots bad?\n\nThey're not _bad_ exactly, just should not be the _default_ tool people reach for as it means they are influencing the graphs of _every_ store which, more often than not (in my experience with ALS users), is not actually what you want.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$JecVKy7Hc84-Jwa00K5xGM1jUrWUyMQ3DOn379Gymhs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>why are global snapshots bad?</blockquote></mx-reply>They're not <em>bad</em> exactly, just should not be the <em>default</em> tool people reach for as it means they are influencing the graphs of <em>every</em> store which, more often than not (in my experience with ALS users), is not actually what you want.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$JecVKy7Hc84-Jwa00K5xGM1jUrWUyMQ3DOn379Gymhs"}},"msgtype":"m.text"},"ts":1716207030202,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$maxkHHHzkGjIT8d5kSe8yXlF6aQp_yohjaWi9Ph5Jfg"},
{"content":{"body":"There should be clearly communicated difference between \"This is a universally applicable binding point.\" and \"I want _my_ context to flow in this way.\"","format":"org.matrix.custom.html","formatted_body":"There should be clearly communicated difference between \"This is a universally applicable binding point.\" and \"I want <em>my</em> context to flow in this way.\"","m.mentions":{},"msgtype":"m.text"},"ts":1716207109608,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ZtNzTz-ut4ep8vwzs41dcJzN8kuXdvxjzIeMq-PRgJ4"},
{"content":{"body":"> <@legendecas:matrix.org> The proposal as it current stands is maintaining the lexical consistent value inside a async function body across `await` for `AsyncContext.Variable`, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.\n\nYes, and I still don't understand why we are going for lexical scope given that, as far as I've seen, everyone is expecting it to follow execution flow.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$S4OmJohIvXsYjwtstNmKt2U08TnljgtYw_7a4nhaKvQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>The proposal as it current stands is maintaining the lexical consistent value inside a async function body across <code>await</code> for <code>AsyncContext.Variable</code>, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.</blockquote></mx-reply>Yes, and I still don't understand why we are going for lexical scope given that, as far as I've seen, everyone is expecting it to follow execution flow.","m.mentions":{"user_ids":["@legendecas:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$S4OmJohIvXsYjwtstNmKt2U08TnljgtYw_7a4nhaKvQ"}},"msgtype":"m.text"},"ts":1716207185227,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$vlfdjk1CMAf5HqiemxQ6Mzg0rocO2-Gt-gzLTYg1SOY"},
{"content":{"body":"I don't know what the concerns were with dynamic scope. Is information that captured somewhere?","m.mentions":{},"msgtype":"m.text"},"ts":1716207236978,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$4hs-fMNfaIE9vM00BbU-35zXsZViIDygHiJACk1Tll0"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Also, I'd _really_ appreciate if people reconsidered much of what James M Snell was was saying in https://github.com/nodejs/node/issues/46262. As far as people that understand the issues of context flow, he's one of very few others I'd trust to understand this stuff, having done a _bunch_ of work on the Cloudflare equivalent of AsyncLocalStorage.\n\nYeah, James was working closely with us when he filed that issue, and the current spec reflects what he is proposing with respect to rejection. I may have misunderstood his comments on resolving (as you can see in the thread); I guess we should get back in touch to understand his point of view better.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$uPJ_hI5OlXV2X00EMiZp2tF2NzTZYpHGJgaftzEaCDI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Also, I'd <em>really</em> appreciate if people reconsidered much of what <a href=\"https://matrix.to/#/@jasnell:matrix.org\">James M Snell</a> was was saying in https://github.com/nodejs/node/issues/46262. As far as people that understand the issues of context flow, he's one of very few others I'd trust to understand this stuff, having done a <em>bunch</em> of work on the Cloudflare equivalent of AsyncLocalStorage.</blockquote></mx-reply>Yeah, James was working closely with us when he filed that issue, and the current spec reflects what he is proposing with respect to rejection. I may have misunderstood his comments on resolving (as you can see in the thread); I guess we should get back in touch to understand his point of view better.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org","@jasnell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$uPJ_hI5OlXV2X00EMiZp2tF2NzTZYpHGJgaftzEaCDI"}},"msgtype":"m.text"},"ts":1716207292494,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$j1YFszWOIIwVa9MGNNMX-BqHhuZ3k3cbkRiPvzHgDQg"},
{"content":{"body":"> <@littledan:matrix.org> What? I think \"restore after await\" would equally fix that bug (though agree that flows-out works here as well)\n\nIt _is_ doing \"restore after await\" as that is how PromiseHook _works_. That's precisely the _problem_ here is that the user is assuming the context value will flow out of the awaited promises into the scope in which it was awaited.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$apZZkW_2gYjA-4m32Y-6-uIBt1F2FXU8jHvIsDn4sDI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>What? I think \"restore after await\" would equally fix that bug (though agree that flows-out works here as well)</blockquote></mx-reply>It <em>is</em> doing \"restore after await\" as that is how PromiseHook <em>works</em>. That's precisely the <em>problem</em> here is that the user is assuming the context value will flow out of the awaited promises into the scope in which it was awaited.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$apZZkW_2gYjA-4m32Y-6-uIBt1F2FXU8jHvIsDn4sDI"}},"msgtype":"m.text"},"ts":1716207302600,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$6KIISkPDT0j3vFpvl8-_Kqw7V7uW3Iq4qipU64mX3Dg"},
{"content":{"body":"we are definitely not doing lexical scope in general. There are definitely cases where some other relevant snapshot is used.","m.mentions":{},"msgtype":"m.text"},"ts":1716207330809,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$GRNUXxpr4Lehj9QNf1Kt4H5nnyw1mAt_1eoqD8q443Y"},
{"content":{"body":"people have suggested things like \"how about all callbacks just automatically close over the context\" and this is broken and not what is proposed.","m.mentions":{},"msgtype":"m.text"},"ts":1716207356666,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$PnYMDfAM5P9ByJwK54uGfRAlaYbGAIgds5llI4db75I"},
{"content":{"body":"Yeah, it seems like the flow is entirely reasonable with callbacks. I just don't understand why logically equivalent flows with promises and async/await don't flow in the same way. That seems extremely confusing to me.","m.mentions":{},"msgtype":"m.text"},"ts":1716207382298,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$-0wjcKwMdKie4FJNnMDzSnldrCnyX5ZAYq4hEjAD_IQ"},
{"content":{"body":"> <@littledan:matrix.org> people have suggested things like \"how about all callbacks just automatically close over the context\" and this is broken and not what is proposed.\n\nBroken in what way?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$PnYMDfAM5P9ByJwK54uGfRAlaYbGAIgds5llI4db75I?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>people have suggested things like &quot;how about all callbacks just automatically close over the context&quot; and this is broken and not what is proposed.</blockquote></mx-reply>Broken in what way?","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$PnYMDfAM5P9ByJwK54uGfRAlaYbGAIgds5llI4db75I"}},"msgtype":"m.text"},"ts":1716207404894,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$pFO9XnXv_Uf-eB_i8gDDIqVu5BqVjAlN64ZfQVqo8BA"},
{"content":{"body":"well, as you've been saying, sometimes it loses important information","m.mentions":{},"msgtype":"m.text"},"ts":1716207426600,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9Tm_h361JvEpywFBNsgT_L5DUH-PT_aUP9ymAs_GPy8"},
{"content":{"body":"Any callback for an async task _should_ flow context through it.","format":"org.matrix.custom.html","formatted_body":"Any callback for an async task <em>should</em> flow context through it.","m.mentions":{},"msgtype":"m.text"},"ts":1716207450809,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ADuD2zhjI3IYqzOM8fDSn7YluNjTb2TelLHmo2bgB5g"},
{"content":{"body":"but also sometimes the registration context *is* the most relevant one (often it's the only possible one)","format":"org.matrix.custom.html","formatted_body":"but also sometimes the registration context <em>is</em> the most relevant one (often it's the only possible one)","m.mentions":{},"msgtype":"m.text"},"ts":1716207467805,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$8xqTr_DQNUtfLnqgRBNjXeZx2me-J5w8CRCaU1_t1uY"},
{"content":{"body":"But to be clear I mean _through_ and not _around_, which is what binding does rather than just capturing at the edges.","format":"org.matrix.custom.html","formatted_body":"But to be clear I mean <em>through</em> and not <em>around</em>, which is what binding does rather than just capturing at the edges.","m.mentions":{},"msgtype":"m.text"},"ts":1716207497100,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$G9o1DS6F0hWaX6be8gfcSRmFXlApf6nf3QgMt7oh-2s"},
{"content":{"body":"In Node.js we intentionally push capturing to as _close_ to the edges as possible, meaning binding on the internal AsyncWrap type callbacks, so context flows through all the internals to get there.","format":"org.matrix.custom.html","formatted_body":"In Node.js we intentionally push capturing to as <em>close</em> to the edges as possible, meaning binding on the internal AsyncWrap type callbacks, so context flows through all the internals to get there.","m.mentions":{},"msgtype":"m.text"},"ts":1716207547472,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$dTGPAkhPi6HrRtMOVB078OeLZTb2MThugTkBFp4VAf0"},
{"content":{"body":"We could have bound the user callbacks directly instead, but then we would miss all that internal behaviour which may be relevant.","m.mentions":{},"msgtype":"m.text"},"ts":1716207572375,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$0BcmDp3HzrJbn8it-tRNreVlclMH3fzlrjJSZUqL7Uo"}
]