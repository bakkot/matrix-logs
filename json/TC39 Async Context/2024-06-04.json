[
{"content":{"body":"> <@littledan:matrix.org> Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?\n\nWould we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want to expose the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$lu6LNSBXwnCjvMJUvLpFTm_048LxX1wpJKaKGvgu9Ss?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?</blockquote></mx-reply>Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but <code>Promise</code>'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use <code>Snapshot.wrap</code> for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) <em>will</em> want to expose the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$lu6LNSBXwnCjvMJUvLpFTm_048LxX1wpJKaKGvgu9Ss"}},"msgtype":"m.text"},"ts":1717465802565,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$ayfl2nDiHXYZLWPLRWunPxs9ybLbuSrpbL1rErS8Kt4"},
{"content":{"body":"> <@littledan:matrix.org> Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?\n\n * Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$lu6LNSBXwnCjvMJUvLpFTm_048LxX1wpJKaKGvgu9Ss?via=igalia.com&amp;via=matrix.org&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?</blockquote></mx-reply> * Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but <code>Promise</code>'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use <code>Snapshot.wrap</code> for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) <em>will</em> want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.","m.mentions":{},"m.new_content":{"body":"Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.","format":"org.matrix.custom.html","formatted_body":"Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but <code>Promise</code>'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use <code>Snapshot.wrap</code> for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) <em>will</em> want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$ayfl2nDiHXYZLWPLRWunPxs9ybLbuSrpbL1rErS8Kt4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717465834971,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$h3ZxQt4hc1HkhmJKSFguiV7TaEXCWxNyGBDa4cJ9Fiw"},
{"content":{"body":"> <@stephenhicks:matrix.org> Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.\n\nYes, I think (at a minimum) we should do this for a number of Events, make an extra property which is an AsyncContext.Snapshot taken from when it was resolved. So this would be for \"lexical\" variables as well.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$ayfl2nDiHXYZLWPLRWunPxs9ybLbuSrpbL1rErS8Kt4?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but <code>Promise</code>'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use <code>Snapshot.wrap</code> for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) <em>will</em> want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.</blockquote></mx-reply>Yes, I think (at a minimum) we should do this for a number of Events, make an extra property which is an AsyncContext.Snapshot taken from when it was resolved. So this would be for \"lexical\" variables as well.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$ayfl2nDiHXYZLWPLRWunPxs9ybLbuSrpbL1rErS8Kt4"}},"msgtype":"m.text"},"ts":1717484158161,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$C1u5CbGBjgzkx-8CLCHj4EANHkdoQdYq1-PhzfJvtT8"},
{"content":{"body":"then APMs can patch all entry points to set event listeners to watch for a particular variable on that other snapshot and do something with it","m.mentions":{},"msgtype":"m.text"},"ts":1717484185870,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hHYFNTMTlV6eP5pMZAoaEiyweTKjGihudFXMD240K-0"},
{"content":{"body":"> <@legendecas:matrix.org> Yeah, agreed that two type of variables could be a solution. Did you have a chance talking about  `run(value, fn)` vs `set(value)` styles? Would it be too conservative to have strong scope guarantee in Web API designs?\n\nWe didn’t discuss this; I will mention it. But I don’t know if I can represent the arguments for set() well, and I am pretty sure this all would not form much of an interesting argument in favor of flow-through.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24Y2V8uZEQh0JhrnVs9nr-7WhauVSWI1XK7o8-eeoOJxU\">In reply to</a> <a href=\"https://matrix.to/#/@legendecas:matrix.org\">@legendecas:matrix.org</a><br>Yeah, agreed that two type of variables could be a solution. Did you have a chance talking about  <code>run(value, fn)</code> vs <code>set(value)</code> styles? Would it be too conservative to have strong scope guarantee in Web API designs?</blockquote></mx-reply>We didn’t discuss this; I will mention it. But I don’t know if I can represent the arguments for set() well, and I am pretty sure this all would not form much of an interesting argument in favor of flow-through.","m.relates_to":{"m.in_reply_to":{"event_id":"$Y2V8uZEQh0JhrnVs9nr-7WhauVSWI1XK7o8-eeoOJxU"}},"msgtype":"m.text"},"ts":1717485747196,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$MYELbC5cZoozKodumArQyL9simIm0yEP9TBiVmCnJ54"},
{"content":{"body":"> <@littledan:matrix.org> Yes, I think (at a minimum) we should do this for a number of Events, make an extra property which is an AsyncContext.Snapshot taken from when it was resolved. So this would be for \"lexical\" variables as well.\n\nI really dislike finding heterogeneous places to put the flow snapshot for each different system.  What about promises?  Assuming `await` and `Promise.then` are both lexically bound (which I mostly agree with - the former somewhat moreso than the latter, but overall I think it makes sense), there's no way to get at the promise's resolution context, and that's very relevant for understanding \"follows from\".  Would we expose some sort of static function to grab it?  `Promise.resolutionSnapshot(promise)`?  `Snapshot.fromPromise(promise)`?  Could something like that work more generally for other cases like events?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$C1u5CbGBjgzkx-8CLCHj4EANHkdoQdYq1-PhzfJvtT8?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Yes, I think (at a minimum) we should do this for a number of Events, make an extra property which is an AsyncContext.Snapshot taken from when it was resolved. So this would be for \"lexical\" variables as well.</blockquote></mx-reply>I really dislike finding heterogeneous places to put the flow snapshot for each different system.  What about promises?  Assuming <code>await</code> and <code>Promise.then</code> are both lexically bound (which I mostly agree with - the former somewhat moreso than the latter, but overall I think it makes sense), there's no way to get at the promise's resolution context, and that's very relevant for understanding \"follows from\".  Would we expose some sort of static function to grab it?  <code>Promise.resolutionSnapshot(promise)</code>?  <code>Snapshot.fromPromise(promise)</code>?  Could something like that work more generally for other cases like events?","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$C1u5CbGBjgzkx-8CLCHj4EANHkdoQdYq1-PhzfJvtT8"}},"msgtype":"m.text"},"ts":1717521370775,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$y0BAP99sm5Ufp_PbcOffd9_9y4lDR9v0Z3gvw6BHftI"},
{"content":{"body":"Assuming promises store their resolution context somewhere, is there a reasonable way to preserve it when operating on the promise?  I'm imagining wanting to wrap a function `fn` such that `Snapshot.from(p1.then(fn)) === Snapshot.from(p1)` and `Snapshot.from(p2.then(fn)) === Snapshot.from(p2)`... but without having access to the promise itself (just the resolved value), I don't see any way to write such a function.","format":"org.matrix.custom.html","formatted_body":"Assuming promises store their resolution context somewhere, is there a reasonable way to preserve it when operating on the promise?  I'm imagining wanting to wrap a function <code>fn</code> such that <code>Snapshot.from(p1.then(fn)) === Snapshot.from(p1)</code> and <code>Snapshot.from(p2.then(fn)) === Snapshot.from(p2)</code>... but without having access to the promise itself (just the resolved value), I don't see any way to write such a function.","m.mentions":{},"msgtype":"m.text"},"ts":1717521641848,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$G8tVHo2p9WyTMIhhEo1UpZN3pXUn4lK4zjnjyP4-Gv0"},
{"content":{"body":"This seems to still argue for something more general, like `Snapshot.cause` or something","format":"org.matrix.custom.html","formatted_body":"This seems to still argue for something more general, like <code>Snapshot.cause</code> or something","m.mentions":{},"msgtype":"m.text"},"ts":1717521710016,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$4ScSRJO4mDWm89kyv_iITb1XzciHTKq7hbdmTR1jb_c"},
{"content":{"body":" * This seems to still argue for something more general, like a nullary `Snapshot.cause()` or something","format":"org.matrix.custom.html","formatted_body":" * This seems to still argue for something more general, like a nullary <code>Snapshot.cause()</code> or something","m.mentions":{},"m.new_content":{"body":"This seems to still argue for something more general, like a nullary `Snapshot.cause()` or something","format":"org.matrix.custom.html","formatted_body":"This seems to still argue for something more general, like a nullary <code>Snapshot.cause()</code> or something","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$4ScSRJO4mDWm89kyv_iITb1XzciHTKq7hbdmTR1jb_c","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717521725523,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$qrj0eotZecUz4LGsxHux5_QqNMg5kUrFJTB-5pwbNfA"},
{"content":{"body":"(which then sends us back down the rabbit-hole of whether this is a stack of contexts or just a back-and-forth previous context, etc)","m.mentions":{},"msgtype":"m.text"},"ts":1717521769392,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$8NrcYxQr7E8AbTJR0WwxUeOccJ-wWuJW4QrFcs3EiGU"},
{"content":{"body":"Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked.","format":"org.matrix.custom.html","formatted_body":"Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding <code>wrap()</code> calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">Stephen Belanger</a> points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"ts":1717522060887,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$aMWZnmsU0jGKrxMVQtiIzr45GfUDaLaNBDCbBPNwsdY"},
{"content":{"body":" * Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate calls.","format":"org.matrix.custom.html","formatted_body":" * Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding <code>wrap()</code> calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">Stephen Belanger</a> points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate calls.","m.mentions":{},"m.new_content":{"body":"Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate calls.","format":"org.matrix.custom.html","formatted_body":"Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding <code>wrap()</code> calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">Stephen Belanger</a> points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate calls.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$aMWZnmsU0jGKrxMVQtiIzr45GfUDaLaNBDCbBPNwsdY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717522077528,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$ZU5PYpF6czm0O1kvtas8KCP2g7ii9qGNZ5C098vawE0"},
{"content":{"body":" * Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.","format":"org.matrix.custom.html","formatted_body":" * Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding <code>wrap()</code> calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">Stephen Belanger</a> points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.","m.mentions":{},"m.new_content":{"body":"Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.","format":"org.matrix.custom.html","formatted_body":"Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding <code>wrap()</code> calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">Stephen Belanger</a> points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$aMWZnmsU0jGKrxMVQtiIzr45GfUDaLaNBDCbBPNwsdY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717522088516,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$Ghx0UDU6lNfuPvtlUw8DW1kL6HJRSeaPvFI-_oKA8hE"},
{"content":{"body":"I suggest we come up with a common name to use for the instance method/getter where the originating context is","msgtype":"m.text"},"ts":1717535779031,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$a4TO1FfgvsbEno-UBgC72zMbuaFLFtQ1uXG4IJg-L-E"},
{"content":{"body":"My preference is that promises, in particular, would *not* maintain this information, at least at first. We could consider adding it later, but it might be more burden to implement than its value","format":"org.matrix.custom.html","formatted_body":"My preference is that promises, in particular, would <em>not</em> maintain this information, at least at first. We could consider adding it later, but it might be more burden to implement than its value","msgtype":"m.text"},"ts":1717535926533,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ZT_FkxRFCeYCdqJa7eoWVmN1xn7WeUnah53mJmXh8jA"},
{"content":{"body":"There are a few cases where it is very important to present this information, eg unhandled rejections","msgtype":"m.text"},"ts":1717535964365,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$eiBCDVGxqdtDC_dUMn35aLmrJh_30_7mhFQxL33apUg"},
{"content":{"body":"> <@stephenhicks:matrix.org> Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.\n\nYes, it is important to analyze this. How should we do so?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24aMWZnmsU0jGKrxMVQtiIzr45GfUDaLaNBDCbBPNwsdY\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding <code>wrap()</code> calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">Stephen Belanger</a> points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.</blockquote></mx-reply>Yes, it is important to analyze this. How should we do so?","m.relates_to":{"m.in_reply_to":{"event_id":"$aMWZnmsU0jGKrxMVQtiIzr45GfUDaLaNBDCbBPNwsdY"}},"msgtype":"m.text"},"ts":1717535994371,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$e2iT3qwqSKQTFz26tu8ee9mx46SKJ3aj7NH_Qdm6s88"},
{"content":{"body":"Right, so we already need to keep track of resolution context for rejected promises - do you anticipate it's much harder to keep for all promises?","m.mentions":{},"msgtype":"m.text"},"ts":1717536067020,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$bARgjTKrMe-3udHfKsid6n6_zdH07zCu_WeuJrVaB9M"},
{"content":{"body":"I don't know how far a common name will get us.  It only makes sense when you've got an object to look it up on.  What about mutation observers?  Its callback is passed an array and the observer itself, neither of which has a convenient place to hang a flow snapshot.","m.mentions":{},"msgtype":"m.text"},"ts":1717536236067,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$tD3aowf8NXPz__Ufmy7IbCh86GUsbPqvSYl6eZFnNVs"},
{"content":{"body":"The underlying concept of \"what was the context before this callback was run?\" is pretty general and has no specificity to events (though it's not quite the right concept for restoring the resolution context of promises...) - so it seems a bit unnatural to tie it to that.","m.mentions":{},"msgtype":"m.text"},"ts":1717536342630,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$EilmNGARqGZTqSzVaRhPWll2eorgbVfOZ7ztnwpw1zw"},
{"content":{"body":"> <@stephenhicks:matrix.org> I don't know how far a common name will get us.  It only makes sense when you've got an object to look it up on.  What about mutation observers?  Its callback is passed an array and the observer itself, neither of which has a convenient place to hang a flow snapshot.\n\nIsn’t it an array of objects? Each of these objects could have the property","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24tD3aowf8NXPz__Ufmy7IbCh86GUsbPqvSYl6eZFnNVs\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I don't know how far a common name will get us.  It only makes sense when you've got an object to look it up on.  What about mutation observers?  Its callback is passed an array and the observer itself, neither of which has a convenient place to hang a flow snapshot.</blockquote></mx-reply>Isn’t it an array of objects? Each of these objects could have the property","m.relates_to":{"m.in_reply_to":{"event_id":"$tD3aowf8NXPz__Ufmy7IbCh86GUsbPqvSYl6eZFnNVs"}},"msgtype":"m.text"},"ts":1717536468707,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$qWSeT16SegcoNcMgmR9Atv-MRglvYz7s5qmm269k-Zc"},
{"content":{"body":"> <@stephenhicks:matrix.org> Right, so we already need to keep track of resolution context for rejected promises - do you anticipate it's much harder to keep for all promises?\n\nthe way this currently works in the spec and in V8 is that an embedder function is called *synchronously* when the unhandled rejection happens","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$bARgjTKrMe-3udHfKsid6n6_zdH07zCu_WeuJrVaB9M?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Right, so we already need to keep track of resolution context for rejected promises - do you anticipate it&#39;s much harder to keep for all promises?</blockquote></mx-reply>the way this currently works in the spec and in V8 is that an embedder function is called <em>synchronously</em> when the unhandled rejection happens","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$bARgjTKrMe-3udHfKsid6n6_zdH07zCu_WeuJrVaB9M"}},"msgtype":"m.text"},"ts":1717536552071,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$o6Da8Kg3P8QUaMHIbc_yKSk3KmL0LZ-q-0YpbnKFzoE"},
{"content":{"body":"and that function then enqueues a task on the event loop that fires the event","m.mentions":{},"msgtype":"m.text"},"ts":1717536564155,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$ce6SjdPw-zU0gl14AVHFvhJ3WuIKG4x3cGHsx3IvcdE"},
{"content":{"body":"so it happens outside of the JS engine","m.mentions":{},"msgtype":"m.text"},"ts":1717536572266,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$wPGSMT47G_aoBnz3aLaCUFVjkISEZ9DLIcGamxw85as"},
{"content":{"body":"> <@stephenhicks:matrix.org> Right, so we already need to keep track of resolution context for rejected promises - do you anticipate it's much harder to keep for all promises?\n\nI would sort of assume that, for built-in methods, we would generally use the “registration-time” context for that. But then this makes me wonder if we should generally return to the Node.js ALS semantics where rejection is always reported to the allocation-time context…. Now I confused myself ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24bARgjTKrMe-3udHfKsid6n6_zdH07zCu_WeuJrVaB9M\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Right, so we already need to keep track of resolution context for rejected promises - do you anticipate it's much harder to keep for all promises?</blockquote></mx-reply>I would sort of assume that, for built-in methods, we would generally use the “registration-time” context for that. But then this makes me wonder if we should generally return to the Node.js ALS semantics where rejection is always reported to the allocation-time context…. Now I confused myself","m.relates_to":{"m.in_reply_to":{"event_id":"$bARgjTKrMe-3udHfKsid6n6_zdH07zCu_WeuJrVaB9M"}},"msgtype":"m.text"},"ts":1717536604402,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$V2Abv6FAUdbekW3NfFtuMVKB28IX4rwQQATlwGJK4-k"},
{"content":{"body":"> <@abotella:igalia.com> the way this currently works in the spec and in V8 is that an embedder function is called *synchronously* when the unhandled rejection happens\n\nHow does this collect the right context? What if no JS is on the stack?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG%3Amatrix.org/%24o6Da8Kg3P8QUaMHIbc_yKSk3KmL0LZ-q-0YpbnKFzoE\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>the way this currently works in the spec and in V8 is that an embedder function is called <em>synchronously</em> when the unhandled rejection happens</blockquote></mx-reply>How does this collect the right context? What if no JS is on the stack?","m.relates_to":{"m.in_reply_to":{"event_id":"$o6Da8Kg3P8QUaMHIbc_yKSk3KmL0LZ-q-0YpbnKFzoE"}},"msgtype":"m.text"},"ts":1717536653314,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$p0TqhZfCV0arDfJE3jNR1qEbgaS49q0voUetf_P99Pg"},
{"content":{"body":"for a promise-returning web API, you mean?","m.mentions":{},"msgtype":"m.text"},"ts":1717536705966,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$9BlNJtuZlO5QfsNvCU9wDDoAwHscOgvRZfSK61xEeJA"},
{"content":{"body":"the context would be set when rejecting the promise","m.mentions":{},"msgtype":"m.text"},"ts":1717536720878,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$8iuUfnYBPNe3XUmbL_nQnM55jr2GubRyhtvEVRjbc10"}
]