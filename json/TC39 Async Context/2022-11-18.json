[
{"content":{"org.matrix.msc1767.message":[{"body":"Yes, rbuckton was excited about the proposal in June 2020: https://github.com/tc39/notes/blob/3937a973f1903550e33ccebd9bf18f90dd7d5b7c/meetings/2020-06/june-3.md#async-context","mimetype":"text/plain"},{"body":"Yes, <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a> was excited about the proposal in June 2020: https://github.com/tc39/notes/blob/3937a973f1903550e33ccebd9bf18f90dd7d5b7c/meetings/2020-06/june-3.md#async-context","mimetype":"text/html"}],"body":"Yes, rbuckton was excited about the proposal in June 2020: https://github.com/tc39/notes/blob/3937a973f1903550e33ccebd9bf18f90dd7d5b7c/meetings/2020-06/june-3.md#async-context","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Yes, <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a> was excited about the proposal in June 2020: https://github.com/tc39/notes/blob/3937a973f1903550e33ccebd9bf18f90dd7d5b7c/meetings/2020-06/june-3.md#async-context"},"ts":1668737665684,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$hfWJydk0qEOHBvrFF5OsWYPMfZyKi8skHIvOpXGoK48"},
{"content":{"org.matrix.msc1767.message":[{"body":"littledan: I don't have a full grasp of React's concurrent priorities. How are you imagining this will help?","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a>: I don't have a full grasp of React's concurrent priorities. How are you imagining this will help?","mimetype":"text/html"}],"body":"littledan: I don't have a full grasp of React's concurrent priorities. How are you imagining this will help?","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a>: I don't have a full grasp of React's concurrent priorities. How are you imagining this will help?"},"ts":1668747852280,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$DAmvz4GNCcXm8aB_fqztPyXAJCrqLiRNiWD9v_8LQAQ"},
{"content":{"org.matrix.msc1767.text":"Slides are updated besides that.","body":"Slides are updated besides that.","msgtype":"m.text"},"ts":1668750473759,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$xdVxiXxExelNrBZSephh4yJUeOpaW-9tb1c3lB719Rw"},
{"content":{"org.matrix.msc1767.message":[{"body":"How does this compare to `AsyncLocalStorage` in NodeJS? I've used that to good effect so far: https://nodejs.org/dist/latest-v19.x/docs/api/async_context.html#class-asynclocalstorage","mimetype":"text/plain"},{"body":"How does this compare to <code>AsyncLocalStorage</code> in NodeJS? I've used that to good effect so far: https://nodejs.org/dist/latest-v19.x/docs/api/async_context.html#class-asynclocalstorage","mimetype":"text/html"}],"body":"How does this compare to `AsyncLocalStorage` in NodeJS? I've used that to good effect so far: https://nodejs.org/dist/latest-v19.x/docs/api/async_context.html#class-asynclocalstorage","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"How does this compare to <code>AsyncLocalStorage</code> in NodeJS? I've used that to good effect so far: https://nodejs.org/dist/latest-v19.x/docs/api/async_context.html#class-asynclocalstorage"},"ts":1668775699249,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tVlxNS_G-KCIBM2n2LPHP7GID4IgfkGXBzaSMIl1zkA"},
{"content":{"body":"> <@jridgewell:matrix.org> littledan: I don't have a full grasp of React's concurrent priorities. How are you imagining this will help?\n\nI don’t have a full grasp of it either, but Yoav mentioned it in his talk too. Maybe ask Seb?","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy%3Amatrix.org/%24DAmvz4GNCcXm8aB_fqztPyXAJCrqLiRNiWD9v_8LQAQ\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br><a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a>: I don't have a full grasp of React's concurrent priorities. How are you imagining this will help?</blockquote></mx-reply>I don’t have a full grasp of it either, but Yoav mentioned it in his talk too. Maybe ask Seb?","m.relates_to":{"m.in_reply_to":{"event_id":"$DAmvz4GNCcXm8aB_fqztPyXAJCrqLiRNiWD9v_8LQAQ"}}},"ts":1668778085574,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$tDGqOVsrDcV1_2LxCbwQ5UxAyd5N8K1GK2lpnporVog"},
{"content":{"body":"> <@rbuckton:matrix.org> How does this compare to `AsyncLocalStorage` in NodeJS? I've used that to good effect so far: https://nodejs.org/dist/latest-v19.x/docs/api/async_context.html#class-asynclocalstorage\n\nIt is hoped to be roughly equivalent in expressiveness for normal usage, just omitting some weird misfeatures and simplifying the API surface.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy%3Amatrix.org/%24tVlxNS_G-KCIBM2n2LPHP7GID4IgfkGXBzaSMIl1zkA\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>How does this compare to <code>AsyncLocalStorage</code> in NodeJS? I've used that to good effect so far: https://nodejs.org/dist/latest-v19.x/docs/api/async_context.html#class-asynclocalstorage</blockquote></mx-reply>It is hoped to be roughly equivalent in expressiveness for normal usage, just omitting some weird misfeatures and simplifying the API surface.","m.relates_to":{"m.in_reply_to":{"event_id":"$tVlxNS_G-KCIBM2n2LPHP7GID4IgfkGXBzaSMIl1zkA"}}},"ts":1668778166460,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$sq5IkDnFoH0C3Y_zHoD1raDklllDivZChXZsaMrPHSY"},
{"content":{"org.matrix.msc1767.text":"Misfeatures?","body":"Misfeatures?","msgtype":"m.text"},"ts":1668780034386,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4crRUrpUi27idz3krT3W-ZV4RDrn69lbNRMJy_Sg4iU"},
{"content":{"org.matrix.msc1767.message":[{"body":"I'm curious what you're categorizing as misfeatures? `exit` is a convenience method that is shorthand for `run(undefined, ...)`,  `enterWith` is a convenient way to set the context value without introducing a closure (and thus avoiding TCP issues), and `disable` is a convenience wrapper for `enterWith(undefined)`.","mimetype":"text/plain"},{"body":"I'm curious what you're categorizing as misfeatures? <code>exit</code> is a convenience method that is shorthand for <code>run(undefined, ...)</code>,  <code>enterWith</code> is a convenient way to set the context value without introducing a closure (and thus avoiding TCP issues), and <code>disable</code> is a convenience wrapper for <code>enterWith(undefined)</code>.","mimetype":"text/html"}],"body":"I'm curious what you're categorizing as misfeatures? `exit` is a convenience method that is shorthand for `run(undefined, ...)`,  `enterWith` is a convenient way to set the context value without introducing a closure (and thus avoiding TCP issues), and `disable` is a convenience wrapper for `enterWith(undefined)`.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"I'm curious what you're categorizing as misfeatures? <code>exit</code> is a convenience method that is shorthand for <code>run(undefined, ...)</code>,  <code>enterWith</code> is a convenient way to set the context value without introducing a closure (and thus avoiding TCP issues), and <code>disable</code> is a convenience wrapper for <code>enterWith(undefined)</code>."},"ts":1668780402238,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8iwn3Kox8kyMoZggtV9mCkPxEwPWLBap0IOQUxOvbYs"},
{"content":{"org.matrix.msc1767.text":"The current proposal is seeking for a minimum API that can provide the necessary infrastructure in the language for async context propagation. Compared to the Node.js AsyncLocalStorage, they are motivated by the same requirement so they should be very similar.","body":"The current proposal is seeking for a minimum API that can provide the necessary infrastructure in the language for async context propagation. Compared to the Node.js AsyncLocalStorage, they are motivated by the same requirement so they should be very similar.","msgtype":"m.text"},"ts":1668781382662,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$O-QQUTQIjh6YJ1KOh0UIb0ZWbeAaJb8e2Thgul3-M2w"},
{"content":{"org.matrix.msc1767.message":[{"body":"For comparison, .NET has two ways of doing something similar:\n\n`AsyncLocal<T>` (https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-7.0) has a `.Value` property (analogous to Node's `AsyncLocalStorage.getStore()` and `.enterWith(store)` \n\n`ExecutionContext` (https://learn.microsoft.com/en-us/dotnet/api/system.threading.executioncontext.run?view=netframework-4.8) has `.Run()` (analogous to Node's `AsyncLocalStorage.run()`) and can be used with `LogicalCallContext` (https://learn.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.logicalcallcontext.getdata?view=netframework-4.8) to get and set values associated with the logical call flow. It also has a `Dispose`, which is analogous to Node's `.disable()`.\n\nIn addition, `ExecutionContext` allows you to capture the current context, copy it into a new context, and suppress and restore the context across async invocations (using `AsyncFlowControl`).","mimetype":"text/plain"},{"body":"<p>For comparison, .NET has two ways of doing something similar:</p>\n<p><code>AsyncLocal&lt;T&gt;</code> (https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-7.0) has a <code>.Value</code> property (analogous to Node's <code>AsyncLocalStorage.getStore()</code> and <code>.enterWith(store)</code></p>\n<p><code>ExecutionContext</code> (https://learn.microsoft.com/en-us/dotnet/api/system.threading.executioncontext.run?view=netframework-4.8) has <code>.Run()</code> (analogous to Node's <code>AsyncLocalStorage.run()</code>) and can be used with <code>LogicalCallContext</code> (https://learn.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.logicalcallcontext.getdata?view=netframework-4.8) to get and set values associated with the logical call flow. It also has a <code>Dispose</code>, which is analogous to Node's <code>.disable()</code>.</p>\n<p>In addition, <code>ExecutionContext</code> allows you to capture the current context, copy it into a new context, and suppress and restore the context across async invocations (using <code>AsyncFlowControl</code>).</p>\n","mimetype":"text/html"}],"body":"For comparison, .NET has two ways of doing something similar:\n\n`AsyncLocal<T>` (https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-7.0) has a `.Value` property (analogous to Node's `AsyncLocalStorage.getStore()` and `.enterWith(store)` \n\n`ExecutionContext` (https://learn.microsoft.com/en-us/dotnet/api/system.threading.executioncontext.run?view=netframework-4.8) has `.Run()` (analogous to Node's `AsyncLocalStorage.run()`) and can be used with `LogicalCallContext` (https://learn.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.logicalcallcontext.getdata?view=netframework-4.8) to get and set values associated with the logical call flow. It also has a `Dispose`, which is analogous to Node's `.disable()`.\n\nIn addition, `ExecutionContext` allows you to capture the current context, copy it into a new context, and suppress and restore the context across async invocations (using `AsyncFlowControl`).","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>For comparison, .NET has two ways of doing something similar:</p>\n<p><code>AsyncLocal&lt;T&gt;</code> (https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-7.0) has a <code>.Value</code> property (analogous to Node's <code>AsyncLocalStorage.getStore()</code> and <code>.enterWith(store)</code></p>\n<p><code>ExecutionContext</code> (https://learn.microsoft.com/en-us/dotnet/api/system.threading.executioncontext.run?view=netframework-4.8) has <code>.Run()</code> (analogous to Node's <code>AsyncLocalStorage.run()</code>) and can be used with <code>LogicalCallContext</code> (https://learn.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.logicalcallcontext.getdata?view=netframework-4.8) to get and set values associated with the logical call flow. It also has a <code>Dispose</code>, which is analogous to Node's <code>.disable()</code>.</p>\n<p>In addition, <code>ExecutionContext</code> allows you to capture the current context, copy it into a new context, and suppress and restore the context across async invocations (using <code>AsyncFlowControl</code>).</p>\n"},"ts":1668781593429,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$op0ahPfwO5pXcNMnODRDZgC2pHPcPHfRNBHeHKLRfic"},
{"content":{"org.matrix.msc1767.message":[{"body":"And `AsyncLocal<T>` is really just a convenient wrapper over `ExecutionContext`","mimetype":"text/plain"},{"body":"And <code>AsyncLocal&lt;T&gt;</code> is really just a convenient wrapper over <code>ExecutionContext</code>","mimetype":"text/html"}],"body":"And `AsyncLocal<T>` is really just a convenient wrapper over `ExecutionContext`","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"And <code>AsyncLocal&lt;T&gt;</code> is really just a convenient wrapper over <code>ExecutionContext</code>"},"ts":1668781655680,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eNVW5x_fdUzYadyKWg0F2TPkhRVziCxNnAcNN9EORDE"},
{"content":{"org.matrix.msc1767.message":[{"body":"If anything, I find Node's `AsyncLocalStorage` to be somewhat limited.","mimetype":"text/plain"},{"body":"If anything, I find Node's <code>AsyncLocalStorage</code> to be somewhat limited.","mimetype":"text/html"}],"body":"If anything, I find Node's `AsyncLocalStorage` to be somewhat limited.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"If anything, I find Node's <code>AsyncLocalStorage</code> to be somewhat limited."},"ts":1668781701897,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FhfyMjmxEQ7vhszJ-EpA8mMBtMcfAtnIgIEdLgRe4kU"},
{"content":{"org.matrix.msc1767.message":[{"body":"I'm also curious what the motivation is for `.wrap`? It seems like another convenience method, so I'm interested to know why that is prioritized over others.","mimetype":"text/plain"},{"body":"I'm also curious what the motivation is for <code>.wrap</code>? It seems like another convenience method, so I'm interested to know why that is prioritized over others.","mimetype":"text/html"}],"body":"I'm also curious what the motivation is for `.wrap`? It seems like another convenience method, so I'm interested to know why that is prioritized over others.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"I'm also curious what the motivation is for <code>.wrap</code>? It seems like another convenience method, so I'm interested to know why that is prioritized over others."},"ts":1668781829684,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZNt-ea21zhESvTjTljFLbl1YTsFFFAKSvxgQFjmUC0w"},
{"content":{"org.matrix.msc1767.message":[{"body":"I can see not having `.exit()` and `.disable()`, but `.enterWith()` isn't a convenience method, it's a core capability.","mimetype":"text/plain"},{"body":"I can see not having <code>.exit()</code> and <code>.disable()</code>, but <code>.enterWith()</code> isn't a convenience method, it's a core capability.","mimetype":"text/html"}],"body":"I can see not having `.exit()` and `.disable()`, but `.enterWith()` isn't a convenience method, it's a core capability.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"I can see not having <code>.exit()</code> and <code>.disable()</code>, but <code>.enterWith()</code> isn't a convenience method, it's a core capability."},"ts":1668781912206,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xFg7fYmVZW_GLDZNq1QwTWwYT3EPBWJiYoywArDXM-M"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> I'm also curious what the motivation is for `.wrap`? It seems like another convenience method, so I'm interested to know why that is prioritized over others.\n\nIt snapshots the current context into the wrapped function, and restores it when the wrapped function is been invoked. It is part of the basic block to be able to defining userland queues with async context.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$ZNt-ea21zhESvTjTljFLbl1YTsFFFAKSvxgQFjmUC0w?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I'm also curious what the motivation is for <code>.wrap</code>? It seems like another convenience method, so I'm interested to know why that is prioritized over others.</blockquote></mx-reply>It snapshots the current context into the wrapped function, and restores it when the wrapped function is been invoked. It is part of the basic block to be able to defining userland queues with async context.","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> I'm also curious what the motivation is for `.wrap`? It seems like another convenience method, so I'm interested to know why that is prioritized over others.\n\nIt snapshots the current context into the wrapped function, and restores it when the wrapped function is been invoked. It is part of the basic block to be able to defining userland queues with async context.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$ZNt-ea21zhESvTjTljFLbl1YTsFFFAKSvxgQFjmUC0w?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I'm also curious what the motivation is for <code>.wrap</code>? It seems like another convenience method, so I'm interested to know why that is prioritized over others.</blockquote></mx-reply>It snapshots the current context into the wrapped function, and restores it when the wrapped function is been invoked. It is part of the basic block to be able to defining userland queues with async context.","m.relates_to":{"m.in_reply_to":{"event_id":"$ZNt-ea21zhESvTjTljFLbl1YTsFFFAKSvxgQFjmUC0w"}}},"ts":1668782019133,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$DIO2NIqRs5UPB7mXHqQLFhQI_2pSfKfU9epz8TnN2eU"},
{"content":{"org.matrix.msc1767.message":[{"body":"Actually, I'll retract that last statement somewhat. My concern is about async context mutability without violating TCP, but that can be achieved via indirection, i.e. `context.run({ value: 1 }, () => { context.get().value++ })`","mimetype":"text/plain"},{"body":"Actually, I'll retract that last statement somewhat. My concern is about async context mutability without violating TCP, but that can be achieved via indirection, i.e. <code>context.run({ value: 1 }, () =&gt; { context.get().value++ })</code>","mimetype":"text/html"}],"body":"Actually, I'll retract that last statement somewhat. My concern is about async context mutability without violating TCP, but that can be achieved via indirection, i.e. `context.run({ value: 1 }, () => { context.get().value++ })`","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Actually, I'll retract that last statement somewhat. My concern is about async context mutability without violating TCP, but that can be achieved via indirection, i.e. <code>context.run({ value: 1 }, () =&gt; { context.get().value++ })</code>"},"ts":1668782073883,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oVsiRy4OUAR2339Bc6eZR_p7NZe-jUuJZiY2tl4lRBA"},
{"content":{"org.matrix.msc1767.message":[{"body":"I don't disagree with its utility, but It's still a convenience method. You could achieve the same in userland with only `.run()` and `.get()`:\n\n```js\nfunction wrap(ctx, cb) {\n  const store = ctx.get();\n  return () => ctx.run(store, cb);\n}\n```","mimetype":"text/plain"},{"body":"<p>I don't disagree with its utility, but It's still a convenience method. You could achieve the same in userland with only <code>.run()</code> and <code>.get()</code>:</p>\n<pre><code class=\"language-js\">function wrap(ctx, cb) {\n  const store = ctx.get();\n  return () =&gt; ctx.run(store, cb);\n}\n</code></pre>\n","mimetype":"text/html"}],"body":"I don't disagree with its utility, but It's still a convenience method. You could achieve the same in userland with only `.run()` and `.get()`:\n\n```js\nfunction wrap(ctx, cb) {\n  const store = ctx.get();\n  return () => ctx.run(store, cb);\n}\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>I don't disagree with its utility, but It's still a convenience method. You could achieve the same in userland with only <code>.run()</code> and <code>.get()</code>:</p>\n<pre><code class=\"language-js\">function wrap(ctx, cb) {\n  const store = ctx.get();\n  return () =&gt; ctx.run(store, cb);\n}\n</code></pre>\n"},"ts":1668782195982,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$uZroGQ2kwuHSnVXq6oRO6X-3C0WqoGhTD-XwdpZQ2Uc"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> I don't disagree with its utility, but It's still a convenience method. You could achieve the same in userland with only `.run()` and `.get()`:\n> \n> ```js\n> function wrap(ctx, cb) {\n>   const store = ctx.get();\n>   return () => ctx.run(store, cb);\n> }\n> ```\n\nI don't think the `.wrap` in the proposal behaves the same in this example.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$uZroGQ2kwuHSnVXq6oRO6X-3C0WqoGhTD-XwdpZQ2Uc?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>I don't disagree with its utility, but It's still a convenience method. You could achieve the same in userland with only <code>.run()</code> and <code>.get()</code>:</p>\n<pre><code class=\"language-js\">function wrap(ctx, cb) {\n  const store = ctx.get();\n  return () =&gt; ctx.run(store, cb);\n}\n</code></pre>\n</blockquote></mx-reply>I don't think the <code>.wrap</code> in the proposal behaves the same in this example.","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> I don't disagree with its utility, but It's still a convenience method. You could achieve the same in userland with only `.run()` and `.get()`:\n> \n> ```js\n> function wrap(ctx, cb) {\n>   const store = ctx.get();\n>   return () => ctx.run(store, cb);\n> }\n> ```\n\nI don't think the `.wrap` in the proposal behaves the same in this example.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$uZroGQ2kwuHSnVXq6oRO6X-3C0WqoGhTD-XwdpZQ2Uc?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>I don't disagree with its utility, but It's still a convenience method. You could achieve the same in userland with only <code>.run()</code> and <code>.get()</code>:</p>\n<pre><code class=\"language-js\">function wrap(ctx, cb) {\n  const store = ctx.get();\n  return () =&gt; ctx.run(store, cb);\n}\n</code></pre>\n</blockquote></mx-reply>I don't think the <code>.wrap</code> in the proposal behaves the same in this example.","m.relates_to":{"m.in_reply_to":{"event_id":"$uZroGQ2kwuHSnVXq6oRO6X-3C0WqoGhTD-XwdpZQ2Uc"}}},"ts":1668782286838,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$hfV0u_xLr4G6SqE6Endq8P5l1DzQFMpMLrv2HBT4Gg8"},
{"content":{"org.matrix.msc1767.message":[{"body":"Or, as a one-liner: `((store) => ctx.run(store, cb))(ctx.get())`","mimetype":"text/plain"},{"body":"Or, as a one-liner: <code>((store) =&gt; ctx.run(store, cb))(ctx.get())</code>","mimetype":"text/html"}],"body":"Or, as a one-liner: `((store) => ctx.run(store, cb))(ctx.get())`","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Or, as a one-liner: <code>((store) =&gt; ctx.run(store, cb))(ctx.get())</code>"},"ts":1668782313264,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5C6jxdYXgwyZoFURPdKKFOPCzAD1-wKHdvMN2NEBicw"},
{"content":{"org.matrix.msc1767.message":[{"body":"Ah, I see. `.wrap` captures *all* async contexts.","mimetype":"text/plain"},{"body":"Ah, I see. <code>.wrap</code> captures <em>all</em> async contexts.","mimetype":"text/html"}],"body":"Ah, I see. `.wrap` captures *all* async contexts.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Ah, I see. <code>.wrap</code> captures <em>all</em> async contexts."},"ts":1668782381903,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YJ4-lzLPhbPKIyo4uVKp7TpF3Fp5qapMTKTpGmeMPNk"},
{"content":{"org.matrix.msc1767.text":"The static wrap in the proposal snapshots the current global async context storage, in which all async context values are saved.","body":"The static wrap in the proposal snapshots the current global async context storage, in which all async context values are saved.","msgtype":"m.text"},"ts":1668782388269,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$JJ5A9r_rpQm5ter59yxDULAb9dstBzaf0geMwLN35uw"},
{"content":{"org.matrix.msc1767.message":[{"body":"So its more like .NET's `ExecutionContext.Capture()`","mimetype":"text/plain"},{"body":"So its more like .NET's <code>ExecutionContext.Capture()</code>","mimetype":"text/html"}],"body":"So its more like .NET's `ExecutionContext.Capture()`","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"So its more like .NET's <code>ExecutionContext.Capture()</code>"},"ts":1668782399151,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rAuq1Y_nMMvxyQNRxmj1ybukhlFqwEtOVWnNZtZwjeo"},
{"content":{"org.matrix.msc1767.text":"Yes, with your pointers I think so.","body":"Yes, with your pointers I think so.","msgtype":"m.text"},"ts":1668782418940,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$S1gFhb6qCHh0DWzJimEurcmdZ76YPrfchzbemcTYXJM"},
{"content":{"org.matrix.msc1767.text":"Namings in the proposal are not the final decisions at this point.","body":"Namings in the proposal are not the final decisions at this point.","msgtype":"m.text"},"ts":1668782448618,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$2GWvv45GZpMm6rQpfHXhRCG9t5od5I8Epn1M9IWNDb4"},
{"content":{"org.matrix.msc1767.message":[{"body":"In that case I'm finding the granularity of `.run()` at odds with the coarseness of `.wrap()`.","mimetype":"text/plain"},{"body":"In that case I'm finding the granularity of <code>.run()</code> at odds with the coarseness of <code>.wrap()</code>.","mimetype":"text/html"}],"body":"In that case I'm finding the granularity of `.run()` at odds with the coarseness of `.wrap()`.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"In that case I'm finding the granularity of <code>.run()</code> at odds with the coarseness of <code>.wrap()</code>."},"ts":1668782459743,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nSAuq8heUAuy4R1eCZIIzJ6l8wnpPPN-AEB1sd6Lf6s"},
{"content":{"org.matrix.msc1767.message":[{"body":"In .NET, you have an `ExecutionContext` and a `LogicalCallContext`. When you call `ExecutionContext.Run`, you pass in what amounts to _the entire global async context storage_. You then manipulate that storage with `LogicalCallContext.GetData(key)` and `LogicalCallContext.SetData(key, value)`.","mimetype":"text/plain"},{"body":"In .NET, you have an <code>ExecutionContext</code> and a <code>LogicalCallContext</code>. When you call <code>ExecutionContext.Run</code>, you pass in what amounts to <em>the entire global async context storage</em>. You then manipulate that storage with <code>LogicalCallContext.GetData(key)</code> and <code>LogicalCallContext.SetData(key, value)</code>.","mimetype":"text/html"}],"body":"In .NET, you have an `ExecutionContext` and a `LogicalCallContext`. When you call `ExecutionContext.Run`, you pass in what amounts to _the entire global async context storage_. You then manipulate that storage with `LogicalCallContext.GetData(key)` and `LogicalCallContext.SetData(key, value)`.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"In .NET, you have an <code>ExecutionContext</code> and a <code>LogicalCallContext</code>. When you call <code>ExecutionContext.Run</code>, you pass in what amounts to <em>the entire global async context storage</em>. You then manipulate that storage with <code>LogicalCallContext.GetData(key)</code> and <code>LogicalCallContext.SetData(key, value)</code>."},"ts":1668782564052,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$W11-HP8hRRPeeS3JsxK_Y0z7X_WRxExSZjpRz-MLWV4"},
{"content":{"org.matrix.msc1767.message":[{"body":"If you have multiple `AsyncContext` objects, you might end up with:\n```js\nconst ctx1 = new AsyncContext();\nconst ctx2 = new AsyncContext();\n\nfunction foo() {\n  ctx1.run({ id: 1 }, bar);\n}\n\nfunction bar() {\n  ctx1.run({ id: 2 }, baz);\n}\n\nfunction baz() {\n  ctx1.get(); // { id: 1 }\n  ctx2.get(); // { id: 2 } \n}\n```\n\nWhile in .NET you might do:\n\n```cs\nvar local1 = new AsyncLocal<number>();\nvar local2 = new AsyncLocal<number>();\n\nvoid Foo() {\n  var context = ExecutionContext.CreateCopy();\n  ExecutionContext.Run(context, () => {\n    local1.Value = 1;\n    Bar();\n  });\n}\n\nvoid Bar() {\n  local2.Value = 2;\n  Baz();\n}\n\nvoid Baz() { ... }\n```","mimetype":"text/plain"},{"body":"<p>If you have multiple <code>AsyncContext</code> objects, you might end up with:</p>\n<pre><code class=\"language-js\">const ctx1 = new AsyncContext();\nconst ctx2 = new AsyncContext();\n\nfunction foo() {\n  ctx1.run({ id: 1 }, bar);\n}\n\nfunction bar() {\n  ctx1.run({ id: 2 }, baz);\n}\n\nfunction baz() {\n  ctx1.get(); // { id: 1 }\n  ctx2.get(); // { id: 2 } \n}\n</code></pre>\n<p>While in .NET you might do:</p>\n<pre><code class=\"language-cs\">var local1 = new AsyncLocal&lt;number&gt;();\nvar local2 = new AsyncLocal&lt;number&gt;();\n\nvoid Foo() {\n  var context = ExecutionContext.CreateCopy();\n  ExecutionContext.Run(context, () =&gt; {\n    local1.Value = 1;\n    Bar();\n  });\n}\n\nvoid Bar() {\n  local2.Value = 2;\n  Baz();\n}\n\nvoid Baz() { ... }\n</code></pre>\n","mimetype":"text/html"}],"body":"If you have multiple `AsyncContext` objects, you might end up with:\n```js\nconst ctx1 = new AsyncContext();\nconst ctx2 = new AsyncContext();\n\nfunction foo() {\n  ctx1.run({ id: 1 }, bar);\n}\n\nfunction bar() {\n  ctx1.run({ id: 2 }, baz);\n}\n\nfunction baz() {\n  ctx1.get(); // { id: 1 }\n  ctx2.get(); // { id: 2 } \n}\n```\n\nWhile in .NET you might do:\n\n```cs\nvar local1 = new AsyncLocal<number>();\nvar local2 = new AsyncLocal<number>();\n\nvoid Foo() {\n  var context = ExecutionContext.CreateCopy();\n  ExecutionContext.Run(context, () => {\n    local1.Value = 1;\n    Bar();\n  });\n}\n\nvoid Bar() {\n  local2.Value = 2;\n  Baz();\n}\n\nvoid Baz() { ... }\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>If you have multiple <code>AsyncContext</code> objects, you might end up with:</p>\n<pre><code class=\"language-js\">const ctx1 = new AsyncContext();\nconst ctx2 = new AsyncContext();\n\nfunction foo() {\n  ctx1.run({ id: 1 }, bar);\n}\n\nfunction bar() {\n  ctx1.run({ id: 2 }, baz);\n}\n\nfunction baz() {\n  ctx1.get(); // { id: 1 }\n  ctx2.get(); // { id: 2 } \n}\n</code></pre>\n<p>While in .NET you might do:</p>\n<pre><code class=\"language-cs\">var local1 = new AsyncLocal&lt;number&gt;();\nvar local2 = new AsyncLocal&lt;number&gt;();\n\nvoid Foo() {\n  var context = ExecutionContext.CreateCopy();\n  ExecutionContext.Run(context, () =&gt; {\n    local1.Value = 1;\n    Bar();\n  });\n}\n\nvoid Bar() {\n  local2.Value = 2;\n  Baz();\n}\n\nvoid Baz() { ... }\n</code></pre>\n"},"ts":1668783033307,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$M6iS_tPbpUzyTdcyQUBYnhehuXBE2F_leCHfvXqpEHw"},
{"content":{"org.matrix.msc1767.message":[{"body":"I'm not opposed to the design of `AsyncContext` being a per-context `.run()`, I just find `.wrap` to be strange.","mimetype":"text/plain"},{"body":"I'm not opposed to the design of <code>AsyncContext</code> being a per-context <code>.run()</code>, I just find <code>.wrap</code> to be strange.","mimetype":"text/html"}],"body":"I'm not opposed to the design of `AsyncContext` being a per-context `.run()`, I just find `.wrap` to be strange.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"I'm not opposed to the design of <code>AsyncContext</code> being a per-context <code>.run()</code>, I just find <code>.wrap</code> to be strange."},"ts":1668783118337,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$civpmAtA0ojV_yBe6NwQDz7VWOjbXqB-uMA-rgOU9cI"},
{"content":{"org.matrix.msc1767.message":[{"body":"From what I surmise, the purpose of `.wrap` is to address two specific needs:\n1. To capture the current logical call context (i.e., all global async context values)\n2. To, at some point in the future, use that captured context to execute a callback.","mimetype":"text/plain"},{"body":"<p>From what I surmise, the purpose of <code>.wrap</code> is to address two specific needs:</p>\n<ol>\n<li>To capture the current logical call context (i.e., all global async context values)</li>\n<li>To, at some point in the future, use that captured context to execute a callback.</li>\n</ol>\n","mimetype":"text/html"}],"body":"From what I surmise, the purpose of `.wrap` is to address two specific needs:\n1. To capture the current logical call context (i.e., all global async context values)\n2. To, at some point in the future, use that captured context to execute a callback.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>From what I surmise, the purpose of <code>.wrap</code> is to address two specific needs:</p>\n<ol>\n<li>To capture the current logical call context (i.e., all global async context values)</li>\n<li>To, at some point in the future, use that captured context to execute a callback.</li>\n</ol>\n"},"ts":1668783208491,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aSIB-prwSBUIcHEC2bW8d9U7-zmjnyMdNI-0vQoTp88"},
{"content":{"org.matrix.msc1767.message":[{"body":"`.wrap()` does that by combining those two operations into a single operation. This is fine if you want to wrap a single callback, but is less convenient if you want to capture all contexts and pass it to different callbacks:\n```js\nconst callWithContext = AsyncContext.wrap((cb, ...args) => cb(...args));\ncallWithContext(f);\ncallWithContext(g);\n```","mimetype":"text/plain"},{"body":"<p><code>.wrap()</code> does that by combining those two operations into a single operation. This is fine if you want to wrap a single callback, but is less convenient if you want to capture all contexts and pass it to different callbacks:</p>\n<pre><code class=\"language-js\">const callWithContext = AsyncContext.wrap((cb, ...args) =&gt; cb(...args));\ncallWithContext(f);\ncallWithContext(g);\n</code></pre>\n","mimetype":"text/html"}],"body":"`.wrap()` does that by combining those two operations into a single operation. This is fine if you want to wrap a single callback, but is less convenient if you want to capture all contexts and pass it to different callbacks:\n```js\nconst callWithContext = AsyncContext.wrap((cb, ...args) => cb(...args));\ncallWithContext(f);\ncallWithContext(g);\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p><code>.wrap()</code> does that by combining those two operations into a single operation. This is fine if you want to wrap a single callback, but is less convenient if you want to capture all contexts and pass it to different callbacks:</p>\n<pre><code class=\"language-js\">const callWithContext = AsyncContext.wrap((cb, ...args) =&gt; cb(...args));\ncallWithContext(f);\ncallWithContext(g);\n</code></pre>\n"},"ts":1668783440224,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5OvTZ0ZFQ7cBfu6dgPdBV66TYirpAhigWqT-fKqfT2I"},
{"content":{"org.matrix.msc1767.message":[{"body":"vs. something like:\n```js\nconst context = AsyncContext.capture();\n\n// with a `.run` method on the captured context...\ncontext.run(f);\ncontext.run(g);\n\n// or with a static method\nAsyncContext.runWithContext(context, f);\nAsyncContext.runWithContext(context, g);\n```\n\nAnd if `AsyncContext` ever does become mutable (i.e., via `.enterWith`), you might want to be able to clone the global context so that async context mutations are local to the logical call:\n\n```js\nconst ctx = new AsyncContext();\nctx.run(1, main);\n\nfunction main() {\n  const captured = AsyncContext.capture();\n  const copied = AsyncContext.copyContext();\n\n  AsyncContext.runWithContext(captured, foo);\n  AsyncContext.runWithContext(copied, bar);\n\n  console.log(ctx.get()); // 2 (bar's mutation acted on a copy)\n}\n\nfunction foo() {\n  console.log(ctx.get()); // 1\n  ctx.set(2);\n}\n\nfunction bar() {\n  console.log(ctx.get()); // 1 (due to copy)\n  ctx.set(3);\n}\n```","mimetype":"text/plain"},{"body":"<p>vs. something like:</p>\n<pre><code class=\"language-js\">const context = AsyncContext.capture();\n\n// with a `.run` method on the captured context...\ncontext.run(f);\ncontext.run(g);\n\n// or with a static method\nAsyncContext.runWithContext(context, f);\nAsyncContext.runWithContext(context, g);\n</code></pre>\n<p>And if <code>AsyncContext</code> ever does become mutable (i.e., via <code>.enterWith</code>), you might want to be able to clone the global context so that async context mutations are local to the logical call:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nctx.run(1, main);\n\nfunction main() {\n  const captured = AsyncContext.capture();\n  const copied = AsyncContext.copyContext();\n\n  AsyncContext.runWithContext(captured, foo);\n  AsyncContext.runWithContext(copied, bar);\n\n  console.log(ctx.get()); // 2 (bar's mutation acted on a copy)\n}\n\nfunction foo() {\n  console.log(ctx.get()); // 1\n  ctx.set(2);\n}\n\nfunction bar() {\n  console.log(ctx.get()); // 1 (due to copy)\n  ctx.set(3);\n}\n</code></pre>\n","mimetype":"text/html"}],"body":"vs. something like:\n```js\nconst context = AsyncContext.capture();\n\n// with a `.run` method on the captured context...\ncontext.run(f);\ncontext.run(g);\n\n// or with a static method\nAsyncContext.runWithContext(context, f);\nAsyncContext.runWithContext(context, g);\n```\n\nAnd if `AsyncContext` ever does become mutable (i.e., via `.enterWith`), you might want to be able to clone the global context so that async context mutations are local to the logical call:\n\n```js\nconst ctx = new AsyncContext();\nctx.run(1, main);\n\nfunction main() {\n  const captured = AsyncContext.capture();\n  const copied = AsyncContext.copyContext();\n\n  AsyncContext.runWithContext(captured, foo);\n  AsyncContext.runWithContext(copied, bar);\n\n  console.log(ctx.get()); // 2 (bar's mutation acted on a copy)\n}\n\nfunction foo() {\n  console.log(ctx.get()); // 1\n  ctx.set(2);\n}\n\nfunction bar() {\n  console.log(ctx.get()); // 1 (due to copy)\n  ctx.set(3);\n}\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>vs. something like:</p>\n<pre><code class=\"language-js\">const context = AsyncContext.capture();\n\n// with a `.run` method on the captured context...\ncontext.run(f);\ncontext.run(g);\n\n// or with a static method\nAsyncContext.runWithContext(context, f);\nAsyncContext.runWithContext(context, g);\n</code></pre>\n<p>And if <code>AsyncContext</code> ever does become mutable (i.e., via <code>.enterWith</code>), you might want to be able to clone the global context so that async context mutations are local to the logical call:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nctx.run(1, main);\n\nfunction main() {\n  const captured = AsyncContext.capture();\n  const copied = AsyncContext.copyContext();\n\n  AsyncContext.runWithContext(captured, foo);\n  AsyncContext.runWithContext(copied, bar);\n\n  console.log(ctx.get()); // 2 (bar's mutation acted on a copy)\n}\n\nfunction foo() {\n  console.log(ctx.get()); // 1\n  ctx.set(2);\n}\n\nfunction bar() {\n  console.log(ctx.get()); // 1 (due to copy)\n  ctx.set(3);\n}\n</code></pre>\n"},"ts":1668783930566,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BpxewqBaIrMAD0nOfdm_KQF8ZeT-JJQ7P-UPcM0mCF8"},
{"content":{"org.matrix.msc1767.message":[{"body":"Also, without `.enterWith`, you could not easily emulate something like `AsyncLocal` in user code:\n\n```js\n// with AsyncLocalStorage\nclass AsyncLocal {\n  #context = new AsyncLocalStorage();\n  get value() { return this.#context.getStore(); }\n  set value(v) { this.#context.enterWith(v); }\n}\n\nconst loc = new AsyncLocal();\nloc.value = 1;\nloc.value; // 1\n\n// with AsyncContext\nclass AsyncLocal {\n  #context = new AsyncContext();\n  get value() { return this.#context.value; }\n  set value(v) { this.#context.value = v; }\n  enable(cb) {\n    return this.#context.run({ value: undefined }, cb);\n  }\n}\n\nconst loc = new AsyncLocal();\nloc.value = 1; // ReferenceError\n\n// need to establish context first\nloc.enable(() => {\n  loc.value = 1;\n  loc.value; // 1\n});\n```","mimetype":"text/plain"},{"body":"<p>Also, without <code>.enterWith</code>, you could not easily emulate something like <code>AsyncLocal</code> in user code:</p>\n<pre><code class=\"language-js\">// with AsyncLocalStorage\nclass AsyncLocal {\n  #context = new AsyncLocalStorage();\n  get value() { return this.#context.getStore(); }\n  set value(v) { this.#context.enterWith(v); }\n}\n\nconst loc = new AsyncLocal();\nloc.value = 1;\nloc.value; // 1\n\n// with AsyncContext\nclass AsyncLocal {\n  #context = new AsyncContext();\n  get value() { return this.#context.value; }\n  set value(v) { this.#context.value = v; }\n  enable(cb) {\n    return this.#context.run({ value: undefined }, cb);\n  }\n}\n\nconst loc = new AsyncLocal();\nloc.value = 1; // ReferenceError\n\n// need to establish context first\nloc.enable(() =&gt; {\n  loc.value = 1;\n  loc.value; // 1\n});\n</code></pre>\n","mimetype":"text/html"}],"body":"Also, without `.enterWith`, you could not easily emulate something like `AsyncLocal` in user code:\n\n```js\n// with AsyncLocalStorage\nclass AsyncLocal {\n  #context = new AsyncLocalStorage();\n  get value() { return this.#context.getStore(); }\n  set value(v) { this.#context.enterWith(v); }\n}\n\nconst loc = new AsyncLocal();\nloc.value = 1;\nloc.value; // 1\n\n// with AsyncContext\nclass AsyncLocal {\n  #context = new AsyncContext();\n  get value() { return this.#context.value; }\n  set value(v) { this.#context.value = v; }\n  enable(cb) {\n    return this.#context.run({ value: undefined }, cb);\n  }\n}\n\nconst loc = new AsyncLocal();\nloc.value = 1; // ReferenceError\n\n// need to establish context first\nloc.enable(() => {\n  loc.value = 1;\n  loc.value; // 1\n});\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>Also, without <code>.enterWith</code>, you could not easily emulate something like <code>AsyncLocal</code> in user code:</p>\n<pre><code class=\"language-js\">// with AsyncLocalStorage\nclass AsyncLocal {\n  #context = new AsyncLocalStorage();\n  get value() { return this.#context.getStore(); }\n  set value(v) { this.#context.enterWith(v); }\n}\n\nconst loc = new AsyncLocal();\nloc.value = 1;\nloc.value; // 1\n\n// with AsyncContext\nclass AsyncLocal {\n  #context = new AsyncContext();\n  get value() { return this.#context.value; }\n  set value(v) { this.#context.value = v; }\n  enable(cb) {\n    return this.#context.run({ value: undefined }, cb);\n  }\n}\n\nconst loc = new AsyncLocal();\nloc.value = 1; // ReferenceError\n\n// need to establish context first\nloc.enable(() =&gt; {\n  loc.value = 1;\n  loc.value; // 1\n});\n</code></pre>\n"},"ts":1668784497139,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$n0NWREL-AbdP8u-Rh6mHUF5s3wZ2lFlJgA4ob30FnVA"},
{"content":{"org.matrix.msc1767.text":"The user stories of these ideas are important to shape the API in the proposal. I believe it is worthwhile to visit those requirements in stage 1.","body":"The user stories of these ideas are important to shape the API in the proposal. I believe it is worthwhile to visit those requirements in stage 1.","msgtype":"m.text"},"ts":1668785701372,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$2xbFm7AMw1TxQ_FGkvxmABf6bAEAFvW8oflkG6cb7E4"},
{"content":{"body":"> <@rbuckton:matrix.org> Actually, I'll retract that last statement somewhat. My concern is about async context mutability without violating TCP, but that can be achieved via indirection, i.e. `context.run({ value: 1 }, () => { context.get().value++ })`\n\nI might get it wrong. Would you mind expanding on the TCP issue?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy%3Amatrix.org/%24oVsiRy4OUAR2339Bc6eZR_p7NZe-jUuJZiY2tl4lRBA\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Actually, I'll retract that last statement somewhat. My concern is about async context mutability without violating TCP, but that can be achieved via indirection, i.e. <code>context.run({ value: 1 }, () =&gt; { context.get().value++ })</code></blockquote></mx-reply>I might get it wrong. Would you mind expanding on the TCP issue?","msgtype":"m.text","m.relates_to":{"m.in_reply_to":{"event_id":"$oVsiRy4OUAR2339Bc6eZR_p7NZe-jUuJZiY2tl4lRBA"}}},"ts":1668786023115,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$a23LMtus2VjgzUGJn-GPSp6Nwy5gLFJz5F73kSIHVKA"},
{"content":{"org.matrix.msc1767.message":[{"body":"Tennent's Correspondence Principle (aka. \"Tennent's Principle of Correspondence\"): http://techscursion.com/2012/02/tennent-correspondence-principle.html\n\nIn plenary its often used to describe anything that changes the context of an expression such that the expression can no longer be evaluated in the same way, which is a bit of an more expanded definition than the actual principle.  The issue I'm concerned with is as follows: \n\nLets say you start with an async generator:\n```js\nclass C {\nasync function* foo() {\n  await a();\n  yield b();\n  await c();\n}\n```\n\nNow I need to","mimetype":"text/plain"},{"body":"<p>Tennent's Correspondence Principle (aka. &quot;Tennent's Principle of Correspondence&quot;): http://techscursion.com/2012/02/tennent-correspondence-principle.html</p>\n<p>In plenary its often used to describe anything that changes the context of an expression such that the expression can no longer be evaluated in the same way, which is a bit of an more expanded definition than the actual principle.  The issue I'm concerned with is as follows:</p>\n<p>Lets say you start with an async generator:</p>\n<pre><code class=\"language-js\">class C {\nasync function* foo() {\n  await a();\n  yield b();\n  await c();\n}\n</code></pre>\n<p>Now I need to</p>\n","mimetype":"text/html"}],"body":"Tennent's Correspondence Principle (aka. \"Tennent's Principle of Correspondence\"): http://techscursion.com/2012/02/tennent-correspondence-principle.html\n\nIn plenary its often used to describe anything that changes the context of an expression such that the expression can no longer be evaluated in the same way, which is a bit of an more expanded definition than the actual principle.  The issue I'm concerned with is as follows: \n\nLets say you start with an async generator:\n```js\nclass C {\nasync function* foo() {\n  await a();\n  yield b();\n  await c();\n}\n```\n\nNow I need to","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>Tennent's Correspondence Principle (aka. &quot;Tennent's Principle of Correspondence&quot;): http://techscursion.com/2012/02/tennent-correspondence-principle.html</p>\n<p>In plenary its often used to describe anything that changes the context of an expression such that the expression can no longer be evaluated in the same way, which is a bit of an more expanded definition than the actual principle.  The issue I'm concerned with is as follows:</p>\n<p>Lets say you start with an async generator:</p>\n<pre><code class=\"language-js\">class C {\nasync function* foo() {\n  await a();\n  yield b();\n  await c();\n}\n</code></pre>\n<p>Now I need to</p>\n"},"ts":1668786679097,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wmSCUq1UYxTSTdf3zyhiNr1OgGdOlVYQgZhXjPx1Yr0"},
{"content":{"org.matrix.msc1767.message":[{"body":"Now I need to introduce an async context for b() and c():\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.run(value, () => {\n      yield b(); // syntax error, arrow function is not a generator\n      await this.c(); // syntax error, arrow function is not async\n    });\n  }\n}\n```","mimetype":"text/plain"},{"body":"<p>Now I need to introduce an async context for b() and c():</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.run(value, () =&gt; {\n      yield b(); // syntax error, arrow function is not a generator\n      await this.c(); // syntax error, arrow function is not async\n    });\n  }\n}\n</code></pre>\n","mimetype":"text/html"}],"body":"Now I need to introduce an async context for b() and c():\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.run(value, () => {\n      yield b(); // syntax error, arrow function is not a generator\n      await this.c(); // syntax error, arrow function is not async\n    });\n  }\n}\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>Now I need to introduce an async context for b() and c():</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.run(value, () =&gt; {\n      yield b(); // syntax error, arrow function is not a generator\n      await this.c(); // syntax error, arrow function is not async\n    });\n  }\n}\n</code></pre>\n"},"ts":1668786792825,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZVDfOa4RCgcSVoP30UiyXU3DysmHOM_UBVtoZUoml9s"},
{"content":{"org.matrix.msc1767.message":[{"body":"I can make that an async arrow:\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    await ctx.run(value, async () => {\n      yield b(); // syntax error, arrow function is not a generator\n      await this.c(); // ok\n    });\n  }\n}\n```\nBut that won't work with `yield`.","mimetype":"text/plain"},{"body":"<p>I can make that an async arrow:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    await ctx.run(value, async () =&gt; {\n      yield b(); // syntax error, arrow function is not a generator\n      await this.c(); // ok\n    });\n  }\n}\n</code></pre>\n<p>But that won't work with <code>yield</code>.</p>\n","mimetype":"text/html"}],"body":"I can make that an async arrow:\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    await ctx.run(value, async () => {\n      yield b(); // syntax error, arrow function is not a generator\n      await this.c(); // ok\n    });\n  }\n}\n```\nBut that won't work with `yield`.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>I can make that an async arrow:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    await ctx.run(value, async () =&gt; {\n      yield b(); // syntax error, arrow function is not a generator\n      await this.c(); // ok\n    });\n  }\n}\n</code></pre>\n<p>But that won't work with <code>yield</code>.</p>\n"},"ts":1668786842624,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gowtAwlt3KXU2kXuA6ynK9bJz2zVSzK8XtBbnMWn31I"},
{"content":{"org.matrix.msc1767.message":[{"body":"I can make it an async generator:\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.run(value, async function *() {\n      yield b(); // ok\n      await this.c(); // reference error, this is undefined\n    });\n  }\n}\n```\nBut that won't work with the `this` binding.","mimetype":"text/plain"},{"body":"<p>I can make it an async generator:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.run(value, async function *() {\n      yield b(); // ok\n      await this.c(); // reference error, this is undefined\n    });\n  }\n}\n</code></pre>\n<p>But that won't work with the <code>this</code> binding.</p>\n","mimetype":"text/html"}],"body":"I can make it an async generator:\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.run(value, async function *() {\n      yield b(); // ok\n      await this.c(); // reference error, this is undefined\n    });\n  }\n}\n```\nBut that won't work with the `this` binding.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>I can make it an async generator:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.run(value, async function *() {\n      yield b(); // ok\n      await this.c(); // reference error, this is undefined\n    });\n  }\n}\n</code></pre>\n<p>But that won't work with the <code>this</code> binding.</p>\n"},"ts":1668786892135,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lFi54nz2qKevG9N_3VkWTVA3Ef2CLuxowQhylza8_Ok"},
{"content":{"org.matrix.msc1767.text":"any solution requires significant refactoring.","body":"any solution requires significant refactoring.","msgtype":"m.text"},"ts":1668786913943,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$y-MUmQD6S7mzX3yYw-qRUOmCwEIdhltsIfN42rCP4Qc"},
{"content":{"org.matrix.msc1767.message":[{"body":"vs. an `enterWith`:\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.enterWith(value);\n    try {\n      yield b();\n      await this.c();\n    }\n    finally {\n      ctx.disable();\n    }\n  }\n}\n```","mimetype":"text/plain"},{"body":"<p>vs. an <code>enterWith</code>:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.enterWith(value);\n    try {\n      yield b();\n      await this.c();\n    }\n    finally {\n      ctx.disable();\n    }\n  }\n}\n</code></pre>\n","mimetype":"text/html"}],"body":"vs. an `enterWith`:\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.enterWith(value);\n    try {\n      yield b();\n      await this.c();\n    }\n    finally {\n      ctx.disable();\n    }\n  }\n}\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>vs. an <code>enterWith</code>:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    ctx.enterWith(value);\n    try {\n      yield b();\n      await this.c();\n    }\n    finally {\n      ctx.disable();\n    }\n  }\n}\n</code></pre>\n"},"ts":1668786975514,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$uISLwXT3TKDMVfvfzJkl9Y7h6CTZctolZl8f6BbxeEU"},
{"content":{"org.matrix.msc1767.message":[{"body":"And that could be potentially even more convenient with `using` declarations:\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    using _ = ctx.enterWith(value); // assumes disposable return value...\n    yield b();\n    await this.c();\n  }\n}\n```","mimetype":"text/plain"},{"body":"<p>And that could be potentially even more convenient with <code>using</code> declarations:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    using _ = ctx.enterWith(value); // assumes disposable return value...\n    yield b();\n    await this.c();\n  }\n}\n</code></pre>\n","mimetype":"text/html"}],"body":"And that could be potentially even more convenient with `using` declarations:\n```js\nconst ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    using _ = ctx.enterWith(value); // assumes disposable return value...\n    yield b();\n    await this.c();\n  }\n}\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>And that could be potentially even more convenient with <code>using</code> declarations:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nclass C {\n  async * foo() {\n    await a();\n    using _ = ctx.enterWith(value); // assumes disposable return value...\n    yield b();\n    await this.c();\n  }\n}\n</code></pre>\n"},"ts":1668787070712,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8mQzb8OR5QMtmr7xyXQR3rDHBNrKRRYSsVivhreViRA"},
{"content":{"org.matrix.msc1767.message":[{"body":"TCP violations aren't necessarily bad, but are indicative of inconsistencies in the language. For example, using `ctx.run` would be fine if there was an async generator equivalent for arrow functions so that we could more easily preserve `await`, `this`, and `yield`","mimetype":"text/plain"},{"body":"TCP violations aren't necessarily bad, but are indicative of inconsistencies in the language. For example, using <code>ctx.run</code> would be fine if there was an async generator equivalent for arrow functions so that we could more easily preserve <code>await</code>, <code>this</code>, and <code>yield</code>","mimetype":"text/html"}],"body":"TCP violations aren't necessarily bad, but are indicative of inconsistencies in the language. For example, using `ctx.run` would be fine if there was an async generator equivalent for arrow functions so that we could more easily preserve `await`, `this`, and `yield`","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"TCP violations aren't necessarily bad, but are indicative of inconsistencies in the language. For example, using <code>ctx.run</code> would be fine if there was an async generator equivalent for arrow functions so that we could more easily preserve <code>await</code>, <code>this</code>, and <code>yield</code>"},"ts":1668787507455,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BPT3S7J6mva2KBajh0iZjhXxrPJRzGX-dSoqjh8L3Zk"},
{"content":{"body":"Thanks for sharing! This is a very interesting point on `.setValue` versus a structured `.run` method as the basic block.","format":"org.matrix.custom.html","msgtype":"m.text","formatted_body":"Thanks for sharing! This is a very interesting point on <code>.setValue</code> versus a structured <code>.run</code> method as the basic block."},"ts":1668787778497,"senderName":"Chengzhong Wu","senderId":"@legendecas:matrix.org","id":"$iPmXyQLBPtBQP95HDNLirVno_adMv65sYjcD-Dn9Qvk"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> I can see not having `.exit()` and `.disable()`, but `.enterWith()` isn't a convenience method, it's a core capability.\n\nStill reading, all the messages, but this is the first I disagree with. The way I'm explaining the proposal during the meeting will be to equate it with putting data onto the call stack, and `.enterWith()` doesn't create a new callstack entry.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$xFg7fYmVZW_GLDZNq1QwTWwYT3EPBWJiYoywArDXM-M?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I can see not having <code>.exit()</code> and <code>.disable()</code>, but <code>.enterWith()</code> isn't a convenience method, it's a core capability.</blockquote></mx-reply>Still reading, all the messages, but this is the first I disagree with. The way I'm explaining the proposal during the meeting will be to equate it with putting data onto the call stack, and <code>.enterWith()</code> doesn't create a new callstack entry.","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> I can see not having `.exit()` and `.disable()`, but `.enterWith()` isn't a convenience method, it's a core capability.\n\nStill reading, all the messages, but this is the first I disagree with. The way I'm explaining the proposal during the meeting will be to equate it with putting data onto the call stack, and `.enterWith()` doesn't create a new callstack entry.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$xFg7fYmVZW_GLDZNq1QwTWwYT3EPBWJiYoywArDXM-M?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I can see not having <code>.exit()</code> and <code>.disable()</code>, but <code>.enterWith()</code> isn't a convenience method, it's a core capability.</blockquote></mx-reply>Still reading, all the messages, but this is the first I disagree with. The way I'm explaining the proposal during the meeting will be to equate it with putting data onto the call stack, and <code>.enterWith()</code> doesn't create a new callstack entry.","m.relates_to":{"m.in_reply_to":{"event_id":"$xFg7fYmVZW_GLDZNq1QwTWwYT3EPBWJiYoywArDXM-M"}}},"ts":1668792038395,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$hGgohVGpQ0IRIQ4SQ016q-KKXx7WAMoUhbXc0hx_sys"},
{"content":{"org.matrix.msc1767.text":"The behavior here of leaking data beyond the current callstack, and mutating the containing callstack's data for other execution that follows the current, is only a source of bugs.","body":"The behavior here of leaking data beyond the current callstack, and mutating the containing callstack's data for other execution that follows the current, is only a source of bugs.","msgtype":"m.text"},"ts":1668792068808,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$qtKM5-Dp_P2M8z-ijrXLLfZlOL1GDE07TA0uBMVSdHA"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> vs. something like:\n> ```js\n> const context = AsyncContext.capture();\n> \n> // with a `.run` method on the captured context...\n> context.run(f);\n> context.run(g);\n> \n> // or with a static method\n> AsyncContext.runWithContext(context, f);\n> AsyncContext.runWithContext(context, g);\n> ```\n> \n> And if `AsyncContext` ever does become mutable (i.e., via `.enterWith`), you might want to be able to clone the global context so that async context mutations are local to the logical call:\n> \n> ```js\n> const ctx = new AsyncContext();\n> ctx.run(1, main);\n> \n> function main() {\n>   const captured = AsyncContext.capture();\n>   const copied = AsyncContext.copyContext();\n> \n>   AsyncContext.runWithContext(captured, foo);\n>   AsyncContext.runWithContext(copied, bar);\n> \n>   console.log(ctx.get()); // 2 (bar's mutation acted on a copy)\n> }\n> \n> function foo() {\n>   console.log(ctx.get()); // 1\n>   ctx.set(2);\n> }\n> \n> function bar() {\n>   console.log(ctx.get()); // 1 (due to copy)\n>   ctx.set(3);\n> }\n> ```\n\nDan suggested we not reify the snapshot into a class structure. Your suggestion matches pretty closely with what I have in [my gist](https://gist.github.com/jridgewell/3970a3078ebfb90e90cd9d0a36ab9c08#file-async-context-ts-L7-L20)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$BpxewqBaIrMAD0nOfdm_KQF8ZeT-JJQ7P-UPcM0mCF8?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>vs. something like:</p>\n<pre><code class=\"language-js\">const context = AsyncContext.capture();\n\n// with a `.run` method on the captured context...\ncontext.run(f);\ncontext.run(g);\n\n// or with a static method\nAsyncContext.runWithContext(context, f);\nAsyncContext.runWithContext(context, g);\n</code></pre>\n<p>And if <code>AsyncContext</code> ever does become mutable (i.e., via <code>.enterWith</code>), you might want to be able to clone the global context so that async context mutations are local to the logical call:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nctx.run(1, main);\n\nfunction main() {\n  const captured = AsyncContext.capture();\n  const copied = AsyncContext.copyContext();\n\n  AsyncContext.runWithContext(captured, foo);\n  AsyncContext.runWithContext(copied, bar);\n\n  console.log(ctx.get()); // 2 (bar's mutation acted on a copy)\n}\n\nfunction foo() {\n  console.log(ctx.get()); // 1\n  ctx.set(2);\n}\n\nfunction bar() {\n  console.log(ctx.get()); // 1 (due to copy)\n  ctx.set(3);\n}\n</code></pre>\n</blockquote></mx-reply>Dan suggested we not reify the snapshot into a class structure. Your suggestion matches pretty closely with what I have in <a href=\"https://gist.github.com/jridgewell/3970a3078ebfb90e90cd9d0a36ab9c08#file-async-context-ts-L7-L20\">my gist</a>","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> vs. something like:\n> ```js\n> const context = AsyncContext.capture();\n> \n> // with a `.run` method on the captured context...\n> context.run(f);\n> context.run(g);\n> \n> // or with a static method\n> AsyncContext.runWithContext(context, f);\n> AsyncContext.runWithContext(context, g);\n> ```\n> \n> And if `AsyncContext` ever does become mutable (i.e., via `.enterWith`), you might want to be able to clone the global context so that async context mutations are local to the logical call:\n> \n> ```js\n> const ctx = new AsyncContext();\n> ctx.run(1, main);\n> \n> function main() {\n>   const captured = AsyncContext.capture();\n>   const copied = AsyncContext.copyContext();\n> \n>   AsyncContext.runWithContext(captured, foo);\n>   AsyncContext.runWithContext(copied, bar);\n> \n>   console.log(ctx.get()); // 2 (bar's mutation acted on a copy)\n> }\n> \n> function foo() {\n>   console.log(ctx.get()); // 1\n>   ctx.set(2);\n> }\n> \n> function bar() {\n>   console.log(ctx.get()); // 1 (due to copy)\n>   ctx.set(3);\n> }\n> ```\n\nDan suggested we not reify the snapshot into a class structure. Your suggestion matches pretty closely with what I have in [my gist](https://gist.github.com/jridgewell/3970a3078ebfb90e90cd9d0a36ab9c08#file-async-context-ts-L7-L20)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$BpxewqBaIrMAD0nOfdm_KQF8ZeT-JJQ7P-UPcM0mCF8?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>vs. something like:</p>\n<pre><code class=\"language-js\">const context = AsyncContext.capture();\n\n// with a `.run` method on the captured context...\ncontext.run(f);\ncontext.run(g);\n\n// or with a static method\nAsyncContext.runWithContext(context, f);\nAsyncContext.runWithContext(context, g);\n</code></pre>\n<p>And if <code>AsyncContext</code> ever does become mutable (i.e., via <code>.enterWith</code>), you might want to be able to clone the global context so that async context mutations are local to the logical call:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nctx.run(1, main);\n\nfunction main() {\n  const captured = AsyncContext.capture();\n  const copied = AsyncContext.copyContext();\n\n  AsyncContext.runWithContext(captured, foo);\n  AsyncContext.runWithContext(copied, bar);\n\n  console.log(ctx.get()); // 2 (bar's mutation acted on a copy)\n}\n\nfunction foo() {\n  console.log(ctx.get()); // 1\n  ctx.set(2);\n}\n\nfunction bar() {\n  console.log(ctx.get()); // 1 (due to copy)\n  ctx.set(3);\n}\n</code></pre>\n</blockquote></mx-reply>Dan suggested we not reify the snapshot into a class structure. Your suggestion matches pretty closely with what I have in <a href=\"https://gist.github.com/jridgewell/3970a3078ebfb90e90cd9d0a36ab9c08#file-async-context-ts-L7-L20\">my gist</a>","m.relates_to":{"m.in_reply_to":{"event_id":"$BpxewqBaIrMAD0nOfdm_KQF8ZeT-JJQ7P-UPcM0mCF8"}}},"ts":1668792636703,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$T4Xyt7fwR0b8ojZ5Xd2UiVithFOmKvKp75PDqnL26_0"},
{"content":{"msgtype":"m.text","body":"I still am having trouble understanding the motivation for this reified design"},"ts":1668794166754,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$pAQKX2z9Fqcv--i19LH4uoOZ4OXrOVt5Zumn_UsfoRs"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> I still am having trouble understanding the motivation for this reified design\n\nA `.wrap()` method makes it easy to wrap a _single_ callback in a captured execution context, but harder to reuse that context for multiple callbacks without incurring the overhead of an additional function wrapper for each callback.\n\nA `.capture()` method, and an associated `.run(globalContext, cb)` method make it easy to reuse a context with multiple functions without incurring the overhead of a function wrapper.\n\nEither can be composed with the other, however:\n\n```js\n// emulate `capture` if you only have `wrap()`:\n\nfunction capture() {\n    return AsyncContext.wrap((cb, ...args) => cb(...args));\n}\n\n// wrap a single callback\nconst wrapped = AsyncContext.wrap(cb);\nsetImmediate(() => {\n    wrapped();\n});\n\n// capture context and use with multiple functions\nconst context = capture();\nsetImmediate(() => {\n    context(foo);\n    context(bar);\n});\n\n// emulate `wrap` if you only have `capture()`:\n\n// assumes `AsyncContext.capture()` produces `(cb, ...args) => any`\nfunction wrap(cb) {\n    const context = AsyncContext.capture();\n    return (...args) => context(cb, ...args);\n}\n\n// wrap a single callback\nconst wrapped = wrap(cb);\nsetImmediate(() => {\n    wrapped();\n});\n\n// capture context and use with multiple functions\nconst context = AsyncContext.capture();\nsetImmediate(() => {\n    context(foo);\n    context(bar);\n});\n```\n","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$pAQKX2z9Fqcv--i19LH4uoOZ4OXrOVt5Zumn_UsfoRs?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I still am having trouble understanding the motivation for this reified design</blockquote></mx-reply><p>A <code>.wrap()</code> method makes it easy to wrap a <em>single</em> callback in a captured execution context, but harder to reuse that context for multiple callbacks without incurring the overhead of an additional function wrapper for each callback.</p>\n<p>A <code>.capture()</code> method, and an associated <code>.run(globalContext, cb)</code> method make it easy to reuse a context with multiple functions without incurring the overhead of a function wrapper.</p>\n<p>Either can be composed with the other, however:</p>\n<pre><code class=\"language-js\">// emulate `capture` if you only have `wrap()`:\n\nfunction capture() {\n    return AsyncContext.wrap((cb, ...args) =&gt; cb(...args));\n}\n\n// wrap a single callback\nconst wrapped = AsyncContext.wrap(cb);\nsetImmediate(() =&gt; {\n    wrapped();\n});\n\n// capture context and use with multiple functions\nconst context = capture();\nsetImmediate(() =&gt; {\n    context(foo);\n    context(bar);\n});\n\n// emulate `wrap` if you only have `capture()`:\n\n// assumes `AsyncContext.capture()` produces `(cb, ...args) =&gt; any`\nfunction wrap(cb) {\n    const context = AsyncContext.capture();\n    return (...args) =&gt; context(cb, ...args);\n}\n\n// wrap a single callback\nconst wrapped = wrap(cb);\nsetImmediate(() =&gt; {\n    wrapped();\n});\n\n// capture context and use with multiple functions\nconst context = AsyncContext.capture();\nsetImmediate(() =&gt; {\n    context(foo);\n    context(bar);\n});\n</code></pre>\n","mimetype":"text/html"}],"body":"> <@littledan:matrix.org> I still am having trouble understanding the motivation for this reified design\n\nA `.wrap()` method makes it easy to wrap a _single_ callback in a captured execution context, but harder to reuse that context for multiple callbacks without incurring the overhead of an additional function wrapper for each callback.\n\nA `.capture()` method, and an associated `.run(globalContext, cb)` method make it easy to reuse a context with multiple functions without incurring the overhead of a function wrapper.\n\nEither can be composed with the other, however:\n\n```js\n// emulate `capture` if you only have `wrap()`:\n\nfunction capture() {\n    return AsyncContext.wrap((cb, ...args) => cb(...args));\n}\n\n// wrap a single callback\nconst wrapped = AsyncContext.wrap(cb);\nsetImmediate(() => {\n    wrapped();\n});\n\n// capture context and use with multiple functions\nconst context = capture();\nsetImmediate(() => {\n    context(foo);\n    context(bar);\n});\n\n// emulate `wrap` if you only have `capture()`:\n\n// assumes `AsyncContext.capture()` produces `(cb, ...args) => any`\nfunction wrap(cb) {\n    const context = AsyncContext.capture();\n    return (...args) => context(cb, ...args);\n}\n\n// wrap a single callback\nconst wrapped = wrap(cb);\nsetImmediate(() => {\n    wrapped();\n});\n\n// capture context and use with multiple functions\nconst context = AsyncContext.capture();\nsetImmediate(() => {\n    context(foo);\n    context(bar);\n});\n```\n","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$pAQKX2z9Fqcv--i19LH4uoOZ4OXrOVt5Zumn_UsfoRs?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I still am having trouble understanding the motivation for this reified design</blockquote></mx-reply><p>A <code>.wrap()</code> method makes it easy to wrap a <em>single</em> callback in a captured execution context, but harder to reuse that context for multiple callbacks without incurring the overhead of an additional function wrapper for each callback.</p>\n<p>A <code>.capture()</code> method, and an associated <code>.run(globalContext, cb)</code> method make it easy to reuse a context with multiple functions without incurring the overhead of a function wrapper.</p>\n<p>Either can be composed with the other, however:</p>\n<pre><code class=\"language-js\">// emulate `capture` if you only have `wrap()`:\n\nfunction capture() {\n    return AsyncContext.wrap((cb, ...args) =&gt; cb(...args));\n}\n\n// wrap a single callback\nconst wrapped = AsyncContext.wrap(cb);\nsetImmediate(() =&gt; {\n    wrapped();\n});\n\n// capture context and use with multiple functions\nconst context = capture();\nsetImmediate(() =&gt; {\n    context(foo);\n    context(bar);\n});\n\n// emulate `wrap` if you only have `capture()`:\n\n// assumes `AsyncContext.capture()` produces `(cb, ...args) =&gt; any`\nfunction wrap(cb) {\n    const context = AsyncContext.capture();\n    return (...args) =&gt; context(cb, ...args);\n}\n\n// wrap a single callback\nconst wrapped = wrap(cb);\nsetImmediate(() =&gt; {\n    wrapped();\n});\n\n// capture context and use with multiple functions\nconst context = AsyncContext.capture();\nsetImmediate(() =&gt; {\n    context(foo);\n    context(bar);\n});\n</code></pre>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$pAQKX2z9Fqcv--i19LH4uoOZ4OXrOVt5Zumn_UsfoRs"}}},"ts":1668795103417,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yO1moZJE5e6aEINxxfD0d07cr2BHbISQvuwgB8sF8b4"},
{"content":{"org.matrix.msc1767.message":[{"body":"I'd argue its a bit more obvious to a developer that they can do the following to wrap:\n```js\nconst context = AsyncContext.capture();\nreturn () => context(f);\n```\n\nvs. the more opaque syntax needed to emulate `context()`:\n```js\nconst context = AsyncContext.wrap((cb, ...args) => cb(...args));\ncontext(f);\n```","mimetype":"text/plain"},{"body":"<p>I'd argue its a bit more obvious to a developer that they can do the following to wrap:</p>\n<pre><code class=\"language-js\">const context = AsyncContext.capture();\nreturn () =&gt; context(f);\n</code></pre>\n<p>vs. the more opaque syntax needed to emulate <code>context()</code>:</p>\n<pre><code class=\"language-js\">const context = AsyncContext.wrap((cb, ...args) =&gt; cb(...args));\ncontext(f);\n</code></pre>\n","mimetype":"text/html"}],"body":"I'd argue its a bit more obvious to a developer that they can do the following to wrap:\n```js\nconst context = AsyncContext.capture();\nreturn () => context(f);\n```\n\nvs. the more opaque syntax needed to emulate `context()`:\n```js\nconst context = AsyncContext.wrap((cb, ...args) => cb(...args));\ncontext(f);\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>I'd argue its a bit more obvious to a developer that they can do the following to wrap:</p>\n<pre><code class=\"language-js\">const context = AsyncContext.capture();\nreturn () =&gt; context(f);\n</code></pre>\n<p>vs. the more opaque syntax needed to emulate <code>context()</code>:</p>\n<pre><code class=\"language-js\">const context = AsyncContext.wrap((cb, ...args) =&gt; cb(...args));\ncontext(f);\n</code></pre>\n"},"ts":1668795246040,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5pKAHX72LP2OkoxfSci2AHnA5r9zki_mFxn7vNixte0"},
{"content":{"org.matrix.msc1767.text":"But I would argue to have both rather than just one or the other.","body":"But I would argue to have both rather than just one or the other.","msgtype":"m.text"},"ts":1668795272792,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OUB6pfa8LnVFdvDbr2ACzbprDaTKDP9kDMIWQkbLu64"},
{"content":{"org.matrix.msc1767.text":"I agree, I think that makes is simpler for restoring before multiple callbacks","body":"I agree, I think that makes is simpler for restoring before multiple callbacks","msgtype":"m.text"},"ts":1668795412358,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Y5FzcwHZChstzhMquU-xHCSVFhAuPcnLnlkP5TM6BXo"},
{"content":{"org.matrix.msc1767.text":"I also wonder if the MVP should include a mechanism for async context control flow so its easier to escape a global context.","body":"I also wonder if the MVP should include a mechanism for async context control flow so its easier to escape a global context.","msgtype":"m.text"},"ts":1668795448335,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$X9T5eVWA44IO_Z9me0Zlp1U2eC0T3qqcw7vogx-2lTE"},
{"content":{"org.matrix.msc1767.message":[{"body":"My examples above use `setImmediate`, but what if `setImmediate` *also* passes along the current execution context?","mimetype":"text/plain"},{"body":"My examples above use <code>setImmediate</code>, but what if <code>setImmediate</code> <em>also</em> passes along the current execution context?","mimetype":"text/html"}],"body":"My examples above use `setImmediate`, but what if `setImmediate` *also* passes along the current execution context?","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"My examples above use <code>setImmediate</code>, but what if <code>setImmediate</code> <em>also</em> passes along the current execution context?"},"ts":1668795477248,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UP9BZZh6YIKbsPVHgS2PSWj8D8Ui_DLFzWbojbl4_Qs"},
{"content":{"org.matrix.msc1767.message":[{"body":".NET has `ExecutionContext.SuppressFlow()` and `ExecutionContext.RestoreFlow()` for this purpose, and the result of `SuppressFlow()` is disposable (if disposed, it will call `RestoreFlow()` for you).","mimetype":"text/plain"},{"body":".NET has <code>ExecutionContext.SuppressFlow()</code> and <code>ExecutionContext.RestoreFlow()</code> for this purpose, and the result of <code>SuppressFlow()</code> is disposable (if disposed, it will call <code>RestoreFlow()</code> for you).","mimetype":"text/html"}],"body":".NET has `ExecutionContext.SuppressFlow()` and `ExecutionContext.RestoreFlow()` for this purpose, and the result of `SuppressFlow()` is disposable (if disposed, it will call `RestoreFlow()` for you).","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":".NET has <code>ExecutionContext.SuppressFlow()</code> and <code>ExecutionContext.RestoreFlow()</code> for this purpose, and the result of <code>SuppressFlow()</code> is disposable (if disposed, it will call <code>RestoreFlow()</code> for you)."},"ts":1668795566087,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KwHln_uLJbyxu3fHl5UZlBIlNEYQxwmdLhPNDErxln8"},
{"content":{"org.matrix.msc1767.message":[{"body":"(It's intended to keep the execution context, but `setImmediate` and friends don't live in 262)","mimetype":"text/plain"},{"body":"(It's intended to keep the execution context, but <code>setImmediate</code> and friends don't live in 262)","mimetype":"text/html"}],"body":"(It's intended to keep the execution context, but `setImmediate` and friends don't live in 262)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"(It's intended to keep the execution context, but <code>setImmediate</code> and friends don't live in 262)"},"ts":1668795599228,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$v7YIZN87HYJr4FBoQaj9phIElGouPPEXobKgl0lsYAc"},
{"content":{"org.matrix.msc1767.message":[{"body":"then we *definitely* need a way to escape an execution context.","mimetype":"text/plain"},{"body":"then we <em>definitely</em> need a way to escape an execution context.","mimetype":"text/html"}],"body":"then we *definitely* need a way to escape an execution context.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"then we <em>definitely</em> need a way to escape an execution context."},"ts":1668795631113,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CLRvtx-YZQrwvho7_iipargbSZI2MvT8X-Q5KjmvDtA"},
{"content":{"org.matrix.msc1767.message":[{"body":"It's already possible with `.wrap()` in the top level scope","mimetype":"text/plain"},{"body":"It's already possible with <code>.wrap()</code> in the top level scope","mimetype":"text/html"}],"body":"It's already possible with `.wrap()` in the top level scope","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"It's already possible with <code>.wrap()</code> in the top level scope"},"ts":1668795659620,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$s5yqWSSboF5CX2QiGRX3A4GQHeUyJw12D44jOikVrtU"},
{"content":{"org.matrix.msc1767.message":[{"body":"```js\nconst suppressed = AsyncContext.wrap((cb, …args) => cb(…args));\n\ncontext.run(1, () => {\n  suppressed(() => {\n    context.get() === undefined;\n  });\n});\n```","mimetype":"text/plain"},{"body":"<pre><code class=\"language-js\">const suppressed = AsyncContext.wrap((cb, …args) =&gt; cb(…args));\n\ncontext.run(1, () =&gt; {\n  suppressed(() =&gt; {\n    context.get() === undefined;\n  });\n});\n</code></pre>\n","mimetype":"text/html"}],"body":"```js\nconst suppressed = AsyncContext.wrap((cb, …args) => cb(…args));\n\ncontext.run(1, () => {\n  suppressed(() => {\n    context.get() === undefined;\n  });\n});\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">const suppressed = AsyncContext.wrap((cb, …args) =&gt; cb(…args));\n\ncontext.run(1, () =&gt; {\n  suppressed(() =&gt; {\n    context.get() === undefined;\n  });\n});\n</code></pre>\n"},"ts":1668795723629,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$FGYGGs5vpaX5sYpLkH1-VX1wtVB0yig_wI5uCtrDo5c"},
{"content":{"org.matrix.msc1767.message":[{"body":"Yes, but that wouldn't work well if async contexts were mutable like Node's `AsyncLocalStorage.enterWith`, since that can set up a context at the top level before your module body runs.","mimetype":"text/plain"},{"body":"Yes, but that wouldn't work well if async contexts were mutable like Node's <code>AsyncLocalStorage.enterWith</code>, since that can set up a context at the top level before your module body runs.","mimetype":"text/html"}],"body":"Yes, but that wouldn't work well if async contexts were mutable like Node's `AsyncLocalStorage.enterWith`, since that can set up a context at the top level before your module body runs.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Yes, but that wouldn't work well if async contexts were mutable like Node's <code>AsyncLocalStorage.enterWith</code>, since that can set up a context at the top level before your module body runs."},"ts":1668795803785,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$l-_YK0eC21TR6c4xnpzbKQrx3yYsotL-TR_bj1UY6ZE"},
{"content":{"org.matrix.msc1767.message":[{"body":"then again, `capture` and `copy` would have the same problem I suppose.","mimetype":"text/plain"},{"body":"then again, <code>capture</code> and <code>copy</code> would have the same problem I suppose.","mimetype":"text/html"}],"body":"then again, `capture` and `copy` would have the same problem I suppose.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"then again, <code>capture</code> and <code>copy</code> would have the same problem I suppose."},"ts":1668795832212,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZgX1jMDL3eN-NuGwrEDqpeY-IeFipLtUvumMAhTd-Ko"},
{"content":{"org.matrix.msc1767.text":"As I said above, I think mutable context is a bug (and very likely to hit challenges with the SES folks)","body":"As I said above, I think mutable context is a bug (and very likely to hit challenges with the SES folks)","msgtype":"m.text"},"ts":1668795840438,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$QaiXtKaASl0FzSqB85H1J53iQY34cLZSNE7qnJ3ZXNs"},
{"content":{"org.matrix.msc1767.message":[{"body":"But a `suppressFlow()` would avoid that as well.","mimetype":"text/plain"},{"body":"But a <code>suppressFlow()</code> would avoid that as well.","mimetype":"text/html"}],"body":"But a `suppressFlow()` would avoid that as well.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"But a <code>suppressFlow()</code> would avoid that as well."},"ts":1668795861292,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5EB1jYjYbGKFpIBf04toGiUvajSumKx9AIRUIQC4XVg"},
{"content":{"org.matrix.msc1767.text":"I really don't wanna support it.","body":"I really don't wanna support it.","msgtype":"m.text"},"ts":1668795862022,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$IhmwF0zqqtEKHgLM3fYpcLKdqW5JHBDi59hkbp3wP0Y"},
{"content":{"org.matrix.msc1767.text":"Definite +1 on not supporting mutable context. Not a fan of enterWith","body":"Definite +1 on not supporting mutable context. Not a fan of enterWith","msgtype":"m.text"},"ts":1668795882458,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$aEXcC-VE-7w079K-L0el1X41H5H-kLACRVRfe-QtIyw"},
{"content":{"org.matrix.msc1767.message":[{"body":"Something like `SuppressFlow()` would also work well with `using` declarations, i.e.:\n```js\nconst ctx = new AsyncContext();\nctx.run(1, foo);\n\nasync function foo() {\n  console.log(ctx.get()); // 1\n  {\n    using flow = AsyncContext.suppressFlow();\n    console.log(ctx.get()); // undefined\n  }\n  console.log(ctx.get()); // 1\n}\n```","mimetype":"text/plain"},{"body":"<p>Something like <code>SuppressFlow()</code> would also work well with <code>using</code> declarations, i.e.:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nctx.run(1, foo);\n\nasync function foo() {\n  console.log(ctx.get()); // 1\n  {\n    using flow = AsyncContext.suppressFlow();\n    console.log(ctx.get()); // undefined\n  }\n  console.log(ctx.get()); // 1\n}\n</code></pre>\n","mimetype":"text/html"}],"body":"Something like `SuppressFlow()` would also work well with `using` declarations, i.e.:\n```js\nconst ctx = new AsyncContext();\nctx.run(1, foo);\n\nasync function foo() {\n  console.log(ctx.get()); // 1\n  {\n    using flow = AsyncContext.suppressFlow();\n    console.log(ctx.get()); // undefined\n  }\n  console.log(ctx.get()); // 1\n}\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>Something like <code>SuppressFlow()</code> would also work well with <code>using</code> declarations, i.e.:</p>\n<pre><code class=\"language-js\">const ctx = new AsyncContext();\nctx.run(1, foo);\n\nasync function foo() {\n  console.log(ctx.get()); // 1\n  {\n    using flow = AsyncContext.suppressFlow();\n    console.log(ctx.get()); // undefined\n  }\n  console.log(ctx.get()); // 1\n}\n</code></pre>\n"},"ts":1668795911132,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$M0BGcluilU-2591XNtIhMBql1zC8yOPdru7vpg78MFU"},
{"content":{"org.matrix.msc1767.message":[{"body":"I'd really like to be able to have a simple `AsyncLocal` primitive, or even an `@AsyncLocal` decorator (not unlike a potential `@ThreadLocal` decorator that could someday exist for shared structs):\n\n```js\nclass HttpServer {\n  @AsyncLocal\n  accessor currentRequest;\n  ...\n}\n```\nBut that wouldn't work without the ability attach an async context to the _current_ execution context without needing to go through a `.run` call.","mimetype":"text/plain"},{"body":"<p>I'd really like to be able to have a simple <code>AsyncLocal</code> primitive, or even an <code>@AsyncLocal</code> decorator (not unlike a potential <code>@ThreadLocal</code> decorator that could someday exist for shared structs):</p>\n<pre><code class=\"language-js\">class HttpServer {\n  @AsyncLocal\n  accessor currentRequest;\n  ...\n}\n</code></pre>\n<p>But that wouldn't work without the ability attach an async context to the <em>current</em> execution context without needing to go through a <code>.run</code> call.</p>\n","mimetype":"text/html"}],"body":"I'd really like to be able to have a simple `AsyncLocal` primitive, or even an `@AsyncLocal` decorator (not unlike a potential `@ThreadLocal` decorator that could someday exist for shared structs):\n\n```js\nclass HttpServer {\n  @AsyncLocal\n  accessor currentRequest;\n  ...\n}\n```\nBut that wouldn't work without the ability attach an async context to the _current_ execution context without needing to go through a `.run` call.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>I'd really like to be able to have a simple <code>AsyncLocal</code> primitive, or even an <code>@AsyncLocal</code> decorator (not unlike a potential <code>@ThreadLocal</code> decorator that could someday exist for shared structs):</p>\n<pre><code class=\"language-js\">class HttpServer {\n  @AsyncLocal\n  accessor currentRequest;\n  ...\n}\n</code></pre>\n<p>But that wouldn't work without the ability attach an async context to the <em>current</em> execution context without needing to go through a <code>.run</code> call.</p>\n"},"ts":1668796067551,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KYCjKkmU3-DbmiZDgFglntForboVIFijgm_JOtjaij8"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@jasnell:matrix.org> Definite +1 on not supporting mutable context. Not a fan of enterWith\n\nYet `context.run({ value: 1 }, () => context.get().value++)` is still mutable. Not having `enterWith` just makes other related primitives harder to implement.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$aEXcC-VE-7w079K-L0el1X41H5H-kLACRVRfe-QtIyw?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jasnell:matrix.org\">@jasnell:matrix.org</a><br>Definite +1 on not supporting mutable context. Not a fan of enterWith</blockquote></mx-reply>Yet <code>context.run({ value: 1 }, () =&gt; context.get().value++)</code> is still mutable. Not having <code>enterWith</code> just makes other related primitives harder to implement.","mimetype":"text/html"}],"body":"> <@jasnell:matrix.org> Definite +1 on not supporting mutable context. Not a fan of enterWith\n\nYet `context.run({ value: 1 }, () => context.get().value++)` is still mutable. Not having `enterWith` just makes other related primitives harder to implement.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$aEXcC-VE-7w079K-L0el1X41H5H-kLACRVRfe-QtIyw?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jasnell:matrix.org\">@jasnell:matrix.org</a><br>Definite +1 on not supporting mutable context. Not a fan of enterWith</blockquote></mx-reply>Yet <code>context.run({ value: 1 }, () =&gt; context.get().value++)</code> is still mutable. Not having <code>enterWith</code> just makes other related primitives harder to implement.","m.relates_to":{"m.in_reply_to":{"event_id":"$aEXcC-VE-7w079K-L0el1X41H5H-kLACRVRfe-QtIyw"}}},"ts":1668796194544,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OxjlOssIsDpGyT0oSCvMkHTaOLLI9jpEHUv7MvXSI0A"},
{"content":{"org.matrix.msc1767.text":"Yeah, and we have plenty of use cases where folks add to or change values in the context... mutable context is likely the wrong phrase. I'm not a big fan of the enterWith(...) model at all, and I shouldn't be able to completely replace the context value.","body":"Yeah, and we have plenty of use cases where folks add to or change values in the context... mutable context is likely the wrong phrase. I'm not a big fan of the enterWith(...) model at all, and I shouldn't be able to completely replace the context value.","msgtype":"m.text"},"ts":1668796503574,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$vi2PSDWtAA10WBVltpZxsOsvIzMtR3K2NDfk-gMCvKE"},
{"content":{"org.matrix.msc1767.text":"unfortunately I'm on my way out the door for an appointment. Will be back and will try to weigh in more","body":"unfortunately I'm on my way out the door for an appointment. Will be back and will try to weigh in more","msgtype":"m.text"},"ts":1668796649340,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$pl4zC8FV2FgOw06wCh9AOTwOz36AX26q8mFXxaSE2x8"},
{"content":{"org.matrix.msc1767.message":[{"body":"Its not the wrong phrase. I was just illustrating that an _immutable context_ can still hold _mutable values_. And in most other languages I'm familiar with, the context is also mutable.","mimetype":"text/plain"},{"body":"Its not the wrong phrase. I was just illustrating that an <em>immutable context</em> can still hold <em>mutable values</em>. And in most other languages I'm familiar with, the context is also mutable.","mimetype":"text/html"}],"body":"Its not the wrong phrase. I was just illustrating that an _immutable context_ can still hold _mutable values_. And in most other languages I'm familiar with, the context is also mutable.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Its not the wrong phrase. I was just illustrating that an <em>immutable context</em> can still hold <em>mutable values</em>. And in most other languages I'm familiar with, the context is also mutable."},"ts":1668796651651,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mpPcWd4zEd4tCucv9vN2sNZt-KxtKvrCf9GsgEMqCfk"},
{"content":{"org.matrix.msc1767.text":"tl;dr is just I really dislike enterWith","body":"tl;dr is just I really dislike enterWith","msgtype":"m.text"},"ts":1668796665336,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$dSI5bwK4vGttUN69Lvx2rh2AxpLX2cf5ffqq30g1M3Q"},
{"content":{"org.matrix.msc1767.text":"will be back later","body":"will be back later","msgtype":"m.text"},"ts":1668796675615,"senderName":"James M Snell","senderId":"@jasnell:matrix.org","id":"$J-349cAXc6zGheYy0AeV2-bSDp3-FTY4XvorT673Apk"},
{"content":{"org.matrix.msc1767.text":"(I'm looking for Marks' comments on mutability during our call)","body":"(I'm looking for Marks' comments on mutability during our call)","msgtype":"m.text"},"ts":1668796806734,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$tQxbIfxK6muhaSBw0nq7YCNJLuqrWE6iPFOwxb1LKq8"},
{"content":{"org.matrix.msc1767.text":"The model that I'm building the slides is simple to explain only because we don't need deep integration with the runtime","body":"The model that I'm building the slides is simple to explain only because we don't need deep integration with the runtime","msgtype":"m.text"},"ts":1668796845306,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$I-U5UB3M1G6UCyl5pPU32WKf-BOv7f-9u-Al-hHqnBE"},
{"content":{"org.matrix.msc1767.message":[{"body":"If we were to support mutable contexts, it would either\n- allow one function to replace the context for sibling calls (which I think is what Mark is objecting to)\n- push a context onto the stack (but then it's not obvious where we would pop with deep integration with the host's actual call stack)","mimetype":"text/plain"},{"body":"<p>If we were to support mutable contexts, it would either</p>\n<ul>\n<li>allow one function to replace the context for sibling calls (which I think is what Mark is objecting to)</li>\n<li>push a context onto the stack (but then it's not obvious where we would pop with deep integration with the host's actual call stack)</li>\n</ul>\n","mimetype":"text/html"}],"body":"If we were to support mutable contexts, it would either\n- allow one function to replace the context for sibling calls (which I think is what Mark is objecting to)\n- push a context onto the stack (but then it's not obvious where we would pop with deep integration with the host's actual call stack)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>If we were to support mutable contexts, it would either</p>\n<ul>\n<li>allow one function to replace the context for sibling calls (which I think is what Mark is objecting to)</li>\n<li>push a context onto the stack (but then it's not obvious where we would pop with deep integration with the host's actual call stack)</li>\n</ul>\n"},"ts":1668796977947,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$CLCGcYwqSxQJm5Cli7LQW1NJFDeFbBQL2sfpKJH3dVw"},
{"content":{"org.matrix.msc1767.message":[{"body":"It's _possible_ we could work this with Disposable proposal, but I don't want to the two proposals together","mimetype":"text/plain"},{"body":"It's <em>possible</em> we could work this with Disposable proposal, but I don't want to the two proposals together","mimetype":"text/html"}],"body":"It's _possible_ we could work this with Disposable proposal, but I don't want to the two proposals together","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"It's <em>possible</em> we could work this with Disposable proposal, but I don't want to the two proposals together"},"ts":1668797027195,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$zG-hZGfT7my-MxHW8wihE-UaLbx6y5eQBLdkK0mJ9Cs"},
{"content":{"org.matrix.msc1767.message":[{"body":"The current `.run()`'s try-finally push-call-pop can be understood extremely easily and it's directly teachable with what's possible in userland today with sync execution","mimetype":"text/plain"},{"body":"The current <code>.run()</code>'s try-finally push-call-pop can be understood extremely easily and it's directly teachable with what's possible in userland today with sync execution","mimetype":"text/html"}],"body":"The current `.run()`'s try-finally push-call-pop can be understood extremely easily and it's directly teachable with what's possible in userland today with sync execution","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"The current <code>.run()</code>'s try-finally push-call-pop can be understood extremely easily and it's directly teachable with what's possible in userland today with sync execution"},"ts":1668797114359,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$VWgIBL_btB2XM2N7mFpywBweUc5vNZXLBvYmD9FaerU"},
{"content":{"org.matrix.msc1767.message":[{"body":"I _really_ like that it's simple","mimetype":"text/plain"},{"body":"I <em>really</em> like that it's simple","mimetype":"text/html"}],"body":"I _really_ like that it's simple","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"I <em>really</em> like that it's simple"},"ts":1668797120756,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$tbI5ZrrosP_qtBDoLIVQVWSkEbR82ex_OVXDH8lJyVQ"},
{"content":{"org.matrix.msc1767.message":[{"body":"> - allow one function to replace the context for sibling calls (which I think is what Mark is objecting to)\n\n\nIn a mutable context world, you would use `.copyContext()` to clone the global context to avoid mutations in siblings.","mimetype":"text/plain"},{"body":"<blockquote>\n<ul>\n<li>allow one function to replace the context for sibling calls (which I think is what Mark is objecting to)</li>\n</ul>\n</blockquote>\n<p>In a mutable context world, you would use <code>.copyContext()</code> to clone the global context to avoid mutations in siblings.</p>\n","mimetype":"text/html"}],"body":"> - allow one function to replace the context for sibling calls (which I think is what Mark is objecting to)\n\n\nIn a mutable context world, you would use `.copyContext()` to clone the global context to avoid mutations in siblings.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<ul>\n<li>allow one function to replace the context for sibling calls (which I think is what Mark is objecting to)</li>\n</ul>\n</blockquote>\n<p>In a mutable context world, you would use <code>.copyContext()</code> to clone the global context to avoid mutations in siblings.</p>\n"},"ts":1668800486222,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zIbxCzM8X5YI6qNlahWm_TbOkRelQUtHP5uLESX41DQ"},
{"content":{"org.matrix.msc1767.text":"Here's the part where Mark starts talking about mutability: https://youtu.be/Y6hQLM08Ig8?t=4513","body":"Here's the part where Mark starts talking about mutability: https://youtu.be/Y6hQLM08Ig8?t=4513","msgtype":"m.text"},"ts":1668800491844,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$g7Kfk4XfLPeMUecsn_TiUKWx6NEjR-LfizRY3SeTBQc"},
{"content":{"org.matrix.msc1767.text":"And a bit more at https://youtu.be/Y6hQLM08Ig8?t=5106","body":"And a bit more at https://youtu.be/Y6hQLM08Ig8?t=5106","msgtype":"m.text"},"ts":1668800641053,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$qzvfPghXcc_T-72zOaRuIuPzu5-b4JuKS9YQ_kel9eE"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> But I would argue to have both rather than just one or the other.\n\nYeah, my interpretation has been that each can express the other; that's why my intuition was that we should go with the smaller API surface","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$OUB6pfa8LnVFdvDbr2ACzbprDaTKDP9kDMIWQkbLu64?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>But I would argue to have both rather than just one or the other.</blockquote></mx-reply>Yeah, my interpretation has been that each can express the other; that's why my intuition was that we should go with the smaller API surface","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> But I would argue to have both rather than just one or the other.\n\nYeah, my interpretation has been that each can express the other; that's why my intuition was that we should go with the smaller API surface","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$OUB6pfa8LnVFdvDbr2ACzbprDaTKDP9kDMIWQkbLu64?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>But I would argue to have both rather than just one or the other.</blockquote></mx-reply>Yeah, my interpretation has been that each can express the other; that's why my intuition was that we should go with the smaller API surface","m.relates_to":{"m.in_reply_to":{"event_id":"$OUB6pfa8LnVFdvDbr2ACzbprDaTKDP9kDMIWQkbLu64"}}},"ts":1668807522108,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$KoLrYMcBh8Yx2wVaBhhNbkS00uR6Vvd2N5agP49a2BQ"},
{"content":{"org.matrix.msc1767.message":[{"body":"(smaller API surface was a guiding principle of Chengzhong Wu 's recent edits and I like it, even if I have other preferences for the exact form)","mimetype":"text/plain"},{"body":"(smaller API surface was a guiding principle of <a href=\"https://matrix.to/#/@legendecas:matrix.org\">Chengzhong Wu</a> 's recent edits and I like it, even if I have other preferences for the exact form)","mimetype":"text/html"}],"body":"(smaller API surface was a guiding principle of Chengzhong Wu 's recent edits and I like it, even if I have other preferences for the exact form)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"(smaller API surface was a guiding principle of <a href=\"https://matrix.to/#/@legendecas:matrix.org\">Chengzhong Wu</a> 's recent edits and I like it, even if I have other preferences for the exact form)"},"ts":1668807565458,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$7rmLWa552bFcdiZ6nO6XcxOKzovsQ1TqK0D00KFuj44"},
{"content":{"org.matrix.msc1767.message":[{"body":"I don't mind a small API surface, my concerns stem from ensuring the appropriate building blocks are surfaced. Most of what I've mentioned is inconsequential, you can implement some of the missing functionality in terms of other functionality. The `@AsyncLocal` or `new AsyncLocal()` approach can't be solved with the current API, which makes it infeasible to do in userland. Suspending and resuming global async context flow is only barely feasible given that it requires you do `const emptyContext = AsyncContext.wrap((cb, ...args) => cb(...args))` at the top level before any context is created, which certainly isn't a great developer experience.","mimetype":"text/plain"},{"body":"I don't mind a small API surface, my concerns stem from ensuring the appropriate building blocks are surfaced. Most of what I've mentioned is inconsequential, you can implement some of the missing functionality in terms of other functionality. The <code>@AsyncLocal</code> or <code>new AsyncLocal()</code> approach can't be solved with the current API, which makes it infeasible to do in userland. Suspending and resuming global async context flow is only barely feasible given that it requires you do <code>const emptyContext = AsyncContext.wrap((cb, ...args) =&gt; cb(...args))</code> at the top level before any context is created, which certainly isn't a great developer experience.","mimetype":"text/html"}],"body":"I don't mind a small API surface, my concerns stem from ensuring the appropriate building blocks are surfaced. Most of what I've mentioned is inconsequential, you can implement some of the missing functionality in terms of other functionality. The `@AsyncLocal` or `new AsyncLocal()` approach can't be solved with the current API, which makes it infeasible to do in userland. Suspending and resuming global async context flow is only barely feasible given that it requires you do `const emptyContext = AsyncContext.wrap((cb, ...args) => cb(...args))` at the top level before any context is created, which certainly isn't a great developer experience.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"I don't mind a small API surface, my concerns stem from ensuring the appropriate building blocks are surfaced. Most of what I've mentioned is inconsequential, you can implement some of the missing functionality in terms of other functionality. The <code>@AsyncLocal</code> or <code>new AsyncLocal()</code> approach can't be solved with the current API, which makes it infeasible to do in userland. Suspending and resuming global async context flow is only barely feasible given that it requires you do <code>const emptyContext = AsyncContext.wrap((cb, ...args) =&gt; cb(...args))</code> at the top level before any context is created, which certainly isn't a great developer experience."},"ts":1668808480006,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TGkHQRGyK-atLDnBC2CQEj5iyuUTK6nxG47zgZ_-Mso"},
{"content":{"org.matrix.msc1767.text":"Could this be solve by using a mutable object in the context, and allowing a default value when constructing?","body":"Could this be solve by using a mutable object in the context, and allowing a default value when constructing?","msgtype":"m.text"},"ts":1668808709529,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$gZCzl-GGebCdQFswxNCcwA88H90OrCRE1jSyh-ZySVw"},
{"content":{"org.matrix.msc1767.text":"I don't understand the decorator usecase yet.","body":"I don't understand the decorator usecase yet.","msgtype":"m.text"},"ts":1668808719602,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$MEgW70nUNL7HL8cLpR-r41oIoNmCm6AcUCOik32ka7E"},
{"content":{"org.matrix.msc1767.message":[{"body":"But a default value would allow the your `AsyncLocal` example to work at the top-level","mimetype":"text/plain"},{"body":"But a default value would allow the your <code>AsyncLocal</code> example to work at the top-level","mimetype":"text/html"}],"body":"But a default value would allow the your `AsyncLocal` example to work at the top-level","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"But a default value would allow the your <code>AsyncLocal</code> example to work at the top-level"},"ts":1668808752606,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$7MUMEyWtR3oPzs4OB6z87vrVm5snW5JOaFLMaRSU078"},
{"content":{"org.matrix.msc1767.text":"(React also allows a default value for its contexts)","body":"(React also allows a default value for its contexts)","msgtype":"m.text"},"ts":1668808760938,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$aszqKcbXEHzzFxXImzzmW6jSUNJNUmzj1wg5VZKRi3I"},
{"content":{"org.matrix.msc1767.message":[{"body":"Except there's no way to switch contexts with just `@AsyncLocal`, it depends on the ability to copy a context or suppress async flow to actually get a different value each time.","mimetype":"text/plain"},{"body":"Except there's no way to switch contexts with just <code>@AsyncLocal</code>, it depends on the ability to copy a context or suppress async flow to actually get a different value each time.","mimetype":"text/html"}],"body":"Except there's no way to switch contexts with just `@AsyncLocal`, it depends on the ability to copy a context or suppress async flow to actually get a different value each time.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Except there's no way to switch contexts with just <code>@AsyncLocal</code>, it depends on the ability to copy a context or suppress async flow to actually get a different value each time."},"ts":1668808836505,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$qkSCfviFICucm1VJclR051EUbSiEtnLHOJsDjHg18f8"},
{"content":{"org.matrix.msc1767.text":"Can you explain more? What would code using this look like?","body":"Can you explain more? What would code using this look like?","msgtype":"m.text"},"ts":1668808875509,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$DJCorkuYcs6ruRnXXqW9yGofYzsW4RAkvT_79nBfhaM"},
{"content":{"org.matrix.msc1767.text":"I don't understand what a context would do unless there is execution that happens further down the callstack","body":"I don't understand what a context would do unless there is execution that happens further down the callstack","msgtype":"m.text"},"ts":1668808903372,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$5xqjMk_OhWVUPO8PbTOhrlLkYq-LhnnAdW7kBV_Li_4"},
{"content":{"org.matrix.msc1767.message":[{"body":"One moment, I'm refreshing my knowledge of how `AsyncLocal` works in .NET to make sure I'm not misspeaking","mimetype":"text/plain"},{"body":"One moment, I'm refreshing my knowledge of how <code>AsyncLocal</code> works in .NET to make sure I'm not misspeaking","mimetype":"text/html"}],"body":"One moment, I'm refreshing my knowledge of how `AsyncLocal` works in .NET to make sure I'm not misspeaking","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"One moment, I'm refreshing my knowledge of how <code>AsyncLocal</code> works in .NET to make sure I'm not misspeaking"},"ts":1668809087953,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$efhaKoPwDeVEixezVR3lgdYzwXZhMUdGA453xWRiT-s"},
{"content":{"org.matrix.msc1767.text":"yeah I agree you shouldn't have to run top-level code (this always creates problems with composition/packaging), but I'd like to understand the use case for escaping all the contexts","body":"yeah I agree you shouldn't have to run top-level code (this always creates problems with composition/packaging), but I'd like to understand the use case for escaping all the contexts","msgtype":"m.text"},"ts":1668809159301,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$tnjxcBD_LwILjV4ekg75ncmKcvPJUovKR0zzEU6HLV0"},
{"content":{"org.matrix.msc1767.text":"we should expect the platform itself to make some context variables too, so I'm not even sure what it means to escape all of them","body":"we should expect the platform itself to make some context variables too, so I'm not even sure what it means to escape all of them","msgtype":"m.text"},"ts":1668809227468,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$N8h2v4XsKI03w2PaWwfkUp4KbTpMTQJ-7lL_4mp7zXI"},
{"content":{"org.matrix.msc1767.message":[{"body":"It looks like how .NET's `AsyncLocal` works, is that each \"mutation\" of the local results in the local values in the execution context being copied, such that when an `await` occurs, the current snapshot of the locals in the execution context is copied to the context bound to that `await`.","mimetype":"text/plain"},{"body":"It looks like how .NET's <code>AsyncLocal</code> works, is that each &quot;mutation&quot; of the local results in the local values in the execution context being copied, such that when an <code>await</code> occurs, the current snapshot of the locals in the execution context is copied to the context bound to that <code>await</code>.","mimetype":"text/html"}],"body":"It looks like how .NET's `AsyncLocal` works, is that each \"mutation\" of the local results in the local values in the execution context being copied, such that when an `await` occurs, the current snapshot of the locals in the execution context is copied to the context bound to that `await`.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"It looks like how .NET's <code>AsyncLocal</code> works, is that each &quot;mutation&quot; of the local results in the local values in the execution context being copied, such that when an <code>await</code> occurs, the current snapshot of the locals in the execution context is copied to the context bound to that <code>await</code>."},"ts":1668809251584,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$seodq2hU1NUirAOnJeaSp_3vYsOJJeGQHHxM6wJMFrA"},
{"content":{"org.matrix.msc1767.message":[{"body":"So based on that, here's a rough example:\n```js\nconst local = new AsyncLocal();\nlocal.value = 1;\nawait foo(); \n\n// mutation of local doesn't change the snapshot seen by the `await` in foo\nlocal.value = 2; \n\nawait bar();\n\nfunction foo() {\n  console.log(local.value); // 1\n\n  // takes snapshot of current async execution context\n  // restores snapshot when `await` resumes\n  await Promise.resolve(); \n\n  console.log(local.value); // 1\n}\n\nfunction bar() {\n  console.log(local.value); // 2\n\n  // takes snapshot of current async execution context\n  // restores snapshot when `await` resumes\n  await Promise.resolve(); \n\n  console.log(local.value); // 2\n}\n```","mimetype":"text/plain"},{"body":"<p>So based on that, here's a rough example:</p>\n<pre><code class=\"language-js\">const local = new AsyncLocal();\nlocal.value = 1;\nawait foo(); \n\n// mutation of local doesn't change the snapshot seen by the `await` in foo\nlocal.value = 2; \n\nawait bar();\n\nfunction foo() {\n  console.log(local.value); // 1\n\n  // takes snapshot of current async execution context\n  // restores snapshot when `await` resumes\n  await Promise.resolve(); \n\n  console.log(local.value); // 1\n}\n\nfunction bar() {\n  console.log(local.value); // 2\n\n  // takes snapshot of current async execution context\n  // restores snapshot when `await` resumes\n  await Promise.resolve(); \n\n  console.log(local.value); // 2\n}\n</code></pre>\n","mimetype":"text/html"}],"body":"So based on that, here's a rough example:\n```js\nconst local = new AsyncLocal();\nlocal.value = 1;\nawait foo(); \n\n// mutation of local doesn't change the snapshot seen by the `await` in foo\nlocal.value = 2; \n\nawait bar();\n\nfunction foo() {\n  console.log(local.value); // 1\n\n  // takes snapshot of current async execution context\n  // restores snapshot when `await` resumes\n  await Promise.resolve(); \n\n  console.log(local.value); // 1\n}\n\nfunction bar() {\n  console.log(local.value); // 2\n\n  // takes snapshot of current async execution context\n  // restores snapshot when `await` resumes\n  await Promise.resolve(); \n\n  console.log(local.value); // 2\n}\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>So based on that, here's a rough example:</p>\n<pre><code class=\"language-js\">const local = new AsyncLocal();\nlocal.value = 1;\nawait foo(); \n\n// mutation of local doesn't change the snapshot seen by the `await` in foo\nlocal.value = 2; \n\nawait bar();\n\nfunction foo() {\n  console.log(local.value); // 1\n\n  // takes snapshot of current async execution context\n  // restores snapshot when `await` resumes\n  await Promise.resolve(); \n\n  console.log(local.value); // 1\n}\n\nfunction bar() {\n  console.log(local.value); // 2\n\n  // takes snapshot of current async execution context\n  // restores snapshot when `await` resumes\n  await Promise.resolve(); \n\n  console.log(local.value); // 2\n}\n</code></pre>\n"},"ts":1668809486981,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rMnSmztE0MP8O3z1YJL9Vd3GiaY1Ous8GTjCelyGVwQ"},
{"content":{"org.matrix.msc1767.message":[{"body":"yeah, I can see how this snapshotting approach is convenient; I guess I prefer the `run`-based API which makes it a bit more explicit when the copying occurs","mimetype":"text/plain"},{"body":"yeah, I can see how this snapshotting approach is convenient; I guess I prefer the <code>run</code>-based API which makes it a bit more explicit when the copying occurs","mimetype":"text/html"}],"body":"yeah, I can see how this snapshotting approach is convenient; I guess I prefer the `run`-based API which makes it a bit more explicit when the copying occurs","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"yeah, I can see how this snapshotting approach is convenient; I guess I prefer the <code>run</code>-based API which makes it a bit more explicit when the copying occurs"},"ts":1668809616650,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$U7IkEaYGyqZQULuYlBi25hNrcq_phx32SmV6go4Nr48"},
{"content":{"org.matrix.msc1767.text":"I sort of assumed that, with what's in the main branch of AsyncContext, the get/set functions didn't have any copying semantics, that you're responsible for saving and restoring things when appropriate","body":"I sort of assumed that, with what's in the main branch of AsyncContext, the get/set functions didn't have any copying semantics, that you're responsible for saving and restoring things when appropriate","msgtype":"m.text"},"ts":1668809662197,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$sGm9FwphlqAWgANYNZ_wOz8TQ_y2En6f758YMippd30"},
{"content":{"org.matrix.msc1767.text":"maybe I understood wrong?","body":"maybe I understood wrong?","msgtype":"m.text"},"ts":1668809733961,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$27q8HOUwOLCS1tBSYT3zVByUNlNwegNqni_NACRBhi4"},
{"content":{"org.matrix.msc1767.message":[{"body":"anyway if you only have `run` and not a setter, then it is sort of clearer why `run` doesn't hold in the reaction (because you've already exited it by then)","mimetype":"text/plain"},{"body":"anyway if you only have <code>run</code> and not a setter, then it is sort of clearer why <code>run</code> doesn't hold in the reaction (because you've already exited it by then)","mimetype":"text/html"}],"body":"anyway if you only have `run` and not a setter, then it is sort of clearer why `run` doesn't hold in the reaction (because you've already exited it by then)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"anyway if you only have <code>run</code> and not a setter, then it is sort of clearer why <code>run</code> doesn't hold in the reaction (because you've already exited it by then)"},"ts":1668809826233,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$-5a2NerBd1Tl7wWEyUmvHHG5u_JTxza5x6C5IULXTLs"},
{"content":{"org.matrix.msc1767.message":[{"body":"I think earlier I said .NET has two approaches: `AsyncLocal` which stores a local associated with async control flow, and `ExecutionContext`, which has a logical call context that can have data stored within it.","mimetype":"text/plain"},{"body":"I think earlier I said .NET has two approaches: <code>AsyncLocal</code> which stores a local associated with async control flow, and <code>ExecutionContext</code>, which has a logical call context that can have data stored within it.","mimetype":"text/html"}],"body":"I think earlier I said .NET has two approaches: `AsyncLocal` which stores a local associated with async control flow, and `ExecutionContext`, which has a logical call context that can have data stored within it.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"I think earlier I said .NET has two approaches: <code>AsyncLocal</code> which stores a local associated with async control flow, and <code>ExecutionContext</code>, which has a logical call context that can have data stored within it."},"ts":1668809858868,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ow3gNyqpaikhtJ71sV7LwlVQKV4a2dOlT5BuM8BJJFo"},
{"content":{"org.matrix.msc1767.message":[{"body":"`ExecutionContext.Run()` is kind of like `AsyncContext.prototype.run()`, except it covers the entire execution context, not just a single value.","mimetype":"text/plain"},{"body":"<code>ExecutionContext.Run()</code> is kind of like <code>AsyncContext.prototype.run()</code>, except it covers the entire execution context, not just a single value.","mimetype":"text/html"}],"body":"`ExecutionContext.Run()` is kind of like `AsyncContext.prototype.run()`, except it covers the entire execution context, not just a single value.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<code>ExecutionContext.Run()</code> is kind of like <code>AsyncContext.prototype.run()</code>, except it covers the entire execution context, not just a single value."},"ts":1668809894834,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FdC1H9xT8vKZOZYFastZR9vGSB-B9W4wr40SeTdpbow"},
{"content":{"org.matrix.msc1767.message":[{"body":"`AsyncLocal` state is _stored_ in an `ExecutionContext`, but that context is captured and restored whenever you create a `Task` or a task continuation is invoked.","mimetype":"text/plain"},{"body":"<code>AsyncLocal</code> state is <em>stored</em> in an <code>ExecutionContext</code>, but that context is captured and restored whenever you create a <code>Task</code> or a task continuation is invoked.","mimetype":"text/html"}],"body":"`AsyncLocal` state is _stored_ in an `ExecutionContext`, but that context is captured and restored whenever you create a `Task` or a task continuation is invoked.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<code>AsyncLocal</code> state is <em>stored</em> in an <code>ExecutionContext</code>, but that context is captured and restored whenever you create a <code>Task</code> or a task continuation is invoked."},"ts":1668809948517,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cZQplNaJUAM1jdfLRbfTSyXVQOK3du2TkulncNLmFsI"},
{"content":{"org.matrix.msc1767.message":[{"body":"So `AsyncLocal` (which snapshots) is built on an `ExecutionContext` (which is mutable).","mimetype":"text/plain"},{"body":"So <code>AsyncLocal</code> (which snapshots) is built on an <code>ExecutionContext</code> (which is mutable).","mimetype":"text/html"}],"body":"So `AsyncLocal` (which snapshots) is built on an `ExecutionContext` (which is mutable).","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"So <code>AsyncLocal</code> (which snapshots) is built on an <code>ExecutionContext</code> (which is mutable)."},"ts":1668809980262,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NR73Pl_FSQ_1FeicmJ8YV5xhFTGG4bLhZMmtNCH36GY"},
{"content":{"org.matrix.msc1767.text":"I see","body":"I see","msgtype":"m.text"},"ts":1668810093008,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$DL_0cvBvMWNRAnOSWrk9B6nJBR0xOPPVUawWeX9UbRY"},
{"content":{"org.matrix.msc1767.text":"Do you have an example of something you can do in this system which wouldn't work with the kinds of approaches we've been discussing?","body":"Do you have an example of something you can do in this system which wouldn't work with the kinds of approaches we've been discussing?","msgtype":"m.text"},"ts":1668810127976,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$gMsthcZOkSBcMHGvQLOGUbFjhYSgl2N3AATRbZkD9qY"},
{"content":{"org.matrix.msc1767.text":"(apologies if that's above)","body":"(apologies if that's above)","msgtype":"m.text"},"ts":1668810137516,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$UcS4P0QQrvPdZiGDQsRO223G7vjpMlCjBebT7zXXPo8"},
{"content":{"org.matrix.msc1767.message":[{"body":"So in .NET, you can do:\n```cs\nLogicalCallContext.SetData(\"foo\", 1);\nvar context = ExecutionContext.Capture();\n\nExecutionContext.Run(context, () => {\n  Console.WriteLine(LogicalCallContext.GetData(\"foo\")); // 1\n  LogicalCallContext.SetData(\"foo\", 2);\n});\n\nConsole.WriteLine(LogicalCallContext.GetData(\"foo\")); // 2\n```\nSince the context is mutable.","mimetype":"text/plain"},{"body":"<p>So in .NET, you can do:</p>\n<pre><code class=\"language-cs\">LogicalCallContext.SetData(&quot;foo&quot;, 1);\nvar context = ExecutionContext.Capture();\n\nExecutionContext.Run(context, () =&gt; {\n  Console.WriteLine(LogicalCallContext.GetData(&quot;foo&quot;)); // 1\n  LogicalCallContext.SetData(&quot;foo&quot;, 2);\n});\n\nConsole.WriteLine(LogicalCallContext.GetData(&quot;foo&quot;)); // 2\n</code></pre>\n<p>Since the context is mutable.</p>\n","mimetype":"text/html"}],"body":"So in .NET, you can do:\n```cs\nLogicalCallContext.SetData(\"foo\", 1);\nvar context = ExecutionContext.Capture();\n\nExecutionContext.Run(context, () => {\n  Console.WriteLine(LogicalCallContext.GetData(\"foo\")); // 1\n  LogicalCallContext.SetData(\"foo\", 2);\n});\n\nConsole.WriteLine(LogicalCallContext.GetData(\"foo\")); // 2\n```\nSince the context is mutable.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>So in .NET, you can do:</p>\n<pre><code class=\"language-cs\">LogicalCallContext.SetData(&quot;foo&quot;, 1);\nvar context = ExecutionContext.Capture();\n\nExecutionContext.Run(context, () =&gt; {\n  Console.WriteLine(LogicalCallContext.GetData(&quot;foo&quot;)); // 1\n  LogicalCallContext.SetData(&quot;foo&quot;, 2);\n});\n\nConsole.WriteLine(LogicalCallContext.GetData(&quot;foo&quot;)); // 2\n</code></pre>\n<p>Since the context is mutable.</p>\n"},"ts":1668810210987,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$66OSPskhmNln_EXXY3BzWjr9ThszY6hyYJKiFFRtqaU"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> Do you have an example of something you can do in this system which wouldn't work with the kinds of approaches we've been discussing?\n\nSince AsyncLocal does snapshotting, its very useful for fork/join operations like this:\n```js\nconst local = new AsyncLocal();\nlocal.value = 1;\nawait Promise.all(operations.map(async (op) => {\n  await op.execute(); // where op.execute reads or writes local.value\n}));\n```\nWhere each `op.execute()` gets a copy of the state, such that any state mutations don't affect other parallel tasks.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$gMsthcZOkSBcMHGvQLOGUbFjhYSgl2N3AATRbZkD9qY?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Do you have an example of something you can do in this system which wouldn&#39;t work with the kinds of approaches we&#39;ve been discussing?</blockquote></mx-reply><p>Since AsyncLocal does snapshotting, its very useful for fork/join operations like this:</p>\n<pre><code class=\"language-js\">const local = new AsyncLocal();\nlocal.value = 1;\nawait Promise.all(operations.map(async (op) =&gt; {\n  await op.execute(); // where op.execute reads or writes local.value\n}));\n</code></pre>\n<p>Where each <code>op.execute()</code> gets a copy of the state, such that any state mutations don't affect other parallel tasks.</p>\n","mimetype":"text/html"}],"body":"> <@littledan:matrix.org> Do you have an example of something you can do in this system which wouldn't work with the kinds of approaches we've been discussing?\n\nSince AsyncLocal does snapshotting, its very useful for fork/join operations like this:\n```js\nconst local = new AsyncLocal();\nlocal.value = 1;\nawait Promise.all(operations.map(async (op) => {\n  await op.execute(); // where op.execute reads or writes local.value\n}));\n```\nWhere each `op.execute()` gets a copy of the state, such that any state mutations don't affect other parallel tasks.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$gMsthcZOkSBcMHGvQLOGUbFjhYSgl2N3AATRbZkD9qY?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Do you have an example of something you can do in this system which wouldn&#39;t work with the kinds of approaches we&#39;ve been discussing?</blockquote></mx-reply><p>Since AsyncLocal does snapshotting, its very useful for fork/join operations like this:</p>\n<pre><code class=\"language-js\">const local = new AsyncLocal();\nlocal.value = 1;\nawait Promise.all(operations.map(async (op) =&gt; {\n  await op.execute(); // where op.execute reads or writes local.value\n}));\n</code></pre>\n<p>Where each <code>op.execute()</code> gets a copy of the state, such that any state mutations don't affect other parallel tasks.</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$gMsthcZOkSBcMHGvQLOGUbFjhYSgl2N3AATRbZkD9qY"}}},"ts":1668810417242,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5YMu8fXIGp3vOQ1rhQlivoy8NvgTXgyW9uYVzX54t-k"},
{"content":{"org.matrix.msc1767.message":[{"body":"In reality, this probably can't be implemented in userland regardless. The kind of snapshotting that is necessary would require the same hooks that `AsyncContext` needs to restore the context after `await`.","mimetype":"text/plain"},{"body":"In reality, this probably can't be implemented in userland regardless. The kind of snapshotting that is necessary would require the same hooks that <code>AsyncContext</code> needs to restore the context after <code>await</code>.","mimetype":"text/html"}],"body":"In reality, this probably can't be implemented in userland regardless. The kind of snapshotting that is necessary would require the same hooks that `AsyncContext` needs to restore the context after `await`.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"In reality, this probably can't be implemented in userland regardless. The kind of snapshotting that is necessary would require the same hooks that <code>AsyncContext</code> needs to restore the context after <code>await</code>."},"ts":1668810512605,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$787rZyMx5V5Phnqe5ThrS_cAyXqLHJK_mVR2AX1CDvk"},
{"content":{"org.matrix.msc1767.message":[{"body":"the upside of `AsyncLocal` is that you don't really need to worry about closures and TCP","mimetype":"text/plain"},{"body":"the upside of <code>AsyncLocal</code> is that you don't really need to worry about closures and TCP","mimetype":"text/html"}],"body":"the upside of `AsyncLocal` is that you don't really need to worry about closures and TCP","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"the upside of <code>AsyncLocal</code> is that you don't really need to worry about closures and TCP"},"ts":1668810581610,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1ASuDMtW9Ji0fy18lg0DGfpcdgbRRFvojzkOH4x6QpM"},
{"content":{"org.matrix.msc1767.message":[{"body":"I guess all of the alternatives here have the property (which I agree is essential) that you can write to the variable without affecting parallel tasks. The `run` method certainly does, at least.","mimetype":"text/plain"},{"body":"I guess all of the alternatives here have the property (which I agree is essential) that you can write to the variable without affecting parallel tasks. The <code>run</code> method certainly does, at least.","mimetype":"text/html"}],"body":"I guess all of the alternatives here have the property (which I agree is essential) that you can write to the variable without affecting parallel tasks. The `run` method certainly does, at least.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"I guess all of the alternatives here have the property (which I agree is essential) that you can write to the variable without affecting parallel tasks. The <code>run</code> method certainly does, at least."},"ts":1668810585692,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kqcVHxtjOhoHK85hZ5Sy-sZczLw7SfjZ5XuPmIYpulU"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> the upside of `AsyncLocal` is that you don't really need to worry about closures and TCP\n\nI see, I guess this is the part I need to understand better (probably you already explained this and I need to reread the logs)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$1ASuDMtW9Ji0fy18lg0DGfpcdgbRRFvojzkOH4x6QpM?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>the upside of <code>AsyncLocal</code> is that you don't really need to worry about closures and TCP</blockquote></mx-reply>I see, I guess this is the part I need to understand better (probably you already explained this and I need to reread the logs)","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> the upside of `AsyncLocal` is that you don't really need to worry about closures and TCP\n\nI see, I guess this is the part I need to understand better (probably you already explained this and I need to reread the logs)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$1ASuDMtW9Ji0fy18lg0DGfpcdgbRRFvojzkOH4x6QpM?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>the upside of <code>AsyncLocal</code> is that you don't really need to worry about closures and TCP</blockquote></mx-reply>I see, I guess this is the part I need to understand better (probably you already explained this and I need to reread the logs)","m.relates_to":{"m.in_reply_to":{"event_id":"$1ASuDMtW9Ji0fy18lg0DGfpcdgbRRFvojzkOH4x6QpM"}}},"ts":1668810650512,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ZpScDRivnMUKTylPlhULwFVnEte5nytQk3MGz91hjpI"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> I guess all of the alternatives here have the property (which I agree is essential) that you can write to the variable without affecting parallel tasks. The `run` method certainly does, at least.\n\nI guess the get/set functions in the main branch would not handle this properly","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$kqcVHxtjOhoHK85hZ5Sy-sZczLw7SfjZ5XuPmIYpulU?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I guess all of the alternatives here have the property (which I agree is essential) that you can write to the variable without affecting parallel tasks. The <code>run</code> method certainly does, at least.</blockquote></mx-reply>I guess the get/set functions in the main branch would not handle this properly","mimetype":"text/html"}],"body":"> <@littledan:matrix.org> I guess all of the alternatives here have the property (which I agree is essential) that you can write to the variable without affecting parallel tasks. The `run` method certainly does, at least.\n\nI guess the get/set functions in the main branch would not handle this properly","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$kqcVHxtjOhoHK85hZ5Sy-sZczLw7SfjZ5XuPmIYpulU?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I guess all of the alternatives here have the property (which I agree is essential) that you can write to the variable without affecting parallel tasks. The <code>run</code> method certainly does, at least.</blockquote></mx-reply>I guess the get/set functions in the main branch would not handle this properly","m.relates_to":{"m.in_reply_to":{"event_id":"$kqcVHxtjOhoHK85hZ5Sy-sZczLw7SfjZ5XuPmIYpulU"}}},"ts":1668810688289,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ZwOSQuUBDGKMLlefDhe4RsysNhzl4a7_PiHi3POsvyA"},
{"content":{"org.matrix.msc1767.text":"No, I've been a bit randomized today so I feel I've been jumping around between topics too frequently and may not be making a coherent argument.","body":"No, I've been a bit randomized today so I feel I've been jumping around between topics too frequently and may not be making a coherent argument.","msgtype":"m.text"},"ts":1668810700736,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hsIN-XhU8Zd5qkaDdON39K-m8MtXnKg0qy4c8vIpqAQ"},
{"content":{"org.matrix.msc1767.message":[{"body":"I'll simplify my thoughts:\n- `new AsyncContext()` is great.\n- `AsyncContext.prototype.run()` is great.\n- `AsyncContext.prototype.get()` is great.\n- The capability introduced by `AsyncContext.wrap()` is necessary, but has some ergonomics issues I have concerns about.\n- The minimal API for `AsyncContext` means some other useful primitives like an `AsyncLocal` can't be modeled in userland. However, its likely it would need to be introduced as a built-in anyways if we wanted anything like snapshotting capabilities such that the value is associated with control flow.\n- A way to suppress and restore the global context is necessary, and I'm not convinced the approach of a \"call to `AsyncContext.wrap()` at the top level\" is sufficiently ergonomic.","mimetype":"text/plain"},{"body":"<p>I'll simplify my thoughts:</p>\n<ul>\n<li><code>new AsyncContext()</code> is great.</li>\n<li><code>AsyncContext.prototype.run()</code> is great.</li>\n<li><code>AsyncContext.prototype.get()</code> is great.</li>\n<li>The capability introduced by <code>AsyncContext.wrap()</code> is necessary, but has some ergonomics issues I have concerns about.</li>\n<li>The minimal API for <code>AsyncContext</code> means some other useful primitives like an <code>AsyncLocal</code> can't be modeled in userland. However, its likely it would need to be introduced as a built-in anyways if we wanted anything like snapshotting capabilities such that the value is associated with control flow.</li>\n<li>A way to suppress and restore the global context is necessary, and I'm not convinced the approach of a &quot;call to <code>AsyncContext.wrap()</code> at the top level&quot; is sufficiently ergonomic.</li>\n</ul>\n","mimetype":"text/html"}],"body":"I'll simplify my thoughts:\n- `new AsyncContext()` is great.\n- `AsyncContext.prototype.run()` is great.\n- `AsyncContext.prototype.get()` is great.\n- The capability introduced by `AsyncContext.wrap()` is necessary, but has some ergonomics issues I have concerns about.\n- The minimal API for `AsyncContext` means some other useful primitives like an `AsyncLocal` can't be modeled in userland. However, its likely it would need to be introduced as a built-in anyways if we wanted anything like snapshotting capabilities such that the value is associated with control flow.\n- A way to suppress and restore the global context is necessary, and I'm not convinced the approach of a \"call to `AsyncContext.wrap()` at the top level\" is sufficiently ergonomic.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>I'll simplify my thoughts:</p>\n<ul>\n<li><code>new AsyncContext()</code> is great.</li>\n<li><code>AsyncContext.prototype.run()</code> is great.</li>\n<li><code>AsyncContext.prototype.get()</code> is great.</li>\n<li>The capability introduced by <code>AsyncContext.wrap()</code> is necessary, but has some ergonomics issues I have concerns about.</li>\n<li>The minimal API for <code>AsyncContext</code> means some other useful primitives like an <code>AsyncLocal</code> can't be modeled in userland. However, its likely it would need to be introduced as a built-in anyways if we wanted anything like snapshotting capabilities such that the value is associated with control flow.</li>\n<li>A way to suppress and restore the global context is necessary, and I'm not convinced the approach of a &quot;call to <code>AsyncContext.wrap()</code> at the top level&quot; is sufficiently ergonomic.</li>\n</ul>\n"},"ts":1668811028966,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3fxYnb7nLKC10CQG3g4bA0FhXXZP9e6O6mLXeTk7d28"},
{"content":{"org.matrix.msc1767.message":[{"body":"If the value associated with an `AsyncContext` is immutable, then a `.copyContext()` isn't necessary because *every* `await` (or other async mechanism) would already snapshot the current global execution context.","mimetype":"text/plain"},{"body":"If the value associated with an <code>AsyncContext</code> is immutable, then a <code>.copyContext()</code> isn't necessary because <em>every</em> <code>await</code> (or other async mechanism) would already snapshot the current global execution context.","mimetype":"text/html"}],"body":"If the value associated with an `AsyncContext` is immutable, then a `.copyContext()` isn't necessary because *every* `await` (or other async mechanism) would already snapshot the current global execution context.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"If the value associated with an <code>AsyncContext</code> is immutable, then a <code>.copyContext()</code> isn't necessary because <em>every</em> <code>await</code> (or other async mechanism) would already snapshot the current global execution context."},"ts":1668811251843,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$EJKa85oo0NWDmQ416rVJ9aO_rZF8ZbPNB_v_hd2a6cc"},
{"content":{"org.matrix.msc1767.message":[{"body":"I guess I could see how freely getting/setting and expecting the snapshotting to be automatic can't be built in terms of `run`, and what I don't understand yet is why we'd want that.","mimetype":"text/plain"},{"body":"I guess I could see how freely getting/setting and expecting the snapshotting to be automatic can't be built in terms of <code>run</code>, and what I don't understand yet is why we'd want that.","mimetype":"text/html"}],"body":"I guess I could see how freely getting/setting and expecting the snapshotting to be automatic can't be built in terms of `run`, and what I don't understand yet is why we'd want that.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"I guess I could see how freely getting/setting and expecting the snapshotting to be automatic can't be built in terms of <code>run</code>, and what I don't understand yet is why we'd want that."},"ts":1668811496278,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kdQZE0aLk-hsj9BLDfih_8YKYhfb0pqe9i0U5Ij_MKc"},
{"content":{"org.matrix.msc1767.text":"I also don't understand in what sorts of cases you'd want to restore the global context","body":"I also don't understand in what sorts of cases you'd want to restore the global context","msgtype":"m.text"},"ts":1668811509529,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XQfRa1PTsVoKgvcBC-fpt_bG5nSB2UmYgKseuHve7pg"},
{"content":{"org.matrix.msc1767.text":"I think we can support both, but I would want to see use cases that can't be solved by the immutable context","body":"I think we can support both, but I would want to see use cases that can't be solved by the immutable context","msgtype":"m.text"},"ts":1668811527228,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$c9yJ2VqaLoA1oRi47KTaSZIJfgEj1VemZAjYP2AFdfU"},
{"content":{"org.matrix.msc1767.text":"I guess I assumed that it'd be an anti-goal to have any sort of notion of the global context","body":"I guess I assumed that it'd be an anti-goal to have any sort of notion of the global context","msgtype":"m.text"},"ts":1668811530695,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$VQ82GY4in57MeXT_RtTK5-FykCDzx3kn9ZzeWUOogAk"},
{"content":{"org.matrix.msc1767.text":"(since it's sort of anti-compositional)","body":"(since it's sort of anti-compositional)","msgtype":"m.text"},"ts":1668811541428,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uc78zXboDbqNHxyZ293AX1nDuZt-P5YUvNkV0yiZ6_w"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> I don’t have a full grasp of it either, but Yoav mentioned it in his talk too. Maybe ask Seb?\n\nSeb pushed me back to talking about `cache`, but dropping `use` discussion (it's not necessary, client will support async/await without it)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$tDGqOVsrDcV1_2LxCbwQ5UxAyd5N8K1GK2lpnporVog?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I don’t have a full grasp of it either, but Yoav mentioned it in his talk too. Maybe ask Seb?</blockquote></mx-reply>Seb pushed me back to talking about <code>cache</code>, but dropping <code>use</code> discussion (it's not necessary, client will support async/await without it)","mimetype":"text/html"}],"body":"> <@littledan:matrix.org> I don’t have a full grasp of it either, but Yoav mentioned it in his talk too. Maybe ask Seb?\n\nSeb pushed me back to talking about `cache`, but dropping `use` discussion (it's not necessary, client will support async/await without it)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$tDGqOVsrDcV1_2LxCbwQ5UxAyd5N8K1GK2lpnporVog?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I don’t have a full grasp of it either, but Yoav mentioned it in his talk too. Maybe ask Seb?</blockquote></mx-reply>Seb pushed me back to talking about <code>cache</code>, but dropping <code>use</code> discussion (it's not necessary, client will support async/await without it)","m.relates_to":{"m.in_reply_to":{"event_id":"$tDGqOVsrDcV1_2LxCbwQ5UxAyd5N8K1GK2lpnporVog"}}},"ts":1668811700001,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$det0UIAdxzjfQ7IlQ6Dwy0QEtlgqDFluli94uNp2avk"},
{"content":{"org.matrix.msc1767.message":[{"body":"Not that I don't need to discuss `use`, I can dive deeper into the real use for this for client side","mimetype":"text/plain"},{"body":"Not that I don't need to discuss <code>use</code>, I can dive deeper into the real use for this for client side","mimetype":"text/html"}],"body":"Not that I don't need to discuss `use`, I can dive deeper into the real use for this for client side","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Not that I don't need to discuss <code>use</code>, I can dive deeper into the real use for this for client side"},"ts":1668811717183,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$QRq19D96YsKPH8rCQ469pItOUUUQ05LIhHrm46qNz6k"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@jridgewell:matrix.org> Seb pushed me back to talking about `cache`, but dropping `use` discussion (it's not necessary, client will support async/await without it)\n\nDid he not like the idea of discussing priorities?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$det0UIAdxzjfQ7IlQ6Dwy0QEtlgqDFluli94uNp2avk?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Seb pushed me back to talking about <code>cache</code>, but dropping <code>use</code> discussion (it's not necessary, client will support async/await without it)</blockquote></mx-reply>Did he not like the idea of discussing priorities?","mimetype":"text/html"}],"body":"> <@jridgewell:matrix.org> Seb pushed me back to talking about `cache`, but dropping `use` discussion (it's not necessary, client will support async/await without it)\n\nDid he not like the idea of discussing priorities?","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$det0UIAdxzjfQ7IlQ6Dwy0QEtlgqDFluli94uNp2avk?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Seb pushed me back to talking about <code>cache</code>, but dropping <code>use</code> discussion (it's not necessary, client will support async/await without it)</blockquote></mx-reply>Did he not like the idea of discussing priorities?","m.relates_to":{"m.in_reply_to":{"event_id":"$det0UIAdxzjfQ7IlQ6Dwy0QEtlgqDFluli94uNp2avk"}}},"ts":1668811723107,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$aCFB5YA1LNm9-i-jiQ7vmIQa508Xp1GwEaBS9sLXypI"},
{"content":{"org.matrix.msc1767.text":"I mean, more importantly: would this feature be useful for priorities?","body":"I mean, more importantly: would this feature be useful for priorities?","msgtype":"m.text"},"ts":1668811752833,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$UQ2ouelGb8O-lcXZEIcpDyRzbTgyosW2ErI3u2VR9qQ"},
{"content":{"org.matrix.msc1767.text":"Yah, he said that priorities really needs brower APIs that this won't solve (the priority scheduler work would be the API)","body":"Yah, he said that priorities really needs brower APIs that this won't solve (the priority scheduler work would be the API)","msgtype":"m.text"},"ts":1668811760173,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$-JX51Lj0LgDv4kOBhO-5wjrYgWNOnOVeVjy2ali-Lfk"},
{"content":{"org.matrix.msc1767.message":[{"body":"Possibly, in that they could store the priority on an `AsyncContext`","mimetype":"text/plain"},{"body":"Possibly, in that they could store the priority on an <code>AsyncContext</code>","mimetype":"text/html"}],"body":"Possibly, in that they could store the priority on an `AsyncContext`","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Possibly, in that they could store the priority on an <code>AsyncContext</code>"},"ts":1668811787750,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$xiNhHI_vRp24z7tUcW5XEgqGij0Mv7yg2ypPQV--X_I"},
{"content":{"org.matrix.msc1767.message":[{"body":"ah, but as discussed in Yoav's talk, browsers are unable to make this capability due to *the need for the same platform feature*","mimetype":"text/plain"},{"body":"ah, but as discussed in Yoav's talk, browsers are unable to make this capability due to <em>the need for the same platform feature</em>","mimetype":"text/html"}],"body":"ah, but as discussed in Yoav's talk, browsers are unable to make this capability due to *the need for the same platform feature*","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"ah, but as discussed in Yoav's talk, browsers are unable to make this capability due to <em>the need for the same platform feature</em>"},"ts":1668811792712,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$SRJncfv7uO2fFtS7JyrdVyJ_QvuHZkJseeRT9oKv_KI"},
{"content":{"org.matrix.msc1767.text":"But it needs platform support to not be able to create a high priority task from a low priority one, and that's not solved by us","body":"But it needs platform support to not be able to create a high priority task from a low priority one, and that's not solved by us","msgtype":"m.text"},"ts":1668811812083,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ha4msEO351bSW-2LsGvmXigoYVyq5RQ2sCsMXTRIVvg"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> I guess I could see how freely getting/setting and expecting the snapshotting to be automatic can't be built in terms of `run`, and what I don't understand yet is why we'd want that.\n\nI think that's actually how the proposal probably works right now.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$kdQZE0aLk-hsj9BLDfih_8YKYhfb0pqe9i0U5Ij_MKc?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I guess I could see how freely getting/setting and expecting the snapshotting to be automatic can't be built in terms of <code>run</code>, and what I don't understand yet is why we'd want that.</blockquote></mx-reply>I think that's actually how the proposal probably works right now.","mimetype":"text/html"}],"body":"> <@littledan:matrix.org> I guess I could see how freely getting/setting and expecting the snapshotting to be automatic can't be built in terms of `run`, and what I don't understand yet is why we'd want that.\n\nI think that's actually how the proposal probably works right now.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$kdQZE0aLk-hsj9BLDfih_8YKYhfb0pqe9i0U5Ij_MKc?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I guess I could see how freely getting/setting and expecting the snapshotting to be automatic can't be built in terms of <code>run</code>, and what I don't understand yet is why we'd want that.</blockquote></mx-reply>I think that's actually how the proposal probably works right now.","m.relates_to":{"m.in_reply_to":{"event_id":"$kdQZE0aLk-hsj9BLDfih_8YKYhfb0pqe9i0U5Ij_MKc"}}},"ts":1668811824790,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0yd6HASjp1H5jRbXtcCFlO5dpEWGKzVue9KhiqSWxpA"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> I think that's actually how the proposal probably works right now.\n\nby \"right now\" you mean the flat get/set variable API in the main branch?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$0yd6HASjp1H5jRbXtcCFlO5dpEWGKzVue9KhiqSWxpA?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I think that's actually how the proposal probably works right now.</blockquote></mx-reply>by &quot;right now&quot; you mean the flat get/set variable API in the main branch?","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> I think that's actually how the proposal probably works right now.\n\nby \"right now\" you mean the flat get/set variable API in the main branch?","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$0yd6HASjp1H5jRbXtcCFlO5dpEWGKzVue9KhiqSWxpA?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I think that's actually how the proposal probably works right now.</blockquote></mx-reply>by &quot;right now&quot; you mean the flat get/set variable API in the main branch?","m.relates_to":{"m.in_reply_to":{"event_id":"$0yd6HASjp1H5jRbXtcCFlO5dpEWGKzVue9KhiqSWxpA"}}},"ts":1668811860042,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$L3Hd6MUGKHTPnPMOBGlCdQ-hN1D_2M_GrSYMbjwlloc"},
{"content":{"org.matrix.msc1767.text":"No","body":"No","msgtype":"m.text"},"ts":1668811864246,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mjHo7uWRfy9DHDuGFTybTjzV_rEBLjEZ_gkpPuUfBSk"},
{"content":{"org.matrix.msc1767.text":"Sorry, no. Snapshotting is likely how we would achieve the semantics that Justin Ridgewell seems to prefer.","body":"Sorry, no. Snapshotting is likely how we would achieve the semantics that Justin Ridgewell seems to prefer.","msgtype":"m.text"},"ts":1668811895760,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$B_YUQE9EWbXMxd-MJUTYv80Sa2kYdGV782nlDMmyMMw"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@jridgewell:matrix.org> But it needs platform support to not be able to create a high priority task from a low priority one, and that's not solved by us\n\nhmm, I would like to dig into this more (but maybe another day/with Seb and/or Yoav)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$ha4msEO351bSW-2LsGvmXigoYVyq5RQ2sCsMXTRIVvg?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>But it needs platform support to not be able to create a high priority task from a low priority one, and that&#39;s not solved by us</blockquote></mx-reply>hmm, I would like to dig into this more (but maybe another day/with Seb and/or Yoav)","mimetype":"text/html"}],"body":"> <@jridgewell:matrix.org> But it needs platform support to not be able to create a high priority task from a low priority one, and that's not solved by us\n\nhmm, I would like to dig into this more (but maybe another day/with Seb and/or Yoav)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$ha4msEO351bSW-2LsGvmXigoYVyq5RQ2sCsMXTRIVvg?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>But it needs platform support to not be able to create a high priority task from a low priority one, and that&#39;s not solved by us</blockquote></mx-reply>hmm, I would like to dig into this more (but maybe another day/with Seb and/or Yoav)","m.relates_to":{"m.in_reply_to":{"event_id":"$ha4msEO351bSW-2LsGvmXigoYVyq5RQ2sCsMXTRIVvg"}}},"ts":1668811904161,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9JUrNQGEXzNcDUZWYEtdAkVe1-U_oehDUU7c06kWWwE"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> Sorry, no. Snapshotting is likely how we would achieve the semantics that Justin Ridgewell seems to prefer.\n\nWhat do you mean by this?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$B_YUQE9EWbXMxd-MJUTYv80Sa2kYdGV782nlDMmyMMw?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Sorry, no. Snapshotting is likely how we would achieve the semantics that Justin Ridgewell seems to prefer.</blockquote></mx-reply>What do you mean by this?","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> Sorry, no. Snapshotting is likely how we would achieve the semantics that Justin Ridgewell seems to prefer.\n\nWhat do you mean by this?","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$B_YUQE9EWbXMxd-MJUTYv80Sa2kYdGV782nlDMmyMMw?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Sorry, no. Snapshotting is likely how we would achieve the semantics that Justin Ridgewell seems to prefer.</blockquote></mx-reply>What do you mean by this?","m.relates_to":{"m.in_reply_to":{"event_id":"$B_YUQE9EWbXMxd-MJUTYv80Sa2kYdGV782nlDMmyMMw"}}},"ts":1668812041146,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Q09Qc9mEqFix86x0ZJTPoq8msW1MZYk_95-Pk1Xn_Tg"},
{"content":{"org.matrix.msc1767.message":[{"body":"Imagine the current execution context as an ImmutableMap. Adding or replacing entries in the map copies the map.\nSo:\n```js\nconst ctx1 = new AsyncContext();\nconst ctx2 = new AsyncContext();\nconst ctx3 = new AsyncContext();\n\n// execution context: {}\nctx1.run(\"a\", () => {\n  // execution context: { [ctx1]: \"a\" }\n  ctx2.run(\"b\", () => {\n    // execution context: { [ctx1]: \"a\", [ctx2]: \"b\" }\n  });\n  ctx3.run(\"c\", () => {\n    // execution context: { [ctx1]: \"a\", [ctx3]: \"c\" }\n  });\n});","mimetype":"text/plain"},{"body":"<p>Imagine the current execution context as an ImmutableMap. Adding or replacing entries in the map copies the map.<br>So:</p>\n<pre><code class=\"language-js\">const ctx1 = new AsyncContext();\nconst ctx2 = new AsyncContext();\nconst ctx3 = new AsyncContext();\n\n// execution context: {}\nctx1.run(&quot;a&quot;, () =&gt; {\n  // execution context: { [ctx1]: &quot;a&quot; }\n  ctx2.run(&quot;b&quot;, () =&gt; {\n    // execution context: { [ctx1]: &quot;a&quot;, [ctx2]: &quot;b&quot; }\n  });\n  ctx3.run(&quot;c&quot;, () =&gt; {\n    // execution context: { [ctx1]: &quot;a&quot;, [ctx3]: &quot;c&quot; }\n  });\n});\n</code></pre>\n","mimetype":"text/html"}],"body":"Imagine the current execution context as an ImmutableMap. Adding or replacing entries in the map copies the map.\nSo:\n```js\nconst ctx1 = new AsyncContext();\nconst ctx2 = new AsyncContext();\nconst ctx3 = new AsyncContext();\n\n// execution context: {}\nctx1.run(\"a\", () => {\n  // execution context: { [ctx1]: \"a\" }\n  ctx2.run(\"b\", () => {\n    // execution context: { [ctx1]: \"a\", [ctx2]: \"b\" }\n  });\n  ctx3.run(\"c\", () => {\n    // execution context: { [ctx1]: \"a\", [ctx3]: \"c\" }\n  });\n});","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>Imagine the current execution context as an ImmutableMap. Adding or replacing entries in the map copies the map.<br>So:</p>\n<pre><code class=\"language-js\">const ctx1 = new AsyncContext();\nconst ctx2 = new AsyncContext();\nconst ctx3 = new AsyncContext();\n\n// execution context: {}\nctx1.run(&quot;a&quot;, () =&gt; {\n  // execution context: { [ctx1]: &quot;a&quot; }\n  ctx2.run(&quot;b&quot;, () =&gt; {\n    // execution context: { [ctx1]: &quot;a&quot;, [ctx2]: &quot;b&quot; }\n  });\n  ctx3.run(&quot;c&quot;, () =&gt; {\n    // execution context: { [ctx1]: &quot;a&quot;, [ctx3]: &quot;c&quot; }\n  });\n});\n</code></pre>\n"},"ts":1668812042831,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xh7YClYYmqsQa77H53Cq0TqPvse4YrA8881SaCXzaeY"},
{"content":{"org.matrix.msc1767.text":"Yes, well, if that is snapshotting, then I agree it's how we'd achieve the semantics","body":"Yes, well, if that is snapshotting, then I agree it's how we'd achieve the semantics","msgtype":"m.text"},"ts":1668812091889,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$77pR-E5XZUQkLUiElkGC_PMV5f1HMpjBrRLAGFzLiQY"},
{"content":{"org.matrix.msc1767.message":[{"body":"You don't mutate the execution context, you copy it when you call `contxt.run`, adding or replacing the value for `context` in the copy of the execution context seen by the callback.","mimetype":"text/plain"},{"body":"You don't mutate the execution context, you copy it when you call <code>contxt.run</code>, adding or replacing the value for <code>context</code> in the copy of the execution context seen by the callback.","mimetype":"text/html"}],"body":"You don't mutate the execution context, you copy it when you call `contxt.run`, adding or replacing the value for `context` in the copy of the execution context seen by the callback.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"You don't mutate the execution context, you copy it when you call <code>contxt.run</code>, adding or replacing the value for <code>context</code> in the copy of the execution context seen by the callback."},"ts":1668812097141,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3rW4uIg4Tzm54v9Tkej4gym8oJEZzI7gQLxqrnWvqr8"},
{"content":{"org.matrix.msc1767.message":[{"body":"```js\nlet __storage__ = new Map();\nclass AsyncContext {\n  // Pushes a new state, and pops it when done\n  run(val, cb) {\n    let prev = __storage__;\n    try {\n      this.set(val);\n      return cb();\n    } finally {\n      __storage__ = prev;\n    }\n  }\n\n  // Mutates the current state\n  set(val) {\n    const next = new Map(__storage__);\n    next.set(this, val);\n    __storage__ = next;\n  }\n}\n```","mimetype":"text/plain"},{"body":"<pre><code class=\"language-js\">let __storage__ = new Map();\nclass AsyncContext {\n  // Pushes a new state, and pops it when done\n  run(val, cb) {\n    let prev = __storage__;\n    try {\n      this.set(val);\n      return cb();\n    } finally {\n      __storage__ = prev;\n    }\n  }\n\n  // Mutates the current state\n  set(val) {\n    const next = new Map(__storage__);\n    next.set(this, val);\n    __storage__ = next;\n  }\n}\n</code></pre>\n","mimetype":"text/html"}],"body":"```js\nlet __storage__ = new Map();\nclass AsyncContext {\n  // Pushes a new state, and pops it when done\n  run(val, cb) {\n    let prev = __storage__;\n    try {\n      this.set(val);\n      return cb();\n    } finally {\n      __storage__ = prev;\n    }\n  }\n\n  // Mutates the current state\n  set(val) {\n    const next = new Map(__storage__);\n    next.set(this, val);\n    __storage__ = next;\n  }\n}\n```","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">let __storage__ = new Map();\nclass AsyncContext {\n  // Pushes a new state, and pops it when done\n  run(val, cb) {\n    let prev = __storage__;\n    try {\n      this.set(val);\n      return cb();\n    } finally {\n      __storage__ = prev;\n    }\n  }\n\n  // Mutates the current state\n  set(val) {\n    const next = new Map(__storage__);\n    next.set(this, val);\n    __storage__ = next;\n  }\n}\n</code></pre>\n"},"ts":1668812105086,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$kmC1TOrEo74LLJ4jIKLeVvl7HLWGC5vCOw0IkD4tGfE"},
{"content":{"org.matrix.msc1767.text":"I like to think of it as, a singly-linked list, which you don't need to copy, just push associations onto","body":"I like to think of it as, a singly-linked list, which you don't need to copy, just push associations onto","msgtype":"m.text"},"ts":1668812111716,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$8Qtjng7zm5JFBGaB43gZMEW7AWwjZnWJRUWrMebu6vc"},
{"content":{"org.matrix.msc1767.message":[{"body":"this differentiates `run` from an AsyncLocal that you can literally mutate (which woudln't have that property)","mimetype":"text/plain"},{"body":"this differentiates <code>run</code> from an AsyncLocal that you can literally mutate (which woudln't have that property)","mimetype":"text/html"}],"body":"this differentiates `run` from an AsyncLocal that you can literally mutate (which woudln't have that property)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"this differentiates <code>run</code> from an AsyncLocal that you can literally mutate (which woudln't have that property)"},"ts":1668812131207,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$zCDRUTUGl-oKWx1QobifR9yW_0JvyckKXP1rfyYzRm8"},
{"content":{"org.matrix.msc1767.message":[{"body":"Justin Ridgewell: Yes, while you can't mutate the execution context itself (since its immutable), you can mutate the values stored in it.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a>: Yes, while you can't mutate the execution context itself (since its immutable), you can mutate the values stored in it.","mimetype":"text/html"}],"body":"Justin Ridgewell: Yes, while you can't mutate the execution context itself (since its immutable), you can mutate the values stored in it.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jridgewell:matrix.org\">Justin Ridgewell</a>: Yes, while you can't mutate the execution context itself (since its immutable), you can mutate the values stored in it."},"ts":1668812152732,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VZjF7rYlQT6JwA02Fqjp6GkXGdZk6-Tnhkc5N6PBYe8"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> I like to think of it as, a singly-linked list, which you don't need to copy, just push associations onto\n\nand this singly linked list is immutable; the only thing that changes is the pointer to its root","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$8Qtjng7zm5JFBGaB43gZMEW7AWwjZnWJRUWrMebu6vc?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I like to think of it as, a singly-linked list, which you don&#39;t need to copy, just push associations onto</blockquote></mx-reply>and this singly linked list is immutable; the only thing that changes is the pointer to its root","mimetype":"text/html"}],"body":"> <@littledan:matrix.org> I like to think of it as, a singly-linked list, which you don't need to copy, just push associations onto\n\nand this singly linked list is immutable; the only thing that changes is the pointer to its root","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$8Qtjng7zm5JFBGaB43gZMEW7AWwjZnWJRUWrMebu6vc?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>I like to think of it as, a singly-linked list, which you don&#39;t need to copy, just push associations onto</blockquote></mx-reply>and this singly linked list is immutable; the only thing that changes is the pointer to its root","m.relates_to":{"m.in_reply_to":{"event_id":"$8Qtjng7zm5JFBGaB43gZMEW7AWwjZnWJRUWrMebu6vc"}}},"ts":1668812184310,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$3PigWVHoUBR33Tye8MIBWevONdSOuy-Z-r2h87OuRYE"},
{"content":{"org.matrix.msc1767.text":"so if that's our data model, the usage of AsyncContext is somehow \"structured\" (debatable how useful that is, I'm just describing how I'm conceptualizing this)","body":"so if that's our data model, the usage of AsyncContext is somehow \"structured\" (debatable how useful that is, I'm just describing how I'm conceptualizing this)","msgtype":"m.text"},"ts":1668812215811,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$4GoVX4tlchtwe6_wHDIgyzGfI4margKLxWTNgzDo6tc"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> and this singly linked list is immutable; the only thing that changes is the pointer to its root\n\nYes, and that's how an `ImmutableDictionary` would be implemented. Not precisely a \"copy\" but essentially a snapshot since it can't be changed.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$3PigWVHoUBR33Tye8MIBWevONdSOuy-Z-r2h87OuRYE?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>and this singly linked list is immutable; the only thing that changes is the pointer to its root</blockquote></mx-reply>Yes, and that's how an <code>ImmutableDictionary</code> would be implemented. Not precisely a &quot;copy&quot; but essentially a snapshot since it can't be changed.","mimetype":"text/html"}],"body":"> <@littledan:matrix.org> and this singly linked list is immutable; the only thing that changes is the pointer to its root\n\nYes, and that's how an `ImmutableDictionary` would be implemented. Not precisely a \"copy\" but essentially a snapshot since it can't be changed.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$3PigWVHoUBR33Tye8MIBWevONdSOuy-Z-r2h87OuRYE?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>and this singly linked list is immutable; the only thing that changes is the pointer to its root</blockquote></mx-reply>Yes, and that's how an <code>ImmutableDictionary</code> would be implemented. Not precisely a &quot;copy&quot; but essentially a snapshot since it can't be changed.","m.relates_to":{"m.in_reply_to":{"event_id":"$3PigWVHoUBR33Tye8MIBWevONdSOuy-Z-r2h87OuRYE"}}},"ts":1668812223166,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Rs75E6Ga6AHCuPd3ih7kgF3UjVouUaVgTQYNvwW9zLw"},
{"content":{"org.matrix.msc1767.message":[{"body":"right so since the snapshot operation is the identity function, we don't have to worry about \"when\" the snapshot occurs, just when/how the mutation occurs (with `run`)","mimetype":"text/plain"},{"body":"right so since the snapshot operation is the identity function, we don't have to worry about &quot;when&quot; the snapshot occurs, just when/how the mutation occurs (with <code>run</code>)","mimetype":"text/html"}],"body":"right so since the snapshot operation is the identity function, we don't have to worry about \"when\" the snapshot occurs, just when/how the mutation occurs (with `run`)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"right so since the snapshot operation is the identity function, we don't have to worry about &quot;when&quot; the snapshot occurs, just when/how the mutation occurs (with <code>run</code>)"},"ts":1668812279103,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$FAnP2xWosGgzaJ87eA5yPoUGI3ktnmExIukdn-3TUtk"},
{"content":{"org.matrix.msc1767.message":[{"body":"The difference between `AsyncContext` and something like `AsyncLocal`, is that `AsyncContext` is _explicit_ (you must call `.run()`, while `AsyncLocal` is implicit.","mimetype":"text/plain"},{"body":"The difference between <code>AsyncContext</code> and something like <code>AsyncLocal</code>, is that <code>AsyncContext</code> is <em>explicit</em> (you must call <code>.run()</code>, while <code>AsyncLocal</code> is implicit.","mimetype":"text/html"}],"body":"The difference between `AsyncContext` and something like `AsyncLocal`, is that `AsyncContext` is _explicit_ (you must call `.run()`, while `AsyncLocal` is implicit.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"The difference between <code>AsyncContext</code> and something like <code>AsyncLocal</code>, is that <code>AsyncContext</code> is <em>explicit</em> (you must call <code>.run()</code>, while <code>AsyncLocal</code> is implicit."},"ts":1668812289029,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$N-gtVqoxr4B2Tb-Uu1JMB_YoigmfNLYY4ZIdMvLjJgw"},
{"content":{"org.matrix.msc1767.text":"Makes sense","body":"Makes sense","msgtype":"m.text"},"ts":1668812313376,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$iXfLpBUaQ5ghksdyebJMK6dIb3oGZAP1l4pF-qQoLJw"},
{"content":{"org.matrix.msc1767.text":"I can see how the two things have this difference; I haven't yet understood the downside of explicitness","body":"I can see how the two things have this difference; I haven't yet understood the downside of explicitness","msgtype":"m.text"},"ts":1668812333768,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$1IbGHiRZi2WFfC5RtI8h22syop45hw8m9sp8AuVxxPc"},
{"content":{"org.matrix.msc1767.message":[{"body":"Explicitness is fine for imperative code, not so much for declarative code (such as using with decorators). Also the TCP issue (managing `yield`, `await`, and `this` when you shift to a callback).","mimetype":"text/plain"},{"body":"Explicitness is fine for imperative code, not so much for declarative code (such as using with decorators). Also the TCP issue (managing <code>yield</code>, <code>await</code>, and <code>this</code> when you shift to a callback).","mimetype":"text/html"}],"body":"Explicitness is fine for imperative code, not so much for declarative code (such as using with decorators). Also the TCP issue (managing `yield`, `await`, and `this` when you shift to a callback).","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Explicitness is fine for imperative code, not so much for declarative code (such as using with decorators). Also the TCP issue (managing <code>yield</code>, <code>await</code>, and <code>this</code> when you shift to a callback)."},"ts":1668812425746,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ogOreQVz0nWQN5bXHOh6X0gA-EaVfzvfL8dm-PII0qk"},
{"content":{"org.matrix.msc1767.message":[{"body":"Imagine there was an internal `ExecutionContext` object that had an immutable dictionary of `AsyncContext->value` entries. What an `AsyncLocal` would need is a second immutable dictionary on that object:\n\n```ts\n// internal implementation details...\nclass ExecutionContext {\n  #asyncContextValues;\n  #asyncLocalValues;\n  constructor(asyncContextValues, asyncLocalValues) {\n    this.#asyncContextValues = asyncContextValues;\n    this.#asyncLocalValues = asyncLocalValues;\n  }\n\n  static get current() {\n    return %GetCurrentExecutionContext();\n  }\n\n  static set current(value) {\n    %SetCurrentExecutionContext(value);\n  }\n\n  static create() {\n    return new ExecutionContext(new ImmutableMap(), new ImmutableMap());\n  }\n\n  copy() {\n    return new ExecutionContext(this.#asyncContextValues, this.#asyncLocalValues);\n  }\n\n  getContext(key) {\n    return this.#asyncContextValues.get(key);\n  }\n\n  getLocal(key) {\n    return this.#asyncLocalValues.get(key);\n  }\n\n  setLocal(key, value) {\n    this.#asyncLocalValues = this.#asyncLocalValues.set(key, value);\n  }\n\n  runWithContext(asyncContext, value, callback, args) {\n    const context = new ExecutionContext(this.#asyncContextValues.set(asyncContext, value), this.#asyncLocalValues);\n    return %RunWithContext(context, callback, args);\n  }\n}\n\n// global scope would have a root context\nExecutionContext.current = ExecutionContext.create();\n\n// public\nclass AsyncContext {\n  run(value, callback, ...args) {\n    return ExecutionContext.current.runWithContext(this, value, callback, args);\n  }\n\n  get() {\n    return ExecutionContext.current.getContext(this);\n  }\n\n  static wrap(cb) {\n    const captured = ExecutionContext.current;\n    return (...args) => {\n      const current = ExecutionContext.current;\n      try {\n        ExecutionContext.captured = captured;\n        return cb(...args);\n      }\n      finally {\n        ExecutionContext.current = current;\n      }\n    }\n  }\n}\n\n// public\nclass AsyncLocal {\n  get value() { return ExecutionContext.current.getLocal(this); }\n  set value(v) { ExecutionContext.current.setLocal(this, v); }\n}\n\n// and `await f()` is translated to something like:\n\nconst result = Promise.resolve(f());\nresult.[[ExecutionContext]] = ExecutionContext.current.copy(); // used for continuations\nawait result;\n\n```\n\nAn `await` would just preserve the pointer to the `AsyncContext` entries, but get an independent reference to the `AsyncLocal` entries. Mutating the `asyncLocalValues` reference wouldn't affect snapshots taken during `await`.","mimetype":"text/plain"},{"body":"<p>Imagine there was an internal <code>ExecutionContext</code> object that had an immutable dictionary of <code>AsyncContext-&gt;value</code> entries. What an <code>AsyncLocal</code> would need is a second immutable dictionary on that object:</p>\n<pre><code class=\"language-ts\">// internal implementation details...\nclass ExecutionContext {\n  #asyncContextValues;\n  #asyncLocalValues;\n  constructor(asyncContextValues, asyncLocalValues) {\n    this.#asyncContextValues = asyncContextValues;\n    this.#asyncLocalValues = asyncLocalValues;\n  }\n\n  static get current() {\n    return %GetCurrentExecutionContext();\n  }\n\n  static set current(value) {\n    %SetCurrentExecutionContext(value);\n  }\n\n  static create() {\n    return new ExecutionContext(new ImmutableMap(), new ImmutableMap());\n  }\n\n  copy() {\n    return new ExecutionContext(this.#asyncContextValues, this.#asyncLocalValues);\n  }\n\n  getContext(key) {\n    return this.#asyncContextValues.get(key);\n  }\n\n  getLocal(key) {\n    return this.#asyncLocalValues.get(key);\n  }\n\n  setLocal(key, value) {\n    this.#asyncLocalValues = this.#asyncLocalValues.set(key, value);\n  }\n\n  runWithContext(asyncContext, value, callback, args) {\n    const context = new ExecutionContext(this.#asyncContextValues.set(asyncContext, value), this.#asyncLocalValues);\n    return %RunWithContext(context, callback, args);\n  }\n}\n\n// global scope would have a root context\nExecutionContext.current = ExecutionContext.create();\n\n// public\nclass AsyncContext {\n  run(value, callback, ...args) {\n    return ExecutionContext.current.runWithContext(this, value, callback, args);\n  }\n\n  get() {\n    return ExecutionContext.current.getContext(this);\n  }\n\n  static wrap(cb) {\n    const captured = ExecutionContext.current;\n    return (...args) =&gt; {\n      const current = ExecutionContext.current;\n      try {\n        ExecutionContext.captured = captured;\n        return cb(...args);\n      }\n      finally {\n        ExecutionContext.current = current;\n      }\n    }\n  }\n}\n\n// public\nclass AsyncLocal {\n  get value() { return ExecutionContext.current.getLocal(this); }\n  set value(v) { ExecutionContext.current.setLocal(this, v); }\n}\n\n// and `await f()` is translated to something like:\n\nconst result = Promise.resolve(f());\nresult.[[ExecutionContext]] = ExecutionContext.current.copy(); // used for continuations\nawait result;\n\n</code></pre>\n<p>An <code>await</code> would just preserve the pointer to the <code>AsyncContext</code> entries, but get an independent reference to the <code>AsyncLocal</code> entries. Mutating the <code>asyncLocalValues</code> reference wouldn't affect snapshots taken during <code>await</code>.</p>\n","mimetype":"text/html"}],"body":"Imagine there was an internal `ExecutionContext` object that had an immutable dictionary of `AsyncContext->value` entries. What an `AsyncLocal` would need is a second immutable dictionary on that object:\n\n```ts\n// internal implementation details...\nclass ExecutionContext {\n  #asyncContextValues;\n  #asyncLocalValues;\n  constructor(asyncContextValues, asyncLocalValues) {\n    this.#asyncContextValues = asyncContextValues;\n    this.#asyncLocalValues = asyncLocalValues;\n  }\n\n  static get current() {\n    return %GetCurrentExecutionContext();\n  }\n\n  static set current(value) {\n    %SetCurrentExecutionContext(value);\n  }\n\n  static create() {\n    return new ExecutionContext(new ImmutableMap(), new ImmutableMap());\n  }\n\n  copy() {\n    return new ExecutionContext(this.#asyncContextValues, this.#asyncLocalValues);\n  }\n\n  getContext(key) {\n    return this.#asyncContextValues.get(key);\n  }\n\n  getLocal(key) {\n    return this.#asyncLocalValues.get(key);\n  }\n\n  setLocal(key, value) {\n    this.#asyncLocalValues = this.#asyncLocalValues.set(key, value);\n  }\n\n  runWithContext(asyncContext, value, callback, args) {\n    const context = new ExecutionContext(this.#asyncContextValues.set(asyncContext, value), this.#asyncLocalValues);\n    return %RunWithContext(context, callback, args);\n  }\n}\n\n// global scope would have a root context\nExecutionContext.current = ExecutionContext.create();\n\n// public\nclass AsyncContext {\n  run(value, callback, ...args) {\n    return ExecutionContext.current.runWithContext(this, value, callback, args);\n  }\n\n  get() {\n    return ExecutionContext.current.getContext(this);\n  }\n\n  static wrap(cb) {\n    const captured = ExecutionContext.current;\n    return (...args) => {\n      const current = ExecutionContext.current;\n      try {\n        ExecutionContext.captured = captured;\n        return cb(...args);\n      }\n      finally {\n        ExecutionContext.current = current;\n      }\n    }\n  }\n}\n\n// public\nclass AsyncLocal {\n  get value() { return ExecutionContext.current.getLocal(this); }\n  set value(v) { ExecutionContext.current.setLocal(this, v); }\n}\n\n// and `await f()` is translated to something like:\n\nconst result = Promise.resolve(f());\nresult.[[ExecutionContext]] = ExecutionContext.current.copy(); // used for continuations\nawait result;\n\n```\n\nAn `await` would just preserve the pointer to the `AsyncContext` entries, but get an independent reference to the `AsyncLocal` entries. Mutating the `asyncLocalValues` reference wouldn't affect snapshots taken during `await`.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<p>Imagine there was an internal <code>ExecutionContext</code> object that had an immutable dictionary of <code>AsyncContext-&gt;value</code> entries. What an <code>AsyncLocal</code> would need is a second immutable dictionary on that object:</p>\n<pre><code class=\"language-ts\">// internal implementation details...\nclass ExecutionContext {\n  #asyncContextValues;\n  #asyncLocalValues;\n  constructor(asyncContextValues, asyncLocalValues) {\n    this.#asyncContextValues = asyncContextValues;\n    this.#asyncLocalValues = asyncLocalValues;\n  }\n\n  static get current() {\n    return %GetCurrentExecutionContext();\n  }\n\n  static set current(value) {\n    %SetCurrentExecutionContext(value);\n  }\n\n  static create() {\n    return new ExecutionContext(new ImmutableMap(), new ImmutableMap());\n  }\n\n  copy() {\n    return new ExecutionContext(this.#asyncContextValues, this.#asyncLocalValues);\n  }\n\n  getContext(key) {\n    return this.#asyncContextValues.get(key);\n  }\n\n  getLocal(key) {\n    return this.#asyncLocalValues.get(key);\n  }\n\n  setLocal(key, value) {\n    this.#asyncLocalValues = this.#asyncLocalValues.set(key, value);\n  }\n\n  runWithContext(asyncContext, value, callback, args) {\n    const context = new ExecutionContext(this.#asyncContextValues.set(asyncContext, value), this.#asyncLocalValues);\n    return %RunWithContext(context, callback, args);\n  }\n}\n\n// global scope would have a root context\nExecutionContext.current = ExecutionContext.create();\n\n// public\nclass AsyncContext {\n  run(value, callback, ...args) {\n    return ExecutionContext.current.runWithContext(this, value, callback, args);\n  }\n\n  get() {\n    return ExecutionContext.current.getContext(this);\n  }\n\n  static wrap(cb) {\n    const captured = ExecutionContext.current;\n    return (...args) =&gt; {\n      const current = ExecutionContext.current;\n      try {\n        ExecutionContext.captured = captured;\n        return cb(...args);\n      }\n      finally {\n        ExecutionContext.current = current;\n      }\n    }\n  }\n}\n\n// public\nclass AsyncLocal {\n  get value() { return ExecutionContext.current.getLocal(this); }\n  set value(v) { ExecutionContext.current.setLocal(this, v); }\n}\n\n// and `await f()` is translated to something like:\n\nconst result = Promise.resolve(f());\nresult.[[ExecutionContext]] = ExecutionContext.current.copy(); // used for continuations\nawait result;\n\n</code></pre>\n<p>An <code>await</code> would just preserve the pointer to the <code>AsyncContext</code> entries, but get an independent reference to the <code>AsyncLocal</code> entries. Mutating the <code>asyncLocalValues</code> reference wouldn't affect snapshots taken during <code>await</code>.</p>\n"},"ts":1668813760787,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$R0mRS64YdeWBbpoH_982C69RDngRvoKcPcIfgFngwTM"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> Explicitness is fine for imperative code, not so much for declarative code (such as using with decorators). Also the TCP issue (managing `yield`, `await`, and `this` when you shift to a callback).\n\nAh, I see (abstractly, still trying to conceptualize how this relates to likely concrete code)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$ogOreQVz0nWQN5bXHOh6X0gA-EaVfzvfL8dm-PII0qk?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Explicitness is fine for imperative code, not so much for declarative code (such as using with decorators). Also the TCP issue (managing <code>yield</code>, <code>await</code>, and <code>this</code> when you shift to a callback).</blockquote></mx-reply>Ah, I see (abstractly, still trying to conceptualize how this relates to likely concrete code)","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> Explicitness is fine for imperative code, not so much for declarative code (such as using with decorators). Also the TCP issue (managing `yield`, `await`, and `this` when you shift to a callback).\n\nAh, I see (abstractly, still trying to conceptualize how this relates to likely concrete code)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$ogOreQVz0nWQN5bXHOh6X0gA-EaVfzvfL8dm-PII0qk?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Explicitness is fine for imperative code, not so much for declarative code (such as using with decorators). Also the TCP issue (managing <code>yield</code>, <code>await</code>, and <code>this</code> when you shift to a callback).</blockquote></mx-reply>Ah, I see (abstractly, still trying to conceptualize how this relates to likely concrete code)","m.relates_to":{"m.in_reply_to":{"event_id":"$ogOreQVz0nWQN5bXHOh6X0gA-EaVfzvfL8dm-PII0qk"}}},"ts":1668813806523,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$2teAzAdRnMcbKz7sU8yUB5nbpMg_s4c1U_De1yCCx4o"},
{"content":{"org.matrix.msc1767.text":"Most of the real world examples I can think of are related to things like HttpContext in ASP.NET, which I'm a few years out from using regularly.","body":"Most of the real world examples I can think of are related to things like HttpContext in ASP.NET, which I'm a few years out from using regularly.","msgtype":"m.text"},"ts":1668813846903,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$J205PJVG7GSqwE1aRMY3emKYtXI0ALWd8Z-nuR-tzvI"},
{"content":{"org.matrix.msc1767.message":[{"body":"my intuition is that it's generally a \"big deal\" when you use `run`. There are many wrapped callbacks/promise reactions for every big `run` setting up a context","mimetype":"text/plain"},{"body":"my intuition is that it's generally a &quot;big deal&quot; when you use <code>run</code>. There are many wrapped callbacks/promise reactions for every big <code>run</code> setting up a context","mimetype":"text/html"}],"body":"my intuition is that it's generally a \"big deal\" when you use `run`. There are many wrapped callbacks/promise reactions for every big `run` setting up a context","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"my intuition is that it's generally a &quot;big deal&quot; when you use <code>run</code>. There are many wrapped callbacks/promise reactions for every big <code>run</code> setting up a context"},"ts":1668813864393,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$8UM_wNkB7EPPQmBKiGvmbgaa8d9QiXz8Y93SfQDl-gs"},
{"content":{"org.matrix.msc1767.text":"I've used this feature in .NET a fair bit though.","body":"I've used this feature in .NET a fair bit though.","msgtype":"m.text"},"ts":1668813866029,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WyNDIPLFmsoNJ5Av3ruZYoUd0TxwHRCFVvCHluj6i70"},
{"content":{"org.matrix.msc1767.message":[{"body":"So really, neither `AsyncContext` nor `AsyncLocal` are the actual building block, but rather `ExecutionContext` is. However, I think `ExecutionContext` provides too much access to internals.","mimetype":"text/plain"},{"body":"So really, neither <code>AsyncContext</code> nor <code>AsyncLocal</code> are the actual building block, but rather <code>ExecutionContext</code> is. However, I think <code>ExecutionContext</code> provides too much access to internals.","mimetype":"text/html"}],"body":"So really, neither `AsyncContext` nor `AsyncLocal` are the actual building block, but rather `ExecutionContext` is. However, I think `ExecutionContext` provides too much access to internals.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"So really, neither <code>AsyncContext</code> nor <code>AsyncLocal</code> are the actual building block, but rather <code>ExecutionContext</code> is. However, I think <code>ExecutionContext</code> provides too much access to internals."},"ts":1668813957540,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CNKZSCyPLXW74V-tCX9LJz77lEIfkrmzzDeA3vceKiI"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> my intuition is that it's generally a \"big deal\" when you use `run`. There are many wrapped callbacks/promise reactions for every big `run` setting up a context\n\nYes, and that's generally true for an `ExecutionContext` which is a bit more coarse grained. You will see `asyncContext.run` more often since its so granular (i.e., a single value). `AsyncLocal` is designed to be more lightweight.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$8UM_wNkB7EPPQmBKiGvmbgaa8d9QiXz8Y93SfQDl-gs?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>my intuition is that it's generally a \"big deal\" when you use <code>run</code>. There are many wrapped callbacks/promise reactions for every big <code>run</code> setting up a context</blockquote></mx-reply>Yes, and that's generally true for an <code>ExecutionContext</code> which is a bit more coarse grained. You will see <code>asyncContext.run</code> more often since its so granular (i.e., a single value). <code>AsyncLocal</code> is designed to be more lightweight.","mimetype":"text/html"}],"body":"> <@littledan:matrix.org> my intuition is that it's generally a \"big deal\" when you use `run`. There are many wrapped callbacks/promise reactions for every big `run` setting up a context\n\nYes, and that's generally true for an `ExecutionContext` which is a bit more coarse grained. You will see `asyncContext.run` more often since its so granular (i.e., a single value). `AsyncLocal` is designed to be more lightweight.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$8UM_wNkB7EPPQmBKiGvmbgaa8d9QiXz8Y93SfQDl-gs?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>my intuition is that it's generally a \"big deal\" when you use <code>run</code>. There are many wrapped callbacks/promise reactions for every big <code>run</code> setting up a context</blockquote></mx-reply>Yes, and that's generally true for an <code>ExecutionContext</code> which is a bit more coarse grained. You will see <code>asyncContext.run</code> more often since its so granular (i.e., a single value). <code>AsyncLocal</code> is designed to be more lightweight.","m.relates_to":{"m.in_reply_to":{"event_id":"$8UM_wNkB7EPPQmBKiGvmbgaa8d9QiXz8Y93SfQDl-gs"}}},"ts":1668814039493,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zpj4OK9QLKzmFqsM8OcCMF6EAiW2c3g2fv7YfoEsHjE"},
{"content":{"org.matrix.msc1767.text":"so, we're talking about https://learn.microsoft.com/en-us/dotnet/api/system.web.httpcontext?view=netframework-4.8 ?","body":"so, we're talking about https://learn.microsoft.com/en-us/dotnet/api/system.web.httpcontext?view=netframework-4.8 ?","msgtype":"m.text"},"ts":1668814065998,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9hr0IIk9mb4UP18xahB7Fh71R86NGDbHUEIcXDjb76w"},
{"content":{"org.matrix.msc1767.text":"When I'm talking about HttpContext, yes.","body":"When I'm talking about HttpContext, yes.","msgtype":"m.text"},"ts":1668814082240,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MLiCL1lda0sgTbYpv__PUiEjgu0v8SNb0kDM56WaVWw"},
{"content":{"org.matrix.msc1767.text":"that looks like an example of something coarse-grained, which library user code doesn't manually set","body":"that looks like an example of something coarse-grained, which library user code doesn't manually set","msgtype":"m.text"},"ts":1668814084343,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$BTB_uYf9WTdmzpgyYevYmbV1ElQfSseGkb94gtKkqKw"},
{"content":{"org.matrix.msc1767.text":"HttpContext.Items uses LogicalCallContext.GetValue under the hood.","body":"HttpContext.Items uses LogicalCallContext.GetValue under the hood.","msgtype":"m.text"},"ts":1668814095222,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-8i-9k3UXnYYbsmIP7OKzINIf80NfTX3ElMS_SWgIdA"},
{"content":{"org.matrix.msc1767.text":"And multiple HttpRequests are handled by calls to ExecutionContext.Run, which provides isolated execution contexts containing sensitive things like the current security principal, in addition to HttpRequests and responses.","body":"And multiple HttpRequests are handled by calls to ExecutionContext.Run, which provides isolated execution contexts containing sensitive things like the current security principal, in addition to HttpRequests and responses.","msgtype":"m.text"},"ts":1668814137428,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UIfyEE3fnNwQZEBzLzJuHnnPskr8BChASjdRX9zTsiE"},
{"content":{"org.matrix.msc1767.text":"this is also how a lightweight version of MEF (Managed Extensibility Framework) interacted with HttpContext to provide dependency injection for web applications. When a new HttpRequest is created, a new DI composition scope would be created and associated with the request context, allowing you to pull in request-specific services.","body":"this is also how a lightweight version of MEF (Managed Extensibility Framework) interacted with HttpContext to provide dependency injection for web applications. When a new HttpRequest is created, a new DI composition scope would be created and associated with the request context, allowing you to pull in request-specific services.","msgtype":"m.text"},"ts":1668814254513,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HZ98QKCrGe9cFR6Bclg13O-jRj9UzdNC9X7TqjG73kI"},
{"content":{"org.matrix.msc1767.text":"Again, I'm a few years out from using that actively so some things may have changed.","body":"Again, I'm a few years out from using that actively so some things may have changed.","msgtype":"m.text"},"ts":1668814312517,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$r8MEQJvvs_MVAqCkaL0DEr670K-KR0jHrS0oY2ViuPM"},
{"content":{"org.matrix.msc1767.text":"well, it's interesting to hear about this; it's not so relevant if this is current","body":"well, it's interesting to hear about this; it's not so relevant if this is current","msgtype":"m.text"},"ts":1668814360579,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$tZBufuR3p0k2WaqgdB9GW3irOnbD-Z0rDC0cZtpMzaQ"},
{"content":{"org.matrix.msc1767.text":"The underlying logic is still actively in use, even if some parts have changed.","body":"The underlying logic is still actively in use, even if some parts have changed.","msgtype":"m.text"},"ts":1668814387543,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fXqJi5-ugzn9YoGzvB6OC-0A4mSvnL31Jo_96beX-kE"},
{"content":{"org.matrix.msc1767.text":"Does the security aspect mean that it should be top-level, or just that the framework needs to be careful about what information it nests where?","body":"Does the security aspect mean that it should be top-level, or just that the framework needs to be careful about what information it nests where?","msgtype":"m.text"},"ts":1668814388353,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$w6LnZcX_Y9FYeEHQ95rIktQzhSVFXsdNr3dX6zpQcsU"},
{"content":{"org.matrix.msc1767.text":"Are there any use cases here for mutating the value of an AsyncLocal, or is this all through Run?","body":"Are there any use cases here for mutating the value of an AsyncLocal, or is this all through Run?","msgtype":"m.text"},"ts":1668814419671,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$tYHisJsWobXpW4mA1UcsSd7Rnd46ONcJQq_l6ltBb0Q"},
{"content":{"org.matrix.msc1767.message":[{"body":"It needs to be careful about information nesting. The LogicalCallContext exists to do this work for you, though awaitable things in .NET let you configure how to capture and restore execution contexts via `.ConfigureAwait()`.","mimetype":"text/plain"},{"body":"It needs to be careful about information nesting. The LogicalCallContext exists to do this work for you, though awaitable things in .NET let you configure how to capture and restore execution contexts via <code>.ConfigureAwait()</code>.","mimetype":"text/html"}],"body":"It needs to be careful about information nesting. The LogicalCallContext exists to do this work for you, though awaitable things in .NET let you configure how to capture and restore execution contexts via `.ConfigureAwait()`.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"It needs to be careful about information nesting. The LogicalCallContext exists to do this work for you, though awaitable things in .NET let you configure how to capture and restore execution contexts via <code>.ConfigureAwait()</code>."},"ts":1668814469707,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$W4k8yoOFeDwhyHA5MvE9NKnKYjDTTS9XgNreWqmyKqM"},
{"content":{"org.matrix.msc1767.text":"https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.configureawait?view=netframework-4.8#system-threading-tasks-task-configureawait(system-boolean)","body":"https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.configureawait?view=netframework-4.8#system-threading-tasks-task-configureawait(system-boolean)","msgtype":"m.text"},"ts":1668814485285,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4cYJZ8VmH1zMiHNft8RWbRAJ4Dn0N3zI_Z1X7nd64Nc"},
{"content":{"org.matrix.msc1767.text":"Do you think we need .ConfigureAwait?","body":"Do you think we need .ConfigureAwait?","msgtype":"m.text"},"ts":1668814504199,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$w5qP4SiqxPpIPa59Hq2prZX9Ph48OaYyThs0BNAUQU8"},
{"content":{"org.matrix.msc1767.text":"Hopefully not.","body":"Hopefully not.","msgtype":"m.text"},"ts":1668814509988,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$EZuOboFkkRVeXYLU7xFPPVO_caz-yf4SVdkRTyRzafg"},
{"content":{"org.matrix.msc1767.message":[{"body":"Mostly .ConfigureAwait is used to determine whether to resume on the context captured at `await` or to continue with the context that's part of the continuation.","mimetype":"text/plain"},{"body":"Mostly .ConfigureAwait is used to determine whether to resume on the context captured at <code>await</code> or to continue with the context that's part of the continuation.","mimetype":"text/html"}],"body":"Mostly .ConfigureAwait is used to determine whether to resume on the context captured at `await` or to continue with the context that's part of the continuation.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Mostly .ConfigureAwait is used to determine whether to resume on the context captured at <code>await</code> or to continue with the context that's part of the continuation."},"ts":1668814552647,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$drjOvcVHsdyrFfT5UQ-tdfnJhLo4M8jy38BmcQOOkfg"},
{"content":{"org.matrix.msc1767.text":"One moment and I'll put together an example.","body":"One moment and I'll put together an example.","msgtype":"m.text"},"ts":1668814570662,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_ofwLuRv2keVdrJpmLcLg-gNwCPLmzPgQzO0ZtgQIY8"},
{"content":{"org.matrix.msc1767.message":[{"body":"Actually, it shouldn't matter. `.ContinueAwait(false)` is used to resume on the same _SynchronizationContext_, which affects which thread pool is used. A UI thread in a Windows app uses a Windows message queue based thread pool, while background threads might handle the work that is being awaited. Since you have to be on the UI thread to do UI updates, you need to go back to the original synchronization context to be on the correct thread pool/thread.","mimetype":"text/plain"},{"body":"Actually, it shouldn't matter. <code>.ContinueAwait(false)</code> is used to resume on the same <em>SynchronizationContext</em>, which affects which thread pool is used. A UI thread in a Windows app uses a Windows message queue based thread pool, while background threads might handle the work that is being awaited. Since you have to be on the UI thread to do UI updates, you need to go back to the original synchronization context to be on the correct thread pool/thread.","mimetype":"text/html"}],"body":"Actually, it shouldn't matter. `.ContinueAwait(false)` is used to resume on the same _SynchronizationContext_, which affects which thread pool is used. A UI thread in a Windows app uses a Windows message queue based thread pool, while background threads might handle the work that is being awaited. Since you have to be on the UI thread to do UI updates, you need to go back to the original synchronization context to be on the correct thread pool/thread.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Actually, it shouldn't matter. <code>.ContinueAwait(false)</code> is used to resume on the same <em>SynchronizationContext</em>, which affects which thread pool is used. A UI thread in a Windows app uses a Windows message queue based thread pool, while background threads might handle the work that is being awaited. Since you have to be on the UI thread to do UI updates, you need to go back to the original synchronization context to be on the correct thread pool/thread."},"ts":1668815154001,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$smVXVRjPnLoAkA9HNWssGLtFbe7LKrczFK0PRll157A"},
{"content":{"org.matrix.msc1767.message":[{"body":"However, context switching is still useful. Without async context flow suppression, you can still do `asyncContext.run(undefined, cb)`, but that's on an individual `AsyncContext` bases. Something like .NET's `ExecutionContext.SuppressFlow()` would suppress copying the current context for *every* `AsyncContext`. Again, that's achieveable with `wrap` but not very ergonomic.","mimetype":"text/plain"},{"body":"However, context switching is still useful. Without async context flow suppression, you can still do <code>asyncContext.run(undefined, cb)</code>, but that's on an individual <code>AsyncContext</code> bases. Something like .NET's <code>ExecutionContext.SuppressFlow()</code> would suppress copying the current context for <em>every</em> <code>AsyncContext</code>. Again, that's achieveable with <code>wrap</code> but not very ergonomic.","mimetype":"text/html"}],"body":"However, context switching is still useful. Without async context flow suppression, you can still do `asyncContext.run(undefined, cb)`, but that's on an individual `AsyncContext` bases. Something like .NET's `ExecutionContext.SuppressFlow()` would suppress copying the current context for *every* `AsyncContext`. Again, that's achieveable with `wrap` but not very ergonomic.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"However, context switching is still useful. Without async context flow suppression, you can still do <code>asyncContext.run(undefined, cb)</code>, but that's on an individual <code>AsyncContext</code> bases. Something like .NET's <code>ExecutionContext.SuppressFlow()</code> would suppress copying the current context for <em>every</em> <code>AsyncContext</code>. Again, that's achieveable with <code>wrap</code> but not very ergonomic."},"ts":1668815492444,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YiCE0WmFC3XJp3f16CWI0Zgf5ax6imkVDo6rWHUGA2U"},
{"content":{"org.matrix.msc1767.text":"sorry what is the purpose of context flow suppression?","body":"sorry what is the purpose of context flow suppression?","msgtype":"m.text"},"ts":1668815530421,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$jPVXrsh8gvvA20E-pBP3FmjXTUjO5yB5t4_QWbSLh1g"},
{"content":{"org.matrix.msc1767.text":"My earlier example was an HTTP Server. you may have context information for the server itself (such as the server's security principal) that you don't want to propagate to each request handler. In that case you would suppress execution context flow so that the current context isn't copied when you spin up a request handler (which will need to set its own context).","body":"My earlier example was an HTTP Server. you may have context information for the server itself (such as the server's security principal) that you don't want to propagate to each request handler. In that case you would suppress execution context flow so that the current context isn't copied when you spin up a request handler (which will need to set its own context).","msgtype":"m.text"},"ts":1668815658157,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aZnqkNVko6WPKpWmG5X6uGDOd-drTi3xk2FuXCCCZh0"},
{"content":{"msgtype":"m.text","body":"I’m also not understanding that usecase"},"ts":1668815687980,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$oL_1Sithjj8apOxZ28pM_DLJIGZEd41HGRyrbL2SAWo"},
{"content":{"org.matrix.msc1767.text":"Its also useful if you are using an async context that is reachable both from your code and potentially untrusted/sandboxed code. You may want to suppress async flow when invoking the untrusted code so as not to leak information.","body":"Its also useful if you are using an async context that is reachable both from your code and potentially untrusted/sandboxed code. You may want to suppress async flow when invoking the untrusted code so as not to leak information.","msgtype":"m.text"},"ts":1668815708646,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$osG7uot0s0kllz_bj0RubYour9EcRx898NcpK8hGhmA"},
{"content":{"msgtype":"m.text","body":"Is this because execution context allows you to change all contexts?"},"ts":1668815712286,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$7rtCHRSfUnb3W6NNeNyROKniD3n9Yy_rucbReN4KjoI"},
{"content":{"org.matrix.msc1767.text":"The untrusted code use case is very important when building an plugin/extensibility ecosystem, such as the one used in VS Code.","body":"The untrusted code use case is very important when building an plugin/extensibility ecosystem, such as the one used in VS Code.","msgtype":"m.text"},"ts":1668815762756,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mAnmFjyJ3shWTmvn8Jj3cQz9OaTGI___3sfSkStTpXY"},
{"content":{"org.matrix.msc1767.message":[{"body":"Its because there's no easy way to reset all the context information for the purpose of an invocation into untrusted code, aside from a top-level `AsyncContext.wrap((cb, ...args) => cb(...args))`.","mimetype":"text/plain"},{"body":"Its because there's no easy way to reset all the context information for the purpose of an invocation into untrusted code, aside from a top-level <code>AsyncContext.wrap((cb, ...args) =&gt; cb(...args))</code>.","mimetype":"text/html"}],"body":"Its because there's no easy way to reset all the context information for the purpose of an invocation into untrusted code, aside from a top-level `AsyncContext.wrap((cb, ...args) => cb(...args))`.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Its because there's no easy way to reset all the context information for the purpose of an invocation into untrusted code, aside from a top-level <code>AsyncContext.wrap((cb, ...args) =&gt; cb(...args))</code>."},"ts":1668815817279,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nDOGMWgvkyz2g-EiZr8x8jJ_T8M0XryQdMfSvchzK64"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> My earlier example was an HTTP Server. you may have context information for the server itself (such as the server's security principal) that you don't want to propagate to each request handler. In that case you would suppress execution context flow so that the current context isn't copied when you spin up a request handler (which will need to set its own context).\n\nOK, so in this case, the sensitive information is in an outer context, and then inner nested contexts need to not be able to see it?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$aZnqkNVko6WPKpWmG5X6uGDOd-drTi3xk2FuXCCCZh0?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>My earlier example was an HTTP Server. you may have context information for the server itself (such as the server&#39;s security principal) that you don&#39;t want to propagate to each request handler. In that case you would suppress execution context flow so that the current context isn&#39;t copied when you spin up a request handler (which will need to set its own context).</blockquote></mx-reply>OK, so in this case, the sensitive information is in an outer context, and then inner nested contexts need to not be able to see it?","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> My earlier example was an HTTP Server. you may have context information for the server itself (such as the server's security principal) that you don't want to propagate to each request handler. In that case you would suppress execution context flow so that the current context isn't copied when you spin up a request handler (which will need to set its own context).\n\nOK, so in this case, the sensitive information is in an outer context, and then inner nested contexts need to not be able to see it?","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$aZnqkNVko6WPKpWmG5X6uGDOd-drTi3xk2FuXCCCZh0?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>My earlier example was an HTTP Server. you may have context information for the server itself (such as the server&#39;s security principal) that you don&#39;t want to propagate to each request handler. In that case you would suppress execution context flow so that the current context isn&#39;t copied when you spin up a request handler (which will need to set its own context).</blockquote></mx-reply>OK, so in this case, the sensitive information is in an outer context, and then inner nested contexts need to not be able to see it?","m.relates_to":{"m.in_reply_to":{"event_id":"$aZnqkNVko6WPKpWmG5X6uGDOd-drTi3xk2FuXCCCZh0"}}},"ts":1668815858531,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Bq3WhK5u8_q9572UF0BI8otrb8HZL2tCkWzEviThYf8"},
{"content":{"org.matrix.msc1767.text":"Plus I may just want a way to kick off an async operation in a base state without whatever extra context baggage the current function is holding on to.","body":"Plus I may just want a way to kick off an async operation in a base state without whatever extra context baggage the current function is holding on to.","msgtype":"m.text"},"ts":1668815889084,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fAur9YNlJgR7bFcNZ1abbJIvm6Fa8GuLzk_0OFL2Gl8"},
{"content":{"org.matrix.msc1767.text":"Yes.","body":"Yes.","msgtype":"m.text"},"ts":1668815896489,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nja3pdYfu7ANIltpS7TULHrqSxS-FRXLInzdnoexdAY"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@rbuckton:matrix.org> Its because there's no easy way to reset all the context information for the purpose of an invocation into untrusted code, aside from a top-level `AsyncContext.wrap((cb, ...args) => cb(...args))`.\n\nI guess, for both of these examples, a \"true\" top-level usage is not needed--we just need to capture this before the sensitive information is added by the server/vscode, right?","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$nDOGMWgvkyz2g-EiZr8x8jJ_T8M0XryQdMfSvchzK64?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Its because there's no easy way to reset all the context information for the purpose of an invocation into untrusted code, aside from a top-level <code>AsyncContext.wrap((cb, ...args) =&gt; cb(...args))</code>.</blockquote></mx-reply>I guess, for both of these examples, a &quot;true&quot; top-level usage is not needed--we just need to capture this before the sensitive information is added by the server/vscode, right?","mimetype":"text/html"}],"body":"> <@rbuckton:matrix.org> Its because there's no easy way to reset all the context information for the purpose of an invocation into untrusted code, aside from a top-level `AsyncContext.wrap((cb, ...args) => cb(...args))`.\n\nI guess, for both of these examples, a \"true\" top-level usage is not needed--we just need to capture this before the sensitive information is added by the server/vscode, right?","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$nDOGMWgvkyz2g-EiZr8x8jJ_T8M0XryQdMfSvchzK64?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Its because there's no easy way to reset all the context information for the purpose of an invocation into untrusted code, aside from a top-level <code>AsyncContext.wrap((cb, ...args) =&gt; cb(...args))</code>.</blockquote></mx-reply>I guess, for both of these examples, a &quot;true&quot; top-level usage is not needed--we just need to capture this before the sensitive information is added by the server/vscode, right?","m.relates_to":{"m.in_reply_to":{"event_id":"$nDOGMWgvkyz2g-EiZr8x8jJ_T8M0XryQdMfSvchzK64"}}},"ts":1668815903401,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$VqUVnOtDlAS3kEqAqXdpG0N7QXEJLFJg0-6_Dq8cdGs"},
{"content":{"org.matrix.msc1767.message":[{"body":"Again, you can do that on a case by case basis with `asyncContext.run(undefined, cb)`, but not for *all* async contexts","mimetype":"text/plain"},{"body":"Again, you can do that on a case by case basis with <code>asyncContext.run(undefined, cb)</code>, but not for <em>all</em> async contexts","mimetype":"text/html"}],"body":"Again, you can do that on a case by case basis with `asyncContext.run(undefined, cb)`, but not for *all* async contexts","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"Again, you can do that on a case by case basis with <code>asyncContext.run(undefined, cb)</code>, but not for <em>all</em> async contexts"},"ts":1668815920312,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YQGJSbZ0ZBPDGSZ7Np-7ZZ6QuayB5xMHi_TY_NRKmSA"},
{"content":{"org.matrix.msc1767.text":"Yes, but making this specifically a case-by-case basis is very fiddly. that can be fine for an and user application, but it makes it hard for intermediate libraries to work around.","body":"Yes, but making this specifically a case-by-case basis is very fiddly. that can be fine for an and user application, but it makes it hard for intermediate libraries to work around.","msgtype":"m.text"},"ts":1668815986805,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OFIIh8Qo5ZNy6HniERAmvOWrweQyFlUlcyDDdISQu8U"},
{"content":{"org.matrix.msc1767.text":"So, this is important if you have a profusion of sensitive things, where the inner modules can find the AsyncContext objects, but otoh it would be impractical to construct a list of all of them to censor them?","body":"So, this is important if you have a profusion of sensitive things, where the inner modules can find the AsyncContext objects, but otoh it would be impractical to construct a list of all of them to censor them?","msgtype":"m.text"},"ts":1668815987882,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$S5qRpmbrcVWw8CAshUxXagJZbbg062Dsz69tzptJXLU"}
]