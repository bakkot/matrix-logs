[
{"content":{"org.matrix.msc1767.text":"There's some related discussion on Mastodon! https://hachyderm.io/@develwithoutacause@techhub.social/109488473692344107","body":"There's some related discussion on Mastodon! https://hachyderm.io/@develwithoutacause@techhub.social/109488473692344107","msgtype":"m.text"},"ts":1670946424607,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$eGmr09EtftL5ManN12NtvzhfQBxYbCYKoD00wVXiItc"},
{"content":{"org.matrix.msc1767.text":"Doug, who started the thread and works on Angular, might be thinking about their use of zone.js","body":"Doug, who started the thread and works on Angular, might be thinking about their use of zone.js","msgtype":"m.text"},"ts":1670946462255,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uh_qKuK7_2sHcx4i1UBIOMDIzAi5rs7UkbS7JSdVDEQ"},
{"content":{"org.matrix.msc1767.text":"Does anyone want to get in touch with Doug and Minko for a review of AsyncContext from Angular's perspective?","body":"Does anyone want to get in touch with Doug and Minko for a review of AsyncContext from Angular's perspective?","msgtype":"m.text"},"ts":1670946480431,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$FR_h222ZoypG6qcaXbz3mJmuIVcQWFg1m-9JFIqsp14"},
{"content":{"org.matrix.msc1767.text":"Misko Hevery (of Angular fame) did a quick review of the AsyncContext API. He told me it seemed good to focus on just one aspect, but that Angular would still miss the ability to run a callback \"when the microtask queue becomes empty\" (a concept which isn't very composition-friendly, but which Angular needs to decide when to render to the DOM)","body":"Misko Hevery (of Angular fame) did a quick review of the AsyncContext API. He told me it seemed good to focus on just one aspect, but that Angular would still miss the ability to run a callback \"when the microtask queue becomes empty\" (a concept which isn't very composition-friendly, but which Angular needs to decide when to render to the DOM)","msgtype":"m.text"},"ts":1670946567771,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$WPRD_0avxvs53q8ifwmdLfrpBdTW46ckTGjgLxTFaJo"},
{"content":{"msgtype":"m.text","body":"That sounds like they need a scheduling API"},"ts":1670947686913,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$gUAFSZCGDBpXMjjGxYeOyFXeWFAVRuva2o7bf9R5Wbk"},
{"content":{"org.matrix.msc1767.text":"I think they need an API analogous to requestAnimationFrame but that runs a little earlier","body":"I think they need an API analogous to requestAnimationFrame but that runs a little earlier","msgtype":"m.text"},"ts":1670947816785,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$7NN4P8OqVcOWhH8gWlN4miF30c7Jw0GYFDg1CJu5usk"},
{"content":{"org.matrix.msc1767.text":"anyway they currently implement this by patching promises and also transpiling async/await such that it uses those promises. This lets them implement both AsyncContext and a mechanism to count how many outstanding microtask queue items there are","body":"anyway they currently implement this by patching promises and also transpiling async/await such that it uses those promises. This lets them implement both AsyncContext and a mechanism to count how many outstanding microtask queue items there are","msgtype":"m.text"},"ts":1670947867821,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$UOwu-6CGsNsM7Y0yS9a0w_PNwU-7dEPIrjxxsj8cV48"},
{"content":{"org.matrix.msc1767.text":"so AsyncContext alone will not solve the whole problem that they are patching promises for. Anyway, I agree with Misko that we shouldn't attempt to solve their whole problem","body":"so AsyncContext alone will not solve the whole problem that they are patching promises for. Anyway, I agree with Misko that we shouldn't attempt to solve their whole problem","msgtype":"m.text"},"ts":1670947903332,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$oZEjOQjYdLq9k9jSSPh8byuuKOIfKioKa9qAwwrQFd8"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@littledan:matrix.org> Misko Hevery (of Angular fame) did a quick review of the AsyncContext API. He told me it seemed good to focus on just one aspect, but that Angular would still miss the ability to run a callback \"when the microtask queue becomes empty\" (a concept which isn't very composition-friendly, but which Angular needs to decide when to render to the DOM)\n\nAt Agoric, we have historically drained the microtask queue in two different ways. You can approximate it with setImmediate, since it enqueues an event on the I/O queue. But, now we use a privileged API provided by XS that lets us dispatch an event and wait for the event loop to quiesce.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$WPRD_0avxvs53q8ifwmdLfrpBdTW46ckTGjgLxTFaJo?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Misko Hevery (of Angular fame) did a quick review of the AsyncContext API. He told me it seemed good to focus on just one aspect, but that Angular would still miss the ability to run a callback &quot;when the microtask queue becomes empty&quot; (a concept which isn&#39;t very composition-friendly, but which Angular needs to decide when to render to the DOM)</blockquote></mx-reply>At Agoric, we have historically drained the microtask queue in two different ways. You can approximate it with setImmediate, since it enqueues an event on the I/O queue. But, now we use a privileged API provided by XS that lets us dispatch an event and wait for the event loop to quiesce.","mimetype":"text/html"}],"body":"> <@littledan:matrix.org> Misko Hevery (of Angular fame) did a quick review of the AsyncContext API. He told me it seemed good to focus on just one aspect, but that Angular would still miss the ability to run a callback \"when the microtask queue becomes empty\" (a concept which isn't very composition-friendly, but which Angular needs to decide when to render to the DOM)\n\nAt Agoric, we have historically drained the microtask queue in two different ways. You can approximate it with setImmediate, since it enqueues an event on the I/O queue. But, now we use a privileged API provided by XS that lets us dispatch an event and wait for the event loop to quiesce.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$WPRD_0avxvs53q8ifwmdLfrpBdTW46ckTGjgLxTFaJo?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Misko Hevery (of Angular fame) did a quick review of the AsyncContext API. He told me it seemed good to focus on just one aspect, but that Angular would still miss the ability to run a callback &quot;when the microtask queue becomes empty&quot; (a concept which isn&#39;t very composition-friendly, but which Angular needs to decide when to render to the DOM)</blockquote></mx-reply>At Agoric, we have historically drained the microtask queue in two different ways. You can approximate it with setImmediate, since it enqueues an event on the I/O queue. But, now we use a privileged API provided by XS that lets us dispatch an event and wait for the event loop to quiesce.","m.relates_to":{"m.in_reply_to":{"event_id":"$WPRD_0avxvs53q8ifwmdLfrpBdTW46ckTGjgLxTFaJo"}}},"ts":1670952217487,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$nzR7UPVD30lLymvJ6DqiGrseRYvopnFuqyuQk-vPeYo"},
{"content":{"org.matrix.msc1767.message":[{"body":"The latter we invoke from outside the execution context. Doing the same from inside an execution context is a bit of an ouroboros, or as littledan put it, doesn’t compose well.","mimetype":"text/plain"},{"body":"The latter we invoke from outside the execution context. Doing the same from inside an execution context is a bit of an ouroboros, or as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> put it, doesn’t compose well.","mimetype":"text/html"}],"body":"The latter we invoke from outside the execution context. Doing the same from inside an execution context is a bit of an ouroboros, or as littledan put it, doesn’t compose well.","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"The latter we invoke from outside the execution context. Doing the same from inside an execution context is a bit of an ouroboros, or as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> put it, doesn’t compose well."},"ts":1670952319360,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$S_PGmofpljoDmZPMR8dYY0VM1DILx7OIlIeusPfgh4I"},
{"content":{"org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> At Agoric, we have historically drained the microtask queue in two different ways. You can approximate it with setImmediate, since it enqueues an event on the I/O queue. But, now we use a privileged API provided by XS that lets us dispatch an event and wait for the event loop to quiesce.\n\nYeah, this sort of solution sounds great to me; I hope Angular can find a similar solution for itself. (Or it might go \"zoneless\" but they have been talking about that since 2017...)","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$nzR7UPVD30lLymvJ6DqiGrseRYvopnFuqyuQk-vPeYo?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>At Agoric, we have historically drained the microtask queue in two different ways. You can approximate it with setImmediate, since it enqueues an event on the I/O queue. But, now we use a privileged API provided by XS that lets us dispatch an event and wait for the event loop to quiesce.</blockquote></mx-reply>Yeah, this sort of solution sounds great to me; I hope Angular can find a similar solution for itself. (Or it might go &quot;zoneless&quot; but they have been talking about that since 2017...)","mimetype":"text/html"}],"body":"> <@kriskowal:matrix.org> At Agoric, we have historically drained the microtask queue in two different ways. You can approximate it with setImmediate, since it enqueues an event on the I/O queue. But, now we use a privileged API provided by XS that lets us dispatch an event and wait for the event loop to quiesce.\n\nYeah, this sort of solution sounds great to me; I hope Angular can find a similar solution for itself. (Or it might go \"zoneless\" but they have been talking about that since 2017...)","msgtype":"m.text","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!siOjSOrhCVYVzIoThy:matrix.org/$nzR7UPVD30lLymvJ6DqiGrseRYvopnFuqyuQk-vPeYo?via=matrix.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>At Agoric, we have historically drained the microtask queue in two different ways. You can approximate it with setImmediate, since it enqueues an event on the I/O queue. But, now we use a privileged API provided by XS that lets us dispatch an event and wait for the event loop to quiesce.</blockquote></mx-reply>Yeah, this sort of solution sounds great to me; I hope Angular can find a similar solution for itself. (Or it might go &quot;zoneless&quot; but they have been talking about that since 2017...)","m.relates_to":{"m.in_reply_to":{"event_id":"$nzR7UPVD30lLymvJ6DqiGrseRYvopnFuqyuQk-vPeYo"}}},"ts":1670952332303,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$3xrcHVAP1VjgX2P-6UJy3WXw9AwpMs40DYJounQoF3o"}
]