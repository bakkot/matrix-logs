[
{"content":{"body":"I think we have more `unhandledrejection` bugs that we haven't caught yet","format":"org.matrix.custom.html","formatted_body":"I think we have more <code>unhandledrejection</code> bugs that we haven't caught yet","m.mentions":{},"msgtype":"m.text"},"ts":1716832612413,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$1ZB0IIoDBrF3wWpL0n7VOVMyd34i5MWri33YB5w2Zjc"},
{"content":{"body":"this was in part because `unhandledrejection` is tested with WPT, not test262, and I haven't gotten around to writing WPT tests yet","format":"org.matrix.custom.html","formatted_body":"this was in part because <code>unhandledrejection</code> is tested with WPT, not test262, and I haven't gotten around to writing WPT tests yet","m.mentions":{},"msgtype":"m.text"},"ts":1716832637542,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$1Ca4jPr7JLCcsRVndoQJilZM6v4mW3v7GgS04VgIl6k"},
{"content":{"body":"but it's looking like with the current spec, `someApi().then()` would lose track of the rejection context","format":"org.matrix.custom.html","formatted_body":"but it's looking like with the current spec, <code>someApi().then()</code> would lose track of the rejection context","m.mentions":{},"msgtype":"m.text"},"ts":1716832695395,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$jf44l-YKfd4kHttjS1x46QVSXmJ0A1fp7DRQeGw420c"},
{"content":{"body":" * but it's looking like with the current spec, `someAsyncApi().then()` would lose track of the rejection context","format":"org.matrix.custom.html","formatted_body":" * but it's looking like with the current spec, <code>someAsyncApi().then()</code> would lose track of the rejection context","m.mentions":{},"m.new_content":{"body":"but it's looking like with the current spec, `someAsyncApi().then()` would lose track of the rejection context","format":"org.matrix.custom.html","formatted_body":"but it's looking like with the current spec, <code>someAsyncApi().then()</code> would lose track of the rejection context","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$jf44l-YKfd4kHttjS1x46QVSXmJ0A1fp7DRQeGw420c","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716832707348,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$47SOK9LxfLnMi_odnMrde_hEpBZTGbRa-xnA1hwgNHs"},
{"content":{"body":"in Stephen's proposal of preserving the resolution context, this would just work I think","m.mentions":{},"msgtype":"m.text"},"ts":1716832744870,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$obAxmbioP6_uxcgILpRu2PJPcC8MZuwR-adtQAzL03I"},
{"content":{"body":"> <@jridgewell:matrix.org> This seems funcionally equivalent to https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550, which solves the global leak issue by having a wrapping try-catch reset the vaules after exiting the closure. It’s still not my favorite implementation becuase of mutability and odering of async functions causing unrelated breakages, eg if [main](https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d) started with an `await 0` before entering `’bar’`, the outside caller sees different behavior. It feels like Zalgo-lite.\n\nSimilar, but the intent is that the _runtime_ would generally be defining those scopes rather than only ever being handled by a user-facing API. We have a bunch of discrete execution concepts which can be used as boundaries for these scopes such as a promise continuation or a callback. We could also probably extend the Function type with something like a `func.bindToContext(value)` which could be similar to having that function call `run(...)` internally.\n\nMy point is, we can have the nice DX of the set/get interface without too heavily exposing the scoping problem to users. Decoupling the scoping also makes it potentially reusable, which would be beneficial if we _do_ decide to make separate types for the two around and through flows. It would simplify things for users if they can describes scopes with a single API and have both flow systems just make different decisions about how to link the scopes together in the graph.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$fiVwqndboo6mXJ01igGxVo4jk0tyfJH4g8mNKB2pcmU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>This seems funcionally equivalent to https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550, which solves the global leak issue by having a wrapping try-catch reset the vaules after exiting the closure. It’s still not my favorite implementation becuase of mutability and odering of async functions causing unrelated breakages, eg if <a data-md href=\"https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d\">main</a> started with an <code data-md=\"`\">await 0</code> before entering <code data-md=\"`\">’bar’</code>, the outside caller sees different behavior. It feels like Zalgo-lite.</blockquote></mx-reply><p>Similar, but the intent is that the <em>runtime</em> would generally be defining those scopes rather than only ever being handled by a user-facing API. We have a bunch of discrete execution concepts which can be used as boundaries for these scopes such as a promise continuation or a callback. We could also probably extend the Function type with something like a <code>func.bindToContext(value)</code> which could be similar to having that function call <code>run(...)</code> internally.</p>\n<p>My point is, we can have the nice DX of the set/get interface without too heavily exposing the scoping problem to users. Decoupling the scoping also makes it potentially reusable, which would be beneficial if we <em>do</em> decide to make separate types for the two around and through flows. It would simplify things for users if they can describes scopes with a single API and have both flow systems just make different decisions about how to link the scopes together in the graph.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$fiVwqndboo6mXJ01igGxVo4jk0tyfJH4g8mNKB2pcmU"}},"msgtype":"m.text"},"ts":1716832967695,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$wc4PaWHNjoi3f9qjNB6VdBgksN8xqgEPGTbAQn4tstk"},
{"content":{"body":"> <@jridgewell:matrix.org> Everywhere except if it’s set within the global context, which persists beyond just the current sync execution. Your above `defineScope(() => {})` solves this by definining an exit point that cleans the global context.\n\nIf you mean the top-level of the file/module, it'd just live as long as that script/module does, which seems to make sense to me.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$zsPTxqj7WoePgXeX44i9rQHqlcqmsUWD_TIX9gMWqHo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Everywhere except if it’s set within the global context, which persists beyond just the current sync execution. Your above <code data-md=\"`\">defineScope(() =&gt; {})</code> solves this by definining an exit point that cleans the global context.</blockquote></mx-reply>If you mean the top-level of the file/module, it'd just live as long as that script/module does, which seems to make sense to me.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zsPTxqj7WoePgXeX44i9rQHqlcqmsUWD_TIX9gMWqHo"}},"msgtype":"m.text"},"ts":1716833027425,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$-3d0vUaluEblaywga6yiCmREWU_-o-Za5NTHu77nAcs"},
{"content":{"body":"> <@jridgewell:matrix.org> > The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to undefined when you've decided you're done with it.\n> \n> In a flows-through system, I think you also need to free every cached promise that holds that context? They would strongly hold their resolution context. The engine wouldn’t mutate user’s context automatically, and without a library API to know when the current exeuction is finalized, you’re left guessing when you can mutate the context or drop all promises.\n\nYes, promises suck a little bit in that they would need to hold the reference alive as long as the promise remains alive. This _could_ increase memory pressure, but is also the _expected_ behaviour as any future continuation attached to that promise _should_ restore that context value.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$xLgn1L7yDpNXKEtgMe3yLvEcVmclUtwa3A0Ffv7QBh4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br><blockquote data-md=\"&gt;\">The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to undefined when you've decided you're done with it.<br /></blockquote><br />In a flows-through system, I think you also need to free every cached promise that holds that context? They would strongly hold their resolution context. The engine wouldn’t mutate user’s context automatically, and without a library API to know when the current exeuction is finalized, you’re left guessing when you can mutate the context or drop all promises.</blockquote></mx-reply>Yes, promises suck a little bit in that they would need to hold the reference alive as long as the promise remains alive. This <em>could</em> increase memory pressure, but is also the <em>expected</em> behaviour as any future continuation attached to that promise <em>should</em> restore that context value.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$xLgn1L7yDpNXKEtgMe3yLvEcVmclUtwa3A0Ffv7QBh4"}},"msgtype":"m.text"},"ts":1716833096225,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$k0nShT5uLRzZWTDRaLyp7JgBTXPAMwZfe9Jzlagf0XE"}
]