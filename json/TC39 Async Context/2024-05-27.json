[
{"content":{"body":"I think we have more `unhandledrejection` bugs that we haven't caught yet","format":"org.matrix.custom.html","formatted_body":"I think we have more <code>unhandledrejection</code> bugs that we haven't caught yet","m.mentions":{},"msgtype":"m.text"},"ts":1716832612413,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$1ZB0IIoDBrF3wWpL0n7VOVMyd34i5MWri33YB5w2Zjc"},
{"content":{"body":"this was in part because `unhandledrejection` is tested with WPT, not test262, and I haven't gotten around to writing WPT tests yet","format":"org.matrix.custom.html","formatted_body":"this was in part because <code>unhandledrejection</code> is tested with WPT, not test262, and I haven't gotten around to writing WPT tests yet","m.mentions":{},"msgtype":"m.text"},"ts":1716832637542,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$1Ca4jPr7JLCcsRVndoQJilZM6v4mW3v7GgS04VgIl6k"},
{"content":{"body":"but it's looking like with the current spec, `someApi().then()` would lose track of the rejection context","format":"org.matrix.custom.html","formatted_body":"but it's looking like with the current spec, <code>someApi().then()</code> would lose track of the rejection context","m.mentions":{},"msgtype":"m.text"},"ts":1716832695395,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$jf44l-YKfd4kHttjS1x46QVSXmJ0A1fp7DRQeGw420c"},
{"content":{"body":" * but it's looking like with the current spec, `someAsyncApi().then()` would lose track of the rejection context","format":"org.matrix.custom.html","formatted_body":" * but it's looking like with the current spec, <code>someAsyncApi().then()</code> would lose track of the rejection context","m.mentions":{},"m.new_content":{"body":"but it's looking like with the current spec, `someAsyncApi().then()` would lose track of the rejection context","format":"org.matrix.custom.html","formatted_body":"but it's looking like with the current spec, <code>someAsyncApi().then()</code> would lose track of the rejection context","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$jf44l-YKfd4kHttjS1x46QVSXmJ0A1fp7DRQeGw420c","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716832707348,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$47SOK9LxfLnMi_odnMrde_hEpBZTGbRa-xnA1hwgNHs"},
{"content":{"body":"in Stephen's proposal of preserving the resolution context, this would just work I think","m.mentions":{},"msgtype":"m.text"},"ts":1716832744870,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$obAxmbioP6_uxcgILpRu2PJPcC8MZuwR-adtQAzL03I"},
{"content":{"body":"> <@jridgewell:matrix.org> This seems funcionally equivalent to https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550, which solves the global leak issue by having a wrapping try-catch reset the vaules after exiting the closure. It’s still not my favorite implementation becuase of mutability and odering of async functions causing unrelated breakages, eg if [main](https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d) started with an `await 0` before entering `’bar’`, the outside caller sees different behavior. It feels like Zalgo-lite.\n\nSimilar, but the intent is that the _runtime_ would generally be defining those scopes rather than only ever being handled by a user-facing API. We have a bunch of discrete execution concepts which can be used as boundaries for these scopes such as a promise continuation or a callback. We could also probably extend the Function type with something like a `func.bindToContext(value)` which could be similar to having that function call `run(...)` internally.\n\nMy point is, we can have the nice DX of the set/get interface without too heavily exposing the scoping problem to users. Decoupling the scoping also makes it potentially reusable, which would be beneficial if we _do_ decide to make separate types for the two around and through flows. It would simplify things for users if they can describes scopes with a single API and have both flow systems just make different decisions about how to link the scopes together in the graph.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$fiVwqndboo6mXJ01igGxVo4jk0tyfJH4g8mNKB2pcmU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>This seems funcionally equivalent to https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550, which solves the global leak issue by having a wrapping try-catch reset the vaules after exiting the closure. It’s still not my favorite implementation becuase of mutability and odering of async functions causing unrelated breakages, eg if <a data-md href=\"https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d\">main</a> started with an <code data-md=\"`\">await 0</code> before entering <code data-md=\"`\">’bar’</code>, the outside caller sees different behavior. It feels like Zalgo-lite.</blockquote></mx-reply><p>Similar, but the intent is that the <em>runtime</em> would generally be defining those scopes rather than only ever being handled by a user-facing API. We have a bunch of discrete execution concepts which can be used as boundaries for these scopes such as a promise continuation or a callback. We could also probably extend the Function type with something like a <code>func.bindToContext(value)</code> which could be similar to having that function call <code>run(...)</code> internally.</p>\n<p>My point is, we can have the nice DX of the set/get interface without too heavily exposing the scoping problem to users. Decoupling the scoping also makes it potentially reusable, which would be beneficial if we <em>do</em> decide to make separate types for the two around and through flows. It would simplify things for users if they can describes scopes with a single API and have both flow systems just make different decisions about how to link the scopes together in the graph.</p>\n","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$fiVwqndboo6mXJ01igGxVo4jk0tyfJH4g8mNKB2pcmU"}},"msgtype":"m.text"},"ts":1716832967695,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$wc4PaWHNjoi3f9qjNB6VdBgksN8xqgEPGTbAQn4tstk"},
{"content":{"body":"> <@jridgewell:matrix.org> Everywhere except if it’s set within the global context, which persists beyond just the current sync execution. Your above `defineScope(() => {})` solves this by definining an exit point that cleans the global context.\n\nIf you mean the top-level of the file/module, it'd just live as long as that script/module does, which seems to make sense to me.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$zsPTxqj7WoePgXeX44i9rQHqlcqmsUWD_TIX9gMWqHo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>Everywhere except if it’s set within the global context, which persists beyond just the current sync execution. Your above <code data-md=\"`\">defineScope(() =&gt; {})</code> solves this by definining an exit point that cleans the global context.</blockquote></mx-reply>If you mean the top-level of the file/module, it'd just live as long as that script/module does, which seems to make sense to me.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zsPTxqj7WoePgXeX44i9rQHqlcqmsUWD_TIX9gMWqHo"}},"msgtype":"m.text"},"ts":1716833027425,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$-3d0vUaluEblaywga6yiCmREWU_-o-Za5NTHu77nAcs"},
{"content":{"body":"> <@jridgewell:matrix.org> > The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to undefined when you've decided you're done with it.\n> \n> In a flows-through system, I think you also need to free every cached promise that holds that context? They would strongly hold their resolution context. The engine wouldn’t mutate user’s context automatically, and without a library API to know when the current exeuction is finalized, you’re left guessing when you can mutate the context or drop all promises.\n\nYes, promises suck a little bit in that they would need to hold the reference alive as long as the promise remains alive. This _could_ increase memory pressure, but is also the _expected_ behaviour as any future continuation attached to that promise _should_ restore that context value.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$xLgn1L7yDpNXKEtgMe3yLvEcVmclUtwa3A0Ffv7QBh4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br><blockquote data-md=\"&gt;\">The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to undefined when you've decided you're done with it.<br /></blockquote><br />In a flows-through system, I think you also need to free every cached promise that holds that context? They would strongly hold their resolution context. The engine wouldn’t mutate user’s context automatically, and without a library API to know when the current exeuction is finalized, you’re left guessing when you can mutate the context or drop all promises.</blockquote></mx-reply>Yes, promises suck a little bit in that they would need to hold the reference alive as long as the promise remains alive. This <em>could</em> increase memory pressure, but is also the <em>expected</em> behaviour as any future continuation attached to that promise <em>should</em> restore that context value.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$xLgn1L7yDpNXKEtgMe3yLvEcVmclUtwa3A0Ffv7QBh4"}},"msgtype":"m.text"},"ts":1716833096225,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$k0nShT5uLRzZWTDRaLyp7JgBTXPAMwZfe9Jzlagf0XE"},
{"content":{"body":"> <@abotella:igalia.com> in Stephen's proposal of preserving the resolution context, this would just work I think\n\nYes, `unhandledrejection` is one particular case where the desired context is _always_ the flows-through context. You want to capture the context as it was when the rejection _happened_, even if it flows through a bunch of intermediate layers.\n\nThe difference between through and around flows is basically the same conceptually as subject and predicate. The _through_ path gives you the subject of the failure so you can actually _see_ what's going on. Whereas the _around_ path gives you the predicate which is only describing what is being _done_ with that subject, but that's not relevant in the case of a failure as it's what _would have_ been done but will not be _because_ of the failure.\n\nThis also matches that prior description of around flow being like parameter flow. It describes where execution is _going_ and not so much where it _came from_, which is a bit counter-intuitive from the flow users have generally expected from AsyncLocalStorage where they want to know where something _came from_ so they can acquired stored information about that originating execution.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$obAxmbioP6_uxcgILpRu2PJPcC8MZuwR-adtQAzL03I?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@abotella:igalia.com\">@abotella:igalia.com</a><br>in Stephen&#39;s proposal of preserving the resolution context, this would just work I think</blockquote></mx-reply><p>Yes, <code>unhandledrejection</code> is one particular case where the desired context is <em>always</em> the flows-through context. You want to capture the context as it was when the rejection <em>happened</em>, even if it flows through a bunch of intermediate layers.</p>\n<p>The difference between through and around flows is basically the same conceptually as subject and predicate. The <em>through</em> path gives you the subject of the failure so you can actually <em>see</em> what's going on. Whereas the <em>around</em> path gives you the predicate which is only describing what is being <em>done</em> with that subject, but that's not relevant in the case of a failure as it's what <em>would have</em> been done but will not be <em>because</em> of the failure.</p>\n<p>This also matches that prior description of around flow being like parameter flow. It describes where execution is <em>going</em> and not so much where it <em>came from</em>, which is a bit counter-intuitive from the flow users have generally expected from AsyncLocalStorage where they want to know where something <em>came from</em> so they can acquired stored information about that originating execution.</p>\n","m.mentions":{"user_ids":["@abotella:igalia.com"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$obAxmbioP6_uxcgILpRu2PJPcC8MZuwR-adtQAzL03I"}},"msgtype":"m.text"},"ts":1716833641037,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$VmuweaKPEJOudCkfj-CzMFZKL8T59SPMeU7757BipQI"},
{"content":{"body":"so if we have both types of async context variables, then the only one that would have a relevant context for unhandledrejection would be the get/set one?","m.mentions":{},"msgtype":"m.text"},"ts":1716833759775,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$lbOHOrScepnpGUY31k-Vk-n0WCVcv_AF-Kv4LZdJx6M"},
{"content":{"body":"no, you still need some value for the other variables","m.mentions":{},"msgtype":"m.text"},"ts":1716833792814,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$hLCLWF76ODpSkt03lSs5RX3j7uet60VNex-m7nbMQeQ"},
{"content":{"body":"get/set is a separate thing.","m.mentions":{},"msgtype":"m.text"},"ts":1716833798909,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$mzpM_CuFD9IQAj6nF6rrm9lp3wjSMh9HB9LHmyZ1Iwg"},
{"content":{"body":"oh, I might have been conflating both proposals","m.mentions":{},"msgtype":"m.text"},"ts":1716833816570,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$Bex51iODEMm1E9rBba9pNVC7twEoI4I8nt2XFMeBvh0"},
{"content":{"body":"The get/set thing is just about that you don't actually _need_ the `store.run(...)` if you have the _runtime_ provide scopes.","format":"org.matrix.custom.html","formatted_body":"The get/set thing is just about that you don't actually <em>need</em> the <code>store.run(...)</code> if you have the <em>runtime</em> provide scopes.","m.mentions":{},"msgtype":"m.text"},"ts":1716833847489,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7Z-J9grq_nLIpr8ZB98IxnPJuFwuj1Z2-w-DXckWw4E"},
{"content":{"body":"Well, you still might _want_ to have `run(..)` sometimes, but it becomes less important if the context flow model is clear and correct from the core.","format":"org.matrix.custom.html","formatted_body":"Well, you still might <em>want</em> to have <code>run(..)</code> sometimes, but it becomes less important if the context flow model is clear and correct from the core.","m.mentions":{},"msgtype":"m.text"},"ts":1716833903656,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$7bKAF47Ggj2sBVbepm6Wi9P6utZNTLN-jA5a7HwJRyM"},
{"content":{"body":"Which is where integration with things like promises comes in.","m.mentions":{},"msgtype":"m.text"},"ts":1716833930792,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$2Bt6hIdnKPQ0Z7_Zan2Cnxk3LdGlJWhu5q_C0fSokJc"},
{"content":{"body":"well, I think the idea I had was James Snell's distinction between a run API that flows around and a set API that flows through","m.mentions":{},"msgtype":"m.text"},"ts":1716833943381,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$cfNdBf9URFqP6Y65OWPUnaZRU5996ZjOOTIQRt-3p1g"},
{"content":{"body":"I might have missed some of the intervening discussion because I was sick","m.mentions":{},"msgtype":"m.text"},"ts":1716833968258,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$xJdh708Rm7jteaod4wpR4NXLAAB0YYAKIwKRLMkyH64"},
{"content":{"body":"So it's a little weird to me that we're pursuing _both_ defining the correct flow model _and_ still using the `run(...)` scoping when we could just safely modify the _current_ scope if we actually _have_ a clearly defined \"current scope\" to be modifying.","format":"org.matrix.custom.html","formatted_body":"So it's a little weird to me that we're pursuing <em>both</em> defining the correct flow model <em>and</em> still using the <code>run(...)</code> scoping when we could just safely modify the <em>current</em> scope if we actually <em>have</em> a clearly defined \"current scope\" to be modifying.","m.mentions":{},"msgtype":"m.text"},"ts":1716833981951,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Ao2UY4fOaYynXoVP-riOkDh0mNawHjnep15ksF_N4Qk"},
{"content":{"body":"I may have missed that too. 🤔","m.mentions":{},"msgtype":"m.text"},"ts":1716834022081,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$iizeUye5KcFDj6VX4Q6FsVdkreg5mES8LCDxEIoRG10"},
{"content":{"body":"would sync function boundaries be part of that scope?","m.mentions":{},"msgtype":"m.text"},"ts":1716834091301,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$FxGK7NsSpbK6yanZVduSpzbBYeEJ7pe4vx9M-Vdop5I"},
{"content":{"body":"Yes, it should be only sync segments of execution.","m.mentions":{},"msgtype":"m.text"},"ts":1716834126201,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$DXITo-5CSHPxT9UyYEDxanmVfyWcfvvo8OYTOb_2SIw"},
{"content":{"body":"And then the `run` function would essentially just be: ```run(value, scope) {\n  const prev = this.get()\n  this.set(value)\n  try {\n    return scope()\n  } finally {\n    this.set(prev)\n  }\n}```","format":"org.matrix.custom.html","formatted_body":"And then the <code>run</code> function would essentially just be: <code>run(value, scope) { const prev = this.get() this.set(value) try { return scope() } finally { this.set(prev) } }</code>","m.mentions":{},"msgtype":"m.text"},"ts":1716834148687,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$4FUqCtx-dducHtVd219Ldc6QtxnJAWmTzWsRau-KXEo"},
{"content":{"body":" * And then the `run` function would essentially just be:\n\n```js\nrun(value, scope) {\n  const prev = this.get()\n  this.set(value)\n  try {\n    return scope()\n  } finally {\n    this.set(prev)\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>And then the <code>run</code> function would essentially just be:</p>\n<pre><code class=\"language-js\">run(value, scope) {\n  const prev = this.get()\n  this.set(value)\n  try {\n    return scope()\n  } finally {\n    this.set(prev)\n  }\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"And then the `run` function would essentially just be:\n\n```js\nrun(value, scope) {\n  const prev = this.get()\n  this.set(value)\n  try {\n    return scope()\n  } finally {\n    this.set(prev)\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>And then the <code>run</code> function would essentially just be:</p>\n<pre><code class=\"language-js\">run(value, scope) {\n  const prev = this.get()\n  this.set(value)\n  try {\n    return scope()\n  } finally {\n    this.set(prev)\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$4FUqCtx-dducHtVd219Ldc6QtxnJAWmTzWsRau-KXEo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716834188699,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$pZoAAw0NePpLu955Crj4ViI-jz0jTo_dIY9MvWUqPLo"},
{"content":{"body":"I think one of the hurdles we have at the implementor level is that we _really_ want to think about async functions and generators as singular functions and not chains of segments of synchronous execution managed by a scheduler.","format":"org.matrix.custom.html","formatted_body":"I think one of the hurdles we have at the implementor level is that we <em>really</em> want to think about async functions and generators as singular functions and not chains of segments of synchronous execution managed by a scheduler.","m.mentions":{},"msgtype":"m.text"},"ts":1716834313599,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$8T8pjF9FII4k599PRkUZUkcChAE-BEKaovUw3irJdts"},
{"content":{"body":"so IIUC:\n```js\nasyncVar.set(\"foo\");\n\nawait (async () => {\n\tasyncVar.set(\"bar\");\n})();\n\nconsole.log(asyncVar.get());  // bar\n```\nbut\n```js\nasyncVar.set(\"foo\");\n\n// No await!\n(async () => {\n\tasyncVar.set(\"bar\");\n})();\n\nconsole.log(asyncVar.get());  // foo\n```","format":"org.matrix.custom.html","formatted_body":"<p>so IIUC:</p>\n<pre><code class=\"language-js\">asyncVar.set(\"foo\");\n\nawait (async () =&gt; {\n\tasyncVar.set(\"bar\");\n})();\n\nconsole.log(asyncVar.get());  // bar\n</code></pre>\n<p>but</p>\n<pre><code class=\"language-js\">asyncVar.set(\"foo\");\n\n// No await!\n(async () =&gt; {\n\tasyncVar.set(\"bar\");\n})();\n\nconsole.log(asyncVar.get());  // foo\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716834317949,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$cfyxiKB9sN0QP7TUGqqd92F47L5kz_-aTVBgRXFA3LI"},
{"content":{"body":"wait","m.mentions":{},"msgtype":"m.text"},"ts":1716834349345,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$m2WgyxwhJVdPSpZYPtrBjYwSCC-EOWK92CVwFA7zZnA"},
{"content":{"body":"Both would actually be bar.","m.mentions":{},"msgtype":"m.text"},"ts":1716834363147,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$Gm4l5B1hx_W0joEYWDdSrZti6AH18JmlMG02KOV6Pxc"},
{"content":{"body":"do things change if there's some await inside the async function?","m.mentions":{},"msgtype":"m.text"},"ts":1716834376471,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$RWeMgm2SJn6cs4mIhoVuzJAH04aOWAnI4WJjLGoIJUA"},
{"content":{"body":"And the first is bar _now_ because that first segment of the inner async function is sync.","format":"org.matrix.custom.html","formatted_body":"And the first is bar <em>now</em> because that first segment of the inner async function is sync.","m.mentions":{},"msgtype":"m.text"},"ts":1716834380329,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$l75gNsC6xp_aKu8E3BL2WezpHZ4cbcV4sqiNGB9_kB4"},
{"content":{"body":" * do things change if there's some await inside the async function, before the set?\\","format":"org.matrix.custom.html","formatted_body":" * do things change if there's some await inside the async function, before the set?\\","m.mentions":{},"m.new_content":{"body":"do things change if there's some await inside the async function, before the set?\\","format":"org.matrix.custom.html","formatted_body":"do things change if there's some await inside the async function, before the set?\\","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$RWeMgm2SJn6cs4mIhoVuzJAH04aOWAnI4WJjLGoIJUA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716834387177,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$csCzZsw7MqzqIAQkNLMfwFPU-ct_17ZfeGizVxPF5M0"},
{"content":{"body":"Yes, so currently a _huge_ source of confusion in Node.js is that `store.enterWith(...)` _before_ the first await behaves very differently from `store.enterWith(...)` _after_ the first await.","format":"org.matrix.custom.html","formatted_body":"Yes, so currently a <em>huge</em> source of confusion in Node.js is that <code>store.enterWith(...)</code> <em>before</em> the first await behaves very differently from <code>store.enterWith(...)</code> <em>after</em> the first await.","m.mentions":{},"msgtype":"m.text"},"ts":1716834421972,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$197YR5W_pmfcYSRjPSPh_lMFalZHA_5gSn4HYlENZwM"},
{"content":{"body":"Because that first segment of an async function is actually executed synchronously rather than lazily.","m.mentions":{},"msgtype":"m.text"},"ts":1716834442247,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$MhrmBWxekBL0vXIQ3a6PAm-lJNjnG5LG18JaO5EN4ik"},
{"content":{"body":"I think that's more a problem with how async functions are defined that with AsyncLocalStorage though. You can get the same unexpected behaviour just modifying globals in an async function.","m.mentions":{},"msgtype":"m.text"},"ts":1716834515307,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$l4jlHjArdho5qZO7k-QsYENzZcZcprqxLiLPWWCuRH0"},
{"content":{"body":" * I think that's more a problem with how async functions are defined than with AsyncLocalStorage though. You can get the same unexpected behaviour just modifying globals in an async function.","m.mentions":{},"m.new_content":{"body":"I think that's more a problem with how async functions are defined than with AsyncLocalStorage though. You can get the same unexpected behaviour just modifying globals in an async function.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$l4jlHjArdho5qZO7k-QsYENzZcZcprqxLiLPWWCuRH0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716834524221,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$K4lcmudxa8kGlGNNEu44WIL3GIVecRfIiJkqo7bc2n4"},
{"content":{"body":"I really wish async functions were actually lazy started and would not run anything until they are awaited or a continuation is attached. A bit late to change the past though. 😐️","m.mentions":{},"msgtype":"m.text"},"ts":1716834582289,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$blCJc46IMyNM0vlvnKQXUhZuIydeu5gZ2S1nmidWcUE"},
{"content":{"body":"To distill things down to the essence of context management: all that is actually required to fully implement context flow is to capture three points:\n- When a call schedules an async task the current context needs to be scheduled.\n- When top-level or any nested continuations of async tasks would begin sync execution.\n- And if context is not flowed _completely_ into all paths then the _end_ of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.","format":"org.matrix.custom.html","formatted_body":"<p>To distill things down to the essence of context management: all that is actually required to fully implement context flow is to capture three points:</p>\n<ul>\n<li>When a call schedules an async task the current context needs to be scheduled.</li>\n<li>When top-level or any nested continuations of async tasks would begin sync execution.</li>\n<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1716834954867,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$csqhY6ZU6npVwr8lxc8qOrrBuPZ8iateEY0hQ5dJ5iU"},
{"content":{"body":" * To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:\n\n- When a call schedules an async task the current context needs to be scheduled.\n- When top-level or any nested continuations of async tasks would begin sync execution.\n- And if context is not flowed _completely_ into all paths then the _end_ of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.","format":"org.matrix.custom.html","formatted_body":" * <p>To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:</p>\n<ul>\n<li>When a call schedules an async task the current context needs to be scheduled.</li>\n<li>When top-level or any nested continuations of async tasks would begin sync execution.</li>\n<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:\n\n- When a call schedules an async task the current context needs to be scheduled.\n- When top-level or any nested continuations of async tasks would begin sync execution.\n- And if context is not flowed _completely_ into all paths then the _end_ of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.","format":"org.matrix.custom.html","formatted_body":"<p>To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:</p>\n<ul>\n<li>When a call schedules an async task the current context needs to be scheduled.</li>\n<li>When top-level or any nested continuations of async tasks would begin sync execution.</li>\n<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$csqhY6ZU6npVwr8lxc8qOrrBuPZ8iateEY0hQ5dJ5iU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716834971508,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$MSkqn2Ryk2T-vgamIDUMp5IMTpV5BPVF5yMHeNb4ClY"},
{"content":{"body":" * To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:\n\n- When a call schedules an async task the current context needs to be captured.\n- When top-level or any nested continuations of async tasks would begin sync execution.\n- And if context is not flowed _completely_ into all paths then the _end_ of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.","format":"org.matrix.custom.html","formatted_body":" * <p>To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:</p>\n<ul>\n<li>When a call schedules an async task the current context needs to be captured.</li>\n<li>When top-level or any nested continuations of async tasks would begin sync execution.</li>\n<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:\n\n- When a call schedules an async task the current context needs to be captured.\n- When top-level or any nested continuations of async tasks would begin sync execution.\n- And if context is not flowed _completely_ into all paths then the _end_ of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.","format":"org.matrix.custom.html","formatted_body":"<p>To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:</p>\n<ul>\n<li>When a call schedules an async task the current context needs to be captured.</li>\n<li>When top-level or any nested continuations of async tasks would begin sync execution.</li>\n<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$csqhY6ZU6npVwr8lxc8qOrrBuPZ8iateEY0hQ5dJ5iU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716834984669,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$OtGBHtBT7soTh__YMMSCjsxWkKcdWp1Dkwf-r2AOTyg"},
{"content":{"body":" * To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:\n\n- When a call schedules an async task the current context needs to be captured.\n- When top-level or any nested continuations of async tasks would begin sync execution the context needs to be restored.\n- And if context is not flowed _completely_ into all paths then the _end_ of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.","format":"org.matrix.custom.html","formatted_body":" * <p>To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:</p>\n<ul>\n<li>When a call schedules an async task the current context needs to be captured.</li>\n<li>When top-level or any nested continuations of async tasks would begin sync execution the context needs to be restored.</li>\n<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:\n\n- When a call schedules an async task the current context needs to be captured.\n- When top-level or any nested continuations of async tasks would begin sync execution the context needs to be restored.\n- And if context is not flowed _completely_ into all paths then the _end_ of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.","format":"org.matrix.custom.html","formatted_body":"<p>To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:</p>\n<ul>\n<li>When a call schedules an async task the current context needs to be captured.</li>\n<li>When top-level or any nested continuations of async tasks would begin sync execution the context needs to be restored.</li>\n<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider all execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$csqhY6ZU6npVwr8lxc8qOrrBuPZ8iateEY0hQ5dJ5iU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716834998455,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$PcyEsg-4RO0kNQqaF8uokH5WwIB2qrZXi7jJsl8MOpM"},
{"content":{"body":" * To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:\n\n- When a call schedules an async task the current context needs to be captured.\n- When top-level or any nested continuations of async tasks would begin sync execution the context needs to be restored.\n- And if context is not flowed _completely_ into all paths then the _end_ of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider _all_ execution as logically descending from the runtime starting and branch contexts off from that accordingly.","format":"org.matrix.custom.html","formatted_body":" * <p>To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:</p>\n<ul>\n<li>When a call schedules an async task the current context needs to be captured.</li>\n<li>When top-level or any nested continuations of async tasks would begin sync execution the context needs to be restored.</li>\n<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider <em>all</em> execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:\n\n- When a call schedules an async task the current context needs to be captured.\n- When top-level or any nested continuations of async tasks would begin sync execution the context needs to be restored.\n- And if context is not flowed _completely_ into all paths then the _end_ of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider _all_ execution as logically descending from the runtime starting and branch contexts off from that accordingly.","format":"org.matrix.custom.html","formatted_body":"<p>To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:</p>\n<ul>\n<li>When a call schedules an async task the current context needs to be captured.</li>\n<li>When top-level or any nested continuations of async tasks would begin sync execution the context needs to be restored.</li>\n<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider <em>all</em> execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$csqhY6ZU6npVwr8lxc8qOrrBuPZ8iateEY0hQ5dJ5iU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1716835054590,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$pO5Cy5oyKTA83S9oN1kTfvX9rEZafDZQh1ycjxCm8UE"},
{"content":{"body":"The window between a sync execution beginning and either that sync execution ending or the _next_ sync execution beginning is the exact scope for which you can apply a `set` in the `set`/`get` model. You would just need copy-on-write semantics so changes don't impact execution already _passed_ in that sync window. And then the `get` is all you need for async task scheduling to capture the value to be restored in the sync execution of its continuation using `set` again before beginning that execution.","format":"org.matrix.custom.html","formatted_body":"The window between a sync execution beginning and either that sync execution ending or the <em>next</em> sync execution beginning is the exact scope for which you can apply a <code>set</code> in the <code>set</code>/<code>get</code> model. You would just need copy-on-write semantics so changes don't impact execution already <em>passed</em> in that sync window. And then the <code>get</code> is all you need for async task scheduling to capture the value to be restored in the sync execution of its continuation using <code>set</code> again before beginning that execution.","m.mentions":{},"msgtype":"m.text"},"ts":1716835254869,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$mfdAJf5XnqiTxGVmPVKlp_35Z_uzDwXik42S9jKrRPE"},
{"content":{"body":"So _in theory_ you actually only need the _two_ points: `set` corresponding to a sync execution starting or a desired change partway through a sync execution to segment out the remainder, and the `get` corresponding to capturing the context when an async task is scheduled or when the user would like to retrieve the value themselves.","format":"org.matrix.custom.html","formatted_body":"So <em>in theory</em> you actually only need the <em>two</em> points: <code>set</code> corresponding to a sync execution starting or a desired change partway through a sync execution to segment out the remainder, and the <code>get</code> corresponding to capturing the context when an async task is scheduled or when the user would like to retrieve the value themselves.","m.mentions":{},"msgtype":"m.text"},"ts":1716835403106,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$OnC_t8fOGkcAudG9zGSZr6rD0wa654c2Ar6xib1Ef84"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Yes, so currently a _huge_ source of confusion in Node.js is that `store.enterWith(...)` _before_ the first await behaves very differently from `store.enterWith(...)` _after_ the first await.\n\nThis wouldn't be an issue with `run`. I suspect you think that removing this footgun makes things so much less convenient that it's not worth it?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$197YR5W_pmfcYSRjPSPh_lMFalZHA_5gSn4HYlENZwM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Yes, so currently a <em>huge</em> source of confusion in Node.js is that <code>store.enterWith(...)</code> <em>before</em> the first await behaves very differently from <code>store.enterWith(...)</code> <em>after</em> the first await.</blockquote></mx-reply>This wouldn't be an issue with <code>run</code>. I suspect you think that removing this footgun makes things so much less convenient that it's not worth it?","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$197YR5W_pmfcYSRjPSPh_lMFalZHA_5gSn4HYlENZwM"}},"msgtype":"m.text"},"ts":1716835525795,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$ci7v3TAi0KEJXqXYyXb2SMyWhUjTZ5G9lqeAEuZaxho"},
{"content":{"body":"It's not an issue, but `run(...)` is even _harder_ to figure out how to use correctly in an async function.","format":"org.matrix.custom.html","formatted_body":"It's not an issue, but <code>run(...)</code> is even <em>harder</em> to figure out how to use correctly in an async function.","m.mentions":{},"msgtype":"m.text"},"ts":1716835629358,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$V_ebZqo1261bU05qpVPm3zi6QjkICMymbCVRr7_Vaw8"},
{"content":{"body":"Do you wrap the call to that function? Do you nest its entire body in _another_ async function within a nested run? Either way the DX is pretty bad.","format":"org.matrix.custom.html","formatted_body":"Do you wrap the call to that function? Do you nest its entire body in <em>another</em> async function within a nested run? Either way the DX is pretty bad.","m.mentions":{},"msgtype":"m.text"},"ts":1716835667570,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$DjyWo_mo86t5RASEN1JEH8_mqPyeufv2Gk7CQtH8MtQ"},
{"content":{"body":"Whereas a simple `store.set(...)` is a lot more straightforward.","format":"org.matrix.custom.html","formatted_body":"Whereas a simple <code>store.set(...)</code> is a lot more straightforward.","m.mentions":{},"msgtype":"m.text"},"ts":1716835692997,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$vzPAdg8Tw5nRmVV5YLvmiGLaRiME9Mdt3KvyH5ULLsI"},
{"content":{"body":"And also, _importantly_, is _not yet defined_, so we could specify that calling `set(...)` inside an async function is treated as if that async function had a scope around it, if we want to do the _around_ scope and not leak out even if calling it _before_ that first await.","format":"org.matrix.custom.html","formatted_body":"And also, <em>importantly</em>, is <em>not yet defined</em>, so we could specify that calling <code>set(...)</code> inside an async function is treated as if that async function had a scope around it, if we want to do the <em>around</em> scope and not leak out even if calling it <em>before</em> that first await.","m.mentions":{},"msgtype":"m.text"},"ts":1716835771054,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$aNngnZ5luYU2AWsaUPGXD6QdG7XbxG0GUNnDK4PAJ3Q"},
{"content":{"body":"So the semantics of the initial sync segment would not leak _at all_.","format":"org.matrix.custom.html","formatted_body":"So the semantics of the initial sync segment would not leak <em>at all</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1716835786464,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$fArZbeoTIlPlfFHQ4p5iBRvUWQ2EM9ID6aLPqJaKNNQ"},
{"content":{"body":"that might work","m.mentions":{},"msgtype":"m.text"},"ts":1716835800884,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$_L5GCrFfPYjJUPX6hxD7M9qWgvovMHqsI7VB5OhrwOw"},
{"content":{"body":"We have the power to make it a lot more clear.","m.mentions":{},"msgtype":"m.text"},"ts":1716835810444,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$nB8JiTe2BkMj9AinPxx5nQnpIv83rXPpBN_149dJocI"},
{"content":{"body":"I guess it could come down to implementation complexity, because now it would no longer be a simple pointer swap","m.mentions":{},"msgtype":"m.text"},"ts":1716835847213,"senderName":"Andreu Botella","senderId":"@abotella:igalia.com","id":"$R8hwuIoLasSI4OTwkBefGK9Yquku0NOEcSoDuLqjg6Q"},
{"content":{"body":"The `enterWith(...)` only leaks because we don't have any mechanism of doing that auto-scoping.","format":"org.matrix.custom.html","formatted_body":"The <code>enterWith(...)</code> only leaks because we don't have any mechanism of doing that auto-scoping.","m.mentions":{},"msgtype":"m.text"},"ts":1716835854570,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$y64CPabl_XKpCUn2ElevbjTYMfpTGwlgdoa1e4798j8"},
{"content":{"body":"It's just userland being less powerful.","m.mentions":{},"msgtype":"m.text"},"ts":1716835872381,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$xIO1o2pRoneGtVCCD5K4QbdoTMfCXv9tvdRSm0DvIWU"},
{"content":{"body":"Well, it could still be a pointer swap, just whenever you call an async function you could just add an additional scope around that initial segment to separate out any context values set there.","m.mentions":{},"msgtype":"m.text"},"ts":1716835920202,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$LxHQ1iMcf710Y20Ro2T8qidGnKOlmGIr_iean165CTE"},
{"content":{"body":"So it'd create a new scope when starting the async function, then pointer-swap back after it returns its promise.","m.mentions":{},"msgtype":"m.text"},"ts":1716835989913,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$gq7aRDFhYK0zgVoxRhUDIL66VyQqEn4Y8PPzS0j3O5U"},
{"content":{"body":"And that first await would have linked its context to whatever the context was _inside_ that async function.","format":"org.matrix.custom.html","formatted_body":"And that first await would have linked its context to whatever the context was <em>inside</em> that async function.","m.mentions":{},"msgtype":"m.text"},"ts":1716836050123,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ARSXQ5ZRarFfE8Fa5K6JL3ZedJW0f_s7y-AVHpj-jFk"},
{"content":{"body":"The _neat_ thing though, which is partly what I'm trying to define in that context management RFC I'm working on _myself_ which I shared recently, is that if you treat async functions as just a chain of sync segments, you can apply different types of propagation semantics to each segment. The _around_ scope could link each segment _directly_, flowing context from the point an await starts to the point where it ends, giving you that lexical scope style some want for those things like signal-sharing for cancellation. And the _through_ scope would simply include the nested segment sequences in the flow chain, so context would flow out through the branches and come back out the await. You can use _the same_ scope definitions for both systems though.","format":"org.matrix.custom.html","formatted_body":"The <em>neat</em> thing though, which is partly what I'm trying to define in that context management RFC I'm working on <em>myself</em> which I shared recently, is that if you treat async functions as just a chain of sync segments, you can apply different types of propagation semantics to each segment. The <em>around</em> scope could link each segment <em>directly</em>, flowing context from the point an await starts to the point where it ends, giving you that lexical scope style some want for those things like signal-sharing for cancellation. And the <em>through</em> scope would simply include the nested segment sequences in the flow chain, so context would flow out through the branches and come back out the await. You can use <em>the same</em> scope definitions for both systems though.","m.mentions":{},"msgtype":"m.text"},"ts":1716836331574,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$jy1rYZQUEvjOWjbQ4SQRLsTx3U5FPiPmsBGfz2mTENs"}
]