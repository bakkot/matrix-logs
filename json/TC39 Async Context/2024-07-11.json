[
{"content":{"body":"> <@mcollina:matrix.org> Unfortunately that does not work to \"fix\" the use case. I don't see how you can think it would. You lose any sense of \"globality\" of the variable.\n\nBumping this - can you elaborate on what you mean by \"globality\"?  I'm clearly missing something because I don't understand what's missing with the approach of indirecting via a mutable holder object.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$cplyr04-nNnqnEdcItC3W2sYFiF3D2xOgiEpRr0KOPU?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mcollina:matrix.org\">@mcollina:matrix.org</a><br>Unfortunately that does not work to \"fix\" the use case. I don't see how you can think it would. You lose any sense of \"globality\" of the variable.</blockquote></mx-reply>Bumping this - can you elaborate on what you mean by \"globality\"?  I'm clearly missing something because I don't understand what's missing with the approach of indirecting via a mutable holder object.","m.mentions":{"user_ids":["@mcollina:matrix.org","@devsnek:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$cplyr04-nNnqnEdcItC3W2sYFiF3D2xOgiEpRr0KOPU"}},"msgtype":"m.text"},"ts":1720714301769,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$eLJn8sBoswWxGXcRbUJop6bH3El3t7kEyPdU1WsgM48"},
{"content":{"body":"> <@jridgewell:matrix.org> How would you capture it? Components return VDOM, not snapshots. Even ignoring that, the way React implements Context via special handling of the VDOM structure, it would require invoking the batched queue within new function calls, breaking the purpose of the batching code (to avoid recursion)\n\nyou could put an AsyncContext.Snapshot instance in each VDOM node, to be restored when rendering? maybe that's too expensive.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$HeTYkxpVpBmZp-O7GXN7oRkjdlW4PkgxJTsGUgIT9eQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jridgewell:matrix.org\">@jridgewell:matrix.org</a><br>How would you capture it? Components return VDOM, not snapshots. Even ignoring that, the way React implements Context via special handling of the VDOM structure, it would require invoking the batched queue within new function calls, breaking the purpose of the batching code (to avoid recursion)</blockquote></mx-reply>you could put an AsyncContext.Snapshot instance in each VDOM node, to be restored when rendering? maybe that's too expensive.","m.mentions":{"user_ids":["@jridgewell:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$HeTYkxpVpBmZp-O7GXN7oRkjdlW4PkgxJTsGUgIT9eQ"}},"msgtype":"m.text"},"ts":1720715108204,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$WhT9hlfo2sNGnfVWUSaQJmhnNM9yePOdFeZs-H0JQks"},
{"content":{"body":"For tests, as well as middleware: what if there were a context object that you could set variables on, and then when running the inner thing, you do the series of .run calls? this gives you a more ergonomic way to do what Justin suggested above.","m.mentions":{},"msgtype":"m.text"},"ts":1720715195570,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$K_Z0simEKz4tisP9F2MESfZDG8h0We89ddHbI_p7nXA"},
{"content":{"body":"```js\n const ctx = new AsyncContext.Variable();\n\n  beforeEach(() => {\n    jest.setAsyncContextVariable(ctx, 1);\n  });\n\n  it('run in snapshot', () => {\n    expect(ctx.get()).toBe(1);\n  });\n});\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\"> const ctx = new AsyncContext.Variable();\n\n  beforeEach(() =&gt; {\n    jest.setAsyncContextVariable(ctx, 1);\n  });\n\n  it('run in snapshot', () =&gt; {\n    expect(ctx.get()).toBe(1);\n  });\n});\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1720715278402,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$O4bbcqWxn3m-vqEANqyADYPCxCrILiXqV-QcuFJWCkM"},
{"content":{"body":" * ```js\ndescribe(\"asynct context\", () => {\n const ctx = new AsyncContext.Variable();\n\n  beforeEach(() => {\n    jest.setAsyncContextVariable(ctx, 1);\n  });\n\n  it('run in snapshot', () => {\n    expect(ctx.get()).toBe(1);\n  });\n});\n```","format":"org.matrix.custom.html","formatted_body":" * <pre><code class=\"language-js\">describe(\"asynct context\", () =&gt; {\n const ctx = new AsyncContext.Variable();\n\n  beforeEach(() =&gt; {\n    jest.setAsyncContextVariable(ctx, 1);\n  });\n\n  it('run in snapshot', () =&gt; {\n    expect(ctx.get()).toBe(1);\n  });\n});\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"```js\ndescribe(\"asynct context\", () => {\n const ctx = new AsyncContext.Variable();\n\n  beforeEach(() => {\n    jest.setAsyncContextVariable(ctx, 1);\n  });\n\n  it('run in snapshot', () => {\n    expect(ctx.get()).toBe(1);\n  });\n});\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">describe(\"asynct context\", () =&gt; {\n const ctx = new AsyncContext.Variable();\n\n  beforeEach(() =&gt; {\n    jest.setAsyncContextVariable(ctx, 1);\n  });\n\n  it('run in snapshot', () =&gt; {\n    expect(ctx.get()).toBe(1);\n  });\n});\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$O4bbcqWxn3m-vqEANqyADYPCxCrILiXqV-QcuFJWCkM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720715299441,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$UCQHg8vmnB9g69owrpCnhmYUHr4sen4xgCPXS4furH0"}
]