[
{"content":{"body":"Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up _a lot_. https://github.com/nodejs/node/issues/53037","format":"org.matrix.custom.html","formatted_body":"Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up <em>a lot</em>. https://github.com/nodejs/node/issues/53037","m.mentions":{},"msgtype":"m.text"},"ts":1716124051520,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$SdyIZ6r2_ihXcnzN_x41LggncfjgfchOSA519QbiKII"},
{"content":{"body":"It happens to use `enterWith(...)` rather than `run(...)`, but the confusion around expected slow is effectively the same.","format":"org.matrix.custom.html","formatted_body":"It happens to use <code>enterWith(...)</code> rather than <code>run(...)</code>, but the confusion around expected slow is effectively the same.","m.mentions":{},"msgtype":"m.text"},"ts":1716124091396,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$34T1U8SBPGAPyFFzrz_w5rghdqi09MkQ55NAmD2aB2U"},
{"content":{"body":"> <@littledan:matrix.org> Do you have an example of this sort of fix, and the costs and benefits of it, that we can look into?\n\nWe use it all over the place in the Datadog tracer, though we've been gradually migrating away to doing context recovery using TracingChannel instead as we don't break other users and tracing products that way. The cost is not really much, and like I said _will_ happen whether we provide fast-paths for it or not--you can just do `store.get()` and `store.run(...)` in a closure, but then you're making a closure and doing some extra steps which could _probably_ be more optimizable as an instance-scoped bind method of some sort.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$qxT1ATvG-m8alnqmnjnUyZAui3ogHnMpWU-CHWtNEcE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>Do you have an example of this sort of fix, and the costs and benefits of it, that we can look into?</blockquote></mx-reply>We use it all over the place in the Datadog tracer, though we've been gradually migrating away to doing context recovery using TracingChannel instead as we don't break other users and tracing products that way. The cost is not really much, and like I said <em>will</em> happen whether we provide fast-paths for it or not--you can just do <code>store.get()</code> and <code>store.run(...)</code> in a closure, but then you're making a closure and doing some extra steps which could <em>probably</em> be more optimizable as an instance-scoped bind method of some sort.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$qxT1ATvG-m8alnqmnjnUyZAui3ogHnMpWU-CHWtNEcE"}},"msgtype":"m.text"},"ts":1716125193251,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$HIqyePbFFrlTl3mRnxw020PAtyEk8QPS_w4tTBd-VB0"},
{"content":{"body":"> <@stephenhicks:matrix.org> Catching up on a lot here. I think I'm starting to come around a bit more to Stephen's perspective w.r.t. context flowing out from resolves.  I think he's right that, in general (when people do the right thing) it ends up maintaining the same root for the context tree, since the resolved promise generally comes from earlier in the same scope, and I like the fact that it aligns the opt-in for registration time with something that's actually quite reasonable to implement. I believe it's also pretty trivial to do a paranoid await-wrapping: `await bindTask(() => untrustedApi())` which would guarantee the untrustedApi can't change the context on you. Where it still feels wrong to me is Andreu's concern. The really nice property in the current proposal is that it's really well encapsulated. Context variable behave just like lexical consts, where you have guarantees that anything you can't see can never change them out from under you, and that's a _very attractive_ guarantee. Whereas the flows-out approach seems very brittle if any single bad/careless actor anywhere in your downstream call chain is able to irretrievably break the flow. I think that's where this disconnect is coming from - the encapsulation purists in the group are very hesitant to give up that guarantee.\n> \n> I wonder if there's some middle ground where you could at least detect when an abrupt context change has occurred? For instance, I could imagine something along the lines of `using _ = contextMonitor();` at the top of the function.  It could install a new variable and if it detected that the variable has changed at the end of the scope, it knows something fishy has happened. And if we're giving up the encapsulation, I suspect mutating variables with `using` might actually be reasonable as well...\n\nThe bad actor changing your value is only a problem if you explicitly give them the store and let them _do_ that. If you just keep your stores private this is not a real problem.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$qAIZmohKGuKIeQ6vuQV4CRDM72ZnJkpz76hBeQPCEvg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>Catching up on a lot here. I think I&#39;m starting to come around a bit more to Stephen&#39;s perspective w.r.t. context flowing out from resolves.  I think he&#39;s right that, in general (when people do the right thing) it ends up maintaining the same root for the context tree, since the resolved promise generally comes from earlier in the same scope, and I like the fact that it aligns the opt-in for registration time with something that&#39;s actually quite reasonable to implement. I believe it&#39;s also pretty trivial to do a paranoid await-wrapping: `await bindTask(() =&gt; untrustedApi())` which would guarantee the untrustedApi can&#39;t change the context on you. Where it still feels wrong to me is Andreu&#39;s concern. The really nice property in the current proposal is that it&#39;s really well encapsulated. Context variable behave just like lexical consts, where you have guarantees that anything you can&#39;t see can never change them out from under you, and that&#39;s a _very attractive_ guarantee. Whereas the flows-out approach seems very brittle if any single bad/careless actor anywhere in your downstream call chain is able to irretrievably break the flow. I think that&#39;s where this disconnect is coming from - the encapsulation purists in the group are very hesitant to give up that guarantee.<br/><br/>I wonder if there&#39;s some middle ground where you could at least detect when an abrupt context change has occurred? For instance, I could imagine something along the lines of `using _ = contextMonitor();` at the top of the function.  It could install a new variable and if it detected that the variable has changed at the end of the scope, it knows something fishy has happened. And if we&#39;re giving up the encapsulation, I suspect mutating variables with `using` might actually be reasonable as well...</blockquote></mx-reply>The bad actor changing your value is only a problem if you explicitly give them the store and let them <em>do</em> that. If you just keep your stores private this is not a real problem.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$qAIZmohKGuKIeQ6vuQV4CRDM72ZnJkpz76hBeQPCEvg"}},"msgtype":"m.text"},"ts":1716125322229,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$2cRrAvquMAjDmp8f8Qtw8XsCNtTKDdPBZxLsIJopl5g"},
{"content":{"body":"Also, the `using` syntax doesn't play particularly nice with async context as it not only crosses _over_ async barriers, but _also_ (as far as I'm aware) does nothing to signal any sort of change of state around awaits in its scope so if you, for example, mutate a global in whatever the `using` is doing and then expect it to restore the value when the use expires it may _also_ be required that the value is altered to match the appropriate value between async code, so I expect that is going to be a bit of a footgun when combined with async code.","format":"org.matrix.custom.html","formatted_body":"Also, the <code>using</code> syntax doesn't play particularly nice with async context as it not only crosses <em>over</em> async barriers, but <em>also</em> (as far as I'm aware) does nothing to signal any sort of change of state around awaits in its scope so if you, for example, mutate a global in whatever the <code>using</code> is doing and then expect it to restore the value when the use expires it may <em>also</em> be required that the value is altered to match the appropriate value between async code, so I expect that is going to be a bit of a footgun when combined with async code.","m.mentions":{},"msgtype":"m.text"},"ts":1716125629639,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$EixxQhofr7E8hmtsfoZsubWRlbqqYDiU6H0s2TB95mM"}
]