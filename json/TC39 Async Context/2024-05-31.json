[
{"content":{"body":"> <@stephenbelanger:matrix.org> ```js\n> // Measure request time\n> app.use(async function (ctx, next) {\n>   const start = Date.now()\n>   await next()\n> \n>   // While this happens _after_ the following middleware runs,\n>   // the store value will not be set.\n>   const id = store.get()\n>   console.log(`Request #${id} took ${Date.now() - start}ms`)\n> })\n> \n> // Store a request id value\n> let id = 0\n> app.use(async function (ctx, next) {\n>   await store.run(++id, next)\n> })\n> ```\n\nThis took me a while to understand your logic as to why this _benefits_ from flowing through, rather than the other way around. It seems strange to me that you would expect to be able to use the id produced later - if you just rearrange them, then it works with flow-around, and that's the order I'd expect them to be in.\n\nBut it seems like flow-through allows making it order-independent with a bit more care, at the cost of risking a catastrophic failure if somebody trashes your state, while flow-around insulates you from the risk (it's defensive programming by default, essentially), but then adds risk from structuring your middlewares incorrectly.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FMWw1ZTsQo7YeLNDwbhmc2MBvWTSBJw0g3a5EFKF5NQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br /><pre><code class=\"language-js\">// Measure request time\napp.use(async function (ctx, next) {\n  const start = Date.now()\n  await next()\n\n  // While this happens _after_ the following middleware runs,\n  // the store value will not be set.\n  const id = store.get()\n  console.log(`Request #${id} took ${Date.now() - start}ms`)\n})\n\n// Store a request id value\nlet id = 0\napp.use(async function (ctx, next) {\n  await store.run(++id, next)\n})\n</code></pre>\n</blockquote></mx-reply><p>This took me a while to understand your logic as to why this <em>benefits</em> from flowing through, rather than the other way around. It seems strange to me that you would expect to be able to use the id produced later - if you just rearrange them, then it works with flow-around, and that's the order I'd expect them to be in.</p>\n<p>But it seems like flow-through allows making it order-independent with a bit more care, at the cost of risking a catastrophic failure if somebody trashes your state, while flow-around insulates you from the risk (it's defensive programming by default, essentially), but then adds risk from structuring your middlewares incorrectly.</p>","m.relates_to":{"m.in_reply_to":{"event_id":"$FMWw1ZTsQo7YeLNDwbhmc2MBvWTSBJw0g3a5EFKF5NQ"}},"msgtype":"m.text"},"ts":1717172403976,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$AaEfOvLy_K83mETodH49hQq4V0i3_t53Eb3BmW8KSBw"},
{"content":{"body":"That particular case is an _obvious_ ordering problem, but when different systems are owned by different teams it's common to encounter scenarios like that where a team doesn't realize the specific implementation details of something means the data is not available where they expect it to be. With flow-through, anything that is logically _after_ should reasonably expect to receive the context from something which came before it, whereas with around flow you have to deeply understand the full structure of the application to know exactly _where_ context will reach, and refactors become problematic because if things get raised to different levels suddenly they have different contexts.\n\nAs for risk of state being trashed, I don't see how that's possible unless you go around sharing stores with untrusted users, in which case it's kind of your own fault if it gets trashed. Generally a store should be owned and managed by the same code so you always fully _know_ what's in the store. Even with around flow you can still get trashed stores if you give others access to the store as they can just `store.run(...)` _anywhere_.","format":"org.matrix.custom.html","formatted_body":"<p>That particular case is an <em>obvious</em> ordering problem, but when different systems are owned by different teams it's common to encounter scenarios like that where a team doesn't realize the specific implementation details of something means the data is not available where they expect it to be. With flow-through, anything that is logically <em>after</em> should reasonably expect to receive the context from something which came before it, whereas with around flow you have to deeply understand the full structure of the application to know exactly <em>where</em> context will reach, and refactors become problematic because if things get raised to different levels suddenly they have different contexts.</p>\n<p>As for risk of state being trashed, I don't see how that's possible unless you go around sharing stores with untrusted users, in which case it's kind of your own fault if it gets trashed. Generally a store should be owned and managed by the same code so you always fully <em>know</em> what's in the store. Even with around flow you can still get trashed stores if you give others access to the store as they can just <code>store.run(...)</code> <em>anywhere</em>.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1717175482723,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$MXZt7B_0sx0SI6AEpuqJ9boqwArAi3EbjtPl0aFPFuw"},
{"content":{"body":"To me, there's not really _any_ \"risk\" of store state being corrupted in the through flow, and on the contrary there is _lots_ of risk of it being corrupted by _around_ flow as it cuts off branches all over the place, often in places no desired by the consuming code.","format":"org.matrix.custom.html","formatted_body":"To me, there's not really <em>any</em> \"risk\" of store state being corrupted in the through flow, and on the contrary there is <em>lots</em> of risk of it being corrupted by <em>around</em> flow as it cuts off branches all over the place, often in places no desired by the consuming code.","m.mentions":{},"msgtype":"m.text"},"ts":1717175636743,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$29roxl4fBQyzITMO6ZtR2kkZakH06JFOvNaSSDNw22Q"},
{"content":{"body":" * To me, there's not really _any_ \"risk\" of store state being corrupted in the through flow, and on the contrary there is _lots_ of risk of it being corrupted by _around_ flow as it cuts off branches all over the place, often in places not desired by the consuming code.","format":"org.matrix.custom.html","formatted_body":" * To me, there's not really <em>any</em> \"risk\" of store state being corrupted in the through flow, and on the contrary there is <em>lots</em> of risk of it being corrupted by <em>around</em> flow as it cuts off branches all over the place, often in places not desired by the consuming code.","m.mentions":{},"m.new_content":{"body":"To me, there's not really _any_ \"risk\" of store state being corrupted in the through flow, and on the contrary there is _lots_ of risk of it being corrupted by _around_ flow as it cuts off branches all over the place, often in places not desired by the consuming code.","format":"org.matrix.custom.html","formatted_body":"To me, there's not really <em>any</em> \"risk\" of store state being corrupted in the through flow, and on the contrary there is <em>lots</em> of risk of it being corrupted by <em>around</em> flow as it cuts off branches all over the place, often in places not desired by the consuming code.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$29roxl4fBQyzITMO6ZtR2kkZakH06JFOvNaSSDNw22Q","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717175652359,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$s9Y_PTe-t11ygZBFc2Fa-JLH_UDFg19V5K2NayrVGWg"},
{"content":{"body":"Even for the _intended_ case of only flowing inward, it's _still_ possible to mess up the state by wrapping nested calls in additional unexpected `store.run(...)` calls, if you've passed around the store, and the global snapshot concept gives _anyone_ a bunch of power to completely destroy the state of _all_ stores by binding in strange places. I've always advocated for per-store binding with global/snapshot bind only used for _very exceptional_ cases, generally managed by the runtime or some very specific userland module cases which should be _very clearly_ communicated what the risks are to modifying the global flow graph.","format":"org.matrix.custom.html","formatted_body":"Even for the <em>intended</em> case of only flowing inward, it's <em>still</em> possible to mess up the state by wrapping nested calls in additional unexpected <code>store.run(...)</code> calls, if you've passed around the store, and the global snapshot concept gives <em>anyone</em> a bunch of power to completely destroy the state of <em>all</em> stores by binding in strange places. I've always advocated for per-store binding with global/snapshot bind only used for <em>very exceptional</em> cases, generally managed by the runtime or some very specific userland module cases which should be <em>very clearly</em> communicated what the risks are to modifying the global flow graph.","m.mentions":{},"msgtype":"m.text"},"ts":1717175848645,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$HQzI4n4GN4b0xDzvPb87K4HpzWc4XIR7s6-fmWvhNBY"},
{"content":{"body":"> <@stephenbelanger:matrix.org> To me, there's not really _any_ \"risk\" of store state being corrupted in the through flow, and on the contrary there is _lots_ of risk of it being corrupted by _around_ flow as it cuts off branches all over the place, often in places not desired by the consuming code.\n\nThe existence of global snapshotting means that (with flow-through) a subtask you call can trash your continuation context.  Flow-around insulates you from this because it guarantees that no subtask can affect your state, but at the cost of making it more expensive to extract state you actually _want_ to get out of a subtask.  Again, it's a question of intention, assumptions, and defaults.\n\nIf we get the defaults right, then it may be perfectly reasonable to say \"just don't use global snapshot\" because the defaults will make it so that nobody ever really needs to.  If we get it even slightly wrong, we risk a cargo cult developing where less-informed developers think they need to use it _everywhere_ and now you're stuck being ridiculously defensive about protecting your own context.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$29roxl4fBQyzITMO6ZtR2kkZakH06JFOvNaSSDNw22Q?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>To me, there's not really <em>any</em> \"risk\" of store state being corrupted in the through flow, and on the contrary there is <em>lots</em> of risk of it being corrupted by <em>around</em> flow as it cuts off branches all over the place, often in places not desired by the consuming code.</blockquote></mx-reply><p>The existence of global snapshotting means that (with flow-through) a subtask you call can trash your continuation context.  Flow-around insulates you from this because it guarantees that no subtask can affect your state, but at the cost of making it more expensive to extract state you actually <em>want</em> to get out of a subtask.  Again, it's a question of intention, assumptions, and defaults.</p>\n<p>If we get the defaults right, then it may be perfectly reasonable to say \"just don't use global snapshot\" because the defaults will make it so that nobody ever really needs to.  If we get it even slightly wrong, we risk a cargo cult developing where less-informed developers think they need to use it <em>everywhere</em> and now you're stuck being ridiculously defensive about protecting your own context.</p>\n","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$29roxl4fBQyzITMO6ZtR2kkZakH06JFOvNaSSDNw22Q"}},"msgtype":"m.text"},"ts":1717178840594,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$MhaSEnSgwCYa4H1q4riCpPrI5fWNumFbg_zOBID67hU"},
{"content":{"body":"It can't trash your state within local scope, but it definitely _can_ trash your state in descending contexts.","format":"org.matrix.custom.html","formatted_body":"It can't trash your state within local scope, but it definitely <em>can</em> trash your state in descending contexts.","m.mentions":{},"msgtype":"m.text"},"ts":1717178922132,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$0iHIviumuJNZtwV7A89Xq3gpgKsuxQixLWWvghUwF5s"},
{"content":{"body":"As I expressed previously, around flow is actually just through flow with some extra snapshot binds layered on top. You can interfere with it in _exactly the same ways_ when messing with global snapshots.","format":"org.matrix.custom.html","formatted_body":"As I expressed previously, around flow is actually just through flow with some extra snapshot binds layered on top. You can interfere with it in <em>exactly the same ways</em> when messing with global snapshots.","m.mentions":{},"msgtype":"m.text"},"ts":1717178987057,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$VXVEGjrlC2ygK8gUyYmDRbxuMjrt68dII8aPpte88ws"},
{"content":{"body":"All the issues you are pointing out are issues with around flow too.","m.mentions":{},"msgtype":"m.text"},"ts":1717179070015,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$H1Bu94QYa2Pfh2ntLgQrHy_NUpSCcokP9itmtAeVeOk"},
{"content":{"body":"I see descending contexts as their own responsibility.  I think this is reflecting our different perspectives.  I'm inclined to trust functions that call me (insofar as I'll assume that whatever state they give me is what they intended to, at least) more than I am to trust functions that I call.  It sounds like you're more inclined to trust the functions that you call, and less inclined to trust the functions that call you.","m.mentions":{},"msgtype":"m.text"},"ts":1717179073651,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$YMv_8F-0lm_Lv1-qXzjKWlKPQ2dpppGSLA25yoF6u-c"},
{"content":{"body":"What I'm getting at is that we seem to be looking at something from two different directions - there's a lot of analogue/duality between them, and I think if we understand the bigger picture it might lead to a unified solution that makes sense from all angles.","m.mentions":{},"msgtype":"m.text"},"ts":1717179172085,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$G1TSAvtDY8rq0Q9i8h7z-BVD5bB6SgA7EGKuFYZz3i8"},
{"content":{"body":"It's not about _trust_, it's about _expectation_. With through flow it is _expected_ that intermediate things can mutate the context if you give them access to do so. Whereas with _around_ context it's _not_ generally expected, but still possible.","format":"org.matrix.custom.html","formatted_body":"It's not about <em>trust</em>, it's about <em>expectation</em>. With through flow it is <em>expected</em> that intermediate things can mutate the context if you give them access to do so. Whereas with <em>around</em> context it's <em>not</em> generally expected, but still possible.","m.mentions":{},"msgtype":"m.text"},"ts":1717179180071,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$DWAMcvWJKvAWH9EmQLwT3vOm_wCcT-4rGHouuWzDdgI"},
{"content":{"body":"Around context is actually two separate flows, which is why it's confusing. It flows _inward_ as would be expected of context to flow to logically continuing code. But it also flows _around_ branches which orphans branches all over the place, leaving you with a whole lot of paths to nowhere. In certain flows, mainly function/recursive, the inward-only flow can make sense. But in more complex code which branches and _converges_ you get context changing unexpectedly _all over the place_ when using around flow.","format":"org.matrix.custom.html","formatted_body":"Around context is actually two separate flows, which is why it's confusing. It flows <em>inward</em> as would be expected of context to flow to logically continuing code. But it also flows <em>around</em> branches which orphans branches all over the place, leaving you with a whole lot of paths to nowhere. In certain flows, mainly function/recursive, the inward-only flow can make sense. But in more complex code which branches and <em>converges</em> you get context changing unexpectedly <em>all over the place</em> when using around flow.","m.mentions":{},"msgtype":"m.text"},"ts":1717179423992,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$wEaOB0FSilSenPUulCpmc7yoPn9vigf4vUPVjQ_QE58"},
{"content":{"body":"Essentially the context _splits_ every time an await happens, and then walks one path out to the leaf before switching back to the other half of the split when returning, so you get all this context fragmentation.","format":"org.matrix.custom.html","formatted_body":"Essentially the context <em>splits</em> every time an await happens, and then walks one path out to the leaf before switching back to the other half of the split when returning, so you get all this context fragmentation.","m.mentions":{},"msgtype":"m.text"},"ts":1717179510537,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$FDE8reNPphQKtZV-jBYQAL6F16nvF6w1ElCofC5Excw"},
{"content":{"body":"> <@stephenbelanger:matrix.org> Essentially the context _splits_ every time an await happens, and then walks one path out to the leaf before switching back to the other half of the split when returning, so you get all this context fragmentation.\n\nAn await is a merge, not a split...?  Unless you're walking backwards in time?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FDE8reNPphQKtZV-jBYQAL6F16nvF6w1ElCofC5Excw?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br>Essentially the context <em>splits</em> every time an await happens, and then walks one path out to the leaf before switching back to the other half of the split when returning, so you get all this context fragmentation.</blockquote></mx-reply>An await is a merge, not a split...?  Unless you're walking backwards in time?","m.mentions":{"user_ids":["@stephenbelanger:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$FDE8reNPphQKtZV-jBYQAL6F16nvF6w1ElCofC5Excw"}},"msgtype":"m.text"},"ts":1717179585118,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$cR2jP51P2cK8qwYeRESWdCZqO4tgtcR50XD50DLGckY"},
{"content":{"body":"I think splits (looking forward in time) comprise any sort of scheduling event - if you start an async task without awaiting it, you're _scheduling_ a continuation that splits off from the sync flow. ","format":"org.matrix.custom.html","formatted_body":"I think splits (looking forward in time) comprise any sort of scheduling event - if you start an async task without awaiting it, you're <em>scheduling</em> a continuation that splits off from the sync flow.","m.mentions":{},"msgtype":"m.text"},"ts":1717179691225,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$jJPbadEY1dDvAvhKLiPWZfHvjwlGxDgOD_IJtEIUQsk"},
{"content":{"body":"It's a split _before_ the await.","format":"org.matrix.custom.html","formatted_body":"It's a split <em>before</em> the await.","m.mentions":{},"msgtype":"m.text"},"ts":1717179694854,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$OnSChY5GRubdPM7cu7-3Rv3ou74WpDgCEWJnXU1-ysE"},
{"content":{"body":"It splits into one copy of the context flowing into the branch and a _separate_ copy capturing and restoring when the await resolves.","format":"org.matrix.custom.html","formatted_body":"It splits into one copy of the context flowing into the branch and a <em>separate</em> copy capturing and restoring when the await resolves.","m.mentions":{},"msgtype":"m.text"},"ts":1717179726112,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$E68PCtj9FGhW6Ttz2ZLwfpAqifjnouFWM8yQ1symfj8"},
{"content":{"body":"but then that scheduled task is basically a merge (possibly with a null context) to even start running its on continuation","m.mentions":{},"msgtype":"m.text"},"ts":1717179749972,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$_CSM1qUOkp0PzL56gIF34rNio1GCbN80av-mpTWE2TM"},
{"content":{"body":" * but then that scheduled task is basically a merge (possibly with a null context) to even start running its own continuation","m.mentions":{},"m.new_content":{"body":"but then that scheduled task is basically a merge (possibly with a null context) to even start running its own continuation","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_CSM1qUOkp0PzL56gIF34rNio1GCbN80av-mpTWE2TM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717179758835,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$_BOO-3xquA4vWxpfaGAxbEYAN3UoLOKnfdmqrg7C7C4"},
{"content":{"body":"Why a null context? It inherits whatever context was present when the async function was called.","m.mentions":{},"msgtype":"m.text"},"ts":1717179796928,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$72__YIZFTDX3YVNHCtXDr5XEFKQatvjJpqMYm67hqSQ"},
{"content":{"body":"fair, I was being lazy about e.g. browser events","m.mentions":{},"msgtype":"m.text"},"ts":1717179817996,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$AJEsdE9lhv5919R5vtlxuYpWuR8azrgTfqmgChiE-uU"},
{"content":{"body":"some potentially-older inherited context","m.mentions":{},"msgtype":"m.text"},"ts":1717179826890,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$8FhtUSq_IeVH7vV9Govbjn2WItMsbPQcanN3adAr9DM"},
{"content":{"body":"That inheriting is what I mean by it _splitting_ context. The context goes off down that branch and can be modified there, but what comes out the other side of the await is what was captured before it did _any_ of that, discarding the entire branch it just made and creating this pattern of continuously chopping of all branching code, which seems like a really odd thing for context to do.","format":"org.matrix.custom.html","formatted_body":"That inheriting is what I mean by it <em>splitting</em> context. The context goes off down that branch and can be modified there, but what comes out the other side of the await is what was captured before it did <em>any</em> of that, discarding the entire branch it just made and creating this pattern of continuously chopping of all branching code, which seems like a really odd thing for context to do.","m.mentions":{},"msgtype":"m.text"},"ts":1717179918637,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$YkMH8Q3o2SRxizdYWaHAoVIwrFMQIQRmK5b2EdYp56E"},
{"content":{"body":"You're coming at this from an APM perspective.  When you look at how parameters flow through function calls, this \"continuously chopping off\" is exactly what happens all the time and is perfectly expected.","m.mentions":{},"msgtype":"m.text"},"ts":1717180146001,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$v4s5h5gGkUW00cilfJiqv5oP7hoyFrooqKolZTeQRhQ"},
{"content":{"body":"Suppose you have some abstract code like so:\n\n```\nconst p = doSomethingAsync();\ndoStuffWhileWaiting();\nawait p;\n```\n\nThe question of flow-around vs flow-through seems to be entirely about whether `doSomethingAsync` or `doStuffWhileWaiting` is more important to retain after the merge.  You're worried that flow-around is pruning off the former, but what I'm not fully understanding is why the latter is less concerning to prune off?  I get that `await doSomethingAsync()` is a common pattern where `doStuffWhileWaiting` is empty, and in that case the only concern is whether or not the longer (more interesting) path might trash something.  But more generally, there's a split and a merge and we need to either pick the right context to resume after the merge, or else find some way to cast that choice such that the default is less relevant.","format":"org.matrix.custom.html","formatted_body":"<p>Suppose you have some abstract code like so:</p>\n<pre><code>const p = doSomethingAsync();\ndoStuffWhileWaiting();\nawait p;\n</code></pre>\n<p>The question of flow-around vs flow-through seems to be entirely about whether <code>doSomethingAsync</code> or <code>doStuffWhileWaiting</code> is more important to retain after the merge.  You're worried that flow-around is pruning off the former, but what I'm not fully understanding is why the latter is less concerning to prune off?  I get that <code>await doSomethingAsync()</code> is a common pattern where <code>doStuffWhileWaiting</code> is empty, and in that case the only concern is whether or not the longer (more interesting) path might trash something.  But more generally, there's a split and a merge and we need to either pick the right context to resume after the merge, or else find some way to cast that choice such that the default is less relevant.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1717180780324,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$7tGrGoiuRSoADWIX9MEaY3WYnXnDcdELok63aEsztI0"},
{"content":{"body":"I'm drawing some diagrams.  I've identified `then`, `await`, `addEventListener`, etc, as corresponding to merge points.  Instantiation of a closure seems to correspond to branch points (and note that every promise takes a closure in its ctor).  Event listeners can actually cause multiple repeated rebranches and merges - so branching is apparently N-way - basically, the vertex is the instantiation and the separate edges coming off are each individual call.  Merging tends to be 2-to-1 except for Promise.all.  I don't know how helpful this is, but looking at the different shapes for different operations in the abstract might inform something?","format":"org.matrix.custom.html","formatted_body":"I'm drawing some diagrams.  I've identified <code>then</code>, <code>await</code>, <code>addEventListener</code>, etc, as corresponding to merge points.  Instantiation of a closure seems to correspond to branch points (and note that every promise takes a closure in its ctor).  Event listeners can actually cause multiple repeated rebranches and merges - so branching is apparently N-way - basically, the vertex is the instantiation and the separate edges coming off are each individual call.  Merging tends to be 2-to-1 except for Promise.all.  I don't know how helpful this is, but looking at the different shapes for different operations in the abstract might inform something?","m.mentions":{},"msgtype":"m.text"},"ts":1717181496897,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$sM4rYqKfz9ErgVD072b8fI4e1RPl_Rf-OSb0rwN80iM"},
{"content":{"body":"> <@stephenhicks:matrix.org> You're coming at this from an APM perspective.  When you look at how parameters flow through function calls, this \"continuously chopping off\" is exactly what happens all the time and is perfectly expected.\n\nNot just APM perspective, it's also what is expected by everyone I've ever talked to using context as a request-scoped store.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$v4s5h5gGkUW00cilfJiqv5oP7hoyFrooqKolZTeQRhQ?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>You&#39;re coming at this from an APM perspective.  When you look at how parameters flow through function calls, this &quot;continuously chopping off&quot; is exactly what happens all the time and is perfectly expected.</blockquote></mx-reply>Not just APM perspective, it's also what is expected by everyone I've ever talked to using context as a request-scoped store.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$v4s5h5gGkUW00cilfJiqv5oP7hoyFrooqKolZTeQRhQ"}},"msgtype":"m.text"},"ts":1717183055076,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$WsDpm9C0y2vI9HVkgqkqYeLQ1RQwP0iOQJ-pZL2I-_U"},
{"content":{"body":"> <@stephenhicks:matrix.org> Suppose you have some abstract code like so:\n> \n> ```\n> const p = doSomethingAsync();\n> doStuffWhileWaiting();\n> await p;\n> ```\n> \n> The question of flow-around vs flow-through seems to be entirely about whether `doSomethingAsync` or `doStuffWhileWaiting` is more important to retain after the merge.  You're worried that flow-around is pruning off the former, but what I'm not fully understanding is why the latter is less concerning to prune off?  I get that `await doSomethingAsync()` is a common pattern where `doStuffWhileWaiting` is empty, and in that case the only concern is whether or not the longer (more interesting) path might trash something.  But more generally, there's a split and a merge and we need to either pick the right context to resume after the merge, or else find some way to cast that choice such that the default is less relevant.\n\n`doStuffWhileWaiting()` is sync, so it's _already done_ whatever it was going to do with the context. And even if it spins off async activity internally, it's not merging _back_ and so the following code would not be in any way a _continuation_ of that.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$7tGrGoiuRSoADWIX9MEaY3WYnXnDcdELok63aEsztI0?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br><p>Suppose you have some abstract code like so:</p>\n<pre><code>const p = doSomethingAsync();\ndoStuffWhileWaiting();\nawait p;\n</code></pre>\n<p>The question of flow-around vs flow-through seems to be entirely about whether <code>doSomethingAsync</code> or <code>doStuffWhileWaiting</code> is more important to retain after the merge.  You're worried that flow-around is pruning off the former, but what I'm not fully understanding is why the latter is less concerning to prune off?  I get that <code>await doSomethingAsync()</code> is a common pattern where <code>doStuffWhileWaiting</code> is empty, and in that case the only concern is whether or not the longer (more interesting) path might trash something.  But more generally, there's a split and a merge and we need to either pick the right context to resume after the merge, or else find some way to cast that choice such that the default is less relevant.</p>\n</blockquote></mx-reply><code>doStuffWhileWaiting()</code> is sync, so it's <em>already done</em> whatever it was going to do with the context. And even if it spins off async activity internally, it's not merging <em>back</em> and so the following code would not be in any way a <em>continuation</em> of that.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$7tGrGoiuRSoADWIX9MEaY3WYnXnDcdELok63aEsztI0"}},"msgtype":"m.text"},"ts":1717183170987,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$NTVWxg3AjVFZdRSt0mUQ7a9U_vyv-XuacsjjeSkdZdY"},
{"content":{"body":"> <@stephenhicks:matrix.org> I'm drawing some diagrams.  I've identified `then`, `await`, `addEventListener`, etc, as corresponding to merge points.  Instantiation of a closure seems to correspond to branch points (and note that every promise takes a closure in its ctor).  Event listeners can actually cause multiple repeated rebranches and merges - so branching is apparently N-way - basically, the vertex is the instantiation and the separate edges coming off are each individual call.  Merging tends to be 2-to-1 except for Promise.all.  I don't know how helpful this is, but looking at the different shapes for different operations in the abstract might inform something?\n\nNot _closures_. _Callbacks_. The promise executor is not a callback as it executes _immediately_ so is not relevant to capture and restore around that boundary. It's only relevant to capture and restore around points where execution rearrangement occurs, which is between some promise resolving and its eventually continuation running, because of the microtask queue, or some libuv-backed thing in Node.js which takes a callback, because of the event loop moving on to other things until the libuv handle signals the work is complete.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$sM4rYqKfz9ErgVD072b8fI4e1RPl_Rf-OSb0rwN80iM?via=igalia.com&via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I'm drawing some diagrams.  I've identified <code>then</code>, <code>await</code>, <code>addEventListener</code>, etc, as corresponding to merge points.  Instantiation of a closure seems to correspond to branch points (and note that every promise takes a closure in its ctor).  Event listeners can actually cause multiple repeated rebranches and merges - so branching is apparently N-way - basically, the vertex is the instantiation and the separate edges coming off are each individual call.  Merging tends to be 2-to-1 except for Promise.all.  I don't know how helpful this is, but looking at the different shapes for different operations in the abstract might inform something?</blockquote></mx-reply>Not <em>closures</em>. <em>Callbacks</em>. The promise executor is not a callback as it executes <em>immediately</em> so is not relevant to capture and restore around that boundary. It's only relevant to capture and restore around points where execution rearrangement occurs, which is between some promise resolving and its eventually continuation running, because of the microtask queue, or some libuv-backed thing in Node.js which takes a callback, because of the event loop moving on to other things until the libuv handle signals the work is complete.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$sM4rYqKfz9ErgVD072b8fI4e1RPl_Rf-OSb0rwN80iM"}},"msgtype":"m.text"},"ts":1717183367989,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$gePWO0PcWWaUB8l7PezZeambXGGihbahO2_HqNxBrco"},
{"content":{"body":"> <@stephenhicks:matrix.org> I'm drawing some diagrams.  I've identified `then`, `await`, `addEventListener`, etc, as corresponding to merge points.  Instantiation of a closure seems to correspond to branch points (and note that every promise takes a closure in its ctor).  Event listeners can actually cause multiple repeated rebranches and merges - so branching is apparently N-way - basically, the vertex is the instantiation and the separate edges coming off are each individual call.  Merging tends to be 2-to-1 except for Promise.all.  I don't know how helpful this is, but looking at the different shapes for different operations in the abstract might inform something?\n\n * Not _closures_. _Callbacks_. The promise executor is not a callback as it executes _immediately_ so is not relevant to capture and restore around that boundary. It's only relevant to capture and restore around points where execution rearrangement occurs, which is between some promise resolving and its eventual continuation running, because of the microtask queue, or some libuv-backed thing in Node.js which takes a callback, because of the event loop moving on to other things until the libuv handle signals the work is complete.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$sM4rYqKfz9ErgVD072b8fI4e1RPl_Rf-OSb0rwN80iM?via=igalia.com&amp;via=matrix.org&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@stephenhicks:matrix.org\">@stephenhicks:matrix.org</a><br>I'm drawing some diagrams.  I've identified <code>then</code>, <code>await</code>, <code>addEventListener</code>, etc, as corresponding to merge points.  Instantiation of a closure seems to correspond to branch points (and note that every promise takes a closure in its ctor).  Event listeners can actually cause multiple repeated rebranches and merges - so branching is apparently N-way - basically, the vertex is the instantiation and the separate edges coming off are each individual call.  Merging tends to be 2-to-1 except for Promise.all.  I don't know how helpful this is, but looking at the different shapes for different operations in the abstract might inform something?</blockquote></mx-reply> * Not <em>closures</em>. <em>Callbacks</em>. The promise executor is not a callback as it executes <em>immediately</em> so is not relevant to capture and restore around that boundary. It's only relevant to capture and restore around points where execution rearrangement occurs, which is between some promise resolving and its eventual continuation running, because of the microtask queue, or some libuv-backed thing in Node.js which takes a callback, because of the event loop moving on to other things until the libuv handle signals the work is complete.","m.mentions":{},"m.new_content":{"body":"Not _closures_. _Callbacks_. The promise executor is not a callback as it executes _immediately_ so is not relevant to capture and restore around that boundary. It's only relevant to capture and restore around points where execution rearrangement occurs, which is between some promise resolving and its eventual continuation running, because of the microtask queue, or some libuv-backed thing in Node.js which takes a callback, because of the event loop moving on to other things until the libuv handle signals the work is complete.","format":"org.matrix.custom.html","formatted_body":"Not <em>closures</em>. <em>Callbacks</em>. The promise executor is not a callback as it executes <em>immediately</em> so is not relevant to capture and restore around that boundary. It's only relevant to capture and restore around points where execution rearrangement occurs, which is between some promise resolving and its eventual continuation running, because of the microtask queue, or some libuv-backed thing in Node.js which takes a callback, because of the event loop moving on to other things until the libuv handle signals the work is complete.","m.mentions":{"user_ids":["@stephenhicks:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$gePWO0PcWWaUB8l7PezZeambXGGihbahO2_HqNxBrco","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717183389399,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$ruN2WIbnybhNu18cN-INSqi2VV_9nUdl9FS27I0yvdg"}
]