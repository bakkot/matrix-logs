[
{"content":{"body":"> <@stephenbelanger:matrix.org> ```js\n> // Measure request time\n> app.use(async function (ctx, next) {\n>   const start = Date.now()\n>   await next()\n> \n>   // While this happens _after_ the following middleware runs,\n>   // the store value will not be set.\n>   const id = store.get()\n>   console.log(`Request #${id} took ${Date.now() - start}ms`)\n> })\n> \n> // Store a request id value\n> let id = 0\n> app.use(async function (ctx, next) {\n>   await store.run(++id, next)\n> })\n> ```\n\nThis took me a while to understand your logic as to why this _benefits_ from flowing through, rather than the other way around. It seems strange to me that you would expect to be able to use the id produced later - if you just rearrange them, then it works with flow-around, and that's the order I'd expect them to be in.\n\nBut it seems like flow-through allows making it order-independent with a bit more care, at the cost of risking a catastrophic failure if somebody trashes your state, while flow-around insulates you from the risk (it's defensive programming by default, essentially), but then adds risk from structuring your middlewares incorrectly.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eQuZUAhGqudVFPodUG:matrix.org/$FMWw1ZTsQo7YeLNDwbhmc2MBvWTSBJw0g3a5EFKF5NQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@stephenbelanger:matrix.org\">@stephenbelanger:matrix.org</a><br /><pre><code class=\"language-js\">// Measure request time\napp.use(async function (ctx, next) {\n  const start = Date.now()\n  await next()\n\n  // While this happens _after_ the following middleware runs,\n  // the store value will not be set.\n  const id = store.get()\n  console.log(`Request #${id} took ${Date.now() - start}ms`)\n})\n\n// Store a request id value\nlet id = 0\napp.use(async function (ctx, next) {\n  await store.run(++id, next)\n})\n</code></pre>\n</blockquote></mx-reply><p>This took me a while to understand your logic as to why this <em>benefits</em> from flowing through, rather than the other way around. It seems strange to me that you would expect to be able to use the id produced later - if you just rearrange them, then it works with flow-around, and that's the order I'd expect them to be in.</p>\n<p>But it seems like flow-through allows making it order-independent with a bit more care, at the cost of risking a catastrophic failure if somebody trashes your state, while flow-around insulates you from the risk (it's defensive programming by default, essentially), but then adds risk from structuring your middlewares incorrectly.</p>","m.relates_to":{"m.in_reply_to":{"event_id":"$FMWw1ZTsQo7YeLNDwbhmc2MBvWTSBJw0g3a5EFKF5NQ"}},"msgtype":"m.text"},"ts":1717172403976,"senderName":"Steve Hicks","senderId":"@stephenhicks:matrix.org","id":"$AaEfOvLy_K83mETodH49hQq4V0i3_t53Eb3BmW8KSBw"},
{"content":{"body":"That particular case is an _obvious_ ordering problem, but when different systems are owned by different teams it's common to encounter scenarios like that where a team doesn't realize the specific implementation details of something means the data is not available where they expect it to be. With flow-through, anything that is logically _after_ should reasonably expect to receive the context from something which came before it, whereas with around flow you have to deeply understand the full structure of the application to know exactly _where_ context will reach, and refactors become problematic because if things get raised to different levels suddenly they have different contexts.\n\nAs for risk of state being trashed, I don't see how that's possible unless you go around sharing stores with untrusted users, in which case it's kind of your own fault if it gets trashed. Generally a store should be owned and managed by the same code so you always fully _know_ what's in the store. Even with around flow you can still get trashed stores if you give others access to the store as they can just `store.run(...)` _anywhere_.","format":"org.matrix.custom.html","formatted_body":"<p>That particular case is an <em>obvious</em> ordering problem, but when different systems are owned by different teams it's common to encounter scenarios like that where a team doesn't realize the specific implementation details of something means the data is not available where they expect it to be. With flow-through, anything that is logically <em>after</em> should reasonably expect to receive the context from something which came before it, whereas with around flow you have to deeply understand the full structure of the application to know exactly <em>where</em> context will reach, and refactors become problematic because if things get raised to different levels suddenly they have different contexts.</p>\n<p>As for risk of state being trashed, I don't see how that's possible unless you go around sharing stores with untrusted users, in which case it's kind of your own fault if it gets trashed. Generally a store should be owned and managed by the same code so you always fully <em>know</em> what's in the store. Even with around flow you can still get trashed stores if you give others access to the store as they can just <code>store.run(...)</code> <em>anywhere</em>.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1717175482723,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$MXZt7B_0sx0SI6AEpuqJ9boqwArAi3EbjtPl0aFPFuw"},
{"content":{"body":"To me, there's not really _any_ \"risk\" of store state being corrupted in the through flow, and on the contrary there is _lots_ of risk of it being corrupted by _around_ flow as it cuts off branches all over the place, often in places no desired by the consuming code.","format":"org.matrix.custom.html","formatted_body":"To me, there's not really <em>any</em> \"risk\" of store state being corrupted in the through flow, and on the contrary there is <em>lots</em> of risk of it being corrupted by <em>around</em> flow as it cuts off branches all over the place, often in places no desired by the consuming code.","m.mentions":{},"msgtype":"m.text"},"ts":1717175636743,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$29roxl4fBQyzITMO6ZtR2kkZakH06JFOvNaSSDNw22Q"},
{"content":{"body":" * To me, there's not really _any_ \"risk\" of store state being corrupted in the through flow, and on the contrary there is _lots_ of risk of it being corrupted by _around_ flow as it cuts off branches all over the place, often in places not desired by the consuming code.","format":"org.matrix.custom.html","formatted_body":" * To me, there's not really <em>any</em> \"risk\" of store state being corrupted in the through flow, and on the contrary there is <em>lots</em> of risk of it being corrupted by <em>around</em> flow as it cuts off branches all over the place, often in places not desired by the consuming code.","m.mentions":{},"m.new_content":{"body":"To me, there's not really _any_ \"risk\" of store state being corrupted in the through flow, and on the contrary there is _lots_ of risk of it being corrupted by _around_ flow as it cuts off branches all over the place, often in places not desired by the consuming code.","format":"org.matrix.custom.html","formatted_body":"To me, there's not really <em>any</em> \"risk\" of store state being corrupted in the through flow, and on the contrary there is <em>lots</em> of risk of it being corrupted by <em>around</em> flow as it cuts off branches all over the place, often in places not desired by the consuming code.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$29roxl4fBQyzITMO6ZtR2kkZakH06JFOvNaSSDNw22Q","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717175652359,"senderName":"Stephen Belanger","senderId":"@stephenbelanger:matrix.org","id":"$s9Y_PTe-t11ygZBFc2Fa-JLH_UDFg19V5K2NayrVGWg"}
]