[
{"content":{"body":"My apologies, I will be about 2 minutes late to the working session today","m.mentions":{},"msgtype":"m.text"},"ts":1705600789092,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1cAfeSzdphwWHOiXRxXJchbJHiCmNpmEVrMXCPkMink"},
{"content":{"body":"shu: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would just having the inherited struct just maintain the initial field layout of the base struct be sufficient?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a>: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would just having the inherited struct just maintain the initial field layout of the base struct be sufficient?","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"msgtype":"m.text"},"ts":1705604478733,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Kz5QSNaPzHEMgqPuWTEGs9MLnNYj550l7e6NouiulFg"},
{"content":{"body":" * shu: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would having the inherited struct just maintain the initial field layout of the base struct be sufficient?","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a>: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would having the inherited struct just maintain the initial field layout of the base struct be sufficient?","m.mentions":{},"m.new_content":{"body":"shu: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would having the inherited struct just maintain the initial field layout of the base struct be sufficient?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a>: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would having the inherited struct just maintain the initial field layout of the base struct be sufficient?","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Kz5QSNaPzHEMgqPuWTEGs9MLnNYj550l7e6NouiulFg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1705604492434,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$13kFRxWSxzlgrYJs621DmLkt4uhjAT4Y9ZTJgi-oCGA"},
{"content":{"body":"i think the benefit is more like \"full composability with rest of the language\", mainly","m.mentions":{},"msgtype":"m.text"},"ts":1705604584001,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$tkkZ0fbzB0EsiQ7HUfnkLTUeLMujSA043fBI3Bri020"},
{"content":{"body":"i know the field has kind of soured on inheritance hierarchies vs inline storage of stuff","m.mentions":{},"msgtype":"m.text"},"ts":1705604604790,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$dEWKDJJQ5CqZ3sEiD5rynWqu1nB9F87_5SQ9udT8IEg"},
{"content":{"body":"but for e.g. AST nodes, you probably do want an inheritance hierarchy in the \"layout prefix\" sense that i was imagining","m.mentions":{},"msgtype":"m.text"},"ts":1705604639833,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5yQDpvmxg7MpeTR9ouVSvbkOQEqrfiyEJNA3VVunk8w"},
{"content":{"body":"`AstNodeBase` has `loc` or whatever","format":"org.matrix.custom.html","formatted_body":"<code>AstNodeBase</code> has <code>loc</code> or whatever","m.mentions":{},"msgtype":"m.text"},"ts":1705604651726,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$oRv7imh3_Bx9qKsvC6FxpbiLvbVDL3K-pKrihJZf0IQ"},
{"content":{"body":"I'm more asking if there is any reason that `struct B extends A {}` needs to care about `A` other than its field layout (if you ignore TLS prototypes and constructor initialization logic)","format":"org.matrix.custom.html","formatted_body":"I'm more asking if there is any reason that <code>struct B extends A {}</code> needs to care about <code>A</code> other than its field layout (if you ignore TLS prototypes and constructor initialization logic)","m.mentions":{},"msgtype":"m.text"},"ts":1705604686753,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$k-jbO04Rhng0UBhMmjkQ6eEWPtaOObLadXlArtEK9Ww"},
{"content":{"body":"(aside from internal AST reasons)","m.mentions":{},"msgtype":"m.text"},"ts":1705604712670,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fWqh_AtEShLn0o6FoghzzA5QISRzfgpNrD6lN4I1fDI"},
{"content":{"body":"ooh","m.mentions":{},"msgtype":"m.text"},"ts":1705604739337,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$C06isxruUXtQ6d3ARRqcCvgw2TxyQDAxFW7KzCIsnQo"},
{"content":{"body":"It goes to simplifying the syntax I've been considering.","m.mentions":{},"msgtype":"m.text"},"ts":1705604739973,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PPBkH7zVyM5OwBSyFIHXngkCHQFz2NH4DKApXIQoQ0c"},
{"content":{"body":"i feel like no?","m.mentions":{},"msgtype":"m.text"},"ts":1705604750320,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$RbmzovHubYGEtfLCXfLP2QUO4ScecjCUHmXGLA6kQ2U"},
{"content":{"body":"my intention was literally for layout","m.mentions":{},"msgtype":"m.text"},"ts":1705604755197,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$3r5TIyAVfkvFeAyL8mQFvjaQe3PQ1lrKKekU7AI-9As"},
{"content":{"body":"In classes, field order is determined by calling `super()`, where each `super` constructor installs its fields and returns the thing to be the used as the `this` in the subclass constructor.","format":"org.matrix.custom.html","formatted_body":"In classes, field order is determined by calling <code>super()</code>, where each <code>super</code> constructor installs its fields and returns the thing to be the used as the <code>this</code> in the subclass constructor.","m.mentions":{},"msgtype":"m.text"},"ts":1705604803099,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nJXrhNR-MZmaVa1erKPjSp7XuioP-gGZNmzNlRIQUwA"},
{"content":{"body":"That helps","m.mentions":{},"msgtype":"m.text"},"ts":1705604813437,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$sdVeVcK3KDIkwT-Vawco3R152IQRvpSbPgdx3He5eSk"},
{"content":{"body":"what i want for struct inheritance semantics:\n\n- one shot initialization. even if we allow field initializers or user-programmable constructors, they get a fully initialized instance with all fields initialized to a sentinel (`undefined`, i guess)\n- superclass's fields precede your own fields","format":"org.matrix.custom.html","formatted_body":"<p>what i want for struct inheritance semantics:</p>\n<ul>\n<li>one shot initialization. even if we allow field initializers or user-programmable constructors, they get a fully initialized instance with all fields initialized to a sentinel (<code>undefined</code>, i guess)</li>\n<li>superclass's fields precede your own fields</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1705604915352,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$c-uniRFo-MuCtN7pQwDogzFGi4dP-SpQeowsDrrUTj8"},
{"content":{"body":"the invariant is that a half-constructed, out-of-declared-order instance is not observable if you use structs","m.mentions":{},"msgtype":"m.text"},"ts":1705604937744,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$l9KxxBpZZD5Vffmg5Ux3hZsrLH2twX6Vzan9Onz9GBE"},
{"content":{"body":"That syntax sketch I wrote up a few months back has a lot of corner cases to handle future complexity, like:\n- declaring whether a struct has a `null` prototype, or a \"shared\" prototype, or a TLS prototype.\n- declaring whether a struct field is \"non-shared\" on a shared struct (i.e., a TLS-backed field).\n- indicating whether a method is shared or non-shared, for a potential future that might somehow include shared functions.\n\nI'd like to cut a lot of that for simplicity's sake. For example, every `struct` declaration has a non-shared prototype (a TLS prototype for shared structs). You can use `extends null` if you don't need the prototype, and we can just make that work as opposed to how `class extends null` doesn't work today.","format":"org.matrix.custom.html","formatted_body":"<p>That syntax sketch I wrote up a few months back has a lot of corner cases to handle future complexity, like:</p>\n<ul>\n<li>declaring whether a struct has a <code>null</code> prototype, or a \"shared\" prototype, or a TLS prototype.</li>\n<li>declaring whether a struct field is \"non-shared\" on a shared struct (i.e., a TLS-backed field).</li>\n<li>indicating whether a method is shared or non-shared, for a potential future that might somehow include shared functions.</li>\n</ul>\n<p>I'd like to cut a lot of that for simplicity's sake. For example, every <code>struct</code> declaration has a non-shared prototype (a TLS prototype for shared structs). You can use <code>extends null</code> if you don't need the prototype, and we can just make that work as opposed to how <code>class extends null</code> doesn't work today.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1705605250604,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7ZFxCJPHRNpLRg7zDCQrY0WDnhAB3eDWcYiPdEDxW84"},
{"content":{"body":"So `shared struct A extends B {}` gives `A` a TLS prototype that inherits from `B`'s TLS prototype.","format":"org.matrix.custom.html","formatted_body":"So <code>shared struct A extends B {}</code> gives <code>A</code> a TLS prototype that inherits from <code>B</code>'s TLS prototype.","m.mentions":{},"msgtype":"m.text"},"ts":1705605293668,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ITXpmK_U-brvV0e_vTehFrFyu7ofiu5i_PXKmffbZLo"}
]