[
{"content":{"body":"rbuckton: working session call happening now if you can make it","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: working session call happening now if you can make it","msgtype":"m.text"},"ts":1637258562521,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$SvFs6lO-pooQTT9HrWm4KLCbZ7t3iWUr1AeV1bbo2J8"},
{"content":{"body":"Mathieu Hofman: so if we do allow them in weak collections, it's probably not the case that they become eternal the minute they get put in there, but that they become eternal if there is a cycle","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>: so if we do allow them in weak collections, it's probably not the case that they become eternal the minute they get put in there, but that they become eternal if there is a cycle","msgtype":"m.text"},"ts":1637263043183,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$avRZhQLVql-bzhEJG-2Vmp6t5gaf48cMKhK6_EUC4K8"},
{"content":{"body":"which is an implementation problem that i can live with, i guess","msgtype":"m.text"},"ts":1637263065535,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xYqixJuYltb8g8_2N1O0AIpuEgRGH0P2sTs0xtpDhqQ"},
{"content":{"body":"the spec can say, they are allowed in weak collections","msgtype":"m.text"},"ts":1637263072062,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$YnFXStjrG7X4GZCTIselslSc7U_30iVG_7ruRMY4_1I"},
{"content":{"body":"correct, engines could always figure out directed graph through internal weakrefs","msgtype":"m.text"},"ts":1637263079157,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$sAu13G_C20taPfPNk18Lnb6Svqz4Hz9yq9G9vr9FmZw"},
{"content":{"body":"but until XX years from now when massive rearchitecting has been undertaken, know that in practice cycles will leak","msgtype":"m.text"},"ts":1637263089299,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xrXck8vovpTlU7JfpHPZjS1tfAQfOsarLMBkAfuvywk"},
{"content":{"body":"which is still compliant, but unfortunate","msgtype":"m.text"},"ts":1637263096934,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$x43S3CqxhSMPaUaKQupuy_fXqGg7Bh-tpBKJ-GeDAvE"},
{"content":{"body":"there's no good language reason to disallow them","msgtype":"m.text"},"ts":1637263110939,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mxjJb44Gn2n-sRaDVBtYxbAsPFJOkCGSQt0KEghDd5w"},
{"content":{"body":"I just wanted to point out you were opening pandora's box","msgtype":"m.text"},"ts":1637263132442,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Z8cYB6zQzJzU1kFPwjJCG1ZSuuVwm0FF_CB2cptPL5U"},
{"content":{"body":"there is a safety aspect of disallowing shared -> unshared edges, since obviously multiple threads accessing an unshared thing can't work","msgtype":"m.text"},"ts":1637263134333,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$BJpe7ebxCX7s9WeBOcxa-OiKyqiNsMErx6KokbapTy4"},
{"content":{"body":"I've been trying to keep it closed in a few places where these things came up","msgtype":"m.text"},"ts":1637263150615,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Mfn6s1F8yCNks9VR4PL4SMp53mVc8xQ2cErNhleikSI"},
{"content":{"body":"this is not a problem for weak collections, since there's a per-thread view of the weak collection","msgtype":"m.text"},"ts":1637263152759,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$omxC5OugP51enA60o7dwVOzvfmC0oHOQGJ3LRzfy6Ss"},
{"content":{"body":"what's the pandora's box? cycles between shared and unshared?","msgtype":"m.text"},"ts":1637263163472,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$27G5Jm85CK_fBtWx2RR73J0pBiuhWsbGMUKnBDUHpHo"},
{"content":{"body":"the requirement for a distributed garbage collection","msgtype":"m.text"},"ts":1637263182145,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$3DSGMV2AsK3UxhAko-_Rk53DHjkI-aHZWA5VSsF_4hg"},
{"content":{"body":"ah, i see","msgtype":"m.text"},"ts":1637263191024,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$0_Gb0qneF1VQSOFglszoMYhLhj43O5mEw3ug0kZS9kE"},
{"content":{"body":"yes, indeed, it is inherent in a shared memory proposal to open that pandora's box","msgtype":"m.text"},"ts":1637263206268,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VghwIBs-l9FbHClvxvDNBsIl2kri68g1ESH-n67F4RE"},
{"content":{"body":"much of the work internally i've been doing before proposing this in public is to get a roadmap worked out for GC evolution to support a shared memory future","msgtype":"m.text"},"ts":1637263225698,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$MGSljXt0OURou5aAibUk5sfL5qHAfD_FmGb1w_nD4RU"},
{"content":{"body":"and it sounds like at least V8 and JSC are converging on what to do","msgtype":"m.text"},"ts":1637263233458,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$dMwCuAMNjAVU0ujAqSfZAHjWyU5k4E3wTiFZEiob7IY"},
{"content":{"body":"well SharedArrayBuffer avoided that bullet with unstable identities between agents","msgtype":"m.text"},"ts":1637263235075,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$W7nfYYHLi0B1y8rfCHsLFYTO5cueZUYcUGx1V5gTC0c"},
{"content":{"body":"correct","msgtype":"m.text"},"ts":1637263240801,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$AnYu2cb8MXGAMAulx0UrLahIOkPYbUI-8SFbj1xOoqA"},
{"content":{"body":"but it's also a \"solved\" problem in the literature, at least","msgtype":"m.text"},"ts":1637263254568,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$WR2CWV4DYhVWaH4ue_rBLOyNjAhh92EJ2J9r-8G_AVE"},
{"content":{"body":"there are plenty of GCed languages with shared memory","msgtype":"m.text"},"ts":1637263262921,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$DkIxpLPuF2fGjTSq_LTcqbolPRKEVrfiPtd6XaKa_D8"},
{"content":{"body":"it's solved if you have a single GC, nothing is published for cooperative distributed gc","msgtype":"m.text"},"ts":1637263299604,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$btH9ZBoMcpK6EjimgFBS3eF_xHj0U0E5X2DARWvZhco"},
{"content":{"body":"i guess i don't know what you mean by distributed","msgtype":"m.text"},"ts":1637263315710,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$o3kpLiYvDlYtkzSScOjiJkcH8tyGKZc0u3dSCG_l--I"},
{"content":{"body":"independently collected heaps that point to each other?","msgtype":"m.text"},"ts":1637263324184,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Zb0eryvn4OsrClLU9DTPCuFiEe2XwJj_uEYrUKilLEg"},
{"content":{"body":"multiple local GCs coordinating to identify and prune distributed cycles","msgtype":"m.text"},"ts":1637263348793,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$UBwtt1hHj9gLVB_L-NNFAfo2fGlNOIQ89FkmodN7oBU"},
{"content":{"body":"ah i see","msgtype":"m.text"},"ts":1637263357738,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5P8dcqJRJXRPMfbKfxygMWcj7smvCOBINxsKDgtIkhA"},
{"content":{"body":"but that implementation is not a requirement","msgtype":"m.text"},"ts":1637263369652,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$stJhZk2GPwpvZbInwIM4-RGN0Z_swCsMI6zsDlRK8IA"},
{"content":{"body":"the prevailing wisdom seems to be to do a single marking phase across all threads","msgtype":"m.text"},"ts":1637263402610,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9HIiABiVQFBATCSoY_6ODtnwOd_CJywUKAh-N-qWxTU"},
{"content":{"body":"I do have a proposal to solve that, but as you mentioned, the motivation is probably not going to be Web user agents","msgtype":"m.text"},"ts":1637263412718,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$blCP76MP4rckzWThqSi5fY34MqHUPCdrvPSlwsIN1Vo"},
{"content":{"body":"I am skeptical however that all engines will be on board with a requirement for a single gc per agent cluster. As you mentioned, afaik it requires a stop the world that is proportional to the amount of threads","msgtype":"m.text"},"ts":1637263509559,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YZh2ORGwzcMY3nNTBjX-N_13v8RcrAjfKSoXHwSZsNo"},
{"content":{"body":"only if you want to handle cycles","msgtype":"m.text"},"ts":1637263528330,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ziyQmDj5o3JxHOK52SqaITFsRBjV0qttqhgYmzdrjd8"},
{"content":{"body":"of course","msgtype":"m.text"},"ts":1637263557214,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$-hXMlk_2tUzM4dvpxMrPCjkDml5ltYavtWVBc9-igJM"},
{"content":{"body":"even with a naive STW, if you remember all ephemeron edges, can't you still collect the cycles without having to mark all local threads?","msgtype":"m.text"},"ts":1637263652752,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5SuBDTaUt5a7_lyrPYL6cfHUEDxasfE8rhZyAIwuZ1w"},
{"content":{"body":"remember all ephemeron edges in which a shared struct participates, that is","msgtype":"m.text"},"ts":1637263747537,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$YYIliFBBbyxY8rp7S5DQYmtAKeMQTSqC_ZN4Jyvh98c"},
{"content":{"body":"local GCs defer sweeping local objects in an ephemeron edge with a shared object until the shared GC happens","msgtype":"m.text"},"ts":1637263772980,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$U9WUbLKs8O5pTR3rkzyPT6ckVdtD8KM6GAQIQi59F_A"},
{"content":{"body":"when the shared GC happens, process shared ephemeron edges","msgtype":"m.text"},"ts":1637263788470,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$e8JZ1Go414453by5mZrqP8YGQ814bNYOGgr8ULyEayk"},
{"content":{"body":"right, you're basically getting into collaborative gc territory ;) Being able to trace exits to other gc from a local ephemeron is basically the crux of my idea","msgtype":"m.text"},"ts":1637263859509,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$qfnkMgtxKPnTdwQxiAM7QNU5yc5zm_uxBElqvx7xPAk"},
{"content":{"body":"ah okay, cool","msgtype":"m.text"},"ts":1637263868638,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ZuVk1d12seFAUDSxYIDaLMsJIIFC0SZpcsabkFil-Vg"},
{"content":{"body":"i'm just thinking out loud that there might be a \"good enough\" implementation strategy that we can implement in the meantime","msgtype":"m.text"},"ts":1637263881075,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$PxFDJvmPEmrW07_JR7GXC6OK8mVlluRI-GOcsOrlBmc"},
{"content":{"body":"as a 3rd phase style","msgtype":"m.text"},"ts":1637263882169,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$h2AYR7oOtOB-A9FxDo7KJAVzIt0brd2hiU-tNOa8kUY"},
{"content":{"body":"without a huge performance cliff","msgtype":"m.text"},"ts":1637263883997,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mTA_94GvH36PpV56kjKvBcCF1CLsWHeeX4mLe_0Uxo0"},
{"content":{"body":"until we get a shared heap architecture","msgtype":"m.text"},"ts":1637263893572,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cx9YYnBhGoeMNH_lk1ku3oF9tH7IkFGZr6SyLneFpII"},
{"content":{"body":"And introducing a reification of that mechanism is what my proposal hoped to accomplish. I just haven't had time to work on it in the past couple years","msgtype":"m.text"},"ts":1637263944199,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CKJhbt1t3vdwJ7sDaD9i4fL9xGJ8d1cJVFIs3p72VJY"},
{"content":{"body":"so i'm cautiously optimistically now changing my position to: we'll allow these in WeakCollections, and we can probably implement it, but it'll likely be not as fast as you'd like and you'll incur some GC pause penalty if you heavily use shared structs in WeakMaps","msgtype":"m.text"},"ts":1637263958156,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5JqeBv2UFFLv78m-exExZ9QxcaKMlHpuNGAN5nvtHmw"},
{"content":{"body":"but the GC pause penalty won't be catastrophic","msgtype":"m.text"},"ts":1637263976712,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$dPX5ggwzIhT43XBIHj3hjmnyEQ1OcDR_Q83wOe-dRfo"},
{"content":{"body":"(i'm cautiously optimistic because the ephemeron collection is already a separate phase and already complicated, so why not tack on more? :P)","msgtype":"m.text"},"ts":1637264001070,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$lq3d0scFSyfAgsLqRyN4VschBuYzIDrp5d10EKoLo9Q"},
{"content":{"body":"yeah the drawback is that it might take a much longer time to figure out distributed cycles, but the pause can be made so that it's not worse than a regular local gc","msgtype":"m.text"},"ts":1637264021781,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$h455NoOK5v9hv6ThRvEVtJrJhP8CLndf21racwUGfR4"},
{"content":{"body":"right, it'll definitely take longer for shared structs to get collected from weak collections","msgtype":"m.text"},"ts":1637264041773,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$WnPyI4K0XRjNd7-qQ1x4GET_6gBDQyQdM0-55BWpHh4"},
{"content":{"body":"because shared structs will be collected at a lower frequency, period, until rearchitected to a single heap","msgtype":"m.text"},"ts":1637264055615,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LEyraLc_-6e0aj-xKBF2xjqUJxpVem7sCeW4avFcsjw"},
{"content":{"body":"but this matches well with my intuition that JS is still staunchly \"single-threaded first\", and we're carving out multithreading here as explicit opt-ins with its own caveats","msgtype":"m.text"},"ts":1637264098109,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$jZscQfPpwfYY0IghXxCbzLfCywXm5E-p0VDOUKbdUHk"},
{"content":{"body":"i want it to be possible, but i recognize that to have it be _good_ from a PL perspective is not realistically attainable IMO","format":"org.matrix.custom.html","formatted_body":"i want it to be possible, but i recognize that to have it be <em>good</em> from a PL perspective is not realistically attainable IMO","msgtype":"m.text"},"ts":1637264117512,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$A-WhR91jOkfQ7p-5dYa-ebKuqx81O2FF2j3eZQz_Z3s"},
{"content":{"body":"the use case pressure is just too great to not solve it, however","msgtype":"m.text"},"ts":1637264131492,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$qlRF8EMUz_qnLyxTqQ3gmnUBBSwiNbd1qpENQKDEN9w"},
{"content":{"body":"gotta run, but fascinating chat","msgtype":"m.text"},"ts":1637264245321,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9On2oerJnZ2lVyv9TNp_Oc_d7knmTkvVhWADwmCitmI"},
{"content":{"body":"btw, here is a thought. The identity of the shared struct is not directly observable by programs between agents, the only thing that is observable is that when sending a shared struct back and forth between agents, you get the same local identity. The same object wrappers could be an implementation optimization.\n\nOnce you've done that, you could design it so that a shared struct have their methods declared in a module block, which is automatically loaded once per realm where the shared struct is used. Those methods from the module instance define the \"prototype\" object of the shared struct in that realm. Now the optimization is that in practice you don't have a different wrapper object per realm, and you have a dynamic prototype look up that takes into consideration the calling realm.","msgtype":"m.text"},"ts":1637264544818,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$u-N2JGH5MtL0nlLopjJy1nuNothMM6is4QOtztTRG9c"},
{"content":{"body":"Btw, since JS doesn't specify the mechanism how these wrappers are shared between agents, the only thing ecam262 needs to say nothing, aka these objects don't need any more mechanisms than e.g. SharedArrayBuffer","msgtype":"m.text"},"ts":1637264653355,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$rjDQC9vuUWwjZKQHDmkO1meLBrs9BXKD15edAJb6QZo"},
{"content":{"body":" * Btw, since JS doesn't specify the mechanism how these wrappers are shared between agents, the only thing ecam262 needs to say nothing, aka these objects don't need any more mechanisms than e.g. SharedArrayBuffer","m.new_content":{"body":"Btw, since JS doesn't specify the mechanism how these wrappers are shared between agents, the only thing ecam262 needs to say nothing, aka these objects don't need any more mechanisms than e.g. SharedArrayBuffer","msgtype":"m.text"},"m.relates_to":{"event_id":"$rjDQC9vuUWwjZKQHDmkO1meLBrs9BXKD15edAJb6QZo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1637264673942,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$zvhgz-AP4NQqfUyGPlF5SL8wUitPonY8qhRqQufXFGE"},
{"content":{"body":"The modulo here is legacy realms (as always). ShadowRealms can have the same dynamic dispatch mechanism since object graphs are not entangled","msgtype":"m.text"},"ts":1637264796094,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$2r7Tqd9iLZuDBq3EG7wUNvYS0hnF96aRz12HV_MmDOg"},
{"content":{"body":"it is a nonstarter to implement it with wrappers","msgtype":"m.text"},"ts":1637266747137,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VdTibiSECygNG2NnQ2a3jGuPGgL79IBiarO7n7Vm6-U"},
{"content":{"body":"i'm not sure what that spec fiction buys us","msgtype":"m.text"},"ts":1637266756484,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$n72NtsEmQfdZWtAc1JZk5JPbNjpUTuljvPSZJrTsRdk"}
]