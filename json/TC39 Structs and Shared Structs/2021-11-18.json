[
{"content":{"body":"rbuckton: working session call happening now if you can make it","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: working session call happening now if you can make it","msgtype":"m.text"},"ts":1637258562521,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$SvFs6lO-pooQTT9HrWm4KLCbZ7t3iWUr1AeV1bbo2J8"},
{"content":{"body":"Mathieu Hofman: so if we do allow them in weak collections, it's probably not the case that they become eternal the minute they get put in there, but that they become eternal if there is a cycle","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>: so if we do allow them in weak collections, it's probably not the case that they become eternal the minute they get put in there, but that they become eternal if there is a cycle","msgtype":"m.text"},"ts":1637263043183,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$avRZhQLVql-bzhEJG-2Vmp6t5gaf48cMKhK6_EUC4K8"},
{"content":{"body":"which is an implementation problem that i can live with, i guess","msgtype":"m.text"},"ts":1637263065535,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xYqixJuYltb8g8_2N1O0AIpuEgRGH0P2sTs0xtpDhqQ"},
{"content":{"body":"the spec can say, they are allowed in weak collections","msgtype":"m.text"},"ts":1637263072062,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$YnFXStjrG7X4GZCTIselslSc7U_30iVG_7ruRMY4_1I"},
{"content":{"body":"correct, engines could always figure out directed graph through internal weakrefs","msgtype":"m.text"},"ts":1637263079157,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$sAu13G_C20taPfPNk18Lnb6Svqz4Hz9yq9G9vr9FmZw"},
{"content":{"body":"but until XX years from now when massive rearchitecting has been undertaken, know that in practice cycles will leak","msgtype":"m.text"},"ts":1637263089299,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xrXck8vovpTlU7JfpHPZjS1tfAQfOsarLMBkAfuvywk"},
{"content":{"body":"which is still compliant, but unfortunate","msgtype":"m.text"},"ts":1637263096934,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$x43S3CqxhSMPaUaKQupuy_fXqGg7Bh-tpBKJ-GeDAvE"},
{"content":{"body":"there's no good language reason to disallow them","msgtype":"m.text"},"ts":1637263110939,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mxjJb44Gn2n-sRaDVBtYxbAsPFJOkCGSQt0KEghDd5w"},
{"content":{"body":"I just wanted to point out you were opening pandora's box","msgtype":"m.text"},"ts":1637263132442,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Z8cYB6zQzJzU1kFPwjJCG1ZSuuVwm0FF_CB2cptPL5U"},
{"content":{"body":"there is a safety aspect of disallowing shared -> unshared edges, since obviously multiple threads accessing an unshared thing can't work","msgtype":"m.text"},"ts":1637263134333,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$BJpe7ebxCX7s9WeBOcxa-OiKyqiNsMErx6KokbapTy4"},
{"content":{"body":"I've been trying to keep it closed in a few places where these things came up","msgtype":"m.text"},"ts":1637263150615,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Mfn6s1F8yCNks9VR4PL4SMp53mVc8xQ2cErNhleikSI"},
{"content":{"body":"this is not a problem for weak collections, since there's a per-thread view of the weak collection","msgtype":"m.text"},"ts":1637263152759,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$omxC5OugP51enA60o7dwVOzvfmC0oHOQGJ3LRzfy6Ss"},
{"content":{"body":"what's the pandora's box? cycles between shared and unshared?","msgtype":"m.text"},"ts":1637263163472,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$27G5Jm85CK_fBtWx2RR73J0pBiuhWsbGMUKnBDUHpHo"},
{"content":{"body":"the requirement for a distributed garbage collection","msgtype":"m.text"},"ts":1637263182145,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$3DSGMV2AsK3UxhAko-_Rk53DHjkI-aHZWA5VSsF_4hg"},
{"content":{"body":"ah, i see","msgtype":"m.text"},"ts":1637263191024,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$0_Gb0qneF1VQSOFglszoMYhLhj43O5mEw3ug0kZS9kE"},
{"content":{"body":"yes, indeed, it is inherent in a shared memory proposal to open that pandora's box","msgtype":"m.text"},"ts":1637263206268,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VghwIBs-l9FbHClvxvDNBsIl2kri68g1ESH-n67F4RE"},
{"content":{"body":"much of the work internally i've been doing before proposing this in public is to get a roadmap worked out for GC evolution to support a shared memory future","msgtype":"m.text"},"ts":1637263225698,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$MGSljXt0OURou5aAibUk5sfL5qHAfD_FmGb1w_nD4RU"},
{"content":{"body":"and it sounds like at least V8 and JSC are converging on what to do","msgtype":"m.text"},"ts":1637263233458,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$dMwCuAMNjAVU0ujAqSfZAHjWyU5k4E3wTiFZEiob7IY"},
{"content":{"body":"well SharedArrayBuffer avoided that bullet with unstable identities between agents","msgtype":"m.text"},"ts":1637263235075,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$W7nfYYHLi0B1y8rfCHsLFYTO5cueZUYcUGx1V5gTC0c"},
{"content":{"body":"correct","msgtype":"m.text"},"ts":1637263240801,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$AnYu2cb8MXGAMAulx0UrLahIOkPYbUI-8SFbj1xOoqA"},
{"content":{"body":"but it's also a \"solved\" problem in the literature, at least","msgtype":"m.text"},"ts":1637263254568,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$WR2CWV4DYhVWaH4ue_rBLOyNjAhh92EJ2J9r-8G_AVE"},
{"content":{"body":"there are plenty of GCed languages with shared memory","msgtype":"m.text"},"ts":1637263262921,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$DkIxpLPuF2fGjTSq_LTcqbolPRKEVrfiPtd6XaKa_D8"},
{"content":{"body":"it's solved if you have a single GC, nothing is published for cooperative distributed gc","msgtype":"m.text"},"ts":1637263299604,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$btH9ZBoMcpK6EjimgFBS3eF_xHj0U0E5X2DARWvZhco"},
{"content":{"body":"i guess i don't know what you mean by distributed","msgtype":"m.text"},"ts":1637263315710,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$o3kpLiYvDlYtkzSScOjiJkcH8tyGKZc0u3dSCG_l--I"},
{"content":{"body":"independently collected heaps that point to each other?","msgtype":"m.text"},"ts":1637263324184,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Zb0eryvn4OsrClLU9DTPCuFiEe2XwJj_uEYrUKilLEg"},
{"content":{"body":"multiple local GCs coordinating to identify and prune distributed cycles","msgtype":"m.text"},"ts":1637263348793,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$UBwtt1hHj9gLVB_L-NNFAfo2fGlNOIQ89FkmodN7oBU"},
{"content":{"body":"ah i see","msgtype":"m.text"},"ts":1637263357738,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5P8dcqJRJXRPMfbKfxygMWcj7smvCOBINxsKDgtIkhA"},
{"content":{"body":"but that implementation is not a requirement","msgtype":"m.text"},"ts":1637263369652,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$stJhZk2GPwpvZbInwIM4-RGN0Z_swCsMI6zsDlRK8IA"},
{"content":{"body":"the prevailing wisdom seems to be to do a single marking phase across all threads","msgtype":"m.text"},"ts":1637263402610,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9HIiABiVQFBATCSoY_6ODtnwOd_CJywUKAh-N-qWxTU"},
{"content":{"body":"I do have a proposal to solve that, but as you mentioned, the motivation is probably not going to be Web user agents","msgtype":"m.text"},"ts":1637263412718,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$blCP76MP4rckzWThqSi5fY34MqHUPCdrvPSlwsIN1Vo"},
{"content":{"body":"I am skeptical however that all engines will be on board with a requirement for a single gc per agent cluster. As you mentioned, afaik it requires a stop the world that is proportional to the amount of threads","msgtype":"m.text"},"ts":1637263509559,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YZh2ORGwzcMY3nNTBjX-N_13v8RcrAjfKSoXHwSZsNo"},
{"content":{"body":"only if you want to handle cycles","msgtype":"m.text"},"ts":1637263528330,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ziyQmDj5o3JxHOK52SqaITFsRBjV0qttqhgYmzdrjd8"},
{"content":{"body":"of course","msgtype":"m.text"},"ts":1637263557214,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$-hXMlk_2tUzM4dvpxMrPCjkDml5ltYavtWVBc9-igJM"},
{"content":{"body":"even with a naive STW, if you remember all ephemeron edges, can't you still collect the cycles without having to mark all local threads?","msgtype":"m.text"},"ts":1637263652752,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5SuBDTaUt5a7_lyrPYL6cfHUEDxasfE8rhZyAIwuZ1w"},
{"content":{"body":"remember all ephemeron edges in which a shared struct participates, that is","msgtype":"m.text"},"ts":1637263747537,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$YYIliFBBbyxY8rp7S5DQYmtAKeMQTSqC_ZN4Jyvh98c"},
{"content":{"body":"local GCs defer sweeping local objects in an ephemeron edge with a shared object until the shared GC happens","msgtype":"m.text"},"ts":1637263772980,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$U9WUbLKs8O5pTR3rkzyPT6ckVdtD8KM6GAQIQi59F_A"},
{"content":{"body":"when the shared GC happens, process shared ephemeron edges","msgtype":"m.text"},"ts":1637263788470,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$e8JZ1Go414453by5mZrqP8YGQ814bNYOGgr8ULyEayk"},
{"content":{"body":"right, you're basically getting into collaborative gc territory ;) Being able to trace exits to other gc from a local ephemeron is basically the crux of my idea","msgtype":"m.text"},"ts":1637263859509,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$qfnkMgtxKPnTdwQxiAM7QNU5yc5zm_uxBElqvx7xPAk"},
{"content":{"body":"ah okay, cool","msgtype":"m.text"},"ts":1637263868638,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ZuVk1d12seFAUDSxYIDaLMsJIIFC0SZpcsabkFil-Vg"},
{"content":{"body":"i'm just thinking out loud that there might be a \"good enough\" implementation strategy that we can implement in the meantime","msgtype":"m.text"},"ts":1637263881075,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$PxFDJvmPEmrW07_JR7GXC6OK8mVlluRI-GOcsOrlBmc"},
{"content":{"body":"as a 3rd phase style","msgtype":"m.text"},"ts":1637263882169,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$h2AYR7oOtOB-A9FxDo7KJAVzIt0brd2hiU-tNOa8kUY"},
{"content":{"body":"without a huge performance cliff","msgtype":"m.text"},"ts":1637263883997,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mTA_94GvH36PpV56kjKvBcCF1CLsWHeeX4mLe_0Uxo0"},
{"content":{"body":"until we get a shared heap architecture","msgtype":"m.text"},"ts":1637263893572,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cx9YYnBhGoeMNH_lk1ku3oF9tH7IkFGZr6SyLneFpII"},
{"content":{"body":"And introducing a reification of that mechanism is what my proposal hoped to accomplish. I just haven't had time to work on it in the past couple years","msgtype":"m.text"},"ts":1637263944199,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CKJhbt1t3vdwJ7sDaD9i4fL9xGJ8d1cJVFIs3p72VJY"},
{"content":{"body":"so i'm cautiously optimistically now changing my position to: we'll allow these in WeakCollections, and we can probably implement it, but it'll likely be not as fast as you'd like and you'll incur some GC pause penalty if you heavily use shared structs in WeakMaps","msgtype":"m.text"},"ts":1637263958156,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5JqeBv2UFFLv78m-exExZ9QxcaKMlHpuNGAN5nvtHmw"},
{"content":{"body":"but the GC pause penalty won't be catastrophic","msgtype":"m.text"},"ts":1637263976712,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$dPX5ggwzIhT43XBIHj3hjmnyEQ1OcDR_Q83wOe-dRfo"},
{"content":{"body":"(i'm cautiously optimistic because the ephemeron collection is already a separate phase and already complicated, so why not tack on more? :P)","msgtype":"m.text"},"ts":1637264001070,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$lq3d0scFSyfAgsLqRyN4VschBuYzIDrp5d10EKoLo9Q"},
{"content":{"body":"yeah the drawback is that it might take a much longer time to figure out distributed cycles, but the pause can be made so that it's not worse than a regular local gc","msgtype":"m.text"},"ts":1637264021781,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$h455NoOK5v9hv6ThRvEVtJrJhP8CLndf21racwUGfR4"},
{"content":{"body":"right, it'll definitely take longer for shared structs to get collected from weak collections","msgtype":"m.text"},"ts":1637264041773,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$WnPyI4K0XRjNd7-qQ1x4GET_6gBDQyQdM0-55BWpHh4"},
{"content":{"body":"because shared structs will be collected at a lower frequency, period, until rearchitected to a single heap","msgtype":"m.text"},"ts":1637264055615,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LEyraLc_-6e0aj-xKBF2xjqUJxpVem7sCeW4avFcsjw"},
{"content":{"body":"but this matches well with my intuition that JS is still staunchly \"single-threaded first\", and we're carving out multithreading here as explicit opt-ins with its own caveats","msgtype":"m.text"},"ts":1637264098109,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$jZscQfPpwfYY0IghXxCbzLfCywXm5E-p0VDOUKbdUHk"},
{"content":{"body":"i want it to be possible, but i recognize that to have it be _good_ from a PL perspective is not realistically attainable IMO","format":"org.matrix.custom.html","formatted_body":"i want it to be possible, but i recognize that to have it be <em>good</em> from a PL perspective is not realistically attainable IMO","msgtype":"m.text"},"ts":1637264117512,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$A-WhR91jOkfQ7p-5dYa-ebKuqx81O2FF2j3eZQz_Z3s"},
{"content":{"body":"the use case pressure is just too great to not solve it, however","msgtype":"m.text"},"ts":1637264131492,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$qlRF8EMUz_qnLyxTqQ3gmnUBBSwiNbd1qpENQKDEN9w"},
{"content":{"body":"gotta run, but fascinating chat","msgtype":"m.text"},"ts":1637264245321,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9On2oerJnZ2lVyv9TNp_Oc_d7knmTkvVhWADwmCitmI"},
{"content":{"body":"btw, here is a thought. The identity of the shared struct is not directly observable by programs between agents, the only thing that is observable is that when sending a shared struct back and forth between agents, you get the same local identity. The same object wrappers could be an implementation optimization.\n\nOnce you've done that, you could design it so that a shared struct have their methods declared in a module block, which is automatically loaded once per realm where the shared struct is used. Those methods from the module instance define the \"prototype\" object of the shared struct in that realm. Now the optimization is that in practice you don't have a different wrapper object per realm, and you have a dynamic prototype look up that takes into consideration the calling realm.","msgtype":"m.text"},"ts":1637264544818,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$u-N2JGH5MtL0nlLopjJy1nuNothMM6is4QOtztTRG9c"},
{"content":{"body":"Btw, since JS doesn't specify the mechanism how these wrappers are shared between agents, the only thing ecam262 needs to say nothing, aka these objects don't need any more mechanisms than e.g. SharedArrayBuffer","msgtype":"m.text"},"ts":1637264653355,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$rjDQC9vuUWwjZKQHDmkO1meLBrs9BXKD15edAJb6QZo"},
{"content":{"body":" * Btw, since JS doesn't specify the mechanism how these wrappers are shared between agents, the only thing ecam262 needs to say nothing, aka these objects don't need any more mechanisms than e.g. SharedArrayBuffer","m.new_content":{"body":"Btw, since JS doesn't specify the mechanism how these wrappers are shared between agents, the only thing ecam262 needs to say nothing, aka these objects don't need any more mechanisms than e.g. SharedArrayBuffer","msgtype":"m.text"},"m.relates_to":{"event_id":"$rjDQC9vuUWwjZKQHDmkO1meLBrs9BXKD15edAJb6QZo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1637264673942,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$zvhgz-AP4NQqfUyGPlF5SL8wUitPonY8qhRqQufXFGE"},
{"content":{"body":"The modulo here is legacy realms (as always). ShadowRealms can have the same dynamic dispatch mechanism since object graphs are not entangled","msgtype":"m.text"},"ts":1637264796094,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$2r7Tqd9iLZuDBq3EG7wUNvYS0hnF96aRz12HV_MmDOg"},
{"content":{"body":"it is a nonstarter to implement it with wrappers","msgtype":"m.text"},"ts":1637266747137,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VdTibiSECygNG2NnQ2a3jGuPGgL79IBiarO7n7Vm6-U"},
{"content":{"body":"i'm not sure what that spec fiction buys us","msgtype":"m.text"},"ts":1637266756484,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$n72NtsEmQfdZWtAc1JZk5JPbNjpUTuljvPSZJrTsRdk"},
{"content":{"body":"the automatic loading thing worries me -- i'd rather there be no magic with module blocks, but that they be a pure workaround without extra mechanism","msgtype":"m.text"},"ts":1637266804718,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$r9RulYpauxV_BNwh8VjDp76cTM8mgodU6wv-PlXLLL0"},
{"content":{"body":"sure pure functions would be great. You might want to chat with the Moddable folks about their idea on that","msgtype":"m.text"},"ts":1637266861951,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$K4yUtXcgxD5jRxc0n6FHGYe8iTveHW-yxY5vDgBYxO8"},
{"content":{"body":"i didn't mean \"pure\" in that sense","msgtype":"m.text"},"ts":1637266873386,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Ax4yZjg2aYrcCjNku-THsxDIzDrDjOI0JhHqZ3QWtUY"},
{"content":{"body":"i meant pure as in module blocks do not have extra mechanism to interact with shared structs","msgtype":"m.text"},"ts":1637266887610,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$bSeQK2ketg9Q4HLpUyoikez5hgzOqg1xsjFjWxxG7vI"},
{"content":{"body":"i suppose i object more to a dynamic per-realm prototype lookup than the automatic loading","msgtype":"m.text"},"ts":1637266983259,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$vkF-09s3g0UmRWhvpUU7ElcAZYIK8SSr7ZlP3w4J_II"},
{"content":{"body":"So the loading could be part of the out of scope mechanism that introduces the shared struct to the realm. And the spec fiction allows you to pretend there is no realm sensitive resolution of the prototype object","msgtype":"m.text"},"ts":1637266985275,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$j7FnYPj5k59tPr_Apz1W94ghclbCdPZQQ8JQVPDG0Vc"},
{"content":{"body":"ah i see what you're getting at for introducing the definition","msgtype":"m.text"},"ts":1637267047331,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cSBPP9zWfYTMhb2_X_7dV2ZUYi9caj-HWETY9U1WHNg"},
{"content":{"body":"how does that idea work if i send a struct instance to a realm that didn't load the module block that defines it?","msgtype":"m.text"},"ts":1637267123239,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ao0s_r4li27JO89ki3GE51zDDWqBUqzATk_ktAkFbJk"},
{"content":{"body":"(implementation wise i'm not sure how the dynamic prototype lookup can be efficient implemented either)","msgtype":"m.text"},"ts":1637267161595,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$_lgomrIkpgFGPrlOERtX9NtN_rI7hfmkVxd3zc1TYSE"},
{"content":{"body":"To be honest that would be in scope of the channel that does the sharing, which would be host defined. I assume it would grab the module associated to the struct, and send it along, and load the module when receiving it.","msgtype":"m.text"},"ts":1637267202255,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$UWwAzTyodzkKm5k4o7x5XfBUSGdEyqOvoTkc8yxXnAg"},
{"content":{"body":"With some logic to avoid trying to reload modules that were already loaded.","msgtype":"m.text"},"ts":1637267280455,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$jBTYZbi4enDwTBj5jlo-K_TRIF6NFk3Dphumyab66ww"},
{"content":{"body":"Don't we effectively have dynamic prototype lookup in primitives today? I assume implementation optimize that away?","msgtype":"m.text"},"ts":1637267335617,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$DtH7Xs30qlYY3aFhnGgqTcqnX02Tlm_ilfudLwQBmM4"},
{"content":{"body":"well, they get boxed","msgtype":"m.text"},"ts":1637267382974,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$W1wJgH8-VL7qVIsWReaACduWgQE3qd44Q9hlPIFa7Ps"},
{"content":{"body":"i don't think it's some magic","msgtype":"m.text"},"ts":1637267386259,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$8FaFCPQilFWmUiQi4aAXCdmDVv6bGd6WeIr_tTvmTgE"},
{"content":{"body":"i don't want extra allocations here","msgtype":"m.text"},"ts":1637267391268,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$GyNoHRfATgNIsHswPPoo2ZpH7Uh8IJ_q6q9MkxHp5Ys"},
{"content":{"body":"right but you dynamically figure out the box to use depending on the realm","msgtype":"m.text"},"ts":1637267432299,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$IJnJTXbtPr8RD3TZD-v8-2cbsdYIOunbE9RFP9j1F6w"},
{"content":{"body":"Anyway, I believe you, I am clueless when it comes to implementation. I was hoping this could be way to make it more ergonomic without introducing weird spec","msgtype":"m.text"},"ts":1637267625669,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$DSfBbpX3W0GvIAeiUAXHFf3Wl6_AMDX94Y52klAe5Bw"},
{"content":{"body":"yeah, per-realm (thread?) prototypes is something dan ehrenberg has brought up as well before","msgtype":"m.text"},"ts":1637268291125,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$qF-CvtKmNloD9bI2AbP4zug2yx5jc48L-3TEpoRc-YE"},
{"content":{"body":"but i think if we're holding out hope for eventually actually sharing prototypes","msgtype":"m.text"},"ts":1637268299209,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$GztlobpZlHnV9_Ctc8r6LuIdOt4oItDwz-6ORLTDZJQ"},
{"content":{"body":"we can't really do that then, right?","msgtype":"m.text"},"ts":1637268311496,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$QGtOPyIFvcuFQ7jLCAfSlumB3_Me2OfLb067wKR3VAM"},
{"content":{"body":"I just don't see how actually sharing prototypes would work, it'd require you to have a shared version of the intrinsics, which would have to be deeply frozen at least, and would still create identity discontinuity issues that plague legacy realms today. Unless they're specced like the callable boundary that only primitives and other shared structs can be exchanged through them, but that seems like a worse restriction.","msgtype":"m.text"},"ts":1637268524437,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$xGuP4baYwrQhSLwsfiZyYSQ93oyd_IcUM-KGFCYPkS8"},
{"content":{"body":"what intrinsics?","msgtype":"m.text"},"ts":1637268599325,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VEnVt9QRIB7HEMGawlLMdLD7VjY-al_acZtzN6tbdrU"},
{"content":{"body":"i'm not saying all prototypes become shareable. shared struct prototypes are new things we design","msgtype":"m.text"},"ts":1637268627572,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$80Fg1ENz0XRuzNDvDEYxz08RYUERrwzc9x1rk_zXOHY"},
{"content":{"body":"i agree having shared versions of intrinsics is not tractable","msgtype":"m.text"},"ts":1637268635559,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9GcS_sTAQ1UXFZKcb2FPj6dTMXNt-9AZonIl4Mx7rno"},
{"content":{"body":"the prototypes would at least be sealed like shared structs themselves","msgtype":"m.text"},"ts":1637268662701,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$YKgpzr1y5XIAla9dtXqOy34FdYAuWLpfFifl5jx69Xk"},
{"content":{"body":"i don't think deeply frozen is necessary","msgtype":"m.text"},"ts":1637268671375,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$JPxHtRe-l1Uj65LBxQvPLllKExtH2uZU7DYHbQk39ic"},
{"content":{"body":"function prototype is one, but then if you return an object from your shared method, what prototype does it have ?","msgtype":"m.text"},"ts":1637268672816,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$rBmw0QB1N1GXbGhXX7C_YOJo9H61nR1dtSlXqTfD7d4"},
{"content":{"body":"you cannot return plain objects from shared functions","msgtype":"m.text"},"ts":1637268688074,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$KY4sX1A-KOvPOZoDWfQ4Jdpzq-CCTbb7PLf1x6EWMhE"},
{"content":{"body":"ok so you do have a restriction at the boundary to only accept or return primitives or other shared structs","msgtype":"m.text"},"ts":1637268722548,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Mr3yIziSypsNC4RrtUt0e8scf65LsBxbuUWiuJyJknM"},
{"content":{"body":"yeah, i was imagining extending the restriction we have today to the shared functions","msgtype":"m.text"},"ts":1637268739169,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$pSDYm6j_W4ga6G8j17zyxha8fNRSnOS5Kc5Onhxm6WQ"},
{"content":{"body":"i don't see how it works otherwise","msgtype":"m.text"},"ts":1637268742122,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$in515vpYgRH7JU0FnVLcEbB5N279_dUorSENhMgkCkQ"},
{"content":{"body":"then yes it is like the ShadowRealm callable boundary","msgtype":"m.text"},"ts":1637268743267,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$aHdYEm_X1CboHoFWY0HjQ4b7FPSew4TFqvzjPCV-L1A"},
{"content":{"body":"i suppose? there's no wrapping","msgtype":"m.text"},"ts":1637268757943,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$vLR7DpZXe5WQEw_k0F9alXcZMZ_fj8AQ0s0K_LDzNQs"},
{"content":{"body":"it's a selective boundary, yes","msgtype":"m.text"},"ts":1637268762195,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9MUnj6e2OzgRXG-DA5c5xI9MLO3nS5f5ls5c4f14fk8"},
{"content":{"body":"well if you have instances of methods per realm, they're free to do whatever they want","msgtype":"m.text"},"ts":1637268765147,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Blrkp7plH1Ytb6evZF0nq3xFQXWOpJ9KmQQP-SiuZVE"},
{"content":{"body":"right, and that's a different model, where the functions are not actually shared","msgtype":"m.text"},"ts":1637268784331,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Ade_FQPTmQHiul1M3xQhQzWVkwFQjFMFnYRbM7GKv6U"},
{"content":{"body":"just duplicated","msgtype":"m.text"},"ts":1637268785603,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$qJxI4uX0xrnJhOiaDdpbrRLlOwto3jgHybindc46gKk"},
{"content":{"body":"and return objects of their instantiated realm","msgtype":"m.text"},"ts":1637268789999,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$dw8Yt3vOSm4rPr0XCBrIPBiV1r401nOalQidorPz0ak"},
{"content":{"body":"and maybe that's fine, but i'm not sure we have agreement on that","msgtype":"m.text"},"ts":1637268793142,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ZcEO-SdgcCGS-yCnlyyCx_3twLexHsIHakEqXg_uU_I"},
{"content":{"body":"I'm just not aware of the design goals or motivation","msgtype":"m.text"},"ts":1637268832072,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$hqZmkLkeNmyDyHT5nTLHTkOQSt5TVEs9Mi4ZfcnLQhs"},
{"content":{"body":"well, this part isn't in scope of the mvp structs :)","msgtype":"m.text"},"ts":1637268846826,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Cv1dx9bPyQy3u_0YchjC9bOML94SwSFWcWW1HCPkTjo"},
{"content":{"body":"which is probably why it's so nebulous","msgtype":"m.text"},"ts":1637268853901,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$OE1F0A1H2WBeDfofl2S48pmpo41rgJS0V9O9Mqi5YwI"}
]