[
{"content":{"body":"> <@rbuckton:matrix.org> I could possibly model this in terms of `attachBehavior` and abstract it away, assuming some other information is available. I can't emulate the thread-localness I'm describing in quite the same way, but could emulate it with a lock-free data structure\n\nI threw together a bunch of pseudocode for this to get an idea of what's needed. You couldn't support the synchronous case without some kind of synchronous notification occurring when an Agent encounters a shared struct with a previously unseen type identity, but that callback would be something like:\n\n```js\n    setFindMissingPrototypeCallback((exemplar, agentId) => {\n        const agentRegistry = agentId === 0 ? registry.root : ConcurrentList.find(registry.children, registry => registry.agentId === agentId);\n        if (!agentRegistry) {\n            return false;\n        }\n\n        const exemplarTypeIdentity = getTypeIdentity(exemplar);\n        const agentEntry = Array.prototype.find.call(agentRegistry.entries, entry => getTypeIdentity(entry.exemplar) === exemplarTypeIdentity);\n        if (!agentEntry) {\n            return false;\n        }\n\n        const thisAgentEntry = Array.prototype.find.call(perAgentRegistry.entries, entry => entry.key === agentEntry.key);\n        if (!thisAgentEntry || !thisAgentEntry.prototype) {\n            return false;\n        }\n\n        attachBehavior(exemplar, thisAgentEntry.prototype);\n        return true;\n    });\n\n```\n\nAnd something similar would be wired up on the main thread when constructing the `Worker`","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$uhsC8Zg5S259u8or1HRIyqawk_X7SllTwcRN7tiNaL0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I could possibly model this in terms of <code>attachBehavior</code> and abstract it away, assuming some other information is available. I can't emulate the thread-localness I'm describing in quite the same way, but could emulate it with a lock-free data structure</blockquote></mx-reply><p>I threw together a bunch of pseudocode for this to get an idea of what's needed. You couldn't support the synchronous case without some kind of synchronous notification occurring when an Agent encounters a shared struct with a previously unseen type identity, but that callback would be something like:</p>\n<pre><code class=\"language-js\">    setFindMissingPrototypeCallback((exemplar, agentId) =&gt; {\n        const agentRegistry = agentId === 0 ? registry.root : ConcurrentList.find(registry.children, registry =&gt; registry.agentId === agentId);\n        if (!agentRegistry) {\n            return false;\n        }\n\n        const exemplarTypeIdentity = getTypeIdentity(exemplar);\n        const agentEntry = Array.prototype.find.call(agentRegistry.entries, entry =&gt; getTypeIdentity(entry.exemplar) === exemplarTypeIdentity);\n        if (!agentEntry) {\n            return false;\n        }\n\n        const thisAgentEntry = Array.prototype.find.call(perAgentRegistry.entries, entry =&gt; entry.key === agentEntry.key);\n        if (!thisAgentEntry || !thisAgentEntry.prototype) {\n            return false;\n        }\n\n        attachBehavior(exemplar, thisAgentEntry.prototype);\n        return true;\n    });\n\n</code></pre>\n<p>And something similar would be wired up on the main thread when constructing the <code>Worker</code></p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$uhsC8Zg5S259u8or1HRIyqawk_X7SllTwcRN7tiNaL0"}},"msgtype":"m.text"},"ts":1695083126717,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0RngzmX2Bb6JEr7v2irXywViztfcIEm5ovHdoXumcRI"},
{"content":{"body":"Without the synchronous case, you could achieve this via `postMessage` if the worker/port checked each shared struct being sent out to see if it had already seen its type identity, and then posting a handshake message before posting the actual message.","format":"org.matrix.custom.html","formatted_body":"Without the synchronous case, you could achieve this via <code>postMessage</code> if the worker/port checked each shared struct being sent out to see if it had already seen its type identity, and then posting a handshake message before posting the actual message.","msgtype":"m.text"},"ts":1695083264587,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3ijPeaLBAgAcIxWGXNucYiJFlqJqy5hQikZ2XN7XY7U"},
{"content":{"body":"right there has to be something that triggers when another agent register an examplar","msgtype":"m.text"},"ts":1695083294506,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$WAf6_9-g27q9i3NCJByJQV5jdc70i7jsLUevktv_6Oo"},
{"content":{"body":"But this is much simpler if we do all this work on the user's behalf.","msgtype":"m.text"},"ts":1695083332477,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yrqpk4XARtp0m_H8EcdYsp6_4WFn2OlR6sqTNyGnHic"},
{"content":{"body":"for the async case you don't really need to check every shared struct being sent, I'll send some code later","msgtype":"m.text"},"ts":1695083341137,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$vhNwX4I801oIr7M_YGp1S6ceM9pNSpsNVrAMcqmsPjA"},
{"content":{"body":"An async-only case doesn't really exist though, since any thread could set data on a shared struct visible by any other thread.","msgtype":"m.text"},"ts":1695083394843,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-l8-sWQ_CDTmMaqAgdYY6a0iygrnBqRnJEIvGgI3C-o"},
{"content":{"body":"And this `setFindMissingPrototypeCallback` only needs to be invoked lazily when performing `[[GetPrototype]]`","format":"org.matrix.custom.html","formatted_body":"And this <code>setFindMissingPrototypeCallback</code> only needs to be invoked lazily when performing <code>[[GetPrototype]]</code>","msgtype":"m.text"},"ts":1695083500706,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Bh9rwBIXgYQkX0fIII9LeCu7bLaJiEzJ0afe_Vs0StU"},
{"content":{"body":"You could theoretically shim *all* of this with the current shared structs trial if you want to use `Proxy` and patch a bunch of globals and imports.","format":"org.matrix.custom.html","formatted_body":"You could theoretically shim <em>all</em> of this with the current shared structs trial if you want to use <code>Proxy</code> and patch a bunch of globals and imports.","msgtype":"m.text"},"ts":1695083563043,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tfCdjsATlWjfnIHp6_yUt-2yCsZd7mPz2RgRErvqmtY"},
{"content":{"body":"but it would be abysmally slow.","msgtype":"m.text"},"ts":1695083572414,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$w1SPURopJzHjXafXOZQWIGrq_jofOP1jE-ubv8eaHBI"},
{"content":{"body":"> <@rbuckton:matrix.org> And this `setFindMissingPrototypeCallback` only needs to be invoked lazily when performing `[[GetPrototype]]`\n\nAnd this lazy operation doesn't necessarily require blocking. By the time thread A and B can communicate, they would both have already filled out their side of the shared registry.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Bh9rwBIXgYQkX0fIII9LeCu7bLaJiEzJ0afe_Vs0StU?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>And this <code>setFindMissingPrototypeCallback</code> only needs to be invoked lazily when performing <code>[[GetPrototype]]</code></blockquote></mx-reply>And this lazy operation doesn't necessarily require blocking. By the time thread A and B can communicate, they would both have already filled out their side of the shared registry.","m.relates_to":{"m.in_reply_to":{"event_id":"$Bh9rwBIXgYQkX0fIII9LeCu7bLaJiEzJ0afe_Vs0StU"}},"msgtype":"m.text"},"ts":1695084362982,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9he5m5MgxEegboOUTDzHzs8Yan9ZTCf14xyWeybJWb0"},
{"content":{"body":"I'm really not good at multi-threaded coded, but I was thinking of something along the lines of:\n```\nshared struct StructRegistryEntry {\n    name;\n    examplar;\n    next;\n}\n\nshared struct StructRegistry {\n  head;\n  names;\n\n  nonshared lastAttached;\n  nonshared prototypes;\n\n  nonshared constructor(structs = {}) {\n    const names = Object.keys(structs);\n    this.names = new SharedFixedArray(names.length);\n    for (const [i, name] of names.entries()) {\n      this.names[i] = name;\n    }\n    this.prepare(structs);\n  }\n\n  nonshared prepare(structs) {\n    const prototypes = new Map([...this.names].map(name => [name, null]));\n\n    const entries = [];\n\n    for (const [name, constructor] of Object.entries(structs)) {\n      if (!prototypes.has(name)) {\n        throw new Error(`Undeclared struct name ${name}`);\n      }\n\n      prototypes.set(name, constructor.prototype)\n      entries.push([name, new constructor()]);\n    }\n\n    this.prototypes = prototypes;\n\n    for (const [name, examplar] of entries) {\n      this.register(name, examplar);\n    }\n  }\n  \n  nonshared register(name, examplar) {\n    if (!this.prototypes.has(name)) {\n      throw new Error(`Undeclared struct name ${name}`);\n    }\n    const entry = new StructRegistryEntry()\n    entry.name = name;\n    entry.examplar = examplar;\n    entry.next = this.head;\n\n    while (true) {\n      const oldHead = Atomics.compareExchange(this, 'head', entry.next, entry)\n      if (oldHead === entry.next) {\n        break;\n      } else {\n        entry.next = oldHead;\n      }\n    }\n\n    updateRegistrations(this)\n  }\n}\n\nfunction updateRegistrations(structRegistry) {\n  const head = structRegistry.head;\n  let entry = head;\n  while (entry !== structRegistry.lastAttached) {\n    const behavior = structRegistry.prototypes.get(entry.name);\n    if (behavior) {\n      attachBehavior(entry.examplar, behavior);\n    }\n    entry = entry.next;\n  }\n  structRegistry.lastAttached = head;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I'm really not good at multi-threaded coded, but I was thinking of something along the lines of:</p>\n<pre><code>shared struct StructRegistryEntry {\n    name;\n    examplar;\n    next;\n}\n\nshared struct StructRegistry {\n  head;\n  names;\n\n  nonshared lastAttached;\n  nonshared prototypes;\n\n  nonshared constructor(structs = {}) {\n    const names = Object.keys(structs);\n    this.names = new SharedFixedArray(names.length);\n    for (const [i, name] of names.entries()) {\n      this.names[i] = name;\n    }\n    this.prepare(structs);\n  }\n\n  nonshared prepare(structs) {\n    const prototypes = new Map([...this.names].map(name =&gt; [name, null]));\n\n    const entries = [];\n\n    for (const [name, constructor] of Object.entries(structs)) {\n      if (!prototypes.has(name)) {\n        throw new Error(`Undeclared struct name ${name}`);\n      }\n\n      prototypes.set(name, constructor.prototype)\n      entries.push([name, new constructor()]);\n    }\n\n    this.prototypes = prototypes;\n\n    for (const [name, examplar] of entries) {\n      this.register(name, examplar);\n    }\n  }\n  \n  nonshared register(name, examplar) {\n    if (!this.prototypes.has(name)) {\n      throw new Error(`Undeclared struct name ${name}`);\n    }\n    const entry = new StructRegistryEntry()\n    entry.name = name;\n    entry.examplar = examplar;\n    entry.next = this.head;\n\n    while (true) {\n      const oldHead = Atomics.compareExchange(this, 'head', entry.next, entry)\n      if (oldHead === entry.next) {\n        break;\n      } else {\n        entry.next = oldHead;\n      }\n    }\n\n    updateRegistrations(this)\n  }\n}\n\nfunction updateRegistrations(structRegistry) {\n  const head = structRegistry.head;\n  let entry = head;\n  while (entry !== structRegistry.lastAttached) {\n    const behavior = structRegistry.prototypes.get(entry.name);\n    if (behavior) {\n      attachBehavior(entry.examplar, behavior);\n    }\n    entry = entry.next;\n  }\n  structRegistry.lastAttached = head;\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1695085574004,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Ne7ma8A0Efz6q0SVFz1EbQIH3rgxpa3krzhdxzo7Qgs"},
{"content":{"body":"`updateRegistrations` would have to be triggered anytime there is some unattached struct, or eagerly for every message received. I'm not sure how you trigger it in the sync case","format":"org.matrix.custom.html","formatted_body":"<code>updateRegistrations</code> would have to be triggered anytime there is some unattached struct, or eagerly for every message received. I'm not sure how you trigger it in the sync case","msgtype":"m.text"},"ts":1695085649306,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$UBdffVHRDnJa2APRt4TPkVrdsdDDc3MzkBXOfcTyUpw"},
{"content":{"body":"anyway I need to head out, hopefully that pseudo code conveys how I thought of the StructRegistry that Ron suggested","msgtype":"m.text"},"ts":1695085695399,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$bzBuWyULVtsYyh_45fDrmytTMplzK_SiEDRB1UL6_rs"},
{"content":{"body":"Thinking more about it, one way to have all threads process the types of any other thread is to\n- block completion of registering a new thread's examplar until all other existing threads connected to the registry have signaled they have attached behaviors to the new examplar\n- somehow be able to have existing threads process new examplars while they're currently executing\n\nThere doesn't seem to be a good way to explain in terms of initialization and messaging the kind of preemption required by introducing a new thread's types to other connected threads that are potentially in busy loops. Maybe it demonstrates that \"attach behavior\" is not sufficient, and it likely means the registration mechanism has to be language specified instead, which kinda saddens me.","format":"org.matrix.custom.html","formatted_body":"<p>Thinking more about it, one way to have all threads process the types of any other thread is to</p>\n<ul>\n<li>block completion of registering a new thread's examplar until all other existing threads connected to the registry have signaled they have attached behaviors to the new examplar</li>\n<li>somehow be able to have existing threads process new examplars while they're currently executing</li>\n</ul>\n<p>There doesn't seem to be a good way to explain in terms of initialization and messaging the kind of preemption required by introducing a new thread's types to other connected threads that are potentially in busy loops. Maybe it demonstrates that \"attach behavior\" is not sufficient, and it likely means the registration mechanism has to be language specified instead, which kinda saddens me.</p>\n","msgtype":"m.text"},"ts":1695130853339,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$8imMdsd6WAOo14QRw9wJSKGuAnwgtUUdx2YD5xg32mw"},
{"content":{"body":" * Thinking more about it, one way to have all threads process the types of any other thread is to\n\n- block completion of registering a new thread's examplar until all other existing threads connected to the registry have signaled they have attached behaviors to the new examplar\n- somehow be able to have existing threads process new examplars while they're currently executing\n\nThere doesn't seem to be a good way to explain in terms of initialization and messaging the kind of preemption required by introducing a new thread's types to other connected threads that are potentially in busy loops. Maybe it demonstrates that \"attach behavior\" is not sufficient, and it likely means the registry mechanism has to be language specified instead, which kinda saddens me.","format":"org.matrix.custom.html","formatted_body":" * <p>Thinking more about it, one way to have all threads process the types of any other thread is to</p>\n<ul>\n<li>block completion of registering a new thread's examplar until all other existing threads connected to the registry have signaled they have attached behaviors to the new examplar</li>\n<li>somehow be able to have existing threads process new examplars while they're currently executing</li>\n</ul>\n<p>There doesn't seem to be a good way to explain in terms of initialization and messaging the kind of preemption required by introducing a new thread's types to other connected threads that are potentially in busy loops. Maybe it demonstrates that \"attach behavior\" is not sufficient, and it likely means the registry mechanism has to be language specified instead, which kinda saddens me.</p>\n","m.new_content":{"body":"Thinking more about it, one way to have all threads process the types of any other thread is to\n\n- block completion of registering a new thread's examplar until all other existing threads connected to the registry have signaled they have attached behaviors to the new examplar\n- somehow be able to have existing threads process new examplars while they're currently executing\n\nThere doesn't seem to be a good way to explain in terms of initialization and messaging the kind of preemption required by introducing a new thread's types to other connected threads that are potentially in busy loops. Maybe it demonstrates that \"attach behavior\" is not sufficient, and it likely means the registry mechanism has to be language specified instead, which kinda saddens me.","format":"org.matrix.custom.html","formatted_body":"<p>Thinking more about it, one way to have all threads process the types of any other thread is to</p>\n<ul>\n<li>block completion of registering a new thread's examplar until all other existing threads connected to the registry have signaled they have attached behaviors to the new examplar</li>\n<li>somehow be able to have existing threads process new examplars while they're currently executing</li>\n</ul>\n<p>There doesn't seem to be a good way to explain in terms of initialization and messaging the kind of preemption required by introducing a new thread's types to other connected threads that are potentially in busy loops. Maybe it demonstrates that \"attach behavior\" is not sufficient, and it likely means the registry mechanism has to be language specified instead, which kinda saddens me.</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$8imMdsd6WAOo14QRw9wJSKGuAnwgtUUdx2YD5xg32mw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695133083665,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$2gQuqXDDKbB8JX3paCkyjLPQlVflDBL_y_I3_atF3W8"},
{"content":{"body":"What if we only support wiring up exemplars between A and B that *only* have a matching key in M? The shared registry would just track the type identities of each registered exemplar in one place during preload, so you wouldn't need to process new exemplars:\n\n```js\n//\n// main.js\n//\nimport { Foo, Bar, Baz } from \"./structs.js\";\nconst structs = new StructRegistry({ Foo, Bar, Baz });\nconst data = new (new SharedStructType([\"mut\", \"cond\", \"ready\", \"value\"]))();\ndata.mut = new Atomics.Mutex();\ndata.cond = new Atomics.Condition();\ndata.ready = false;\nconst A = new Worker(\"A.js\", { preload: \"preloadA.js\", structs, workerData: data });\nconst B = new Worker(\"B.js\", { preload: \"preloadB.js\", structs, workerData: data });\n\n//\n// preloadA.js\n//\nimport { Foo, Bar, Quxx } from \"./structs.js\";\nimport { prepareWorker } from \"worker_threads\";\nprepareWorker({ structs: { Foo, Bar, Quxx } });\n\n//\n// preloadB.js\n//\nimport { Foo, Baz, Quxx } from \"./structs.js\";\nimport { prepareWorker } from \"worker_threads\";\nprepareWorker({ structs: { Foo, Baz, Quxx } });\n\n//\n// A.js\n//\nimport { Foo, Bar, Baz, Quxx } from \"./structs.js\";\nimport { workerData } from \"worker_threads\";\n\nAtomics.Mutex.lock(workerData.mut, () => {\n  function waitForB() {\n    while (!workerData.ready) Atomics.Condition.wait(workerData.cond, workerData.mut);\n  }\n\n  function sendToB(value) {\n    workerData.value = value;\n    workerData.ready = false;\n    Atomics.Condition.notify(workerData.cond);\n    waitForB();\n  }\n\n  function receiveFromB() {\n    waitForB();\n    return workerData.value;\n  }\n\n  waitForB();\n\n  // send our `Foo`\n  sendToB(new Foo());\n\n  // Check whether the `Foo` sent by B shares the same prototype as our `Foo`.\n  // This works because both A and B have registered a `Foo` entry that maps to `Foo` in the main thread.\n  console.log(receiveFromB() instanceof Foo); // prints: true\n\n  // send our `Bar`\n  sendToB(new Bar());\n\n  // Check whether the `Bar` sent by B shares the same prototype as our `Bar`.\n  // This does not work because preloadB.js did not register `Bar`.\n  console.log(receiveFromB() instanceof Bar); // prints: false\n\n  // send our `Baz`\n  sendToB(new Baz());\n\n  // Check whether the `Baz` sent by B shares the same prototype as our `Baz`.\n  // This does not work because preloadA.js did not register `Baz`.\n  console.log(receiveFromB() instanceof Baz); // prints: false\n\n  // send our `Quxx`\n  sendToB(new Quxx());\n\n  // Check whether the `Quxx` sent by B shares the same prototype as our `Quxx`.\n  // This does not work because main.js did not register `Quxx`.\n  console.log(receiveFromB() instanceof Quxx); // prints: false\n});\n\n// B.js\nimport { Foo, Bar, Baz, Quxx } from \"./structs.js\";\nimport { workerData } from \"worker_threads\";\n\nAtomics.Mutex.lock(workerData.mut, () => {\n  function waitForA() {\n    while (workerData.ready) Atomics.Condition.wait(workerData.cond, workerData.mut);\n  }\n\n  function sendToA(value) {\n    workerData.value = value;\n    workerData.ready = true;\n    Atomics.Condition.notify(workerData.cond);\n    waitForA();\n  }\n\n  function receiveFromA() {\n    waitForA();\n    return workerData.value;\n  }\n\n  // signal to A that we're ready\n  sendToA(undefined);\n\n  // Check whether the `Foo` sent by A shares the same prototype as our `Foo`.\n  // This works because both A and B have registered a `Foo` entry that maps to `Foo` in the main thread.\n  console.log(receiveFromA() instanceof Foo); // prints: true\n\n  // send our `Foo`\n  sendToA(new Foo());\n\n  // Check whether the `Bar` sent by A shares the same prototype as our `Bar`.\n  // This does not work because preloadB.js did not register `Bar`.\n  console.log(receiveFromA() instanceof Bar); // prints: false\n  \n  // send our `Bar`\n  sendToA(new Bar());\n\n  // Check whether the `Baz` sent by A shares the same prototype as our `Baz`.\n  // This does not work because preloadA.js did not register `Baz`.\n  console.log(receiveFromA() instanceof Baz); // prints: false\n\n  // send our `Baz`\n  sendToA(new Baz());\n\n  // Check whether the `Quxx` sent by B shares the same prototype as our `Quxx`.\n  // This does not work because main.js did not register `Quxx`.\n  console.log(receiveFromA() instanceof Quxx); // prints: false\n\n  // send our `Quxx`\n  sendToA(new Quxx());\n});\n```","format":"org.matrix.custom.html","formatted_body":"<p>What if we only support wiring up exemplars between A and B that <em>only</em> have a matching key in M? The shared registry would just track the type identities of each registered exemplar in one place during preload, so you wouldn't need to process new exemplars:</p>\n<pre><code class=\"language-js\">//\n// main.js\n//\nimport { Foo, Bar, Baz } from \"./structs.js\";\nconst structs = new StructRegistry({ Foo, Bar, Baz });\nconst data = new (new SharedStructType([\"mut\", \"cond\", \"ready\", \"value\"]))();\ndata.mut = new Atomics.Mutex();\ndata.cond = new Atomics.Condition();\ndata.ready = false;\nconst A = new Worker(\"A.js\", { preload: \"preloadA.js\", structs, workerData: data });\nconst B = new Worker(\"B.js\", { preload: \"preloadB.js\", structs, workerData: data });\n\n//\n// preloadA.js\n//\nimport { Foo, Bar, Quxx } from \"./structs.js\";\nimport { prepareWorker } from \"worker_threads\";\nprepareWorker({ structs: { Foo, Bar, Quxx } });\n\n//\n// preloadB.js\n//\nimport { Foo, Baz, Quxx } from \"./structs.js\";\nimport { prepareWorker } from \"worker_threads\";\nprepareWorker({ structs: { Foo, Baz, Quxx } });\n\n//\n// A.js\n//\nimport { Foo, Bar, Baz, Quxx } from \"./structs.js\";\nimport { workerData } from \"worker_threads\";\n\nAtomics.Mutex.lock(workerData.mut, () =&gt; {\n  function waitForB() {\n    while (!workerData.ready) Atomics.Condition.wait(workerData.cond, workerData.mut);\n  }\n\n  function sendToB(value) {\n    workerData.value = value;\n    workerData.ready = false;\n    Atomics.Condition.notify(workerData.cond);\n    waitForB();\n  }\n\n  function receiveFromB() {\n    waitForB();\n    return workerData.value;\n  }\n\n  waitForB();\n\n  // send our `Foo`\n  sendToB(new Foo());\n\n  // Check whether the `Foo` sent by B shares the same prototype as our `Foo`.\n  // This works because both A and B have registered a `Foo` entry that maps to `Foo` in the main thread.\n  console.log(receiveFromB() instanceof Foo); // prints: true\n\n  // send our `Bar`\n  sendToB(new Bar());\n\n  // Check whether the `Bar` sent by B shares the same prototype as our `Bar`.\n  // This does not work because preloadB.js did not register `Bar`.\n  console.log(receiveFromB() instanceof Bar); // prints: false\n\n  // send our `Baz`\n  sendToB(new Baz());\n\n  // Check whether the `Baz` sent by B shares the same prototype as our `Baz`.\n  // This does not work because preloadA.js did not register `Baz`.\n  console.log(receiveFromB() instanceof Baz); // prints: false\n\n  // send our `Quxx`\n  sendToB(new Quxx());\n\n  // Check whether the `Quxx` sent by B shares the same prototype as our `Quxx`.\n  // This does not work because main.js did not register `Quxx`.\n  console.log(receiveFromB() instanceof Quxx); // prints: false\n});\n\n// B.js\nimport { Foo, Bar, Baz, Quxx } from \"./structs.js\";\nimport { workerData } from \"worker_threads\";\n\nAtomics.Mutex.lock(workerData.mut, () =&gt; {\n  function waitForA() {\n    while (workerData.ready) Atomics.Condition.wait(workerData.cond, workerData.mut);\n  }\n\n  function sendToA(value) {\n    workerData.value = value;\n    workerData.ready = true;\n    Atomics.Condition.notify(workerData.cond);\n    waitForA();\n  }\n\n  function receiveFromA() {\n    waitForA();\n    return workerData.value;\n  }\n\n  // signal to A that we're ready\n  sendToA(undefined);\n\n  // Check whether the `Foo` sent by A shares the same prototype as our `Foo`.\n  // This works because both A and B have registered a `Foo` entry that maps to `Foo` in the main thread.\n  console.log(receiveFromA() instanceof Foo); // prints: true\n\n  // send our `Foo`\n  sendToA(new Foo());\n\n  // Check whether the `Bar` sent by A shares the same prototype as our `Bar`.\n  // This does not work because preloadB.js did not register `Bar`.\n  console.log(receiveFromA() instanceof Bar); // prints: false\n  \n  // send our `Bar`\n  sendToA(new Bar());\n\n  // Check whether the `Baz` sent by A shares the same prototype as our `Baz`.\n  // This does not work because preloadA.js did not register `Baz`.\n  console.log(receiveFromA() instanceof Baz); // prints: false\n\n  // send our `Baz`\n  sendToA(new Baz());\n\n  // Check whether the `Quxx` sent by B shares the same prototype as our `Quxx`.\n  // This does not work because main.js did not register `Quxx`.\n  console.log(receiveFromA() instanceof Quxx); // prints: false\n\n  // send our `Quxx`\n  sendToA(new Quxx());\n});\n</code></pre>\n","msgtype":"m.text"},"ts":1695134664185,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4JG5FIiuvtIdfcue0cRE02tZyjb9lKAP-ueGpNqI3K0"},
{"content":{"body":"When A and B receive something they don't share a mapping for, you just get data and no behavior.","msgtype":"m.text"},"ts":1695134759529,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KrGW1fhDGumRMWjCa4t3NQcDGu9baWRiRkwXQdu-riY"},
{"content":{"body":"In that way its still useful for read/write and for sending it along to another thread that might be able to interpret it.","msgtype":"m.text"},"ts":1695134796524,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$EE3UIeLbbb9NkdRmh0CWw3Dz-Uxuvcio43d9pa3f0vI"},
{"content":{"body":"In the same vein, if `main.js` starts two workers that don't share the same registry, they can't wire up behavior at all.","format":"org.matrix.custom.html","formatted_body":"In the same vein, if <code>main.js</code> starts two workers that don't share the same registry, they can't wire up behavior at all.","msgtype":"m.text"},"ts":1695135203266,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ksmh_r0wpiMT54MiZXIPE_iS8ixm3QT66bmAwZYsl7E"},
{"content":{"body":"I was assuming only matching keys in the registry in the first place, but I don't think that solves the problem. For example:\n- M creates the registry\n- M creates A with the shared registry. A can block during prepare until it has attached behaviors for M's examplars, and M can block until A has shared its examplars, and M has attached behavior\n- M shares a container struct with A\n- M subsequently creates B with the same shared registry. B can block during prepare until it has attached behaviors for both M and A's examplars, and M can block until B has shared its examplars, and M has attached behavior\n- M shares the previously created container with B (possibly in the init params of the worker)\n- B adds some shared structs it creates to the container\n- A attempts to read from the container\n\nHow do we make sure that A has had the opportunity to process B's examplars to attach behavior to B's types before A encounters the B struct types in the shared container. A may be doing a busy loop we cannot preempt. I can probably imagine patching all atomics operations to interleave the attachment check, but that feels gross.\n\nOr maybe there's something simply I'm overlooking","format":"org.matrix.custom.html","formatted_body":"<p>I was assuming only matching keys in the registry in the first place, but I don't think that solves the problem. For example:</p>\n<ul>\n<li>M creates the registry</li>\n<li>M creates A with the shared registry. A can block during prepare until it has attached behaviors for M's examplars, and M can block until A has shared its examplars, and M has attached behavior</li>\n<li>M shares a container struct with A</li>\n<li>M subsequently creates B with the same shared registry. B can block during prepare until it has attached behaviors for both M and A's examplars, and M can block until B has shared its examplars, and M has attached behavior</li>\n<li>M shares the previously created container with B (possibly in the init params of the worker)</li>\n<li>B adds some shared structs it creates to the container</li>\n<li>A attempts to read from the container</li>\n</ul>\n<p>How do we make sure that A has had the opportunity to process B's examplars to attach behavior to B's types before A encounters the B struct types in the shared container. A may be doing a busy loop we cannot preempt. I can probably imagine patching all atomics operations to interleave the attachment check, but that feels gross.</p>\n<p>Or maybe there's something simply I'm overlooking</p>\n","msgtype":"m.text"},"ts":1695139407877,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$AA4x9I9v3wBvfYt_NV7rH32rkJFP2LYderF34ac8vuk"},
{"content":{"body":"I don't think we need to block until behavior is attached to exemplars until we do `[[GetPrototypeOf]]`, at which time we can look up the matching exemplars from the registry. By the time A communicates with B, or either communicates with M, their registries would already be connected.","format":"org.matrix.custom.html","formatted_body":"I don't think we need to block until behavior is attached to exemplars until we do <code>[[GetPrototypeOf]]</code>, at which time we can look up the matching exemplars from the registry. By the time A communicates with B, or either communicates with M, their registries would already be connected.","msgtype":"m.text"},"ts":1695145979543,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tj4f-Kf8JiYKVWh0TSukRfXEOAt0ByFJLifrjk6pbVg"},
{"content":{"body":"Right, that's what I mean, it requires the concept of the registry to be known to the spec so that `[[GetPrototypeOf]]` can do necessary lookup. I was still trying to explain the registry in terms of simpler attach behavior semantics, but that doesn't seem to be possible","format":"org.matrix.custom.html","formatted_body":"Right, that's what I mean, it requires the concept of the registry to be known to the spec so that <code>[[GetPrototypeOf]]</code> can do necessary lookup. I was still trying to explain the registry in terms of simpler attach behavior semantics, but that doesn't seem to be possible","msgtype":"m.text"},"ts":1695146183176,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$BEbvgyMMTWPXAMGJL2h1f6_LjNZFKsq8BylxvZTSCKQ"},
{"content":{"body":"Even for attachBehavior to work there has to be some behind-the-scenes work in the spec to generate a prototype based on the type identity of a shared struct type.","msgtype":"m.text"},"ts":1695146273108,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ulmLe2CgfAs3VgqDJdZUbnvaZYReEM-tNWjkZgylVio"},
{"content":{"body":"shu: yesterday we were discussing marking methods as `nonshared`, are you anticipating these methods would be attached to the instance as `nonshared` fields, or to an agent-local `[[Prototype]]`? ","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a>: yesterday we were discussing marking methods as <code>nonshared</code>, are you anticipating these methods would be attached to the instance as <code>nonshared</code> fields, or to an agent-local <code>[[Prototype]]</code>?","msgtype":"m.text"},"ts":1695150562291,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8g2bxwJBO3aBa_EBkgPqH0zt7zE4lnkJOsmKj_RjANA"},
{"content":{"body":"> <@rbuckton:matrix.org> Even for attachBehavior to work there has to be some behind-the-scenes work in the spec to generate a prototype based on the type identity of a shared struct type.\n\nsure, but while that's also technically an internal registry, it's from an internal and non-forgeable type identity to a local behavior object. Your proposed registry is mapping from a string, which to prevent introducing a realm / agent wide communication channel has to be connection specific, or the registry state cannot be observable by the program in any way, neither of which I am convinced about being the case yet.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$ulmLe2CgfAs3VgqDJdZUbnvaZYReEM-tNWjkZgylVio?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Even for attachBehavior to work there has to be some behind-the-scenes work in the spec to generate a prototype based on the type identity of a shared struct type.</blockquote></mx-reply>sure, but while that's also technically an internal registry, it's from an internal and non-forgeable type identity to a local behavior object. Your proposed registry is mapping from a string, which to prevent introducing a realm / agent wide communication channel has to be connection specific, or the registry state cannot be observable by the program in any way, neither of which I am convinced about being the case yet.","m.relates_to":{"m.in_reply_to":{"event_id":"$ulmLe2CgfAs3VgqDJdZUbnvaZYReEM-tNWjkZgylVio"}},"msgtype":"m.text"},"ts":1695155212591,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$MFRc0ru3El2PmtZb5CkE7nXi63P0mjxX0tpQYWdHolA"},
{"content":{"body":"Even the `on(\"message\", ...)` + `attachBehavior` mechanism uses a string key, it's just that the string key you used was `\"registerPoint\"`.","format":"org.matrix.custom.html","formatted_body":"Even the <code>on(\"message\", ...)</code> + <code>attachBehavior</code> mechanism uses a string key, it's just that the string key you used was <code>\"registerPoint\"</code>.","msgtype":"m.text"},"ts":1695155320931,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$swaa5ix7Zkx67hnHNbSbrN5BQcETyQWKMl31nSaiW9I"},
{"content":{"body":"An in earlier discussions with shu he'd suggested something like \"you send an array of exemplars\", in which case the key you use is an integer. What the key is doesn't matter.","format":"org.matrix.custom.html","formatted_body":"An in earlier discussions with <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a> he'd suggested something like \"you send an array of exemplars\", in which case the key you use is an integer. What the key is doesn't matter.","msgtype":"m.text"},"ts":1695155384697,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-eZGFvUF2u-wCFLJigZDBWwIYsnOsiaGbG1s0uSTXeU"},
{"content":{"body":"Everything I'm suggesting is basically just a layer of abstraction above the same capabilities you're proposing.","msgtype":"m.text"},"ts":1695155428391,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$c2cRzavnx2cD8hX2cjT7fc9US44bTddf8HV-tjtI-9g"},
{"content":{"body":"The initiating thread needs to pass a message containing one or more exemplars to a child thread, keyed in some way as to be interpreted as a way to identify which exemplar is an example of which known thing we want to associate it with.","msgtype":"m.text"},"ts":1695155525583,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZDJMDxAb9uJB8vH3S7WT-bwwpe01glESqZk93FQRjoc"},
{"content":{"body":"rbuckton: the former, though there's nothing precluding an agent-local [[Prototype]] either","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: the former, though there's nothing precluding an agent-local [[Prototype]] either","msgtype":"m.text"},"ts":1695155529403,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ea8ZC2SoBBuEbnrH43N9pk80NcOb1SV2NxvY5FUOExU"},
{"content":{"body":"it is slightly more difficult to implement the latter so that's not what the dev trial does","msgtype":"m.text"},"ts":1695155545120,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xwdrEho-7xhmbjvM1XpXvJ2arqC1IOorKPY6HcYg4o8"},
{"content":{"body":"you should probably be able to express it both ways","msgtype":"m.text"},"ts":1695155567516,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$W94K3718tH1CvLG1hbinaomjcNg2QALu-e7xdlaG8UA"},
{"content":{"body":"Does this process even work if I have to attach agent local values for every method every time I receive a new instance of an existing struct type?","msgtype":"m.text"},"ts":1695155583510,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$crmpoD3c4oXRnsm29TJmsnR6cpRIIJT8KNCCdkOR9Ng"},
{"content":{"body":"sorry i think i misread","msgtype":"m.text"},"ts":1695155599511,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$FoQJXQMY3vv80C8UKO2rgj8vPsOHZYXn6opTRMActTE"},
{"content":{"body":"the two choices are:\n\n1. a shared struct instance's [[Prototype]] is a shared field and holds a shared struct, with `nonshared` fields, into which you assign methods\n2. a shared struct instance's [[Prototype]] is a `nonshared` field and points to a per-agent local struct","format":"org.matrix.custom.html","formatted_body":"<p>the two choices are:</p>\n<ol>\n<li>a shared struct instance's [[Prototype]] is a shared field and holds a shared struct, with <code>nonshared</code> fields, into which you assign methods</li>\n<li>a shared struct instance's [[Prototype]] is a <code>nonshared</code> field and points to a per-agent local struct</li>\n</ol>\n","msgtype":"m.text"},"ts":1695155646040,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$HTj3amOy9ic6346qUM25tQy0JsCrTg3J9KwgjiRxuIo"},
{"content":{"body":"i think you want `nonshared` fields regardless","format":"org.matrix.custom.html","formatted_body":"i think you want <code>nonshared</code> fields regardless","msgtype":"m.text"},"ts":1695155682244,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$3NlXkzou5p-DYG7o1Wt85ILMRPnYR2wHqqK1uAMj880"},
{"content":{"body":"and maybe (2) as well","msgtype":"m.text"},"ts":1695155698624,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$QMDn6i8dWDLYxbDojAsGbpvoH_LJ0vwGPJ3gEPJYDQo"},
{"content":{"body":"but that one's less clear to me","msgtype":"m.text"},"ts":1695155703425,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$oTTxZQRgvN3SIu3DbkH8Ah39w1md8hJnI1APDMAnE7A"},
{"content":{"body":"i am prototyping (1) in the dev trial","msgtype":"m.text"},"ts":1695155708496,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Y82Dmt1ZmwvY7T8GuM_efFAFVVrVVA8lxH727ZivKqc"},
{"content":{"body":"in either case you don't have to attach methods for every new instance","msgtype":"m.text"},"ts":1695155729032,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$y47RcBG9LZcHkRAYr3zHnVcevzELXDlnKT0QQiI9WFw"},
{"content":{"body":"> <@rbuckton:matrix.org> Everything I'm suggesting is basically just a layer of abstraction above the same capabilities you're proposing.\n\nRight but that is clearly and explicitly scoped to the connection. I'm struggling to think of a way to specify the registry that remains fully connection oriented.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$c2cRzavnx2cD8hX2cjT7fc9US44bTddf8HV-tjtI-9g?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Everything I&#39;m suggesting is basically just a layer of abstraction above the same capabilities you&#39;re proposing.</blockquote></mx-reply>Right but that is clearly and explicitly scoped to the connection. I'm struggling to think of a way to specify the registry that remains fully connection oriented.","m.relates_to":{"m.in_reply_to":{"event_id":"$c2cRzavnx2cD8hX2cjT7fc9US44bTddf8HV-tjtI-9g"}},"msgtype":"m.text"},"ts":1695155809217,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$-HNuojFj5uUmWT3JgkWYvsg7gmhwVPZQZHXK99ZrSXw"},
{"content":{"body":"(1) works, I suppose. What's important is that for a given struct type, I only need to establish the `[[Prototype]]` relationship once in a given thread, not once every time a new instance is observed.","format":"org.matrix.custom.html","formatted_body":"(1) works, I suppose. What's important is that for a given struct type, I only need to establish the <code>[[Prototype]]</code> relationship once in a given thread, not once every time a new instance is observed.","msgtype":"m.text"},"ts":1695155841799,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$v6tS4BtXHScbWuPoPWoaYZbqHNwnS02GNrAXp2SE98U"},
{"content":{"body":"(1) has some advantages, like, `instanceof` just works with the usual semantics","format":"org.matrix.custom.html","formatted_body":"(1) has some advantages, like, <code>instanceof</code> just works with the usual semantics","msgtype":"m.text"},"ts":1695155881463,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$pfrxxzKezAY7QsGECI5JmY2zsaH-VBqGb2j_ysoUUsI"},
{"content":{"body":"since all instances have the same prototype object","msgtype":"m.text"},"ts":1695155890389,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$HWtuLKCpiW7IDVxtOPGPj_eaiHkqrIsH4tc4ajuBoFo"},
{"content":{"body":"What I suggested *is* connection oriented. The main thread doesn't have a global registry shared across all workers. It has a _specific_ registry you hand to individual workers on creation. The child thread associated with that worker will always be able to refer to its parent, thus the registry will always be reachable.","format":"org.matrix.custom.html","formatted_body":"What I suggested <em>is</em> connection oriented. The main thread doesn't have a global registry shared across all workers. It has a <em>specific</em> registry you hand to individual workers on creation. The child thread associated with that worker will always be able to refer to its parent, thus the registry will always be reachable.","msgtype":"m.text"},"ts":1695155934254,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XNDOtulbzBiV5U6_DARvTlie24MVIeUMo-V-3t-yx3o"}
]