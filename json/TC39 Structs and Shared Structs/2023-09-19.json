[
{"content":{"body":"> <@rbuckton:matrix.org> I could possibly model this in terms of `attachBehavior` and abstract it away, assuming some other information is available. I can't emulate the thread-localness I'm describing in quite the same way, but could emulate it with a lock-free data structure\n\nI threw together a bunch of pseudocode for this to get an idea of what's needed. You couldn't support the synchronous case without some kind of synchronous notification occurring when an Agent encounters a shared struct with a previously unseen type identity, but that callback would be something like:\n\n```js\n    setFindMissingPrototypeCallback((exemplar, agentId) => {\n        const agentRegistry = agentId === 0 ? registry.root : ConcurrentList.find(registry.children, registry => registry.agentId === agentId);\n        if (!agentRegistry) {\n            return false;\n        }\n\n        const exemplarTypeIdentity = getTypeIdentity(exemplar);\n        const agentEntry = Array.prototype.find.call(agentRegistry.entries, entry => getTypeIdentity(entry.exemplar) === exemplarTypeIdentity);\n        if (!agentEntry) {\n            return false;\n        }\n\n        const thisAgentEntry = Array.prototype.find.call(perAgentRegistry.entries, entry => entry.key === agentEntry.key);\n        if (!thisAgentEntry || !thisAgentEntry.prototype) {\n            return false;\n        }\n\n        attachBehavior(exemplar, thisAgentEntry.prototype);\n        return true;\n    });\n\n```\n\nAnd something similar would be wired up on the main thread when constructing the `Worker`","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$uhsC8Zg5S259u8or1HRIyqawk_X7SllTwcRN7tiNaL0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I could possibly model this in terms of <code>attachBehavior</code> and abstract it away, assuming some other information is available. I can't emulate the thread-localness I'm describing in quite the same way, but could emulate it with a lock-free data structure</blockquote></mx-reply><p>I threw together a bunch of pseudocode for this to get an idea of what's needed. You couldn't support the synchronous case without some kind of synchronous notification occurring when an Agent encounters a shared struct with a previously unseen type identity, but that callback would be something like:</p>\n<pre><code class=\"language-js\">    setFindMissingPrototypeCallback((exemplar, agentId) =&gt; {\n        const agentRegistry = agentId === 0 ? registry.root : ConcurrentList.find(registry.children, registry =&gt; registry.agentId === agentId);\n        if (!agentRegistry) {\n            return false;\n        }\n\n        const exemplarTypeIdentity = getTypeIdentity(exemplar);\n        const agentEntry = Array.prototype.find.call(agentRegistry.entries, entry =&gt; getTypeIdentity(entry.exemplar) === exemplarTypeIdentity);\n        if (!agentEntry) {\n            return false;\n        }\n\n        const thisAgentEntry = Array.prototype.find.call(perAgentRegistry.entries, entry =&gt; entry.key === agentEntry.key);\n        if (!thisAgentEntry || !thisAgentEntry.prototype) {\n            return false;\n        }\n\n        attachBehavior(exemplar, thisAgentEntry.prototype);\n        return true;\n    });\n\n</code></pre>\n<p>And something similar would be wired up on the main thread when constructing the <code>Worker</code></p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$uhsC8Zg5S259u8or1HRIyqawk_X7SllTwcRN7tiNaL0"}},"msgtype":"m.text"},"ts":1695083126717,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0RngzmX2Bb6JEr7v2irXywViztfcIEm5ovHdoXumcRI"},
{"content":{"body":"Without the synchronous case, you could achieve this via `postMessage` if the worker/port checked each shared struct being sent out to see if it had already seen its type identity, and then posting a handshake message before posting the actual message.","format":"org.matrix.custom.html","formatted_body":"Without the synchronous case, you could achieve this via <code>postMessage</code> if the worker/port checked each shared struct being sent out to see if it had already seen its type identity, and then posting a handshake message before posting the actual message.","msgtype":"m.text"},"ts":1695083264587,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3ijPeaLBAgAcIxWGXNucYiJFlqJqy5hQikZ2XN7XY7U"},
{"content":{"body":"right there has to be something that triggers when another agent register an examplar","msgtype":"m.text"},"ts":1695083294506,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$WAf6_9-g27q9i3NCJByJQV5jdc70i7jsLUevktv_6Oo"},
{"content":{"body":"But this is much simpler if we do all this work on the user's behalf.","msgtype":"m.text"},"ts":1695083332477,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yrqpk4XARtp0m_H8EcdYsp6_4WFn2OlR6sqTNyGnHic"},
{"content":{"body":"for the async case you don't really need to check every shared struct being sent, I'll send some code later","msgtype":"m.text"},"ts":1695083341137,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$vhNwX4I801oIr7M_YGp1S6ceM9pNSpsNVrAMcqmsPjA"},
{"content":{"body":"An async-only case doesn't really exist though, since any thread could set data on a shared struct visible by any other thread.","msgtype":"m.text"},"ts":1695083394843,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-l8-sWQ_CDTmMaqAgdYY6a0iygrnBqRnJEIvGgI3C-o"}
]