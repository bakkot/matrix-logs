[
{"content":{"body":"> <@rbuckton:matrix.org> I could possibly model this in terms of `attachBehavior` and abstract it away, assuming some other information is available. I can't emulate the thread-localness I'm describing in quite the same way, but could emulate it with a lock-free data structure\n\nI threw together a bunch of pseudocode for this to get an idea of what's needed. You couldn't support the synchronous case without some kind of synchronous notification occurring when an Agent encounters a shared struct with a previously unseen type identity, but that callback would be something like:\n\n```js\n    setFindMissingPrototypeCallback((exemplar, agentId) => {\n        const agentRegistry = agentId === 0 ? registry.root : ConcurrentList.find(registry.children, registry => registry.agentId === agentId);\n        if (!agentRegistry) {\n            return false;\n        }\n\n        const exemplarTypeIdentity = getTypeIdentity(exemplar);\n        const agentEntry = Array.prototype.find.call(agentRegistry.entries, entry => getTypeIdentity(entry.exemplar) === exemplarTypeIdentity);\n        if (!agentEntry) {\n            return false;\n        }\n\n        const thisAgentEntry = Array.prototype.find.call(perAgentRegistry.entries, entry => entry.key === agentEntry.key);\n        if (!thisAgentEntry || !thisAgentEntry.prototype) {\n            return false;\n        }\n\n        attachBehavior(exemplar, thisAgentEntry.prototype);\n        return true;\n    });\n\n```\n\nAnd something similar would be wired up on the main thread when constructing the `Worker`","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$uhsC8Zg5S259u8or1HRIyqawk_X7SllTwcRN7tiNaL0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I could possibly model this in terms of <code>attachBehavior</code> and abstract it away, assuming some other information is available. I can't emulate the thread-localness I'm describing in quite the same way, but could emulate it with a lock-free data structure</blockquote></mx-reply><p>I threw together a bunch of pseudocode for this to get an idea of what's needed. You couldn't support the synchronous case without some kind of synchronous notification occurring when an Agent encounters a shared struct with a previously unseen type identity, but that callback would be something like:</p>\n<pre><code class=\"language-js\">    setFindMissingPrototypeCallback((exemplar, agentId) =&gt; {\n        const agentRegistry = agentId === 0 ? registry.root : ConcurrentList.find(registry.children, registry =&gt; registry.agentId === agentId);\n        if (!agentRegistry) {\n            return false;\n        }\n\n        const exemplarTypeIdentity = getTypeIdentity(exemplar);\n        const agentEntry = Array.prototype.find.call(agentRegistry.entries, entry =&gt; getTypeIdentity(entry.exemplar) === exemplarTypeIdentity);\n        if (!agentEntry) {\n            return false;\n        }\n\n        const thisAgentEntry = Array.prototype.find.call(perAgentRegistry.entries, entry =&gt; entry.key === agentEntry.key);\n        if (!thisAgentEntry || !thisAgentEntry.prototype) {\n            return false;\n        }\n\n        attachBehavior(exemplar, thisAgentEntry.prototype);\n        return true;\n    });\n\n</code></pre>\n<p>And something similar would be wired up on the main thread when constructing the <code>Worker</code></p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$uhsC8Zg5S259u8or1HRIyqawk_X7SllTwcRN7tiNaL0"}},"msgtype":"m.text"},"ts":1695083126717,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0RngzmX2Bb6JEr7v2irXywViztfcIEm5ovHdoXumcRI"},
{"content":{"body":"Without the synchronous case, you could achieve this via `postMessage` if the worker/port checked each shared struct being sent out to see if it had already seen its type identity, and then posting a handshake message before posting the actual message.","format":"org.matrix.custom.html","formatted_body":"Without the synchronous case, you could achieve this via <code>postMessage</code> if the worker/port checked each shared struct being sent out to see if it had already seen its type identity, and then posting a handshake message before posting the actual message.","msgtype":"m.text"},"ts":1695083264587,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3ijPeaLBAgAcIxWGXNucYiJFlqJqy5hQikZ2XN7XY7U"},
{"content":{"body":"right there has to be something that triggers when another agent register an examplar","msgtype":"m.text"},"ts":1695083294506,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$WAf6_9-g27q9i3NCJByJQV5jdc70i7jsLUevktv_6Oo"},
{"content":{"body":"But this is much simpler if we do all this work on the user's behalf.","msgtype":"m.text"},"ts":1695083332477,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yrqpk4XARtp0m_H8EcdYsp6_4WFn2OlR6sqTNyGnHic"},
{"content":{"body":"for the async case you don't really need to check every shared struct being sent, I'll send some code later","msgtype":"m.text"},"ts":1695083341137,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$vhNwX4I801oIr7M_YGp1S6ceM9pNSpsNVrAMcqmsPjA"},
{"content":{"body":"An async-only case doesn't really exist though, since any thread could set data on a shared struct visible by any other thread.","msgtype":"m.text"},"ts":1695083394843,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-l8-sWQ_CDTmMaqAgdYY6a0iygrnBqRnJEIvGgI3C-o"},
{"content":{"body":"And this `setFindMissingPrototypeCallback` only needs to be invoked lazily when performing `[[GetPrototype]]`","format":"org.matrix.custom.html","formatted_body":"And this <code>setFindMissingPrototypeCallback</code> only needs to be invoked lazily when performing <code>[[GetPrototype]]</code>","msgtype":"m.text"},"ts":1695083500706,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Bh9rwBIXgYQkX0fIII9LeCu7bLaJiEzJ0afe_Vs0StU"},
{"content":{"body":"You could theoretically shim *all* of this with the current shared structs trial if you want to use `Proxy` and patch a bunch of globals and imports.","format":"org.matrix.custom.html","formatted_body":"You could theoretically shim <em>all</em> of this with the current shared structs trial if you want to use <code>Proxy</code> and patch a bunch of globals and imports.","msgtype":"m.text"},"ts":1695083563043,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tfCdjsATlWjfnIHp6_yUt-2yCsZd7mPz2RgRErvqmtY"},
{"content":{"body":"but it would be abysmally slow.","msgtype":"m.text"},"ts":1695083572414,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$w1SPURopJzHjXafXOZQWIGrq_jofOP1jE-ubv8eaHBI"},
{"content":{"body":"> <@rbuckton:matrix.org> And this `setFindMissingPrototypeCallback` only needs to be invoked lazily when performing `[[GetPrototype]]`\n\nAnd this lazy operation doesn't necessarily require blocking. By the time thread A and B can communicate, they would both have already filled out their side of the shared registry.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Bh9rwBIXgYQkX0fIII9LeCu7bLaJiEzJ0afe_Vs0StU?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>And this <code>setFindMissingPrototypeCallback</code> only needs to be invoked lazily when performing <code>[[GetPrototype]]</code></blockquote></mx-reply>And this lazy operation doesn't necessarily require blocking. By the time thread A and B can communicate, they would both have already filled out their side of the shared registry.","m.relates_to":{"m.in_reply_to":{"event_id":"$Bh9rwBIXgYQkX0fIII9LeCu7bLaJiEzJ0afe_Vs0StU"}},"msgtype":"m.text"},"ts":1695084362982,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9he5m5MgxEegboOUTDzHzs8Yan9ZTCf14xyWeybJWb0"},
{"content":{"body":"I'm really not good at multi-threaded coded, but I was thinking of something along the lines of:\n```\nshared struct StructRegistryEntry {\n    name;\n    examplar;\n    next;\n}\n\nshared struct StructRegistry {\n  head;\n  names;\n\n  nonshared lastAttached;\n  nonshared prototypes;\n\n  nonshared constructor(structs = {}) {\n    const names = Object.keys(structs);\n    this.names = new SharedFixedArray(names.length);\n    for (const [i, name] of names.entries()) {\n      this.names[i] = name;\n    }\n    this.prepare(structs);\n  }\n\n  nonshared prepare(structs) {\n    const prototypes = new Map([...this.names].map(name => [name, null]));\n\n    const entries = [];\n\n    for (const [name, constructor] of Object.entries(structs)) {\n      if (!prototypes.has(name)) {\n        throw new Error(`Undeclared struct name ${name}`);\n      }\n\n      prototypes.set(name, constructor.prototype)\n      entries.push([name, new constructor()]);\n    }\n\n    this.prototypes = prototypes;\n\n    for (const [name, examplar] of entries) {\n      this.register(name, examplar);\n    }\n  }\n  \n  nonshared register(name, examplar) {\n    if (!this.prototypes.has(name)) {\n      throw new Error(`Undeclared struct name ${name}`);\n    }\n    const entry = new StructRegistryEntry()\n    entry.name = name;\n    entry.examplar = examplar;\n    entry.next = this.head;\n\n    while (true) {\n      const oldHead = Atomics.compareExchange(this, 'head', entry.next, entry)\n      if (oldHead === entry.next) {\n        break;\n      } else {\n        entry.next = oldHead;\n      }\n    }\n\n    updateRegistrations(this)\n  }\n}\n\nfunction updateRegistrations(structRegistry) {\n  const head = structRegistry.head;\n  let entry = head;\n  while (entry !== structRegistry.lastAttached) {\n    const behavior = structRegistry.prototypes.get(entry.name);\n    if (behavior) {\n      attachBehavior(entry.examplar, behavior);\n    }\n    entry = entry.next;\n  }\n  structRegistry.lastAttached = head;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I'm really not good at multi-threaded coded, but I was thinking of something along the lines of:</p>\n<pre><code>shared struct StructRegistryEntry {\n    name;\n    examplar;\n    next;\n}\n\nshared struct StructRegistry {\n  head;\n  names;\n\n  nonshared lastAttached;\n  nonshared prototypes;\n\n  nonshared constructor(structs = {}) {\n    const names = Object.keys(structs);\n    this.names = new SharedFixedArray(names.length);\n    for (const [i, name] of names.entries()) {\n      this.names[i] = name;\n    }\n    this.prepare(structs);\n  }\n\n  nonshared prepare(structs) {\n    const prototypes = new Map([...this.names].map(name =&gt; [name, null]));\n\n    const entries = [];\n\n    for (const [name, constructor] of Object.entries(structs)) {\n      if (!prototypes.has(name)) {\n        throw new Error(`Undeclared struct name ${name}`);\n      }\n\n      prototypes.set(name, constructor.prototype)\n      entries.push([name, new constructor()]);\n    }\n\n    this.prototypes = prototypes;\n\n    for (const [name, examplar] of entries) {\n      this.register(name, examplar);\n    }\n  }\n  \n  nonshared register(name, examplar) {\n    if (!this.prototypes.has(name)) {\n      throw new Error(`Undeclared struct name ${name}`);\n    }\n    const entry = new StructRegistryEntry()\n    entry.name = name;\n    entry.examplar = examplar;\n    entry.next = this.head;\n\n    while (true) {\n      const oldHead = Atomics.compareExchange(this, 'head', entry.next, entry)\n      if (oldHead === entry.next) {\n        break;\n      } else {\n        entry.next = oldHead;\n      }\n    }\n\n    updateRegistrations(this)\n  }\n}\n\nfunction updateRegistrations(structRegistry) {\n  const head = structRegistry.head;\n  let entry = head;\n  while (entry !== structRegistry.lastAttached) {\n    const behavior = structRegistry.prototypes.get(entry.name);\n    if (behavior) {\n      attachBehavior(entry.examplar, behavior);\n    }\n    entry = entry.next;\n  }\n  structRegistry.lastAttached = head;\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1695085574004,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Ne7ma8A0Efz6q0SVFz1EbQIH3rgxpa3krzhdxzo7Qgs"},
{"content":{"body":"`updateRegistrations` would have to be triggered anytime there is some unattached struct, or eagerly for every message received. I'm not sure how you trigger it in the sync case","format":"org.matrix.custom.html","formatted_body":"<code>updateRegistrations</code> would have to be triggered anytime there is some unattached struct, or eagerly for every message received. I'm not sure how you trigger it in the sync case","msgtype":"m.text"},"ts":1695085649306,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$UBdffVHRDnJa2APRt4TPkVrdsdDDc3MzkBXOfcTyUpw"},
{"content":{"body":"anyway I need to head out, hopefully that pseudo code conveys how I thought of the StructRegistry that Ron suggested","msgtype":"m.text"},"ts":1695085695399,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$bzBuWyULVtsYyh_45fDrmytTMplzK_SiEDRB1UL6_rs"},
{"content":{"body":"Thinking more about it, one way to have all threads process the types of any other thread is to\n- block completion of registering a new thread's examplar until all other existing threads connected to the registry have signaled they have attached behaviors to the new examplar\n- somehow be able to have existing threads process new examplars while they're currently executing\n\nThere doesn't seem to be a good way to explain in terms of initialization and messaging the kind of preemption required by introducing a new thread's types to other connected threads that are potentially in busy loops. Maybe it demonstrates that \"attach behavior\" is not sufficient, and it likely means the registration mechanism has to be language specified instead, which kinda saddens me.","format":"org.matrix.custom.html","formatted_body":"<p>Thinking more about it, one way to have all threads process the types of any other thread is to</p>\n<ul>\n<li>block completion of registering a new thread's examplar until all other existing threads connected to the registry have signaled they have attached behaviors to the new examplar</li>\n<li>somehow be able to have existing threads process new examplars while they're currently executing</li>\n</ul>\n<p>There doesn't seem to be a good way to explain in terms of initialization and messaging the kind of preemption required by introducing a new thread's types to other connected threads that are potentially in busy loops. Maybe it demonstrates that \"attach behavior\" is not sufficient, and it likely means the registration mechanism has to be language specified instead, which kinda saddens me.</p>\n","msgtype":"m.text"},"ts":1695130853339,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$8imMdsd6WAOo14QRw9wJSKGuAnwgtUUdx2YD5xg32mw"}
]