[
{"content":{"body":"> <@shuyuguo:matrix.org> though those restriction just as well applies to shared structs\n\nMakes sense but do these things work with non-shared structs?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24DP_PsKzcpYWEkYaBoAAYJhxXYYdGl3WibkM6_rX6iQQ\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>though those restriction just as well applies to shared structs</blockquote></mx-reply>Makes sense but do these things work with non-shared structs?","m.relates_to":{"m.in_reply_to":{"event_id":"$DP_PsKzcpYWEkYaBoAAYJhxXYYdGl3WibkM6_rX6iQQ"}},"msgtype":"m.text"},"ts":1705799160673,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Nrv3AnIhvm3aXAqFkAdenFk2JguHx2wkxzutK3h7E7o"},
{"content":{"body":"> <@shuyuguo:matrix.org> one idea that was raised was additional restrictions on methods declared within structs, like making them always throw on instances of different types, and making them unbindable (unrelated ideas)\n\nWhy is the unbindable restriction an optimization?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24nfG8yzWSa6v4CMCf_OTBxJlN5e2E3hFHSne0il8_g4g\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>one idea that was raised was additional restrictions on methods declared within structs, like making them always throw on instances of different types, and making them unbindable (unrelated ideas)</blockquote></mx-reply>Why is the unbindable restriction an optimization?","m.relates_to":{"m.in_reply_to":{"event_id":"$nfG8yzWSa6v4CMCf_OTBxJlN5e2E3hFHSne0il8_g4g"}},"msgtype":"m.text"},"ts":1705799228607,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$JXztJ2J6yikKF-Q6VvFy_LrD28AVqVK4LSF2iKohcmU"},
{"content":{"body":"> <@shuyuguo:matrix.org> we have ideas there, but i kinda don't want them to lump those ideas into this proposal at the moment. namely, when i discussed with V8 staff, the sentiment was that explicit classes that don't change layout aren't necessarily more performant than hidden classes from a megamorphism POV, but we may have opportunities in layering additional restrictions on top to aid performance\n\nThe concern is often that some aspect of the restrictions “doesn’t necessarily” reduce hidden megamorphism; this seems true but I wonder how we could evaluate empirically the frequency of how much this helps (and maybe even compare vs, eg, type system features to encourage people to program a particular way)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24pDEQRDG5ftXqP30Rd12fnMMyrYUTUDOCl4k0kIVhemk\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>we have ideas there, but i kinda don't want them to lump those ideas into this proposal at the moment. namely, when i discussed with V8 staff, the sentiment was that explicit classes that don't change layout aren't necessarily more performant than hidden classes from a megamorphism POV, but we may have opportunities in layering additional restrictions on top to aid performance</blockquote></mx-reply>The concern is often that some aspect of the restrictions “doesn’t necessarily” reduce hidden megamorphism; this seems true but I wonder how we could evaluate empirically the frequency of how much this helps (and maybe even compare vs, eg, type system features to encourage people to program a particular way)","m.relates_to":{"m.in_reply_to":{"event_id":"$pDEQRDG5ftXqP30Rd12fnMMyrYUTUDOCl4k0kIVhemk"}},"msgtype":"m.text"},"ts":1705799438507,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5yIkHWeNjSUkZ-VcsyOhgX8R2i9PnpivdO9ZLMMvnD4"}
]