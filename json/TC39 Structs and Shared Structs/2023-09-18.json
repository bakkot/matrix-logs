[
{"content":{"body":"> <@rbuckton:matrix.org> I'm still tinkering with my parallel parse prototype, and I'm planning to try it on a few large scale projects. I'm not currently seeing the perf-gains I would hope, but its too early to say if its an issue with the shared structs functionality, the size of the projects I've been using for testing, or something about how I've had to hack around parts of the compiler to get something functional.\n> I wrote a rudimentary work-stealing thread pooling mechanism, but I'm finding that adding more threads slows down parse rather than speeding it up for the monorepo I've been using as a test case. CPU profiling shows a lot of the threads aren't processing work efficiently, and are either spinning around trying to steal work or are waiting to be notified of work. Spinning isn't very efficient because there's no spin-wait mechanism nor the ability to write an efficient one (I can sort-of approximate one using `Condition.wait` with a short timeout to emulate `sleep`, but I can't efficiently yield). I also can't write efficient lock-free algorithms with shared structs alone, since I can't do CAS, so the fastest \"lock-free\"-ish updates I can perform are inside of a `Mutex.tryLock` unless I want to fall back to also sending a `SharedArrayBuffer` to the worker just so I can use `Atomics.compareExchange`.\n> \n> Here's a rough approximation of the thread pool I'm using right now, if anyone has suggestions or feedback: https://gist.github.com/rbuckton/3648f878595ed4e2ff3d52a15baaf6b9\n\nLooks good to me. Have you experimented with batch sizes? Each task being N files, rather than 1:1 task file ratio?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24k0312Le1qqzBZ_AgI-7QIdIsuBN7__7Fv949n6o_JYs\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>I'm still tinkering with my parallel parse prototype, and I'm planning to try it on a few large scale projects. I'm not currently seeing the perf-gains I would hope, but its too early to say if its an issue with the shared structs functionality, the size of the projects I've been using for testing, or something about how I've had to hack around parts of the compiler to get something functional.<br>I wrote a rudimentary work-stealing thread pooling mechanism, but I'm finding that adding more threads slows down parse rather than speeding it up for the monorepo I've been using as a test case. CPU profiling shows a lot of the threads aren't processing work efficiently, and are either spinning around trying to steal work or are waiting to be notified of work. Spinning isn't very efficient because there's no spin-wait mechanism nor the ability to write an efficient one (I can sort-of approximate one using <code>Condition.wait</code> with a short timeout to emulate <code>sleep</code>, but I can't efficiently yield). I also can't write efficient lock-free algorithms with shared structs alone, since I can't do CAS, so the fastest \"lock-free\"-ish updates I can perform are inside of a <code>Mutex.tryLock</code> unless I want to fall back to also sending a <code>SharedArrayBuffer</code> to the worker just so I can use <code>Atomics.compareExchange</code>.</p>\n<p>Here's a rough approximation of the thread pool I'm using right now, if anyone has suggestions or feedback: https://gist.github.com/rbuckton/3648f878595ed4e2ff3d52a15baaf6b9</p>\n</blockquote></mx-reply>Looks good to me. Have you experimented with batch sizes? Each task being N files, rather than 1:1 task file ratio?","m.relates_to":{"m.in_reply_to":{"event_id":"$k0312Le1qqzBZ_AgI-7QIdIsuBN7__7Fv949n6o_JYs"}},"msgtype":"m.text"},"ts":1695034188663,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$9M9vnCNsGPYBWpCAzVYNm_KkSZpqIjQJyMhQev5i_-w"},
{"content":{"body":"Also wondering how much the tasks are known up front (one main glob) vs discovered as imports are found. I.e how well the queue can stay pumped?","format":"org.matrix.custom.html","formatted_body":"Also wondering how much the tasks are known up front (one main glob) vs discovered as imports are found. I.e how well the queue can stay pumped?","msgtype":"m.text"},"ts":1695034256958,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$UCcwcvuX_i10r8S-dgrZO2TOz-RXkPY_GH7ECIGp134"},
{"content":{"body":"Tasks are 1:1 per file. With work stealing, batching would be less efficient since you could have threads sitting idle. ","format":"org.matrix.custom.html","formatted_body":"Tasks are 1:1 per file. With work stealing, batching would be less efficient since you could have threads sitting idle.","msgtype":"m.text"},"ts":1695034586704,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$iXwgVd6cmHGEs_cVQITsL1b07tkkx666eI4kq3IVlfQ"},
{"content":{"body":"How much is known upfront depends on the tsconfig `files`, `include`, and `exclude` options, though I'm using a striping approach to try to collect all imports/references for each pass around the file list. ","format":"org.matrix.custom.html","formatted_body":"How much is known upfront depends on the tsconfig <code>files</code>, <code>include</code>, and <code>exclude</code> options, though I'm using a striping approach to try to collect all imports/references for each pass around the file list.","msgtype":"m.text"},"ts":1695034728425,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lQl_UEZJCUa5yrCQCLsljpTbvHjONBykWFPCAIIb5dA"},
{"content":{"body":"I need to experiment with a few more projects of different sizes though, it's still fairly early yet. ","format":"org.matrix.custom.html","formatted_body":"I need to experiment with a few more projects of different sizes though, it's still fairly early yet.","msgtype":"m.text"},"ts":1695034799871,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FtXUEnpZkXJUMvLt_XF9AmJ4DTTArTJ6QDMAb1-fmKk"},
{"content":{"body":"The current approach is still very waterfall like in the main thread. I would need to do a lot more work to have the child threads scan for imports/references so they don't have to constantly wait for the main thread to hand out more work. ","format":"org.matrix.custom.html","formatted_body":"The current approach is still very waterfall like in the main thread. I would need to do a lot more work to have the child threads scan for imports/references so they don't have to constantly wait for the main thread to hand out more work.","msgtype":"m.text"},"ts":1695034953531,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4CmcJ4fAhuwsT0fDnbpM0iCZZ0cdH02Fgm8980eGxS0"},
{"content":{"body":"Unfortunately, program.ts is very callback heavy and dependent on caches that would *also* need to be shared. ","format":"org.matrix.custom.html","formatted_body":"Unfortunately, program.ts is very callback heavy and dependent on caches that would <em>also</em> need to be shared.","msgtype":"m.text"},"ts":1695035046959,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Hw1DHkC8eoOVjo6X8ENTcK1O4mKkJPqDxVZtQy-VTOA"},
{"content":{"body":"There's a lot of idle time waiting for main right now","msgtype":"m.text"},"ts":1695035102798,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jo7jwZzAWVjh_a_cGrbCUmqDBn9OU5hnuGsbYuzHJto"},
{"content":{"body":"I currently have a synchronized, shareable `Map`-like data structure I can use for that, but I may want to see if I can build a lock-free, concurrent Map first so there's less blocking involved","format":"org.matrix.custom.html","formatted_body":"I currently have a synchronized, shareable <code>Map</code>-like data structure I can use for that, but I may want to see if I can build a lock-free, concurrent Map first so there's less blocking involved","msgtype":"m.text"},"ts":1695035284489,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HaAXSR3d1YclXh-r2BbHPWn1kpVWuXphCAvJhVOEJrI"},
{"content":{"body":"> <@rbuckton:matrix.org> Tasks are 1:1 per file. With work stealing, batching would be less efficient since you could have threads sitting idle.\n\ntrue tho that assumes the queuing system is zero-cost (no padding around tasks). So might work out that some batching, while theoretically less efficient at packing, leads to better results.\nJust an idea :) ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$iXwgVd6cmHGEs_cVQITsL1b07tkkx666eI4kq3IVlfQ?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Tasks are 1:1 per file. With work stealing, batching would be less efficient since you could have threads sitting idle.</blockquote></mx-reply>true tho that assumes the queuing system is zero-cost (no padding around tasks). So might work out that some batching, while theoretically less efficient at packing, leads to better results.<br>Just an idea :)","m.relates_to":{"m.in_reply_to":{"event_id":"$iXwgVd6cmHGEs_cVQITsL1b07tkkx666eI4kq3IVlfQ"}},"msgtype":"m.text"},"ts":1695040012862,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$ccgvBflUxHTJ5b5dl1V0DAxHx47iPITAxeDw7SYz_ZA"},
{"content":{"body":"In an ideal world parsing the largest files first would also be ideal for work stealing, though finding the largest files may be more costly than that saves too","msgtype":"m.text"},"ts":1695040096925,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$HeD-1jqMrVVIQLsPiNKiaQQlQdiM4yQCMbYksWrPOBY"},
{"content":{"body":"is there slides of update?","msgtype":"m.text"},"ts":1695042547471,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Fzn8L3ezNnAhGxk_BU4iliWtzpN8vNcBJNoaGZLQKow"},
{"content":{"body":"I'm excited about the progress you've made and want to know more details! I can't wait!","msgtype":"m.text"},"ts":1695042581521,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$TWkLd_Q_gWJ45vr6x23Mkdn9J8EeeuB1y99yMflddUQ"},
{"content":{"body":"Jack Works: there are in fact no slides yet :(","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jackworks:matrix.org\">Jack Works</a>: there are in fact no slides yet :(","msgtype":"m.text"},"ts":1695048215324,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Vhvaev2U5Rsb_Zn3fuvX1IZgYWNUTrAo4sGenO1fGTI"},
{"content":{"body":"got so much to do this week","msgtype":"m.text"},"ts":1695048219239,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Pg_RLSUJazWglUKY614GduBDgAKC1C-kSiiJ5uxhS4M"},
{"content":{"body":"rbuckton: i wonder if also web workers sucking somehow is getting in the way of your performance? this is node though so who knows, might be unrelated to web workers even if its worker implementation were less than ideal","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: i wonder if also web workers sucking somehow is getting in the way of your performance? this is node though so who knows, might be unrelated to web workers even if its worker implementation were less than ideal","msgtype":"m.text"},"ts":1695048258193,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$1x6DMJpPaTlzpUFYUccvbemPJSDzDQWaO_LhgqiQnA4"},
{"content":{"body":"> <@aclaymore:matrix.org> true tho that assumes the queuing system is zero-cost (no padding around tasks). So might work out that some batching, while theoretically less efficient at packing, leads to better results.\n> Just an idea :)\n\nYou are possibly correct, though that is a level of fine tuning I'm not anywhere near investigating yet.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$ccgvBflUxHTJ5b5dl1V0DAxHx47iPITAxeDw7SYz_ZA?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br>true tho that assumes the queuing system is zero-cost (no padding around tasks). So might work out that some batching, while theoretically less efficient at packing, leads to better results.<br />Just an idea :)</blockquote></mx-reply>You are possibly correct, though that is a level of fine tuning I'm not anywhere near investigating yet.","m.relates_to":{"m.in_reply_to":{"event_id":"$ccgvBflUxHTJ5b5dl1V0DAxHx47iPITAxeDw7SYz_ZA"}},"msgtype":"m.text"},"ts":1695053007413,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zevSt-sQzmpAZfRBldG4hPRWz2KdQKZtgrBwg7igQ20"},
{"content":{"body":"> <@shuyuguo:matrix.org> rbuckton: i wonder if also web workers sucking somehow is getting in the way of your performance? this is node though so who knows, might be unrelated to web workers even if its worker implementation were less than ideal\n\nAre you imagining there is overhead to reading/writing from shared structs or using mutex/condition caused by the worker? Or are you talking about overhead due as a result of setup, postMessage, etc.?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$1x6DMJpPaTlzpUFYUccvbemPJSDzDQWaO_LhgqiQnA4?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br><a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: i wonder if also web workers sucking somehow is getting in the way of your performance? this is node though so who knows, might be unrelated to web workers even if its worker implementation were less than ideal</blockquote></mx-reply>Are you imagining there is overhead to reading/writing from shared structs or using mutex/condition caused by the worker? Or are you talking about overhead due as a result of setup, postMessage, etc.?","m.relates_to":{"m.in_reply_to":{"event_id":"$1x6DMJpPaTlzpUFYUccvbemPJSDzDQWaO_LhgqiQnA4"}},"msgtype":"m.text"},"ts":1695053089981,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PeXhd3iFvgbRaFugIou2tc8K5_YGfls3vdKvOA2CZec"},
{"content":{"body":"I've updated the thread pool example to use a lock free Chase-Lev deque, though it still uses a Mutex/Condition to put the thread to sleep when there's no work to do.","msgtype":"m.text"},"ts":1695056915457,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nM0t_9ikW97kliKOuq632fwC30LI6caYBDyTq5WG-_E"},
{"content":{"body":"It's still somewhat inefficient if a thread ends up sleeping and a task is added to a queue for a different thread that is still active.","msgtype":"m.text"},"ts":1695057960758,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IN1bnnpzpQSPetvBWLXAsFAPGtO7H6FwW-1VFC54SH8"},
{"content":{"body":"Reading all this, I am still curious to understand how Shared Struct help compared to a synchronization mechanism (to implement a thread pool) coupled with an efficient message passing. How much actual shared mutable state is necessary?","msgtype":"m.text"},"ts":1695064565145,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$cKsSdE1ktI02O2m9ChSMinLZIFcrxm2mNDIP8aBIGqg"},
{"content":{"body":"What would you consider to be \"efficient message passing\"? ","msgtype":"m.text"},"ts":1695066708726,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dFH8Ub_URqh6R41kZ3dpFj_C-gob69JskpSB4j_NozY"},
{"content":{"body":"The lion's share of what TypeScript would send back and forth for parallel parse is essentially immutable, but a lot of the smaller data structures I need just to do coordination require shared mutable state.","msgtype":"m.text"},"ts":1695066793519,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cbYHfmZT7I6ZFzRSQIYsqMoJjnp5O7Rd5jM5DwVQINI"},
{"content":{"body":"If I wanted to write my own `malloc`/`free` over a growable `SharedArrayBuffer` as a heap, I could mostly do the same things as what we can do with Shared Structs, albeit *far* slower due to the need for wrappers and indirection, plus I would have to handle string encoding/decoding on my own and could never shrink the size heap. Shared structs are far more efficient in this regard.","format":"org.matrix.custom.html","formatted_body":"If I wanted to write my own <code>malloc</code>/<code>free</code> over a growable <code>SharedArrayBuffer</code> as a heap, I could mostly do the same things as what we can do with Shared Structs, albeit <em>far</em> slower due to the need for wrappers and indirection, plus I would have to handle string encoding/decoding on my own and could never shrink the size heap. Shared structs are far more efficient in this regard.","msgtype":"m.text"},"ts":1695066907476,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Rbo1InhnvvrENTjxb8wUi93jbMuBkLBSpYQmf3fjd1U"},
{"content":{"body":"And when I say \"could mostly do the same things\", I mean \"have done something very similar\" with https://esfx.js.org/esfx/api/struct-type.html, with the downside that it requires fixed sized types for fields and everything is laid out flat within a `SharedArrayBuffer`.","format":"org.matrix.custom.html","formatted_body":"And when I say \"could mostly do the same things\", I mean \"have done something very similar\" with https://esfx.js.org/esfx/api/struct-type.html, with the downside that it requires fixed sized types for fields and everything is laid out flat within a <code>SharedArrayBuffer</code>.","msgtype":"m.text"},"ts":1695067110453,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$neVzz1tEn2ZUS4ICMpohPbCBwbj6EgSg8y-kdK5-94Q"},
{"content":{"body":"(and it doesn't support arbitrary string values)","msgtype":"m.text"},"ts":1695067145587,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ie043kcndtJjw1KYbKqOyPAPQN3TrE-1uHZMPyJL2Nc"},
{"content":{"body":"> <@rbuckton:matrix.org> Are you imagining there is overhead to reading/writing from shared structs or using mutex/condition caused by the worker? Or are you talking about overhead due as a result of setup, postMessage, etc.?\n\ni was thinking the latter, and scheduling","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$PeXhd3iFvgbRaFugIou2tc8K5_YGfls3vdKvOA2CZec?via=matrix.org&via=igalia.com&via=tchncs.de\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Are you imagining there is overhead to reading/writing from shared structs or using mutex/condition caused by the worker? Or are you talking about overhead due as a result of setup, postMessage, etc.?</blockquote></mx-reply>i was thinking the latter, and scheduling","m.relates_to":{"m.in_reply_to":{"event_id":"$PeXhd3iFvgbRaFugIou2tc8K5_YGfls3vdKvOA2CZec"}},"msgtype":"m.text"},"ts":1695068957123,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$nIhmTRfrA_tVzEqW1Pn2OCslDKvZZW7ZJoMY9GXe0f4"},
{"content":{"body":"> <@mhofman:matrix.org> Reading all this, I am still curious to understand how Shared Struct help compared to a synchronization mechanism (to implement a thread pool) coupled with an efficient message passing. How much actual shared mutable state is necessary?\n\nmy thinking has always been single-writer XOR multiple-reader kind of data sharing will get you pretty far","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$cKsSdE1ktI02O2m9ChSMinLZIFcrxm2mNDIP8aBIGqg?via=matrix.org&via=igalia.com&via=tchncs.de\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Reading all this, I am still curious to understand how Shared Struct help compared to a synchronization mechanism (to implement a thread pool) coupled with an efficient message passing. How much actual shared mutable state is necessary?</blockquote></mx-reply>my thinking has always been single-writer XOR multiple-reader kind of data sharing will get you pretty far","m.relates_to":{"m.in_reply_to":{"event_id":"$cKsSdE1ktI02O2m9ChSMinLZIFcrxm2mNDIP8aBIGqg"}},"msgtype":"m.text"},"ts":1695069042491,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$auOV_-vUHouqyf1G1IS2qZg72nLNNd5THk4eSsDcf5Y"},
{"content":{"body":"I guess I'm wondering how these small data structures for synchronization are used, how much they need to do, and if there's any way to abstract them into higher level concepts. The immutable data could be passed as messages, and does not need to be based on shared struct from what I gather. I am basically still worried we're designing a blunt tool that will be abused when alternatives would be more aligned with the JS ecosystem.","msgtype":"m.text"},"ts":1695069052224,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$qYF6-qHdW-fRH6jc-Vq85ZD9I39m3jdBvEvllZ_KmjM"},
{"content":{"body":"but if your application wants mutable shared state there is no alternative","msgtype":"m.text"},"ts":1695069068391,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$4uPX_1ZwBAUsRXojDzim-Z0qbdTqew8lr-ZdLteP8eY"},
{"content":{"body":"i continue to strongly disagree with this handwringing about abuse","msgtype":"m.text"},"ts":1695069136992,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$lXz0T0qcVxFRfJdrjQFg7jD_c7lYoO-K7XE2GZ_jxJY"},
{"content":{"body":"but i think we remain agreed that shared mutable state is a bad thing to entice people into reaching for from the get go","msgtype":"m.text"},"ts":1695069839607,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$qrWNnMV3giHAzraSNvlkiq-uRdYKuJapJLsCFD0wPzo"},
{"content":{"body":"> <@shuyuguo:matrix.org> i was thinking the latter, and scheduling\n\nFor TypeScript, I'm not using postMessage at all except for the built-in one NodeJS does to pass the initial value of `workerData`, so that wouldn't be the cause. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$nIhmTRfrA_tVzEqW1Pn2OCslDKvZZW7ZJoMY9GXe0f4?via=matrix.org&via=igalia.com&via=tzchat.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br />i was thinking the latter, and scheduling</blockquote></mx-reply>For TypeScript, I'm not using postMessage at all except for the built-in one NodeJS does to pass the initial value of <code>workerData</code>, so that wouldn't be the cause.","m.relates_to":{"m.in_reply_to":{"event_id":"$nIhmTRfrA_tVzEqW1Pn2OCslDKvZZW7ZJoMY9GXe0f4"}},"msgtype":"m.text"},"ts":1695070837075,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Q8unRAGLeyHWxHBIinfb_RA1w-fQ9tC5Opp6-WhjaSg"},
{"content":{"body":"> <@mhofman:matrix.org> I guess I'm wondering how these small data structures for synchronization are used, how much they need to do, and if there's any way to abstract them into higher level concepts. The immutable data could be passed as messages, and does not need to be based on shared struct from what I gather. I am basically still worried we're designing a blunt tool that will be abused when alternatives would be more aligned with the JS ecosystem.\n\nThe problem is that concurrency and coordination often requires far more complex coordination primitives than we are likely to ship in the standard library. With the implementation in the origin trial, I can easily build these more complex coordination capabilities out of the primitives we have through the use of mutable shared state. If we are limited to only a few built-in mutable and shareable data structures and everything else is immutable, then it is possible this proposal won't meet the needs of the applications that need this capability the most.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$qYF6-qHdW-fRH6jc-Vq85ZD9I39m3jdBvEvllZ_KmjM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I guess I&#39;m wondering how these small data structures for synchronization are used, how much they need to do, and if there&#39;s any way to abstract them into higher level concepts. The immutable data could be passed as messages, and does not need to be based on shared struct from what I gather. I am basically still worried we&#39;re designing a blunt tool that will be abused when alternatives would be more aligned with the JS ecosystem.</blockquote></mx-reply>The problem is that concurrency and coordination often requires far more complex coordination primitives than we are likely to ship in the standard library. With the implementation in the origin trial, I can easily build these more complex coordination capabilities out of the primitives we have through the use of mutable shared state. If we are limited to only a few built-in mutable and shareable data structures and everything else is immutable, then it is possible this proposal won't meet the needs of the applications that need this capability the most.","m.relates_to":{"m.in_reply_to":{"event_id":"$qYF6-qHdW-fRH6jc-Vq85ZD9I39m3jdBvEvllZ_KmjM"}},"msgtype":"m.text"},"ts":1695071087007,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jwL01yQqeMt-bOqDTiEpbNkOoIoreMZMkBS6RoSjAJw"},
{"content":{"body":"That's not saying we shouldn't *also* have immutable data structures, or at least the ability to freeze all or part of a shared struct, as I'd like those too.","format":"org.matrix.custom.html","formatted_body":"That's not saying we shouldn't <em>also</em> have immutable data structures, or at least the ability to freeze all or part of a shared struct, as I'd like those too.","msgtype":"m.text"},"ts":1695071156119,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YK4E703mGqqTNwEBJLuea5fqrK8ZPJK24pH6kfXN-mo"},
{"content":{"body":"rbuckton: yeah that all tracks exactly with my intuition","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: yeah that all tracks exactly with my intuition","msgtype":"m.text"},"ts":1695071180693,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$K9PLJeJKFe_MpkFbmzqIJJcEy2f2N5lywuuN-noqEIE"},
{"content":{"body":"Even though I would consider most of the TypeScript AST to be immutable, that's not exactly true. It's immutable to our consumers, but we need to be able to attach additional shared data ourselves.","msgtype":"m.text"},"ts":1695071211107,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$pUrrBetif8QKifFXfJRoPFWmuo6ui4Kt3xsi0h2_9TQ"},
{"content":{"body":"for example, I may build a `SourceFile` and its AST in parallel parse, but this file hasn't been bound and had its symbols and exports recorded yet. Once parse is complete, we hand the entire program off to the binder which could also do its work in parallel.","format":"org.matrix.custom.html","formatted_body":"for example, I may build a <code>SourceFile</code> and its AST in parallel parse, but this file hasn't been bound and had its symbols and exports recorded yet. Once parse is complete, we hand the entire program off to the binder which could also do its work in parallel.","msgtype":"m.text"},"ts":1695071285886,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cM5grddFEYkWPVclLyIJL4vq-260R2KA1jGe16lHTyI"},
{"content":{"body":"in the back of my mind i'm still thinking about the viability of dynamic \"ownership\" tracking, for lack of a better word. by \"ownership\" i mean single writer XOR multiple readers","msgtype":"m.text"},"ts":1695071336380,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$RYJSSxiEEusfkFrz34qivk1BPIy7U1pv0dE4Uvol-gY"},
{"content":{"body":"And while our emitter uses tree transformations that produce a new AST for changed subtrees, we still reuse unchanged subtrees as much as possible, and need to attach additional information about how those original nodes should be handled during emit as well. ","msgtype":"m.text"},"ts":1695071378717,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$szQX1GwOA5udfGLeucQf2hOIVqRlrBDzzXApgonAgEo"},
{"content":{"body":"Weak Maps and thread-local state don't help there as I may want to parallelize emit and transformation for subtrees as well, which means handing parts of the tree off to other threads.","msgtype":"m.text"},"ts":1695071447816,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bAgVisZFvZcFc4bc0AWhdAD-EAXzvIGCrIY672t0O5M"},
{"content":{"body":"> <@shuyuguo:matrix.org> in the back of my mind i'm still thinking about the viability of dynamic \"ownership\" tracking, for lack of a better word. by \"ownership\" i mean single writer XOR multiple readers\n\nOn a per-instance level, or something less fine grained? In my TypeScript experiment I wrote a `SharedMutex` that supports single writer (exclusive) locks and multiple reader (shared) locks on top of the ones you provide on `Atomic`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$RYJSSxiEEusfkFrz34qivk1BPIy7U1pv0dE4Uvol-gY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>in the back of my mind i&#39;m still thinking about the viability of dynamic &quot;ownership&quot; tracking, for lack of a better word. by &quot;ownership&quot; i mean single writer XOR multiple readers</blockquote></mx-reply>On a per-instance level, or something less fine grained? In my TypeScript experiment I wrote a <code>SharedMutex</code> that supports single writer (exclusive) locks and multiple reader (shared) locks on top of the ones you provide on <code>Atomic</code>.","m.relates_to":{"m.in_reply_to":{"event_id":"$RYJSSxiEEusfkFrz34qivk1BPIy7U1pv0dE4Uvol-gY"}},"msgtype":"m.text"},"ts":1695071558988,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ysmVaTg9Z0PYzUUuW4PL3VtNl7tXgWiSe_6V06WeXa4"},
{"content":{"body":"> <@shuyuguo:matrix.org> in the back of my mind i'm still thinking about the viability of dynamic \"ownership\" tracking, for lack of a better word. by \"ownership\" i mean single writer XOR multiple readers\n\n * On a per-instance level, or something less fine grained? In my TypeScript experiment I wrote a `SharedMutex` that supports single writer (exclusive) locks and multiple reader (shared) locks on top of the ones you provide on `Atomics`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$RYJSSxiEEusfkFrz34qivk1BPIy7U1pv0dE4Uvol-gY?via=matrix.org&amp;via=igalia.com&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>in the back of my mind i'm still thinking about the viability of dynamic \"ownership\" tracking, for lack of a better word. by \"ownership\" i mean single writer XOR multiple readers</blockquote></mx-reply> * On a per-instance level, or something less fine grained? In my TypeScript experiment I wrote a <code>SharedMutex</code> that supports single writer (exclusive) locks and multiple reader (shared) locks on top of the ones you provide on <code>Atomics</code>.","m.new_content":{"body":"On a per-instance level, or something less fine grained? In my TypeScript experiment I wrote a `SharedMutex` that supports single writer (exclusive) locks and multiple reader (shared) locks on top of the ones you provide on `Atomics`.","format":"org.matrix.custom.html","formatted_body":"On a per-instance level, or something less fine grained? In my TypeScript experiment I wrote a <code>SharedMutex</code> that supports single writer (exclusive) locks and multiple reader (shared) locks on top of the ones you provide on <code>Atomics</code>.","msgtype":"m.text"},"m.relates_to":{"event_id":"$ysmVaTg9Z0PYzUUuW4PL3VtNl7tXgWiSe_6V06WeXa4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695071569162,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$o60l-HPp2UykT6W_JrSvkpFaTCvsHGwXvUfF5jEbl84"},
{"content":{"body":"rbuckton: on a per-instance level","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: on a per-instance level","msgtype":"m.text"},"ts":1695071665811,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mIGvUNIb9U5eIgJ4pzfqvSmFeFmGe6Lj6qcTX-koUQA"},
{"content":{"body":"That sounds potentially expensive?","msgtype":"m.text"},"ts":1695071697728,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$qiKO4mf5FVPCwyybnd7r3nvbaJezFa39Fe8gAGehP0U"},
{"content":{"body":"not to provide ordering, or blocking until reading is available, but to e.g. throw, or provide query APIs for whether it's currently safe to read","msgtype":"m.text"},"ts":1695071699948,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$UAyWV5g4bc0xhRhgQfXTuZ8mS18d8xLyzY8Y1VJ50F8"},
{"content":{"body":"indeed, that's why i've punted on it","msgtype":"m.text"},"ts":1695071704084,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$b4yMyHBdKgqn2jlnHY7lLItAZ8QQp24M6Zc4ilXmJq4"},
{"content":{"body":"there is a 2-bit lock-free scheme, but that still means an additional load and branch on every access, and then an additional CAS on state changes","msgtype":"m.text"},"ts":1695071744707,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$aR1qjJA_t5s4z1wAmbru_d3xVkr5HvBgmwAOAVwOuD0"},
{"content":{"body":"2 bits are needed to transition the state between \"unused\", \"being read\", and \"being written to\"","msgtype":"m.text"},"ts":1695071776413,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$meQ5jjLMBDOCwiqZU4xVLd5SkJOfz-PEznyy9p4PgO8"},
{"content":{"body":"My intuition is that if you're writing JS code that really needs multiple threads of execution, then you want things to be as lean as possible with explicit opt-ins to anything slower or more complex.","msgtype":"m.text"},"ts":1695071792088,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HX5oTc15iWKXYUtaFMXDKF9p6bLkmDS36wq1QNF23mA"},
{"content":{"body":"that is my intuition as well for shared structs","msgtype":"m.text"},"ts":1695071810607,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$W6I-Nc7zQCP2oJkpC34ENFi2DhAshl0dO5A_lpj9o4g"},
{"content":{"body":"to be clear i'm thinking of these in the context of additions after the building blocks are there, to encourage a happy path that is a little less performant but a little more safe","msgtype":"m.text"},"ts":1695071840918,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$DhT3EEbiMTBZMa5CRFxDnmx80rVidBOxrR2dnIfbWIM"},
{"content":{"body":"but this is probably still too fine-grained to make the safety tradeoff worth it","msgtype":"m.text"},"ts":1695071858263,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$npCHZ2B2iCEYi5Aw5SxRyCwT6h1Iwo-MM2ylxVzIavw"},
{"content":{"body":"Was this related to the idea of snapshotting an object for mutation, and then applying the update atomically?","msgtype":"m.text"},"ts":1695071922690,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$De0ccFKHzHObdJMOiUMxgrlsbxJ43qgPvA7rZtj34zA"},
{"content":{"body":"the RCU approach?","msgtype":"m.text"},"ts":1695071993860,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$apY7EPsv9BMRZSuRUda55-ip1Djb466iD8cJI2cvAF4"},
{"content":{"body":"yep, in that vicinity for sure","msgtype":"m.text"},"ts":1695072005942,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$qVKwk1jCJb6mjUrY0A9pG-RnUSt3d4Ggh18CM8eyM5s"},
{"content":{"body":"A few years ago there was discussion about the \"monocle-mustache\" operator, and I wondered if it could be used for this, i.e.:\n\n```\nlet copy = obj.{ x, y };\ncopy.x++;\ncopy.y--;\nobj.{ x, y } = copy;\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>A few years ago there was discussion about the \"monocle-mustache\" operator, and I wondered if it could be used for this, i.e.:</p>\n<pre><code>let copy = obj.{ x, y };\ncopy.x++;\ncopy.y--;\nobj.{ x, y } = copy;\n</code></pre>\n","msgtype":"m.text"},"ts":1695072179161,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ruOHfgK9QnWcg2z_BOjRF0mK-yTBKMnpsgSXW8GXQbQ"},
{"content":{"body":"oh interesting","msgtype":"m.text"},"ts":1695072229283,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$tSsoXlYGcmR3e48F1XZ2c8RSIdoOylpV6xpRxgZ9coU"},
{"content":{"body":"and you're thinking of things between the { } as comprising a transaction?","msgtype":"m.text"},"ts":1695072239634,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Qzued0vVdaWrbyHvHgWibu2P3rC9CxSG15cH9JcA7RU"},
{"content":{"body":"i.e., normal JS objects could use it as a pick-operator for read, and like `Object.assign` for write, but shared structs could return a mutable snapshot that provides an atomic read of the requested values, and could perform an atomic write at the bottom.","format":"org.matrix.custom.html","formatted_body":"i.e., normal JS objects could use it as a pick-operator for read, and like <code>Object.assign</code> for write, but shared structs could return a mutable snapshot that provides an atomic read of the requested values, and could perform an atomic write at the bottom.","msgtype":"m.text"},"ts":1695072299815,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JCFYTX9nWNXv4aKLb0Os6KTWvvgyQS8i3D1WJgVQX_s"},
{"content":{"body":"cool idea though a little magical feeling","msgtype":"m.text"},"ts":1695072340211,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$_l3uzOh-HbxDuugztpU4kg02lt8IwyN9KbklFmvwLLA"},
{"content":{"body":"rbuckton: oh btw i wanted to poll your opinion before i made slides for the next meeting...","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: oh btw i wanted to poll your opinion before i made slides for the next meeting...","msgtype":"m.text"},"ts":1695072348820,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ePqpAFCRqamvkteSPBEGCrybKv0I7EFoMmn7Dinyrhc"},
{"content":{"body":"`.{` isn't new to most of the committee though, it's been discussed on and off for almost 9 years now, iirc.","format":"org.matrix.custom.html","formatted_body":"<code>.{</code> isn't new to most of the committee though, it's been discussed on and off for almost 9 years now, iirc.","msgtype":"m.text"},"ts":1695072375350,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DaG_70N-ooKclmnW5qKWjs_Q3pRi7Ug3ITVnagWM608"},
{"content":{"body":"just never formally presented.","msgtype":"m.text"},"ts":1695072385355,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$P0291n8J50q2iixoheq-CaGze4z4XT6xQBr-OrkL4iE"},
{"content":{"body":"since the current prototyping effort is to do agent-local/realm-local (i'd like to discuss the granularity during the meeting) fields, how do you think that should look in syntax?","msgtype":"m.text"},"ts":1695072387044,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$vZ4UOyfq-y1ZKXw1S6SXS_77Un51B_2OnlJ6yxI4uks"},
{"content":{"body":"we have precedent in auto accessors as having modifiers to fields","msgtype":"m.text"},"ts":1695072399485,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$D9rTtrm5cJWi3Xsmmr6_E7JXdqeTtMkppjXQ1dl7_So"},
{"content":{"body":"i was thinking like `agentlocal fieldName;` or something","format":"org.matrix.custom.html","formatted_body":"i was thinking like <code>agentlocal fieldName;</code> or something","msgtype":"m.text"},"ts":1695072413508,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Egrx0D6UHo3ph_dnPpLxuFWMgTLhkSMY0lXM2m_RAO8"},
{"content":{"body":"https://github.com/rtm/js-pick-notation for the pick notation, and I think there was some discussion in https://github.com/rbuckton/proposal-shorthand-improvements as well","msgtype":"m.text"},"ts":1695072488330,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UI9kCSOERpZ8-LdQWeLZtLXNqlToVJXDFsLiDV3kS-k"},
{"content":{"body":"> <@shuyuguo:matrix.org> i was thinking like `agentlocal fieldName;` or something\n\nIt's not terrible, I suppose? In other contexts/languages I might call it `threadlocal`, but another option might be `nonshared`? Especially if the struct syntax is something like `struct Foo {}` and `shared struct Bar {}`, declaring something as `nonshared` seems semantically consistent without needing to bring in terms like \"agent\"","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Egrx0D6UHo3ph_dnPpLxuFWMgTLhkSMY0lXM2m_RAO8?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>i was thinking like <code>agentlocal fieldName;</code> or something</blockquote></mx-reply>It's not terrible, I suppose? In other contexts/languages I might call it <code>threadlocal</code>, but another option might be <code>nonshared</code>? Especially if the struct syntax is something like <code>struct Foo {}</code> and <code>shared struct Bar {}</code>, declaring something as <code>nonshared</code> seems semantically consistent without needing to bring in terms like \"agent\"","m.relates_to":{"m.in_reply_to":{"event_id":"$Egrx0D6UHo3ph_dnPpLxuFWMgTLhkSMY0lXM2m_RAO8"}},"msgtype":"m.text"},"ts":1695072637915,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ojtfq6PP5mzX_1qLT4WvGzJ1gQFLTQkdfV4aUlWppIk"},
{"content":{"body":"yes, i don't love the name agent","msgtype":"m.text"},"ts":1695072675063,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$GqQg7r7M1tYbG_Dbr76SGAdsKfotQrspTY9n_QUJ03k"},
{"content":{"body":"i kinda like `nonshared`, though i wonder if it glosses over the per-thread/per-realm view aspect of the semantics","format":"org.matrix.custom.html","formatted_body":"i kinda like <code>nonshared</code>, though i wonder if it glosses over the per-thread/per-realm view aspect of the semantics","msgtype":"m.text"},"ts":1695072711633,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$gDSXr1iJUHHRJK2JpNpE94-Vz58g-R9cGvXtJU6piRo"},
{"content":{"body":"actually, the bigger possibility for confusion is that the modifier applies values, not the field itself","msgtype":"m.text"},"ts":1695072749767,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$op3fo4CXKMWxCH1PyJjMoLhnsWRx12GVIucrN62nJZ4"},
{"content":{"body":"kind of like the `const` confusion","format":"org.matrix.custom.html","formatted_body":"kind of like the <code>const</code> confusion","msgtype":"m.text"},"ts":1695072754040,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$MgcrKJQaKDLJIyXo0SGCajMNEALzb9EghsZj0vSnlDo"},
{"content":{"body":"We don't say \"agent\" in any of the Atomics APIs, despite those APIs having to do with memory ordering to support atomic writes across agents, so I don't think its that bad to avoid the terminology.","msgtype":"m.text"},"ts":1695072767665,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4bfAcF7E1q0T7i-cyxqIDvsJVBr6sD8PRSgii32Ao8M"},
{"content":{"body":"OTOH we already have that confusion, and the use of `nonshared` is consistent with how `const` modifies the binding","format":"org.matrix.custom.html","formatted_body":"OTOH we already have that confusion, and the use of <code>nonshared</code> is consistent with how <code>const</code> modifies the binding","msgtype":"m.text"},"ts":1695072778454,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$TFxIKBwETJyvZhLcKmf3G6Qsekbchz73CKVtM9LzNTw"},
{"content":{"body":"or maybe just `local`","format":"org.matrix.custom.html","formatted_body":"or maybe just <code>local</code>","msgtype":"m.text"},"ts":1695072799621,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5E64TNaMQd7ECNQ-FNbtxrpDE-BxsozSqCWPyU6KPZI"},
{"content":{"body":"though that's pretty vague","msgtype":"m.text"},"ts":1695072803357,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zMo3h8I8pe9-4xXKG-CcXqWGOsrhpcemoZIkPxgX1-M"},
{"content":{"body":"```\nshared struct Data {\n  x;\n  y;\n  nonshared foo;\n\n  // would methods need this keyword too, or automatically be considered nonshared?\n  method() { }\n\n  nonshared method2() {}\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>shared struct Data {\n  x;\n  y;\n  nonshared foo;\n\n  // would methods need this keyword too, or automatically be considered nonshared?\n  method() { }\n\n  nonshared method2() {}\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1695072830655,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ypORS9AfEIefQuKrVyRUZI7iwXJvTLzUESnhlyXgDSg"},
{"content":{"body":"`local` feels vague and has a different context in some other languages","format":"org.matrix.custom.html","formatted_body":"<code>local</code> feels vague and has a different context in some other languages","msgtype":"m.text"},"ts":1695072859244,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hWDSVZANF7yAXKdjAwvU1544AAYlYFpduXuKlLngma8"},
{"content":{"body":"i.e., in some languages, `local` refers to how you access shadowed variable bindings","format":"org.matrix.custom.html","formatted_body":"i.e., in some languages, <code>local</code> refers to how you access shadowed variable bindings","msgtype":"m.text"},"ts":1695072886564,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Fz_mnEJXMW5T8wbAj7x7Ma3OpOUFx7d_bfJ0GE5bGE8"},
{"content":{"body":"method declarations are currently just disallowed","msgtype":"m.text"},"ts":1695072925993,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ftDESyoqUQy3DORU2nWFEuRKbECWuxBiTLk0HHGbLPQ"},
{"content":{"body":"i don't know what it means to have that in a shared struct, without bringing in ideas we've talked about in the past like packaging it up as a module block that gets re-evaluated","msgtype":"m.text"},"ts":1695072947996,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5r9AAD7NWs4xkR7wtDBN4gnfCgBflFNvgYStXEzE3jA"},
{"content":{"body":"> <@shuyuguo:matrix.org> method declarations are currently just disallowed\n\nYes, but I'm imagining syntax based on what I hope we can get in the end, including an easy Developer experience for the prototype handshake for attaching behavior, as in the Gist I shared several weeks ago.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$ftDESyoqUQy3DORU2nWFEuRKbECWuxBiTLk0HHGbLPQ?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>method declarations are currently just disallowed</blockquote></mx-reply>Yes, but I'm imagining syntax based on what I hope we can get in the end, including an easy Developer experience for the prototype handshake for attaching behavior, as in the Gist I shared several weeks ago.","m.relates_to":{"m.in_reply_to":{"event_id":"$ftDESyoqUQy3DORU2nWFEuRKbECWuxBiTLk0HHGbLPQ"}},"msgtype":"m.text"},"ts":1695072991991,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8Nia74a0sDeUdkY46t11R-TjDUv1kVVXdpZ4ygCahAA"},
{"content":{"body":"I'm referring to this: ```\nshared struct Point","msgtype":"m.text"},"ts":1695073033326,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CXwl5e5kgvEBf7u3cdAXDjGOrSqpZSwtbcXqyMhd5t4"},
{"content":{"body":" * I'm referring to this: https://gist.github.com/rbuckton/08d020fc80da308ad3a1991384d4ff62","m.new_content":{"body":"I'm referring to this: https://gist.github.com/rbuckton/08d020fc80da308ad3a1991384d4ff62","msgtype":"m.text"},"m.relates_to":{"event_id":"$CXwl5e5kgvEBf7u3cdAXDjGOrSqpZSwtbcXqyMhd5t4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695073053049,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0LcXfZsplQUypD-fkU6UJ7q0HQegb3j5UNm5YL9yQrA"},
{"content":{"body":"> <@rbuckton:matrix.org> Yes, but I'm imagining syntax based on what I hope we can get in the end, including an easy Developer experience for the prototype handshake for attaching behavior, as in the Gist I shared several weeks ago.\n\nthen in that future i favor requiring `nonshared method() {}` and making `method() {}` a parse error, to make the semantics explicit","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$8Nia74a0sDeUdkY46t11R-TjDUv1kVVXdpZ4ygCahAA?via=matrix.org&via=igalia.com&via=tchncs.de\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Yes, but I'm imagining syntax based on what I hope we can get in the end, including an easy Developer experience for the prototype handshake for attaching behavior, as in the Gist I shared several weeks ago.</blockquote></mx-reply>then in that future i favor requiring <code>nonshared method() {}</code> and making <code>method() {}</code> a parse error, to make the semantics explicit","m.relates_to":{"m.in_reply_to":{"event_id":"$8Nia74a0sDeUdkY46t11R-TjDUv1kVVXdpZ4ygCahAA"}},"msgtype":"m.text"},"ts":1695073070505,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zviO4VokoJYaevNfhxY-eN5AgchiXCm-EKolaS2BZTs"},
{"content":{"body":"also, just in case by divine inspiration we manage to actually share functions in the future, somehow","msgtype":"m.text"},"ts":1695073101135,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5ed1ixoZOSgSHmab5FQOc4k2SijAV8ttoXXJ4IDtNo4"},
{"content":{"body":"essentially, the syntax covers multiple things:\n- Declaring the fields that are shared (with a convenient place to hang type annotations off of)\n- Declaring the fields that are not shared (specific to the current thread/agent/whatnot)\n- Declaring the construction logic that is not shared (specific to the current thread/etc.)\n- Declaring the instance methods that are not shared (specific to the current thread/etc.)\n- Declaring the static methods on the non-shared constructor.","format":"org.matrix.custom.html","formatted_body":"<p>essentially, the syntax covers multiple things:</p>\n<ul>\n<li>Declaring the fields that are shared (with a convenient place to hang type annotations off of)</li>\n<li>Declaring the fields that are not shared (specific to the current thread/agent/whatnot)</li>\n<li>Declaring the construction logic that is not shared (specific to the current thread/etc.)</li>\n<li>Declaring the instance methods that are not shared (specific to the current thread/etc.)</li>\n<li>Declaring the static methods on the non-shared constructor.</li>\n</ul>\n","msgtype":"m.text"},"ts":1695073198911,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$iPc8ILZc0iQOMdoz97tOq7rIB8HRoSY5I8PWO61Ez74"},
{"content":{"body":"i plan to reference that doc in the update sildes","msgtype":"m.text"},"ts":1695073247695,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$roAr9vsJSVbFbsrDKGo0USptKyvDBHLmI-QtOKsq11I"},
{"content":{"body":" * i plan to reference that doc in the update slides","m.new_content":{"body":"i plan to reference that doc in the update slides","msgtype":"m.text"},"m.relates_to":{"event_id":"$roAr9vsJSVbFbsrDKGo0USptKyvDBHLmI-QtOKsq11I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695073252969,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$eZ1pxCcrVDhowQ3q8SL5c7CfnmSzACOI-rM7QIdy3fE"},
{"content":{"body":"so, would you be suggesting it be this:\n\n```\nshared struct Foo {\n  x;\n  y;\n  \n  nonshared constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  nonshared toString() {\n    return `${this.x},${this.y}`;\n  }\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>so, would you be suggesting it be this:</p>\n<pre><code>shared struct Foo {\n  x;\n  y;\n  \n  nonshared constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  nonshared toString() {\n    return `${this.x},${this.y}`;\n  }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1695073274084,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mOVC9Q1OxjPwN9hhNXc1sU4v_oJTY2ZULYj5WxuMV4k"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1695073299758,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Cf_BO9vdk8yGc4vyZXpkHvqwBRRc5ZGRP0hbalSAiaY"},
{"content":{"body":"It seems somewhat redundant, IMO, unless you expect we would ever have the concept of a \"shared constructor\" or a \"shared method\"","msgtype":"m.text"},"ts":1695073314626,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Lp7OTYos1cH51kseaZ9fgm2SU9CI5ujnMT6Hkp9Qyjo"},
{"content":{"body":"(but to be clear i plan to leave out any mention of inline method declarations at all)","msgtype":"m.text"},"ts":1695073319383,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$D3wgZj-1zK5ugAKAgIPWnjwp0YJ5-C74m7IdMqJtQr0"},
{"content":{"body":"in this update stage","msgtype":"m.text"},"ts":1695073331858,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$aQ4oFD3P83S9oMQMKseMVjvDjh66kcddnorHotR5zNA"},
{"content":{"body":"btw, in the origin trial this has been pretty convenient in both JS and TS:\n\n```js\nclass Foo extends SharedStructType([\"x\", \"y\"]) {\n  constructor(x, y) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}","format":"org.matrix.custom.html","formatted_body":"<p>btw, in the origin trial this has been pretty convenient in both JS and TS:</p>\n<pre><code class=\"language-js\">class Foo extends SharedStructType([\"x\", \"y\"]) {\n  constructor(x, y) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1695073427067,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$q2xYS0Xr5GK-iOdVznV76L0mzn2Nmq06yX7QEkq7pvY"},
{"content":{"body":"> <@rbuckton:matrix.org> It seems somewhat redundant, IMO, unless you expect we would ever have the concept of a \"shared constructor\" or a \"shared method\"\n\ni don't at this time, but things could change? but that's not the main reason for my preference. the main reason is i want the syntax to be explicitly reflect the semantics","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Lp7OTYos1cH51kseaZ9fgm2SU9CI5ujnMT6Hkp9Qyjo?via=matrix.org&via=igalia.com&via=tchncs.de\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>It seems somewhat redundant, IMO, unless you expect we would ever have the concept of a &quot;shared constructor&quot; or a &quot;shared method&quot;</blockquote></mx-reply>i don't at this time, but things could change? but that's not the main reason for my preference. the main reason is i want the syntax to be explicitly reflect the semantics","m.relates_to":{"m.in_reply_to":{"event_id":"$Lp7OTYos1cH51kseaZ9fgm2SU9CI5ujnMT6Hkp9Qyjo"}},"msgtype":"m.text"},"ts":1695073447383,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ybKqvhyRhNxy6CwgNU3AKKZRXAE2ywOAcY-rLR2QdIo"},
{"content":{"body":"my personal design sense is i hate implicit stuff","msgtype":"m.text"},"ts":1695073470203,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xzTaBjGmVYUokCpi3hYb2osDRBP_FFwEWw6F1HrImWk"},
{"content":{"body":" * btw, in the origin trial this has been pretty convenient in both JS and TS:\n\n```ts\n// js\nclass Foo extends SharedStructType([\"x\", \"y\"]) {\n  constructor(x, y) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}\n\n// ts\nclass Foo extends SharedStructType([\"x\", \"y\"]) {\n  declare x: number;\n  declare y: number;\n  constructor(x: number, y: number) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>btw, in the origin trial this has been pretty convenient in both JS and TS:</p>\n<pre><code class=\"language-ts\">// js\nclass Foo extends SharedStructType([\"x\", \"y\"]) {\n  constructor(x, y) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}\n\n// ts\nclass Foo extends SharedStructType([\"x\", \"y\"]) {\n  declare x: number;\n  declare y: number;\n  constructor(x: number, y: number) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}\n</code></pre>\n","m.new_content":{"body":"btw, in the origin trial this has been pretty convenient in both JS and TS:\n\n```ts\n// js\nclass Foo extends SharedStructType([\"x\", \"y\"]) {\n  constructor(x, y) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}\n\n// ts\nclass Foo extends SharedStructType([\"x\", \"y\"]) {\n  declare x: number;\n  declare y: number;\n  constructor(x: number, y: number) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>btw, in the origin trial this has been pretty convenient in both JS and TS:</p>\n<pre><code class=\"language-ts\">// js\nclass Foo extends SharedStructType([\"x\", \"y\"]) {\n  constructor(x, y) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}\n\n// ts\nclass Foo extends SharedStructType([\"x\", \"y\"]) {\n  declare x: number;\n  declare y: number;\n  constructor(x: number, y: number) {\n    super();\n    this.x = x;\n    this.y = y;\n  }\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$q2xYS0Xr5GK-iOdVznV76L0mzn2Nmq06yX7QEkq7pvY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695073470368,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rz4POwMEO1Cn_PG9909j5VejPLQLo1NwY3PXuPFxYUQ"},
{"content":{"body":"As someone who has had chronic wrist pain due to a pretty severe break around 20 years ago, my opinion is the less redundancy and repetition when typing, the better.","msgtype":"m.text"},"ts":1695073577762,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zSf6t4q3ANyT0iJeQBbAO6ED-LrTrc2KkV0eDyIglbE"},
{"content":{"body":"though I agree with explicitness when necessary.","msgtype":"m.text"},"ts":1695073608285,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$v1eNr32f-N3lz6SZcjLHtUgN03AdScEnwwozXnvKEqI"},
{"content":{"body":"> <@rbuckton:matrix.org> As someone who has had chronic wrist pain due to a pretty severe break around 20 years ago, my opinion is the less redundancy and repetition when typing, the better.\n\nthat's good feedback","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$zSf6t4q3ANyT0iJeQBbAO6ED-LrTrc2KkV0eDyIglbE?via=matrix.org&via=igalia.com&via=tchncs.de\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>As someone who has had chronic wrist pain due to a pretty severe break around 20 years ago, my opinion is the less redundancy and repetition when typing, the better.</blockquote></mx-reply>that's good feedback","m.relates_to":{"m.in_reply_to":{"event_id":"$zSf6t4q3ANyT0iJeQBbAO6ED-LrTrc2KkV0eDyIglbE"}},"msgtype":"m.text"},"ts":1695073726847,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$3D_-lsetyskzBZQ6vJdPnI-ciww0--3gsxA2w3MCTBQ"},
{"content":{"body":"If you think we will ever come to a place were we can actually share code across threads or allow threads to coexeist with main thread application memory like they do in many other languages, then I would agree that we need the keyword to avoid painting ourselves into a corner.","msgtype":"m.text"},"ts":1695073739796,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$H7-ZllPpQ5kqShDY1JyJ1ppMt03c2bC2fP59k2q2eyk"},
{"content":{"body":"I always advocate for \"less ceremony is better\" when it comes to syntax, though not so much that I agree with using keywords like `pub`, `fn`, `def`.","format":"org.matrix.custom.html","formatted_body":"I always advocate for \"less ceremony is better\" when it comes to syntax, though not so much that I agree with using keywords like <code>pub</code>, <code>fn</code>, <code>def</code>.","msgtype":"m.text"},"ts":1695073801574,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vI1ffqzEGtx9GxW3YGyQb4UXaFVY0_Ydm53bUcZ6SSU"},
{"content":{"body":"`const`-aside","format":"org.matrix.custom.html","formatted_body":"<code>const</code>-aside","msgtype":"m.text"},"ts":1695073911044,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XBJaERruIizoaWuJ__M7DQmx4ocUWVm2RhOBCtTd2Qg"},
{"content":{"body":"One question with the syntax as proposed above is how do you attach nonshared properties / methods to a struct definition you received from another thread ","msgtype":"m.text"},"ts":1695074331982,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$AB9hB4IVWfsMQgC2ocxJqdIAQ5--U5ik8YqtY3R9PnU"},
{"content":{"body":"That's explained in the gist I linked above.","msgtype":"m.text"},"ts":1695074995680,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VL3Q61rH_bmcLfY1RuZmPOXEXjiwQs6RIgB7jyl_6Vc"},
{"content":{"body":"The gist proposes a simple handshaking mechanism through the use of a string-keyed map. At the most fundamental level, you declare \"this name is associated with this exemplar\" on one thread, and \"this name is associated with this prototype\" on the other thread. \n\nSince you want to be able to produce new struct instances on both sides, you could declare these things bidirectionally, i.e. \"this name is associated with this exemplar and prototype\" on one thread, and \"this name is associated with this exemplar and prototype\" on another thread:\n\n```js\n// main.js\nconst worker = new Worker(file, {\n  preload: \"preload.js\",\n  structs: {\n    Foo: { exemplar: FOO_EXEMPLAR, prototype: FOO_PROTOTYPE }\n  }\n});\n\n// preload.js\nprepareWorker({\n  structs: {\n    Foo: { exemplar: FOO_EXEMPLAR, prototype: FOO_PROTOTYPE }\n  }\n});\n```","format":"org.matrix.custom.html","formatted_body":"<p>The gist proposes a simple handshaking mechanism through the use of a string-keyed map. At the most fundamental level, you declare \"this name is associated with this exemplar\" on one thread, and \"this name is associated with this prototype\" on the other thread.</p>\n<p>Since you want to be able to produce new struct instances on both sides, you could declare these things bidirectionally, i.e. \"this name is associated with this exemplar and prototype\" on one thread, and \"this name is associated with this exemplar and prototype\" on another thread:</p>\n<pre><code class=\"language-js\">// main.js\nconst worker = new Worker(file, {\n  preload: \"preload.js\",\n  structs: {\n    Foo: { exemplar: FOO_EXEMPLAR, prototype: FOO_PROTOTYPE }\n  }\n});\n\n// preload.js\nprepareWorker({\n  structs: {\n    Foo: { exemplar: FOO_EXEMPLAR, prototype: FOO_PROTOTYPE }\n  }\n});\n</code></pre>\n","msgtype":"m.text"},"ts":1695075217016,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$B_V8DanSGq3lDLo6xcZntcCujm2ngHrIESlSJ6smTG4"},
{"content":{"body":"The preload script could run at the startup of the worker thread. It would establish the relationship on the worker's side, but wouldn't be allowed to send or receive messages on the worker. That would allow you to establish the relationship all at once and avoids a mutable registry.","msgtype":"m.text"},"ts":1695075328694,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hm1FOqn3ZVlf-04H1hkOZbDN66qWgsmOy0hS7Za-zcs"},
{"content":{"body":"This can then be expanded to introduce something like a built-in symbol-named method that the handshaking process could look at first, before looking for `{ exemplar, prototype }`, and a `shared struct` declaration would implement that as a static method, returning a suitable exemplar and prototype for the handshake without needing to run the constructor","format":"org.matrix.custom.html","formatted_body":"This can then be expanded to introduce something like a built-in symbol-named method that the handshaking process could look at first, before looking for <code>{ exemplar, prototype }</code>, and a <code>shared struct</code> declaration would implement that as a static method, returning a suitable exemplar and prototype for the handshake without needing to run the constructor","msgtype":"m.text"},"ts":1695075410247,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DYEzLQVCiz5WreFc6A_FuKIh1T2dQUKLyinrafnQjX8"},
{"content":{"body":"only allowing init time registration somewhat concerns me, and I have to think more about this per connection registry.","msgtype":"m.text"},"ts":1695075456385,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$m9100IHCqvMGFe9GmYIOGWFQf1dUmV20YELSd9ce2So"},
{"content":{"body":"Thus the handshake can be simplified with `shared struct` declarations like this:\n\n```js\n// foo.js\nexport shared struct Foo { \n  ...\n}\n\n// main.js\nimport { Foo } from \"foo.js\";\nconst worker = new Worker(\"worker.js\", {\n  preload: \"preload.js\",\n  structs: { Foo }\n});\n\n// preload.js\nimport { Foo } from \"foo.js\";\nprepareWorker({ structs: { Foo } });\n\n```","format":"org.matrix.custom.html","formatted_body":"<p>Thus the handshake can be simplified with <code>shared struct</code> declarations like this:</p>\n<pre><code class=\"language-js\">// foo.js\nexport shared struct Foo { \n  ...\n}\n\n// main.js\nimport { Foo } from \"foo.js\";\nconst worker = new Worker(\"worker.js\", {\n  preload: \"preload.js\",\n  structs: { Foo }\n});\n\n// preload.js\nimport { Foo } from \"foo.js\";\nprepareWorker({ structs: { Foo } });\n\n</code></pre>\n","msgtype":"m.text"},"ts":1695075492004,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NTOQ5QycAVpdBh7rPyimRbhLq2H8ldsV44tXaQDivhg"},
{"content":{"body":"The reason I proposed init-time registration was due to concerns you raised about data exfiltration with a mutable registry.","msgtype":"m.text"},"ts":1695075523950,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$I8usZfxRMmKj2hcuT0SaWSVUcWOsFhNNyOuev3vNlbE"},
{"content":{"body":"also this mechanism means there is technically 2 different point definitions, but since they share a prototype the type discontinuity is not observable?","msgtype":"m.text"},"ts":1695075584413,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$dfK7PL-XYBK0EFtquHUi4agALxFewn9cCAg5UfEsXrM"},
{"content":{"body":"This approach also avoids giving shared structs an identity based on path, and instead is a user-defined identity declared when the `Worker` is created. Its no different then just passing an array of workers without the need to ensure you properly marry up element order on both sides, and `Foo` is easier to remember and debug than an integer value.","format":"org.matrix.custom.html","formatted_body":"This approach also avoids giving shared structs an identity based on path, and instead is a user-defined identity declared when the <code>Worker</code> is created. Its no different then just passing an array of workers without the need to ensure you properly marry up element order on both sides, and <code>Foo</code> is easier to remember and debug than an integer value.","msgtype":"m.text"},"ts":1695075619460,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1iNaLz_7oVCElS31G_FlQ6FQ4pkesQyeYz77-_UTjQI"},
{"content":{"body":"yes non-init time registration does raise the problem of \"land-rush\", ability to extract information through the registry","msgtype":"m.text"},"ts":1695075661613,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YU7708LgI96aaYKcjT3PQ5X2t-bvUcrAUej8dsGbqcU"},
{"content":{"body":"> <@mhofman:matrix.org> also this mechanism means there is technically 2 different point definitions, but since they share a prototype the type discontinuity is not observable?\n\nI thought that was the rationale we were moving towards anyways? To attach behavior to a shared struct in two threads, you must have two different definitions of the behavior, one in each thread.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$dfK7PL-XYBK0EFtquHUi4agALxFewn9cCAg5UfEsXrM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>also this mechanism means there is technically 2 different point definitions, but since they share a prototype the type discontinuity is not observable?</blockquote></mx-reply>I thought that was the rationale we were moving towards anyways? To attach behavior to a shared struct in two threads, you must have two different definitions of the behavior, one in each thread.","m.relates_to":{"m.in_reply_to":{"event_id":"$dfK7PL-XYBK0EFtquHUi4agALxFewn9cCAg5UfEsXrM"}},"msgtype":"m.text"},"ts":1695075667809,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dpizXQCczYChPe-UsTXwijaR1J-_cPvE3nCkz0-sx1A"},
{"content":{"body":"I just wish we didn't have to make the trade-off somehow","msgtype":"m.text"},"ts":1695075679530,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$2qfwODQVr--eoN8r9lXq4S-rwewqOeyEAuJURcalL5c"},
{"content":{"body":"> <@rbuckton:matrix.org> I thought that was the rationale we were moving towards anyways? To attach behavior to a shared struct in two threads, you must have two different definitions of the behavior, one in each thread.\n\nyes just wanted to make sure that's actually what's happening, and that it should be fine","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$dpizXQCczYChPe-UsTXwijaR1J-_cPvE3nCkz0-sx1A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I thought that was the rationale we were moving towards anyways? To attach behavior to a shared struct in two threads, you must have two different definitions of the behavior, one in each thread.</blockquote></mx-reply>yes just wanted to make sure that's actually what's happening, and that it should be fine","m.relates_to":{"m.in_reply_to":{"event_id":"$dpizXQCczYChPe-UsTXwijaR1J-_cPvE3nCkz0-sx1A"}},"msgtype":"m.text"},"ts":1695075742655,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$QMQ-c8Gd7A-6xavsI5y07wiAhu-Xo6wUBFiwXj1a1Cc"},
{"content":{"body":"I think the preload mechanism is at the very least a palatable way to address it, and its the same approach used by runtimes like electron to provide privileged access when creating sandboxed environments","msgtype":"m.text"},"ts":1695075769078,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$331sZ3qMt0v_dhDm5eRQ3y5YUy4xKDLCyaxgCTMFxIQ"},
{"content":{"body":"a possible 1-to-many relationship from behavior to type definition","msgtype":"m.text"},"ts":1695075783326,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$v6q4Dxz_hJtrS42RCtdlg0SCG5CwLyC_veqIxU-Np_k"},
{"content":{"body":"This approach presupposes that you know ahead of time all of the possible types you wish to flow through all threads that can talk to each other in your application.","msgtype":"m.text"},"ts":1695075825911,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ga5t7kkxrmZ7mEDYUxem0qHL_7iRh28ndDdSqOLkbGU"}
]