[
{"content":{"body":"Here’s an idea for the semantic details for unsafe, Reflect, Atomics, and MOP for shared structs:\n- There is an abstract op, GetUnsafe(obj, propKey), which checks whether the obj is a shared struct, if so tries to get the propKey, if it is missing or if it isn’t a shared struct, fall back to Get. Analogously for SetUnsafe.\n- Reflect.getUnsafe/setUnsafe expose these ops\n- inside of an unsafe {} block, all direct property access is interpreted as GetUnsafe/SetUnsafe\n- Get and Set on shared structs are missing their own data properties. Those props don’t show up for any other MOP things either. But the thread-local prototype is present (it isn’t unsafe; a method might call an unsafe thing as an implementation detail though)\n- Atomics are always unsafe (that’s literally the point) so they are just overloaded for shared struct properties regardless of where they come from.\n- if we were doing SAB today, we might also consider this same unsafe restriction, but what’s done is done. This only applies for shared structs.","format":"org.matrix.custom.html","formatted_body":"<p>Here’s an idea for the semantic details for unsafe, Reflect, Atomics, and MOP for shared structs:</p>\n<ul>\n<li>There is an abstract op, GetUnsafe(obj, propKey), which checks whether the obj is a shared struct, if so tries to get the propKey, if it is missing or if it isn’t a shared struct, fall back to Get. Analogously for SetUnsafe.</li>\n<li>Reflect.getUnsafe/setUnsafe expose these ops</li>\n<li>inside of an unsafe {} block, all direct property access is interpreted as GetUnsafe/SetUnsafe</li>\n<li>Get and Set on shared structs are missing their own data properties. Those props don’t show up for any other MOP things either. But the thread-local prototype is present (it isn’t unsafe; a method might call an unsafe thing as an implementation detail though)</li>\n<li>Atomics are always unsafe (that’s literally the point) so they are just overloaded for shared struct properties regardless of where they come from.</li>\n<li>if we were doing SAB today, we might also consider this same unsafe restriction, but what’s done is done. This only applies for shared structs.</li>\n</ul>","msgtype":"m.text"},"ts":1720915668433,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$BU_VgHa-0iqyn9sFTRRDpLunFyypTmwA88dofeXNtzU"},
{"content":{"body":"The property keys need to show up in MOP operations. `in` and `hasOwnProperty` and `Reflect.has` are safe because structs have a fixed layout. ","format":"org.matrix.custom.html","formatted_body":"The property keys need to show up in MOP operations. <code>in</code> and <code>hasOwnProperty</code> and <code>Reflect.has</code> are safe because structs have a fixed layout.","msgtype":"m.text"},"ts":1720919437743,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$voHl4CZjelWVhlK2rM83LKq_pUrBn4iW1Fwb_s8qa34"},
{"content":{"body":"Though [[Get]] and [[Set]] would throw","msgtype":"m.text"},"ts":1720919527932,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FhMN5U5ApIgIlE0yYYJxMxtLOCKJ5glI8ounVqrFlmg"},
{"content":{"body":"What do you mean by \"Atomics are always unsafe?\" my perspective is that Atomics should not need an `umsafe` block at all","format":"org.matrix.custom.html","formatted_body":"What do you mean by &quot;Atomics are always unsafe?&quot; my perspective is that Atomics should not need an <code>umsafe</code> block at all","msgtype":"m.text"},"ts":1720919674328,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JeE6T36L9ZtRNUVlaYK_3GEn3P7Yuk0bYkaKkjaElUs"},
{"content":{"body":"* What do you mean by \"Atomics are always unsafe?\" my perspective is that Atomics should not need an `unsafe` block at all","m.new_content":{"body":"What do you mean by \"Atomics are always unsafe?\" my perspective is that Atomics should not need an `unsafe` block at all","format":"org.matrix.custom.html","formatted_body":"What do you mean by &quot;Atomics are always unsafe?&quot; my perspective is that Atomics should not need an <code>unsafe</code> block at all","msgtype":"m.text"},"m.relates_to":{"event_id":"$JeE6T36L9ZtRNUVlaYK_3GEn3P7Yuk0bYkaKkjaElUs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720919900291,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$261oOvwkMVpcBwNyg9xrTDiauhY-R5rk0Ri6kahI1TM"},
{"content":{"body":"> <@rbuckton:matrix.org> What do you mean by \"Atomics are always unsafe?\" my perspective is that Atomics should not need an `unsafe` block at all\n\nI think we are saying the same thing ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24JeE6T36L9ZtRNUVlaYK_3GEn3P7Yuk0bYkaKkjaElUs\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>What do you mean by &quot;Atomics are always unsafe?&quot; my perspective is that Atomics should not need an <code>unsafe</code> block at all</blockquote></mx-reply>I think we are saying the same thing","m.relates_to":{"m.in_reply_to":{"event_id":"$JeE6T36L9ZtRNUVlaYK_3GEn3P7Yuk0bYkaKkjaElUs"}},"msgtype":"m.text"},"ts":1720920144856,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5KbCuv_XY72xtIJwD-_SmlEt5XVVQM7G6EDC80YLiM8"},
{"content":{"body":"OK","msgtype":"m.text"},"ts":1720920149811,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bvQZFOPwKe7wZhvYJP_t8wTil9MTTlXL-iOTpoctoCU"},
{"content":{"body":"> <@rbuckton:matrix.org> The property keys need to show up in MOP operations. `in` and `hasOwnProperty` and `Reflect.has` are safe because structs have a fixed layout. \n\nSure, that makes sense. The important thing is that normal MOP operations can’t get at the contents, it’s just this other operation that can","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24voHl4CZjelWVhlK2rM83LKq_pUrBn4iW1Fwb_s8qa34\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>The property keys need to show up in MOP operations. <code>in</code> and <code>hasOwnProperty</code> and <code>Reflect.has</code> are safe because structs have a fixed layout.</blockquote></mx-reply>Sure, that makes sense. The important thing is that normal MOP operations can’t get at the contents, it’s just this other operation that can","m.relates_to":{"m.in_reply_to":{"event_id":"$voHl4CZjelWVhlK2rM83LKq_pUrBn4iW1Fwb_s8qa34"}},"msgtype":"m.text"},"ts":1720920186280,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$nTFGtpyqrT8bkXqtRuBNYhLZlSrDlQn469Rfh5QYXNM"},
{"content":{"body":"The rest of what you describe sounds like another namespace (like private names) which we absolutely do not want","msgtype":"m.text"},"ts":1720920202214,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ljVnIOl_zGl1u1679E8eyGdP63rubyED5HfNEjUEi3I"},
{"content":{"body":"> <@rbuckton:matrix.org> The rest of what you describe sounds like another namespace (like private names) which we absolutely do not want\n\nNot sure what you mean. It is still strings (or maybe symbols)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24ljVnIOl_zGl1u1679E8eyGdP63rubyED5HfNEjUEi3I\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>The rest of what you describe sounds like another namespace (like private names) which we absolutely do not want</blockquote></mx-reply>Not sure what you mean. It is still strings (or maybe symbols)","m.relates_to":{"m.in_reply_to":{"event_id":"$ljVnIOl_zGl1u1679E8eyGdP63rubyED5HfNEjUEi3I"}},"msgtype":"m.text"},"ts":1720920225668,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$aP-WZlu37x19qmqBArcSysaT7Qe7dMz9JsFAgk5SOBI"},
{"content":{"body":"I am not especially attached to the idea I wrote above, it is just the simplest thing I can imagine. How do you think unsafe blocks should work with respect to the MOP?","msgtype":"m.text"},"ts":1720920258648,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$gNcmuXsALFDKc0heqAghRv-6uSqeoiQ9DIHMVOAWtvg"},
{"content":{"body":"It sounded like you were saying that shared struct properties are transparent to MOP operations, which would not be correct","msgtype":"m.text"},"ts":1720920289226,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7fEy3XbM73DPnYCEejt7yDdajygcQ30t-S9k1HYSt1E"},
{"content":{"body":"> <@rbuckton:matrix.org> It sounded like you were saying that shared struct properties are transparent to MOP operations, which would not be correct\n\nNot transparent, just missing","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%247fEy3XbM73DPnYCEejt7yDdajygcQ30t-S9k1HYSt1E\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>It sounded like you were saying that shared struct properties are transparent to MOP operations, which would not be correct</blockquote></mx-reply>Not transparent, just missing","m.relates_to":{"m.in_reply_to":{"event_id":"$7fEy3XbM73DPnYCEejt7yDdajygcQ30t-S9k1HYSt1E"}},"msgtype":"m.text"},"ts":1720920311699,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$lrEgKSi6JUrpovd7YicCaccSU7JvtP-VwLJHfkf1Zgw"},
{"content":{"body":"Maybe that is what you meant","msgtype":"m.text"},"ts":1720920339950,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$bSQKjlbB1vHxmU2zHB0C3jCRqugLhfpbrSTU7u2FmOc"},
{"content":{"body":"Yes, thats what I meant","m.mentions":{},"msgtype":"m.text"},"ts":1720920345225,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Pq8HciGkArIX1SZ9VgMgztrwr4hrL-_c0Tttd44K6Uo"},
{"content":{"body":"they cannot be missing","m.mentions":{},"msgtype":"m.text"},"ts":1720920348412,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$E17Kw2zMXt-C_OP6c6IMUWpzF7szgvNuzaD6xxqbcN8"},
{"content":{"body":"You cannot have a [[Get]] outside of `unsafe` return a prototype property if there was a struct field of the same name.","format":"org.matrix.custom.html","formatted_body":"You cannot have a [[Get]] outside of <code>unsafe</code> return a prototype property if there was a struct field of the same name.","m.mentions":{},"msgtype":"m.text"},"ts":1720920378953,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZSUg7tOOp8MwYdwUu6T8erBJ8IWkjLc_SFvFYYLLd6c"},
{"content":{"body":"Can you explain how you think it should work?","msgtype":"m.text"},"ts":1720920388074,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$SA_BAqQJXycY0_ZSiXs2xl00koay0_fwxgb3LZRdvuI"},
{"content":{"body":"They have to treat them like normal properties, except that [[Get]] and [[Set]] throws.","m.mentions":{},"msgtype":"m.text"},"ts":1720920399929,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KQS6Gvij-FmHR-r8GImciTGM-BVjkq8ajiEv9hxrCNE"},
{"content":{"body":"How?","msgtype":"m.text"},"ts":1720920408147,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$y7qcK25vgKrQFNnLsyCR65-VNMf437-9xLypJLyt-jA"},
{"content":{"body":"You override [[Get]] and [[Set]] for shared struct objects. ","m.mentions":{},"msgtype":"m.text"},"ts":1720920423961,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$b4SyByIZqgG99Icl1NdqW1jt-g0aeIegMw2wYtuWaM4"},
{"content":{"body":"Those are abstract.","m.mentions":{},"msgtype":"m.text"},"ts":1720920431257,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Px2mBpD4fR6eEpoEHy78yAiCBNeGaQ5qKJBX0_dvt9o"},
{"content":{"body":"Will GetOwnPropertyDescriptor throw?","msgtype":"m.text"},"ts":1720920483827,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$RjhsBEs0Hgc3jIZIhBmtdHey4j2xINFdafpnU1ZY2xE"},
{"content":{"body":"Lets say you have [[Get]], [[Set]], [[UnsafeGet]], and [[UnsafeSet]]. On all objects, [[UnsafeGet]]/[[UnsafeSet]] just forwards on to the ordinary get/set behavior.","m.mentions":{},"msgtype":"m.text"},"ts":1720920499055,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OrotfukffLgN5DK5SDF5cQ0lRFBGapBjcfhaiUsYLpE"},
{"content":{"body":"What happens in the unsafe blocks?","msgtype":"m.text"},"ts":1720920508213,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$RIJBkeMuL3oWfi68v1czhCUQkkf7zl2zQ2IY-WiWams"},
{"content":{"body":"But shared structs have a [[Get]] and [[Set]] that throw.","m.mentions":{},"msgtype":"m.text"},"ts":1720920510988,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fCRTbsgEgdkEHuu0DqP5F0kazVSCVh2Gzlhl_Ums8lc"},
{"content":{"body":"In an unsafe block, get operations use [[UnsafeGet]]/[[UnsafeSet]] instead of [[Get]]/[[Set]]","m.mentions":{},"msgtype":"m.text"},"ts":1720920529179,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Zgv96cgrkKbjrj4b2Tr6zBQtk4CrjzSByrtmyWSRtyQ"},
{"content":{"body":"Even without `unsafe` we need to do something similar to handle shared memory access for shared struct fields in [[Get]] and [[Set]], so we already expect to pay this cost.","format":"org.matrix.custom.html","formatted_body":"Even without <code>unsafe</code> we need to do something similar to handle shared memory access for shared struct fields in [[Get]] and [[Set]], so we already expect to pay this cost.","m.mentions":{},"msgtype":"m.text"},"ts":1720920590003,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XRsy-vxgbOfYsUTvu5dHEbBM7EHbJipLTjTIvhewZ6E"},
{"content":{"body":"GetOwnPropertyDescriptor would probably throw outside of `unsafe`, or possibly would return a new descriptor that is `{ enumerable: ?, writable: false, configurable: false, shared: true }` with no `value` property.","format":"org.matrix.custom.html","formatted_body":"GetOwnPropertyDescriptor would probably throw outside of <code>unsafe</code>, or possibly would return a new descriptor that is <code>{ enumerable: ?, writable: false, configurable: false, shared: true }</code> with no <code>value</code> property.","m.mentions":{},"msgtype":"m.text"},"ts":1720920661615,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dhC_4Bt4M_FOdGpqJh3NG2dBwme1H2OfYoG9dIckAec"},
{"content":{"body":"OK, so how does Object.getOwnPropertyDescriptor know if it’s in an unsafe block?","msgtype":"m.text"},"ts":1720920701513,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ciVl-2orWc0xRCnoZHTBoebSVem90M_qayzmG9mcaE8"},
{"content":{"body":"But `in` and `Reflect.has` et al should work outside of unsafe because for a given reference to a shared struct, it will still have a fixed shape.","format":"org.matrix.custom.html","formatted_body":"But <code>in</code> and <code>Reflect.has</code> et al should work outside of unsafe because for a given reference to a shared struct, it will still have a fixed shape.","m.mentions":{},"msgtype":"m.text"},"ts":1720920707525,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$GDp0YsQMAysAqLDmvb342T_fjw5qV4fzOn00WNZx7JE"},
{"content":{"body":"I was trying to avoid functions changing behavior based on their caller","msgtype":"m.text"},"ts":1720920741828,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$QEKJ6o8Vx_-sz13LhpCeQcpl_zg7dlBsKL9g3sAdBbA"},
{"content":{"body":"> <@rbuckton:matrix.org> You cannot have a [[Get]] outside of `unsafe` return a prototype property if there was a struct field of the same name.\n\nI think this problem can be fixed in my suggestion without making any new MOP ops or anything","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24ZSUg7tOOp8MwYdwUu6T8erBJ8IWkjLc_SFvFYYLLd6c\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>You cannot have a [[Get]] outside of <code>unsafe</code> return a prototype property if there was a struct field of the same name.</blockquote></mx-reply>I think this problem can be fixed in my suggestion without making any new MOP ops or anything","m.relates_to":{"m.in_reply_to":{"event_id":"$ZSUg7tOOp8MwYdwUu6T8erBJ8IWkjLc_SFvFYYLLd6c"}},"msgtype":"m.text"},"ts":1720920818739,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$sBpIruMl-u9rLNe0w_UfyXnvwSOHeo7XhAYvG9iSA7Y"},
{"content":{"body":"We could have gOPD return a new kind of descriptor both in and out of `unsafe`, and an `Reflect.unsafeGetOwnPropertyDescriptor` that has the same magic that `Reflect.unsafeGet`/`Reflect.unsafeSet` would have (if any).","format":"org.matrix.custom.html","formatted_body":"We could have gOPD return a new kind of descriptor both in and out of <code>unsafe</code>, and an <code>Reflect.unsafeGetOwnPropertyDescriptor</code> that has the same magic that <code>Reflect.unsafeGet</code>/<code>Reflect.unsafeSet</code> would have (if any).","m.mentions":{},"msgtype":"m.text"},"ts":1720920824042,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZEIG3T2hT2mEo6SXe5m_1D1-RzMZ1Yordh5sOG8SBc4"},
{"content":{"body":"Maybe gOPD would throw if you don’t call the unsafe one?","msgtype":"m.text"},"ts":1720920889920,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XtwisCZpdJKfJVEG-FtvsECPfAhPeYCIajLLqArSNUI"},
{"content":{"body":"You need MOP operations to be reliable. What happens if I do `Object.create(sharedStruct)`? Now I have a normal JS object with a shared struct prototype. If I call [[Get]] on the result it should still throw if it tries to read a prototype field outside of `unsafe`.","format":"org.matrix.custom.html","formatted_body":"You need MOP operations to be reliable. What happens if I do <code>Object.create(sharedStruct)</code>? Now I have a normal JS object with a shared struct prototype. If I call [[Get]] on the result it should still throw if it tries to read a prototype field outside of <code>unsafe</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1720920901125,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DGuun7I33mq8ank15dq10fmuZxbdk8cFxin13UK3JCU"}
]