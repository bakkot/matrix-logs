[
{"content":{"body":"Here’s an idea for the semantic details for unsafe, Reflect, Atomics, and MOP for shared structs:\n- There is an abstract op, GetUnsafe(obj, propKey), which checks whether the obj is a shared struct, if so tries to get the propKey, if it is missing or if it isn’t a shared struct, fall back to Get. Analogously for SetUnsafe.\n- Reflect.getUnsafe/setUnsafe expose these ops\n- inside of an unsafe {} block, all direct property access is interpreted as GetUnsafe/SetUnsafe\n- Get and Set on shared structs are missing their own data properties. Those props don’t show up for any other MOP things either. But the thread-local prototype is present (it isn’t unsafe; a method might call an unsafe thing as an implementation detail though)\n- Atomics are always unsafe (that’s literally the point) so they are just overloaded for shared struct properties regardless of where they come from.\n- if we were doing SAB today, we might also consider this same unsafe restriction, but what’s done is done. This only applies for shared structs.","format":"org.matrix.custom.html","formatted_body":"<p>Here’s an idea for the semantic details for unsafe, Reflect, Atomics, and MOP for shared structs:</p>\n<ul>\n<li>There is an abstract op, GetUnsafe(obj, propKey), which checks whether the obj is a shared struct, if so tries to get the propKey, if it is missing or if it isn’t a shared struct, fall back to Get. Analogously for SetUnsafe.</li>\n<li>Reflect.getUnsafe/setUnsafe expose these ops</li>\n<li>inside of an unsafe {} block, all direct property access is interpreted as GetUnsafe/SetUnsafe</li>\n<li>Get and Set on shared structs are missing their own data properties. Those props don’t show up for any other MOP things either. But the thread-local prototype is present (it isn’t unsafe; a method might call an unsafe thing as an implementation detail though)</li>\n<li>Atomics are always unsafe (that’s literally the point) so they are just overloaded for shared struct properties regardless of where they come from.</li>\n<li>if we were doing SAB today, we might also consider this same unsafe restriction, but what’s done is done. This only applies for shared structs.</li>\n</ul>","msgtype":"m.text"},"ts":1720915668433,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$BU_VgHa-0iqyn9sFTRRDpLunFyypTmwA88dofeXNtzU"},
{"content":{"body":"The property keys need to show up in MOP operations. `in` and `hasOwnProperty` and `Reflect.has` are safe because structs have a fixed layout. ","format":"org.matrix.custom.html","formatted_body":"The property keys need to show up in MOP operations. <code>in</code> and <code>hasOwnProperty</code> and <code>Reflect.has</code> are safe because structs have a fixed layout.","msgtype":"m.text"},"ts":1720919437743,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$voHl4CZjelWVhlK2rM83LKq_pUrBn4iW1Fwb_s8qa34"},
{"content":{"body":"Though [[Get]] and [[Set]] would throw","msgtype":"m.text"},"ts":1720919527932,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FhMN5U5ApIgIlE0yYYJxMxtLOCKJ5glI8ounVqrFlmg"},
{"content":{"body":"What do you mean by \"Atomics are always unsafe?\" my perspective is that Atomics should not need an `umsafe` block at all","format":"org.matrix.custom.html","formatted_body":"What do you mean by &quot;Atomics are always unsafe?&quot; my perspective is that Atomics should not need an <code>umsafe</code> block at all","msgtype":"m.text"},"ts":1720919674328,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JeE6T36L9ZtRNUVlaYK_3GEn3P7Yuk0bYkaKkjaElUs"},
{"content":{"body":"* What do you mean by \"Atomics are always unsafe?\" my perspective is that Atomics should not need an `unsafe` block at all","m.new_content":{"body":"What do you mean by \"Atomics are always unsafe?\" my perspective is that Atomics should not need an `unsafe` block at all","format":"org.matrix.custom.html","formatted_body":"What do you mean by &quot;Atomics are always unsafe?&quot; my perspective is that Atomics should not need an <code>unsafe</code> block at all","msgtype":"m.text"},"m.relates_to":{"event_id":"$JeE6T36L9ZtRNUVlaYK_3GEn3P7Yuk0bYkaKkjaElUs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720919900291,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$261oOvwkMVpcBwNyg9xrTDiauhY-R5rk0Ri6kahI1TM"},
{"content":{"body":"> <@rbuckton:matrix.org> What do you mean by \"Atomics are always unsafe?\" my perspective is that Atomics should not need an `unsafe` block at all\n\nI think we are saying the same thing ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24JeE6T36L9ZtRNUVlaYK_3GEn3P7Yuk0bYkaKkjaElUs\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>What do you mean by &quot;Atomics are always unsafe?&quot; my perspective is that Atomics should not need an <code>unsafe</code> block at all</blockquote></mx-reply>I think we are saying the same thing","m.relates_to":{"m.in_reply_to":{"event_id":"$JeE6T36L9ZtRNUVlaYK_3GEn3P7Yuk0bYkaKkjaElUs"}},"msgtype":"m.text"},"ts":1720920144856,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5KbCuv_XY72xtIJwD-_SmlEt5XVVQM7G6EDC80YLiM8"},
{"content":{"body":"OK","msgtype":"m.text"},"ts":1720920149811,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bvQZFOPwKe7wZhvYJP_t8wTil9MTTlXL-iOTpoctoCU"},
{"content":{"body":"> <@rbuckton:matrix.org> The property keys need to show up in MOP operations. `in` and `hasOwnProperty` and `Reflect.has` are safe because structs have a fixed layout. \n\nSure, that makes sense. The important thing is that normal MOP operations can’t get at the contents, it’s just this other operation that can","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24voHl4CZjelWVhlK2rM83LKq_pUrBn4iW1Fwb_s8qa34\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>The property keys need to show up in MOP operations. <code>in</code> and <code>hasOwnProperty</code> and <code>Reflect.has</code> are safe because structs have a fixed layout.</blockquote></mx-reply>Sure, that makes sense. The important thing is that normal MOP operations can’t get at the contents, it’s just this other operation that can","m.relates_to":{"m.in_reply_to":{"event_id":"$voHl4CZjelWVhlK2rM83LKq_pUrBn4iW1Fwb_s8qa34"}},"msgtype":"m.text"},"ts":1720920186280,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$nTFGtpyqrT8bkXqtRuBNYhLZlSrDlQn469Rfh5QYXNM"},
{"content":{"body":"The rest of what you describe sounds like another namespace (like private names) which we absolutely do not want","msgtype":"m.text"},"ts":1720920202214,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ljVnIOl_zGl1u1679E8eyGdP63rubyED5HfNEjUEi3I"},
{"content":{"body":"> <@rbuckton:matrix.org> The rest of what you describe sounds like another namespace (like private names) which we absolutely do not want\n\nNot sure what you mean. It is still strings (or maybe symbols)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24ljVnIOl_zGl1u1679E8eyGdP63rubyED5HfNEjUEi3I\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>The rest of what you describe sounds like another namespace (like private names) which we absolutely do not want</blockquote></mx-reply>Not sure what you mean. It is still strings (or maybe symbols)","m.relates_to":{"m.in_reply_to":{"event_id":"$ljVnIOl_zGl1u1679E8eyGdP63rubyED5HfNEjUEi3I"}},"msgtype":"m.text"},"ts":1720920225668,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$aP-WZlu37x19qmqBArcSysaT7Qe7dMz9JsFAgk5SOBI"},
{"content":{"body":"I am not especially attached to the idea I wrote above, it is just the simplest thing I can imagine. How do you think unsafe blocks should work with respect to the MOP?","msgtype":"m.text"},"ts":1720920258648,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$gNcmuXsALFDKc0heqAghRv-6uSqeoiQ9DIHMVOAWtvg"},
{"content":{"body":"It sounded like you were saying that shared struct properties are transparent to MOP operations, which would not be correct","msgtype":"m.text"},"ts":1720920289226,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7fEy3XbM73DPnYCEejt7yDdajygcQ30t-S9k1HYSt1E"},
{"content":{"body":"> <@rbuckton:matrix.org> It sounded like you were saying that shared struct properties are transparent to MOP operations, which would not be correct\n\nNot transparent, just missing","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%247fEy3XbM73DPnYCEejt7yDdajygcQ30t-S9k1HYSt1E\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>It sounded like you were saying that shared struct properties are transparent to MOP operations, which would not be correct</blockquote></mx-reply>Not transparent, just missing","m.relates_to":{"m.in_reply_to":{"event_id":"$7fEy3XbM73DPnYCEejt7yDdajygcQ30t-S9k1HYSt1E"}},"msgtype":"m.text"},"ts":1720920311699,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$lrEgKSi6JUrpovd7YicCaccSU7JvtP-VwLJHfkf1Zgw"},
{"content":{"body":"Maybe that is what you meant","msgtype":"m.text"},"ts":1720920339950,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$bSQKjlbB1vHxmU2zHB0C3jCRqugLhfpbrSTU7u2FmOc"},
{"content":{"body":"Yes, thats what I meant","m.mentions":{},"msgtype":"m.text"},"ts":1720920345225,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Pq8HciGkArIX1SZ9VgMgztrwr4hrL-_c0Tttd44K6Uo"},
{"content":{"body":"they cannot be missing","m.mentions":{},"msgtype":"m.text"},"ts":1720920348412,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$E17Kw2zMXt-C_OP6c6IMUWpzF7szgvNuzaD6xxqbcN8"},
{"content":{"body":"You cannot have a [[Get]] outside of `unsafe` return a prototype property if there was a struct field of the same name.","format":"org.matrix.custom.html","formatted_body":"You cannot have a [[Get]] outside of <code>unsafe</code> return a prototype property if there was a struct field of the same name.","m.mentions":{},"msgtype":"m.text"},"ts":1720920378953,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZSUg7tOOp8MwYdwUu6T8erBJ8IWkjLc_SFvFYYLLd6c"},
{"content":{"body":"Can you explain how you think it should work?","msgtype":"m.text"},"ts":1720920388074,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$SA_BAqQJXycY0_ZSiXs2xl00koay0_fwxgb3LZRdvuI"},
{"content":{"body":"They have to treat them like normal properties, except that [[Get]] and [[Set]] throws.","m.mentions":{},"msgtype":"m.text"},"ts":1720920399929,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KQS6Gvij-FmHR-r8GImciTGM-BVjkq8ajiEv9hxrCNE"},
{"content":{"body":"How?","msgtype":"m.text"},"ts":1720920408147,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$y7qcK25vgKrQFNnLsyCR65-VNMf437-9xLypJLyt-jA"},
{"content":{"body":"You override [[Get]] and [[Set]] for shared struct objects. ","m.mentions":{},"msgtype":"m.text"},"ts":1720920423961,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$b4SyByIZqgG99Icl1NdqW1jt-g0aeIegMw2wYtuWaM4"},
{"content":{"body":"Those are abstract.","m.mentions":{},"msgtype":"m.text"},"ts":1720920431257,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Px2mBpD4fR6eEpoEHy78yAiCBNeGaQ5qKJBX0_dvt9o"},
{"content":{"body":"Will GetOwnPropertyDescriptor throw?","msgtype":"m.text"},"ts":1720920483827,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$RjhsBEs0Hgc3jIZIhBmtdHey4j2xINFdafpnU1ZY2xE"},
{"content":{"body":"Lets say you have [[Get]], [[Set]], [[UnsafeGet]], and [[UnsafeSet]]. On all objects, [[UnsafeGet]]/[[UnsafeSet]] just forwards on to the ordinary get/set behavior.","m.mentions":{},"msgtype":"m.text"},"ts":1720920499055,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OrotfukffLgN5DK5SDF5cQ0lRFBGapBjcfhaiUsYLpE"},
{"content":{"body":"What happens in the unsafe blocks?","msgtype":"m.text"},"ts":1720920508213,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$RIJBkeMuL3oWfi68v1czhCUQkkf7zl2zQ2IY-WiWams"},
{"content":{"body":"But shared structs have a [[Get]] and [[Set]] that throw.","m.mentions":{},"msgtype":"m.text"},"ts":1720920510988,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fCRTbsgEgdkEHuu0DqP5F0kazVSCVh2Gzlhl_Ums8lc"},
{"content":{"body":"In an unsafe block, get operations use [[UnsafeGet]]/[[UnsafeSet]] instead of [[Get]]/[[Set]]","m.mentions":{},"msgtype":"m.text"},"ts":1720920529179,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Zgv96cgrkKbjrj4b2Tr6zBQtk4CrjzSByrtmyWSRtyQ"},
{"content":{"body":"Even without `unsafe` we need to do something similar to handle shared memory access for shared struct fields in [[Get]] and [[Set]], so we already expect to pay this cost.","format":"org.matrix.custom.html","formatted_body":"Even without <code>unsafe</code> we need to do something similar to handle shared memory access for shared struct fields in [[Get]] and [[Set]], so we already expect to pay this cost.","m.mentions":{},"msgtype":"m.text"},"ts":1720920590003,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XRsy-vxgbOfYsUTvu5dHEbBM7EHbJipLTjTIvhewZ6E"},
{"content":{"body":"GetOwnPropertyDescriptor would probably throw outside of `unsafe`, or possibly would return a new descriptor that is `{ enumerable: ?, writable: false, configurable: false, shared: true }` with no `value` property.","format":"org.matrix.custom.html","formatted_body":"GetOwnPropertyDescriptor would probably throw outside of <code>unsafe</code>, or possibly would return a new descriptor that is <code>{ enumerable: ?, writable: false, configurable: false, shared: true }</code> with no <code>value</code> property.","m.mentions":{},"msgtype":"m.text"},"ts":1720920661615,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dhC_4Bt4M_FOdGpqJh3NG2dBwme1H2OfYoG9dIckAec"},
{"content":{"body":"OK, so how does Object.getOwnPropertyDescriptor know if it’s in an unsafe block?","msgtype":"m.text"},"ts":1720920701513,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ciVl-2orWc0xRCnoZHTBoebSVem90M_qayzmG9mcaE8"},
{"content":{"body":"But `in` and `Reflect.has` et al should work outside of unsafe because for a given reference to a shared struct, it will still have a fixed shape.","format":"org.matrix.custom.html","formatted_body":"But <code>in</code> and <code>Reflect.has</code> et al should work outside of unsafe because for a given reference to a shared struct, it will still have a fixed shape.","m.mentions":{},"msgtype":"m.text"},"ts":1720920707525,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$GDp0YsQMAysAqLDmvb342T_fjw5qV4fzOn00WNZx7JE"},
{"content":{"body":"I was trying to avoid functions changing behavior based on their caller","msgtype":"m.text"},"ts":1720920741828,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$QEKJ6o8Vx_-sz13LhpCeQcpl_zg7dlBsKL9g3sAdBbA"},
{"content":{"body":"> <@rbuckton:matrix.org> You cannot have a [[Get]] outside of `unsafe` return a prototype property if there was a struct field of the same name.\n\nI think this problem can be fixed in my suggestion without making any new MOP ops or anything","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24ZSUg7tOOp8MwYdwUu6T8erBJ8IWkjLc_SFvFYYLLd6c\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>You cannot have a [[Get]] outside of <code>unsafe</code> return a prototype property if there was a struct field of the same name.</blockquote></mx-reply>I think this problem can be fixed in my suggestion without making any new MOP ops or anything","m.relates_to":{"m.in_reply_to":{"event_id":"$ZSUg7tOOp8MwYdwUu6T8erBJ8IWkjLc_SFvFYYLLd6c"}},"msgtype":"m.text"},"ts":1720920818739,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$sBpIruMl-u9rLNe0w_UfyXnvwSOHeo7XhAYvG9iSA7Y"},
{"content":{"body":"We could have gOPD return a new kind of descriptor both in and out of `unsafe`, and an `Reflect.unsafeGetOwnPropertyDescriptor` that has the same magic that `Reflect.unsafeGet`/`Reflect.unsafeSet` would have (if any).","format":"org.matrix.custom.html","formatted_body":"We could have gOPD return a new kind of descriptor both in and out of <code>unsafe</code>, and an <code>Reflect.unsafeGetOwnPropertyDescriptor</code> that has the same magic that <code>Reflect.unsafeGet</code>/<code>Reflect.unsafeSet</code> would have (if any).","m.mentions":{},"msgtype":"m.text"},"ts":1720920824042,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZEIG3T2hT2mEo6SXe5m_1D1-RzMZ1Yordh5sOG8SBc4"},
{"content":{"body":"Maybe gOPD would throw if you don’t call the unsafe one?","msgtype":"m.text"},"ts":1720920889920,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XtwisCZpdJKfJVEG-FtvsECPfAhPeYCIajLLqArSNUI"},
{"content":{"body":"You need MOP operations to be reliable. What happens if I do `Object.create(sharedStruct)`? Now I have a normal JS object with a shared struct prototype. If I call [[Get]] on the result it should still throw if it tries to read a prototype field outside of `unsafe`.","format":"org.matrix.custom.html","formatted_body":"You need MOP operations to be reliable. What happens if I do <code>Object.create(sharedStruct)</code>? Now I have a normal JS object with a shared struct prototype. If I call [[Get]] on the result it should still throw if it tries to read a prototype field outside of <code>unsafe</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1720920901125,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DGuun7I33mq8ank15dq10fmuZxbdk8cFxin13UK3JCU"},
{"content":{"body":"Do we have unsafeDefineProperty?","msgtype":"m.text"},"ts":1720920911468,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$mgAR8WnXR6jFk3yY7ZRWDQQP3dCLhTE3Gg-ipTTfWO4"},
{"content":{"body":"getOPD shouldn't throw. Nothing causes it to throw today, to my knowledge.","m.mentions":{},"msgtype":"m.text"},"ts":1720920922775,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wz-nUn3v4mYbEy7mNvjkgPAUxUj6kYSfpB5URBdqFcs"},
{"content":{"body":"No. You can't call defineProperty on a shared struct, it would fail.","m.mentions":{},"msgtype":"m.text"},"ts":1720920934236,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$AYChz8Kk2zd5bbQrUnQQggJdaikfu-mjSNIgAQR-KfE"},
{"content":{"body":"Shared struct instances are sealed.","m.mentions":{},"msgtype":"m.text"},"ts":1720920939595,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aSsbLSTt2X8Ih19NHO0yHK130MxmdccvUtfVzEzYoKs"},
{"content":{"body":"No new properties, no deleting properties.","m.mentions":{},"msgtype":"m.text"},"ts":1720920946820,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4DojDe-GilD81QELxyqxAFoFXK80PTl8sofC1PLzFGU"},
{"content":{"body":"Even if the property descriptor matches what’s already there?","msgtype":"m.text"},"ts":1720920957754,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$oyb3FWgXsQleiULv37j2wU_m1jxn69uoAvO5Oomklj4"},
{"content":{"body":"> <@rbuckton:matrix.org> getOPD shouldn't throw. Nothing causes it to throw today, to my knowledge.\n\nProxy can ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24wz-nUn3v4mYbEy7mNvjkgPAUxUj6kYSfpB5URBdqFcs\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>getOPD shouldn't throw. Nothing causes it to throw today, to my knowledge.</blockquote></mx-reply>Proxy can","m.relates_to":{"m.in_reply_to":{"event_id":"$wz-nUn3v4mYbEy7mNvjkgPAUxUj6kYSfpB5URBdqFcs"}},"msgtype":"m.text"},"ts":1720920966907,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$QReWu_p-NfYVWh2d7z0Iw0pYYO5qt-QQylQKR746mhg"},
{"content":{"body":"Normal defineProperty would just fail because of the existing integrity checks","m.mentions":{},"msgtype":"m.text"},"ts":1720920968243,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DU1vzqt4NggrPbXG-Danlr6iD8oX1zRvG0DpPeJ34Js"},
{"content":{"body":"> <@rbuckton:matrix.org> Normal defineProperty would just fail because of the existing integrity checks\n\nI don’t think that’s the case if you define it as what it’s already defined to be, but with a different value ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24DU1vzqt4NggrPbXG-Danlr6iD8oX1zRvG0DpPeJ34Js\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Normal defineProperty would just fail because of the existing integrity checks</blockquote></mx-reply>I don’t think that’s the case if you define it as what it’s already defined to be, but with a different value","m.relates_to":{"m.in_reply_to":{"event_id":"$DU1vzqt4NggrPbXG-Danlr6iD8oX1zRvG0DpPeJ34Js"}},"msgtype":"m.text"},"ts":1720921003066,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$L-Y0ZfRa-Y2Vs2aoCkTJ7NV9EJRDTFji-OmO8un32tc"},
{"content":{"body":"AFAIK, no developers code defensively against gOPD failing. ","m.mentions":{},"msgtype":"m.text"},"ts":1720921004363,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Qp4_LvIiuml2CG5rompbIoEydhFr-3TGqWYocZ03WlA"},
{"content":{"body":"That's fair","m.mentions":{},"msgtype":"m.text"},"ts":1720921014908,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$__gd4lBT3Jss1E-2JOX_NcD8ZapqfKjJbQHvt3lJpt4"},
{"content":{"body":" * GetOwnPropertyDescriptor would probably throw outside of `unsafe`, or possibly would return a new descriptor that is `{ enumerable: ?, writable: ?, configurable: false, shared: true }` with no `value` property.","format":"org.matrix.custom.html","formatted_body":" * GetOwnPropertyDescriptor would probably throw outside of <code>unsafe</code>, or possibly would return a new descriptor that is <code>{ enumerable: ?, writable: ?, configurable: false, shared: true }</code> with no <code>value</code> property.","m.mentions":{},"m.new_content":{"body":"GetOwnPropertyDescriptor would probably throw outside of `unsafe`, or possibly would return a new descriptor that is `{ enumerable: ?, writable: ?, configurable: false, shared: true }` with no `value` property.","format":"org.matrix.custom.html","formatted_body":"GetOwnPropertyDescriptor would probably throw outside of <code>unsafe</code>, or possibly would return a new descriptor that is <code>{ enumerable: ?, writable: ?, configurable: false, shared: true }</code> with no <code>value</code> property.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$dhC_4Bt4M_FOdGpqJh3NG2dBwme1H2OfYoG9dIckAec","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720921030588,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$C12hay0R0qIkT5zXzoFYFNiXj3q2FEBFubjMf3E_LqI"},
{"content":{"body":"Maybe we do need `unsafeDefineProperty`. I do want to be able to change `writable`","format":"org.matrix.custom.html","formatted_body":"Maybe we do need <code>unsafeDefineProperty</code>. I do want to be able to change <code>writable</code>","m.mentions":{},"msgtype":"m.text"},"ts":1720921058616,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ahbuGAAUd4FBIw4wsZOWMsRaHVDZsfmmkQ7vUJcHRvI"},
{"content":{"body":"But you can't create new properties with it, ","m.mentions":{},"msgtype":"m.text"},"ts":1720921070780,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$X8-1YOq7vqtRTddXetGjgSSqph2e5fRD6d0gpJAANZU"},
{"content":{"body":" * But you can't create new properties with it.","m.mentions":{},"m.new_content":{"body":"But you can't create new properties with it.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$X8-1YOq7vqtRTddXetGjgSSqph2e5fRD6d0gpJAANZU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720921075905,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rHNd9pc4RDx7i3EIslEjB2nSXgvLOTK27SBUDa4xvvE"},
{"content":{"body":"Maybe instead of `Reflect.unsafeX` we have `Reflect.unsafe.X` which just mirrors `Reflect`","format":"org.matrix.custom.html","formatted_body":"Maybe instead of <code>Reflect.unsafeX</code> we have <code>Reflect.unsafe.X</code> which just mirrors <code>Reflect</code>","m.mentions":{},"msgtype":"m.text"},"ts":1720921146279,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Km9ylXGJ2E2SqeZ0T0uiAX9YUGeu-aUN8300NTzFBvI"},
{"content":{"body":"I would start simple and omit unsafeGOPD and unsafeDP, letting these always throw on shared struct data props. That might be the only observable difference between the ways we are thinking about this.","msgtype":"m.text"},"ts":1720921150058,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$PwEcZI3JMRU8Hvc0wa6ReXCAMSMdUxxUExkvzZ1R2zY"},
{"content":{"body":"(except for `deleteProperty` since that will never work?)","format":"org.matrix.custom.html","formatted_body":"(except for <code>deleteProperty</code> since that will never work?)","m.mentions":{},"msgtype":"m.text"},"ts":1720921159738,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hfxOnhXFo86kZ4S6zlJPqG4MV896TVeNbpxZ1r8HsVY"},
{"content":{"body":"> <@rbuckton:matrix.org> Maybe instead of `Reflect.unsafeX` we have `Reflect.unsafe.X` which just mirrors `Reflect`\n\nI am a fan of namespace objects, but I don’t know how much of this we need to fill in","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24Km9ylXGJ2E2SqeZ0T0uiAX9YUGeu-aUN8300NTzFBvI\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Maybe instead of <code>Reflect.unsafeX</code> we have <code>Reflect.unsafe.X</code> which just mirrors <code>Reflect</code></blockquote></mx-reply>I am a fan of namespace objects, but I don’t know how much of this we need to fill in","m.relates_to":{"m.in_reply_to":{"event_id":"$Km9ylXGJ2E2SqeZ0T0uiAX9YUGeu-aUN8300NTzFBvI"}},"msgtype":"m.text"},"ts":1720921198617,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Ge4-39iSqPNxSbJoz3VFzO-ZNl125v1RmmF_l5dmqks"},
{"content":{"body":"I really would like to make fields non-writable, though I've been thinking we some kind of \"init-only\" modifier for fields that can only be initialized in the constructor.","m.mentions":{},"msgtype":"m.text"},"ts":1720921218053,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$geIYcujuEjeLYhKV1UJD-J7XyhzeiNH4WMV30iMjzjw"},
{"content":{"body":"> <@rbuckton:matrix.org> I really would like to make fields non-writable, though I've been thinking we some kind of \"init-only\" modifier for fields that can only be initialized in the constructor.\n\nYeah I don’t think nonwritable is a good solution for this. We would need initializer lists. Anyway I imagined shared struct fields would be nonconfigurable","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24geIYcujuEjeLYhKV1UJD-J7XyhzeiNH4WMV30iMjzjw\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I really would like to make fields non-writable, though I've been thinking we some kind of \"init-only\" modifier for fields that can only be initialized in the constructor.</blockquote></mx-reply>Yeah I don’t think nonwritable is a good solution for this. We would need initializer lists. Anyway I imagined shared struct fields would be nonconfigurable","m.relates_to":{"m.in_reply_to":{"event_id":"$geIYcujuEjeLYhKV1UJD-J7XyhzeiNH4WMV30iMjzjw"}},"msgtype":"m.text"},"ts":1720921278267,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$CxzJUjtlkleckxB-1sVGkYH0vuUdoZq_OGCXoW9tTn0"},
{"content":{"body":"But we probably should have some kind of `getOwnPropertyDescriptor` support at some point.","format":"org.matrix.custom.html","formatted_body":"But we probably should have some kind of <code>getOwnPropertyDescriptor</code> support at some point.","m.mentions":{},"msgtype":"m.text"},"ts":1720921291569,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0AFwwZlwW1ZfQQZNPkOtn2zwDPF_nmltluQ8wegd9cI"},
{"content":{"body":"Yes, they are non-configurable","m.mentions":{},"msgtype":"m.text"},"ts":1720921298103,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9C7e_m8biiKobKOO9RUmXeNxy6lJNtNhPNXUXTVEj2I"},
{"content":{"body":"So… no particular use for defineProperty then","msgtype":"m.text"},"ts":1720921340974,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$smy-BvMPaxW_VKHMaMLvd0ODuQ-FX-MenZ4YWFk9kUs"},
{"content":{"body":"> <@rbuckton:matrix.org> But we probably should have some kind of `getOwnPropertyDescriptor` support at some point.\n\nSome kind of introspection would be good, but maybe this should be focused on the class level","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%240AFwwZlwW1ZfQQZNPkOtn2zwDPF_nmltluQ8wegd9cI\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>But we probably should have some kind of <code>getOwnPropertyDescriptor</code> support at some point.</blockquote></mx-reply>Some kind of introspection would be good, but maybe this should be focused on the class level","m.relates_to":{"m.in_reply_to":{"event_id":"$0AFwwZlwW1ZfQQZNPkOtn2zwDPF_nmltluQ8wegd9cI"}},"msgtype":"m.text"},"ts":1720921372020,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$I5pkFLsesZ8fn0VopzmFL2TlcsmcHmRx7wHrXlVjj5c"},
{"content":{"body":"Even if we don't have gOPD, I want to make sure we can still do `{ ...sharedStruct }` inside of an `unsafe` block as it could be an efficient way to copy the properties off of the struct while in a lock.","format":"org.matrix.custom.html","formatted_body":"Even if we don't have gOPD, I want to make sure we can still do <code>{ ...sharedStruct }</code> inside of an <code>unsafe</code> block as it could be an efficient way to copy the properties off of the struct while in a lock.","m.mentions":{},"msgtype":"m.text"},"ts":1720921380703,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aqrfv_GuSzdq1gYOq8eRqGcSGQF9ILkzj8EMtbTd73g"},
{"content":{"body":"> <@rbuckton:matrix.org> Even if we don't have gOPD, I want to make sure we can still do `{ ...sharedStruct }` inside of an `unsafe` block as it could be an efficient way to copy the properties off of the struct while in a lock.\n\nHuh, how do you attach the right cross realm prototype identifier?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24aqrfv_GuSzdq1gYOq8eRqGcSGQF9ILkzj8EMtbTd73g\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Even if we don't have gOPD, I want to make sure we can still do <code>{ ...sharedStruct }</code> inside of an <code>unsafe</code> block as it could be an efficient way to copy the properties off of the struct while in a lock.</blockquote></mx-reply>Huh, how do you attach the right cross realm prototype identifier?","m.relates_to":{"m.in_reply_to":{"event_id":"$aqrfv_GuSzdq1gYOq8eRqGcSGQF9ILkzj8EMtbTd73g"}},"msgtype":"m.text"},"ts":1720921449788,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Atxk8z_ZKcZEDX4wStLdDRiDwNcwgmSvvCcFlyQhzMM"},
{"content":{"body":"you don't? You're not creating a shared struct instance, just a normal object.","m.mentions":{},"msgtype":"m.text"},"ts":1720921470211,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ktxpzli3ixcj1JvCB-LsY0IVI8ZakgkqP6XOSKpkHAE"},
{"content":{"body":"Shared struct instances can only be created via a constructor.","m.mentions":{},"msgtype":"m.text"},"ts":1720921486447,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$U2Acs5QJzspKQ_LHTF3kAxQH5_hL_8NvnTasskoNc3Y"},
{"content":{"body":"Oic. Yes that should be handled like . Access","msgtype":"m.text"},"ts":1720921503597,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$RcfmPfThq_-KIbRXHounMcQitxMjw6bqE5QIFPVXz8E"},
{"content":{"body":"`{ ...sharedStruct }` is \"give me a normal object that is a copy of the struct fields\"","format":"org.matrix.custom.html","formatted_body":"<code>{ ...sharedStruct }</code> is \"give me a normal object that is a copy of the struct fields\"","m.mentions":{},"msgtype":"m.text"},"ts":1720921511808,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$uQG5mWUmTQ8YHsAhDAg9QcA6fMbU7krAtC-GM1os89A"},
{"content":{"body":"I skipped a lot of the discussion, but do shared properties have to appear as data properties, or could they appear as own accessors?","msgtype":"m.text"},"ts":1720921667410,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$_0S4jIY-it3VTv0pMGzgMmMXzcT2eO3qRFcfKLzD26A"},
{"content":{"body":"I guess accessors would be a significant overhead and that engines wouldn't always be able to optimize the same as data props?","msgtype":"m.text"},"ts":1720921738743,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$SfEmEOSKhlG7uE8zdDrTn56cEyHAkbM32x5G6Ke4W4s"},
{"content":{"body":"The problem we are trying to solve is how to explain unsafe blocks. I don’t see how accessors help.","msgtype":"m.text"},"ts":1720922113487,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$uidzLo5OWmfeihF9F_3TyqgxqVACsUyI8IXi0xxhaK8"},
{"content":{"body":"Well accessors means there are no issues with any of the MOP and no special property descriptions ","msgtype":"m.text"},"ts":1720922308599,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$g8MJXFu--MNDHaSoBgYQANxLYBXQzTmKJNYDqmVC9CA"},
{"content":{"body":"get *already* has a lexical rule for `\"use strict\"`. We could just encode [[Unsafe]] on a Reference Record just as we do [[Strict]], and just have the relevant operations check [[Unsafe]] when resolving the reference.","format":"org.matrix.custom.html","formatted_body":"get <em>already</em> has a lexical rule for <code>\"use strict\"</code>. We could just encode [[Unsafe]] on a Reference Record just as we do [[Strict]], and just have the relevant operations check [[Unsafe]] when resolving the reference.","m.mentions":{},"msgtype":"m.text"},"ts":1720922310700,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jCILp4wZOwTW_mWsaZ9SVdbq7Q7781Ybl2q9D00YYNY"},
{"content":{"body":"* Well accessors means there are no issues with any of the MOP and no special property descriptors","m.new_content":{"body":"Well accessors means there are no issues with any of the MOP and no special property descriptors","msgtype":"m.text"},"m.relates_to":{"event_id":"$g8MJXFu--MNDHaSoBgYQANxLYBXQzTmKJNYDqmVC9CA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720922321766,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$bULOH3F3KeeVkGs-kWUKa5Yo4UDDgh1XllyMzzMfRRI"},
{"content":{"body":"i.e., `GetValue` checks for [[Strict]] for variable references. We could modify Step 3.d to check for [[Unsafe]] and call baseObj.[[UnsafeGet]] in that case.","format":"org.matrix.custom.html","formatted_body":"i.e., <code>GetValue</code> checks for [[Strict]] for variable references. We could modify Step 3.d to check for [[Unsafe]] and call baseObj.[[UnsafeGet]] in that case.","m.mentions":{},"msgtype":"m.text"},"ts":1720922429055,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ai29mVGBD4pnvk-965gmj6_9tC-P8nZ_jGZqTp1YO2g"},
{"content":{"body":"Of course we're just pushing the problem down into a problem of function invocation working differently depending on the context where the call occurs, sometimes nested in the case of Reflect.get calling an \"accessors\"","msgtype":"m.text"},"ts":1720922467161,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$jzG020V4XanP9jC8Yg7CCfeBRAv0UKYwXZFLyMlMd0g"},
{"content":{"body":"Adding an [[UnsafeGet]] slot on objects seems to mesh better with the current spec than an UnsafeGet AO  ","m.mentions":{},"msgtype":"m.text"},"ts":1720922495371,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5-aW-pZ7lPUKuq8uu7nDUTIYp5LVBzT7kdTKhiYIW50"},
{"content":{"body":"It really feels that function coloring actually explains all this much better","msgtype":"m.text"},"ts":1720922554304,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ebirVYCGjy2w3IRdzAl0jXu4yPSv96AHuJ8pRFqqYsY"},
{"content":{"body":"If we don't have function coloring, we could just allow you to call the `Reflect.unsafeX` outside of an `unsafe` block. Its in the name, so it's already labeled unsafe.","format":"org.matrix.custom.html","formatted_body":"If we don't have function coloring, we could just allow you to call the <code>Reflect.unsafeX</code> outside of an <code>unsafe</code> block. Its in the name, so it's already labeled unsafe.","m.mentions":{},"msgtype":"m.text"},"ts":1720922565992,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BAER_yvsLgIa5pGfmixf2UThRYbtHoQgzX-kAa4cVPg"},
{"content":{"body":"> <@mhofman:matrix.org> Well accessors means there are no issues with any of the MOP and no special property descriptors\n\nHow are accessors supposed to know whether they are in an unsafe block?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24g8MJXFu--MNDHaSoBgYQANxLYBXQzTmKJNYDqmVC9CA\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Well accessors means there are no issues with any of the MOP and no special property descriptors</blockquote></mx-reply>How are accessors supposed to know whether they are in an unsafe block?","m.relates_to":{"m.in_reply_to":{"event_id":"$g8MJXFu--MNDHaSoBgYQANxLYBXQzTmKJNYDqmVC9CA"}},"msgtype":"m.text"},"ts":1720922603175,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$K7EOKZzDoXAbICmpF_U39jt-0RthnASVWQoN6scuoqs"},
{"content":{"body":"> <@littledan:matrix.org> How are accessors supposed to know whether they are in an unsafe block?\n\nYes that's the problem. Accessor simply reduce to a single kind of problem: function calls, instead of also dealing with the other meta ops. But it remains a problem that it's hard to explain the behavior without function coloring ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$K7EOKZzDoXAbICmpF_U39jt-0RthnASVWQoN6scuoqs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />How are accessors supposed to know whether they are in an unsafe block?</blockquote></mx-reply>Yes that's the problem. Accessor simply reduce to a single kind of problem: function calls, instead of also dealing with the other meta ops. But it remains a problem that it's hard to explain the behavior without function coloring","m.relates_to":{"m.in_reply_to":{"event_id":"$K7EOKZzDoXAbICmpF_U39jt-0RthnASVWQoN6scuoqs"}},"msgtype":"m.text"},"ts":1720922713988,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Y68X5SXhrkiyLANN93xv3fgtKTIFvcR1EfRFDewCFqM"},
{"content":{"body":"Could you describe how you picture function coloring to work?","msgtype":"m.text"},"ts":1720922772655,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$BLfl6w_cbysKTJ5ukQcgH7ON0XfmRKJ0ttL8BG8I5pM"},
{"content":{"body":"e.g., something like this but with proper support for `receiver`\n```js\nReflect.unsafeGet = (obj, key) => {\n  if ({}.hasOwnProperty.call(obj, key)) {\n    unsafe {\n      return obj[key];\n    }\n  }\n  return Reflect.get(obj, key);\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>e.g., something like this but with proper support for <code>receiver</code></p>\n<pre><code class=\"language-js\">Reflect.unsafeGet = (obj, key) =&gt; {\n  if ({}.hasOwnProperty.call(obj, key)) {\n    unsafe {\n      return obj[key];\n    }\n  }\n  return Reflect.get(obj, key);\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1720922798697,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7qSpqzyumGVAgp-Co6HsQ6BE5i7HxNzgySeKbDM-zqc"},
{"content":{"body":"> <@littledan:matrix.org> How are accessors supposed to know whether they are in an unsafe block?\n\nAccessors like `get foo() { }`? They don't? They're just a function. If you expose a getter/setter on your struct you need to do your due diligence to make it safe to outside callers.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$K7EOKZzDoXAbICmpF_U39jt-0RthnASVWQoN6scuoqs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>How are accessors supposed to know whether they are in an unsafe block?</blockquote></mx-reply>Accessors like <code>get foo() { }</code>? They don't? They're just a function. If you expose a getter/setter on your struct you need to do your due diligence to make it safe to outside callers.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$K7EOKZzDoXAbICmpF_U39jt-0RthnASVWQoN6scuoqs"}},"msgtype":"m.text"},"ts":1720922877255,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vPJX2En8tLlnMWjM_ffjhJ1xvRdD5b0QYczS0hdYJKw"},
{"content":{"body":"```js\nshared struct S {\n  #mut = new Atomics.Mutex();\n  #x;\n  get x() {\n    unsafe {\n      using lck = new Atomics.UniqueLock(this.#mut);\n      return this.#x;\n    }\n  }\n}\n```\nIt's nasty, but I suppose that's the point?","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">shared struct S {\n  #mut = new Atomics.Mutex();\n  #x;\n  get x() {\n    unsafe {\n      using lck = new Atomics.UniqueLock(this.#mut);\n      return this.#x;\n    }\n  }\n}\n</code></pre>\n<p>It's nasty, but I suppose that's the point?</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1720922965858,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fTyr5iKW7X01l3mozrz09AR1vfcSTUqpEBJsZv1U_R0"},
{"content":{"body":"Although, without function coloring I don't see how `accessor x;` could ever work. At least, not without doing `unsafe accessor x;` or `accessor x unsafe;` or something","format":"org.matrix.custom.html","formatted_body":"Although, without function coloring I don't see how <code>accessor x;</code> could ever work. At least, not without doing <code>unsafe accessor x;</code> or <code>accessor x unsafe;</code> or something","m.mentions":{},"msgtype":"m.text"},"ts":1720923097503,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PabQs89iCVIe_4rLEKRRWLWJPtZQDyPlSKHRu3eygIQ"},
{"content":{"body":"The way I picture function coloring is that every callable now has 2 ops: `[[Call]]` and `[[CallUnsafe]]`. If you are in an unsafe block, it's CallUnsafe that gets executed. For normal functions, CallUnsafe is the same as Call (maybe it's missing and it falls back to Call when missing?). For shared functions, Call throws (can only be called from unsafe blocks). Reflect and other intrinsics can have different Call and CallUnsafe behaviors, that effectively \"forward\" the unsafe state of the call site.","msgtype":"m.text"},"ts":1720923196506,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$pkrBES5UkjkPAOry5wkOkHKMY-CkDUPEYFaPPx1XOZM"},
{"content":{"body":"this example makes me wonder something... should a shared struct even be exposed? in rust for example you'd write your code like `struct Public(Mutex<Shared>)`, rather than `struct Public { mutex: Mutex<()>, shared: Shared }`","format":"org.matrix.custom.html","formatted_body":"this example makes me wonder something... should a shared struct even be exposed? in rust for example you'd write your code like <code>struct Public(Mutex&lt;Shared&gt;)</code>, rather than <code>struct Public { mutex: Mutex&lt;()&gt;, shared: Shared }</code>","m.mentions":{},"msgtype":"m.text"},"ts":1720923223125,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$ySXUbajSBiDt3Fmw4yvuTceMSrqgFZ6uV32AAgg75uA"},
{"content":{"body":"I'll have to follow up on any other discussion on Monday.","m.mentions":{},"msgtype":"m.text"},"ts":1720923241696,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$c8DaQih8PobTAp3dtLmCqVql0hBOKC8cA5_tQ3BcoXM"},
{"content":{"body":" * this example makes me wonder something... should a shared struct even be exposed? in rust for example you'd write your code like `struct Public(Mutex<Shared>)`, rather than `struct Shared { mutex: Mutex<()>, ...Shared }`","format":"org.matrix.custom.html","formatted_body":" * this example makes me wonder something... should a shared struct even be exposed? in rust for example you'd write your code like <code>struct Public(Mutex&lt;Shared&gt;)</code>, rather than <code>struct Shared { mutex: Mutex&lt;()&gt;, ...Shared }</code>","m.mentions":{},"m.new_content":{"body":"this example makes me wonder something... should a shared struct even be exposed? in rust for example you'd write your code like `struct Public(Mutex<Shared>)`, rather than `struct Shared { mutex: Mutex<()>, ...Shared }`","format":"org.matrix.custom.html","formatted_body":"this example makes me wonder something... should a shared struct even be exposed? in rust for example you'd write your code like <code>struct Public(Mutex&lt;Shared&gt;)</code>, rather than <code>struct Shared { mutex: Mutex&lt;()&gt;, ...Shared }</code>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$ySXUbajSBiDt3Fmw4yvuTceMSrqgFZ6uV32AAgg75uA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720923244005,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$U_QHALKs7rdaopUUYn5jzhRqHNaOt1gzJt5ljaUjEyQ"},
{"content":{"body":"That example I gave is a bad one ","m.mentions":{},"msgtype":"m.text"},"ts":1720923322594,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yYzvUfLcbqhQ8g00YdF-Pj75wcdOTTJwvU5C6rOgkDc"},
{"content":{"body":"> <@mhofman:matrix.org> The way I picture function coloring is that every callable now has 2 ops: `[[Call]]` and `[[CallUnsafe]]`. If you are in an unsafe block, it's CallUnsafe that gets executed. For normal functions, CallUnsafe is the same as Call (maybe it's missing and it falls back to Call when missing?). For shared functions, Call throws (can only be called from unsafe blocks). Reflect and other intrinsics can have different Call and CallUnsafe behaviors, that effectively \"forward\" the unsafe state of the call site.\n\nthis sounds coherent to me, but it's not what I would call \"function coloring\", which would apply recursively somehow, like async/await","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$pkrBES5UkjkPAOry5wkOkHKMY-CkDUPEYFaPPx1XOZM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>The way I picture function coloring is that every callable now has 2 ops: `[[Call]]` and `[[CallUnsafe]]`. If you are in an unsafe block, it&#39;s CallUnsafe that gets executed. For normal functions, CallUnsafe is the same as Call (maybe it&#39;s missing and it falls back to Call when missing?). For shared functions, Call throws (can only be called from unsafe blocks). Reflect and other intrinsics can have different Call and CallUnsafe behaviors, that effectively &quot;forward&quot; the unsafe state of the call site.</blockquote></mx-reply>this sounds coherent to me, but it's not what I would call \"function coloring\", which would apply recursively somehow, like async/await","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$pkrBES5UkjkPAOry5wkOkHKMY-CkDUPEYFaPPx1XOZM"}},"msgtype":"m.text"},"ts":1720923335083,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$2hXqV0uT013_wKJwHepB6f68mCMVNXe_fiD3qIdbpYc"},
{"content":{"body":"But yes, we think a shared struct should be exposed. Mutex and shared struct are not strongly tied to each other.","m.mentions":{},"msgtype":"m.text"},"ts":1720923357369,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RPvRH4dRAvC9VM1obp4vuKnc8Ed1eXJ_-j9zEF0p12M"},
{"content":{"body":"Function coloring does not imply recursive application. Async/await poisoning occurs because you are taking an inherently sequential, synchronous operation and want to turn it into a sequential asynchronous operation.","m.mentions":{},"msgtype":"m.text"},"ts":1720923432247,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zxDyawyh3k79yQtY2e_Mzj_QLpAKeci2qaWwHbqjoHg"},
{"content":{"body":"> <@littledan:matrix.org> this sounds coherent to me, but it's not what I would call \"function coloring\", which would apply recursively somehow, like async/await\n\nRight, technically you can have an `CallUnsafe` implementation that is not itself an unsafe scope ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$2hXqV0uT013_wKJwHepB6f68mCMVNXe_fiD3qIdbpYc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />this sounds coherent to me, but it's not what I would call \"function coloring\", which would apply recursively somehow, like async/await</blockquote></mx-reply>Right, technically you can have an <code>CallUnsafe</code> implementation that is not itself an unsafe scope","m.relates_to":{"m.in_reply_to":{"event_id":"$2hXqV0uT013_wKJwHepB6f68mCMVNXe_fiD3qIdbpYc"}},"msgtype":"m.text"},"ts":1720923469191,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Mehzmnw8Wjw0c_Kxv39y66uge3t0f7Bw9r22si1OLa8"},
{"content":{"body":"Async/await has function coloring (of a sort), but function coloring is not async/await.","m.mentions":{},"msgtype":"m.text"},"ts":1720923478110,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$GFxwom1mfCZfRDui-81c4zdoH0vtWnPbMZclya1GiVU"},
{"content":{"body":"no i don't mean you should have to use mutex specifically, that's just the example here.","m.mentions":{},"msgtype":"m.text"},"ts":1720923492050,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$wQ1bP509hGOI1Nnf2KC4JyL7GSi96Ov0AiS1K7oUUsY"},
{"content":{"body":"(I'm not criticizing the approach, it's just drastically different from what I expected when people started using the term \"function coloring\")","m.mentions":{},"msgtype":"m.text"},"ts":1720923509852,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$ZZcUEdNX_8Rr-DP3n5-7CdyBOvfsRFltRGKhIbHgPlU"},
{"content":{"body":"> <@devsnek:matrix.org> no i don't mean you should have to use mutex specifically, that's just the example here.\n\nyou can organize your code however you want. My use cases have entire object graphs of shared objects with any coordination being through  lock-free concurrent collections.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$wQ1bP509hGOI1Nnf2KC4JyL7GSi96Ov0AiS1K7oUUsY?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@devsnek:matrix.org\">@devsnek:matrix.org</a><br>no i don&#39;t mean you should have to use mutex specifically, that&#39;s just the example here.</blockquote></mx-reply>you can organize your code however you want. My use cases have entire object graphs of shared objects with any coordination being through  lock-free concurrent collections.","m.mentions":{"user_ids":["@devsnek:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$wQ1bP509hGOI1Nnf2KC4JyL7GSi96Ov0AiS1K7oUUsY"}},"msgtype":"m.text"},"ts":1720923593814,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FX2FI71zY2h9vfOstrkTKJm6BSHgeA7Bh2o0m_btRm4"},
{"content":{"body":"> <@littledan:matrix.org> (I'm not criticizing the approach, it's just drastically different from what I expected when people started using the term \"function coloring\")\n\nIt's possible I also misunderstood what people had in mind, but that is what I understood could work","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$ZZcUEdNX_8Rr-DP3n5-7CdyBOvfsRFltRGKhIbHgPlU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />(I'm not criticizing the approach, it's just drastically different from what I expected when people started using the term &quot;function coloring&quot;)</blockquote></mx-reply>It's possible I also misunderstood what people had in mind, but that is what I understood could work","m.relates_to":{"m.in_reply_to":{"event_id":"$ZZcUEdNX_8Rr-DP3n5-7CdyBOvfsRFltRGKhIbHgPlU"}},"msgtype":"m.text"},"ts":1720923647723,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$cQVrxcFk11phUiWxRUD1ZJBzpRPzhk_yb31QBViw-H4"},
{"content":{"body":"I was never concerned about function coloring, just that we didn't repeat async/await poisoning by essentially requiring your entire application to be inside of an `unsafe {}` block to use the feature. ","format":"org.matrix.custom.html","formatted_body":"I was never concerned about function coloring, just that we didn't repeat async/await poisoning by essentially requiring your entire application to be inside of an <code>unsafe {}</code> block to use the feature.","m.mentions":{},"msgtype":"m.text"},"ts":1720923758199,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$q4hmd_-3AWv2tmgdcjSRyidTS7Z45M3Q0aPcJKdH6Fo"},
{"content":{"body":"I think it would even be possible to make proxies work that way. As well as let user land do the same as intrinsics by having functions that have dual safe and unsafe behaviors","msgtype":"m.text"},"ts":1720923765614,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$bhXlNOlnXbqCl6wGgSLaQTBQl5ndm04j5WryqCv1ts8"},
{"content":{"body":"keeping `unsafe` localized to just the code that is actually unsafe is important. ","format":"org.matrix.custom.html","formatted_body":"keeping <code>unsafe</code> localized to just the code that is actually unsafe is important.","m.mentions":{},"msgtype":"m.text"},"ts":1720923792534,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$qTScx-jCmcFI85cM24TGbiZH2ON0s54cM8m6_OD1228"},
{"content":{"body":"Having functions that are aware of the context with which they are invoked is nothing new. `unsafe` is more like `this` than `async`/`await`, to be honest. `async` functions don't care how you call them and its up to the callers to determine if they want to use `await` or `.then`.","format":"org.matrix.custom.html","formatted_body":"Having functions that are aware of the context with which they are invoked is nothing new. <code>unsafe</code> is more like <code>this</code> than <code>async</code>/<code>await</code>, to be honest. <code>async</code> functions don't care how you call them and its up to the callers to determine if they want to use <code>await</code> or <code>.then</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1720923858212,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ekTWQnUoWTQJaEi3q3gpad0JWeWjE--9LH4H4OFY-lI"},
{"content":{"body":"> <@rbuckton:matrix.org> I was never concerned about function coloring, just that we didn't repeat async/await poisoning by essentially requiring your entire application to be inside of an `unsafe {}` block to use the feature. \n\nYeah I think that's accomplished by letting you start an unsafe block without modifying the signature of the surrounding function ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$q4hmd_-3AWv2tmgdcjSRyidTS7Z45M3Q0aPcJKdH6Fo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />I was never concerned about function coloring, just that we didn't repeat async/await poisoning by essentially requiring your entire application to be inside of an <code>unsafe {}</code> block to use the feature.</blockquote></mx-reply>Yeah I think that's accomplished by letting you start an unsafe block without modifying the signature of the surrounding function","m.relates_to":{"m.in_reply_to":{"event_id":"$q4hmd_-3AWv2tmgdcjSRyidTS7Z45M3Q0aPcJKdH6Fo"}},"msgtype":"m.text"},"ts":1720923877871,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$mdIzPIYxAH0J5vBJWZGtJmEE5Y8CWMW8OYvSB8Fcf0k"},
{"content":{"body":"Having an operation that throws outside of `unsafe` is more like having a function that throws if you give it the wrong `this`.","format":"org.matrix.custom.html","formatted_body":"Having an operation that throws outside of <code>unsafe</code> is more like having a function that throws if you give it the wrong <code>this</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1720923884573,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$c5q6U-QBFzh2y_4ZAAohBBWSmNHFlX9sl9xf-Nyqkms"},
{"content":{"body":"From a spec perspective, we just have to carry along this extra bit of information that indicates whether you were inside or outside of an `unsafe` block before you get/set.","format":"org.matrix.custom.html","formatted_body":"From a spec perspective, we just have to carry along this extra bit of information that indicates whether you were inside or outside of an <code>unsafe</code> block before you get/set.","m.mentions":{},"msgtype":"m.text"},"ts":1720923982128,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bnlrfwRABcqWagZgYtC2MXXyoGZ2ELWd-F6J1K9o4y4"},
{"content":{"body":"Aside from whatever we decide for `Reflect`, we could just ship with `unsafe {}` and add \"function coloring\" later if needs be.","format":"org.matrix.custom.html","formatted_body":"Aside from whatever we decide for <code>Reflect</code>, we could just ship with <code>unsafe {}</code> and add \"function coloring\" later if needs be.","m.mentions":{},"msgtype":"m.text"},"ts":1720924041658,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$f6fbD-uf3nx4uGjBJOFGQDs5ajITUuUnFnSEGNqrAYE"},
{"content":{"body":"For something like `unsafe function f() {}` I was less concerned with \"function coloring\" and more about improving the DX by moving the `unsafe` out of the block to cover the contents of the whole function (including parameter lists). I think the fact I proposed it as a prefix keyword led to the \"function coloring\" implication of unsafe functions in Rust, that the function itself is somehow unsafe. But it could just as easily have been `function f() unsafe { }` (and is an alternative I mentioned in the related issue on the repo).","format":"org.matrix.custom.html","formatted_body":"For something like <code>unsafe function f() {}</code> I was less concerned with \"function coloring\" and more about improving the DX by moving the <code>unsafe</code> out of the block to cover the contents of the whole function (including parameter lists). I think the fact I proposed it as a prefix keyword led to the \"function coloring\" implication of unsafe functions in Rust, that the function itself is somehow unsafe. But it could just as easily have been <code>function f() unsafe { }</code> (and is an alternative I mentioned in the related issue on the repo).","m.mentions":{},"msgtype":"m.text"},"ts":1720924183535,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Tk3nuuKMiplPR_nP0LJAUNL_kBFeILqCH0n7tEd71g0"},
{"content":{"body":"I'm just not a fan of the C++ namespace nesting style. It looks terrible and there's no reason we should repeat that approach.","m.mentions":{},"msgtype":"m.text"},"ts":1720924250083,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$uHu-jo9EYvcJH-KPb90DdWt-Etrt-ozWL0XCoqV9nVQ"},
{"content":{"body":"what if you want a function that should be unsafe to call","m.mentions":{},"msgtype":"m.text"},"ts":1720924263944,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$gIGbYYCFy0OjGTVnlTQXY9Ee-aH3MX0zVf5fJIC-Isc"},
{"content":{"body":" * what if you want a function that should be unsafe to call, `unsafe` on the declaration referring to the body seems inverted to the expectation of someone using that function.","format":"org.matrix.custom.html","formatted_body":" * what if you want a function that should be unsafe to call, <code>unsafe</code> on the declaration referring to the body seems inverted to the expectation of someone using that function.","m.mentions":{},"m.new_content":{"body":"what if you want a function that should be unsafe to call, `unsafe` on the declaration referring to the body seems inverted to the expectation of someone using that function.","format":"org.matrix.custom.html","formatted_body":"what if you want a function that should be unsafe to call, <code>unsafe</code> on the declaration referring to the body seems inverted to the expectation of someone using that function.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$gIGbYYCFy0OjGTVnlTQXY9Ee-aH3MX0zVf5fJIC-Isc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720924339612,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$eonY8rueD8GD9G5xJsKquci-tFKNDVHnDbsLomDMpHI"},
{"content":{"body":"> <@devsnek:matrix.org> what if you want a function that should be unsafe to call, `unsafe` on the declaration referring to the body seems inverted to the expectation of someone using that function.\n\nThen we reserve the prefix position for that, where `unsafe <x> ...` means \"x is unsafe and does unsafe things\" while `<x> unsafe ...` means \"x is safe, but does unsafe things\".","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$gIGbYYCFy0OjGTVnlTQXY9Ee-aH3MX0zVf5fJIC-Isc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@devsnek:matrix.org\">@devsnek:matrix.org</a><br>what if you want a function that should be unsafe to call, <code>unsafe</code> on the declaration referring to the body seems inverted to the expectation of someone using that function.</blockquote></mx-reply>Then we reserve the prefix position for that, where <code>unsafe &lt;x&gt; ...</code> means \"x is unsafe and does unsafe things\" while <code>&lt;x&gt; unsafe ...</code> means \"x is safe, but does unsafe things\".","m.mentions":{"user_ids":["@devsnek:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$gIGbYYCFy0OjGTVnlTQXY9Ee-aH3MX0zVf5fJIC-Isc"}},"msgtype":"m.text"},"ts":1720924355960,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$e_-Cuya4yttuLmqgiAluC877yHb2AGHaxZ5xQUcTDg4"},
{"content":{"body":"i.e., `function f() unsafe {}` is just shorthand for `function f() { unsafe { } }`. You use that for functions in your API that are at the safe/unsafe boundary. `unsafe function f() {}`, if we added it, would only be intended to be used for functions inside of your library/app that don't perform any locking as they expect to be called from code that has already done any necessary coordination.","format":"org.matrix.custom.html","formatted_body":"i.e., <code>function f() unsafe {}</code> is just shorthand for <code>function f() { unsafe { } }</code>. You use that for functions in your API that are at the safe/unsafe boundary. <code>unsafe function f() {}</code>, if we added it, would only be intended to be used for functions inside of your library/app that don't perform any locking as they expect to be called from code that has already done any necessary coordination.","m.mentions":{},"msgtype":"m.text"},"ts":1720924514995,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bxwrh16m3sBvuhoElRvuTrPEG4P6gEk5U_iUyNuXGps"},
{"content":{"body":"that sounds reasonable","m.mentions":{},"msgtype":"m.text"},"ts":1720924583923,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$5KXPKpQesx-z7R1pAii5Mp3sxTV-l23amQretXdDfB8"},
{"content":{"body":"i like composing with block syntax everywhere","m.mentions":{},"msgtype":"m.text"},"ts":1720924592359,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$wH6vo4CCCvSwEwA5boy4qxZ9dJtvA_s6z8ZeOa5wBlE"},
{"content":{"body":"`unsafe` should be as narrow as reasonable, while being as broad as is useful. I like the idea of being able to write `shared struct S unsafe {}` and have the whole body be unsafe, but also having `shared struct S { foo() unsafe { } }` when I want to limit exposure at the edges of a public API.","format":"org.matrix.custom.html","formatted_body":"<code>unsafe</code> should be as narrow as reasonable, while being as broad as is useful. I like the idea of being able to write <code>shared struct S unsafe {}</code> and have the whole body be unsafe, but also having <code>shared struct S { foo() unsafe { } }</code> when I want to limit exposure at the edges of a public API.","m.mentions":{},"msgtype":"m.text"},"ts":1720924661348,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$x6X-vyF_vzz5lJpHCqY-FXBskydWmPHYUlohccIY3EA"},
{"content":{"body":" * `unsafe` should be as narrow as is reasonable, while being as broad as is useful. I like the idea of being able to write `shared struct S unsafe {}` and have the whole body be unsafe, but also having `shared struct S { foo() unsafe { } }` when I want to limit exposure at the edges of a public API.","format":"org.matrix.custom.html","formatted_body":" * <code>unsafe</code> should be as narrow as is reasonable, while being as broad as is useful. I like the idea of being able to write <code>shared struct S unsafe {}</code> and have the whole body be unsafe, but also having <code>shared struct S { foo() unsafe { } }</code> when I want to limit exposure at the edges of a public API.","m.mentions":{},"m.new_content":{"body":"`unsafe` should be as narrow as is reasonable, while being as broad as is useful. I like the idea of being able to write `shared struct S unsafe {}` and have the whole body be unsafe, but also having `shared struct S { foo() unsafe { } }` when I want to limit exposure at the edges of a public API.","format":"org.matrix.custom.html","formatted_body":"<code>unsafe</code> should be as narrow as is reasonable, while being as broad as is useful. I like the idea of being able to write <code>shared struct S unsafe {}</code> and have the whole body be unsafe, but also having <code>shared struct S { foo() unsafe { } }</code> when I want to limit exposure at the edges of a public API.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$x6X-vyF_vzz5lJpHCqY-FXBskydWmPHYUlohccIY3EA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720924673234,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4S-cIxnDPcINi0QVPO5ID2zT8GT7Th9cMK7QM8BGPe0"},
{"content":{"body":"for example, I might have a `shared struct ConcurrentDeque<T> { ... }` whose public methods are safe to use and whose contents are private and encapsulated. But I might also want to have a `shared struct RingBuffer<T> unsafe { ... }` because the whole body will contain unsafe code and the struct won't be exposed outside of my API.","format":"org.matrix.custom.html","formatted_body":"for example, I might have a <code>shared struct ConcurrentDeque&lt;T&gt; { ... }</code> whose public methods are safe to use and whose contents are private and encapsulated. But I might also want to have a <code>shared struct RingBuffer&lt;T&gt; unsafe { ... }</code> because the whole body will contain unsafe code and the struct won't be exposed outside of my API.","m.mentions":{},"msgtype":"m.text"},"ts":1720924802602,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$qUALVp-M8Wl7GNxi4O2PLL68Q-kuygMnuCuI_TIeGlo"},
{"content":{"body":"We can defer \"function coloring\" till later. For example, we could add `Reflect.unsafeGet` now, which internally applies `unsafe` and thus can be used outside of an `unsafe {}` block, and if we add \"function coloring\" we could possibly modify `Reflect.get` to have some way to know. Maybe even add a `function.unsafe` metaproperty that lets you know if you were called from an unsafe context (which better explains a `Reflect.get` that works conditionally based on invocation context)","format":"org.matrix.custom.html","formatted_body":"We can defer \"function coloring\" till later. For example, we could add <code>Reflect.unsafeGet</code> now, which internally applies <code>unsafe</code> and thus can be used outside of an <code>unsafe {}</code> block, and if we add \"function coloring\" we could possibly modify <code>Reflect.get</code> to have some way to know. Maybe even add a <code>function.unsafe</code> metaproperty that lets you know if you were called from an unsafe context (which better explains a <code>Reflect.get</code> that works conditionally based on invocation context)","m.mentions":{},"msgtype":"m.text"},"ts":1720924946661,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HW4YwzoBAaMdXMbH7UQqX80t2rTZeKa5-kyvZvs5Uvg"},
{"content":{"body":" * We can defer \"function coloring\" 'til later. For example, we could add `Reflect.unsafeGet` now, which internally applies `unsafe` and thus can be used outside of an `unsafe {}` block, and if we add \"function coloring\" we could possibly modify `Reflect.get` to have some way to know. Maybe even add a `function.unsafe` metaproperty that lets you know if you were called from an unsafe context (which better explains a `Reflect.get` that works conditionally based on invocation context)","format":"org.matrix.custom.html","formatted_body":" * We can defer \"function coloring\" 'til later. For example, we could add <code>Reflect.unsafeGet</code> now, which internally applies <code>unsafe</code> and thus can be used outside of an <code>unsafe {}</code> block, and if we add \"function coloring\" we could possibly modify <code>Reflect.get</code> to have some way to know. Maybe even add a <code>function.unsafe</code> metaproperty that lets you know if you were called from an unsafe context (which better explains a <code>Reflect.get</code> that works conditionally based on invocation context)","m.mentions":{},"m.new_content":{"body":"We can defer \"function coloring\" 'til later. For example, we could add `Reflect.unsafeGet` now, which internally applies `unsafe` and thus can be used outside of an `unsafe {}` block, and if we add \"function coloring\" we could possibly modify `Reflect.get` to have some way to know. Maybe even add a `function.unsafe` metaproperty that lets you know if you were called from an unsafe context (which better explains a `Reflect.get` that works conditionally based on invocation context)","format":"org.matrix.custom.html","formatted_body":"We can defer \"function coloring\" 'til later. For example, we could add <code>Reflect.unsafeGet</code> now, which internally applies <code>unsafe</code> and thus can be used outside of an <code>unsafe {}</code> block, and if we add \"function coloring\" we could possibly modify <code>Reflect.get</code> to have some way to know. Maybe even add a <code>function.unsafe</code> metaproperty that lets you know if you were called from an unsafe context (which better explains a <code>Reflect.get</code> that works conditionally based on invocation context)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$HW4YwzoBAaMdXMbH7UQqX80t2rTZeKa5-kyvZvs5Uvg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720924960596,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VHTgynbR-6QRfk4kwopF7EQOXl0IGClg6SU5ra4mlkk"},
{"content":{"body":" * We can defer \"function coloring\" 'til later. For example, we could add `Reflect.unsafeGet` now, which internally applies `unsafe` and thus can be used outside of an `unsafe {}` block, and have `Reflect.get` always throw on shared struct fields. If we add \"function coloring\" later we could possibly modify `Reflect.get` to have some way to know. Maybe even add a `function.unsafe` metaproperty that lets you know if you were called from an unsafe context (which better explains a `Reflect.get` that works conditionally based on invocation context)","format":"org.matrix.custom.html","formatted_body":" * We can defer \"function coloring\" 'til later. For example, we could add <code>Reflect.unsafeGet</code> now, which internally applies <code>unsafe</code> and thus can be used outside of an <code>unsafe {}</code> block, and have <code>Reflect.get</code> always throw on shared struct fields. If we add \"function coloring\" later we could possibly modify <code>Reflect.get</code> to have some way to know. Maybe even add a <code>function.unsafe</code> metaproperty that lets you know if you were called from an unsafe context (which better explains a <code>Reflect.get</code> that works conditionally based on invocation context)","m.mentions":{},"m.new_content":{"body":"We can defer \"function coloring\" 'til later. For example, we could add `Reflect.unsafeGet` now, which internally applies `unsafe` and thus can be used outside of an `unsafe {}` block, and have `Reflect.get` always throw on shared struct fields. If we add \"function coloring\" later we could possibly modify `Reflect.get` to have some way to know. Maybe even add a `function.unsafe` metaproperty that lets you know if you were called from an unsafe context (which better explains a `Reflect.get` that works conditionally based on invocation context)","format":"org.matrix.custom.html","formatted_body":"We can defer \"function coloring\" 'til later. For example, we could add <code>Reflect.unsafeGet</code> now, which internally applies <code>unsafe</code> and thus can be used outside of an <code>unsafe {}</code> block, and have <code>Reflect.get</code> always throw on shared struct fields. If we add \"function coloring\" later we could possibly modify <code>Reflect.get</code> to have some way to know. Maybe even add a <code>function.unsafe</code> metaproperty that lets you know if you were called from an unsafe context (which better explains a <code>Reflect.get</code> that works conditionally based on invocation context)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$HW4YwzoBAaMdXMbH7UQqX80t2rTZeKa5-kyvZvs5Uvg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1720925025912,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Bzhi_a7_mcdgR5E18-0x5EqvvK688unHFqPgIAmioWQ"}
]