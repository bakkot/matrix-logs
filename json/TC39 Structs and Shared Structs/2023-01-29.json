[
{"content":{"body":"> <@mhofman:matrix.org> I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the `SharedStructType.prepare` call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.\n\nThe API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't \"provided after shared struct creation\", but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call `register` to make the struct type valid.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$8i7J9kQJhb-XbStTTn401OKkz212u1VY28tQRprdg9A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the <code>SharedStructType.prepare</code> call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.</blockquote></mx-reply>The API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't &quot;provided after shared struct creation&quot;, but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call <code>register</code> to make the struct type valid.","m.relates_to":{"m.in_reply_to":{"event_id":"$8i7J9kQJhb-XbStTTn401OKkz212u1VY28tQRprdg9A"}},"msgtype":"m.text"},"ts":1675030644023,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ok_kneLbAgu78fzVWNnEU0BIHg7kqAGHe-KInRL6rQk"},
{"content":{"body":"> <@mhofman:matrix.org> I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the `SharedStructType.prepare` call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.\n\n\"Objects that carry identity across agents\" doesn't help with the model I was proposing. In my model, each agent must independently register the type associated with the struct.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$8i7J9kQJhb-XbStTTn401OKkz212u1VY28tQRprdg9A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the <code>SharedStructType.prepare</code> call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.</blockquote></mx-reply>&quot;Objects that carry identity across agents&quot; doesn't help with the model I was proposing. In my model, each agent must independently register the type associated with the struct.","m.relates_to":{"m.in_reply_to":{"event_id":"$8i7J9kQJhb-XbStTTn401OKkz212u1VY28tQRprdg9A"}},"msgtype":"m.text"},"ts":1675030728064,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$e6HtUfVuEwqD6pGsgKPxmcc7hCMzVnbwbXTxQjEFkU4"},
{"content":{"body":"> <@rbuckton:matrix.org> The API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't \"provided after shared struct creation\", but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call `register` to make the struct type valid.\n\nThat's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Ok_kneLbAgu78fzVWNnEU0BIHg7kqAGHe-KInRL6rQk?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />The API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't &quot;provided after shared struct creation&quot;, but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call <code>register</code> to make the struct type valid.</blockquote></mx-reply>That's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?","m.relates_to":{"m.in_reply_to":{"event_id":"$Ok_kneLbAgu78fzVWNnEU0BIHg7kqAGHe-KInRL6rQk"}},"msgtype":"m.text"},"ts":1675030816004,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$fDbyW0xpgzVPMzTtud3pdbMuGzY-4CUzOVrjYJTEDSA"},
{"content":{"body":"> <@mhofman:matrix.org> ```js\n> // vector2d.js\n> // Each shared struct type, whether data only or \"prepared\" has its own unique type\n> export const vector2Dtype = SharedStructType.prepare([\"x\", \"y\"]);\n> \n> const _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n> \n> // custom construction behavior\n> export function Vector2D(x = 0, y = 0) {\n>   const _this = Reflect.construct(_Vector2D, [], new.target);\n>   _this.x = x;\n>   _this.y = y;\n>   return _this;\n> }\n> \n> // prototype methods\n> Vector2D.prototype.distanceTo = function (v) {\n>   const dx = this.x - v.x;\n>   const dy = this.y - v.y;\n>   return Math.sqrt(dx * dx + dy * dy);\n> };\n> \n> SharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n> \n> // main.js\n> import { Vector2D, vector2DType } from \"./vector2d.js\";\n> const v1 = new Vector2D(1, 2);\n> const worker = new Worker(\"worker.js\");\n> worker.postMessage([vector2DType, v1]);\n> \n> // worker.js\n> // worker imports Vector2D, which causes registration as a side-effect.\n> import { Vector2D, vector2DType } from \"./vector2d.js\";\n> \n> const v2 = new Vector2D(3, 4);\n> \n> parentPort.on(\"message\", ([mainVector2DType, v1]) => {\n>   SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n>   assert(mainVector2DType !== vector2DType);\n>   assert(\n>     SharedStructType.getConstructor(mainVector2DType) !==\n>       SharedStructType.getConstructor(vector2Dtype)\n>   );\n>   assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n>   v1.x; // 1\n>   v1.distanceTo(v2); // ok\n>   v1.toString(); // ok\n> });\n> \n> ```\n> \n> SharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.\n> \n> If the engine had to deduplicate itself, you'd either need a user provided type identifier at \"prepare\" time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?\n> \n> By having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.\n\nThis assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$hvjgknJMdDSzY0wT0tSfVQQAC1aW1pyprtBZ9Phn2ss?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br><pre><code class=\"language-js\">// vector2d.js\n// Each shared struct type, whether data only or \"prepared\" has its own unique type\nexport const vector2Dtype = SharedStructType.prepare([\"x\", \"y\"]);\n\nconst _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n  const _this = Reflect.construct(_Vector2D, [], new.target);\n  _this.x = x;\n  _this.y = y;\n  return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n  const dx = this.x - v.x;\n  const dy = this.y - v.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nSharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n\n// main.js\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\nconst v1 = new Vector2D(1, 2);\nconst worker = new Worker(\"worker.js\");\nworker.postMessage([vector2DType, v1]);\n\n// worker.js\n// worker imports Vector2D, which causes registration as a side-effect.\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\n\nconst v2 = new Vector2D(3, 4);\n\nparentPort.on(\"message\", ([mainVector2DType, v1]) =&gt; {\n  SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n  assert(mainVector2DType !== vector2DType);\n  assert(\n    SharedStructType.getConstructor(mainVector2DType) !==\n      SharedStructType.getConstructor(vector2Dtype)\n  );\n  assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n  v1.x; // 1\n  v1.distanceTo(v2); // ok\n  v1.toString(); // ok\n});\n\n</code></pre>\n<p>SharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.</p>\n<p>If the engine had to deduplicate itself, you'd either need a user provided type identifier at \"prepare\" time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?</p>\n<p>By having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.</p>\n</blockquote></mx-reply>This assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.","m.relates_to":{"m.in_reply_to":{"event_id":"$hvjgknJMdDSzY0wT0tSfVQQAC1aW1pyprtBZ9Phn2ss"}},"msgtype":"m.text"},"ts":1675030817823,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TepU-GzgUManPvjE1fUkLPg5sFvB4FMwfMfgaffejRo"},
{"content":{"body":"> <@mhofman:matrix.org> That's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?\n\nAn error. If the user defined identity is already registered to a different shape, it should throw.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$fDbyW0xpgzVPMzTtud3pdbMuGzY-4CUzOVrjYJTEDSA?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>That's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?</blockquote></mx-reply>An error. If the user defined identity is already registered to a different shape, it should throw.","m.relates_to":{"m.in_reply_to":{"event_id":"$fDbyW0xpgzVPMzTtud3pdbMuGzY-4CUzOVrjYJTEDSA"}},"msgtype":"m.text"},"ts":1675030852690,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2jylb2V5pVfU0gBQEa9H-FWWM-plrvho5_iYFy9oixk"},
{"content":{"body":"The bigger question is, what do we want the final, shipping version of this to look like? Do we want package authors to be able to define structs that package consumers can just use, or do we want package consumers to need to register shared structs themselves in any messaging scaffolding?","msgtype":"m.text"},"ts":1675030993461,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kK1IbaMmMwxeGJ0zd-H6SwgbvRrS8Z_6hxNDJArD7Zs"},
{"content":{"body":"> <@rbuckton:matrix.org> This assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.\n\nRight it requires more setup dance from the program, and it's that setup dance that we should try to make easier. But I'm very doubtful we can overcome the issue with a user supplied identity.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$TepU-GzgUManPvjE1fUkLPg5sFvB4FMwfMfgaffejRo?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />This assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.</blockquote></mx-reply>Right it requires more setup dance from the program, and it's that setup dance that we should try to make easier. But I'm very doubtful we can overcome the issue with a user supplied identity.","m.relates_to":{"m.in_reply_to":{"event_id":"$TepU-GzgUManPvjE1fUkLPg5sFvB4FMwfMfgaffejRo"}},"msgtype":"m.text"},"ts":1675031018071,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Mv2mFY-shG4nTGbsQ7lTunP6C_q_pUGzGCx3zfR1b3o"},
{"content":{"body":"If we want to make this simple for application developers, then they should be able to install a package, import the struct type (or at least use a side-effecting import for the file containing the struct type to make it visible to the agent), and just use it. This means some kind of per-agent registration would need to occur within the file that contains the struct itself. One mechanism we discussed for that was to depend on the resolved module ID (i.e., if we were depending on the module loader cache). However, that doesn't work well with bundling scenarios where I have one bundle for the main thread, and another bundle for a worker.","msgtype":"m.text"},"ts":1675031284034,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$STp2FvQy74UyXdNoq-WwqPUCwNlcBXLmI4suGKXDxiQ"},
{"content":{"body":"So there would need to be some way to uniquely identify a struct type regardless of path, such that the same struct types in each bundle can be associated with each other.","msgtype":"m.text"},"ts":1675031340167,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Kt9g6b5eHlCMCw43e_pDKJejXSjD3WYGxwRppQ6NCn4"},
{"content":{"body":"User-defined IDs are used _everywhere_ for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","format":"org.matrix.custom.html","formatted_body":"User-defined IDs are used <em>everywhere</em> for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","msgtype":"m.text"},"ts":1675031464823,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$i5Hh4S4Td0Sui0rP6ooCsXgUOxYcmgMRI7dzFF-NeSE"},
{"content":{"body":" * User-defined IDs are used _everywhere_ for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","format":"org.matrix.custom.html","formatted_body":" * User-defined IDs are used <em>everywhere</em> for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","m.new_content":{"body":"User-defined IDs are used _everywhere_ for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","format":"org.matrix.custom.html","formatted_body":"User-defined IDs are used <em>everywhere</em> for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","msgtype":"m.text"},"m.relates_to":{"event_id":"$i5Hh4S4Td0Sui0rP6ooCsXgUOxYcmgMRI7dzFF-NeSE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675031482312,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hocHwqF_wgBGhGeaxV7896nUHGUNMvkOXMfdnZdQLjc"},
{"content":{"body":"My main concern is that any burden for registration should fall on the package developer, not the application developer, whatever the design looks like in the end.","msgtype":"m.text"},"ts":1675031603933,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wu7CzIQ-QkEg8bcs9QDLq4PtmKMgQd8qdVz_s8_fRFA"}
]