[
{"content":{"body":"> <@mhofman:matrix.org> I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the `SharedStructType.prepare` call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.\n\nThe API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't \"provided after shared struct creation\", but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call `register` to make the struct type valid.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$8i7J9kQJhb-XbStTTn401OKkz212u1VY28tQRprdg9A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the <code>SharedStructType.prepare</code> call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.</blockquote></mx-reply>The API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't &quot;provided after shared struct creation&quot;, but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call <code>register</code> to make the struct type valid.","m.relates_to":{"m.in_reply_to":{"event_id":"$8i7J9kQJhb-XbStTTn401OKkz212u1VY28tQRprdg9A"}},"msgtype":"m.text"},"ts":1675030644023,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ok_kneLbAgu78fzVWNnEU0BIHg7kqAGHe-KInRL6rQk"},
{"content":{"body":"> <@mhofman:matrix.org> I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the `SharedStructType.prepare` call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.\n\n\"Objects that carry identity across agents\" doesn't help with the model I was proposing. In my model, each agent must independently register the type associated with the struct.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$8i7J9kQJhb-XbStTTn401OKkz212u1VY28tQRprdg9A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the <code>SharedStructType.prepare</code> call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.</blockquote></mx-reply>&quot;Objects that carry identity across agents&quot; doesn't help with the model I was proposing. In my model, each agent must independently register the type associated with the struct.","m.relates_to":{"m.in_reply_to":{"event_id":"$8i7J9kQJhb-XbStTTn401OKkz212u1VY28tQRprdg9A"}},"msgtype":"m.text"},"ts":1675030728064,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$e6HtUfVuEwqD6pGsgKPxmcc7hCMzVnbwbXTxQjEFkU4"},
{"content":{"body":"> <@rbuckton:matrix.org> The API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't \"provided after shared struct creation\", but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call `register` to make the struct type valid.\n\nThat's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Ok_kneLbAgu78fzVWNnEU0BIHg7kqAGHe-KInRL6rQk?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />The API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't &quot;provided after shared struct creation&quot;, but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call <code>register</code> to make the struct type valid.</blockquote></mx-reply>That's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?","m.relates_to":{"m.in_reply_to":{"event_id":"$Ok_kneLbAgu78fzVWNnEU0BIHg7kqAGHe-KInRL6rQk"}},"msgtype":"m.text"},"ts":1675030816004,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$fDbyW0xpgzVPMzTtud3pdbMuGzY-4CUzOVrjYJTEDSA"},
{"content":{"body":"> <@mhofman:matrix.org> ```js\n> // vector2d.js\n> // Each shared struct type, whether data only or \"prepared\" has its own unique type\n> export const vector2Dtype = SharedStructType.prepare([\"x\", \"y\"]);\n> \n> const _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n> \n> // custom construction behavior\n> export function Vector2D(x = 0, y = 0) {\n>   const _this = Reflect.construct(_Vector2D, [], new.target);\n>   _this.x = x;\n>   _this.y = y;\n>   return _this;\n> }\n> \n> // prototype methods\n> Vector2D.prototype.distanceTo = function (v) {\n>   const dx = this.x - v.x;\n>   const dy = this.y - v.y;\n>   return Math.sqrt(dx * dx + dy * dy);\n> };\n> \n> SharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n> \n> // main.js\n> import { Vector2D, vector2DType } from \"./vector2d.js\";\n> const v1 = new Vector2D(1, 2);\n> const worker = new Worker(\"worker.js\");\n> worker.postMessage([vector2DType, v1]);\n> \n> // worker.js\n> // worker imports Vector2D, which causes registration as a side-effect.\n> import { Vector2D, vector2DType } from \"./vector2d.js\";\n> \n> const v2 = new Vector2D(3, 4);\n> \n> parentPort.on(\"message\", ([mainVector2DType, v1]) => {\n>   SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n>   assert(mainVector2DType !== vector2DType);\n>   assert(\n>     SharedStructType.getConstructor(mainVector2DType) !==\n>       SharedStructType.getConstructor(vector2Dtype)\n>   );\n>   assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n>   v1.x; // 1\n>   v1.distanceTo(v2); // ok\n>   v1.toString(); // ok\n> });\n> \n> ```\n> \n> SharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.\n> \n> If the engine had to deduplicate itself, you'd either need a user provided type identifier at \"prepare\" time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?\n> \n> By having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.\n\nThis assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$hvjgknJMdDSzY0wT0tSfVQQAC1aW1pyprtBZ9Phn2ss?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br><pre><code class=\"language-js\">// vector2d.js\n// Each shared struct type, whether data only or \"prepared\" has its own unique type\nexport const vector2Dtype = SharedStructType.prepare([\"x\", \"y\"]);\n\nconst _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n  const _this = Reflect.construct(_Vector2D, [], new.target);\n  _this.x = x;\n  _this.y = y;\n  return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n  const dx = this.x - v.x;\n  const dy = this.y - v.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nSharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n\n// main.js\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\nconst v1 = new Vector2D(1, 2);\nconst worker = new Worker(\"worker.js\");\nworker.postMessage([vector2DType, v1]);\n\n// worker.js\n// worker imports Vector2D, which causes registration as a side-effect.\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\n\nconst v2 = new Vector2D(3, 4);\n\nparentPort.on(\"message\", ([mainVector2DType, v1]) =&gt; {\n  SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n  assert(mainVector2DType !== vector2DType);\n  assert(\n    SharedStructType.getConstructor(mainVector2DType) !==\n      SharedStructType.getConstructor(vector2Dtype)\n  );\n  assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n  v1.x; // 1\n  v1.distanceTo(v2); // ok\n  v1.toString(); // ok\n});\n\n</code></pre>\n<p>SharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.</p>\n<p>If the engine had to deduplicate itself, you'd either need a user provided type identifier at \"prepare\" time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?</p>\n<p>By having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.</p>\n</blockquote></mx-reply>This assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.","m.relates_to":{"m.in_reply_to":{"event_id":"$hvjgknJMdDSzY0wT0tSfVQQAC1aW1pyprtBZ9Phn2ss"}},"msgtype":"m.text"},"ts":1675030817823,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TepU-GzgUManPvjE1fUkLPg5sFvB4FMwfMfgaffejRo"},
{"content":{"body":"> <@mhofman:matrix.org> That's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?\n\nAn error. If the user defined identity is already registered to a different shape, it should throw.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$fDbyW0xpgzVPMzTtud3pdbMuGzY-4CUzOVrjYJTEDSA?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>That's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?</blockquote></mx-reply>An error. If the user defined identity is already registered to a different shape, it should throw.","m.relates_to":{"m.in_reply_to":{"event_id":"$fDbyW0xpgzVPMzTtud3pdbMuGzY-4CUzOVrjYJTEDSA"}},"msgtype":"m.text"},"ts":1675030852690,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2jylb2V5pVfU0gBQEa9H-FWWM-plrvho5_iYFy9oixk"},
{"content":{"body":"The bigger question is, what do we want the final, shipping version of this to look like? Do we want package authors to be able to define structs that package consumers can just use, or do we want package consumers to need to register shared structs themselves in any messaging scaffolding?","msgtype":"m.text"},"ts":1675030993461,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kK1IbaMmMwxeGJ0zd-H6SwgbvRrS8Z_6hxNDJArD7Zs"},
{"content":{"body":"> <@rbuckton:matrix.org> This assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.\n\nRight it requires more setup dance from the program, and it's that setup dance that we should try to make easier. But I'm very doubtful we can overcome the issue with a user supplied identity.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$TepU-GzgUManPvjE1fUkLPg5sFvB4FMwfMfgaffejRo?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />This assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.</blockquote></mx-reply>Right it requires more setup dance from the program, and it's that setup dance that we should try to make easier. But I'm very doubtful we can overcome the issue with a user supplied identity.","m.relates_to":{"m.in_reply_to":{"event_id":"$TepU-GzgUManPvjE1fUkLPg5sFvB4FMwfMfgaffejRo"}},"msgtype":"m.text"},"ts":1675031018071,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Mv2mFY-shG4nTGbsQ7lTunP6C_q_pUGzGCx3zfR1b3o"},
{"content":{"body":"If we want to make this simple for application developers, then they should be able to install a package, import the struct type (or at least use a side-effecting import for the file containing the struct type to make it visible to the agent), and just use it. This means some kind of per-agent registration would need to occur within the file that contains the struct itself. One mechanism we discussed for that was to depend on the resolved module ID (i.e., if we were depending on the module loader cache). However, that doesn't work well with bundling scenarios where I have one bundle for the main thread, and another bundle for a worker.","msgtype":"m.text"},"ts":1675031284034,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$STp2FvQy74UyXdNoq-WwqPUCwNlcBXLmI4suGKXDxiQ"},
{"content":{"body":"So there would need to be some way to uniquely identify a struct type regardless of path, such that the same struct types in each bundle can be associated with each other.","msgtype":"m.text"},"ts":1675031340167,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Kt9g6b5eHlCMCw43e_pDKJejXSjD3WYGxwRppQ6NCn4"},
{"content":{"body":"User-defined IDs are used _everywhere_ for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","format":"org.matrix.custom.html","formatted_body":"User-defined IDs are used <em>everywhere</em> for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","msgtype":"m.text"},"ts":1675031464823,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$i5Hh4S4Td0Sui0rP6ooCsXgUOxYcmgMRI7dzFF-NeSE"},
{"content":{"body":" * User-defined IDs are used _everywhere_ for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","format":"org.matrix.custom.html","formatted_body":" * User-defined IDs are used <em>everywhere</em> for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","m.new_content":{"body":"User-defined IDs are used _everywhere_ for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","format":"org.matrix.custom.html","formatted_body":"User-defined IDs are used <em>everywhere</em> for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.","msgtype":"m.text"},"m.relates_to":{"event_id":"$i5Hh4S4Td0Sui0rP6ooCsXgUOxYcmgMRI7dzFF-NeSE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675031482312,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hocHwqF_wgBGhGeaxV7896nUHGUNMvkOXMfdnZdQLjc"},
{"content":{"body":"My main concern is that any burden for registration should fall on the package developer, not the application developer, whatever the design looks like in the end.","msgtype":"m.text"},"ts":1675031603933,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wu7CzIQ-QkEg8bcs9QDLq4PtmKMgQd8qdVz_s8_fRFA"},
{"content":{"body":"I think the question raised by Ashley Claymoreis is relevant: how do you handle the fan in case where multiple agents setup a shared type before being introduced to each other. A forgeable type identifier in my opinion is not safe, and I'm pretty sure it'd never make it through committee. However I'm not convinced we need prototype/constructor continuity here.","format":"org.matrix.custom.html","formatted_body":"I think the question raised by <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">Ashley Claymore</a>is relevant: how do you handle the fan in case where multiple agents setup a shared type before being introduced to each other. A forgeable type identifier in my opinion is not safe, and I'm pretty sure it'd never make it through committee. However I'm not convinced we need prototype/constructor continuity here.","msgtype":"m.text"},"ts":1675031762527,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$eGy4litn6kZmcIVd6ZuqpC0X5PTxGPqMfBebZQxrb0Y"},
{"content":{"body":"And that whatever that design is should be able to take into account bundling, be that with module declarations/module expressions, or traditional bundlers","msgtype":"m.text"},"ts":1675031765085,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KNZMkQAC9Mkj8dADW_ilPoSRhZBojsCVpwGwn4L73kk"},
{"content":{"body":"> <@mhofman:matrix.org> I think the question raised by Ashley Claymoreis is relevant: how do you handle the fan in case where multiple agents setup a shared type before being introduced to each other. A forgeable type identifier in my opinion is not safe, and I'm pretty sure it'd never make it through committee. However I'm not convinced we need prototype/constructor continuity here.\n\nSince this wouldn't be a global registry, it wouldn't matter. Your code defines the relationship between an id and a constructor/prototype on your agent. If your code tries to register the same unique id twice, it should be an error so you can isolate the problem early. If the constructor/prototype on one agent doesn't match the constructor/prototype on another agent, that's fine. In fact, that may even be a value add, since bundlers could potentially tree-shake away prototype methods that aren't used.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$eGy4litn6kZmcIVd6ZuqpC0X5PTxGPqMfBebZQxrb0Y?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I think the question raised by <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">Ashley Claymore</a>is relevant: how do you handle the fan in case where multiple agents setup a shared type before being introduced to each other. A forgeable type identifier in my opinion is not safe, and I'm pretty sure it'd never make it through committee. However I'm not convinced we need prototype/constructor continuity here.</blockquote></mx-reply>Since this wouldn't be a global registry, it wouldn't matter. Your code defines the relationship between an id and a constructor/prototype on your agent. If your code tries to register the same unique id twice, it should be an error so you can isolate the problem early. If the constructor/prototype on one agent doesn't match the constructor/prototype on another agent, that's fine. In fact, that may even be a value add, since bundlers could potentially tree-shake away prototype methods that aren't used.","m.relates_to":{"m.in_reply_to":{"event_id":"$eGy4litn6kZmcIVd6ZuqpC0X5PTxGPqMfBebZQxrb0Y"}},"msgtype":"m.text"},"ts":1675031936259,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$qSAcHxyeusBFIS8JmK4SbCPNgvAMgY_UAC_ehs095nk"},
{"content":{"body":"How is it not a global registry?","msgtype":"m.text"},"ts":1675032133632,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$YSDBQzMGVj1xsllXniqgN-3BQqZ9UjMXKay-bBn57Y4"},
{"content":{"body":"You're assuming there is a single author to code running in an agent","msgtype":"m.text"},"ts":1675032177419,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$e29uHieBQEyJfyVZd0Jb-oPR07DqPF_ND799BoV4C9g"},
{"content":{"body":"All that matters is that a given struct type has the same type identity on multiple Agents, so that each Agent can bind a prototype to that type identity. Producing an instance of a struct type should be possible on any Agent, such that I could do:\n\n```js\n// main.js\nconst v1 = new Vector2D(1, 2);\nworker.postMessage(v1);\nworker.on(\"message\", e => console.log(e instanceof Vector2D));\n\n// worker.js\nconst v2 = new Vector2D(3, 4);\nremotePort.postMessage(v1);\nremotePort.on(\"message\", e => console.log(e instanceof Vector2D));\n```","format":"org.matrix.custom.html","formatted_body":"<p>All that matters is that a given struct type has the same type identity on multiple Agents, so that each Agent can bind a prototype to that type identity. Producing an instance of a struct type should be possible on any Agent, such that I could do:</p>\n<pre><code class=\"language-js\">// main.js\nconst v1 = new Vector2D(1, 2);\nworker.postMessage(v1);\nworker.on(&quot;message&quot;, e =&gt; console.log(e instanceof Vector2D));\n\n// worker.js\nconst v2 = new Vector2D(3, 4);\nremotePort.postMessage(v1);\nremotePort.on(&quot;message&quot;, e =&gt; console.log(e instanceof Vector2D));\n</code></pre>\n","msgtype":"m.text"},"ts":1675032179625,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JAbt9qIvsHW9O3eqadAIA4t65RR5aa2kG5G-eymS-ro"},
{"content":{"body":"And a single author to code running in communicating agents","msgtype":"m.text"},"ts":1675032193360,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$7RvbMoWXbLUpM0gjPjf-yFZLitq8DNEdDZXNoe6WFmk"},
{"content":{"body":"> <@mhofman:matrix.org> How is it not a global registry?\n\nI don't understand. Each Agent would have an independent registry mapping a type identity to a prototype. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$YSDBQzMGVj1xsllXniqgN-3BQqZ9UjMXKay-bBn57Y4?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>How is it not a global registry?</blockquote></mx-reply>I don't understand. Each Agent would have an independent registry mapping a type identity to a prototype.","m.relates_to":{"m.in_reply_to":{"event_id":"$YSDBQzMGVj1xsllXniqgN-3BQqZ9UjMXKay-bBn57Y4"}},"msgtype":"m.text"},"ts":1675032209422,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9l-wJSgpyzMq3praAVKhIXs4VlCNKGXmXv57Bo-JfJ8"},
{"content":{"body":"> <@mhofman:matrix.org> You're assuming there is a single author to code running in an agent\n\nI'm assuming that if you want to consistently use the same data in multiple agents, with the same underling behavior, then you should use a consistent definition.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$e29uHieBQEyJfyVZd0Jb-oPR07DqPF_ND799BoV4C9g?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>You&#39;re assuming there is a single author to code running in an agent</blockquote></mx-reply>I'm assuming that if you want to consistently use the same data in multiple agents, with the same underling behavior, then you should use a consistent definition.","m.relates_to":{"m.in_reply_to":{"event_id":"$e29uHieBQEyJfyVZd0Jb-oPR07DqPF_ND799BoV4C9g"}},"msgtype":"m.text"},"ts":1675032265264,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$6fj7NDPiYD6L9_9XkUHwQajV_ahFOpCdKMjODhO63z0"},
{"content":{"body":"> <@rbuckton:matrix.org> All that matters is that a given struct type has the same type identity on multiple Agents, so that each Agent can bind a prototype to that type identity. Producing an instance of a struct type should be possible on any Agent, such that I could do:\n> \n> ```js\n> // main.js\n> const v1 = new Vector2D(1, 2);\n> worker.postMessage(v1);\n> worker.on(\"message\", e => console.log(e instanceof Vector2D));\n> \n> // worker.js\n> const v2 = new Vector2D(3, 4);\n> remotePort.postMessage(v1);\n> remotePort.on(\"message\", e => console.log(e instanceof Vector2D));\n> ```\n\nDo you expect these console logs to print true or false?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$JAbt9qIvsHW9O3eqadAIA4t65RR5aa2kG5G-eymS-ro?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br /><p>All that matters is that a given struct type has the same type identity on multiple Agents, so that each Agent can bind a prototype to that type identity. Producing an instance of a struct type should be possible on any Agent, such that I could do:</p>\n<pre><code class=\"language-js\">// main.js\nconst v1 = new Vector2D(1, 2);\nworker.postMessage(v1);\nworker.on(&quot;message&quot;, e =&gt; console.log(e instanceof Vector2D));\n\n// worker.js\nconst v2 = new Vector2D(3, 4);\nremotePort.postMessage(v1);\nremotePort.on(&quot;message&quot;, e =&gt; console.log(e instanceof Vector2D));\n</code></pre>\n</blockquote></mx-reply>Do you expect these console logs to print true or false?","m.relates_to":{"m.in_reply_to":{"event_id":"$JAbt9qIvsHW9O3eqadAIA4t65RR5aa2kG5G-eymS-ro"}},"msgtype":"m.text"},"ts":1675032290931,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$1-DK3cc-tgeIBgq3KW2_qtAk4v-2zctXjJQh3fDsEfg"},
{"content":{"body":"I expect them to print `true`.","format":"org.matrix.custom.html","formatted_body":"I expect them to print <code>true</code>.","msgtype":"m.text"},"ts":1675032299317,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$uFWxzpigHx1ELySKV720HlfiXbssZxsovrDtnL3aLl0"},
{"content":{"body":"Then you expect continuity of constructor / prototype across agents","msgtype":"m.text"},"ts":1675032355135,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$mKWtiTRGW6aOwdA2OpLzO2UsIHC4MA15Zl3_Hy9-BN8"},
{"content":{"body":"If both the main thread and worker register their version of `Vector2D.prototype` for the same type identity, then creating those structs on either side and sending them to the other side should be consistent.","format":"org.matrix.custom.html","formatted_body":"If both the main thread and worker register their version of <code>Vector2D.prototype</code> for the same type identity, then creating those structs on either side and sending them to the other side should be consistent.","msgtype":"m.text"},"ts":1675032357661,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RhY38tC3RsqqZ2IkM_hIDyNOpOu_HIysalhVIl9nh_I"},
{"content":{"body":"> <@mhofman:matrix.org> Then you expect continuity of constructor / prototype across agents\n\nNo. I would _recommend_ continuity of the prototype across agents. Constructor doesn't actually matter.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$mKWtiTRGW6aOwdA2OpLzO2UsIHC4MA15Zl3_Hy9-BN8?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Then you expect continuity of constructor / prototype across agents</blockquote></mx-reply>No. I would <em>recommend</em> continuity of the prototype across agents. Constructor doesn't actually matter.","m.relates_to":{"m.in_reply_to":{"event_id":"$mKWtiTRGW6aOwdA2OpLzO2UsIHC4MA15Zl3_Hy9-BN8"}},"msgtype":"m.text"},"ts":1675032398598,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JWcAoWbT44oiqXrwQtqP2M2EH0zIx6UQ-GPlceW0VdQ"},
{"content":{"body":"As I said, a bundler could potentially tree-shake away prototype methods on either side based on use, and it should still work.","msgtype":"m.text"},"ts":1675032417243,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kvKhSrAyqyDH3LQbFg6mTV12icfBaUQ43Hef1bRS7ns"},
{"content":{"body":"> <@rbuckton:matrix.org> I don't understand. Each Agent would have an independent registry mapping a type identity to a prototype. \n\nYes that we agree on. The question is who generates the key of that mapping. If it's user controlled, you have code running in an agent that can interfere with other code running in the same agent.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$9l-wJSgpyzMq3praAVKhIXs4VlCNKGXmXv57Bo-JfJ8?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />I don't understand. Each Agent would have an independent registry mapping a type identity to a prototype.</blockquote></mx-reply>Yes that we agree on. The question is who generates the key of that mapping. If it's user controlled, you have code running in an agent that can interfere with other code running in the same agent.","m.relates_to":{"m.in_reply_to":{"event_id":"$9l-wJSgpyzMq3praAVKhIXs4VlCNKGXmXv57Bo-JfJ8"}},"msgtype":"m.text"},"ts":1675032441361,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$gVY12hJ6I7jvrLqdey72uoT11XJhsch3gAveSiG4GLg"},
{"content":{"body":"> <@rbuckton:matrix.org> No. I would _recommend_ continuity of the prototype across agents. Constructor doesn't actually matter.\n\nBy continuity I mean recognition of the prototype objects identity. It doesn't need to be the same in multiple agents, obviously, but an object of the type registered in agent1 and sent to agent2 is expected to have the same prototype as an object of the \"same type\" created in agent2. I am not convinced we need that","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$JWcAoWbT44oiqXrwQtqP2M2EH0zIx6UQ-GPlceW0VdQ?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />No. I would <em>recommend</em> continuity of the prototype across agents. Constructor doesn't actually matter.</blockquote></mx-reply>By continuity I mean recognition of the prototype objects identity. It doesn't need to be the same in multiple agents, obviously, but an object of the type registered in agent1 and sent to agent2 is expected to have the same prototype as an object of the &quot;same type&quot; created in agent2. I am not convinced we need that","m.relates_to":{"m.in_reply_to":{"event_id":"$JWcAoWbT44oiqXrwQtqP2M2EH0zIx6UQ-GPlceW0VdQ"}},"msgtype":"m.text"},"ts":1675032604572,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$-t5fb5VdX70RMFG4f90WgyHFE56lVWfkORZwuP-SQfE"},
{"content":{"body":"I believe we could get away with duck typing here","msgtype":"m.text"},"ts":1675032692853,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$tNZl8FVHXmw9yF8f1qi0xolT8k-8ps9gbv21nuS2qAA"},
{"content":{"body":"Basically, imagine this:\n- A Struct Type has a type identity (be it system or user produced).\n- A Struct instance has a private slot containing that type identity.\n- An Agent has a mapping of type identity to a prototype.\n- Agent A registers a Struct type (`Foo`) for a given type identity and a prototype defined in a realm in Agent A.\n- Agent B registers a Struct type (`Foo`) for the same type identity and a prototype defined in a realm in Agent B.\n- Agent A constructs an instance of Agent A's struct type `Foo`, sends it to Agent B.\n- Agent B receives the struct value. When Agent B performs ToObject on the struct value, it looks up the type identity in its internal slot in Agent B's registry to find the prototype.\n- Agent B constructs an instance of Agent B's struct type `Foo`, sends it to Agent A.\n- Agent A receives the struct value. When Agent A performs ToObject on the struct value, it looks up the type identity in its internal slot in Agent A's registry to find the prototype.\n","format":"org.matrix.custom.html","formatted_body":"<p>Basically, imagine this:</p>\n<ul>\n<li>A Struct Type has a type identity (be it system or user produced).</li>\n<li>A Struct instance has a private slot containing that type identity.</li>\n<li>An Agent has a mapping of type identity to a prototype.</li>\n<li>Agent A registers a Struct type (<code>Foo</code>) for a given type identity and a prototype defined in a realm in Agent A.</li>\n<li>Agent B registers a Struct type (<code>Foo</code>) for the same type identity and a prototype defined in a realm in Agent B.</li>\n<li>Agent A constructs an instance of Agent A's struct type <code>Foo</code>, sends it to Agent B.</li>\n<li>Agent B receives the struct value. When Agent B performs ToObject on the struct value, it looks up the type identity in its internal slot in Agent B's registry to find the prototype.</li>\n<li>Agent B constructs an instance of Agent B's struct type <code>Foo</code>, sends it to Agent A.</li>\n<li>Agent A receives the struct value. When Agent A performs ToObject on the struct value, it looks up the type identity in its internal slot in Agent A's registry to find the prototype.</li>\n</ul>\n","msgtype":"m.text"},"ts":1675032748455,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$D6fS3oagnlaC6RWlpx74ukS4dQujXVislRWg53X_fq8"},
{"content":{"body":"The type identity we transfer from A to B, or vise versa, could also encode the expected shape of the struct type. That way, if Agent A and Agent B disagree on the shape associated with the type identity, that error would be thrown on prototype lookup in ToObject.","msgtype":"m.text"},"ts":1675032820930,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dNciJX9j90RXbV6C6Q4TTkDJhxvrVLbUfDoXRR6bcdQ"},
{"content":{"body":"Neither agent needs to communicate their registry to the other agents, thus no global registry.","msgtype":"m.text"},"ts":1675032855275,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XwoSiuHiEZ0yBylbKxfD9fMaZWz5rS483b6bAF00Ubs"},
{"content":{"body":"If Agent A sends a struct value to Agent B that B doesn't have registered, Agent B could still allow access to the data, just not a prototype walk.","msgtype":"m.text"},"ts":1675032914916,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Y-8T3IFvIbZ6pQuoAiTnKnkhf4XLLHY_WbhggzNGpus"},
{"content":{"body":"> <@mhofman:matrix.org> By continuity I mean recognition of the prototype objects identity. It doesn't need to be the same in multiple agents, obviously, but an object of the type registered in agent1 and sent to agent2 is expected to have the same prototype as an object of the \"same type\" created in agent2. I am not convinced we need that\n\nThe prototype shape on each side doesn't matter. Just the type identity. I could have a `Foo { x, y, bar() {} }` on A and a `Baz { x, y, quxx() {} }` on B registered to the same type identity. If I create a `Foo` on A and send it to B, B will see it as a `Bar`. If I construct a `Bar` on B and send it to A, A will see it as a `Foo`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$-t5fb5VdX70RMFG4f90WgyHFE56lVWfkORZwuP-SQfE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>By continuity I mean recognition of the prototype objects identity. It doesn't need to be the same in multiple agents, obviously, but an object of the type registered in agent1 and sent to agent2 is expected to have the same prototype as an object of the \"same type\" created in agent2. I am not convinced we need that</blockquote></mx-reply>The prototype shape on each side doesn't matter. Just the type identity. I could have a <code>Foo { x, y, bar() {} }</code> on A and a <code>Baz { x, y, quxx() {} }</code> on B registered to the same type identity. If I create a <code>Foo</code> on A and send it to B, B will see it as a <code>Bar</code>. If I construct a <code>Bar</code> on B and send it to A, A will see it as a <code>Foo</code>.","m.relates_to":{"m.in_reply_to":{"event_id":"$-t5fb5VdX70RMFG4f90WgyHFE56lVWfkORZwuP-SQfE"}},"msgtype":"m.text"},"ts":1675033078117,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tLjMR6QhBG5W1pkH0FRUV7rtrmJej7R_QJraAsexvM4"},
{"content":{"body":"What I care about is consistency in round-tripping.","msgtype":"m.text"},"ts":1675033092291,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$b7gC_cEMatKv_lNpN7N66uk-2o6KuyNarnCBgKQhA_c"},
{"content":{"body":"My concern is with regards to who mints the type identity, as that grants the right to register it. A forgeable value allows code that doesn't trust each other to interfere with each other. That code could be running in the same realm. If the type is minted by the engine, how is it recovered by the code.","msgtype":"m.text"},"ts":1675033100897,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$xME3nuzbWAqc0DL2p3k-7j-YJsm5TRavA5dPQpJSirQ"},
{"content":{"body":"And the `Foo` vs `Bar` idea isn't farfetched, bundlers can and do tree shake methods, and can and do rename classes.","format":"org.matrix.custom.html","formatted_body":"And the <code>Foo</code> vs <code>Bar</code> idea isn't farfetched, bundlers can and do tree shake methods, and can and do rename classes.","msgtype":"m.text"},"ts":1675033119122,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WVgVkb040V5oEVNjqosDcLaLKZP6mnxBMLraxst9b8E"}
]