[
{"content":{"body":"I do wonder if it would make sense to have structs have a unique `typeof`. Since implementations have been somewhat opposed to new primitives (i.e., decimal) as they require considerable changes to the implementation, introducing a single new \"user-defined primitive\" type a la `struct` might be the answer. If we were to ever introduce operator overloading, we could hang it off of a user-defined \"primitive\" like a `struct` has some similarities to other primitives (i.e., per-realm/per-compartment prototype lookup). We could define `new Decimal()` to return an object, but later define `Decimal()` as returning a `struct`/`shared struct` instance so that it could work with shared memory (treating the object form as a boxed primitive). If we ever did introduce operator overloading to structs we could extend the `struct` version `Decimal` to support operators.","format":"org.matrix.custom.html","formatted_body":"I do wonder if it would make sense to have structs have a unique <code>typeof</code>. Since implementations have been somewhat opposed to new primitives (i.e., decimal) as they require considerable changes to the implementation, introducing a single new \"user-defined primitive\" type a la <code>struct</code> might be the answer. If we were to ever introduce operator overloading, we could hang it off of a user-defined \"primitive\" like a <code>struct</code> has some similarities to other primitives (i.e., per-realm/per-compartment prototype lookup). We could define <code>new Decimal()</code> to return an object, but later define <code>Decimal()</code> as returning a <code>struct</code>/<code>shared struct</code> instance so that it could work with shared memory (treating the object form as a boxed primitive). If we ever did introduce operator overloading to structs we could extend the <code>struct</code> version <code>Decimal</code> to support operators.","m.mentions":{},"msgtype":"m.text"},"ts":1738079960403,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$K9PvZ6uERNn5-LXE_Cmo_VRcbzDFtU7rG1RCPFxfmUk"},
{"content":{"body":"I will reiterate, it is probably important for compatibility that primitive (i.e., `typeof x !== \"object\" || x !== null`) ⇒ immutable. IOW, new `typeof` values are not acceptable for mutable values.","format":"org.matrix.custom.html","formatted_body":"I will reiterate, it is probably important for compatibility that primitive (i.e., <code>typeof x !== \"object\" || x !== null</code>) ⇒ immutable. IOW, new <code>typeof</code> values are not acceptable for mutable values.","m.mentions":{},"msgtype":"m.text"},"ts":1738080372642,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$bgRodLkxNp1E0iYdkNDkFTp80QzJli7Txxm4-uTIGS8"},
{"content":{"body":"it is a certainty, not a probability, that primitives must be immutable, but theres multiple ways to test for being primitive:\n1. has one of the primitive `typeof`s (this logic broke in ES2015 with symbols, and in ES2020 with bigints, so we can probably assume this isn't relied upon as much)\n2. doesn't have one of the object `typeof`s - ie, is truthy, and is typeof object or function. however lots of people forget `function` (like above), but indeed a new object typeof value would break anyone relying on this check.\n3. `Object(x) === x` means it's an object. this check should remain robust forever, but it's thought to be slower, so people tend to prefer the typeof lists.","format":"org.matrix.custom.html","formatted_body":"<p>it is a certainty, not a probability, that primitives must be immutable, but theres multiple ways to test for being primitive:</p>\n<ol>\n<li>has one of the primitive <code>typeof</code>s (this logic broke in ES2015 with symbols, and in ES2020 with bigints, so we can probably assume this isn't relied upon as much)</li>\n<li>doesn't have one of the object <code>typeof</code>s - ie, is truthy, and is typeof object or function. however lots of people forget <code>function</code> (like above), but indeed a new object typeof value would break anyone relying on this check.</li>\n<li><code>Object(x) === x</code> means it's an object. this check should remain robust forever, but it's thought to be slower, so people tend to prefer the typeof lists.</li>\n</ol>\n","m.mentions":{},"msgtype":"m.text"},"ts":1738083258344,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$lcEam-sRlX1RaW7fzzUhU8YNxOPhKXH1LXvT0745LW8"},
{"content":{"body":"I would extend 2 to say we probably should not let a falsy value ever be mutable, in case anyone starts their check with `!x` (with the aim of excluding `null`)","msgtype":"m.text"},"ts":1738083704161,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$rHkFlM__LmdAia2iKXqppVPctF39_KVCO7_0_rDH6jw"},
{"content":{"body":"All that to say I agree that anything mutable should have typeof object, or we'd break a ton of code.","msgtype":"m.text"},"ts":1738083803138,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$zi3mhEk-ET2W8QGD2-FEM30BrX7sp8-Rz14cUyA7vso"}
]