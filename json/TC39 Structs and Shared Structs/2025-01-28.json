[
{"content":{"body":"I do wonder if it would make sense to have structs have a unique `typeof`. Since implementations have been somewhat opposed to new primitives (i.e., decimal) as they require considerable changes to the implementation, introducing a single new \"user-defined primitive\" type a la `struct` might be the answer. If we were to ever introduce operator overloading, we could hang it off of a user-defined \"primitive\" like a `struct` has some similarities to other primitives (i.e., per-realm/per-compartment prototype lookup). We could define `new Decimal()` to return an object, but later define `Decimal()` as returning a `struct`/`shared struct` instance so that it could work with shared memory (treating the object form as a boxed primitive). If we ever did introduce operator overloading to structs we could extend the `struct` version `Decimal` to support operators.","format":"org.matrix.custom.html","formatted_body":"I do wonder if it would make sense to have structs have a unique <code>typeof</code>. Since implementations have been somewhat opposed to new primitives (i.e., decimal) as they require considerable changes to the implementation, introducing a single new \"user-defined primitive\" type a la <code>struct</code> might be the answer. If we were to ever introduce operator overloading, we could hang it off of a user-defined \"primitive\" like a <code>struct</code> has some similarities to other primitives (i.e., per-realm/per-compartment prototype lookup). We could define <code>new Decimal()</code> to return an object, but later define <code>Decimal()</code> as returning a <code>struct</code>/<code>shared struct</code> instance so that it could work with shared memory (treating the object form as a boxed primitive). If we ever did introduce operator overloading to structs we could extend the <code>struct</code> version <code>Decimal</code> to support operators.","m.mentions":{},"msgtype":"m.text"},"ts":1738079960403,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$K9PvZ6uERNn5-LXE_Cmo_VRcbzDFtU7rG1RCPFxfmUk"},
{"content":{"body":"I will reiterate, it is probably important for compatibility that primitive (i.e., `typeof x !== \"object\" || x !== null`) ⇒ immutable. IOW, new `typeof` values are not acceptable for mutable values.","format":"org.matrix.custom.html","formatted_body":"I will reiterate, it is probably important for compatibility that primitive (i.e., <code>typeof x !== \"object\" || x !== null</code>) ⇒ immutable. IOW, new <code>typeof</code> values are not acceptable for mutable values.","m.mentions":{},"msgtype":"m.text"},"ts":1738080372642,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$bgRodLkxNp1E0iYdkNDkFTp80QzJli7Txxm4-uTIGS8"},
{"content":{"body":"it is a certainty, not a probability, that primitives must be immutable, but theres multiple ways to test for being primitive:\n1. has one of the primitive `typeof`s (this logic broke in ES2015 with symbols, and in ES2020 with bigints, so we can probably assume this isn't relied upon as much)\n2. doesn't have one of the object `typeof`s - ie, is truthy, and is typeof object or function. however lots of people forget `function` (like above), but indeed a new object typeof value would break anyone relying on this check.\n3. `Object(x) === x` means it's an object. this check should remain robust forever, but it's thought to be slower, so people tend to prefer the typeof lists.","format":"org.matrix.custom.html","formatted_body":"<p>it is a certainty, not a probability, that primitives must be immutable, but theres multiple ways to test for being primitive:</p>\n<ol>\n<li>has one of the primitive <code>typeof</code>s (this logic broke in ES2015 with symbols, and in ES2020 with bigints, so we can probably assume this isn't relied upon as much)</li>\n<li>doesn't have one of the object <code>typeof</code>s - ie, is truthy, and is typeof object or function. however lots of people forget <code>function</code> (like above), but indeed a new object typeof value would break anyone relying on this check.</li>\n<li><code>Object(x) === x</code> means it's an object. this check should remain robust forever, but it's thought to be slower, so people tend to prefer the typeof lists.</li>\n</ol>\n","m.mentions":{},"msgtype":"m.text"},"ts":1738083258344,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$lcEam-sRlX1RaW7fzzUhU8YNxOPhKXH1LXvT0745LW8"},
{"content":{"body":"I would extend 2 to say we probably should not let a falsy value ever be mutable, in case anyone starts their check with `!x` (with the aim of excluding `null`)","msgtype":"m.text"},"ts":1738083704161,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$rHkFlM__LmdAia2iKXqppVPctF39_KVCO7_0_rDH6jw"},
{"content":{"body":"All that to say I agree that anything mutable should have typeof object, or we'd break a ton of code.","msgtype":"m.text"},"ts":1738083803138,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$zi3mhEk-ET2W8QGD2-FEM30BrX7sp8-Rz14cUyA7vso"},
{"content":{"body":"ack on typeof result \"object\" and \"function\" belonging in the same category; that was written in haste","m.mentions":{},"msgtype":"m.text"},"ts":1738084287602,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$HBhqpFr8WR9JyMIW75INMssrfXZ8Qs8xee6QuIz4kWc"},
{"content":{"body":"* hmm, it is probably important for compatibility that primitive (i.e., `typeof x !== \"object\" || x === null`) ⇒ immutable, and even more important that strict (in)equality is time-invariant","format":"org.matrix.custom.html","formatted_body":"* hmm, it is probably important for compatibility that primitive (i.e., <code>typeof x !== \"object\" || x === null</code>) ⇒ immutable, and even more important that strict (in)equality is time-invariant","m.mentions":{},"m.new_content":{"body":"hmm, it is probably important for compatibility that primitive (i.e., `typeof x !== \"object\" || x === null`) ⇒ immutable, and even more important that strict (in)equality is time-invariant","format":"org.matrix.custom.html","formatted_body":"hmm, it is probably important for compatibility that primitive (i.e., <code>typeof x !== \"object\" || x === null</code>) ⇒ immutable, and even more important that strict (in)equality is time-invariant","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$T0TE9pr2cl7IOrhf4KqKm13PVa-dcLqv6ei5I3EDvDc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1738084340180,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$noN2M2K5R88I5OlPn0l6fOdg4zHtNP1V6pSjDTc6kjc"},
{"content":{"body":"* I will reiterate, it is probably important for compatibility that primitive (i.e., `x === null || typeof x !== \"object\" && typeof x !== \"function\"`) ⇒ immutable. IOW, new `typeof` values are not acceptable for mutable values.","format":"org.matrix.custom.html","formatted_body":"* I will reiterate, it is probably important for compatibility that primitive (i.e., <code>x === null || typeof x !== \"object\" &amp;&amp; typeof x !== \"function\"</code>) ⇒ immutable. IOW, new <code>typeof</code> values are not acceptable for mutable values.","m.mentions":{},"m.new_content":{"body":"I will reiterate, it is probably important for compatibility that primitive (i.e., `x === null || typeof x !== \"object\" && typeof x !== \"function\"`) ⇒ immutable. IOW, new `typeof` values are not acceptable for mutable values.","format":"org.matrix.custom.html","formatted_body":"I will reiterate, it is probably important for compatibility that primitive (i.e., <code>x === null || typeof x !== \"object\" &amp;&amp; typeof x !== \"function\"</code>) ⇒ immutable. IOW, new <code>typeof</code> values are not acceptable for mutable values.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$bgRodLkxNp1E0iYdkNDkFTp80QzJli7Txxm4-uTIGS8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1738084453361,"senderName":"Richard Gibson","senderId":"@gibson042:matrix.org","id":"$FuFo6hamwv5mMkcSba1ODKCJhqGO9mItVntqM-KGUlY"},
{"content":{"body":"of course, if we could add a new predicate like `isPrimitive` or `isObject`, then i think we'd be able to push people to use it and be free to add more `typeof` values (under the same mutability/falsiness constraints ofc)","format":"org.matrix.custom.html","formatted_body":"of course, if we could add a new predicate like <code>isPrimitive</code> or <code>isObject</code>, then i think we'd be able to push people to use it and be free to add more <code>typeof</code> values (under the same mutability/falsiness constraints ofc)","m.mentions":{},"msgtype":"m.text"},"ts":1738085881380,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$juxca9VT6xx26xa3xju-kuHrc-P_j11FkMSZhKvSw08"},
{"content":{"body":"I'm not sure I 100% agree with this in principle. If there is ever a future that includes operator overloading, being able to implicitly coerce decimal `0.0` to a falsy value to match the rest of the language would be invaluable. ","format":"org.matrix.custom.html","formatted_body":"I'm not sure I 100% agree with this in principle. If there is ever a future that includes operator overloading, being able to implicitly coerce decimal <code>0.0</code> to a falsy value to match the rest of the language would be invaluable.","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$rHkFlM__LmdAia2iKXqppVPctF39_KVCO7_0_rDH6jw"}},"msgtype":"m.text"},"ts":1738086253109,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fv4rn-rLxIgkP6brI9bPxfPUr5KjaaKLaKbGjqitJT8"},
{"content":{"body":"that is a very big \"if\"","m.mentions":{},"msgtype":"m.text"},"ts":1738086686286,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$D8dIV02WNYgMxW4RikuBrMmgw_-_zVWnVn95iBPCkV8"}
]