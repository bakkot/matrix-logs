[
{"content":{"body":"FYI, I have someone coming by today to repair some siding that came loose during a thunderstorm and it looks like they were delayed and will be here around 1pm EST (the start of the meeting today), so I may be delayed by a few minutes or interrupted.","m.mentions":{},"msgtype":"m.text"},"ts":1719937451008,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bTBSP7xJl2p7_u2kZqrgLdwLAkXUqHNsAbp3Fg5kI7c"},
{"content":{"body":"ianhedoesit: Regarding your comment that the intuition is that \"`async` affects the type\", I disagree. Both `async` (and `*`) imply a _syntactic transformation in the function body_. Non `async` code can still return a `Promise`, and non `*` code can still return a generator.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@ianhedoesit:matrix.org\">ianhedoesit</a>: Regarding your comment that the intuition is that \"<code>async</code> affects the type\", I disagree. Both <code>async</code> (and <code>*</code>) imply a <em>syntactic transformation in the function body</em>. Non <code>async</code> code can still return a <code>Promise</code>, and non <code>*</code> code can still return a generator.","m.mentions":{"user_ids":["@ianhedoesit:matrix.org"]},"msgtype":"m.text"},"ts":1719942935763,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kf48WPMYsQhmuF74jxjBTHiL5r2ENsdrBpc5xQSlNMA"},
{"content":{"body":"(I think you tagged the wrong Iain)","m.mentions":{},"msgtype":"m.text"},"ts":1719943095251,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$7bh9HNVWWPyriZYWYkb_6-wt21vo-wTPoP7Twq87fqM"},
{"content":{"body":"I don't think that tracks. If I add \"async\" or `*` to a function definition, it returns a different sort of thing, in a way that my caller needs to know about. If I add `unsafe`, it doesn't change anything from the caller's perspective.","format":"org.matrix.custom.html","formatted_body":"I don't think that tracks. If I add \"async\" or <code>*</code> to a function definition, it returns a different sort of thing, in a way that my caller needs to know about. If I add <code>unsafe</code>, it doesn't change anything from the caller's perspective.","m.mentions":{},"msgtype":"m.text"},"ts":1719943184239,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$fjRKkt1aL-7mgYJTBTAyK0YbbsxhDhmBeMj5gEyY6GM"},
{"content":{"body":" * I don't think that tracks. If I add `async` or `*` to a function definition, it returns a different sort of thing, in a way that my caller needs to know about. If I add `unsafe`, it doesn't change anything from the caller's perspective.","format":"org.matrix.custom.html","formatted_body":" * I don't think that tracks. If I add <code>async</code> or <code>*</code> to a function definition, it returns a different sort of thing, in a way that my caller needs to know about. If I add <code>unsafe</code>, it doesn't change anything from the caller's perspective.","m.mentions":{},"m.new_content":{"body":"I don't think that tracks. If I add `async` or `*` to a function definition, it returns a different sort of thing, in a way that my caller needs to know about. If I add `unsafe`, it doesn't change anything from the caller's perspective.","format":"org.matrix.custom.html","formatted_body":"I don't think that tracks. If I add <code>async</code> or <code>*</code> to a function definition, it returns a different sort of thing, in a way that my caller needs to know about. If I add <code>unsafe</code>, it doesn't change anything from the caller's perspective.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$fjRKkt1aL-7mgYJTBTAyK0YbbsxhDhmBeMj5gEyY6GM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719943193456,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$kn6ClMhCeRJOpAvLNADxMSqXpmZ2lpc99MRctrzAgzs"},
{"content":{"body":"Functions don't have typed signatures in raw JS, but if you return a promise or a generator from a function then that is reflected in the implicit return type. The same is not true for `unsafe`.","format":"org.matrix.custom.html","formatted_body":"Functions don't have typed signatures in raw JS, but if you return a promise or a generator from a function then that is reflected in the implicit return type. The same is not true for <code>unsafe</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1719943363333,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$2C0Lzm7BxjVvTmKGI_lCK_YrDaFETYe2YpJQjYTFQUM"},
{"content":{"body":"I did, oops.","m.mentions":{},"msgtype":"m.text"},"ts":1719943400692,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7ruFclST1LinxnHt9NwVFaw62XuZba0dkNYKUpBpEK8"},
{"content":{"body":"The distinction is whether the property is important to the caller, and since we're explicitly avoiding function colouring, I claim that `unsafe` is only relevant to the code inside the function.","format":"org.matrix.custom.html","formatted_body":"The distinction is whether the property is important to the caller, and since we're explicitly avoiding function colouring, I claim that <code>unsafe</code> is only relevant to the code inside the function.","m.mentions":{},"msgtype":"m.text"},"ts":1719943418658,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$OP6emjYdo4HlzCBI2uvGsMJAjmmi3ZaAAbfTCkPS_iQ"},
{"content":{"body":" * iain: Regarding your comment that the intuition is that \"`async` affects the type\", I disagree. Both `async` (and `*`) imply a _syntactic transformation in the function body_. Non `async` code can still return a `Promise`, and non `*` code can still return a generator.","format":"org.matrix.custom.html","formatted_body":" * <a href=\"https://matrix.to/#/@iain:mozilla.org\">iain</a>: Regarding your comment that the intuition is that \"<code>async</code> affects the type\", I disagree. Both <code>async</code> (and <code>*</code>) imply a <em>syntactic transformation in the function body</em>. Non <code>async</code> code can still return a <code>Promise</code>, and non <code>*</code> code can still return a generator.","m.mentions":{"user_ids":["@iain:mozilla.org"]},"m.new_content":{"body":"iain: Regarding your comment that the intuition is that \"`async` affects the type\", I disagree. Both `async` (and `*`) imply a _syntactic transformation in the function body_. Non `async` code can still return a `Promise`, and non `*` code can still return a generator.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@iain:mozilla.org\">iain</a>: Regarding your comment that the intuition is that \"<code>async</code> affects the type\", I disagree. Both <code>async</code> (and <code>*</code>) imply a <em>syntactic transformation in the function body</em>. Non <code>async</code> code can still return a <code>Promise</code>, and non <code>*</code> code can still return a generator.","m.mentions":{"user_ids":["@iain:mozilla.org"]},"msgtype":"m.text"},"m.relates_to":{"event_id":"$kf48WPMYsQhmuF74jxjBTHiL5r2ENsdrBpc5xQSlNMA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719943422528,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mx9BW7n9DaK_LIPkpMr2IGTK5muaO23OlBItIawOLUo"},
{"content":{"body":"My anecdotal evidence that this is potentially confusing is that I was personally confused by this while reading the explainer.","m.mentions":{},"msgtype":"m.text"},"ts":1719943518661,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$5AWhBcQMxXX1dvQZfRVpE55vdszTHiaRPYMtpzvyWys"},
{"content":{"body":"We tried to make this distinction in TypeScript fairly clear. While you can write `async function f(): Promise<void> { ... }` in your code, the output declaration is `declare function f(): Promise<void> { ... }`, as `async` only performs a syntactic transformation. It does certainly _inform_ the return type, but it is not part of the function signature from a type checking perspective.","format":"org.matrix.custom.html","formatted_body":"We tried to make this distinction in TypeScript fairly clear. While you can write <code>async function f(): Promise&lt;void&gt; { ... }</code> in your code, the output declaration is <code>declare function f(): Promise&lt;void&gt; { ... }</code>, as <code>async</code> only performs a syntactic transformation. It does certainly <em>inform</em> the return type, but it is not part of the function signature from a type checking perspective.","m.mentions":{},"msgtype":"m.text"},"ts":1719943547215,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FDDb9jzaiiI6zXqV0lPq3t5yvxmaplrVtzF8QuShWEk"},
{"content":{"body":"(Although it is certainly plausible that I am too easily confused!)","m.mentions":{},"msgtype":"m.text"},"ts":1719943549531,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$EFfTAaWlEfwaMlVz1Bkj4T84YlWiwYtLZ3d1oERNFvI"},
{"content":{"body":"Decorators will further complicate that mental model, though, as a decorator could affect the return type of a function as well. At one point (after we had already shipped `async`/`await`), there were comments that we could have just used generators and `@async function* f() { ... }`.","format":"org.matrix.custom.html","formatted_body":"Decorators will further complicate that mental model, though, as a decorator could affect the return type of a function as well. At one point (after we had already shipped <code>async</code>/<code>await</code>), there were comments that we could have just used generators and <code>@async function* f() { ... }</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1719943649684,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2GGX4RXIbUoDM0nPUPqzM_kLm96EpZUiddbx-hKmIKE"},
{"content":{"body":"Yes, `async` and `*` do imply a specific return type, but that is purely a result of the syntactic transformation. In the same way, `accessor` is also a syntactic transformation.","format":"org.matrix.custom.html","formatted_body":"Yes, <code>async</code> and <code>*</code> do imply a specific return type, but that is purely a result of the syntactic transformation. In the same way, <code>accessor</code> is also a syntactic transformation.","m.mentions":{},"msgtype":"m.text"},"ts":1719943717985,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$K1GjoiZ9t6k9MaEMjDWyZUpWdMVGKrdEl74ztbJL4js"},
{"content":{"body":"It could even be argued that `static` is a syntactic transformation insomuch as it applies to where a method or field is placed on a class. All of these potentially affect the type, but the type produced is purely a result of the transformation itself.","format":"org.matrix.custom.html","formatted_body":"It could even be argued that <code>static</code> is a syntactic transformation insomuch as it applies to where a method or field is placed on a class. All of these potentially affect the type, but the type produced is purely a result of the transformation itself.","m.mentions":{},"msgtype":"m.text"},"ts":1719943781049,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Dq_0xtGxJbw4u-nDjpuG4SFo5oWFxg6kq53m3__TgUk"},
{"content":{"body":"I'd also like to point out that `unsafe`, as I've proposed, is generally consistent with Rust as prior art. Rust allows `unsafe {}`, but also `unsafe fn`, `unsafe trait`, and `unsafe impl`:\n\n> By default, `unsafe fn` also acts like an `unsafe {}` block around the code inside the function. This means it is not just a signal to the caller, but also promises that the preconditions for the operations inside the function are upheld. Mixing these two meanings can be confusing, so the `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe blocks even inside `unsafe fn`.\n\nIn rust, disallowing `unsafe fn` in favor of a nested unsafe block is specified as a lint rule.","format":"org.matrix.custom.html","formatted_body":"<p>I'd also like to point out that <code>unsafe</code>, as I've proposed, is generally consistent with Rust as prior art. Rust allows <code>unsafe {}</code>, but also <code>unsafe fn</code>, <code>unsafe trait</code>, and <code>unsafe impl</code>:</p>\n<blockquote>\n<p>By default, <code>unsafe fn</code> also acts like an <code>unsafe {}</code> block around the code inside the function. This means it is not just a signal to the caller, but also promises that the preconditions for the operations inside the function are upheld. Mixing these two meanings can be confusing, so the <code>unsafe_op_in_unsafe_fn</code> lint can be enabled to warn against that and require explicit unsafe blocks even inside <code>unsafe fn</code>.</p>\n</blockquote>\n<p>In rust, disallowing <code>unsafe fn</code> in favor of a nested unsafe block is specified as a lint rule.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719944010682,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4u4xUKnPWdfkkvOe781_YYKuJ8W1AOLNVbyTPBi88DY"},
{"content":{"body":" * I'd also like to point out that `unsafe`, as I've proposed, is generally consistent with Rust as prior art. Rust allows `unsafe {}`, but also `unsafe fn`, `unsafe trait`, and `unsafe impl`:\n\n> By default, `unsafe fn` also acts like an `unsafe {}` block around the code inside the function. This means it is not just a signal to the caller, but also promises that the preconditions for the operations inside the function are upheld. Mixing these two meanings can be confusing, so the `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe blocks even inside `unsafe fn`.\n\nIn Rust, disallowing `unsafe fn` in favor of a nested unsafe block is specified as a lint rule.","format":"org.matrix.custom.html","formatted_body":" * <p>I'd also like to point out that <code>unsafe</code>, as I've proposed, is generally consistent with Rust as prior art. Rust allows <code>unsafe {}</code>, but also <code>unsafe fn</code>, <code>unsafe trait</code>, and <code>unsafe impl</code>:</p>\n<blockquote>\n<p>By default, <code>unsafe fn</code> also acts like an <code>unsafe {}</code> block around the code inside the function. This means it is not just a signal to the caller, but also promises that the preconditions for the operations inside the function are upheld. Mixing these two meanings can be confusing, so the <code>unsafe_op_in_unsafe_fn</code> lint can be enabled to warn against that and require explicit unsafe blocks even inside <code>unsafe fn</code>.</p>\n</blockquote>\n<p>In Rust, disallowing <code>unsafe fn</code> in favor of a nested unsafe block is specified as a lint rule.</p>\n","m.mentions":{},"m.new_content":{"body":"I'd also like to point out that `unsafe`, as I've proposed, is generally consistent with Rust as prior art. Rust allows `unsafe {}`, but also `unsafe fn`, `unsafe trait`, and `unsafe impl`:\n\n> By default, `unsafe fn` also acts like an `unsafe {}` block around the code inside the function. This means it is not just a signal to the caller, but also promises that the preconditions for the operations inside the function are upheld. Mixing these two meanings can be confusing, so the `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe blocks even inside `unsafe fn`.\n\nIn Rust, disallowing `unsafe fn` in favor of a nested unsafe block is specified as a lint rule.","format":"org.matrix.custom.html","formatted_body":"<p>I'd also like to point out that <code>unsafe</code>, as I've proposed, is generally consistent with Rust as prior art. Rust allows <code>unsafe {}</code>, but also <code>unsafe fn</code>, <code>unsafe trait</code>, and <code>unsafe impl</code>:</p>\n<blockquote>\n<p>By default, <code>unsafe fn</code> also acts like an <code>unsafe {}</code> block around the code inside the function. This means it is not just a signal to the caller, but also promises that the preconditions for the operations inside the function are upheld. Mixing these two meanings can be confusing, so the <code>unsafe_op_in_unsafe_fn</code> lint can be enabled to warn against that and require explicit unsafe blocks even inside <code>unsafe fn</code>.</p>\n</blockquote>\n<p>In Rust, disallowing <code>unsafe fn</code> in favor of a nested unsafe block is specified as a lint rule.</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$4u4xUKnPWdfkkvOe781_YYKuJ8W1AOLNVbyTPBi88DY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719944013889,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HuPC2jnGt-uMwjP1H06ZL3E92bwY9bBgpDJGGATiZxM"},
{"content":{"body":"https://doc.rust-lang.org/std/keyword.unsafe.html","m.mentions":{},"msgtype":"m.text"},"ts":1719944045118,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$z8Nx07lp7CshRrhtV17OG6s8NfKk6sLQQg2OqWE5nks"},
{"content":{"body":"Or am I misinterpreting? Does Rust require an `unsafe` block around an unsafe function call?","format":"org.matrix.custom.html","formatted_body":"Or am I misinterpreting? Does Rust require an <code>unsafe</code> block around an unsafe function call?","m.mentions":{},"msgtype":"m.text"},"ts":1719944105111,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zZTvIlkipQtQFF0cLEL9cEuPN3hmz-yv5mGUW0zOUlg"},
{"content":{"body":"In general, I would say that a function signature (broadly waving at all the parts of a function declaration outside the body) provides information that is important to the caller. This is especially true in statically typed languages, but even in JS I think it holds. By putting `unsafe` in such a prominent location, we imply that it is similarly important to the caller, which is not the case here.","format":"org.matrix.custom.html","formatted_body":"In general, I would say that a function signature (broadly waving at all the parts of a function declaration outside the body) provides information that is important to the caller. This is especially true in statically typed languages, but even in JS I think it holds. By putting <code>unsafe</code> in such a prominent location, we imply that it is similarly important to the caller, which is not the case here.","m.mentions":{},"msgtype":"m.text"},"ts":1719944115179,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$T5mUSIX6WS9KnfvQy0RvYvU5XK_JCu6jdENs95IypMg"},
{"content":{"body":"You are misinterpreting: Rust requires an unsafe block around calls to unsafe functions.","m.mentions":{},"msgtype":"m.text"},"ts":1719944130026,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$gZOvSRm3o0HcBAF0jwLjLfCmUynFhjxrUPYfWFzdyQY"},
{"content":{"body":"Ah, thanks. My mistake.","m.mentions":{},"msgtype":"m.text"},"ts":1719944144846,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YZs18GT9zYdejqRXOfZcdlQgDi2_fvvexmnCS3L9cLo"},
{"content":{"body":"That's a big part of why I misread your explainer.","m.mentions":{},"msgtype":"m.text"},"ts":1719944153905,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$TCB-S2uR7o4CWlnL9HrNLRqABWTZKx_ZcJMiMOBJozc"},
{"content":{"body":"The purpose of the Rust lint is to encourage code to be precise about which parts of a function body are unsafe, even if the entire function must be called in an unsafe context.","m.mentions":{},"msgtype":"m.text"},"ts":1719944265897,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$zcdMD7-Itsnurzk4SHKFH0vRsmWvkSTOkpFQJza5kk0"},
{"content":{"body":"An alternative to `unsafe function f() {}` that I'd also put on the explainer might be `function f() unsafe { }`. My concern is that this isn't obvious that it also affects the parameter list. Then again `function f() { \"use strict\"; }` affects the parameter list as well.","format":"org.matrix.custom.html","formatted_body":"An alternative to <code>unsafe function f() {}</code> that I'd also put on the explainer might be <code>function f() unsafe { }</code>. My concern is that this isn't obvious that it also affects the parameter list. Then again <code>function f() { \"use strict\"; }</code> affects the parameter list as well.","m.mentions":{},"msgtype":"m.text"},"ts":1719944267164,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$V3DzgIPaOW5ya52cV9woO84YvH7Mdckp7eFqAABmRBY"},
{"content":{"body":"The equivalent in JS of the Rust lint would be to have function colouring (where `unsafe function foo()` can only be called from inside an unsafe block) and also require explicit unsafe blocks inside the body of the function, which is the opposite of what you are proposing.","format":"org.matrix.custom.html","formatted_body":"The equivalent in JS of the Rust lint would be to have function colouring (where <code>unsafe function foo()</code> can only be called from inside an unsafe block) and also require explicit unsafe blocks inside the body of the function, which is the opposite of what you are proposing.","m.mentions":{},"msgtype":"m.text"},"ts":1719944357665,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$I6cl_C1VzT_vswWlfMzl2aKZ0bTUZ7bdc-ML0O4dpDE"},
{"content":{"body":"So, `class C unsafe { }` to make a class body unsafe, or `shared struct S unsafe { }` to make a shared struct body unsafe. We probably wouldn't do `unsafe const`/`unsafe let` in that case because it would be mixing up suffix vs. prefix, so we *would* need to depend on an unsafe IIFE or `unsafe do`","format":"org.matrix.custom.html","formatted_body":"So, <code>class C unsafe { }</code> to make a class body unsafe, or <code>shared struct S unsafe { }</code> to make a shared struct body unsafe. We probably wouldn't do <code>unsafe const</code>/<code>unsafe let</code> in that case because it would be mixing up suffix vs. prefix, so we <em>would</em> need to depend on an unsafe IIFE or <code>unsafe do</code>","m.mentions":{},"msgtype":"m.text"},"ts":1719944363675,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$v319TQ1yfBfA3BgWHOn0iAFYLRFU5kKxfsvrLtJ8qgk"},
{"content":{"body":"function coloring is a major DX pain. I see it as a necessity for `async` and `*` given that the syntactic transformations affect the return type, but it's not a practice I'm fond of continuing with new syntax if it isn't warranted.","format":"org.matrix.custom.html","formatted_body":"function coloring is a major DX pain. I see it as a necessity for <code>async</code> and <code>*</code> given that the syntactic transformations affect the return type, but it's not a practice I'm fond of continuing with new syntax if it isn't warranted.","m.mentions":{},"msgtype":"m.text"},"ts":1719944497165,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7vIFSOihvW3FA7fS6_YwKdDYOdVDIhygj6yhuTR7BiQ"},
{"content":{"body":"> <@rbuckton:matrix.org> So, `class C unsafe { }` to make a class body unsafe, or `shared struct S unsafe { }` to make a shared struct body unsafe. We probably wouldn't do `unsafe const`/`unsafe let` in that case because it would be mixing up suffix vs. prefix, so we *would* need to depend on an unsafe IIFE or `unsafe do`\n\nI suppose it would be `do unsafe {}`, to maintain the suffix position","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$v319TQ1yfBfA3BgWHOn0iAFYLRFU5kKxfsvrLtJ8qgk?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>So, <code>class C unsafe { }</code> to make a class body unsafe, or <code>shared struct S unsafe { }</code> to make a shared struct body unsafe. We probably wouldn't do <code>unsafe const</code>/<code>unsafe let</code> in that case because it would be mixing up suffix vs. prefix, so we <em>would</em> need to depend on an unsafe IIFE or <code>unsafe do</code></blockquote></mx-reply>I suppose it would be <code>do unsafe {}</code>, to maintain the suffix position","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$v319TQ1yfBfA3BgWHOn0iAFYLRFU5kKxfsvrLtJ8qgk"}},"msgtype":"m.text"},"ts":1719944542514,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hAaDkSnv5A9pp6p3eLQti17APFWa_B1TujeLGsBrA_Y"},
{"content":{"body":"Function colouring in this case allows for the more nuanced expression of safety invariants. So for example you could have `function foo() { unsafe {...} }` and `unsafe function foo_AlreadyHoldingLock() {...}`, in which case `unsafe function` does not do a syntactic transformation, but it does impose restrictions on the callers to maintain invariants.","format":"org.matrix.custom.html","formatted_body":"Function colouring in this case allows for the more nuanced expression of safety invariants. So for example you could have <code>function foo() { unsafe {...} }</code> and <code>unsafe function foo_AlreadyHoldingLock() {...}</code>, in which case <code>unsafe function</code> does not do a syntactic transformation, but it does impose restrictions on the callers to maintain invariants.","m.mentions":{},"msgtype":"m.text"},"ts":1719944784021,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$Rkp_xCFG8Qq-j-qztrco_2aMY1F0VuIUU_0woT3OnZQ"},
{"content":{"body":"I'm not convinced we want that, and I think adding it might impose a small performance overhead on unrelated code, but it's a point in design space.","m.mentions":{},"msgtype":"m.text"},"ts":1719944834303,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$wunR0_favry4Y4WjXLRNnAITiNox57b3Tyndyw3F5CM"},
{"content":{"body":"There is one thing about function coloring an `unsafe` function has over `async`/`await` that makes it somewhat more palatable, which is that you can introduce an `unsafe {}` block in safe code to perform the operation. That almost makes me want to have both `unsafe function` (\"it is unsafe to call me and my contents are unsafe\") and `function () unsafe { }` (\"it is safe to call me as I have done my due diligence to ensure I am safe at the boundaries\"), mostly because I really am not a fan of the namespace nesting style often seen in C++, i.e.\n```js\nfunction f() { unsafe { \n  ...\n} }\n```","format":"org.matrix.custom.html","formatted_body":"<p>There is one thing about function coloring an <code>unsafe</code> function has over <code>async</code>/<code>await</code> that makes it somewhat more palatable, which is that you can introduce an <code>unsafe {}</code> block in safe code to perform the operation. That almost makes me want to have both <code>unsafe function</code> (\"it is unsafe to call me and my contents are unsafe\") and <code>function () unsafe { }</code> (\"it is safe to call me as I have done my due diligence to ensure I am safe at the boundaries\"), mostly because I really am not a fan of the namespace nesting style often seen in C++, i.e.</p>\n<pre><code class=\"language-js\">function f() { unsafe { \n  ...\n} }\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719944848921,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2POGjwaKqj-0eC8AkSkhSYPBkEQMj1xhMHmvssSqqmA"},
{"content":{"body":" * There is one thing about function coloring an `unsafe` function has over `async`/`await` that makes it somewhat more palatable, which is that you can introduce an `unsafe {}` block in safe code to perform the operation. That almost makes me want to have both `unsafe function` (\"it is unsafe to call me and my contents are unsafe\") and `function () unsafe { }` (\"my contents are unsafe, but it is safe to call me as I have done my due diligence to ensure I am safe at the boundaries\"), mostly because I really am not a fan of the namespace nesting style often seen in C++, i.e.\n\n```js\nfunction f() { unsafe { \n  ...\n} }\n```","format":"org.matrix.custom.html","formatted_body":" * <p>There is one thing about function coloring an <code>unsafe</code> function has over <code>async</code>/<code>await</code> that makes it somewhat more palatable, which is that you can introduce an <code>unsafe {}</code> block in safe code to perform the operation. That almost makes me want to have both <code>unsafe function</code> (\"it is unsafe to call me and my contents are unsafe\") and <code>function () unsafe { }</code> (\"my contents are unsafe, but it is safe to call me as I have done my due diligence to ensure I am safe at the boundaries\"), mostly because I really am not a fan of the namespace nesting style often seen in C++, i.e.</p>\n<pre><code class=\"language-js\">function f() { unsafe { \n  ...\n} }\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"There is one thing about function coloring an `unsafe` function has over `async`/`await` that makes it somewhat more palatable, which is that you can introduce an `unsafe {}` block in safe code to perform the operation. That almost makes me want to have both `unsafe function` (\"it is unsafe to call me and my contents are unsafe\") and `function () unsafe { }` (\"my contents are unsafe, but it is safe to call me as I have done my due diligence to ensure I am safe at the boundaries\"), mostly because I really am not a fan of the namespace nesting style often seen in C++, i.e.\n\n```js\nfunction f() { unsafe { \n  ...\n} }\n```","format":"org.matrix.custom.html","formatted_body":"<p>There is one thing about function coloring an <code>unsafe</code> function has over <code>async</code>/<code>await</code> that makes it somewhat more palatable, which is that you can introduce an <code>unsafe {}</code> block in safe code to perform the operation. That almost makes me want to have both <code>unsafe function</code> (\"it is unsafe to call me and my contents are unsafe\") and <code>function () unsafe { }</code> (\"my contents are unsafe, but it is safe to call me as I have done my due diligence to ensure I am safe at the boundaries\"), mostly because I really am not a fan of the namespace nesting style often seen in C++, i.e.</p>\n<pre><code class=\"language-js\">function f() { unsafe { \n  ...\n} }\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$2POGjwaKqj-0eC8AkSkhSYPBkEQMj1xhMHmvssSqqmA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719944889359,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Cjp54mARVUqNDP1rsztU7usbPSZyqTixJ2G8wYEsR6Y"},
{"content":{"body":"Yeah, given my previous experience in Rust, that's what I thought you were proposing initially. The problem is that then every call that is not in an unsafe context is responsible for checking that the callee is not an unsafe function, which potentially slows down polymorphic code.","m.mentions":{},"msgtype":"m.text"},"ts":1719944923993,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$frsMgYEzgS7jv2NZ31v-beLcwCdC6-lO8BtMTzYpirY"},
{"content":{"body":"Where `... unsafe { }` is just syntactic sugar for `... { unsafe { } }`","format":"org.matrix.custom.html","formatted_body":"Where <code>... unsafe { }</code> is just syntactic sugar for <code>... { unsafe { } }</code>","m.mentions":{},"msgtype":"m.text"},"ts":1719944938366,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2ePHFrN3tdqBluufTb-3oPQI7Ns7u1UXNrxvf757VE4"},
{"content":{"body":"(Although there's a chance that we could fold it into checks that we already have to do to ensure that you don't call a derived constructor without `new`)","format":"org.matrix.custom.html","formatted_body":"(Although there's a chance that we could fold it into checks that we already have to do to ensure that you don't call a derived constructor without <code>new</code>)","m.mentions":{},"msgtype":"m.text"},"ts":1719944972224,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$e6gnZgu6LKEVODlsdM9wFzc4_7gMDouFfGnFVwPm70A"},
{"content":{"body":"Could that slow down be handled via a function stub, such that \"safe\" code has no overhead (if it calls the stub, the stub throws), while \"unsafe\" code has overhead as it must check for the stub to step over it, or to pass the stub a flag indicating safety.","m.mentions":{},"msgtype":"m.text"},"ts":1719945065883,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ihRKEU8I_sk9W0WzCjEyrl6iksNUnZ9B5tskzVSIY4c"},
{"content":{"body":" * Could that slow down be handled via a function stub, such that \"safe\" code has no overhead (if it calls the stub, the stub throws), while \"unsafe\" code has overhead as it must check for the stub to step over it, or to pass the stub a flag indicating safety?","m.mentions":{},"m.new_content":{"body":"Could that slow down be handled via a function stub, such that \"safe\" code has no overhead (if it calls the stub, the stub throws), while \"unsafe\" code has overhead as it must check for the stub to step over it, or to pass the stub a flag indicating safety?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$ihRKEU8I_sk9W0WzCjEyrl6iksNUnZ9B5tskzVSIY4c","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719945075109,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KSul9iF9ZvjJ5P155c7zgH5nUlktiSJf7h1U1qaUed4"},
{"content":{"body":"We already expect \"unsafe\" code will have some additional complexity even without the notion of an `unsafe {}` block, purely because reads and writes potentially require agent coordination","format":"org.matrix.custom.html","formatted_body":"We already expect \"unsafe\" code will have some additional complexity even without the notion of an <code>unsafe {}</code> block, purely because reads and writes potentially require agent coordination","m.mentions":{},"msgtype":"m.text"},"ts":1719945224340,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZQzH445UkW40IQZCrPOpqZIL5xU894zSum2vv9VLOSg"},
{"content":{"body":"At a hardware level there isn't really any way to pass a flag that doesn't require the safe caller to do at least a little bit of work to not pass it","m.mentions":{},"msgtype":"m.text"},"ts":1719945357145,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$f4L2ZUIQ1XiRAD188BrbekqqGUonOZ_7ZYzljU66o1Q"},
{"content":{"body":"(That's maybe not true if you imagine that we have some sort of global \"are we in an unsafe block\" flag that gets cleared when unsafe code calls into safe code and reset when we return, but keeping that flag set correctly seems potentially complicated.)","m.mentions":{},"msgtype":"m.text"},"ts":1719945473546,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$zB1EGWfqcUqkU4GnuNVeofZWkcWkdpK0O5nm2m8SOoE"},
{"content":{"body":"So \"safe code just calls the function\" as normal (which throws for the stub), and \"unsafe code first checks if the function is an unsafe function stub and then calls the underlying function\" isn't an option?","m.mentions":{},"msgtype":"m.text"},"ts":1719945512625,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$m779N-kWcnRhpoJF5-ENP23HD6q4XC_qpPwirJTdvAU"},
{"content":{"body":"The overall performance cost here is pretty small","m.mentions":{},"msgtype":"m.text"},"ts":1719945513004,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$uMnkt6iTWmY8GMw0e7eeK9Xv3Lgr5YUlzJqrHGm42CU"},
{"content":{"body":"I'll admit, I'm primarily coming at this from the spec perspective, and not the perspective of an implementer or optimizin gcompiler.","m.mentions":{},"msgtype":"m.text"},"ts":1719945549058,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rL8BSueCCCAndIaWXc2nVuVMgtJBSHMhgyvHjbO83Uo"},
{"content":{"body":"Yeah, I guess I can see some ways of making that work. ","m.mentions":{},"msgtype":"m.text"},"ts":1719945600055,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$Gd_ucsvxtTSCiT6-C9INOAKIWtSDdLE6IMZE6-UrSn8"},
{"content":{"body":"Although they end up adding a fair bit of complexity to some already very complicated code","m.mentions":{},"msgtype":"m.text"},"ts":1719945663166,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$NiJkZtX_wnsEgQSJND1YiYMr5JNTLhG2zOkjFu1-JwE"},
{"content":{"body":"But I wouldn't expect a global flag is necessary given that `unsafe {}` is purely syntactic and could be used to drive transformations or optimizations based on its presence in the parse tree.","format":"org.matrix.custom.html","formatted_body":"But I wouldn't expect a global flag is necessary given that <code>unsafe {}</code> is purely syntactic and could be used to drive transformations or optimizations based on its presence in the parse tree.","m.mentions":{},"msgtype":"m.text"},"ts":1719945665206,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eWeIOGYI_4mIbt8xuj9OBx3YX0LMR61p0IinXubw0Ug"},
{"content":{"body":"Taking a step back: this can all be implemented, and with sufficient elbow grease the overhead could be minimized. The question is whether coloured functions provide enough value to justify engines spending their limited elbows on this instead of the million other things we could be implementing / optimizing.","m.mentions":{},"msgtype":"m.text"},"ts":1719945884476,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$R617YgXyXEUWfPgpYlmSknCya5GqiYn1I-T-QXSJlkE"},
{"content":{"body":"i don't think function coloring is problematic from engines' perspectives, but it is pretty bad for usability, especially since we already have async/non-async","m.mentions":{},"msgtype":"m.text"},"ts":1719946298938,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$qqDE0p9s3r1lEj-uA9VuCX-x_3PHCCfrYzfgX3nzRfs"},
{"content":{"body":"Actually, now that I'm thinking through the implementation, even normal `unsafe` blocks are at least a little annoying to implement, because it means that every GetProperty needs to know its location in the source. Or else you use a global flag, and clear it around calls?","format":"org.matrix.custom.html","formatted_body":"Actually, now that I'm thinking through the implementation, even normal <code>unsafe</code> blocks are at least a little annoying to implement, because it means that every GetProperty needs to know its location in the source. Or else you use a global flag, and clear it around calls?","m.mentions":{},"msgtype":"m.text"},"ts":1719946540735,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$x9YDHZ5B-UCi1ulTnHTsj0Ee6HW7I8O12E55d1MpPY4"},
{"content":{"body":"i was actually imagining something even dumber, like outputting different bytecode","m.mentions":{},"msgtype":"m.text"},"ts":1719946612924,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$uBFu789Lu_NdI7xH7kYTRtFe1r0XymKYbovOriLnET4"},
{"content":{"body":"since it's lexical","m.mentions":{},"msgtype":"m.text"},"ts":1719946641897,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Ie9KQal0KW3NGcltETANdEjg4paQnwcieB0lXPoAliI"},
{"content":{"body":"Oh, yeah, maybe that works too","m.mentions":{},"msgtype":"m.text"},"ts":1719946659753,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$ec9X7z5Q3Htn0bGBBwg5BAQM7L86tvF5oqJEqcpk_rs"},
{"content":{"body":"could still be slightly annoying maybe to maintain two types of property access, with their ICs and such","m.mentions":{},"msgtype":"m.text"},"ts":1719946679559,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$HjS1uK1mNJAtfCus4gZzDJF1nqD4VPALeWtVpRNuLA0"},
{"content":{"body":"My biggest concern was `unsafe` having `async`/`await`-like poisoning effects. Introducing `async` to a sync function normally poisons it's callers if they must maintain sequential execution. Given that you can nest an `unsafe{}` block in safe code, the concern is lessened somewhat. In the call I said that an `unsafe function` doesn't perform any implicit synchronization or coordination, so its up to the author to implement any necessary coordination, including none at all. The \"none at all\" coordination was meant as a way for you to decompose an `unsafe` function into multiple `unsafe` functions without having to guard against \"safe\" code invoking them unintentionally by leveraging scoping. Function coloring at this level isn't quite as bad as I'd feared, and has the benefit of pushing the user to implement safety in a function not marked `unsafe`.","format":"org.matrix.custom.html","formatted_body":"My biggest concern was <code>unsafe</code> having <code>async</code>/<code>await</code>-like poisoning effects. Introducing <code>async</code> to a sync function normally poisons it's callers if they must maintain sequential execution. Given that you can nest an <code>unsafe{}</code> block in safe code, the concern is lessened somewhat. In the call I said that an <code>unsafe function</code> doesn't perform any implicit synchronization or coordination, so its up to the author to implement any necessary coordination, including none at all. The \"none at all\" coordination was meant as a way for you to decompose an <code>unsafe</code> function into multiple <code>unsafe</code> functions without having to guard against \"safe\" code invoking them unintentionally by leveraging scoping. Function coloring at this level isn't quite as bad as I'd feared, and has the benefit of pushing the user to implement safety in a function not marked <code>unsafe</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1719946691811,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QnZVjL6IUrrN6pbDoGqDDwHf4xWZOfqQTXt8fGh0QOk"},
{"content":{"body":"> <@littledan:matrix.org> could still be slightly annoying maybe to maintain two types of property access, with their ICs and such\n\nV8 bytecodes at least can have immediate arguments. it could be a Get with an \"in-unsafe-block\" bit","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$HjS1uK1mNJAtfCus4gZzDJF1nqD4VPALeWtVpRNuLA0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>could still be slightly annoying maybe to maintain two types of property access, with their ICs and such</blockquote></mx-reply>V8 bytecodes at least can have immediate arguments. it could be a Get with an \"in-unsafe-block\" bit","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$HjS1uK1mNJAtfCus4gZzDJF1nqD4VPALeWtVpRNuLA0"}},"msgtype":"m.text"},"ts":1719946712422,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Sm1uaRWKtnt8djLdQfZwi-BWOOyw61yByyMYgDrq318"},
{"content":{"body":"like, the same way \"should throw\" flags are threaded through for strict code","m.mentions":{},"msgtype":"m.text"},"ts":1719946746490,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$PpQh3z31tFU-SUZBlfmpxcVmjE_AbfFYi_38YbreCbY"},
{"content":{"body":"SM has SetProp/StrictSetProp and so on","m.mentions":{},"msgtype":"m.text"},"ts":1719946804837,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$Fz40n_zw4NVDPfn7NNl2yRi7Wrxzys2RKMnlN6l_zlY"},
{"content":{"body":"Although most of the code is shared","m.mentions":{},"msgtype":"m.text"},"ts":1719946821710,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$jTL4MzjpMjUZ5NzHFy7gMez5YW4fc1rPPSdhl7DVkeY"},
{"content":{"body":"yeah, same","m.mentions":{},"msgtype":"m.text"},"ts":1719946826344,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$svLbqPRmu17Cc7vggXxUV0xPoweQtoX_FedDBRaluDQ"},
{"content":{"body":"It ends up being similar in practice","m.mentions":{},"msgtype":"m.text"},"ts":1719946828175,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$D0CtPdncUGMbA128I7-HpcOihtS1LQWmKPgtAAGiq70"},
{"content":{"body":"same to \"most of the code is shared\"","m.mentions":{},"msgtype":"m.text"},"ts":1719946831917,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$A8zIlXdb6HM1a_5S8KaXKbw0XeT4lZfU3BEvUrckr6o"},
{"content":{"body":"In other words, this\n```js\nunsafe function readMessage(workArea) { ... }\nunsafe function writeMessage(workArea, message) { ... }\nunsafe function processMessage(message) { ... }\n\nfunction processWorkArea(workArea) unsafe {\n  let message;\n  while (message = readMessage(workArea)) {\n    const result = processMessage(message);\n    writeMessage(workArea, result);\n  }\n}\n```\nDoesn't seem quite so bad to me (though I still prefer `function() unsafe { }` to `function() { unsafe { } }`)","format":"org.matrix.custom.html","formatted_body":"<p>In other words, this</p>\n<pre><code class=\"language-js\">unsafe function readMessage(workArea) { ... }\nunsafe function writeMessage(workArea, message) { ... }\nunsafe function processMessage(message) { ... }\n\nfunction processWorkArea(workArea) unsafe {\n  let message;\n  while (message = readMessage(workArea)) {\n    const result = processMessage(message);\n    writeMessage(workArea, result);\n  }\n}\n</code></pre>\n<p>Doesn't seem quite so bad to me (though I still prefer <code>function() unsafe { }</code> to <code>function() { unsafe { } }</code>)</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719946898020,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Xuhr8_CuYfZzjXMsN3MhL2VGAks2588YnLzBeF4G2mU"},
{"content":{"body":" * In other words, this\n\n```js\nunsafe function readMessage(lck, workArea) { ... }\nunsafe function writeMessage(workArea, message) { ... }\nunsafe function processMessage(message) { ... }\n\nfunction processWorkArea(mut, workArea) unsafe {\n  using lck = new UniqueLock(mut);\n  let message;\n  while (message = readMessage(lck, workArea)) {\n    const result = processMessage(message);\n    writeMessage(workArea, result);\n  }\n}\n```\n\nDoesn't seem quite so bad to me (though I still prefer `function() unsafe { }` to `function() { unsafe { } }`)","format":"org.matrix.custom.html","formatted_body":" * <p>In other words, this</p>\n<pre><code class=\"language-js\">unsafe function readMessage(lck, workArea) { ... }\nunsafe function writeMessage(workArea, message) { ... }\nunsafe function processMessage(message) { ... }\n\nfunction processWorkArea(mut, workArea) unsafe {\n  using lck = new UniqueLock(mut);\n  let message;\n  while (message = readMessage(lck, workArea)) {\n    const result = processMessage(message);\n    writeMessage(workArea, result);\n  }\n}\n</code></pre>\n<p>Doesn't seem quite so bad to me (though I still prefer <code>function() unsafe { }</code> to <code>function() { unsafe { } }</code>)</p>\n","m.mentions":{},"m.new_content":{"body":"In other words, this\n\n```js\nunsafe function readMessage(lck, workArea) { ... }\nunsafe function writeMessage(workArea, message) { ... }\nunsafe function processMessage(message) { ... }\n\nfunction processWorkArea(mut, workArea) unsafe {\n  using lck = new UniqueLock(mut);\n  let message;\n  while (message = readMessage(lck, workArea)) {\n    const result = processMessage(message);\n    writeMessage(workArea, result);\n  }\n}\n```\n\nDoesn't seem quite so bad to me (though I still prefer `function() unsafe { }` to `function() { unsafe { } }`)","format":"org.matrix.custom.html","formatted_body":"<p>In other words, this</p>\n<pre><code class=\"language-js\">unsafe function readMessage(lck, workArea) { ... }\nunsafe function writeMessage(workArea, message) { ... }\nunsafe function processMessage(message) { ... }\n\nfunction processWorkArea(mut, workArea) unsafe {\n  using lck = new UniqueLock(mut);\n  let message;\n  while (message = readMessage(lck, workArea)) {\n    const result = processMessage(message);\n    writeMessage(workArea, result);\n  }\n}\n</code></pre>\n<p>Doesn't seem quite so bad to me (though I still prefer <code>function() unsafe { }</code> to <code>function() { unsafe { } }</code>)</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$Xuhr8_CuYfZzjXMsN3MhL2VGAks2588YnLzBeF4G2mU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719946997239,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$EvVHv9jHe3xB8kmNq-bA7QwhsDZvDlm1rpn5aT1BWEY"},
{"content":{"body":"It has the upside of preventing users from inadvertently invoking unsafe code from safe code and allows you to declare your function as not only containing unsafe code, but also indicating that it doesn't internally perform any coordination.","m.mentions":{},"msgtype":"m.text"},"ts":1719947081124,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gr9CK-Gyfg6MWwhYFVY2hOO42FDvzykyN0u3J59JsME"},
{"content":{"body":"In C#, `unsafe` can apply to a function/method, but does not affect callers: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unsafe","format":"org.matrix.custom.html","formatted_body":"In C#, <code>unsafe</code> can apply to a function/method, but does not affect callers: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unsafe","m.mentions":{},"msgtype":"m.text"},"ts":1719947337608,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-b3trGqO6eMlnTKDtOSCx5BVTrxcGnxpOYhNQGu4cCo"},
{"content":{"body":"Though `unsafe` in C# is primarily around direct access to pointers (which Rust also shares).","format":"org.matrix.custom.html","formatted_body":"Though <code>unsafe</code> in C# is primarily around direct access to pointers (which Rust also shares).","m.mentions":{},"msgtype":"m.text"},"ts":1719947381438,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KyM4gz7YzgXayv7T2ObQriXz53ZO71aVm3Z5_uu8i7A"},
{"content":{"body":"For me the uncertainty about the value of function colouring implies strongly that we should leave out `unsafe function` syntax for now. In the future we will have much more user experience to help determine what that syntax should mean.","format":"org.matrix.custom.html","formatted_body":"For me the uncertainty about the value of function colouring implies strongly that we should leave out <code>unsafe function</code> syntax for now. In the future we will have much more user experience to help determine what that syntax should mean.","m.mentions":{},"msgtype":"m.text"},"ts":1719947401273,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$m_pvpKgMDZGBcbiUwfihfIaQ_SyGcLsOMu33ipdAPPA"},
{"content":{"body":"I'd really like to be able to write conventional JS with shared structs when I know I already have exclusive access to an object. If we only have `unsafe {}`, I can't write this\n```js\nunsafe function doWork(task, timeout = task.timeout ?? 1000) { ... }\n```\nand instead must write this\n```js\nfunction doWork(task, timeout) {\n  unsafe {\n    timeout ??= task.timeout ?? 1000;\n    ...\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I'd really like to be able to write conventional JS with shared structs when I know I already have exclusive access to an object. If we only have <code>unsafe {}</code>, I can't write this</p>\n<pre><code class=\"language-js\">unsafe function doWork(task, timeout = task.timeout ?? 1000) { ... }\n</code></pre>\n<p>and instead must write this</p>\n<pre><code class=\"language-js\">function doWork(task, timeout) {\n  unsafe {\n    timeout ??= task.timeout ?? 1000;\n    ...\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719947642398,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nbMkTr_IFehHbsBCHGdNHVbPz69dm_AYPzFbFImFABo"},
{"content":{"body":"However, I do see the potential value of safe code erroring if you invoke `doWork`, since `doWork` here _doesn't_ implement a coordination mechanism as it's intended to be used from another function that does. Instead, I must indicate it by convention, i.e. `function doWorkUnsafe()` to draw attention to its use.","format":"org.matrix.custom.html","formatted_body":"However, I do see the potential value of safe code erroring if you invoke <code>doWork</code>, since <code>doWork</code> here <em>doesn't</em> implement a coordination mechanism as it's intended to be used from another function that does. Instead, I must indicate it by convention, i.e. <code>function doWorkUnsafe()</code> to draw attention to its use.","m.mentions":{},"msgtype":"m.text"},"ts":1719947771644,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KHCWCS8uckdhoZEfV6vx4DnWwvyCYQADhIdadytmD5Q"},
{"content":{"body":"Let me be clear on my position though. If we must have `unsafe`, but can only have `unsafe {}` for now, I'm fine with that. I do think the lack of an `unsafe` marker for functions and class/struct bodies is a major DX wart that will very likely need to be addressed at some point, function coloring or not. I just don't want to go down a road of allowing `import`/`export` inside of an `unsafe` block as it would likely be a long term aesthetic wart on the language *after* we introduce an `unsafe` marker in other contexts.","format":"org.matrix.custom.html","formatted_body":"Let me be clear on my position though. If we must have <code>unsafe</code>, but can only have <code>unsafe {}</code> for now, I'm fine with that. I do think the lack of an <code>unsafe</code> marker for functions and class/struct bodies is a major DX wart that will very likely need to be addressed at some point, function coloring or not. I just don't want to go down a road of allowing <code>import</code>/<code>export</code> inside of an <code>unsafe</code> block as it would likely be a long term aesthetic wart on the language <em>after</em> we introduce an <code>unsafe</code> marker in other contexts.","m.mentions":{},"msgtype":"m.text"},"ts":1719948074726,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tm5h18peixYxZVcSJ1HA4QiyW_x2aOPTaqxV0uI_t7c"},
{"content":{"body":"We *could* consider an alternative to make `import`/`export` work, by declaring the entire module as `unsafe` via something like `unsafe module;` (or some other incantation) at the top level.","format":"org.matrix.custom.html","formatted_body":"We <em>could</em> consider an alternative to make <code>import</code>/<code>export</code> work, by declaring the entire module as <code>unsafe</code> via something like <code>unsafe module;</code> (or some other incantation) at the top level.","m.mentions":{},"msgtype":"m.text"},"ts":1719948234877,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BsZMOk1KdEM0i4W0QbegjZFOGiDg1xIWU0GkcbNAXB0"},
{"content":{"body":"Or use module blocks, i.e.:\n\n```js\nunsafe module M {\n  export shared struct AtomicValue { ... }\n}\nexport * from M;\n```","format":"org.matrix.custom.html","formatted_body":"<p>Or use module blocks, i.e.:</p>\n<pre><code class=\"language-js\">unsafe module M {\n  export shared struct AtomicValue { ... }\n}\nexport * from M;\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719948310966,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$do1G4yeiWC7iNQ9hJiHzsVSfc30nFjKujEgQUH5l04M"},
{"content":{"body":" * Or use module blocks, e.g.:\n\n```js\nunsafe module M {\n  export shared struct AtomicValue { ... }\n}\nexport * from M;\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Or use module blocks, e.g.:</p>\n<pre><code class=\"language-js\">unsafe module M {\n  export shared struct AtomicValue { ... }\n}\nexport * from M;\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"Or use module blocks, e.g.:\n\n```js\nunsafe module M {\n  export shared struct AtomicValue { ... }\n}\nexport * from M;\n```","format":"org.matrix.custom.html","formatted_body":"<p>Or use module blocks, e.g.:</p>\n<pre><code class=\"language-js\">unsafe module M {\n  export shared struct AtomicValue { ... }\n}\nexport * from M;\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$do1G4yeiWC7iNQ9hJiHzsVSfc30nFjKujEgQUH5l04M","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719948318769,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9XhsG4zkXnO9Vfv26gGoCpzfTGJiCxGYu_TcHVRgfgI"},
{"content":{"body":"(though that still uses `unsafe` as a prefix)","format":"org.matrix.custom.html","formatted_body":"(though that still uses <code>unsafe</code> as a prefix)","m.mentions":{},"msgtype":"m.text"},"ts":1719948409541,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rQ2uqSRRSSxeCXIi3JXQcQg6ATDBviJeAXWvSL7o3Co"},
{"content":{"body":"I'd also be fine with postfix-`unsafe` markers for declarations (`function f() unsafe { }`) and potentially allowing `unsafe` in both positions (`unsafe function f() {}` and `function f() unsafe {}`, though `unsafe function f() unsafe {}` is redundant). I'd also be fine with `unsafe` markers for parameters much like I suggested for variable and field initializers in a world where we either can't have postifx-`unsafe` or if postfix-`unsafe` can't include parameters, e.g.:\n```js\nfunction doWork(task, unsafe timeout = task.timeout ?? 1000) {\n  unsafe { ... }\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>I'd also be fine with postfix-<code>unsafe</code> markers for declarations (<code>function f() unsafe { }</code>) and potentially allowing <code>unsafe</code> in both positions (<code>unsafe function f() {}</code> and <code>function f() unsafe {}</code>, though <code>unsafe function f() unsafe {}</code> is redundant). I'd also be fine with <code>unsafe</code> markers for parameters much like I suggested for variable and field initializers in a world where we either can't have postifx-<code>unsafe</code> or if postfix-<code>unsafe</code> can't include parameters, e.g.:</p>\n<pre><code class=\"language-js\">function doWork(task, unsafe timeout = task.timeout ?? 1000) {\n  unsafe { ... }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719948775316,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TYZ3DRsBIp_Vb-itwIOEK_IMSOLNZ9tB8xNjKaf_chg"},
{"content":{"body":"IMO, only having `unsafe {}` is not ideal, though `do unsafe {}` would make that *somewhat* more bearable, e.g.:\n```js\nfunction doWork(task, timeout = do unsafe { task.timeout } ?? 1000) {\n  unsafe { }\n}\n```\nBut for that we would need `do {}` to advance.","format":"org.matrix.custom.html","formatted_body":"<p>IMO, only having <code>unsafe {}</code> is not ideal, though <code>do unsafe {}</code> would make that <em>somewhat</em> more bearable, e.g.:</p>\n<pre><code class=\"language-js\">function doWork(task, timeout = do unsafe { task.timeout } ?? 1000) {\n  unsafe { }\n}\n</code></pre>\n<p>But for that we would need <code>do {}</code> to advance.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719948939858,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$H_PwwEwrBxxr4ywhsppPcho7wGOXB5N8cQ4dLcEZ7RM"},
{"content":{"body":"Or we would have to advance `unsafe {}` as an expression as well, which would be confusing if we do end up advancing `do`.","format":"org.matrix.custom.html","formatted_body":"Or we would have to advance <code>unsafe {}</code> as an expression as well, which would be confusing if we do end up advancing <code>do</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1719949007395,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rOBO1FklvUexwjX3SjY35FKCPGz1cJ0tHzWRwKJ8jeU"},
{"content":{"body":"It would be great if someone brought do expressions back to committee. My understanding is that bakkot is leaving that for others to champion. (Maybe there is some remaining controversy but I dont know what it is)","msgtype":"m.text"},"ts":1719958082343,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$TZSpp3WVUO_yd4SmvSrlZGCYzkQS-uFr1qBnEaAGED0"},
{"content":{"body":"It looks like we decided in [March 2021](https://github.com/tc39/notes/blob/main/meetings/2021-03/mar-9.md) that we were going to do some sort of user study. Did anything ever come of that?","format":"org.matrix.custom.html","formatted_body":"It looks like we decided in <a href=\"https://github.com/tc39/notes/blob/main/meetings/2021-03/mar-9.md\">March 2021</a> that we were going to do some sort of user study. Did anything ever come of that?","m.mentions":{},"msgtype":"m.text"},"ts":1719959344986,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$7KQwolmuPG1-LxOWR97P3EAQ8Pl0IbCrBlkGYbPigMA"},
{"content":{"body":"> <@rbuckton:matrix.org> An alternative to `unsafe function f() {}` that I'd also put on the explainer might be `function f() unsafe { }`. My concern is that this isn't obvious that it also affects the parameter list. Then again `function f() { \"use strict\"; }` affects the parameter list as well.\n\nI am honestly suspicious of any code that attempts to do anything with a shared struct passed in arguments without first satisfying whatever synchronization mechanism is appropriate to access that shared struct. As such I suspect that only allowing unsafe blocks is actually a benefit as it would force authors to consider whether they've first satisfied the synchronization responsibility they're supposed to take on, and which seem hard to satisfy within the parameters list alone.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$V3DzgIPaOW5ya52cV9woO84YvH7Mdckp7eFqAABmRBY?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />An alternative to <code>unsafe function f() {}</code> that I'd also put on the explainer might be <code>function f() unsafe { }</code>. My concern is that this isn't obvious that it also affects the parameter list. Then again <code>function f() { \"use strict\"; }</code> affects the parameter list as well.</blockquote></mx-reply>I am honestly suspicious of any code that attempts to do anything with a shared struct passed in arguments without first satisfying whatever synchronization mechanism is appropriate to access that shared struct. As such I suspect that only allowing unsafe blocks is actually a benefit as it would force authors to consider whether they've first satisfied the synchronization responsibility they're supposed to take on, and which seem hard to satisfy within the parameters list alone.","m.relates_to":{"m.in_reply_to":{"event_id":"$V3DzgIPaOW5ya52cV9woO84YvH7Mdckp7eFqAABmRBY"}},"msgtype":"m.text"},"ts":1719962694113,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Wpvej-uCRfjUiNRPvpceWaJ7KWPnFEglOF3dJaIqQ20"},
{"content":{"body":"> <@rbuckton:matrix.org> I'd really like to be able to write conventional JS with shared structs when I know I already have exclusive access to an object. If we only have `unsafe {}`, I can't write this\n> ```js\n> unsafe function doWork(task, timeout = task.timeout ?? 1000) { ... }\n> ```\n> and instead must write this\n> ```js\n> function doWork(task, timeout) {\n>   unsafe {\n>     timeout ??= task.timeout ?? 1000;\n>     ...\n>   }\n> }\n> ```\n\nCan't you define your `doWork` function inside an unsafe block instead?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$nbMkTr_IFehHbsBCHGdNHVbPz69dm_AYPzFbFImFABo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br /><p>I'd really like to be able to write conventional JS with shared structs when I know I already have exclusive access to an object. If we only have <code>unsafe {}</code>, I can't write this</p>\n<pre><code class=\"language-js\">unsafe function doWork(task, timeout = task.timeout ?? 1000) { ... }\n</code></pre>\n<p>and instead must write this</p>\n<pre><code class=\"language-js\">function doWork(task, timeout) {\n  unsafe {\n    timeout ??= task.timeout ?? 1000;\n    ...\n  }\n}\n</code></pre>\n</blockquote></mx-reply>Can't you define your <code>doWork</code> function inside an unsafe block instead?","m.relates_to":{"m.in_reply_to":{"event_id":"$nbMkTr_IFehHbsBCHGdNHVbPz69dm_AYPzFbFImFABo"}},"msgtype":"m.text"},"ts":1719963318270,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$iS-tgg-RTOG0GT8Jxe9BFaDEQdD9JgDbg2qcTjYVwcs"},
{"content":{"body":"In an earlier example I showed how you might decompose a series of `unsafe` operations into multiple functions, where only the entrypoint function would perform any coordination, i.e.:\n```js\nunsafe function readMessage(...) { ... }\nunsafe function writeMessage(...) { ... }\nunsafe function processMessage(...) { ... }\nfunction processWorkArea(workArea) {\n  unsafe {\n    // performs locking\n    // calls readMessage/writeMessage/processMessage\n  }\n}\n```\n\nIf we have `unsafe function`, we can enforce that safe code cannot invoke an `unsafe` function directly, or inadvertently. \nIf we do not have `unsafe function` and only have `unsafe {}`, then we cannot perform such enforcement and there is no clear delineation between a safe entrypoint and unsafe code:\n\n```js\nfunction readMessage(...) { unsafe { ... } }\nfunction writeMessage(...) { unsafe { ... } }\nfunction processMessage(...) { unsafe { ... } }\nfunction processWorkArea(workArea) {\n  unsafe {\n    // performs locking\n    // calls readMessage/writeMessage/processMessage\n  }\n}\n```\nHere, `readMessage` will not perform any independent coordination or locking as it expects to be called by `processWorkArea`, which is the function that would actually perform locking. A user could inadvertently invoke `readMessage` from \"safe\" code, resulting in a data race. The only way to enforce this is by convention, thus you would instead want to write this as:\n```js\nfunction readMessageUnsafe(...) { unsafe { ... } }\nfunction writeMessageUnsafe(...) { unsafe { ... } }\nfunction processMessageUnsafe(...) { unsafe { ... } }\nfunction processWorkArea(workArea) {\n  unsafe {\n    // performs locking\n    // calls readMessageUnsafe/writeMessageUnsafe/processMessageUnsafe\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>In an earlier example I showed how you might decompose a series of <code>unsafe</code> operations into multiple functions, where only the entrypoint function would perform any coordination, i.e.:</p>\n<pre><code class=\"language-js\">unsafe function readMessage(...) { ... }\nunsafe function writeMessage(...) { ... }\nunsafe function processMessage(...) { ... }\nfunction processWorkArea(workArea) {\n  unsafe {\n    // performs locking\n    // calls readMessage/writeMessage/processMessage\n  }\n}\n</code></pre>\n<p>If we have <code>unsafe function</code>, we can enforce that safe code cannot invoke an <code>unsafe</code> function directly, or inadvertently.<br>If we do not have <code>unsafe function</code> and only have <code>unsafe {}</code>, then we cannot perform such enforcement and there is no clear delineation between a safe entrypoint and unsafe code:</p>\n<pre><code class=\"language-js\">function readMessage(...) { unsafe { ... } }\nfunction writeMessage(...) { unsafe { ... } }\nfunction processMessage(...) { unsafe { ... } }\nfunction processWorkArea(workArea) {\n  unsafe {\n    // performs locking\n    // calls readMessage/writeMessage/processMessage\n  }\n}\n</code></pre>\n<p>Here, <code>readMessage</code> will not perform any independent coordination or locking as it expects to be called by <code>processWorkArea</code>, which is the function that would actually perform locking. A user could inadvertently invoke <code>readMessage</code> from \"safe\" code, resulting in a data race. The only way to enforce this is by convention, thus you would instead want to write this as:</p>\n<pre><code class=\"language-js\">function readMessageUnsafe(...) { unsafe { ... } }\nfunction writeMessageUnsafe(...) { unsafe { ... } }\nfunction processMessageUnsafe(...) { unsafe { ... } }\nfunction processWorkArea(workArea) {\n  unsafe {\n    // performs locking\n    // calls readMessageUnsafe/writeMessageUnsafe/processMessageUnsafe\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719963328469,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$sJK6SVFdqA33P47CJIvrbYCGVT8KYJKa1Bo01AnVurc"},
{"content":{"body":"> <@mhofman:matrix.org> Can't you define your `doWork` function inside an unsafe block instead?\n\nIt's not quite so easy if I want to make `doWork` available to code outside of the block:\n\n```js\nlet doWork;\nunsafe {\n  doWork = function() { ... };\n}\n```\n\nThis would be a regular frustration developers would encounter, both here and with `import`/`export`, or shared struct bodies, etc.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$iS-tgg-RTOG0GT8Jxe9BFaDEQdD9JgDbg2qcTjYVwcs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Can't you define your <code>doWork</code> function inside an unsafe block instead?</blockquote></mx-reply><p>It's not quite so easy if I want to make <code>doWork</code> available to code outside of the block:</p>\n<pre><code class=\"language-js\">let doWork;\nunsafe {\n  doWork = function() { ... };\n}\n</code></pre>\n<p>This would be a regular frustration developers would encounter, both here and with <code>import</code>/<code>export</code>, or shared struct bodies, etc.</p>\n","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$iS-tgg-RTOG0GT8Jxe9BFaDEQdD9JgDbg2qcTjYVwcs"}},"msgtype":"m.text"},"ts":1719963456948,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_6y_b_5WqcIbtkgZ3f0igHDrEkaXZwJ0gtFeSFoyXV8"},
{"content":{"body":"Blocks are best for localizing the transition from safe to unsafe. They're terrible for encapsulating declarations since you generally want at least one declaration to escape the block to be actually usable.","m.mentions":{},"msgtype":"m.text"},"ts":1719963513274,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3jskITQkOoKoDA0k71acgf_K3q5OnX3VwPYObZdgMbs"},
{"content":{"body":"I do find interesting the proposition that the user could define unsafe functions that like shared struct fields do need to be called from an unsafe context. As mentioned that seems to point we could for know reserve that space in the syntax for later ","msgtype":"m.text"},"ts":1719963527903,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$_ns7ng8NwZrXu48Yi1EdWVjitJGoX1s-nl2DhaFMqcw"},
{"content":{"body":"Note that we could also simply allow\n```\nunsafe {\n  let doWork = ...; \n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Note that we could also simply allow</p>\n<pre><code>unsafe {\n  let doWork = ...; \n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719963588661,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$-3LljEOtVOFHzeCJYq-V_aosrbIXV6F11-O0QOmPD_U"},
{"content":{"body":"An unsafe block doesn't have to be a separate lexical scope of its own","m.mentions":{},"msgtype":"m.text"},"ts":1719963645958,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$xKH3HN_ijFR6s2ng9jEQx_QdGkVqGqzJWhs4mt3Dq8w"},
{"content":{"body":"i would strongly prefer that something that looks like `{ }` be its own lexical scope","format":"org.matrix.custom.html","formatted_body":"i would strongly prefer that something that looks like <code>{ }</code> be its own lexical scope","m.mentions":{},"msgtype":"m.text"},"ts":1719963664557,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$8sQryijqLxsF_XzbKlti9baLJPKjgN57Ldg07CeTKuY"},
{"content":{"body":"lexical scoping should never escape a `{}`, that would be a terrible precedent.","format":"org.matrix.custom.html","formatted_body":"lexical scoping should never escape a <code>{}</code>, that would be a terrible precedent.","m.mentions":{},"msgtype":"m.text"},"ts":1719963686835,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Pt0hm7Iz6GolxG2r-l9LqhmpijV9YKTYkqUSWoHjhtw"},
{"content":{"body":"that is a pretty deep affordance","m.mentions":{},"msgtype":"m.text"},"ts":1719963689154,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$SLeVIIgrAsIzXZmP5b5zi6gaF3-kbUTUag-8G2ID12M"},
{"content":{"body":"yeah","m.mentions":{},"msgtype":"m.text"},"ts":1719963690629,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Ju9J1R3li-GHqiNtZzdQ3a8z1URojLIp2r2BCUtaHJs"},
{"content":{"body":"We don't even let class decorators access lexically scoped private names.","m.mentions":{},"msgtype":"m.text"},"ts":1719963706642,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QJyvkF4206KUMAXThcqQIHc5jV3fqNG5gZt4n_ITEM8"},
{"content":{"body":" * We don't even let class decorators access lexically scoped private names since they're outside of the class body","m.mentions":{},"m.new_content":{"body":"We don't even let class decorators access lexically scoped private names since they're outside of the class body","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$QJyvkF4206KUMAXThcqQIHc5jV3fqNG5gZt4n_ITEM8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719963716983,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MQkTRsEPeEU984BpmIy7i27AAUDKVPSqpahrXjaNhxI"},
{"content":{"body":"I point to the parallel of namespace blocks in C++, where indenting them like:\n```\nunsafe {\n\nlet doWork = ...\n\n}\n```\nmakes it less confusing.","format":"org.matrix.custom.html","formatted_body":"<p>I point to the parallel of namespace blocks in C++, where indenting them like:</p>\n<pre><code>unsafe {\n\nlet doWork = ...\n\n}\n</code></pre>\n<p>makes it less confusing.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719963719689,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$5_eY-LLHUrHmXehk_SpShMowAhGgdHiYngkHV4OZQFI"},
{"content":{"body":"> <@mhofman:matrix.org> I do find interesting the proposition that the user could define unsafe functions that like shared struct fields do need to be called from an unsafe context. As mentioned that seems to point we could for know reserve that space in the syntax for later\n\nruntime enforcement of colored functions like that is probably a no-go","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$_ns7ng8NwZrXu48Yi1EdWVjitJGoX1s-nl2DhaFMqcw?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I do find interesting the proposition that the user could define unsafe functions that like shared struct fields do need to be called from an unsafe context. As mentioned that seems to point we could for know reserve that space in the syntax for later </blockquote></mx-reply>runtime enforcement of colored functions like that is probably a no-go","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$_ns7ng8NwZrXu48Yi1EdWVjitJGoX1s-nl2DhaFMqcw"}},"msgtype":"m.text"},"ts":1719963731219,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$FWgIFRGd69D7OLPKsuIy_AEwXpGmcS6R9p78JAVnNDU"},
{"content":{"body":"> <@iain:mozilla.org> I point to the parallel of namespace blocks in C++, where indenting them like:\n> ```\n> unsafe {\n> \n> let doWork = ...\n> \n> }\n> ```\n> makes it less confusing.\n\nnty :)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$5_eY-LLHUrHmXehk_SpShMowAhGgdHiYngkHV4OZQFI?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@iain:mozilla.org\">@iain:mozilla.org</a><br><p>I point to the parallel of namespace blocks in C++, where indenting them like:</p>\n<pre><code>unsafe {\n\nlet doWork = ...\n\n}\n</code></pre>\n<p>makes it less confusing.</p>\n</blockquote></mx-reply>nty :)","m.mentions":{"user_ids":["@iain:mozilla.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$5_eY-LLHUrHmXehk_SpShMowAhGgdHiYngkHV4OZQFI"}},"msgtype":"m.text"},"ts":1719963744330,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zYea79T5mrgP34K551EuySMzrkitX7O05xW1PUlzty8"},
{"content":{"body":"I maintain that C++ `namespace`-like indentation is a terrible aesthetic that we should not go out of our way to replicate.","format":"org.matrix.custom.html","formatted_body":"I maintain that C++ <code>namespace</code>-like indentation is a terrible aesthetic that we should not go out of our way to replicate.","m.mentions":{},"msgtype":"m.text"},"ts":1719963797028,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BZzvo_IS5YKEFuebGecyd3mkYXlLmt_XRH1tJSWegQs"},
{"content":{"body":"there is the worse-is-worse alternative of `\"use unsafe\"` which doesn't imply anything about scoping","format":"org.matrix.custom.html","formatted_body":"there is the worse-is-worse alternative of <code>\"use unsafe\"</code> which doesn't imply anything about scoping","m.mentions":{},"msgtype":"m.text"},"ts":1719963834732,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6YpF6pxlGNsfhQotTsJ69ZqCftVGjPVF8ah9988KLto"},
{"content":{"body":"however, i find directives bad precisely because of that","m.mentions":{},"msgtype":"m.text"},"ts":1719963847686,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$urNCKAlE7FfMtCT4r7UohFFLPDyZbwMxDSahtmXm3cI"},
{"content":{"body":"All this now makes me realize something. What is the compatibility story of shared structs (and I suppose unsafe functions in the future) with Proxy. I don't think that we should prevent constructing a proxy with such a target, but I also assume a proxy trap implementation wouldn't be exempted from unsafe checks when accessing the target, even if the trap was triggered from an unsafe block. Is the only option that proxy traps be updated to become unsafe themselves? Is there a way to dynamically test whether an object has an unsafe color?","msgtype":"m.text"},"ts":1719963867503,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$zVJZV4t8uf6wot-AHW1p0Pz45TZr3u-eUdUuOgHMJmM"},
{"content":{"body":"there is no function coloring","m.mentions":{},"msgtype":"m.text"},"ts":1719963885296,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$a3zopolZgKH_YBIJRMnp8UPCnCf66su7oceSCkZUBMI"},
{"content":{"body":"proxies just work?","m.mentions":{},"msgtype":"m.text"},"ts":1719963890457,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$TEBQ-RHYIBgLfN4VRWTYihsBeXBEn-VHlNc5E4EOX8U"},
{"content":{"body":"No, they wouldn't.","m.mentions":{},"msgtype":"m.text"},"ts":1719963906726,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ne0OkHJxIu101myRhv5u2kXFLVHRn8bVIO8F8FKdfz8"},
{"content":{"body":"why wouldn't proxies just work?","m.mentions":{},"msgtype":"m.text"},"ts":1719963920256,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$63U6EAiCqUYNX6QIXBMWesdElvIOLZdZLdMRmTBOokA"},
{"content":{"body":"You need to have an unsafe block inside the proxy trap, don't you?","m.mentions":{},"msgtype":"m.text"},"ts":1719963938064,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$baf9LSju9CkSFo1DNlOko5mAA0T6JHkHaoOKvLLLqAo"},
{"content":{"body":"They would work as long as you don't have a proxy trap for `get` or `set`","format":"org.matrix.custom.html","formatted_body":"They would work as long as you don't have a proxy trap for <code>get</code> or <code>set</code>","m.mentions":{},"msgtype":"m.text"},"ts":1719963948429,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$r295qJbJxhQNi_CHriFnZKKJst1uQaOAOBEabWGpKyM"},
{"content":{"body":"But I don't imagine that `unsafe` magically carries through to proxies via the `get` and `set` traps.","format":"org.matrix.custom.html","formatted_body":"But I don't imagine that <code>unsafe</code> magically carries through to proxies via the <code>get</code> and <code>set</code> traps.","m.mentions":{},"msgtype":"m.text"},"ts":1719963981580,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mML7fGJA0RjXS3BMlqbFm-8ujnpev4xUuKAWX2uLQx8"},
{"content":{"body":"sorry, that's what i mean. proxies \"just compose\", unless there's interposed user code like a trap","m.mentions":{},"msgtype":"m.text"},"ts":1719963994366,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$CRo5_I9yiDKhb1ODrSasCaI0SiuQnPSA14H4yvcc5ds"},
{"content":{"body":"Also would the Reflect intrinsics be \"forwarding\" the unsafe environment? Aka throw if not called from an unsafe block when bottoming out in accessing an unsafe receiver?","msgtype":"m.text"},"ts":1719964001362,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$gfNlnMXU-h4dZUgoG9fYZJAeiYuDGsGaetP2AUR3WaU"},
{"content":{"body":"in which case, exactly as ron says, they'd need their own `unsafe { }` marker","format":"org.matrix.custom.html","formatted_body":"in which case, exactly as ron says, they'd need their own <code>unsafe { }</code> marker","m.mentions":{},"msgtype":"m.text"},"ts":1719964003204,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$rdSU2D_HgS92B6Y1D93uIgnZIBY8QnlI3lbylzJVwCc"},
{"content":{"body":"it works exactly like strict mode throwing","m.mentions":{},"msgtype":"m.text"},"ts":1719964018673,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ix1eNn_MbnLNYM83TfDLjbvVR7y8BIGPvmnKyTV7XfE"},
{"content":{"body":"If you have a shared struct `s` and you need an `unsafe` block to read `s.x`, then `new Proxy(s, { get(target, key, receiver) { return Reflect.get(target, key, receiver); } }).x` would through because neither the `get` trap nor `Reflect.get` can read/write the struct's fields.","format":"org.matrix.custom.html","formatted_body":"If you have a shared struct <code>s</code> and you need an <code>unsafe</code> block to read <code>s.x</code>, then <code>new Proxy(s, { get(target, key, receiver) { return Reflect.get(target, key, receiver); } }).x</code> would through because neither the <code>get</code> trap nor <code>Reflect.get</code> can read/write the struct's fields.","m.mentions":{},"msgtype":"m.text"},"ts":1719964062701,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8gBcg20cBYwPugWi6Zo_YVO2snUGNc1y2_IK0pkRr3o"},
{"content":{"body":" * If you have a shared struct `s` and you need an `unsafe` block to read `s.x`, then `new Proxy(s, { get(target, key, receiver) { return Reflect.get(target, key, receiver); } }).x` would throw because neither the `get` trap nor `Reflect.get` can read/write the struct's fields.","format":"org.matrix.custom.html","formatted_body":" * If you have a shared struct <code>s</code> and you need an <code>unsafe</code> block to read <code>s.x</code>, then <code>new Proxy(s, { get(target, key, receiver) { return Reflect.get(target, key, receiver); } }).x</code> would throw because neither the <code>get</code> trap nor <code>Reflect.get</code> can read/write the struct's fields.","m.mentions":{},"m.new_content":{"body":"If you have a shared struct `s` and you need an `unsafe` block to read `s.x`, then `new Proxy(s, { get(target, key, receiver) { return Reflect.get(target, key, receiver); } }).x` would throw because neither the `get` trap nor `Reflect.get` can read/write the struct's fields.","format":"org.matrix.custom.html","formatted_body":"If you have a shared struct <code>s</code> and you need an <code>unsafe</code> block to read <code>s.x</code>, then <code>new Proxy(s, { get(target, key, receiver) { return Reflect.get(target, key, receiver); } }).x</code> would throw because neither the <code>get</code> trap nor <code>Reflect.get</code> can read/write the struct's fields.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$8gBcg20cBYwPugWi6Zo_YVO2snUGNc1y2_IK0pkRr3o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719964090572,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$O8CxsrMHZ_cuyxZcVgbQR9jIy_kkRP8fzKlgNx60ioE"},
{"content":{"body":"* I do find interesting the proposition that the user could define unsafe functions that like shared struct fields do need to be called from an unsafe context. As mentioned that seems to point we could for now reserve that space in the syntax for later ","m.new_content":{"body":"I do find interesting the proposition that the user could define unsafe functions that like shared struct fields do need to be called from an unsafe context. As mentioned that seems to point we could for now reserve that space in the syntax for later ","msgtype":"m.text"},"m.relates_to":{"event_id":"$_ns7ng8NwZrXu48Yi1EdWVjitJGoX1s-nl2DhaFMqcw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1719964163588,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$PUR_0M8LzdfnQZXbToVRMwcit5ab_RjytYqdFnXMtc8"},
{"content":{"body":"e.g., we might need a `Reflect.unsafeGet` and a `{ unsafeGet }` trap, or we'd need to be able to pass `unsafe` as a flag to the trap/Reflect.get","format":"org.matrix.custom.html","formatted_body":"e.g., we might need a <code>Reflect.unsafeGet</code> and a <code>{ unsafeGet }</code> trap, or we'd need to be able to pass <code>unsafe</code> as a flag to the trap/Reflect.get","m.mentions":{},"msgtype":"m.text"},"ts":1719964164846,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$J1-ro6YHRNC_FtqLNhw329yESdGFqdiQLtO-q1yu2F0"},
{"content":{"body":"Would you want `Reflect.get(s, \"x\")` to work outside of an `unsafe` context?","format":"org.matrix.custom.html","formatted_body":"Would you want <code>Reflect.get(s, \"x\")</code> to work outside of an <code>unsafe</code> context?","m.mentions":{},"msgtype":"m.text"},"ts":1719964231048,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JtE-OGAdMUj684ov_VGzFyCYYpSipXhleeKT3_YhTHg"},
{"content":{"body":"> <@shuyuguo:matrix.org> runtime enforcement of colored functions like that is probably a no-go\n\nHow is calling different from field access? Doesn't the receiver need to perform some check in both cases?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$FWgIFRGd69D7OLPKsuIy_AEwXpGmcS6R9p78JAVnNDU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br />runtime enforcement of colored functions like that is probably a no-go</blockquote></mx-reply>How is calling different from field access? Doesn't the receiver need to perform some check in both cases?","m.relates_to":{"m.in_reply_to":{"event_id":"$FWgIFRGd69D7OLPKsuIy_AEwXpGmcS6R9p78JAVnNDU"}},"msgtype":"m.text"},"ts":1719964276916,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Bju7GUh3Mnw0cfJkoWP14ttGE28IWIcAU94SNLHd-64"},
{"content":{"body":"i feel like it really shouldn't?","m.mentions":{},"msgtype":"m.text"},"ts":1719964277715,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$3zNg1TewOORW-_UI44yt4w0i3_V5s9hK_i_eOpY2Zzk"},
{"content":{"body":"`\"use strict\"` applies mostly to `set`, and informs how to react to the boolean return value of `Reflect.set()` or the `set` trap. It doesn't impact the `get` trap at all. ","format":"org.matrix.custom.html","formatted_body":"<code>\"use strict\"</code> applies mostly to <code>set</code>, and informs how to react to the boolean return value of <code>Reflect.set()</code> or the <code>set</code> trap. It doesn't impact the <code>get</code> trap at all.","m.mentions":{},"msgtype":"m.text"},"ts":1719964281331,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XcZDbOAWEBIYAdGjUN_6UHFyBwSgCzkoovbRb6SJ4DM"},
{"content":{"body":"> <@mhofman:matrix.org> How is calling different from field access? Doesn't the receiver need to perform some check in both cases?\n\nit's different in that Ron's sketch is completely lexical, so all property access lexically contained with `unsafe { }` can generate a different bytecode at parse time. there is no propagation from from frame to frame","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Bju7GUh3Mnw0cfJkoWP14ttGE28IWIcAU94SNLHd-64?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>How is calling different from field access? Doesn't the receiver need to perform some check in both cases?</blockquote></mx-reply>it's different in that Ron's sketch is completely lexical, so all property access lexically contained with <code>unsafe { }</code> can generate a different bytecode at parse time. there is no propagation from from frame to frame","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Bju7GUh3Mnw0cfJkoWP14ttGE28IWIcAU94SNLHd-64"}},"msgtype":"m.text"},"ts":1719964334849,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$2S6edFwbTkStDptfqpaaOOSea3944sWHC5S-MfOa5_M"},
{"content":{"body":"We won't need an `unsafe` block to use `Atomics.load(s, \"x\")`, since that already has implications around memory order. I'm not sure where I stand on whether `Reflect.get` observes `unsafe` ","format":"org.matrix.custom.html","formatted_body":"We won't need an <code>unsafe</code> block to use <code>Atomics.load(s, \"x\")</code>, since that already has implications around memory order. I'm not sure where I stand on whether <code>Reflect.get</code> observes <code>unsafe</code>","m.mentions":{},"msgtype":"m.text"},"ts":1719964351827,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$u00ymLxJ6w-aGFUPKI9maaHNX03VMXCGpYOL2Fa5cKA"},
{"content":{"body":"My design sketch is more loosely based on C#'s interpretation of `unsafe` than Rust's in that C# doesn't require `unsafe` functions be invoked from within an `unsafe` block, while Rust does.","format":"org.matrix.custom.html","formatted_body":"My design sketch is more loosely based on C#'s interpretation of <code>unsafe</code> than Rust's in that C# doesn't require <code>unsafe</code> functions be invoked from within an <code>unsafe</code> block, while Rust does.","m.mentions":{},"msgtype":"m.text"},"ts":1719964418771,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ESSDJ3fy61ahtL8uBzWKbQfBuVRv7RueJjhsGs-6AAQ"},
{"content":{"body":"> <@rbuckton:matrix.org> We won't need an `unsafe` block to use `Atomics.load(s, \"x\")`, since that already has implications around memory order. I'm not sure where I stand on whether `Reflect.get` observes `unsafe`\n\ni'm not sure mark would agree to that, actually. while it's true `Atomics.load` can't exhibit a *data* race, it can still exhibit races. so if mark's desired guarantee is \"no non-deterministic races arising from shared memory at all\", then it should also require `unsafe`. otherwise it can be outside of `unsafe`","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$u00ymLxJ6w-aGFUPKI9maaHNX03VMXCGpYOL2Fa5cKA?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>We won't need an <code>unsafe</code> block to use <code>Atomics.load(s, \"x\")</code>, since that already has implications around memory order. I'm not sure where I stand on whether <code>Reflect.get</code> observes <code>unsafe</code></blockquote></mx-reply>i'm not sure mark would agree to that, actually. while it's true <code>Atomics.load</code> can't exhibit a <em>data</em> race, it can still exhibit races. so if mark's desired guarantee is \"no non-deterministic races arising from shared memory at all\", then it should also require <code>unsafe</code>. otherwise it can be outside of <code>unsafe</code>","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$u00ymLxJ6w-aGFUPKI9maaHNX03VMXCGpYOL2Fa5cKA"}},"msgtype":"m.text"},"ts":1719964449256,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$3aBP0G20eiWlPTRRfPrH2HKUIHKE4dMNNNC92C_79Qg"},
{"content":{"body":"While I'm agnostic about the value of function colouring, I don't see why you can't generate different bytecode for calls in the same way you do for property access.","m.mentions":{},"msgtype":"m.text"},"ts":1719964452914,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$-6hruN8z_QWU-ghW2HvyZUoLFjKcrnOS2CYHS9JfAr8"},
{"content":{"body":"It is definitely unfortunate that it would require calls to perform an extra check in safe contexts (aka normal code that isn't touching any of this stuff), but it seems technically feasible to enforce.","m.mentions":{},"msgtype":"m.text"},"ts":1719964519885,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$Ny1bwGI5ZjtuTVZ1kc0Albk97lKeYa2kLM6MG6YhJiI"},
{"content":{"body":"> <@iain:mozilla.org> While I'm agnostic about the value of function colouring, I don't see why you can't generate different bytecode for calls in the same way you do for property access.\n\ni guess i don't know how the unsafe propagation works. if i have `unsafe { safeFunction(); } function safeFunction() { unsafeFunction(); } unsafe unsafeFunction() { ... }`, does that work or does that throw?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$-6hruN8z_QWU-ghW2HvyZUoLFjKcrnOS2CYHS9JfAr8?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@iain:mozilla.org\">@iain:mozilla.org</a><br>While I&#39;m agnostic about the value of function colouring, I don&#39;t see why you can&#39;t generate different bytecode for calls in the same way you do for property access.</blockquote></mx-reply>i guess i don't know how the unsafe propagation works. if i have <code>unsafe { safeFunction(); } function safeFunction() { unsafeFunction(); } unsafe unsafeFunction() { ... }</code>, does that work or does that throw?","m.mentions":{"user_ids":["@iain:mozilla.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$-6hruN8z_QWU-ghW2HvyZUoLFjKcrnOS2CYHS9JfAr8"}},"msgtype":"m.text"},"ts":1719964546878,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$rWxraOHsfWN9DVTvK7nwAG_7EcSlYTyoLtXVwwsGBB0"},
{"content":{"body":"> <@shuyuguo:matrix.org> it's different in that Ron's sketch is completely lexical, so all property access lexically contained with `unsafe { }` can generate a different bytecode at parse time. there is no propagation from from frame to frame\n\nCan't you generate a different byte code for unsafeCall? An unsafe function would throw on regular call. A safe function would accept both call and unsafeCall","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$2S6edFwbTkStDptfqpaaOOSea3944sWHC5S-MfOa5_M?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br />it's different in that Ron's sketch is completely lexical, so all property access lexically contained with <code>unsafe { }</code> can generate a different bytecode at parse time. there is no propagation from from frame to frame</blockquote></mx-reply>Can't you generate a different byte code for unsafeCall? An unsafe function would throw on regular call. A safe function would accept both call and unsafeCall","m.relates_to":{"m.in_reply_to":{"event_id":"$2S6edFwbTkStDptfqpaaOOSea3944sWHC5S-MfOa5_M"}},"msgtype":"m.text"},"ts":1719964551703,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$qnsW8aXURG47NKBgulKS1mMOlWc86xDl5d39jAtRwPY"},
{"content":{"body":"That throws for the same reason as anything else","m.mentions":{},"msgtype":"m.text"},"ts":1719964587051,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$eWp795-pE2d_PwghwY-4LyU_uTXM_bs4GvscheC3kRk"},
{"content":{"body":"okay, then yes, we can also generate a different bytecode","m.mentions":{},"msgtype":"m.text"},"ts":1719964600547,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$wZ0edvYSE-p-HMNG1kja8dpXCaQzVI-bUKoOtcUeOXs"},
{"content":{"body":"and then it comes down to do we really want another function color","m.mentions":{},"msgtype":"m.text"},"ts":1719964607395,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$89EIVbs9so2NPWKNXBTeLDPQs5UM6HYn_t9-tn00OH4"},
{"content":{"body":"> <@shuyuguo:matrix.org> i'm not sure mark would agree to that, actually. while it's true `Atomics.load` can't exhibit a *data* race, it can still exhibit races. so if mark's desired guarantee is \"no non-deterministic races arising from shared memory at all\", then it should also require `unsafe`. otherwise it can be outside of `unsafe`\n\nI don't see a way to have `Atomics.load` be aware of `unsafe` unless we start treating it like we do direct vs. indirect eval? Otherwise we essentially *would* have function coloring, but only for `Atomics` methods and only when they receive a `shared struct` argument.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$3aBP0G20eiWlPTRRfPrH2HKUIHKE4dMNNNC92C_79Qg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>i'm not sure mark would agree to that, actually. while it's true <code>Atomics.load</code> can't exhibit a <em>data</em> race, it can still exhibit races. so if mark's desired guarantee is \"no non-deterministic races arising from shared memory at all\", then it should also require <code>unsafe</code>. otherwise it can be outside of <code>unsafe</code></blockquote></mx-reply>I don't see a way to have <code>Atomics.load</code> be aware of <code>unsafe</code> unless we start treating it like we do direct vs. indirect eval? Otherwise we essentially <em>would</em> have function coloring, but only for <code>Atomics</code> methods and only when they receive a <code>shared struct</code> argument.","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$3aBP0G20eiWlPTRRfPrH2HKUIHKE4dMNNNC92C_79Qg"}},"msgtype":"m.text"},"ts":1719964631981,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$g_4vRCirmWDJEfH0VSIoMlSAjzI_TUxHt43gbbLbY5M"},
{"content":{"body":"good point. for Atomics.load to require `unsafe` would require an `UnsafeCall` internal bytecode as we've been discussing","format":"org.matrix.custom.html","formatted_body":"good point. for Atomics.load to require <code>unsafe</code> would require an <code>UnsafeCall</code> internal bytecode as we've been discussing","m.mentions":{},"msgtype":"m.text"},"ts":1719964709886,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$2JwIRJY85vmpbMUI_VLNAQ0YXMFW3Ck6rqME2wr9m8w"},
{"content":{"body":"So would it be better to special case function coloring purely for the `Atomics` methods, or just make it a more general mechanism? ","format":"org.matrix.custom.html","formatted_body":"So would it be better to special case function coloring purely for the <code>Atomics</code> methods, or just make it a more general mechanism?","m.mentions":{},"msgtype":"m.text"},"ts":1719964727089,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DjILV6X0RsvRKONRajueHdkVF7Txs8HsofjG_1uoXus"},
{"content":{"body":"but that'll be an implementation detail, and is orthogonal to whether we expose that coloring to user code","m.mentions":{},"msgtype":"m.text"},"ts":1719964737860,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$f1VREsrHqbFpuENt5U1149fydpI_B5BNTmT-bj0YNKo"},
{"content":{"body":"I don't see any backwards-compatible way to make Atomics methods usefully unsafe","m.mentions":{},"msgtype":"m.text"},"ts":1719964757349,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$U1aebYZkQWrRVNJD41c88gDw718Io6bBI7PeFfa0cTc"},
{"content":{"body":"well, Atomics currently don't work on field names, only TAs and indices","m.mentions":{},"msgtype":"m.text"},"ts":1719964776783,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$uXLtg_9dNsjI8XnY8GjfQJtbydNKkGoh_gx9D3qbWik"},
{"content":{"body":"that will remain usable everywhere","m.mentions":{},"msgtype":"m.text"},"ts":1719964782696,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$rwgffZCv7tnb2AXhHywsihybjClWf5w9cTd8AYpDUVc"},
{"content":{"body":"and there will be magic to make the new forms throw outside of `unsafe`","format":"org.matrix.custom.html","formatted_body":"and there will be magic to make the new forms throw outside of <code>unsafe</code>","m.mentions":{},"msgtype":"m.text"},"ts":1719964789756,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$RrK0oA-6PmK8USZOABA5o8BqqJ7ns-npvGzzoOw0QVg"}
]