[
{"content":{"body":"I think I caught up on the discussion.\n1. I strongly hold that existing Reflect & co APIs should not work on writable shared structs fields in non unsafe blocks.\n  a. I understand this may break existing code that blindly try to access objects, but technically this is already a possibility with exotic objects, and I really don't want to see us modify the shape of property descriptors.\n  b. It may be acceptable for some new dedicated Reflect APIs to access writable shared struct fields in non unsafe block, but I like the idea that \"unsafe\" access requires new syntax. It'd be a much more consistent model for audits.\n2. I believe that existing Reflect & co APIs should work on shared struct fields inside unsafe blocks. This is especially true if we don't have new dedicated unsafe APIs\n3. At first I didn't like `function.unsafe` as it felt like a form of dynamic scoping, but I am now warming up to it. As explained it is similar to `new.target`: the unsafe block changes the semantics of the call, like `new` would, and as the callee you get to sense the semantic change through some new piece of syntax.\n  a. Unlike construct, I don't think we need `Reflect.unsafeCall`/`Reflect.unsafeContruct` and the corresponding proxy traps as long as the existing call/construct traps get to sense through `function.unsafe`, so they can use an unsafe block to trigger the change of semantics on the target.\n4. `unsafe function () { ... }` would effectively be the equivalent of `function () { if (!function.unsafe) throw TypeError(); unsafe { ... } }`\n5. I like the idea of non-writable properties of shared structs being safe to access anywhere, but since the change from writable to non-writable is intrinsically dynamic, we have to consider whether we might opening too wide a door for authors to shoot themselves in the foot: since the access may not be audited as unsafe, they might not realize that there could be a race with the freezing of the property.\n  a. even if the property becomes non-writable at init, given that you can share the struct before init completes, it is still a dynamic state change","format":"org.matrix.custom.html","formatted_body":"<p>I think I caught up on the discussion.</p>\n<ol>\n<li>I strongly hold that existing Reflect &amp; co APIs should not work on writable shared structs fields in non unsafe blocks.<br>a. I understand this may break existing code that blindly try to access objects, but technically this is already a possibility with exotic objects, and I really don't want to see us modify the shape of property descriptors.<br>b. It may be acceptable for some new dedicated Reflect APIs to access writable shared struct fields in non unsafe block, but I like the idea that \"unsafe\" access requires new syntax. It'd be a much more consistent model for audits.</li>\n<li>I believe that existing Reflect &amp; co APIs should work on shared struct fields inside unsafe blocks. This is especially true if we don't have new dedicated unsafe APIs</li>\n<li>At first I didn't like <code>function.unsafe</code> as it felt like a form of dynamic scoping, but I am now warming up to it. As explained it is similar to <code>new.target</code>: the unsafe block changes the semantics of the call, like <code>new</code> would, and as the callee you get to sense the semantic change through some new piece of syntax.<br>a. Unlike construct, I don't think we need <code>Reflect.unsafeCall</code>/<code>Reflect.unsafeContruct</code> and the corresponding proxy traps as long as the existing call/construct traps get to sense through <code>function.unsafe</code>, so they can use an unsafe block to trigger the change of semantics on the target.</li>\n<li><code>unsafe function () { ... }</code> would effectively be the equivalent of <code>function () { if (!function.unsafe) throw TypeError(); unsafe { ... } }</code></li>\n<li>I like the idea of non-writable properties of shared structs being safe to access anywhere, but since the change from writable to non-writable is intrinsically dynamic, we have to consider whether we might opening too wide a door for authors to shoot themselves in the foot: since the access may not be audited as unsafe, they might not realize that there could be a race with the freezing of the property.<br>a. even if the property becomes non-writable at init, given that you can share the struct before init completes, it is still a dynamic state change</li>\n</ol>\n","m.mentions":{},"msgtype":"m.text"},"ts":1721022002807,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ljRHtiLhTduAwRaDnwCQ69hk6xunv9RpZFHlwBc-QVM"}
]