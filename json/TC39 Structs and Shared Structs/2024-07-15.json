[
{"content":{"body":"I think I caught up on the discussion.\n1. I strongly hold that existing Reflect & co APIs should not work on writable shared structs fields in non unsafe blocks.\n  a. I understand this may break existing code that blindly try to access objects, but technically this is already a possibility with exotic objects, and I really don't want to see us modify the shape of property descriptors.\n  b. It may be acceptable for some new dedicated Reflect APIs to access writable shared struct fields in non unsafe block, but I like the idea that \"unsafe\" access requires new syntax. It'd be a much more consistent model for audits.\n2. I believe that existing Reflect & co APIs should work on shared struct fields inside unsafe blocks. This is especially true if we don't have new dedicated unsafe APIs\n3. At first I didn't like `function.unsafe` as it felt like a form of dynamic scoping, but I am now warming up to it. As explained it is similar to `new.target`: the unsafe block changes the semantics of the call, like `new` would, and as the callee you get to sense the semantic change through some new piece of syntax.\n  a. Unlike construct, I don't think we need `Reflect.unsafeCall`/`Reflect.unsafeContruct` and the corresponding proxy traps as long as the existing call/construct traps get to sense through `function.unsafe`, so they can use an unsafe block to trigger the change of semantics on the target.\n4. `unsafe function () { ... }` would effectively be the equivalent of `function () { if (!function.unsafe) throw TypeError(); unsafe { ... } }`\n5. I like the idea of non-writable properties of shared structs being safe to access anywhere, but since the change from writable to non-writable is intrinsically dynamic, we have to consider whether we might opening too wide a door for authors to shoot themselves in the foot: since the access may not be audited as unsafe, they might not realize that there could be a race with the freezing of the property.\n  a. even if the property becomes non-writable at init, given that you can share the struct before init completes, it is still a dynamic state change","format":"org.matrix.custom.html","formatted_body":"<p>I think I caught up on the discussion.</p>\n<ol>\n<li>I strongly hold that existing Reflect &amp; co APIs should not work on writable shared structs fields in non unsafe blocks.<br>a. I understand this may break existing code that blindly try to access objects, but technically this is already a possibility with exotic objects, and I really don't want to see us modify the shape of property descriptors.<br>b. It may be acceptable for some new dedicated Reflect APIs to access writable shared struct fields in non unsafe block, but I like the idea that \"unsafe\" access requires new syntax. It'd be a much more consistent model for audits.</li>\n<li>I believe that existing Reflect &amp; co APIs should work on shared struct fields inside unsafe blocks. This is especially true if we don't have new dedicated unsafe APIs</li>\n<li>At first I didn't like <code>function.unsafe</code> as it felt like a form of dynamic scoping, but I am now warming up to it. As explained it is similar to <code>new.target</code>: the unsafe block changes the semantics of the call, like <code>new</code> would, and as the callee you get to sense the semantic change through some new piece of syntax.<br>a. Unlike construct, I don't think we need <code>Reflect.unsafeCall</code>/<code>Reflect.unsafeContruct</code> and the corresponding proxy traps as long as the existing call/construct traps get to sense through <code>function.unsafe</code>, so they can use an unsafe block to trigger the change of semantics on the target.</li>\n<li><code>unsafe function () { ... }</code> would effectively be the equivalent of <code>function () { if (!function.unsafe) throw TypeError(); unsafe { ... } }</code></li>\n<li>I like the idea of non-writable properties of shared structs being safe to access anywhere, but since the change from writable to non-writable is intrinsically dynamic, we have to consider whether we might opening too wide a door for authors to shoot themselves in the foot: since the access may not be audited as unsafe, they might not realize that there could be a race with the freezing of the property.<br>a. even if the property becomes non-writable at init, given that you can share the struct before init completes, it is still a dynamic state change</li>\n</ol>\n","m.mentions":{},"msgtype":"m.text"},"ts":1721022002807,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ljRHtiLhTduAwRaDnwCQ69hk6xunv9RpZFHlwBc-QVM"},
{"content":{"body":"(5) is a non-starter","m.mentions":{},"msgtype":"m.text"},"ts":1721035018646,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$KZht699KtCpNK1tSjFk2_Ovzf-gRw1krvg0Qf12NN8M"},
{"content":{"body":"there is no change from writable->non-writable for shared structs, because the invariant is shared structs have fixed shape","m.mentions":{},"msgtype":"m.text"},"ts":1721035040951,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$sDwcYcAw72PtJVqbM4aBRv_NSjyXYcC8bfwN6dUlbxY"},
{"content":{"body":"freezing the properties changes the shape, which requires synchronization, which means *all* accesses will need to become synchronized on the shape, which is too slow","format":"org.matrix.custom.html","formatted_body":"freezing the properties changes the shape, which requires synchronization, which means <em>all</em> accesses will need to become synchronized on the shape, which is too slow","m.mentions":{},"msgtype":"m.text"},"ts":1721035072200,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xkamqur6pO_daia9P5k__-S6LYWG2VM3ks9RvE9WylA"},
{"content":{"body":" * it's not possible to change from writable->non-writable for shared structs fields, because the invariant is shared structs have fixed shape","m.mentions":{},"m.new_content":{"body":"it's not possible to change from writable->non-writable for shared structs fields, because the invariant is shared structs have fixed shape","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$sDwcYcAw72PtJVqbM4aBRv_NSjyXYcC8bfwN6dUlbxY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721035087404,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$TfodKYBuWgev4tFWrBQ1g-_59OaVVRjlNlpd8VMT7Rc"},
{"content":{"body":"the only things i can imagine working is something like being able to freeze the properties before an instance escapes the local thread, but the precise form of that check is also too expensive to perform, so it'll be a conservative check like \"has this instance ever been assigned to another shared struct, or been postMessaged\"","m.mentions":{},"msgtype":"m.text"},"ts":1721035192461,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$SFMy-upJce3cRJz6IjyqfBH_OFVPoo8O24T7N9awVPY"},
{"content":{"body":"i am not sure how useful that is","m.mentions":{},"msgtype":"m.text"},"ts":1721035197598,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$e4_RvWfGg0VL_ZAcDidrFQ7N2e01rlXYN-CUZyqFHbI"},
{"content":{"body":"the more sensible thing is to declare fields as non-writable and create them non-writable","m.mentions":{},"msgtype":"m.text"},"ts":1721035225294,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zAkY1MvqcxTpVBoHf6LU-vKrJi5fJlIQZNVVv8fmBW4"},
{"content":{"body":"(5.a) is also not true, you cannot share a struct before init completes","m.mentions":{},"msgtype":"m.text"},"ts":1721035424329,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$SphIL_7c24P3A24POTDtsDOiCtvVq5nhq2h_DFM5Y-Q"},
{"content":{"body":"but it may be because we have different models of \"init\" here","m.mentions":{},"msgtype":"m.text"},"ts":1721035444961,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$EO4WecW0r4YDGV-7CC6q6XhxgWBr98N7ukZq53rj6Tc"},
{"content":{"body":"for the same reason of the shape itself being immutable, it won't be possible to do any freezing post-construction ","m.mentions":{},"msgtype":"m.text"},"ts":1721035482458,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cFo3VYKZ2fwRfvAHtiRuOvxxrtteP5AUcx7kFsCJHfk"},
{"content":{"body":"so the only way is to declare the shape up front to have some field _f_ be already frozen, and there would be some generated constructor that takes the initial value for _f_ such that by the time user code gets a constructed instance, it has the value for _f_ already. the user initializer won't be able to change the value of the field","format":"org.matrix.custom.html","formatted_body":"so the only way is to declare the shape up front to have some field <em>f</em> be already frozen, and there would be some generated constructor that takes the initial value for <em>f</em> such that by the time user code gets a constructed instance, it has the value for <em>f</em> already. the user initializer won't be able to change the value of the field","m.mentions":{},"msgtype":"m.text"},"ts":1721035549465,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$CVo6xhxMshAH0f8uiG6L_0KVRshjaXExvW3BxDOQXcQ"},
{"content":{"body":"i'd really like to defer declaration of frozen fields and to be a follow-on proposal if possible","m.mentions":{},"msgtype":"m.text"},"ts":1721035616735,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$psDUjAXAtLJ6AzRUQb_oz8yghHNNSgoGwYiPdpkrxOI"},
{"content":{"body":"My understanding of structs was that the object is constructed with a known set of fields with each a value of undefined, then the init step runs, which can set these fields to their value. ","msgtype":"m.text"},"ts":1721035689965,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$iFOM66kZehVBlWu1Mzj4G_oXVZARSQMi-awXsJczKMI"},
{"content":{"body":"> <@shuyuguo:matrix.org> freezing the properties changes the shape, which requires synchronization, which means *all* accesses will need to become synchronized on the shape, which is too slow\n\nactually i'll caveat this: it might not be too slow to have rel/acq accesses on the shape itself, but that opens up precisely the \"too wide a door\" issue you raised above","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$xkamqur6pO_daia9P5k__-S6LYWG2VM3ks9RvE9WylA?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>freezing the properties changes the shape, which requires synchronization, which means <em>all</em> accesses will need to become synchronized on the shape, which is too slow</blockquote></mx-reply>actually i'll caveat this: it might not be too slow to have rel/acq accesses on the shape itself, but that opens up precisely the \"too wide a door\" issue you raised above","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$xkamqur6pO_daia9P5k__-S6LYWG2VM3ks9RvE9WylA"}},"msgtype":"m.text"},"ts":1721035707127,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$hlKa-FmlPlpBex3F37r8R7ViqdtQ_uDeV9th9TmFb0Y"},
{"content":{"body":"> <@mhofman:matrix.org> My understanding of structs was that the object is constructed with a known set of fields with each a value of undefined, then the init step runs, which can set these fields to their value.\n\nright, there's no way to declare a field to be frozen right now. everything is mutable","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$iFOM66kZehVBlWu1Mzj4G_oXVZARSQMi-awXsJczKMI?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>My understanding of structs was that the object is constructed with a known set of fields with each a value of undefined, then the init step runs, which can set these fields to their value. </blockquote></mx-reply>right, there's no way to declare a field to be frozen right now. everything is mutable","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$iFOM66kZehVBlWu1Mzj4G_oXVZARSQMi-awXsJczKMI"}},"msgtype":"m.text"},"ts":1721035719105,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6UD2p_2OEi8G0XMNmledVdi3umaJEruY9etNRSfhESs"},
{"content":{"body":"so your (5) can't come up in the current proposal, is what i was explaining","m.mentions":{},"msgtype":"m.text"},"ts":1721035740217,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$hGRS1mvXKtFX1k5h9dRTsjb1-LIAV0G8p5O3DlG_FM0"},
{"content":{"body":"That init step could share or otherwise set the struct as a field of another struct, which means it can escape before all the init steps complete","msgtype":"m.text"},"ts":1721035741244,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$1GvEMMp1NbD3lErLfEnAgbKgXJNCEvMB6gBaVNS9Y68"},
{"content":{"body":"\"non-applicable\" would've been better than \"non-starter\"","m.mentions":{},"msgtype":"m.text"},"ts":1721035752745,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Va9UT2wHjeughDHD0KX_mGEfJl_cTMHtmkPL7_imZFk"},
{"content":{"body":"> <@mhofman:matrix.org> That init step could share or otherwise set the struct as a field of another struct, which means it can escape before all the init steps complete\n\nthat's right. but the initializer can't freeze, because you just can't freeze shared structs right now","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$1GvEMMp1NbD3lErLfEnAgbKgXJNCEvMB6gBaVNS9Y68?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>That init step could share or otherwise set the struct as a field of another struct, which means it can escape before all the init steps complete</blockquote></mx-reply>that's right. but the initializer can't freeze, because you just can't freeze shared structs right now","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$1GvEMMp1NbD3lErLfEnAgbKgXJNCEvMB6gBaVNS9Y68"}},"msgtype":"m.text"},"ts":1721035793027,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$p99TM3NY0AlG5o_pSFRuDoBI9Cm-7usdXQwPG9b_w7w"},
{"content":{"body":"Yeah I just don't see in this construction+init model how you could provide a value for a field before the instance is constructed, without reverting to the model classes have, aka have a dead zone before super is called.","msgtype":"m.text"},"ts":1721035988022,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$EiZiUdSZaDIq8NrYXLsTuqWVeJNXBWnuHD_rrEkHYPg"},
{"content":{"body":"oh it'd probably be some ugly thing","m.mentions":{},"msgtype":"m.text"},"ts":1721036056844,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$gILAjk70v0j4PM7L0rMdTnyT_i9uxkALYNwm4YYyK_U"},
{"content":{"body":"but yeah i haven't fully thought out how this would look","m.mentions":{},"msgtype":"m.text"},"ts":1721036115492,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LdEWTbaUUFIfjLwlLU-Y-2C17N2bC0PZq-EEzJ1CfKE"},
{"content":{"body":"you can imagine something like, the first argument to a shared struct constructor is always an \"initializer object\" whose fields get assigned to like-named fields on the shared struct, before the user initializer is called","m.mentions":{},"msgtype":"m.text"},"ts":1721036165970,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$SgoyM1Vd2POrzUWxMBnm6GoHH9VsyMqVP5T7EMCk2B0"},
{"content":{"body":"this is real ugly because if your user initializer takes arguments you'd always be doing `new MyStruct(undefined, myFirstArg, etc)`","format":"org.matrix.custom.html","formatted_body":"this is real ugly because if your user initializer takes arguments you'd always be doing <code>new MyStruct(undefined, myFirstArg, etc)</code>","m.mentions":{},"msgtype":"m.text"},"ts":1721036189377,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$3xd8KBfBQGbqDA80OaFeDqcp3qgHGrOu0D4kM7RnQDU"},
{"content":{"body":"Well I suppose only the base constructor needs that argument ","msgtype":"m.text"},"ts":1721036266160,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$4c9nL_ivrj62IZJldnFaj_TV-l8YNgwbfMD8JbfaP6c"},
{"content":{"body":"well, the subclasses need to pass it along somehow","m.mentions":{},"msgtype":"m.text"},"ts":1721036286427,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$31Xo-p52By7ikTEMQau0rnbZ5P7LViKuIRjwpXcHdNI"},
{"content":{"body":"Oh right. Ugh that's not ergonomic ","msgtype":"m.text"},"ts":1721036332000,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Cq0ey8QzVkPQmZhrn9UrkwME6xa54JggqxTnWdOqwzI"},
{"content":{"body":"nope, \"some ugly thing\"","m.mentions":{},"msgtype":"m.text"},"ts":1721036357919,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$QtdN6QcbrSH5_bQNJuKgAkXKXU326EUoKNlX2wbJPlw"},
{"content":{"body":"which is partly why i'd like to avoid speccing frozen-at-declaration fields initially","m.mentions":{},"msgtype":"m.text"},"ts":1721036383632,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Sfp6NARmtmLPeVCuSsgSwTTD5_2I-8PYlXMrbajGeuo"},
{"content":{"body":"Should probably think it through to make sure the init mechanism doesn't make that impossible in the future","msgtype":"m.text"},"ts":1721036468174,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$8-14hKumgvhn9W9yNYR-Xnz80bxOp0eR47-vzW07UWM"},
{"content":{"body":"The way we've been handling a similar problem currently is to have our \"init\" return the set of fields and not have access to the instance reference (which doesn't actually get created until after init runs)","msgtype":"m.text"},"ts":1721036620172,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$U6XJfas0AyoJzYZmHCFk5_LVhdkFc3R2BQjnxnFX02Y"},
{"content":{"body":"Then we have an optional \"finalize\" step which gets access to the populated instance and gets to perform any external wiring before the instance is returned to the caller","msgtype":"m.text"},"ts":1721036732005,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ONVtCV_Su54uzJU_gaX0Uy1bxb6VfIr773FHlz6Ab18"},
{"content":{"body":"We would really need C++-style initializer lists to do this kind of frozen property well, IMO","m.mentions":{},"msgtype":"m.text"},"ts":1721043125856,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$prYj0LEFFp0XPZCzQj8eeQlN7dncWypHTfPY3EbmAh0"},
{"content":{"body":"or, we could go back to Records and Tuples, but object-based -- the various ways of constructing them let you fill in contents without modifying existing things","m.mentions":{},"msgtype":"m.text"},"ts":1721043189445,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$sWYYPIqFojLZaBDO8NL6-e_tK9NSpSGSycXj_2uRmnw"},
{"content":{"body":"ES6 classes didn't really give us a great basis for initializer lists because of how the instance is constructed in the base class and then subsequent subclass constructors can just mutate it. This constrained the design of class fields a lot","m.mentions":{},"msgtype":"m.text"},"ts":1721043243163,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$-huNqpckmt2aQvswuhSi0I4MXTirvu--JTDZL76Ddbc"}
]