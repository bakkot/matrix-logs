[
{"content":{"body":"I think I caught up on the discussion.\n1. I strongly hold that existing Reflect & co APIs should not work on writable shared structs fields in non unsafe blocks.\n  a. I understand this may break existing code that blindly try to access objects, but technically this is already a possibility with exotic objects, and I really don't want to see us modify the shape of property descriptors.\n  b. It may be acceptable for some new dedicated Reflect APIs to access writable shared struct fields in non unsafe block, but I like the idea that \"unsafe\" access requires new syntax. It'd be a much more consistent model for audits.\n2. I believe that existing Reflect & co APIs should work on shared struct fields inside unsafe blocks. This is especially true if we don't have new dedicated unsafe APIs\n3. At first I didn't like `function.unsafe` as it felt like a form of dynamic scoping, but I am now warming up to it. As explained it is similar to `new.target`: the unsafe block changes the semantics of the call, like `new` would, and as the callee you get to sense the semantic change through some new piece of syntax.\n  a. Unlike construct, I don't think we need `Reflect.unsafeCall`/`Reflect.unsafeContruct` and the corresponding proxy traps as long as the existing call/construct traps get to sense through `function.unsafe`, so they can use an unsafe block to trigger the change of semantics on the target.\n4. `unsafe function () { ... }` would effectively be the equivalent of `function () { if (!function.unsafe) throw TypeError(); unsafe { ... } }`\n5. I like the idea of non-writable properties of shared structs being safe to access anywhere, but since the change from writable to non-writable is intrinsically dynamic, we have to consider whether we might opening too wide a door for authors to shoot themselves in the foot: since the access may not be audited as unsafe, they might not realize that there could be a race with the freezing of the property.\n  a. even if the property becomes non-writable at init, given that you can share the struct before init completes, it is still a dynamic state change","format":"org.matrix.custom.html","formatted_body":"<p>I think I caught up on the discussion.</p>\n<ol>\n<li>I strongly hold that existing Reflect &amp; co APIs should not work on writable shared structs fields in non unsafe blocks.<br>a. I understand this may break existing code that blindly try to access objects, but technically this is already a possibility with exotic objects, and I really don't want to see us modify the shape of property descriptors.<br>b. It may be acceptable for some new dedicated Reflect APIs to access writable shared struct fields in non unsafe block, but I like the idea that \"unsafe\" access requires new syntax. It'd be a much more consistent model for audits.</li>\n<li>I believe that existing Reflect &amp; co APIs should work on shared struct fields inside unsafe blocks. This is especially true if we don't have new dedicated unsafe APIs</li>\n<li>At first I didn't like <code>function.unsafe</code> as it felt like a form of dynamic scoping, but I am now warming up to it. As explained it is similar to <code>new.target</code>: the unsafe block changes the semantics of the call, like <code>new</code> would, and as the callee you get to sense the semantic change through some new piece of syntax.<br>a. Unlike construct, I don't think we need <code>Reflect.unsafeCall</code>/<code>Reflect.unsafeContruct</code> and the corresponding proxy traps as long as the existing call/construct traps get to sense through <code>function.unsafe</code>, so they can use an unsafe block to trigger the change of semantics on the target.</li>\n<li><code>unsafe function () { ... }</code> would effectively be the equivalent of <code>function () { if (!function.unsafe) throw TypeError(); unsafe { ... } }</code></li>\n<li>I like the idea of non-writable properties of shared structs being safe to access anywhere, but since the change from writable to non-writable is intrinsically dynamic, we have to consider whether we might opening too wide a door for authors to shoot themselves in the foot: since the access may not be audited as unsafe, they might not realize that there could be a race with the freezing of the property.<br>a. even if the property becomes non-writable at init, given that you can share the struct before init completes, it is still a dynamic state change</li>\n</ol>\n","m.mentions":{},"msgtype":"m.text"},"ts":1721022002807,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ljRHtiLhTduAwRaDnwCQ69hk6xunv9RpZFHlwBc-QVM"},
{"content":{"body":"(5) is a non-starter","m.mentions":{},"msgtype":"m.text"},"ts":1721035018646,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$KZht699KtCpNK1tSjFk2_Ovzf-gRw1krvg0Qf12NN8M"},
{"content":{"body":"there is no change from writable->non-writable for shared structs, because the invariant is shared structs have fixed shape","m.mentions":{},"msgtype":"m.text"},"ts":1721035040951,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$sDwcYcAw72PtJVqbM4aBRv_NSjyXYcC8bfwN6dUlbxY"},
{"content":{"body":"freezing the properties changes the shape, which requires synchronization, which means *all* accesses will need to become synchronized on the shape, which is too slow","format":"org.matrix.custom.html","formatted_body":"freezing the properties changes the shape, which requires synchronization, which means <em>all</em> accesses will need to become synchronized on the shape, which is too slow","m.mentions":{},"msgtype":"m.text"},"ts":1721035072200,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$xkamqur6pO_daia9P5k__-S6LYWG2VM3ks9RvE9WylA"},
{"content":{"body":" * it's not possible to change from writable->non-writable for shared structs fields, because the invariant is shared structs have fixed shape","m.mentions":{},"m.new_content":{"body":"it's not possible to change from writable->non-writable for shared structs fields, because the invariant is shared structs have fixed shape","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$sDwcYcAw72PtJVqbM4aBRv_NSjyXYcC8bfwN6dUlbxY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1721035087404,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$TfodKYBuWgev4tFWrBQ1g-_59OaVVRjlNlpd8VMT7Rc"},
{"content":{"body":"the only things i can imagine working is something like being able to freeze the properties before an instance escapes the local thread, but the precise form of that check is also too expensive to perform, so it'll be a conservative check like \"has this instance ever been assigned to another shared struct, or been postMessaged\"","m.mentions":{},"msgtype":"m.text"},"ts":1721035192461,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$SFMy-upJce3cRJz6IjyqfBH_OFVPoo8O24T7N9awVPY"},
{"content":{"body":"i am not sure how useful that is","m.mentions":{},"msgtype":"m.text"},"ts":1721035197598,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$e4_RvWfGg0VL_ZAcDidrFQ7N2e01rlXYN-CUZyqFHbI"},
{"content":{"body":"the more sensible thing is to declare fields as non-writable and create them non-writable","m.mentions":{},"msgtype":"m.text"},"ts":1721035225294,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zAkY1MvqcxTpVBoHf6LU-vKrJi5fJlIQZNVVv8fmBW4"},
{"content":{"body":"(5.a) is also not true, you cannot share a struct before init completes","m.mentions":{},"msgtype":"m.text"},"ts":1721035424329,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$SphIL_7c24P3A24POTDtsDOiCtvVq5nhq2h_DFM5Y-Q"},
{"content":{"body":"but it may be because we have different models of \"init\" here","m.mentions":{},"msgtype":"m.text"},"ts":1721035444961,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$EO4WecW0r4YDGV-7CC6q6XhxgWBr98N7ukZq53rj6Tc"},
{"content":{"body":"for the same reason of the shape itself being immutable, it won't be possible to do any freezing post-construction ","m.mentions":{},"msgtype":"m.text"},"ts":1721035482458,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cFo3VYKZ2fwRfvAHtiRuOvxxrtteP5AUcx7kFsCJHfk"}
]