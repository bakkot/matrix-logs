[
{"content":{"body":"(the magic from a spec perspective will be, like, look at the current parse node being evaluated, and then find the nearest enclosing block)","m.mentions":{},"msgtype":"m.text"},"ts":1719964819016,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$snbdJDI2ZD1La8BnUrwwhbrPqrU8NOif4TRSw9luH5E"},
{"content":{"body":"I don't necessarily think we *need* general purpose function coloring, though I do like the additional guardrail that provides. I'm primarily interested in just improving the DX of `function f() { unsafe {` and `function f(x, y = do unsafe { x.y })` since those feel very awkward ","format":"org.matrix.custom.html","formatted_body":"I don't necessarily think we <em>need</em> general purpose function coloring, though I do like the additional guardrail that provides. I'm primarily interested in just improving the DX of <code>function f() { unsafe {</code> and <code>function f(x, y = do unsafe { x.y })</code> since those feel very awkward","m.mentions":{},"msgtype":"m.text"},"ts":1719964838982,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Jt0fNh7DP-j39QcEJSdvBcI5zWGqZqenO5jvah-oCDg"},
{"content":{"body":"> <@shuyuguo:matrix.org> (the magic from a spec perspective will be, like, look at the current parse node being evaluated, and then find the nearest enclosing block)\n\nWouldn't we just look at the current lexical environment as part of Call?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$snbdJDI2ZD1La8BnUrwwhbrPqrU8NOif4TRSw9luH5E?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>(the magic from a spec perspective will be, like, look at the current parse node being evaluated, and then find the nearest enclosing block)</blockquote></mx-reply>Wouldn't we just look at the current lexical environment as part of Call?","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$snbdJDI2ZD1La8BnUrwwhbrPqrU8NOif4TRSw9luH5E"}},"msgtype":"m.text"},"ts":1719964889592,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xuo8HbZb097uLOUn9P9J37fM3utZCGsA2_rBNKep1bs"},
{"content":{"body":"To inform this intrinsics call coloring question, I think the `Reflect.get` case is interesting. Would you expect `unsafe { Reflect.get(sharedStruct, \"foo\") }` to work?","msgtype":"m.text"},"ts":1719964893867,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$FBiYq_aCj1y7p90eKTYqcToRZ6PN_BVuTYSy5Q-kFmQ"},
{"content":{"body":"> <@rbuckton:matrix.org> Wouldn't we just look at the current lexical environment as part of Call?\n\noh true, it'll always have one","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$xuo8HbZb097uLOUn9P9J37fM3utZCGsA2_rBNKep1bs?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Wouldn't we just look at the current lexical environment as part of Call?</blockquote></mx-reply>oh true, it'll always have one","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$xuo8HbZb097uLOUn9P9J37fM3utZCGsA2_rBNKep1bs"}},"msgtype":"m.text"},"ts":1719964906805,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$vRda3A58c-QfmD8aixgag-tbeMHxeJTlHheFv625iPc"},
{"content":{"body":"must be nice to have an implementation that never optimizes away scopes!","m.mentions":{},"msgtype":"m.text"},"ts":1719964928183,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$jyidz9220A3NkCOizp6Lg2-hofqmDY2v3q_z30RN9Go"},
{"content":{"body":"> <@mhofman:matrix.org> To inform this intrinsics call coloring question, I think the `Reflect.get` case is interesting. Would you expect `unsafe { Reflect.get(sharedStruct, \"foo\") }` to work?\n\nIIRC, C#'s `unsafe` (which is primarily for working directly with pointers) does not require `unsafe` to interact with pointers via reflection, but C#'s reflection is significantly different from JS's.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$FBiYq_aCj1y7p90eKTYqcToRZ6PN_BVuTYSy5Q-kFmQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>To inform this intrinsics call coloring question, I think the `Reflect.get` case is interesting. Would you expect `unsafe { Reflect.get(sharedStruct, &quot;foo&quot;) }` to work?</blockquote></mx-reply>IIRC, C#'s <code>unsafe</code> (which is primarily for working directly with pointers) does not require <code>unsafe</code> to interact with pointers via reflection, but C#'s reflection is significantly different from JS's.","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$FBiYq_aCj1y7p90eKTYqcToRZ6PN_BVuTYSy5Q-kFmQ"}},"msgtype":"m.text"},"ts":1719965052551,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tuAvMvnYYs3F8FSNTxDXfkim5LMcFHQy95XyhCOawyU"},
{"content":{"body":"If we did require `unsafe`, then `Reflect.get` et al would also need an UnsafeCall","format":"org.matrix.custom.html","formatted_body":"If we did require <code>unsafe</code>, then <code>Reflect.get</code> et al would also need an UnsafeCall","m.mentions":{},"msgtype":"m.text"},"ts":1719965107422,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DgHLURfnZX-uLD7BGarB7ZzqtM1VoWdN1-XbyDk1ZGc"},
{"content":{"body":"Good point. I would expect `Reflect.get` to throw if not in an unsafe context. ","msgtype":"m.text"},"ts":1719965136154,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$cuKS78drslYyajDZx_27hoxnc6IQTXHJyCq9XgYlH64"},
{"content":{"body":"But there would still be no carryover of `unsafe { proxyForS.x }` through a `get` trap, and just marking every proxy trap `unsafe` is dangerous.","format":"org.matrix.custom.html","formatted_body":"But there would still be no carryover of <code>unsafe { proxyForS.x }</code> through a <code>get</code> trap, and just marking every proxy trap <code>unsafe</code> is dangerous.","m.mentions":{},"msgtype":"m.text"},"ts":1719965206054,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2vc0kGM8dVxCiUJbIq0shkE7dG3N7PrjsoDt_OjE63A"},
{"content":{"body":"Which now means we need an unsafeCall trap for proxies if we expose this to user land. Ugh","msgtype":"m.text"},"ts":1719965224004,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$n-7xT1aQdA0_4wbX7Nt8dJ4X6PfZncKsVwMmVsyIT94"},
{"content":{"body":"hey man i'm also happy being laissez-faire with data races","m.mentions":{},"msgtype":"m.text"},"ts":1719965306484,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VGScb9IIlB2XdyLW3JQ02Schk6Z5ErjCU-_luXUFfk4"},
{"content":{"body":"We could instead have `new Proxy(s, { get(target, key, receiver, unsafe) { return Reflect.get(target, key, receiver, unsafe); } })` and traffic the caller's `unsafe`-ness around as a parameter.","format":"org.matrix.custom.html","formatted_body":"We could instead have <code>new Proxy(s, { get(target, key, receiver, unsafe) { return Reflect.get(target, key, receiver, unsafe); } })</code> and traffic the caller's <code>unsafe</code>-ness around as a parameter.","m.mentions":{},"msgtype":"m.text"},"ts":1719965313529,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xXm9u2PdPMUwLykTfCzPVYYq3SRAc3TpENIO2hlJPx0"},
{"content":{"body":"seems fine","m.mentions":{},"msgtype":"m.text"},"ts":1719965401293,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6pDAW59wGIqADuSGzzEluKaeRhtiQfcYwwg1G0qJXvw"},
{"content":{"body":"Seems not, that would effectively allow creating unsafe context without syntax","msgtype":"m.text"},"ts":1719965450188,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$DAkMZrjFxXwiLO0pTAN5IHQKyZ4IO36PaocNMW6LWXY"},
{"content":{"body":"maybe `unsafe` will be some unforgeable capability token?","format":"org.matrix.custom.html","formatted_body":"maybe <code>unsafe</code> will be some unforgeable capability token?","m.mentions":{},"msgtype":"m.text"},"ts":1719965524108,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LywMwS9JIm--P-MbbllSHqQYPK4LuvRg-ErCzwZplMY"},
{"content":{"body":"i guess we can't prevent it from being exfiltrated","m.mentions":{},"msgtype":"m.text"},"ts":1719965536300,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$-WoD4eIoSjYg5PQtk47G-pVNTBgZZ9arPjANKa0TY7U"},
{"content":{"body":"We either have all of this complexity, or we say:\n- no function coloring\n- `Atomics` methods are internally `unsafe` (so `Atomics.load(s, \"x\")` doesn't require an `unsafe` block)\n- `Reflect` methods are internally `unsafe` (so `Reflect.get(s, \"x\")` doesn't require an `unsafe` block)\n- The fact that a shared struct field is unsafe is carried through a proxy as we do other invariants in proxies, so you can't transparently make a Proxy \"safe\" if its fields are unsafe.","format":"org.matrix.custom.html","formatted_body":"<p>We either have all of this complexity, or we say:</p>\n<ul>\n<li>no function coloring</li>\n<li><code>Atomics</code> methods are internally <code>unsafe</code> (so <code>Atomics.load(s, \"x\")</code> doesn't require an <code>unsafe</code> block)</li>\n<li><code>Reflect</code> methods are internally <code>unsafe</code> (so <code>Reflect.get(s, \"x\")</code> doesn't require an <code>unsafe</code> block)</li>\n<li>The fact that a shared struct field is unsafe is carried through a proxy as we do other invariants in proxies, so you can't transparently make a Proxy \"safe\" if its fields are unsafe.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719965542375,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-9e5q0q9zJYtBlNKtxdJtGFBYUjgDRxLkRd3xpQDajs"},
{"content":{"body":"For the 4th bullet, that would mean `new Proxy(s, { get() { } }).x` would throw outside of an `unsafe` block without ever invoking the `get` trap","format":"org.matrix.custom.html","formatted_body":"For the 4th bullet, that would mean <code>new Proxy(s, { get() { } }).x</code> would throw outside of an <code>unsafe</code> block without ever invoking the <code>get</code> trap","m.mentions":{},"msgtype":"m.text"},"ts":1719965593750,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NoKSOZRCc8X5T7Lvkg1uC52CXC3--GcZehokpAl0E20"},
{"content":{"body":"i am definitely coming around to Atomics being internally unsafe, after what i said above","m.mentions":{},"msgtype":"m.text"},"ts":1719965594379,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$0Tnrf3LRkRQ_l-ADh2lR5hF5LxnHijS1XVhc7vRFMtg"},
{"content":{"body":"in fact that's basically all Atomics do, access shared memory","m.mentions":{},"msgtype":"m.text"},"ts":1719965601325,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$skna8FY8w5QhYu_sW1n4cRtFfr0OZUVJcchukn-oL_M"},
{"content":{"body":"so they have to be internally unsafe in a no function coloring world","m.mentions":{},"msgtype":"m.text"},"ts":1719965610011,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$lJItiCocXgKdaKfjlrQZFBh_kY1-k7H8NDvZbVMKDEU"},
{"content":{"body":"> <@shuyuguo:matrix.org> in fact that's basically all Atomics do, access shared memory\n\nAccess shared memory and _enforce sequential ordering of memory accesses_, which _is_ a coordination mechanism.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$skna8FY8w5QhYu_sW1n4cRtFfr0OZUVJcchukn-oL_M?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>in fact that&#39;s basically all Atomics do, access shared memory</blockquote></mx-reply>Access shared memory and <em>enforce sequential ordering of memory accesses</em>, which <em>is</em> a coordination mechanism.","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$skna8FY8w5QhYu_sW1n4cRtFfr0OZUVJcchukn-oL_M"}},"msgtype":"m.text"},"ts":1719965652281,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BAPGHAokuVBF4-A670cgCVXd-77StggCPQJVo4xPipA"},
{"content":{"body":"yes, fair","m.mentions":{},"msgtype":"m.text"},"ts":1719965660574,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Ybjv7VEnFbxtW7JN8GihCDIY0JKlG588YDGgqoB5j5c"},
{"content":{"body":"Maybe for atomics, but I'm a lot less comfortable for reflect","msgtype":"m.text"},"ts":1719965678548,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$gwHIPhE4CTuontZ3AuPwkz3xXqnyUI78xJDLpr0UuUM"},
{"content":{"body":"Atomics are grandfathered in, and it's not too bad to say \"grep for 'atomics' and 'unsafe' to audit\"","m.mentions":{},"msgtype":"m.text"},"ts":1719965715204,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$He7PXktmURSmr_PPHv8VLj3v2ZBPePvesO3CyXAG0dc"},
{"content":{"body":"Otherwise what's the purpose of all of the happens-before and all of the other ordering relations in https://tc39.es/ecma262/#sec-relations-of-candidate-executions","m.mentions":{},"msgtype":"m.text"},"ts":1719965718233,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rjb4KTwC4V-r6ujsnOTyTbVnFBTxOW2VVpJ604wW8Eo"},
{"content":{"body":"I agree that reflect is a harder case","m.mentions":{},"msgtype":"m.text"},"ts":1719965722704,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$tECw045fsOQH8nwoSQXSpcAdfbEKclxg8YdCs8FY0Rk"},
{"content":{"body":"it could also be that `Reflect` methods are not internally `unsafe`, so they just straight up don't work in any context on shared structs","format":"org.matrix.custom.html","formatted_body":"it could also be that <code>Reflect</code> methods are not internally <code>unsafe</code>, so they just straight up don't work in any context on shared structs","m.mentions":{},"msgtype":"m.text"},"ts":1719965764150,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$8sgJOzJ54nrrJilSoi7v134LKfvsfrpcora9fSyCFds"},
{"content":{"body":"*i* can live with that","format":"org.matrix.custom.html","formatted_body":"<em>i</em> can live with that","m.mentions":{},"msgtype":"m.text"},"ts":1719965770855,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VwMaRYF30lG73zfNfmchw7rIs1_JEuDdBfjXOpd4J-Y"},
{"content":{"body":"> <@iain:mozilla.org> Atomics are grandfathered in, and it's not too bad to say \"grep for 'atomics' and 'unsafe' to audit\"\n\nI'm not so sure I would characterize Atomics as \"grandfathered in\", given they are already a complex coordination mechanism.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$He7PXktmURSmr_PPHv8VLj3v2ZBPePvesO3CyXAG0dc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@iain:mozilla.org\">@iain:mozilla.org</a><br>Atomics are grandfathered in, and it&#39;s not too bad to say &quot;grep for &#39;atomics&#39; and &#39;unsafe&#39; to audit&quot;</blockquote></mx-reply>I'm not so sure I would characterize Atomics as \"grandfathered in\", given they are already a complex coordination mechanism.","m.mentions":{"user_ids":["@iain:mozilla.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$He7PXktmURSmr_PPHv8VLj3v2ZBPePvesO3CyXAG0dc"}},"msgtype":"m.text"},"ts":1719965777097,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$n3uBA_R3Q8ymwz38wN3YTMIbhPp25itSXb1W3cI86rM"},
{"content":{"body":"you then have to add `Reflect.unsafeGet` and `Reflect.unsafeSet` that are internally `unsafe`","format":"org.matrix.custom.html","formatted_body":"you then have to add <code>Reflect.unsafeGet</code> and <code>Reflect.unsafeSet</code> that are internally <code>unsafe</code>","m.mentions":{},"msgtype":"m.text"},"ts":1719965809259,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Le7r7IzAo8Xpb8ig3RuVrUkof0bHZR8USzrbKuGgwn8"},
{"content":{"body":"What I mean is that if you want to audit potential data races in your code, you have to look at your uses of Atomics, and we can't put that horse back in the barn","m.mentions":{},"msgtype":"m.text"},"ts":1719965813472,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$EjSr13b3gPFv2ZHYbeqUajSAQapet6TaCqS_aZPSRHo"},
{"content":{"body":"no, Atomics can never exhibit data races","m.mentions":{},"msgtype":"m.text"},"ts":1719965827898,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$UTlZHo6QTY0x4_sll1xlDtibe90saPo6097wGOTwZoY"},
{"content":{"body":"only normal races","m.mentions":{},"msgtype":"m.text"},"ts":1719965831398,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Q4G8i2mTNLGR8GMg9s73aIWvY3T6059WNMUd-AV6Q6A"},
{"content":{"body":"Sorry, yeah, that's what I meant","m.mentions":{},"msgtype":"m.text"},"ts":1719965844518,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$GzoDrKDbd7mTyxxfBoIZMf_X2ua79ImWovrLfULMUVw"},
{"content":{"body":"i'm off for the rest of the week. good progress and discussion everyone","m.mentions":{},"msgtype":"m.text"},"ts":1719966004549,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cKv5iTqcCmVin17D-4aTGNmfU0Q-J7_Buin9Uo2ZbrU"},
{"content":{"body":"I think \"no function coloring\" is a far simpler approach, overall. We shouldn't buy into that complexity unless it is absolutely necessary.","m.mentions":{},"msgtype":"m.text"},"ts":1719966015863,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SJVj_iE9h5czSIFBG0L-IO1ioSuNzRyMlzpuIrbJgek"},
{"content":{"body":"I think it has some interesting benefits, but I don't know that they outweigh the implementation complexity.","m.mentions":{},"msgtype":"m.text"},"ts":1719966068196,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oDR5Nm58t3uXVRQqgFp2idO6mZDrV8MfALJHtSluheA"},
{"content":{"body":"I think it is worth preserving flexibility to add it later if it does not significantly conflict with other goals","m.mentions":{},"msgtype":"m.text"},"ts":1719966101855,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$YxCP5EZfFOEtR9rK88iU4OLAAMqdy9LiG2DNsEFuG28"},
{"content":{"body":"But I do not want function colouring now","m.mentions":{},"msgtype":"m.text"},"ts":1719966107989,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$JHeHUH-MTQ5KO46odxO0b3lhna_JfRiw4cTtW5zljhA"},
{"content":{"body":"In which case, I would still argue in favor of `unsafe function f() {}` as meaning something closer to C#'s interpretation than Rust's, in that `unsafe` in this case is only tagging the declaration as having an `unsafe` lexical scope, since `unsafe` tagging readily solves issues with lifting safe entrypoints to unsafe code out of an `unsafe {}` block.","format":"org.matrix.custom.html","formatted_body":"In which case, I would still argue in favor of <code>unsafe function f() {}</code> as meaning something closer to C#'s interpretation than Rust's, in that <code>unsafe</code> in this case is only tagging the declaration as having an <code>unsafe</code> lexical scope, since <code>unsafe</code> tagging readily solves issues with lifting safe entrypoints to unsafe code out of an <code>unsafe {}</code> block.","m.mentions":{},"msgtype":"m.text"},"ts":1719966182621,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FzwYF5cE_cgeu2I3LEepFxOuX_pXxJRM8XvBqyWIzPs"},
{"content":{"body":"We already have this problem with private state, I'd like us not to repeat that mistake.","m.mentions":{},"msgtype":"m.text"},"ts":1719966286671,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gTiITLeCoOtTOUqj-yXGGYfyis5B_NMBaKWywMKLBIw"},
{"content":{"body":"```js\n// c.js\n\n// expose #x to other declarations in the same lexical scope\nlet getX;\n\nexport class C {\n  #x;\n  static {\n    getX = c => c.#x;\n  }\n}\n\nexport class FriendOfC {\n  method(c) {\n    x = getX(c); // privileged access to #x\n  }\n}\n\n// other.js\nimport { C, FriendOfC } from \"./c.js\";\n\n// can't get to C's #x\n```\n\nWhile it's one of the reasons I proposed `static {}`, it's still awkward to work with.","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">// c.js\n\n// expose #x to other declarations in the same lexical scope\nlet getX;\n\nexport class C {\n  #x;\n  static {\n    getX = c =&gt; c.#x;\n  }\n}\n\nexport class FriendOfC {\n  method(c) {\n    x = getX(c); // privileged access to #x\n  }\n}\n\n// other.js\nimport { C, FriendOfC } from \"./c.js\";\n\n// can't get to C's #x\n</code></pre>\n<p>While it's one of the reasons I proposed <code>static {}</code>, it's still awkward to work with.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1719966692588,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zmLwqQHygiG__B6LpTW75XdCbjgXMka_INkE30t-vSQ"}
]