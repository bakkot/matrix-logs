[
{"content":{"body":"shu: I spoke with Luis and we both concur that `using` is preferred in the long term. For context, these are my primary concerns regarding a callback-based API:\n\n- Since the addition of `async`/`await`, many JS programmers seem to be moving away from CPS for asynchronous code in new projects.\n- Callback based APIs violate Tennent's Correspondence Principle, requiring complex rewrites of statements to introduce the callback when refactoring existing code and making things like `for` loops harder to reason over.\n- An auto-locking callback API assumes no composition of locking mechanisms, such as building a SharedMutex that supports lock promotion, or holding a lock on a mutex longer than the scope of a single function call. \n- While its feasible to build a rudimentary non-callback wrapper for the callback API, such a wrapper will not release its lock if the worker thread terminates abruptly, such as due to an exception or a call to `worker.terminate()`. With an object-based lock, it is feasible to write a callback-based wrapper that does not suffer from this limitation.\n- Object-based locks are more flexible in terms of advanced scenarios, such as implementing a \"scoped lock\" that can lock multiple mutexes at once with a deadlock prevention algorithm (callback-based API is far more complicated and produces an arbitrarily deep call stack), or locks that are only conditionally taken (i.e., to avoid re-acquiring a lock in a recursive algorithm).","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a>: I spoke with Luis and we both concur that <code>using</code> is preferred in the long term. For context, these are my primary concerns regarding a callback-based API:</p>\n<ul>\n<li>Since the addition of <code>async</code>/<code>await</code>, many JS programmers seem to be moving away from CPS for asynchronous code in new projects.</li>\n<li>Callback based APIs violate Tennent's Correspondence Principle, requiring complex rewrites of statements to introduce the callback when refactoring existing code and making things like <code>for</code> loops harder to reason over.</li>\n<li>An auto-locking callback API assumes no composition of locking mechanisms, such as building a SharedMutex that supports lock promotion, or holding a lock on a mutex longer than the scope of a single function call.</li>\n<li>While its feasible to build a rudimentary non-callback wrapper for the callback API, such a wrapper will not release its lock if the worker thread terminates abruptly, such as due to an exception or a call to <code>worker.terminate()</code>. With an object-based lock, it is feasible to write a callback-based wrapper that does not suffer from this limitation.</li>\n<li>Object-based locks are more flexible in terms of advanced scenarios, such as implementing a \"scoped lock\" that can lock multiple mutexes at once with a deadlock prevention algorithm (callback-based API is far more complicated and produces an arbitrarily deep call stack), or locks that are only conditionally taken (i.e., to avoid re-acquiring a lock in a recursive algorithm).</li>\n</ul>\n","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"msgtype":"m.text"},"ts":1700170379632,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5e-XRitVKem3ZOiTxvVSjqToD7B7RO0vDJKjLm8e7GU"},
{"content":{"body":"Regarding the TCP issue, consider something as simple as a for loop with continue, break, and return:\n \n```js\n// non-locking code\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n// add lock using callback-based API\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    const result = Mutex.lock(mut, () => {\n      if (msg.stop) return { op: \"return\", value: msg.result };\n      if (msg.exitQueue) return { op: \"break_outer\" }; \n      if (!msg.accept()) return;\n      processMessage(msg);\n    });\n    if (result?.op === \"return\") return result.return;\n    if (result?.op === \"break_outer\") break outer;\n  }\n}\n// add lock via `using`:\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    using lck = new UniqueLock(mut);\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Regarding the TCP issue, consider something as simple as a for loop with continue, break, and return:</p>\n<pre><code class=\"language-js\">// non-locking code\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n// add lock using callback-based API\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    const result = Mutex.lock(mut, () =&gt; {\n      if (msg.stop) return { op: \"return\", value: msg.result };\n      if (msg.exitQueue) return { op: \"break_outer\" }; \n      if (!msg.accept()) return;\n      processMessage(msg);\n    });\n    if (result?.op === \"return\") return result.return;\n    if (result?.op === \"break_outer\") break outer;\n  }\n}\n// add lock via `using`:\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    using lck = new UniqueLock(mut);\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700170436343,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7Y_zpcg1Zo2orORfjtXRzji1UQw2giMcTEXca8w5gsM"}
]