[
{"content":{"body":"shu: I spoke with Luis and we both concur that `using` is preferred in the long term. For context, these are my primary concerns regarding a callback-based API:\n\n- Since the addition of `async`/`await`, many JS programmers seem to be moving away from CPS for asynchronous code in new projects.\n- Callback based APIs violate Tennent's Correspondence Principle, requiring complex rewrites of statements to introduce the callback when refactoring existing code and making things like `for` loops harder to reason over.\n- An auto-locking callback API assumes no composition of locking mechanisms, such as building a SharedMutex that supports lock promotion, or holding a lock on a mutex longer than the scope of a single function call. \n- While its feasible to build a rudimentary non-callback wrapper for the callback API, such a wrapper will not release its lock if the worker thread terminates abruptly, such as due to an exception or a call to `worker.terminate()`. With an object-based lock, it is feasible to write a callback-based wrapper that does not suffer from this limitation.\n- Object-based locks are more flexible in terms of advanced scenarios, such as implementing a \"scoped lock\" that can lock multiple mutexes at once with a deadlock prevention algorithm (callback-based API is far more complicated and produces an arbitrarily deep call stack), or locks that are only conditionally taken (i.e., to avoid re-acquiring a lock in a recursive algorithm).","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a>: I spoke with Luis and we both concur that <code>using</code> is preferred in the long term. For context, these are my primary concerns regarding a callback-based API:</p>\n<ul>\n<li>Since the addition of <code>async</code>/<code>await</code>, many JS programmers seem to be moving away from CPS for asynchronous code in new projects.</li>\n<li>Callback based APIs violate Tennent's Correspondence Principle, requiring complex rewrites of statements to introduce the callback when refactoring existing code and making things like <code>for</code> loops harder to reason over.</li>\n<li>An auto-locking callback API assumes no composition of locking mechanisms, such as building a SharedMutex that supports lock promotion, or holding a lock on a mutex longer than the scope of a single function call.</li>\n<li>While its feasible to build a rudimentary non-callback wrapper for the callback API, such a wrapper will not release its lock if the worker thread terminates abruptly, such as due to an exception or a call to <code>worker.terminate()</code>. With an object-based lock, it is feasible to write a callback-based wrapper that does not suffer from this limitation.</li>\n<li>Object-based locks are more flexible in terms of advanced scenarios, such as implementing a \"scoped lock\" that can lock multiple mutexes at once with a deadlock prevention algorithm (callback-based API is far more complicated and produces an arbitrarily deep call stack), or locks that are only conditionally taken (i.e., to avoid re-acquiring a lock in a recursive algorithm).</li>\n</ul>\n","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"msgtype":"m.text"},"ts":1700170379632,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5e-XRitVKem3ZOiTxvVSjqToD7B7RO0vDJKjLm8e7GU"},
{"content":{"body":"Regarding the TCP issue, consider something as simple as a for loop with continue, break, and return:\n \n```js\n// non-locking code\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n// add lock using callback-based API\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    const result = Mutex.lock(mut, () => {\n      if (msg.stop) return { op: \"return\", value: msg.result };\n      if (msg.exitQueue) return { op: \"break_outer\" }; \n      if (!msg.accept()) return;\n      processMessage(msg);\n    });\n    if (result?.op === \"return\") return result.return;\n    if (result?.op === \"break_outer\") break outer;\n  }\n}\n// add lock via `using`:\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    using lck = new UniqueLock(mut);\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Regarding the TCP issue, consider something as simple as a for loop with continue, break, and return:</p>\n<pre><code class=\"language-js\">// non-locking code\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n// add lock using callback-based API\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    const result = Mutex.lock(mut, () =&gt; {\n      if (msg.stop) return { op: \"return\", value: msg.result };\n      if (msg.exitQueue) return { op: \"break_outer\" }; \n      if (!msg.accept()) return;\n      processMessage(msg);\n    });\n    if (result?.op === \"return\") return result.return;\n    if (result?.op === \"break_outer\") break outer;\n  }\n}\n// add lock via `using`:\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    using lck = new UniqueLock(mut);\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700170436343,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7Y_zpcg1Zo2orORfjtXRzji1UQw2giMcTEXca8w5gsM"},
{"content":{"body":"And a rough sketch of a `UniqueLock` API might look like:\n\n```js\nclass UniqueLock {\n  constructor(mutex?: Atomics.Mutex, t?: \"lock\" | \"defer-lock\" | \"try-to-lock\" | \"adopt-lock\");\n  static lockAsync(mutex: Atomics.Mutex): Promise<UniqueLock>;\n  get mutex(): Atomics.Mutex | undefined;\n  get ownsLock(): boolean;\n  tryLock(timeout?: number): boolean;\n  lock(): void;\n  lockAsync(): Promise<boolean>;\n  unlock(): void;\n  release(): void;\n  [Symbol.dispose](): void;\n}\n```\n\nwith usage like\n```js\n// sync lock\n{\n  using lck = new UniqueLock(mut);\n  ...\n}\n\n// async lock (option 1)\n{\n  using lck = await UniqueLock.lockAsync(mut);\n  ...\n}\n \n// async lock (option 2)\n{\n  using lck = new UniqueLock(mut, \"defer-lock\");\n  await lck.lockAsync();\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>And a rough sketch of a <code>UniqueLock</code> API might look like:</p>\n<pre><code class=\"language-js\">class UniqueLock {\n  constructor(mutex?: Atomics.Mutex, t?: \"lock\" | \"defer-lock\" | \"try-to-lock\" | \"adopt-lock\");\n  static lockAsync(mutex: Atomics.Mutex): Promise&lt;UniqueLock&gt;;\n  get mutex(): Atomics.Mutex | undefined;\n  get ownsLock(): boolean;\n  tryLock(timeout?: number): boolean;\n  lock(): void;\n  lockAsync(): Promise&lt;boolean&gt;;\n  unlock(): void;\n  release(): void;\n  [Symbol.dispose](): void;\n}\n</code></pre>\n<p>with usage like</p>\n<pre><code class=\"language-js\">// sync lock\n{\n  using lck = new UniqueLock(mut);\n  ...\n}\n\n// async lock (option 1)\n{\n  using lck = await UniqueLock.lockAsync(mut);\n  ...\n}\n \n// async lock (option 2)\n{\n  using lck = new UniqueLock(mut, \"defer-lock\");\n  await lck.lockAsync();\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700170528870,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Q4f-BBHxQ7xKYXJ1dKNCD7GJ-vvvQSsPaIkVhkizIAU"},
{"content":{"body":"i see, thanks","m.mentions":{},"msgtype":"m.text"},"ts":1700171148747,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$1Mlju9MKahtoXzjo7cwBf2OTZwoUYfi3u-uB077nH0A"},
{"content":{"body":"i can live with this","m.mentions":{},"msgtype":"m.text"},"ts":1700171153446,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6v_lrbccrmJHSOi8kRm16wNa5dRIhzb1UWyRfNwx-vs"},
{"content":{"body":"rbuckton: Mutex then would be this opaque thing, no prototype methods, nothing?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: Mutex then would be this opaque thing, no prototype methods, nothing?","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"msgtype":"m.text"},"ts":1700171192283,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ONnjHSbvljH26R5GPtP_AXcm9PfU9RiF-OsOeALyrGw"},
{"content":{"body":"my only quibble with the sketch is i would've figured `tryLock` and `lock` and friends would be on Mutex, with `UniqueLock` just providing a `Symbol.dispose`","format":"org.matrix.custom.html","formatted_body":"my only quibble with the sketch is i would've figured <code>tryLock</code> and <code>lock</code> and friends would be on Mutex, with <code>UniqueLock</code> just providing a <code>Symbol.dispose</code>","m.mentions":{},"msgtype":"m.text"},"ts":1700171240327,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$H-5wnRAs5jIgKR_wFteKTlI4osF6FuXRkd5u-HJ_sgY"},
{"content":{"body":"like what you do in C++","m.mentions":{},"msgtype":"m.text"},"ts":1700171247221,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$kePIeaVx4yQQ6wsKDTORfwITsowXed-FFg2X9QI-lj0"},
{"content":{"body":"C++ `std::unique_lock` has a similar API.","format":"org.matrix.custom.html","formatted_body":"C++ <code>std::unique_lock</code> has a similar API.","m.mentions":{},"msgtype":"m.text"},"ts":1700171435294,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xmhImm_HdSgBEhgPoVzqHlj_umCszBn0xPshn9fqvno"},
{"content":{"body":"`std::scoped_lock` has no methods, but also locks multiple mutexes at once","format":"org.matrix.custom.html","formatted_body":"<code>std::scoped_lock</code> has no methods, but also locks multiple mutexes at once","m.mentions":{},"msgtype":"m.text"},"ts":1700171461261,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fSvtqHMLnTXONONFFVOHRKCshOQx-7sboliKWWh-xnY"},
{"content":{"body":"And sometimes you need need to hand off a lock to something else, or perform programmatic checks. For example:\n\n```js\nusing lck = new UniqueLock(mut, \"try-to-lock\");\nif (lck.ownsLock) {\n  // fast path\n}\nelse {\n  lck.lock(); // blocks\n  // slow path\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>And sometimes you need need to hand off a lock to something else, or perform programmatic checks. For example:</p>\n<pre><code class=\"language-js\">using lck = new UniqueLock(mut, \"try-to-lock\");\nif (lck.ownsLock) {\n  // fast path\n}\nelse {\n  lck.lock(); // blocks\n  // slow path\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700171617574,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XuLUs-jFhl5c4NNdgFmqy4tIGisvsT14yX1zyMPaO_k"},
{"content":{"body":" * And sometimes you need need to hand off a lock to something else, or perform programmatic checks. For example:\n\n```js\nusing lck = new UniqueLock(mut, \"try-to-lock\");\nif (lck.ownsLock) {\n  // fast path\n}\nelse {\n  // slow path, may include calls to `wait` for conditions, etc.\n  lck.lock(); // blocks\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>And sometimes you need need to hand off a lock to something else, or perform programmatic checks. For example:</p>\n<pre><code class=\"language-js\">using lck = new UniqueLock(mut, \"try-to-lock\");\nif (lck.ownsLock) {\n  // fast path\n}\nelse {\n  // slow path, may include calls to `wait` for conditions, etc.\n  lck.lock(); // blocks\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"And sometimes you need need to hand off a lock to something else, or perform programmatic checks. For example:\n\n```js\nusing lck = new UniqueLock(mut, \"try-to-lock\");\nif (lck.ownsLock) {\n  // fast path\n}\nelse {\n  // slow path, may include calls to `wait` for conditions, etc.\n  lck.lock(); // blocks\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>And sometimes you need need to hand off a lock to something else, or perform programmatic checks. For example:</p>\n<pre><code class=\"language-js\">using lck = new UniqueLock(mut, \"try-to-lock\");\nif (lck.ownsLock) {\n  // fast path\n}\nelse {\n  // slow path, may include calls to `wait` for conditions, etc.\n  lck.lock(); // blocks\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$XuLUs-jFhl5c4NNdgFmqy4tIGisvsT14yX1zyMPaO_k","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1700171653970,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PZvo9E3fn63bCQ_LWXkpHgk6lspmUE7QoFX682iD-0g"},
{"content":{"body":"And yes, `mutex` could just be opaque.","format":"org.matrix.custom.html","formatted_body":"And yes, <code>mutex</code> could just be opaque.","m.mentions":{},"msgtype":"m.text"},"ts":1700171674594,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Okfm3DE16dKIbJc8ZnZA2oVriBfiVL0Xhm5wUMbYjjM"},
{"content":{"body":"why start with that and not mutex_guard?","m.mentions":{},"msgtype":"m.text"},"ts":1700171716045,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$OBT2eW8-umYQ4Cnk3_12v1hTlvsv9VkJjSl9fTpf0cs"},
{"content":{"body":"`UniqueLock` could also accept user-defined lockables if you need to build more complex coordination primitives for your use case.","format":"org.matrix.custom.html","formatted_body":"<code>UniqueLock</code> could also accept user-defined lockables if you need to build more complex coordination primitives for your use case.","m.mentions":{},"msgtype":"m.text"},"ts":1700171736775,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$O2uY-qlYzM7ZolEayxl2PLkAwb3dtXuEVb_P4ZtV9-E"},
{"content":{"body":"(again, the minimal thing). i don't want to lead with things like deadlock avoidance for sequencing locks, like unique_locks are often used for","m.mentions":{},"msgtype":"m.text"},"ts":1700171746077,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$4KRNap0u2L7LCdCSzbW74Qam3Ltw8P17n3i6sT3p2lc"},
{"content":{"body":"Because `UniqueLock` is the most flexible as a building block.","format":"org.matrix.custom.html","formatted_body":"Because <code>UniqueLock</code> is the most flexible as a building block.","m.mentions":{},"msgtype":"m.text"},"ts":1700171757563,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zEWO8jflkrXrS-UjMmkoeWIUD62VLrLvQyNdr0GUmGQ"},
{"content":{"body":"IIRC, `unique_lock` doesn't provide deadlock avoidance. That's the job of `scoped_lock`. And I can build `scoped_lock` on top of `unique_lock` if I need too","format":"org.matrix.custom.html","formatted_body":"IIRC, <code>unique_lock</code> doesn't provide deadlock avoidance. That's the job of <code>scoped_lock</code>. And I can build <code>scoped_lock</code> on top of <code>unique_lock</code> if I need too","m.mentions":{},"msgtype":"m.text"},"ts":1700171793129,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WuCU7hBbjNZQyokc8eKp2D8Gpfp7gkE3CeqDg-XyzAM"},
{"content":{"body":"ah perhaps i'm confusing the two","m.mentions":{},"msgtype":"m.text"},"ts":1700171804275,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$8CQ3aBUlw0SigaVIwArSqL85ILCnsNz1jjajt2-1dJk"},
{"content":{"body":"okay","m.mentions":{},"msgtype":"m.text"},"ts":1700171804992,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9MfuKiYSYiNiP8xdsQYNg54J6CdIcXwULa2hGkrZY8k"},
{"content":{"body":"See https://github.com/microsoft/TypeScript/blob/shared-struct-test/src/compiler/threading/scopedLock.ts","m.mentions":{},"msgtype":"m.text"},"ts":1700171807117,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1IBnCZ0WZSHfTCAusE9sVIyh4ayQ5itwEm9RrygIIw4"},
{"content":{"body":"And https://github.com/microsoft/TypeScript/blob/shared-struct-test/src/compiler/threading/uniqueLock.ts","m.mentions":{},"msgtype":"m.text"},"ts":1700171816735,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5Y7rfUsgZR3M6sfswIlky0MxfyOPITIfHgl2hn2cIro"},
{"content":{"body":"i think deadlock avoidance definitely runs afoul of not minimal, but i see that this doesn't have that, that seems fine","m.mentions":{},"msgtype":"m.text"},"ts":1700171842335,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zZ8gllsogrrZEMHpTXfsmOdFUE_FiwMOvPLOuYhw0Ro"},
{"content":{"body":"Both of those use an object-based wrapper for `Mutext` to avoid callbacks, but potentially runs afoul of bullet #4 above (assuming the callback-based approach currently releases the mutex if it is held when the worker is abruptly terminated)","format":"org.matrix.custom.html","formatted_body":"Both of those use an object-based wrapper for <code>Mutext</code> to avoid callbacks, but potentially runs afoul of bullet #4 above (assuming the callback-based approach currently releases the mutex if it is held when the worker is abruptly terminated)","m.mentions":{},"msgtype":"m.text"},"ts":1700171910556,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$C4Ov2Fx-qLH_VmAbBn_NgPf1zDKW97bGoy2d8EEl_Kg"},
{"content":{"body":"`UniqueLock` gives you the minimal functionality and flexibility necessary to build more complex things.","format":"org.matrix.custom.html","formatted_body":"<code>UniqueLock</code> gives you the minimal functionality and flexibility necessary to build more complex things.","m.mentions":{},"msgtype":"m.text"},"ts":1700171958946,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MJ-0kf4Ia38ZZOBi8r_FvN-eGk0HI-eD5MfSlPxhKrU"},
{"content":{"body":"what's the 4th bullet? thread termination?","m.mentions":{},"msgtype":"m.text"},"ts":1700172006649,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$aSTNe61ekWc1SRsK4e--nawlElfv6-PSVtokXNlDMWc"},
{"content":{"body":"And only really exposes `lock`, `tryLock`, and `unlock`","format":"org.matrix.custom.html","formatted_body":"And only really exposes <code>lock</code>, <code>tryLock</code>, and <code>unlock</code>","m.mentions":{},"msgtype":"m.text"},"ts":1700172010898,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$K60Kw-natVbQgaZAYonax-Advtps4GTr6xiRShe-wbA"},
{"content":{"body":"Yeah","m.mentions":{},"msgtype":"m.text"},"ts":1700172012500,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eZ3LPTeXIjy2SgGExRW1VddxYsfomJSklNOfjr5FEMw"},
{"content":{"body":"yeah that's kind of tricky","m.mentions":{},"msgtype":"m.text"},"ts":1700172057782,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$QIBUbUacWZ6aSfnJUINaMPEQvRzhwmhSGFQR6fRrwJI"},
{"content":{"body":"it'd be nice to automatically release but... that has cost","m.mentions":{},"msgtype":"m.text"},"ts":1700172087960,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$D5xdZDA1dhj996Z5Nvr0XCmDpNRkZLAeMZjeUyK567w"},
{"content":{"body":"Even if there isn't automatic release, the object wrapper incurs more overhead since it needs both a `Mutext` and another boolean field.","format":"org.matrix.custom.html","formatted_body":"Even if there isn't automatic release, the object wrapper incurs more overhead since it needs both a <code>Mutext</code> and another boolean field.","m.mentions":{},"msgtype":"m.text"},"ts":1700172136717,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tqt3c-LJRzPbefwIspwRPp8H9AhAzlhEj1uFOYuhyAI"},
{"content":{"body":"`Worker.terminate()` is odd","format":"org.matrix.custom.html","formatted_body":"<code>Worker.terminate()</code> is odd","m.mentions":{},"msgtype":"m.text"},"ts":1700172195666,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$I4Cic7QKBEYoYIFE2UeTgQWZbEmuZIuU0YR3xHqE2FM"},
{"content":{"body":"bb in an hour","m.mentions":{},"msgtype":"m.text"},"ts":1700172204410,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$8-pnE4ny1nYgfp58LPXa4lJoo4PXHRMDOkXXeWIF_4c"}
]