[
{"content":{"body":"shu: I spoke with Luis and we both concur that `using` is preferred in the long term. For context, these are my primary concerns regarding a callback-based API:\n\n- Since the addition of `async`/`await`, many JS programmers seem to be moving away from CPS for asynchronous code in new projects.\n- Callback based APIs violate Tennent's Correspondence Principle, requiring complex rewrites of statements to introduce the callback when refactoring existing code and making things like `for` loops harder to reason over.\n- An auto-locking callback API assumes no composition of locking mechanisms, such as building a SharedMutex that supports lock promotion, or holding a lock on a mutex longer than the scope of a single function call. \n- While its feasible to build a rudimentary non-callback wrapper for the callback API, such a wrapper will not release its lock if the worker thread terminates abruptly, such as due to an exception or a call to `worker.terminate()`. With an object-based lock, it is feasible to write a callback-based wrapper that does not suffer from this limitation.\n- Object-based locks are more flexible in terms of advanced scenarios, such as implementing a \"scoped lock\" that can lock multiple mutexes at once with a deadlock prevention algorithm (callback-based API is far more complicated and produces an arbitrarily deep call stack), or locks that are only conditionally taken (i.e., to avoid re-acquiring a lock in a recursive algorithm).","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a>: I spoke with Luis and we both concur that <code>using</code> is preferred in the long term. For context, these are my primary concerns regarding a callback-based API:</p>\n<ul>\n<li>Since the addition of <code>async</code>/<code>await</code>, many JS programmers seem to be moving away from CPS for asynchronous code in new projects.</li>\n<li>Callback based APIs violate Tennent's Correspondence Principle, requiring complex rewrites of statements to introduce the callback when refactoring existing code and making things like <code>for</code> loops harder to reason over.</li>\n<li>An auto-locking callback API assumes no composition of locking mechanisms, such as building a SharedMutex that supports lock promotion, or holding a lock on a mutex longer than the scope of a single function call.</li>\n<li>While its feasible to build a rudimentary non-callback wrapper for the callback API, such a wrapper will not release its lock if the worker thread terminates abruptly, such as due to an exception or a call to <code>worker.terminate()</code>. With an object-based lock, it is feasible to write a callback-based wrapper that does not suffer from this limitation.</li>\n<li>Object-based locks are more flexible in terms of advanced scenarios, such as implementing a \"scoped lock\" that can lock multiple mutexes at once with a deadlock prevention algorithm (callback-based API is far more complicated and produces an arbitrarily deep call stack), or locks that are only conditionally taken (i.e., to avoid re-acquiring a lock in a recursive algorithm).</li>\n</ul>\n","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"msgtype":"m.text"},"ts":1700170379632,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5e-XRitVKem3ZOiTxvVSjqToD7B7RO0vDJKjLm8e7GU"},
{"content":{"body":"Regarding the TCP issue, consider something as simple as a for loop with continue, break, and return:\n \n```js\n// non-locking code\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n// add lock using callback-based API\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    const result = Mutex.lock(mut, () => {\n      if (msg.stop) return { op: \"return\", value: msg.result };\n      if (msg.exitQueue) return { op: \"break_outer\" }; \n      if (!msg.accept()) return;\n      processMessage(msg);\n    });\n    if (result?.op === \"return\") return result.return;\n    if (result?.op === \"break_outer\") break outer;\n  }\n}\n// add lock via `using`:\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    using lck = new UniqueLock(mut);\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Regarding the TCP issue, consider something as simple as a for loop with continue, break, and return:</p>\n<pre><code class=\"language-js\">// non-locking code\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n// add lock using callback-based API\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    const result = Mutex.lock(mut, () =&gt; {\n      if (msg.stop) return { op: \"return\", value: msg.result };\n      if (msg.exitQueue) return { op: \"break_outer\" }; \n      if (!msg.accept()) return;\n      processMessage(msg);\n    });\n    if (result?.op === \"return\") return result.return;\n    if (result?.op === \"break_outer\") break outer;\n  }\n}\n// add lock via `using`:\nouter: for (const back of queues) {\n  for (const msg of queue.getMessages()) {\n    using lck = new UniqueLock(mut);\n    if (msg.stop) return msg.result;\n    if (msg.exitQueue) break outer; \n    if (!msg.accept()) continue;\n    processMessage(msg);\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700170436343,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7Y_zpcg1Zo2orORfjtXRzji1UQw2giMcTEXca8w5gsM"},
{"content":{"body":"And a rough sketch of a `UniqueLock` API might look like:\n\n```js\nclass UniqueLock {\n  constructor(mutex?: Atomics.Mutex, t?: \"lock\" | \"defer-lock\" | \"try-to-lock\" | \"adopt-lock\");\n  static lockAsync(mutex: Atomics.Mutex): Promise<UniqueLock>;\n  get mutex(): Atomics.Mutex | undefined;\n  get ownsLock(): boolean;\n  tryLock(timeout?: number): boolean;\n  lock(): void;\n  lockAsync(): Promise<boolean>;\n  unlock(): void;\n  release(): void;\n  [Symbol.dispose](): void;\n}\n```\n\nwith usage like\n```js\n// sync lock\n{\n  using lck = new UniqueLock(mut);\n  ...\n}\n\n// async lock (option 1)\n{\n  using lck = await UniqueLock.lockAsync(mut);\n  ...\n}\n \n// async lock (option 2)\n{\n  using lck = new UniqueLock(mut, \"defer-lock\");\n  await lck.lockAsync();\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>And a rough sketch of a <code>UniqueLock</code> API might look like:</p>\n<pre><code class=\"language-js\">class UniqueLock {\n  constructor(mutex?: Atomics.Mutex, t?: \"lock\" | \"defer-lock\" | \"try-to-lock\" | \"adopt-lock\");\n  static lockAsync(mutex: Atomics.Mutex): Promise&lt;UniqueLock&gt;;\n  get mutex(): Atomics.Mutex | undefined;\n  get ownsLock(): boolean;\n  tryLock(timeout?: number): boolean;\n  lock(): void;\n  lockAsync(): Promise&lt;boolean&gt;;\n  unlock(): void;\n  release(): void;\n  [Symbol.dispose](): void;\n}\n</code></pre>\n<p>with usage like</p>\n<pre><code class=\"language-js\">// sync lock\n{\n  using lck = new UniqueLock(mut);\n  ...\n}\n\n// async lock (option 1)\n{\n  using lck = await UniqueLock.lockAsync(mut);\n  ...\n}\n \n// async lock (option 2)\n{\n  using lck = new UniqueLock(mut, \"defer-lock\");\n  await lck.lockAsync();\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700170528870,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Q4f-BBHxQ7xKYXJ1dKNCD7GJ-vvvQSsPaIkVhkizIAU"},
{"content":{"body":"i see, thanks","m.mentions":{},"msgtype":"m.text"},"ts":1700171148747,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$1Mlju9MKahtoXzjo7cwBf2OTZwoUYfi3u-uB077nH0A"},
{"content":{"body":"i can live with this","m.mentions":{},"msgtype":"m.text"},"ts":1700171153446,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6v_lrbccrmJHSOi8kRm16wNa5dRIhzb1UWyRfNwx-vs"},
{"content":{"body":"rbuckton: Mutex then would be this opaque thing, no prototype methods, nothing?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: Mutex then would be this opaque thing, no prototype methods, nothing?","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"msgtype":"m.text"},"ts":1700171192283,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ONnjHSbvljH26R5GPtP_AXcm9PfU9RiF-OsOeALyrGw"},
{"content":{"body":"my only quibble with the sketch is i would've figured `tryLock` and `lock` and friends would be on Mutex, with `UniqueLock` just providing a `Symbol.dispose`","format":"org.matrix.custom.html","formatted_body":"my only quibble with the sketch is i would've figured <code>tryLock</code> and <code>lock</code> and friends would be on Mutex, with <code>UniqueLock</code> just providing a <code>Symbol.dispose</code>","m.mentions":{},"msgtype":"m.text"},"ts":1700171240327,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$H-5wnRAs5jIgKR_wFteKTlI4osF6FuXRkd5u-HJ_sgY"},
{"content":{"body":"like what you do in C++","m.mentions":{},"msgtype":"m.text"},"ts":1700171247221,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$kePIeaVx4yQQ6wsKDTORfwITsowXed-FFg2X9QI-lj0"}
]