[
{"content":{"body":"> <@iain:mozilla.org> The proposal very nearly avoids the need to support shared->local edges. The incremental cost of having to overhaul GC is significantly larger than the incremental benefits for the few use cases.\n\nWell there is the other problem that currently all JS objects are usable as WeakMap keys, and that some libraries rely on that to hold true, possibly some that never attempt to access the fields of the object. If we're talking about shared structs being a drop-in replacement for class instances in some cases, I'd argue we need to uphold that current property of the language.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$GdGQlYaebAX-4kIZdzU-BPBS3TWTHfvCy3ERW0FGP2Y?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@iain:mozilla.org\">@iain:mozilla.org</a><br>The proposal very nearly avoids the need to support shared-&gt;local edges. The incremental cost of having to overhaul GC is significantly larger than the incremental benefits for the few use cases.</blockquote></mx-reply>Well there is the other problem that currently all JS objects are usable as WeakMap keys, and that some libraries rely on that to hold true, possibly some that never attempt to access the fields of the object. If we're talking about shared structs being a drop-in replacement for class instances in some cases, I'd argue we need to uphold that current property of the language.","m.mentions":{"user_ids":["@iain:mozilla.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$GdGQlYaebAX-4kIZdzU-BPBS3TWTHfvCy3ERW0FGP2Y"}},"msgtype":"m.text"},"ts":1725000693961,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$cH2xu0y9b79m6o0HxW4-tn37xiClWOE5g60mTSV5IHI"},
{"content":{"body":"I think everybody agrees that in the long run it would be good to have shared structs that can be used as weakmap keys. My argument is that in terms of the actual implementation effort, supporting shared-to-local edges (which is required to implement weakmaps that don't leak) is a major implementation challenge (like, 1/3 to 1/2 of the overall proposal?). The new capabilities that it unlocks are relatively small. So the question is whether it is better to ship a complete version of shared structs in N years, or a more restricted version in N/2 years followed by a complete version N/2 years later.","m.mentions":{},"msgtype":"m.text"},"ts":1725033319768,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$u8T-Ep_MT3sBZ3RDGMx3iC6fwBJzeu1_c9dkiClXw-o"},
{"content":{"body":" * I think everybody agrees that in the long run it would be good to have shared structs that can be used as weakmap keys. My argument is that in terms of the actual implementation effort, supporting shared-to-local edges (which is required to implement weakmaps that don't leak) is a major implementation challenge (like, 1/3 to 1/2 of the overall proposal?). The new capabilities that it unlocks are relatively small (compared to the overall proposal). So the question is whether it is better to ship a complete version of shared structs in N years, or a more restricted version in N/2 years followed by a complete version N/2 years later.","m.mentions":{},"m.new_content":{"body":"I think everybody agrees that in the long run it would be good to have shared structs that can be used as weakmap keys. My argument is that in terms of the actual implementation effort, supporting shared-to-local edges (which is required to implement weakmaps that don't leak) is a major implementation challenge (like, 1/3 to 1/2 of the overall proposal?). The new capabilities that it unlocks are relatively small (compared to the overall proposal). So the question is whether it is better to ship a complete version of shared structs in N years, or a more restricted version in N/2 years followed by a complete version N/2 years later.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$u8T-Ep_MT3sBZ3RDGMx3iC6fwBJzeu1_c9dkiClXw-o","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1725033339110,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$mVfPsGMYwOleNw3qSPwZYMqSViMnKGcn2ShHCL6kB9I"},
{"content":{"body":"I also expect that getting implementation feedback from more than one engine before locking in the final proposal will lead to a better end result.","m.mentions":{},"msgtype":"m.text"},"ts":1725033545195,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$oyNsVqOdBTuhDnBpKhtEq_-cKXrmgU7O6nZi_LM_CtU"},
{"content":{"body":"Didn't V8 also initially consider banning shared to local edges? Do we know more about what led V8 to change their minds?","m.mentions":{},"msgtype":"m.text"},"ts":1725034963555,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$BTdZTunGbq7doZkrQLY0N1OjbAX5k-Rwi0oImircdv0"},
{"content":{"body":"Sometimes you want to associate some necessarily local data (eg an event handler, a DOM node) with a shared struct.","m.mentions":{},"msgtype":"m.text"},"ts":1725035283086,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$zUDQE5AqTxEwTr2OVyZDe31fFtlhnDi-gKS0rXpJv7M"},
{"content":{"body":"are you saying, we could support those edges, just not for WeakMaps?","m.mentions":{},"msgtype":"m.text"},"ts":1725035350069,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$tSNK5Drw3BTDrUaPfp_aNgfVBnDIwgy9H6p0Bdw6dwo"},
{"content":{"body":"V8 isn't proposing unrestricted shared to local edges. But putting shared structs in weak maps ends up in a similar situation with respect to cycles through the shared space.","m.mentions":{},"msgtype":"m.text"},"ts":1725035635588,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$Il0I7iz-Sf9KOMULUUdejr3ORNq2eqBjgCM1QuC8ZjI"},
{"content":{"body":"Eg if you have two shared structs and two workers, and each worker has a weakmap with one shared struct as a key and the other as the corresponding value, then how do you collect that?","m.mentions":{},"msgtype":"m.text"},"ts":1725035726950,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$xlEjwE059QHET1PrCVpeKfgKkIEjwg1sEMqiRUvWGaM"},
{"content":{"body":"The \"no shared to local edges\" principle, if robustly enforced, means that you can do local collections without having to coordinate with anybody else. Once you break it, then you can have cycles that (as far as anybody can tell) require you to stop the world occasionally to avoid leaking memory.","m.mentions":{},"msgtype":"m.text"},"ts":1725035938442,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$_GBlrIRdm38h0qdxFTjWq7b5fJsGF8MLAr2ClCADLMI"},
{"content":{"body":"oh I see. Yeah, if we want to restrict those edges, then restricting weakmap keys is part of it. Seems reasonable","m.mentions":{},"msgtype":"m.text"},"ts":1725036001941,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kZdBvQE0oF7lQLHY5nczO6j5d4YI5BjgPGwPoxK1xhU"},
{"content":{"body":"having an object that you can't store in a weakmap seems like a nonstarter tho","m.mentions":{},"msgtype":"m.text"},"ts":1725041790404,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$9-PsVeAM3ljnj4vOYNuiaRmCrxobGZlm-zft9BGq0Ac"},
{"content":{"body":"Shared structs are going to be weird in all sorts of ways. Why is this specific restriction a non-starter (compared to, say, not being able to store references to local objects)?","m.mentions":{},"msgtype":"m.text"},"ts":1725042007939,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$gGiWRmNcXr3cm5Y1DBH_m4Idw4SSpVt8i0brii9LVrE"},
{"content":{"body":"I reiterate that from an implementation perspective this is genuinely a major additional effort to implement well, on the rough order of magnitude as the rest of the proposal put together.","m.mentions":{},"msgtype":"m.text"},"ts":1725042242085,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$BjOpZ4yiNi_u-I1DB7bSMblkgW6vq2X7_rdbS0b9EoY"},
{"content":{"body":"(It can be implemented badly with less effort, but there are significant web-compat concerns there.)","m.mentions":{},"msgtype":"m.text"},"ts":1725042339151,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$Qz0E8SJjT5oS_5H8EOjCrxvLTNqb68cjzcWrVv8HqkY"},
{"content":{"body":"I there a middle ground where collecting non cyclic shared->local edges created by weakmaps would not cause significantly more implementation work? I think it's totally acceptable for some non common cases to leak at first","m.mentions":{},"msgtype":"m.text"},"ts":1725042484046,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$0npHeI7874GOoqA1KoYFMAnD9lKy5jRLcIoxMPfSo9M"},
{"content":{"body":"The concern with not being able to blindly put a `typeof foo === 'object' && foo !== null` in a WeakMap is a huge compat concern when an app gradually adopts shared structs","format":"org.matrix.custom.html","formatted_body":"The concern with not being able to blindly put a <code>typeof foo === 'object' &amp;&amp; foo !== null</code> in a WeakMap is a huge compat concern when an app gradually adopts shared structs","m.mentions":{},"msgtype":"m.text"},"ts":1725042577707,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CxEp20cDax2EutokpsLKWR7GGk7lL7WCTI6DjuMAhjE"},
{"content":{"body":" * The concern with not being able to blindly put a `typeof foo === 'object' && foo !== null` in a WeakMap is a compat concern when an app gradually adopts shared structs","format":"org.matrix.custom.html","formatted_body":" * The concern with not being able to blindly put a <code>typeof foo === 'object' &amp;&amp; foo !== null</code> in a WeakMap is a compat concern when an app gradually adopts shared structs","m.mentions":{},"m.new_content":{"body":"The concern with not being able to blindly put a `typeof foo === 'object' && foo !== null` in a WeakMap is a compat concern when an app gradually adopts shared structs","format":"org.matrix.custom.html","formatted_body":"The concern with not being able to blindly put a <code>typeof foo === 'object' &amp;&amp; foo !== null</code> in a WeakMap is a compat concern when an app gradually adopts shared structs","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$CxEp20cDax2EutokpsLKWR7GGk7lL7WCTI6DjuMAhjE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1725042586450,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$6O519w843m1_a9pGoSTF63aB1VETlZuyVAIx--BWFB8"},
{"content":{"body":"I think that roughly works out to be \"WeakMap as a way to implement main-thread TBS\" in the V8 design doc [here](https://docs.google.com/document/d/1GoIWdfsKuKb0PS3gSF8b1U0RoHs5ALPzXAMx-QPHHNg/edit#heading=h.pbq4b3s54rlj). I would have to double-check with our GC experts, but I think that's less effort. My concern there is webcompat: if one browser implements that, and another browser implements full cycle collection, then you're going to have websites that leak in one browser but not the other.","format":"org.matrix.custom.html","formatted_body":"I think that roughly works out to be \"WeakMap as a way to implement main-thread TBS\" in the V8 design doc <a href=\"https://docs.google.com/document/d/1GoIWdfsKuKb0PS3gSF8b1U0RoHs5ALPzXAMx-QPHHNg/edit#heading=h.pbq4b3s54rlj\">here</a>. I would have to double-check with our GC experts, but I think that's less effort. My concern there is webcompat: if one browser implements that, and another browser implements full cycle collection, then you're going to have websites that leak in one browser but not the other.","m.mentions":{},"msgtype":"m.text"},"ts":1725042774612,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$V28KLwwGFPcIIRRp58cOikO0zgMSIHq8-YQY8OzxRPI"},
{"content":{"body":"So in practice there's no difference between that middle ground and the full requirement.","m.mentions":{},"msgtype":"m.text"},"ts":1725042824757,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$X1lX6Tz-IY0kBtQKMFwqGRcwY9Ufpr5O14oKHJiK7Fg"},
{"content":{"body":"I acknowledge that this makes incremental adoption harder.","m.mentions":{},"msgtype":"m.text"},"ts":1725042894513,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$DbX9GbgdTH9Hw7_4LuWh9SRorkzUzOLcH6CkurHx_qQ"},
{"content":{"body":"I am not convinced that it makes incremental adoption so much harder that it outweighs the benefit of being able to ship something sooner.","m.mentions":{},"msgtype":"m.text"},"ts":1725042941796,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$komyByZH_KEl_iX8gDbYZFYvF-Z-1fjo0qZ-10JckB8"},
{"content":{"body":"To be clear, I'm also not convinced of the converse! I just want to make sure that we're all clear on the decision we're making.","m.mentions":{},"msgtype":"m.text"},"ts":1725043003050,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$heEGPdkCom_WRWK69fqaQMphhOodh0Z0kY63dxlRhqI"},
{"content":{"body":"> <@iain:mozilla.org> Shared structs are going to be weird in all sorts of ways. Why is this specific restriction a non-starter (compared to, say, not being able to store references to local objects)?\n\na new thing accepting a subset of values is fine. an existing thing suddenly changing its current invariants (all objects can be weakly held) is not. this would apply to weakmap, weakset, weakref, and finalizationregistry - that's a lot of things to have changed invariants.\n\nif browsers were OK with a `isWeakable` predicate - proposed for precisely this problem when non-global symbols became allowed - then it'd have been OK to change, but sans that predicate, it's not","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$gGiWRmNcXr3cm5Y1DBH_m4Idw4SSpVt8i0brii9LVrE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@iain:mozilla.org\">@iain:mozilla.org</a><br>Shared structs are going to be weird in all sorts of ways. Why is this specific restriction a non-starter (compared to, say, not being able to store references to local objects)?</blockquote></mx-reply><p>a new thing accepting a subset of values is fine. an existing thing suddenly changing its current invariants (all objects can be weakly held) is not. this would apply to weakmap, weakset, weakref, and finalizationregistry - that's a lot of things to have changed invariants.</p>\n<p>if browsers were OK with a <code>isWeakable</code> predicate - proposed for precisely this problem when non-global symbols became allowed - then it'd have been OK to change, but sans that predicate, it's not</p>\n","m.mentions":{"user_ids":["@iain:mozilla.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$gGiWRmNcXr3cm5Y1DBH_m4Idw4SSpVt8i0brii9LVrE"}},"msgtype":"m.text"},"ts":1725044650964,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$YjFFMQ7y7jX51EcicVdDBNcJPUItlGP2ZwJTScHy2iM"},
{"content":{"body":"`let isWeakable = (o) => try { new WeakMap([{}, 1]); return true; } catch { return false : }`","format":"org.matrix.custom.html","formatted_body":"<code>let isWeakable = (o) =&gt; try { new WeakMap([{}, 1]); return true; } catch { return false : }</code>","m.mentions":{},"msgtype":"m.text"},"ts":1725044934133,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$7-smqfnGZCd3oq_Ryj3br5PVsFTQCnvJPb8LNV9f1Ns"},
{"content":{"body":" * `let isWeakable = (o) => try { new WeakMap([{}, 1]); return true; } catch { return false; }`","format":"org.matrix.custom.html","formatted_body":" * <code>let isWeakable = (o) =&gt; try { new WeakMap([{}, 1]); return true; } catch { return false; }</code>","m.mentions":{},"m.new_content":{"body":"`let isWeakable = (o) => try { new WeakMap([{}, 1]); return true; } catch { return false; }`","format":"org.matrix.custom.html","formatted_body":"<code>let isWeakable = (o) =&gt; try { new WeakMap([{}, 1]); return true; } catch { return false; }</code>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$7-smqfnGZCd3oq_Ryj3br5PVsFTQCnvJPb8LNV9f1Ns","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1725044938344,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$UnaCWFgG6onS266xgC9Bnr8tlNZ4TVRD_Mcl9_0fDck"},
{"content":{"body":" * `let isWeakable = (o) => try { new WeakMap([o, 1]); return true; } catch { return false; }`","format":"org.matrix.custom.html","formatted_body":" * <code>let isWeakable = (o) =&gt; try { new WeakMap([o, 1]); return true; } catch { return false; }</code>","m.mentions":{},"m.new_content":{"body":"`let isWeakable = (o) => try { new WeakMap([o, 1]); return true; } catch { return false; }`","format":"org.matrix.custom.html","formatted_body":"<code>let isWeakable = (o) =&gt; try { new WeakMap([o, 1]); return true; } catch { return false; }</code>","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$7-smqfnGZCd3oq_Ryj3br5PVsFTQCnvJPb8LNV9f1Ns","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1725044944178,"senderName":"snek","senderId":"@devsnek:matrix.org","id":"$qrrh4VRchUjQVAEemL8WtXcldrRw7V2oRy15pX-HAXE"},
{"content":{"body":"indeed, that'd be a polyfill for it :-) but unless it's built in, the ecosystem won't use it, and there'll be tons of checks like `Object(o) === o` or `o && typeof o === 'object'` that naively check for a subset of weakable values, that will break if a non-weakable object suddenly gets passed into something","format":"org.matrix.custom.html","formatted_body":"indeed, that'd be a polyfill for it :-) but unless it's built in, the ecosystem won't use it, and there'll be tons of checks like <code>Object(o) === o</code> or <code>o &amp;&amp; typeof o === 'object'</code> that naively check for a subset of weakable values, that will break if a non-weakable object suddenly gets passed into something","m.mentions":{},"msgtype":"m.text"},"ts":1725045138615,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$hWJjkOQWrMGazpknKYfmOo6JFcXkOZx5uXXyL8cxWbk"},
{"content":{"body":"I'm still very concerned that shipping shared structs \"fast\" by dropping agent/realm-local prototypes and not supporting WeakMap is going to significantly hamper adoption for the teams actually requesting this feature. If I don't have the ability to define behavior on the prototype, then I would need to create a membrane over shared data to be able to incrementally adopt. If I can't put the shared structs in a WeakMap to ensure I only ever produce a single proxy for a given shared struct, then I have to put them in a Map. If I put them in a Map, they will leak. If I don't want them to leak, I need to force all of my API consumers to perform manual memory management, which would be a brand new requirement for *all* API consumers, so we probably just end up leaking memory. That is not a great outcome.","format":"org.matrix.custom.html","formatted_body":"I'm still very concerned that shipping shared structs \"fast\" by dropping agent/realm-local prototypes and not supporting WeakMap is going to significantly hamper adoption for the teams actually requesting this feature. If I don't have the ability to define behavior on the prototype, then I would need to create a membrane over shared data to be able to incrementally adopt. If I can't put the shared structs in a WeakMap to ensure I only ever produce a single proxy for a given shared struct, then I have to put them in a Map. If I put them in a Map, they will leak. If I don't want them to leak, I need to force all of my API consumers to perform manual memory management, which would be a brand new requirement for <em>all</em> API consumers, so we probably just end up leaking memory. That is not a great outcome.","m.mentions":{},"msgtype":"m.text"},"ts":1725047783471,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BseUg7GoQspfsYOX9bXHkPCis4jHMSwSjSdQ2xGWy-0"},
{"content":{"body":"I would be happy with a scenario where A) we get agent-local prototypes, but B) we can't have shared structs as WeakMap keys, since for (A) those prototypes would probably never be collected anyways since they will be retained by the shared struct constructors and the module graph.","m.mentions":{},"msgtype":"m.text"},"ts":1725047907630,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$de_ihd9iFVyWMRKJw7FhnTRuy9EhMSzsIRZQIZHTlFo"},
{"content":{"body":"Actually, having prototypes but not WeakMap support is still a problem. Since prototypes would give us behavior, we wouldn't need a membrane for Nodes, but we still need one for `NodeArray`. A TypeScript `NodeArray` is essentially an `Array` with extra `pos`/`end` properties attached. Unfortunately, the `SharedArray` type introduced in the shared structs dev trial doesn't allow for additional (non-indexed) properties. The only way to handle that transparently/incrementally would still be via a `Proxy`, which means we still have a potential memory leak if we don't have WeakMap.","format":"org.matrix.custom.html","formatted_body":"Actually, having prototypes but not WeakMap support is still a problem. Since prototypes would give us behavior, we wouldn't need a membrane for Nodes, but we still need one for <code>NodeArray</code>. A TypeScript <code>NodeArray</code> is essentially an <code>Array</code> with extra <code>pos</code>/<code>end</code> properties attached. Unfortunately, the <code>SharedArray</code> type introduced in the shared structs dev trial doesn't allow for additional (non-indexed) properties. The only way to handle that transparently/incrementally would still be via a <code>Proxy</code>, which means we still have a potential memory leak if we don't have WeakMap.","m.mentions":{},"msgtype":"m.text"},"ts":1725052796677,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ui2Goz34JV7on543wehs3JDDmd2iUqj_O2V3OHkdQWc"},
{"content":{"body":"If we have prototypes and WeakMaps, something like `SourceFile` could have a `statements` getter that could return a `Proxy` for a struct like\n```js\nshared struct NodeArrayStruct {\n  pos; // number\n  end; // number\n  items; // SharedArray<Node>\n}\n```\nwhere the proxy emulates `NodeArray` and redirects numeric indexed access to `items`. The performance would be abysmal though.","format":"org.matrix.custom.html","formatted_body":"<p>If we have prototypes and WeakMaps, something like <code>SourceFile</code> could have a <code>statements</code> getter that could return a <code>Proxy</code> for a struct like</p>\n<pre><code class=\"language-js\">shared struct NodeArrayStruct {\n  pos; // number\n  end; // number\n  items; // SharedArray&lt;Node&gt;\n}\n</code></pre>\n<p>where the proxy emulates <code>NodeArray</code> and redirects numeric indexed access to <code>items</code>. The performance would be abysmal though.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1725053057160,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$6NCMOaQy5qHtielKev1HxBxVcNoKKTyHVzhqqVvi2f4"}
]