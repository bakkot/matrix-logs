[
{"content":{"body":"- When A handshakes with M:\n  - M is able to establish that a PointA should have a PointM prototype and it will apply to every PointA it receives, from anywhere, within the scope of M's Agent.\n  - A is able to establish that a PointM should have a PointA prototype and it will apply to every PointM it receives, from anywhere, within the scope of A's Agent.\n- When B handshakes with M:\n  - M is able to establish that a PointB should have a PointM prototype and it will apply to every PointB it receives, from anywhere, within the scope of M's Agent.\n  - B is able to establish that a PointM should have a PointB prototype and it will apply to every PointM it receives, from anywhere, within the scope of B's Agent.\n\nAs such:\n- M will be able to find behavior for both rect1.topLeft and rect1.topRight, because the handshake between M-A and M-B established that.\n- B will not be able to find a behavior for rect1.topLeft because registries RA and RB are independent.\n- A will not be able to find a behavior for rect1.bottomRight because registries RA and RB are independent.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>When A handshakes with M:\n<ul>\n<li>M is able to establish that a PointA should have a PointM prototype and it will apply to every PointA it receives, from anywhere, within the scope of M's Agent.</li>\n<li>A is able to establish that a PointM should have a PointA prototype and it will apply to every PointM it receives, from anywhere, within the scope of A's Agent.</li>\n</ul>\n</li>\n<li>When B handshakes with M:\n<ul>\n<li>M is able to establish that a PointB should have a PointM prototype and it will apply to every PointB it receives, from anywhere, within the scope of M's Agent.</li>\n<li>B is able to establish that a PointM should have a PointB prototype and it will apply to every PointM it receives, from anywhere, within the scope of B's Agent.</li>\n</ul>\n</li>\n</ul>\n<p>As such:</p>\n<ul>\n<li>M will be able to find behavior for both rect1.topLeft and rect1.topRight, because the handshake between M-A and M-B established that.</li>\n<li>B will not be able to find a behavior for rect1.topLeft because registries RA and RB are independent.</li>\n<li>A will not be able to find a behavior for rect1.bottomRight because registries RA and RB are independent.</li>\n</ul>\n","msgtype":"m.text"},"ts":1695171668855,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HS0y6CUJFfulqtRL9L2OcgfY5tSBNGHpCYZly957_qU"},
{"content":{"body":"However, if you use the same registry RAB with A and B:\n- B is able to establish that a PointA should have a PointB prototype because the registry correlates both PointA and PointB with PointM.\n- A is able to establish that a PointB should have a PointA prototype because the registry correlates both PointA and PointB with PointM.","format":"org.matrix.custom.html","formatted_body":"<p>However, if you use the same registry RAB with A and B:</p>\n<ul>\n<li>B is able to establish that a PointA should have a PointB prototype because the registry correlates both PointA and PointB with PointM.</li>\n<li>A is able to establish that a PointB should have a PointA prototype because the registry correlates both PointA and PointB with PointM.</li>\n</ul>\n","msgtype":"m.text"},"ts":1695171791500,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$iH_SKy4Db-c6Ut52lbeCmsrHPr7BVP8495tzMzfkSGQ"},
{"content":{"body":"If such a prototype is initialized lazily in `[[GetPrototypeOf]]`, by the time B can receive a PointA, or that A can receive a PointB, both agents will have completed their handshake with M, so all information is known. This is another reason why my proposal uses a preload script. The preload script performs the worker side of the handshake before any other data can be shared between the worker and M, so you cannot have a stray PointA sent to B, or PointB sent to A, prior to a completed handshake on both sides.","format":"org.matrix.custom.html","formatted_body":"If such a prototype is initialized lazily in <code>[[GetPrototypeOf]]</code>, by the time B can receive a PointA, or that A can receive a PointB, both agents will have completed their handshake with M, so all information is known. This is another reason why my proposal uses a preload script. The preload script performs the worker side of the handshake before any other data can be shared between the worker and M, so you cannot have a stray PointA sent to B, or PointB sent to A, prior to a completed handshake on both sides.","msgtype":"m.text"},"ts":1695171989576,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9sHMvYsrX12hKrMZ4eVUjV1c-sfRweFv64o1smhunsg"},
{"content":{"body":"Now, we could theoretically have a global registry instead, with the `structs: {}` map only used to correlate PointM and PointA when A is established. Workers will always be part of a tree that points back to some root agent, so there's always a way to collect these things. If the handshake establishes the relationship without the ability to pass messages, would that be sufficient to address concerns about a global registry?","format":"org.matrix.custom.html","formatted_body":"Now, we could theoretically have a global registry instead, with the <code>structs: {}</code> map only used to correlate PointM and PointA when A is established. Workers will always be part of a tree that points back to some root agent, so there's always a way to collect these things. If the handshake establishes the relationship without the ability to pass messages, would that be sufficient to address concerns about a global registry?","msgtype":"m.text"},"ts":1695172399398,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Yb14-RUWWWm1TRT-STKWnZpMPIGXe1Z_ydukyqaDLUw"},
{"content":{"body":"Especially if the worker can't actually observe the exemplar during handshake, since the handshake process is handled by the runtime. We wouldn't even need communicate the actual exemplars through the handshake process, just the type identities of the exemplars. ","msgtype":"m.text"},"ts":1695172612891,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bxx9bKqbyxmNNaRcX6sZwD2o9nYv8E1i5BBstOb37d4"},
{"content":{"body":"Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars you send during the handshake must have been created by a type created in M's Agent.","msgtype":"m.text"},"ts":1695172875759,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xWuIFCyWb_mVwftQlKv4jkzhApT04mLu7S3B3anBEJg"},
{"content":{"body":" * Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars M sends during the handshake must have been created by a type created in M's Agent.","m.new_content":{"body":"Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars M sends during the handshake must have been created by a type created in M's Agent.","msgtype":"m.text"},"m.relates_to":{"event_id":"$xWuIFCyWb_mVwftQlKv4jkzhApT04mLu7S3B3anBEJg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695172893339,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$m0IQQ3IpFh4Muo0ZQSdb-Ave7xmIU-4MDmRlse2Z8r8"},
{"content":{"body":" * Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars M sends during the handshake must have been created by a type created in M's Agent","m.new_content":{"body":"Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars M sends during the handshake must have been created by a type created in M's Agent","msgtype":"m.text"},"m.relates_to":{"event_id":"$xWuIFCyWb_mVwftQlKv4jkzhApT04mLu7S3B3anBEJg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695172907742,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-gtvAasjyry0aOJR7CEpgzcN9yiXpwz8um_s3r3Tk4I"},
{"content":{"body":"and the same thing goes for A (or B) spinning up a Worker (A2) during handshake and passing off one A2's exemplar as one of its own.","msgtype":"m.text"},"ts":1695172974815,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$515_z1tSgS935DJcsmWclJ6vHtH6UK72txO_AMpqVQQ"},
{"content":{"body":" * and the same thing goes for A (or B) spinning up a Worker (A2) during handshake and passing off one A2's exemplars as one of its own.","m.new_content":{"body":"and the same thing goes for A (or B) spinning up a Worker (A2) during handshake and passing off one A2's exemplars as one of its own.","msgtype":"m.text"},"m.relates_to":{"event_id":"$515_z1tSgS935DJcsmWclJ6vHtH6UK72txO_AMpqVQQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695172983400,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$E5IgTu_vuU-PnoArLzAgWmxn1TtjKykOV3Fqb69BBe4"},
{"content":{"body":"Right I think an agent based registry can only work if:\n- the internal agent wide registry is an association from type to local behavior definition\n- there is a unique connection registry between 2 agents, and preparing a connection registry mapping (as creator or as a worker setting up), associates a connection specific string to a locally defined type only\n- you can only populate the agent wide registry through connection registries.\n\nthat means a worker A connected to a worker B through M but not sharing the same connection registry will not be able share behavior throughout. I'm still wondering about the special parent - child relationship these connection based registries seem to have, and how you can only have one connection registry between 2 agents or things fall apart. I can't explain why exactly right now, but this all feels awkward.","format":"org.matrix.custom.html","formatted_body":"<p>Right I think an agent based registry can only work if:</p>\n<ul>\n<li>the internal agent wide registry is an association from type to local behavior definition</li>\n<li>there is a unique connection registry between 2 agents, and preparing a connection registry mapping (as creator or as a worker setting up), associates a connection specific string to a locally defined type only</li>\n<li>you can only populate the agent wide registry through connection registries.</li>\n</ul>\n<p>that means a worker A connected to a worker B through M but not sharing the same connection registry will not be able share behavior throughout. I'm still wondering about the special parent - child relationship these connection based registries seem to have, and how you can only have one connection registry between 2 agents or things fall apart. I can't explain why exactly right now, but this all feels awkward.</p>\n","msgtype":"m.text"},"ts":1695179131028,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$th-UFWSdXkegxitZUoKzHWwt1lg72y0hqYbgRKXqY_s"},
{"content":{"body":"I'm wondering if we even need a connection-based registry if we can devise a global registry strategy that addresses Agoric's concerns about security. You'd discussed how a mutable global registry is a possible side channel for data exfiltration? I'm curious how serious the concern is and if you have a link to a paper or something else that could provide additional context? Is the concern related to how a Worker could abuse such a global registry, or how a script or module in the same Agent could abuse such a registry?","msgtype":"m.text"},"ts":1695213493361,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ob1ulvj0elSC9trzwwPF2OFw4W1yJNPed4rqXh7Vv6A"},
{"content":{"body":"> <@shuyuguo:matrix.org> the two choices are:\n> \n> 1. a shared struct instance's [[Prototype]] is a shared field and holds a shared struct, with `nonshared` fields, into which you assign methods\n> 2. a shared struct instance's [[Prototype]] is a `nonshared` field and points to a per-agent local struct\n\nrbuckton: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$HTj3amOy9ic6346qUM25tQy0JsCrTg3J9KwgjiRxuIo?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br><p>the two choices are:</p>\n<ol>\n<li>a shared struct instance's [[Prototype]] is a shared field and holds a shared struct, with <code>nonshared</code> fields, into which you assign methods</li>\n<li>a shared struct instance's [[Prototype]] is a <code>nonshared</code> field and points to a per-agent local struct</li>\n</ol>\n</blockquote></mx-reply><a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better","m.relates_to":{"m.in_reply_to":{"event_id":"$HTj3amOy9ic6346qUM25tQy0JsCrTg3J9KwgjiRxuIo"}},"msgtype":"m.text"},"ts":1695227563898,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$fEo6I5ZgqR5gDOyP8Gp1RoklPWuxkiXQTa-h7YvNdmg"},
{"content":{"body":"> <@rbuckton:matrix.org> I'm wondering if we even need a connection-based registry if we can devise a global registry strategy that addresses Agoric's concerns about security. You'd discussed how a mutable global registry is a possible side channel for data exfiltration? I'm curious how serious the concern is and if you have a link to a paper or something else that could provide additional context? Is the concern related to how a Worker could abuse such a global registry, or how a script or module in the same Agent could abuse such a registry?\n\nThe concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Ob1ulvj0elSC9trzwwPF2OFw4W1yJNPed4rqXh7Vv6A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I&#39;m wondering if we even need a connection-based registry if we can devise a global registry strategy that addresses Agoric&#39;s concerns about security. You&#39;d discussed how a mutable global registry is a possible side channel for data exfiltration? I&#39;m curious how serious the concern is and if you have a link to a paper or something else that could provide additional context? Is the concern related to how a Worker could abuse such a global registry, or how a script or module in the same Agent could abuse such a registry?</blockquote></mx-reply>The concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.","m.relates_to":{"m.in_reply_to":{"event_id":"$Ob1ulvj0elSC9trzwwPF2OFw4W1yJNPed4rqXh7Vv6A"}},"msgtype":"m.text"},"ts":1695228812186,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$GmbkFyB0O4EvzGffL0gwcYX3s4sFohz7W3r--8w0hqs"},
{"content":{"body":"> <@shuyuguo:matrix.org> rbuckton: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better\n\nWould this affect subclassing or no? I imagine in a subclassing case, we would just collect all of the shared fields up front and put them on the instance, much like we do for private fields today, so I don't imagine it would.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$fEo6I5ZgqR5gDOyP8Gp1RoklPWuxkiXQTa-h7YvNdmg?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br><a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better</blockquote></mx-reply>Would this affect subclassing or no? I imagine in a subclassing case, we would just collect all of the shared fields up front and put them on the instance, much like we do for private fields today, so I don't imagine it would.","m.relates_to":{"m.in_reply_to":{"event_id":"$fEo6I5ZgqR5gDOyP8Gp1RoklPWuxkiXQTa-h7YvNdmg"}},"msgtype":"m.text"},"ts":1695228933136,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oGP9_EGgiMCWsGmV5D7nnN042KUfmuqStY4bVgmt99A"},
{"content":{"body":"rbuckton: that's not clear to me yet. one challenge here is how to express the thread-localness of a superclass","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: that's not clear to me yet. one challenge here is how to express the thread-localness of a superclass","msgtype":"m.text"},"ts":1695229051402,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$gBTW4rJOaRMSLtNrB26Dm3b8LGNF_72fIL9-frTjPv4"},
{"content":{"body":"we want the fixed layout invariant to hold, so do you say like \"shared struct A extends per-agent B\", but what is B? it could be itself a shared struct but its layout gets copied into a thread-local version of the struct the first time [[Prototype]] is accessed in a thread","msgtype":"m.text"},"ts":1695229131232,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$EWAE9X_Kh84FHoUqFDOBXD-lxXCjTdLv43qikfoj4yI"},
{"content":{"body":"should it be a non-shared struct declaration?","msgtype":"m.text"},"ts":1695229139250,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$DNKSASWQFW4fh9DfRbziynlMtwJFANyvExf01VtO9Lg"},
{"content":{"body":"(but it gets that layout copy behavior)","msgtype":"m.text"},"ts":1695229145060,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$c4fyEeBfb2IIRc1nqDbDuyOh2CALwONp4VfNemgugAY"},
{"content":{"body":"> <@mhofman:matrix.org> The concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.\n\nDo you imagine such communication is possible in this case? ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$GmbkFyB0O4EvzGffL0gwcYX3s4sFohz7W3r--8w0hqs?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>The concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.</blockquote></mx-reply>Do you imagine such communication is possible in this case?","m.relates_to":{"m.in_reply_to":{"event_id":"$GmbkFyB0O4EvzGffL0gwcYX3s4sFohz7W3r--8w0hqs"}},"msgtype":"m.text"},"ts":1695230817411,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$AOts5ehWSb6EKC8O2Tm19Mw46rA72de6q3vLYplv3Gw"},
{"content":{"body":"Lets assume you can't use the exemplar values themselves to communicate, i.e., the actual exemplars aren't exposed to user code on the other Agent.","msgtype":"m.text"},"ts":1695231010975,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dgDTfxJOScNcIaBNO4SgDPKqfzxXJ0y7DxrIg34wNec"},
{"content":{"body":"The child thread can't send or receive structs to the parent thread during handshake, and by the time handshake has completed all correlation between the parent and child is frozen.","msgtype":"m.text"},"ts":1695231136501,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$I_6BHT_vT5jTgWqTs3P7XZflCP4oj_EJNKEsI440LVk"},
{"content":{"body":"By the time A can observe a struct from B, the correlation between M, A, and B has already occurred and is frozen. You cannot dynamically attach new behavior, but we do lazily resolve the prototype based on correlation.","msgtype":"m.text"},"ts":1695231284868,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HAGHepkhQd0b5xvg12Ha_-6MpdRwMxg6z0Ffyg8EKP0"},
{"content":{"body":"Maybe there's a small possibility of a timing related exploit if I can somehow spin up multiple additional workers on M and send an existing corelated struct to A to indicate `0` and new correlated struct to A indicating `1` and somehow measure the timing? That might be mitigated if correlation happens before normal communication can occur and prototype lookup always follows the same path, but you could potentially use structs who have narrow and wide correlation sets and measure timing that way, or update an agent-local correlation registry when two agent's communicate for the first time so that you pay that cost once. ","format":"org.matrix.custom.html","formatted_body":"Maybe there's a small possibility of a timing related exploit if I can somehow spin up multiple additional workers on M and send an existing corelated struct to A to indicate <code>0</code> and new correlated struct to A indicating <code>1</code> and somehow measure the timing? That might be mitigated if correlation happens before normal communication can occur and prototype lookup always follows the same path, but you could potentially use structs who have narrow and wide correlation sets and measure timing that way, or update an agent-local correlation registry when two agent's communicate for the first time so that you pay that cost once.","msgtype":"m.text"},"ts":1695231622205,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CL-qRnjV_AMaBii8egzgkEHyp0H83dS7ZTgV389QDNA"},
{"content":{"body":"There are possibly other ways to mitigate that as well.","msgtype":"m.text"},"ts":1695231790393,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$J8k1yxrsI5gJ73S8b09y-_TFSH5QbzblsWlvqKzL6G4"},
{"content":{"body":"Within a single Agent, when worker's aren't involved, you wouldn't be able to use this registry for communication because it would be inaccessible. You can also use CSP to lock down Worker to specific scripts, or disable it entirely.","msgtype":"m.text"},"ts":1695231987824,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$o9Ib1hxb3oy-L2ywjhuZV8jYX2S_a6YiiV8q56kC1ck"},
{"content":{"body":"If `Worker` is locked down via CSP, the only way you could leverage these for a timing attack would to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","format":"org.matrix.custom.html","formatted_body":"If <code>Worker</code> is locked down via CSP, the only way you could leverage these for a timing attack would to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","msgtype":"m.text"},"ts":1695232161856,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nkh_7Bxuw7HNNSkotDK-PvxoiTUqgaz1lul-QjFG5ZA"},
{"content":{"body":" * If `Worker` is locked down via CSP, the only way you could leverage these for a timing attack would be to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","format":"org.matrix.custom.html","formatted_body":" * If <code>Worker</code> is locked down via CSP, the only way you could leverage these for a timing attack would be to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","m.new_content":{"body":"If `Worker` is locked down via CSP, the only way you could leverage these for a timing attack would be to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","format":"org.matrix.custom.html","formatted_body":"If <code>Worker</code> is locked down via CSP, the only way you could leverage these for a timing attack would be to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","msgtype":"m.text"},"m.relates_to":{"event_id":"$nkh_7Bxuw7HNNSkotDK-PvxoiTUqgaz1lul-QjFG5ZA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695232526727,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$LERntAEnEENQm-NhWNIyHyIeUhl0sonA1MHXhK3-UVA"},
{"content":{"body":"If you have two isolated pieces of code in the same Agent that both have access to an unrestricted `Worker`, its possible they could already communicate with each other via resource starvation and timing attacks. ","format":"org.matrix.custom.html","formatted_body":"If you have two isolated pieces of code in the same Agent that both have access to an unrestricted <code>Worker</code>, its possible they could already communicate with each other via resource starvation and timing attacks.","msgtype":"m.text"},"ts":1695232839908,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$M61_ZMA_d2kuJU_NWpfBbk24-1JbF847whPtOA7CLcc"},
{"content":{"body":"For same realm/agent, if the registry is string keyed, Alice can register \"foo\". If Bob can somehow figure out that \"foo\" is already registered, this is a one bit communication channel. There are likely multiple ways Bob could sense whether \"foo\" is registered.","msgtype":"m.text"},"ts":1695236812909,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$X4plMHlNsLYatXoHv2DlB1twMWueZpJID3XjwXhwNJE"},
{"content":{"body":"With the global registry concept, all registration within a single Agent would happen via `new SharedStructType` (or via `shared struct Foo {}`). No errors would be reported except for running out of heap space (and crashing). When setting up a `Worker`, there is a correlation step to correlate the registrations within both Agents, but this only occurs at the time of the Worker handshake and should only be observable by interacting with that Worker or a shared struct provided to the worker.","format":"org.matrix.custom.html","formatted_body":"With the global registry concept, all registration within a single Agent would happen via <code>new SharedStructType</code> (or via <code>shared struct Foo {}</code>). No errors would be reported except for running out of heap space (and crashing). When setting up a <code>Worker</code>, there is a correlation step to correlate the registrations within both Agents, but this only occurs at the time of the Worker handshake and should only be observable by interacting with that Worker or a shared struct provided to the worker.","msgtype":"m.text"},"ts":1695237653936,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rZPCiUAEx1EdYnJ6a_BYDZqTfbp68F6P_5sxahdDPTc"},
{"content":{"body":"As far as I can tell, there's no way to observe that within a single Agent/realm. You can't check if something is \"registered\" because all \"registration\" happens before the thing you would test exists.","msgtype":"m.text"},"ts":1695237758122,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ORPVJmRDAaUMTDn1GyvYZahqGIDV4nUA8wa3zgt8nxY"},
{"content":{"body":"The only way to observe correlation would be to use a Worker and a shared reference, which still only observes correlation between those two Agents.","msgtype":"m.text"},"ts":1695237840255,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$W0BIfIVIeOPx-FO5rnw_QxasoB6ZvmDS0I8nKmUfjiQ"},
{"content":{"body":"There should be no way to get at the registry itself, and the only way to establish correlation is to already have a reference to the shared struct type. ","msgtype":"m.text"},"ts":1695237918716,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XWL1b_DUGxmdqMWL9ZM1FeJIkPurZdbBNLupq7m0DSU"},
{"content":{"body":"You could observe whether A and B share correlation with M, but only if you already have access to shared data from A and B","msgtype":"m.text"},"ts":1695237962406,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TfI_vbMMipI7KafMX6leEOFvDHpbHIu4Zl_nyCD3Brw"},
{"content":{"body":"There would be no error upon registration, because there is no addressable identity to forge, nor a way to forge it. Every shared struct type would have its own type identity, defined at the time of creation.","msgtype":"m.text"},"ts":1695238060153,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Gjy_Omo12RhCtl9dVs_vhMyo0Y4KGCP619yKcyHVBWY"},
{"content":{"body":"I think it depends on how the global registry works, how it handles collisions? Any mechanism that uses a forgeable value as key is likely observable, whether it errors, or first / last win. In the latter case, as you mention starting a worker and asking it to send you that type, and seeing what behavior you get, yours or the other one registered in the same realm. I really cannot imagine any way where a registry with forgeable keys can be made unobservable.\nYou do mention \"no way to get at the registry itself\", which instead sounds like design we were talking about yesterday, not an agent wide string keyed registry, but instead a connection based string-keyed mapper. I agree that it may be possible to make that work, but I think it requires the \"correlation registry\" between 2 agents to be unique and immutable after start.","msgtype":"m.text"},"ts":1695239779091,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$KR2trNZom5w5_s5ks32T0zhi3gH2bi-bQ7aQkft7hms"},
{"content":{"body":"rbuckton: actually how _do_ you think we can syntactically express the shape of a shared struct's prototype, if that prototype is to be fixed layout but per-thread?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: actually how <em>do</em> you think we can syntactically express the shape of a shared struct's prototype, if that prototype is to be fixed layout but per-thread?","msgtype":"m.text"},"ts":1695239853255,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$4kgEp1IKqayDRYOCi8mrqbZ0GC2vjS0MSyr7xh5mTuY"},
{"content":{"body":"there's not a good precedent to fall back on in `class` syntax","format":"org.matrix.custom.html","formatted_body":"there's not a good precedent to fall back on in <code>class</code> syntax","msgtype":"m.text"},"ts":1695239866088,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$paCYoMERy5TRvG45XOx1s1SaWlo303qm4r73Zm58y4c"},
{"content":{"body":"> <@shuyuguo:matrix.org> rbuckton: actually how _do_ you think we can syntactically express the shape of a shared struct's prototype, if that prototype is to be fixed layout but per-thread?\n\nHow important is it that the prototype be fixed shape, especially if we're not actually sharing the prototype around anywhere?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$4kgEp1IKqayDRYOCi8mrqbZ0GC2vjS0MSyr7xh5mTuY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br><a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: actually how <em>do</em> you think we can syntactically express the shape of a shared struct's prototype, if that prototype is to be fixed layout but per-thread?</blockquote></mx-reply>How important is it that the prototype be fixed shape, especially if we're not actually sharing the prototype around anywhere?","m.relates_to":{"m.in_reply_to":{"event_id":"$4kgEp1IKqayDRYOCi8mrqbZ0GC2vjS0MSyr7xh5mTuY"}},"msgtype":"m.text"},"ts":1695240065463,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$L_Ox0eZzF2XTLamRiQ5uMFiQUbdCtkgx4krwZpop6Ng"},
{"content":{"body":"it's not _as_ important but i feel it is still important","format":"org.matrix.custom.html","formatted_body":"it's not <em>as</em> important but i feel it is still important","msgtype":"m.text"},"ts":1695240096883,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$wCboWteiN8kEvC34SU2KSDR-hMCY1-7-7676kp5gtjM"},
{"content":{"body":"part of my mental model of structs (shared or not) over ordinary objects is \"the shape doesn't change\", and that transitively applies via the prototype chain","msgtype":"m.text"},"ts":1695240182404,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$RsKmJhRdM368stwF-95kqIgso3dnf34ub0J2q7uwN2M"},
{"content":{"body":"> <@mhofman:matrix.org> I think it depends on how the global registry works, how it handles collisions? Any mechanism that uses a forgeable value as key is likely observable, whether it errors, or first / last win. In the latter case, as you mention starting a worker and asking it to send you that type, and seeing what behavior you get, yours or the other one registered in the same realm. I really cannot imagine any way where a registry with forgeable keys can be made unobservable.\n> You do mention \"no way to get at the registry itself\", which instead sounds like design we were talking about yesterday, not an agent wide string keyed registry, but instead a connection based string-keyed mapper. I agree that it may be possible to make that work, but I think it requires the \"correlation registry\" between 2 agents to be unique and immutable after start.\n\nWhat collisions? What is forgeable? The only thing user-provided is the correlation token used to explain what prototype to choose for a foreign struct within an Agent, and that only affects that Agent's view of the struct, not any other agent.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$KR2trNZom5w5_s5ks32T0zhi3gH2bi-bQ7aQkft7hms?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I think it depends on how the global registry works, how it handles collisions? Any mechanism that uses a forgeable value as key is likely observable, whether it errors, or first / last win. In the latter case, as you mention starting a worker and asking it to send you that type, and seeing what behavior you get, yours or the other one registered in the same realm. I really cannot imagine any way where a registry with forgeable keys can be made unobservable.<br/>You do mention &quot;no way to get at the registry itself&quot;, which instead sounds like design we were talking about yesterday, not an agent wide string keyed registry, but instead a connection based string-keyed mapper. I agree that it may be possible to make that work, but I think it requires the &quot;correlation registry&quot; between 2 agents to be unique and immutable after start.</blockquote></mx-reply>What collisions? What is forgeable? The only thing user-provided is the correlation token used to explain what prototype to choose for a foreign struct within an Agent, and that only affects that Agent's view of the struct, not any other agent.","m.relates_to":{"m.in_reply_to":{"event_id":"$KR2trNZom5w5_s5ks32T0zhi3gH2bi-bQ7aQkft7hms"}},"msgtype":"m.text"},"ts":1695240193963,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_zouxl7D2WphEqfXD6sZgcsOxEAXJKi7UCerZuh-Sug"},
{"content":{"body":"> <@shuyuguo:matrix.org> part of my mental model of structs (shared or not) over ordinary objects is \"the shape doesn't change\", and that transitively applies via the prototype chain\n\nWay back when I'd thought to have structs act as value objects, my intuition was that the prototype would be looked up during ToObject just like we do for `Number`, `String`, etc. so it had no bearing on the shape of struct's runtime representation.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$RsKmJhRdM368stwF-95kqIgso3dnf34ub0J2q7uwN2M?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>part of my mental model of structs (shared or not) over ordinary objects is &quot;the shape doesn&#39;t change&quot;, and that transitively applies via the prototype chain</blockquote></mx-reply>Way back when I'd thought to have structs act as value objects, my intuition was that the prototype would be looked up during ToObject just like we do for <code>Number</code>, <code>String</code>, etc. so it had no bearing on the shape of struct's runtime representation.","m.relates_to":{"m.in_reply_to":{"event_id":"$RsKmJhRdM368stwF-95kqIgso3dnf34ub0J2q7uwN2M"}},"msgtype":"m.text"},"ts":1695240269313,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cLDxrSRwertgIGrhFVpS2IdN7t9cbh6NM0xXdXF4Yts"},
{"content":{"body":"yes, that is a competing model","msgtype":"m.text"},"ts":1695240295883,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$XE7iiwhpBSF3DRjs4bWV_hlh_elvZ807v5A8FW-xBCA"},
{"content":{"body":"That's not the case now, but I still don't find see the necessity for a fixed shape for the prototype.","msgtype":"m.text"},"ts":1695240311552,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JunI-q2YQ-zV35b_6LcHPTqR0_aNhT0wLdBUJSzBbqA"},
{"content":{"body":"and i am open to be convinced of that competing model","msgtype":"m.text"},"ts":1695240322482,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$gzAn1OMdCcZYk0ofS-oqvF1DwpT_4yAbL2m1ysTBldw"},
{"content":{"body":"it has some attractive properties, like, the dynamism feels more at home with the rest of the language","msgtype":"m.text"},"ts":1695240340764,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$i2tXNKyC8sZ2Tst5rSPzhWJg2jvPmgi5euh7vQAXxQ4"},
{"content":{"body":"it has an exact parallel to primitive prototype wrapping, as you've pointed out","msgtype":"m.text"},"ts":1695240349063,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$lQnA5AoWCuNxDHqx7J1TKdBAt5EitIxLpWcXhbcoahg"},
{"content":{"body":"The caveat is that it doesn't translate well to multiple realms in the same Agent","msgtype":"m.text"},"ts":1695240370852,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$i8AmER-Dy_GhqHzQbq1f0iT3GdsLxtMt99OiJrKeRg4"},
{"content":{"body":"Unless you need to somehow define behavior independently per realm.","msgtype":"m.text"},"ts":1695240394116,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Cf0CG-xq-YyibLyASTaLC49ESCBwl1rBjIlF2afHP_M"},
{"content":{"body":"Which would be another spanner to throw into the behavior assignment discussion :)","msgtype":"m.text"},"ts":1695240428224,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$h-vwKW6yzpA0FvNL_561HFhSK6mJ-6yBxDddL58Ojhc"},
{"content":{"body":"the downside to the primitive-like wrapping model is i had harbored some hopes \"fixed layout\" would translate to \"easy\" static analyzability of static property access on struct instances","msgtype":"m.text"},"ts":1695240457748,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$RfXDkh_qTihvRXsrbzMJGozZE3HUjpuEGMHZBOGfVo0"},
{"content":{"body":"but if for knowing the location `s.p` requires giving up if `p` is from the prototype, that's too bad","format":"org.matrix.custom.html","formatted_body":"but if for knowing the location <code>s.p</code> requires giving up if <code>p</code> is from the prototype, that's too bad","msgtype":"m.text"},"ts":1695240486670,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$lqFdc_rYEnqRtzBidcg5uAYYijOyC0lCbsPSpXg7aPU"},
{"content":{"body":"it's not the end of the world or anything","msgtype":"m.text"},"ts":1695240491194,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5oYN06zAJMYj5ttey9yHVFpi9q6e6QwOZFH5gs7FBx4"},
{"content":{"body":"> <@rbuckton:matrix.org> The caveat is that it doesn't translate well to multiple realms in the same Agent\n\neh, i don't think it's a big stretch to choose per-realm instead of per-agent. in the p95 case i imagine apps have 1 realm per agent","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$i8AmER-Dy_GhqHzQbq1f0iT3GdsLxtMt99OiJrKeRg4?via=matrix.org&via=igalia.com&via=tchncs.de\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>The caveat is that it doesn&#39;t translate well to multiple realms in the same Agent</blockquote></mx-reply>eh, i don't think it's a big stretch to choose per-realm instead of per-agent. in the p95 case i imagine apps have 1 realm per agent","m.relates_to":{"m.in_reply_to":{"event_id":"$i8AmER-Dy_GhqHzQbq1f0iT3GdsLxtMt99OiJrKeRg4"}},"msgtype":"m.text"},"ts":1695240551360,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$szpeL4yXfG-XVBxHonskSYmGBgWB7jipGPspU2On8AE"},
{"content":{"body":"i'm pretty neutral on whether to choose per-realm or per-agent. agent is not a notion we expose right now, but realms are, so that's more natural","msgtype":"m.text"},"ts":1695240587518,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$g6cBSWBw01aNo34nbQl7MPIBOAMxZZ1sJwOmoZnETrE"},
{"content":{"body":"you end up with weird DX papercuts if you _do_ work with multiple realms in the same agent, but i guess any app that works with multiple realms already must deal with identity discontinuity to some extent","format":"org.matrix.custom.html","formatted_body":"you end up with weird DX papercuts if you <em>do</em> work with multiple realms in the same agent, but i guess any app that works with multiple realms already must deal with identity discontinuity to some extent","msgtype":"m.text"},"ts":1695240615169,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$qtzx-ZX87jSSHFPhXe_En03-pnP225qsYlZHXe1nGrU"},
{"content":{"body":"okay, let's continue the thought experiment down the path of relaxing the fixed layout constraint to not apply to nonshared prototypes","msgtype":"m.text"},"ts":1695240681390,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ecr7XeOGSMenvOJ42ZMDQ7mAJbll2gsC_BrGrn34zIs"},
{"content":{"body":"how would you express that in syntax?","msgtype":"m.text"},"ts":1695240685387,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$hyekrUWGYZqj00F6tJqbeCxjMUXmOjegnotLf7mtEOw"},
{"content":{"body":"and how would we take care to not preclude a future with actual shareable functions","msgtype":"m.text"},"ts":1695240723836,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$wqDRBX-I-Whf3MmDyjrlMDMzLjChpFaarJDooOpIEEE"},
{"content":{"body":"> <@rbuckton:matrix.org> What collisions? What is forgeable? The only thing user-provided is the correlation token used to explain what prototype to choose for a foreign struct within an Agent, and that only affects that Agent's view of the struct, not any other agent.\n\nOk so we're in the case of the agent pair having a string keyed correlation registry at initialization of the connection, which I agreed seems fine at first sight, but I still feel weird about, and need to think more about it.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$_zouxl7D2WphEqfXD6sZgcsOxEAXJKi7UCerZuh-Sug?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>What collisions? What is forgeable? The only thing user-provided is the correlation token used to explain what prototype to choose for a foreign struct within an Agent, and that only affects that Agent's view of the struct, not any other agent.</blockquote></mx-reply>Ok so we're in the case of the agent pair having a string keyed correlation registry at initialization of the connection, which I agreed seems fine at first sight, but I still feel weird about, and need to think more about it.","m.relates_to":{"m.in_reply_to":{"event_id":"$_zouxl7D2WphEqfXD6sZgcsOxEAXJKi7UCerZuh-Sug"}},"msgtype":"m.text"},"ts":1695240749280,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$-hmyGr_xoMIIif6Zi_6TJo6o7CXbyB9PSRr_krn4ULk"},
{"content":{"body":"> <@rbuckton:matrix.org> Which would be another spanner to throw into the behavior assignment discussion :)\n\nYeah I've been pondering that one myself, but avoided bringing it up","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$h-vwKW6yzpA0FvNL_561HFhSK6mJ-6yBxDddL58Ojhc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Which would be another spanner to throw into the behavior assignment discussion :)</blockquote></mx-reply>Yeah I've been pondering that one myself, but avoided bringing it up","m.relates_to":{"m.in_reply_to":{"event_id":"$h-vwKW6yzpA0FvNL_561HFhSK6mJ-6yBxDddL58Ojhc"}},"msgtype":"m.text"},"ts":1695240800681,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$WD46y9Ilu27P01ZV2haqfQy5YwKG5v3rfoHIWTAmf4g"},
{"content":{"body":"Mathieu Hofman: i take it you'd prefer per-realm over per-agent?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>: i take it you'd prefer per-realm over per-agent?","msgtype":"m.text"},"ts":1695240824732,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$nm-EAYvwSNCpPY1X3ymqVo1I8v4GX-5_DdFXKFih7Xs"},
{"content":{"body":"I'm not sure any handshake mechanism will work per-realm unless you have to establish the handshake when the realm is created, and you can't do that in the browser on the main thread with frames.","msgtype":"m.text"},"ts":1695240928079,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$I6svEcsFY9clPiiobvaYvNXcsAWUJONtYZsdDk0j6cE"},
{"content":{"body":"ah i hadn't thought that far, that's what you meant by spanner","msgtype":"m.text"},"ts":1695240955476,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$nO_w_cnDag_f7mWnfRLLnaWnHIGVINsTiteAzgqLCCc"},
{"content":{"body":"Well let's say I don't want this to enable a realm to discover the object graph of another realm, if they were previously isolated. I think that's my constraint","msgtype":"m.text"},"ts":1695241007008,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Rt7iIhsaC_MmGdZKpN5xlVhM9hz7Ar6GsoxBd9LXuAQ"},
{"content":{"body":"to answer my own syntax question earlier, this could work:\n\n```\nshared struct class S {\n  static nonshared prototype;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>to answer my own syntax question earlier, this could work:</p>\n<pre><code>shared struct class S {\n  static nonshared prototype;\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1695241037871,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$2ZZVPL9-hAk73VIy3wf8DkiQUZBxKjmaYOilKND-bnk"},
{"content":{"body":"since currently, having `static prototype` is an early error","format":"org.matrix.custom.html","formatted_body":"since currently, having <code>static prototype</code> is an early error","msgtype":"m.text"},"ts":1695241047655,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$IRataQlqy07ylBvXdnKSwHJaS4gNkMzs4lfpjHxtDJQ"},
{"content":{"body":"That's a bit strange, and it doesnt seem like it would work well with method declarations.","msgtype":"m.text"},"ts":1695241101927,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OcAoWBvvUXDRY3qSnF3ypQN9R7IxAF09vcjrXaQ2eOo"},
{"content":{"body":"why wouldn't it work well with method declarations?","msgtype":"m.text"},"ts":1695241155480,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ZGNAL5O8RvSSmPAUY39ZKuRug7__pfnfgW_H7B0q0CE"},
{"content":{"body":"It looks a bit like a field declaration.","msgtype":"m.text"},"ts":1695241181184,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RVwNteo-PpsTN0_mhHdBZ1kv8BtJiFcxsiRS_y3IPGQ"},
{"content":{"body":"(and to clarify, are you thinking of method declarations in the possible future where they are specially-packaged-and-cloned, or the possible future where we have some exotic new callable that's truly shared)","msgtype":"m.text"},"ts":1695241204277,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mHfDQRrZoHw_NFFtqsS-_76f4oL93imyvnk2YTG8PLE"},
{"content":{"body":"I'm considering both","msgtype":"m.text"},"ts":1695241248668,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$U-bPKUaV8ZHp9bKGsZA9-LbgwXrGlz1D02f9_UgQg_8"},
{"content":{"body":"> <@rbuckton:matrix.org> It looks a bit like a field declaration.\n\nindeed. my thought it's \"modifying\" the field","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$RVwNteo-PpsTN0_mhHdBZ1kv8BtJiFcxsiRS_y3IPGQ?via=matrix.org&via=igalia.com&via=tchncs.de\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>It looks a bit like a field declaration.</blockquote></mx-reply>indeed. my thought it's \"modifying\" the field","m.relates_to":{"m.in_reply_to":{"event_id":"$RVwNteo-PpsTN0_mhHdBZ1kv8BtJiFcxsiRS_y3IPGQ"}},"msgtype":"m.text"},"ts":1695241277135,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$hI7lQhYWc56A_TUO2LkjWqpHFM4N_UgzgJgbJNXw3jA"},
{"content":{"body":"well, the internal slot","msgtype":"m.text"},"ts":1695241282309,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$UWFB5bHmdLF34gO35tugNiSaUrVfC8PvMp_OiwjoG1Y"},
{"content":{"body":"I need to think on that a bit.","msgtype":"m.text"},"ts":1695241320072,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$EeXDfVsVMUkIEei0DiomKAuAcd7hJq1L4PUmaLF05X0"},
{"content":{"body":"it's by all means just an incantation","msgtype":"m.text"},"ts":1695241364755,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$EW1khN_G1N7426t06BFC46dDObGKA0DJuXqb4RRgC-g"},
{"content":{"body":"not a composable bit of syntax","msgtype":"m.text"},"ts":1695241367930,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$UXI2XgmWQ5ytjnAIFDX97QvNrANSle8-DgqwiQUOQLk"},
{"content":{"body":"ideas welcome, certainly, most things i've thought of are even uglier","msgtype":"m.text"},"ts":1695241378713,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$uvMB8GOCCTObMvjOWf0rMac8s7L0WdlwQGCJYNGSQUQ"},
{"content":{"body":"You want a syntax that:\n- allows you to opt in or out of sharing for `struct` (for non-shared structs)\n- allows you to opt in or out of sharing for instance fields (for shared structs)\n- allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)\n- allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)\n- allows you to opt in or out of sharing for the prototype (for shared structs)\n- allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists) \n- maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)\nDoes that cover everything?","format":"org.matrix.custom.html","formatted_body":"<p>You want a syntax that:</p>\n<ul>\n<li>allows you to opt in or out of sharing for <code>struct</code> (for non-shared structs)</li>\n<li>allows you to opt in or out of sharing for instance fields (for shared structs)</li>\n<li>allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)</li>\n<li>allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)</li>\n<li>allows you to opt in or out of sharing for the prototype (for shared structs)</li>\n<li>allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)</li>\n<li>maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)<br>Does that cover everything?</li>\n</ul>\n","msgtype":"m.text"},"ts":1695241505659,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ALrtGvwdY1DXq2xgnth4v0m8uHRMX0uDlQCeJ34FDw4"},
{"content":{"body":" * You want a syntax that:\n\n- allows you to opt in or out of sharing for `struct` (for non-shared structs)\n- allows you to opt in or out of sharing for instance fields (for shared structs)\n- allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)\n- allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)\n- allows you to opt in or out of sharing for the prototype (for shared structs)\n- allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)\n- maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)\n\nDoes that cover everything?","format":"org.matrix.custom.html","formatted_body":" * <p>You want a syntax that:</p>\n<ul>\n<li>allows you to opt in or out of sharing for <code>struct</code> (for non-shared structs)</li>\n<li>allows you to opt in or out of sharing for instance fields (for shared structs)</li>\n<li>allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)</li>\n<li>allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)</li>\n<li>allows you to opt in or out of sharing for the prototype (for shared structs)</li>\n<li>allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)</li>\n<li>maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)</li>\n</ul>\n<p>Does that cover everything?</p>\n","m.new_content":{"body":"You want a syntax that:\n\n- allows you to opt in or out of sharing for `struct` (for non-shared structs)\n- allows you to opt in or out of sharing for instance fields (for shared structs)\n- allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)\n- allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)\n- allows you to opt in or out of sharing for the prototype (for shared structs)\n- allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)\n- maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)\n\nDoes that cover everything?","format":"org.matrix.custom.html","formatted_body":"<p>You want a syntax that:</p>\n<ul>\n<li>allows you to opt in or out of sharing for <code>struct</code> (for non-shared structs)</li>\n<li>allows you to opt in or out of sharing for instance fields (for shared structs)</li>\n<li>allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)</li>\n<li>allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)</li>\n<li>allows you to opt in or out of sharing for the prototype (for shared structs)</li>\n<li>allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)</li>\n<li>maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)</li>\n</ul>\n<p>Does that cover everything?</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$ALrtGvwdY1DXq2xgnth4v0m8uHRMX0uDlQCeJ34FDw4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695241521380,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$EstwwtT5mnNP5xa6TsWhnmBjyyvfTJj6FvdLS-keTJ8"},
{"content":{"body":" * You want a syntax that:\n\n- allows you to opt in or out of sharing for `struct` (for non-shared structs)\n- allows you to opt in or out of sharing for instance fields (for shared structs)\n- allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)\n- allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)\n- allows you to opt in or out of sharing for the prototype (for shared structs)\n- maybe allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)\n- maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)\n\nDoes that cover everything?","format":"org.matrix.custom.html","formatted_body":" * <p>You want a syntax that:</p>\n<ul>\n<li>allows you to opt in or out of sharing for <code>struct</code> (for non-shared structs)</li>\n<li>allows you to opt in or out of sharing for instance fields (for shared structs)</li>\n<li>allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)</li>\n<li>allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)</li>\n<li>allows you to opt in or out of sharing for the prototype (for shared structs)</li>\n<li>maybe allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)</li>\n<li>maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)</li>\n</ul>\n<p>Does that cover everything?</p>\n","m.new_content":{"body":"You want a syntax that:\n\n- allows you to opt in or out of sharing for `struct` (for non-shared structs)\n- allows you to opt in or out of sharing for instance fields (for shared structs)\n- allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)\n- allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)\n- allows you to opt in or out of sharing for the prototype (for shared structs)\n- maybe allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)\n- maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)\n\nDoes that cover everything?","format":"org.matrix.custom.html","formatted_body":"<p>You want a syntax that:</p>\n<ul>\n<li>allows you to opt in or out of sharing for <code>struct</code> (for non-shared structs)</li>\n<li>allows you to opt in or out of sharing for instance fields (for shared structs)</li>\n<li>allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)</li>\n<li>allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)</li>\n<li>allows you to opt in or out of sharing for the prototype (for shared structs)</li>\n<li>maybe allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)</li>\n<li>maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)</li>\n</ul>\n<p>Does that cover everything?</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$ALrtGvwdY1DXq2xgnth4v0m8uHRMX0uDlQCeJ34FDw4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695241544344,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$umyRG8ZemwyS2Qs5Kkmya8MjAYz4zZ0ae4tsqtasS1M"},
{"content":{"body":"that seems comprehensive\n\n- for the MVP, i think \"allows you to opt in or out of sharing for instance fields (for shared structs)\" can be scrapped if we go with opting in or out of making prototype itself nonshared. if you need to express agent-localness manually, you can use a WeakMap\n- i think \"allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)\" shouldn't be a toggle but a choice we make. either we decide the fixed layout invariant extends transitively up the proto chain, or it's limited to instance layout only\n\n","format":"org.matrix.custom.html","formatted_body":"<p>that seems comprehensive</p>\n<ul>\n<li>for the MVP, i think \"allows you to opt in or out of sharing for instance fields (for shared structs)\" can be scrapped if we go with opting in or out of making prototype itself nonshared. if you need to express agent-localness manually, you can use a WeakMap</li>\n<li>i think \"allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)\" shouldn't be a toggle but a choice we make. either we decide the fixed layout invariant extends transitively up the proto chain, or it's limited to instance layout only</li>\n</ul>\n","msgtype":"m.text"},"ts":1695241696082,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mT-OxVTMUkirIhJ9BbO7Q_yZJtM1CinpT-h0469W9qk"},
{"content":{"body":"If possible I'd like to *not* have to go indirectly through a WeakMap.","format":"org.matrix.custom.html","formatted_body":"If possible I'd like to <em>not</em> have to go indirectly through a WeakMap.","msgtype":"m.text"},"ts":1695241741659,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yMy94gLubFa396rlxTsJhErXfuITz-V-Qr4BB25QGkI"},
{"content":{"body":"for arbitrary fields?","msgtype":"m.text"},"ts":1695241756357,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$IvbOXq9RlxDkECZ1E84Hnx8RMvOKft6VETUkxTKTQ94"},
{"content":{"body":"I'd also like to find a way to allow private fields, even if that privacy is only agent-local.","msgtype":"m.text"},"ts":1695241783690,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yaf7uz5PK-tB-TUUte9Yz_jzGurO7_QvfX3B9R0_twI"},
{"content":{"body":" * I'd also like to find a way to allow _shared_ private fields, even if that privacy is only agent-local.","format":"org.matrix.custom.html","formatted_body":" * I'd also like to find a way to allow <em>shared</em> private fields, even if that privacy is only agent-local.","m.new_content":{"body":"I'd also like to find a way to allow _shared_ private fields, even if that privacy is only agent-local.","format":"org.matrix.custom.html","formatted_body":"I'd also like to find a way to allow <em>shared</em> private fields, even if that privacy is only agent-local.","msgtype":"m.text"},"m.relates_to":{"event_id":"$yaf7uz5PK-tB-TUUte9Yz_jzGurO7_QvfX3B9R0_twI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695241792394,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ihIx1k_sAIrrAsecIPYyG48jnTW6_guPva_Pas17tIg"},
{"content":{"body":"let's punt on private fields for now :)","msgtype":"m.text"},"ts":1695241854463,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6lEq2Bh_1BosQIcQiXVKGLPOoAUVcwAgCABTOBS5jy8"},
{"content":{"body":"I'm not sure if its feasible, but I'd like to find a way to consider it.","msgtype":"m.text"},"ts":1695241856857,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QdDAQJSD-cZw99cl6tnTO3VIVCg7HgXzX7GuXnBvfz8"},
{"content":{"body":"a big part of the reason i've moved back to thinking thread-local prototype being the superior solution is the performance footgun aspect of heavy thread-local field usage","msgtype":"m.text"},"ts":1695241918742,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$MuLe3UpiE3VnI-ZyuJQNRfH3uR4tVMRqrjXGlYFPYyc"},
{"content":{"body":"I'm writing *a lot* of shared structs using TypeScript's soft `private` currently.","format":"org.matrix.custom.html","formatted_body":"I'm writing <em>a lot</em> of shared structs using TypeScript's soft <code>private</code> currently.","msgtype":"m.text"},"ts":1695241924452,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BnK5tJtWNaHZuYypS-kS50tWqVhgZLmKNL9G5PzDe5A"},
{"content":{"body":"the performance will be so extremely different, yet looks the same","msgtype":"m.text"},"ts":1695241929596,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$emk6Fu6mM04vUWyCqcL0EuvWaLYBwJyZYIjWbKJKs1Y"},
{"content":{"body":"if we bottleneck that thread-local lookup to be just on [[Prototype]], then we ease the performance footgun concerns","msgtype":"m.text"},"ts":1695241965727,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$IqZhISdcGzwvyUGdAWzBtbsnFGkSnX4bPGZwF_YK8qY"},
{"content":{"body":"the expressivity still exists with WeakMaps","msgtype":"m.text"},"ts":1695241983583,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$QAuwLcvqbzqKiLmw-WWWkvRUQxE-TCfqDWEoOBuPHTE"},
{"content":{"body":"private names should just work, with the big exception of the lexical scoping of `#`-names","format":"org.matrix.custom.html","formatted_body":"private names should just work, with the big exception of the lexical scoping of <code>#</code>-names","msgtype":"m.text"},"ts":1695242063148,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$J4qHx_cWSswbSi8ga2BOHT14qzUV7AoMODGvDe_WoKE"},
{"content":{"body":"so the per-agent privacy \"just works\" but that feels weird","msgtype":"m.text"},"ts":1695242086481,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$PYNK39Ua1t_qaH3kGJqMr3an1iWdhX72Nuw8Ceffjb4"},
{"content":{"body":"well no, \"just works\" is too strong. there will need to syntax changes to allow `#`-names to be scoped in such a way that allows it to even be expressed with struct declarations","format":"org.matrix.custom.html","formatted_body":"well no, \"just works\" is too strong. there will need to syntax changes to allow <code>#</code>-names to be scoped in such a way that allows it to even be expressed with struct declarations","msgtype":"m.text"},"ts":1695242179754,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$smfoCt15NFhAPBhfNU7C2JLp-uxzK-2fdjgRae8sGgY"},
{"content":{"body":"The issue with private names is whether `#foo` is accessible inside of a nonshared method in two different threads.","format":"org.matrix.custom.html","formatted_body":"The issue with private names is whether <code>#foo</code> is accessible inside of a nonshared method in two different threads.","msgtype":"m.text"},"ts":1695242240920,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_fVkyhw3Fu2swYYJiihcPMVfytK77bxWVWjogayI6Sk"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1695242259761,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$N07c5m9jLb7ye_FMyHjFNf57BGqdi00rrQ9jURhjUes"},
{"content":{"body":"for it to be useful, it has to be. But that weakens privacy.","msgtype":"m.text"},"ts":1695242282587,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NOB9bf10K3U92jWOnxCjshdYtn1G00PYTIujDUs8fTA"},
{"content":{"body":"So you either need to:\n- disallow privacy\n- disallow access to private names from one thread in another thread\n- weak privacy for shared structs\n- provide a friendship mechanism that you can somehow share in a trusted manner when handshaking with a child thread.","format":"org.matrix.custom.html","formatted_body":"<p>So you either need to:</p>\n<ul>\n<li>disallow privacy</li>\n<li>disallow access to private names from one thread in another thread</li>\n<li>weak privacy for shared structs</li>\n<li>provide a friendship mechanism that you can somehow share in a trusted manner when handshaking with a child thread.</li>\n</ul>\n","msgtype":"m.text"},"ts":1695242384078,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xr6uewwDn8LPgAlizpeeiKLlVuiYe6QkktUCCHTBbMM"},
{"content":{"body":" * So you either need to:\n\n1. disallow privacy\n2. disallow access to private names from one thread in another thread\n3. weak privacy for shared structs\n4. provide a friendship mechanism that you can somehow share in a trusted manner when handshaking with a child thread.","format":"org.matrix.custom.html","formatted_body":" * <p>So you either need to:</p>\n<ol>\n<li>disallow privacy</li>\n<li>disallow access to private names from one thread in another thread</li>\n<li>weak privacy for shared structs</li>\n<li>provide a friendship mechanism that you can somehow share in a trusted manner when handshaking with a child thread.</li>\n</ol>\n","m.new_content":{"body":"So you either need to:\n\n1. disallow privacy\n2. disallow access to private names from one thread in another thread\n3. weak privacy for shared structs\n4. provide a friendship mechanism that you can somehow share in a trusted manner when handshaking with a child thread.","format":"org.matrix.custom.html","formatted_body":"<p>So you either need to:</p>\n<ol>\n<li>disallow privacy</li>\n<li>disallow access to private names from one thread in another thread</li>\n<li>weak privacy for shared structs</li>\n<li>provide a friendship mechanism that you can somehow share in a trusted manner when handshaking with a child thread.</li>\n</ol>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$xr6uewwDn8LPgAlizpeeiKLlVuiYe6QkktUCCHTBbMM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695242412585,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VjMpfHSjWvWDn8wrCsb4A-MvYjZcP4WcrQEw59ePgtM"},
{"content":{"body":"I think (2) is unusable, I'm sure someone won't be happy with (3), and I don't have a solution for (4) yet.","msgtype":"m.text"},"ts":1695242486698,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Za7uUPjYTAxkCuDyU-QzjV3fNdOjw-Tp90JAnW-IFj8"},
{"content":{"body":"nonshared private fields are definitely doable.","msgtype":"m.text"},"ts":1695242511705,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$L5Pm6dVz6L1ss3-_5DpHxOykzH8cNM3s0o_6oFHSlNo"},
{"content":{"body":"> <@shuyuguo:matrix.org> the performance will be so extremely different, yet looks the same\n\nI'd still rather have them, even if we need a different or additional scary-sounding keyword in the field declaration.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$emk6Fu6mM04vUWyCqcL0EuvWaLYBwJyZYIjWbKJKs1Y?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>the performance will be so extremely different, yet looks the same</blockquote></mx-reply>I'd still rather have them, even if we need a different or additional scary-sounding keyword in the field declaration.","m.relates_to":{"m.in_reply_to":{"event_id":"$emk6Fu6mM04vUWyCqcL0EuvWaLYBwJyZYIjWbKJKs1Y"}},"msgtype":"m.text"},"ts":1695242551715,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RwP-QXRhQo1CsS6VS9uK5cICBA8_BU6GN99gzKi8190"},
{"content":{"body":"yeah perhaps","msgtype":"m.text"},"ts":1695242625071,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cwNvUvlIMYjA-q6OyXBp4IwpbCsOYrUus7ukiiGe1HA"},
{"content":{"body":"i agree (2) will be unusable","msgtype":"m.text"},"ts":1695242630763,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$_0v34GyrqGix9dxzEcVl1YDBRdKsayZPlH_vhckv7kU"},
{"content":{"body":"For private names, we could make you explicitly annotate them as `shared` to get the point across that their privacy is weaker.","format":"org.matrix.custom.html","formatted_body":"For private names, we could make you explicitly annotate them as <code>shared</code> to get the point across that their privacy is weaker.","msgtype":"m.text"},"ts":1695242673677,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eatlHFUBeMJPSTDzjT_Mrv6BetDsuNFAyWeBa6iK-VA"},
{"content":{"body":"the only solution that composes i can think of is some kind of new exotic callable that's threadsafe","msgtype":"m.text"},"ts":1695242674372,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mez4Ad7F3rI_iZiyaKR6mUB776nZZA491Rc8XfrV22M"},
{"content":{"body":"and that this new exotic callable can close over `#` names","format":"org.matrix.custom.html","formatted_body":"and that this new exotic callable can close over <code>#</code> names","msgtype":"m.text"},"ts":1695242688354,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Kd53mXHzolJtkDCZG_YlSU_maRF2UCr9SX3dLTjNWHw"},
{"content":{"body":"but it can't close over normal bindings","msgtype":"m.text"},"ts":1695242707904,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$b2OWHZYnR5XabmwwVN2_biwbo1jBa1oAI-HD8P9r3SM"},
{"content":{"body":"nobody liked the exotic callable idea the first time i brought it up though","msgtype":"m.text"},"ts":1695242718489,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$s3-SrVNgjJLwlz7SEsqt6tuPdYrc2d2A5np89oaQxuw"},
{"content":{"body":"why would we need that?","msgtype":"m.text"},"ts":1695242729037,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WHtm6ByaDctJ38UY6iZkAZH3MWxaiT22tPJfE_JAT8k"},
{"content":{"body":"And I'm not even sure how you'd use that","msgtype":"m.text"},"ts":1695242753773,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$q2fgKmr0g1_bPC7gJ9rm7FkBPJkigQRYl36tjh-I31Q"},
{"content":{"body":"the private names thing can fall out of that, what i had in mind:\n\n```\nshared struct class S {\n  #x;\n  shared getX() { return this.#x; } // <- new exotic callable, can't close normal bindings, [[Realm]]-less, etc\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>the private names thing can fall out of that, what i had in mind:</p>\n<pre><code>shared struct class S {\n  #x;\n  shared getX() { return this.#x; } // &lt;- new exotic callable, can't close normal bindings, [[Realm]]-less, etc\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1695242807759,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$NC8R9VaSy5Ect-gBi_GRa7HbwJeuNjILnMzVai3yluE"},
{"content":{"body":"In the \"weaker privacy\" model I was thinking about, private names are part of the type identity associated with a shared struct, and the handshake process that provides correlation between an exemplar and a prototype could be smart enough to correlate the private name as well.","msgtype":"m.text"},"ts":1695242835004,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1ThTiQcjV0tgYuB4O2P0obEgRWrCS4Ut9QGezbGaSTY"},
{"content":{"body":"in the evaluation of `S` above, `#x` gets evaluated once and is closed over by this new shareable exotic callable, and you use those methods on instances and things just work","format":"org.matrix.custom.html","formatted_body":"in the evaluation of <code>S</code> above, <code>#x</code> gets evaluated once and is closed over by this new shareable exotic callable, and you use those methods on instances and things just work","msgtype":"m.text"},"ts":1695242882930,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9nph0Vt1URmSq09HmzGVnJLVU4knzqQ92pukmmtMtfM"},
{"content":{"body":"we can't do this with normal functions obvoiusly because they're not shared things","msgtype":"m.text"},"ts":1695242896278,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mTas_xj0ckiuxrsZ1UQ3nU7AAu2MhuU5LeI4VAXVWGk"},
{"content":{"body":"So you do:\n```\n// structs.js\nexport shared struct S {\n  shared #x; // weak shared private name\n  \n  nonshared getX() {\n    return this.#x; // private name access is correlated for foreign struct types.\n  }\n}\n\n// preload.js\nimport { S } from \"./structs.js\";\nprepareWorker({ structs: { S } });\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>So you do:</p>\n<pre><code>// structs.js\nexport shared struct S {\n  shared #x; // weak shared private name\n  \n  nonshared getX() {\n    return this.#x; // private name access is correlated for foreign struct types.\n  }\n}\n\n// preload.js\nimport { S } from \"./structs.js\";\nprepareWorker({ structs: { S } });\n</code></pre>\n","msgtype":"m.text"},"ts":1695242958213,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oAIU8F2-Ez646JseDY38zojV-lDPxZF2YwxYaFAGgrE"},
{"content":{"body":"You just have the private name itself be correlated.","msgtype":"m.text"},"ts":1695242981668,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mDazkjt-6M7pairANXTxOKeUb5gjtD70_NGu_JtghgY"},
{"content":{"body":"not sure i grasp on the correlation works","msgtype":"m.text"},"ts":1695243009557,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$oBk-fifhCn7gHAN1uV1XW4jzkU_WTLUS-jKW_UXtn6A"},
{"content":{"body":" * not sure i grasp how the correlation works","m.new_content":{"body":"not sure i grasp how the correlation works","msgtype":"m.text"},"m.relates_to":{"event_id":"$oBk-fifhCn7gHAN1uV1XW4jzkU_WTLUS-jKW_UXtn6A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695243016123,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$elbD5ConhClclNCUTqFKOlp-s6CHWHs4-w-3_SKf4cM"},
{"content":{"body":"though that is a step towards always using `shared struct` declarations for handshaking rather than just an exemplar and a prototype.","format":"org.matrix.custom.html","formatted_body":"though that is a step towards always using <code>shared struct</code> declarations for handshaking rather than just an exemplar and a prototype.","msgtype":"m.text"},"ts":1695243040620,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7oJx77Rr67vBzD9LKmneaZGdKAsjZH-RH1UZoTCdCXw"},
{"content":{"body":"I'll see if I can summarize?","msgtype":"m.text"},"ts":1695243059102,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VigzYJNQFjEeFiNMJdQ_wQsUCX0-EJuFPI-QpTgGocM"},
{"content":{"body":"i have a harebarined worse-is-better idea","msgtype":"m.text"},"ts":1695243377004,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$JXJihGFwtU92CdeHZPZeshiy3lnjTX08T42CYkOEALo"},
{"content":{"body":" * i have a harebrained worse-is-better idea","m.new_content":{"body":"i have a harebrained worse-is-better idea","msgtype":"m.text"},"m.relates_to":{"event_id":"$JXJihGFwtU92CdeHZPZeshiy3lnjTX08T42CYkOEALo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695243383835,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$HLFgRvwD6Y2da7l6esjdvVRpqYlWAsJQqUseQRQvA4c"},
{"content":{"body":"- Each agent maintains an independent registry of the shared struct types created within the agent.\n- Each registry is linked bi-directionally to the agent that spawned the thread/agent.\n- When spinning up a new `Worker`, you provide a set of shared struct types to correlate with the worker. In previous discussions these were exemplar structs, but we only really need the type identity of the shared struct type.\n- When the worker starts up, it has a \"preload\" phase where it can handle its side of the handshake, and provide a set of shared struct types to correlate with the parent thread.\n- During preload, the child thread cannot otherwise communicate with the parent thread via the worker/message port (any `postMessage`/`onmessage` ends up queued until the handshake has finished).\n- In the agent registry, or in a global registry, you use this correlation information to establish how to treat any given shared struct in a foreign Agent.\n- When you look up the prototype of a non-local shared struct, you interrogate the registry for an agent-local prototype to use based on this correlation information.\n- By the time you can actually invoke `[[GetPrototypeOf]]`, all information you would need to correlate and resolve the prototype of a given shared struct should be known to the system.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>Each agent maintains an independent registry of the shared struct types created within the agent.</li>\n<li>Each registry is linked bi-directionally to the agent that spawned the thread/agent.</li>\n<li>When spinning up a new <code>Worker</code>, you provide a set of shared struct types to correlate with the worker. In previous discussions these were exemplar structs, but we only really need the type identity of the shared struct type.</li>\n<li>When the worker starts up, it has a \"preload\" phase where it can handle its side of the handshake, and provide a set of shared struct types to correlate with the parent thread.</li>\n<li>During preload, the child thread cannot otherwise communicate with the parent thread via the worker/message port (any <code>postMessage</code>/<code>onmessage</code> ends up queued until the handshake has finished).</li>\n<li>In the agent registry, or in a global registry, you use this correlation information to establish how to treat any given shared struct in a foreign Agent.</li>\n<li>When you look up the prototype of a non-local shared struct, you interrogate the registry for an agent-local prototype to use based on this correlation information.</li>\n<li>By the time you can actually invoke <code>[[GetPrototypeOf]]</code>, all information you would need to correlate and resolve the prototype of a given shared struct should be known to the system.</li>\n</ul>\n","msgtype":"m.text"},"ts":1695243606328,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QmUwZ2yoxewqKeeycqmuuzUeZIyC01bvhid5PERD9fw"},
{"content":{"body":"i'm not clear on the second-to-last bullet point","msgtype":"m.text"},"ts":1695243721843,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$FTzg6oqxJsvDY6DmgKL2XLWTR8QOsb0t3D2ER2YmWS4"},
{"content":{"body":"how does \"look up the prototype of a non-local shared struct\" differ from `[[GetPrototypeOf]]`?","format":"org.matrix.custom.html","formatted_body":"how does \"look up the prototype of a non-local shared struct\" differ from <code>[[GetPrototypeOf]]</code>?","msgtype":"m.text"},"ts":1695243751097,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6bxJRBTNohuh2jv2DtDyZP6qClpfsiRpzCI-DHnTO3s"},
{"content":{"body":"The last two bullet points are mostly part of the same thing.","msgtype":"m.text"},"ts":1695243878054,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5VY5YGwJ4pY4zwIwZLPDGbAmMoKj45_dY8adjJnRJGc"},
{"content":{"body":"are you saying every `[[GetPrototypeOf]]` of an instance has a pre-hook that does correlation in the registry?","format":"org.matrix.custom.html","formatted_body":"are you saying every <code>[[GetPrototypeOf]]</code> of an instance has a pre-hook that does correlation in the registry?","msgtype":"m.text"},"ts":1695243902310,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$wc0F-t6jvmxMFtATggIOnko8j6jCleB04_Kf_VJq1pQ"},
{"content":{"body":"i was hoping you'd set up the correlation once per type and not incur a check on every `[[GetPrototypeOf]]`","format":"org.matrix.custom.html","formatted_body":"i was hoping you'd set up the correlation once per type and not incur a check on every <code>[[GetPrototypeOf]]</code>","msgtype":"m.text"},"ts":1695243924413,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$upcKN7C4Q-Sof9O24rP6ZTiu3C6TNVcV8voDbPFpA9I"},
{"content":{"body":"There are two options. One is \"when we create the thread local prototype Object for the foreign shared struct type we just received, we can correlate it in the registry\"","msgtype":"m.text"},"ts":1695243944586,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$LngqrjJGdT5zCh5etlorGVR6YZRKamH8evTPG-qFEr4"},
{"content":{"body":"The other is lazily on `[[GetPrototypeOf]]`, but we don't need the laziness if the runtime can do all of this work for you.","format":"org.matrix.custom.html","formatted_body":"The other is lazily on <code>[[GetPrototypeOf]]</code>, but we don't need the laziness if the runtime can do all of this work for you.","msgtype":"m.text"},"ts":1695244086034,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gYzzlvXG2iKWCaAjmvnGv6GU-l2v10mAtBGxaK4NjQo"},
{"content":{"body":"so here's my harebrained worse-is-better idea:\n\n_what if_ `shared struct S { }` declarations evaluated to something that has a special `packageForClone()`, which returns some object that can be reevaluated (like direct eval, but i guess safer?)\n\n```\nshared struct S {\n  static nonshared prototype;\n\n  // The static block gets packaged _as source text_.\n  static {\n    // Set up thread-local prototype\n    this.prototype.method = function() { whatever; }\n  }\n}\n\nlet thing = S.packageForClone();\nthing.evaluate(); // Get a constructor back that can create instances of the same layout. The VM knows it's correlated with `S`-instances. Re-evaluates the static block _from source text_ at the point of evaluation.\n```","format":"org.matrix.custom.html","formatted_body":"<p>so here's my harebrained worse-is-better idea:</p>\n<p><em>what if</em> <code>shared struct S { }</code> declarations evaluated to something that has a special <code>packageForClone()</code>, which returns some object that can be reevaluated (like direct eval, but i guess safer?)</p>\n<pre><code>shared struct S {\n  static nonshared prototype;\n\n  // The static block gets packaged _as source text_.\n  static {\n    // Set up thread-local prototype\n    this.prototype.method = function() { whatever; }\n  }\n}\n\nlet thing = S.packageForClone();\nthing.evaluate(); // Get a constructor back that can create instances of the same layout. The VM knows it's correlated with `S`-instances. Re-evaluates the static block _from source text_ at the point of evaluation.\n</code></pre>\n","msgtype":"m.text"},"ts":1695244220732,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$sflUPATRLTip5Qi-STn61qxE16cczHj479SMxiQmK_4"},
{"content":{"body":"the return value of `packageForClone()` would be special cased in the structured clone algorithm to be cloneable","format":"org.matrix.custom.html","formatted_body":"the return value of <code>packageForClone()</code> would be special cased in the structured clone algorithm to be cloneable","msgtype":"m.text"},"ts":1695244339186,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LKV-BUCudCDdoCIURz42P70w94f0LyXOSWom90vQk3s"},
{"content":{"body":"I still don't think this works because it makes assumptions about what is reachable in the child thread.","msgtype":"m.text"},"ts":1695244538585,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cIQVwfa48ymaXIe9VweprGse7MXIF6w7CIu1BXGmwxo"},
{"content":{"body":"how so?","msgtype":"m.text"},"ts":1695244565130,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$dX4qm5323juOa07zLrFfyXJphm7D-TnZnoC3MeMce9s"},
{"content":{"body":"The child thread might be running from a bundle that doesn't include some module names, because the methods that use them were removed from the child thread bundle due to tree shaking.","msgtype":"m.text"},"ts":1695244589868,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$EYZTttrvj_VReowt8p-_yweyhpDc77FLImWqETjmyY4"},
{"content":{"body":"it's like re-evaling a function's `toString()`, no assumptions are made per se, but if things get DCE'd because the tool wasn't aware it's implicitly being used somehow, then the tool needs those exceptions annotated, yeah","format":"org.matrix.custom.html","formatted_body":"it's like re-evaling a function's <code>toString()</code>, no assumptions are made per se, but if things get DCE'd because the tool wasn't aware it's implicitly being used somehow, then the tool needs those exceptions annotated, yeah","msgtype":"m.text"},"ts":1695244636579,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$djyQ2Zmxc_rPiyEQlx0jcdCNEo-Y1ouinqhQ7zhp8rs"},
{"content":{"body":"And its likely that the child thread already has a copy of all of the necessary behavior in memory, so now we're taking up even more memory in the worker thread for duplicate code.","msgtype":"m.text"},"ts":1695244668752,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$B-YOciATqDTqyhRzVwt9kGMO-zzHAD-EK5MAfkDmedM"},
{"content":{"body":"how did it get the necessary behavior in memory, import? this idea means you never import the right structs, you gotta always postMessage them","msgtype":"m.text"},"ts":1695244716143,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LCcaLci890rsTCZhH0j6UutsB96eydVRq8sekBHR26I"},
{"content":{"body":"but agreed that doesn't feel great","msgtype":"m.text"},"ts":1695244724672,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$tckxKNCHRMMtJowqIwyiPveVMP5920yOQllF2bY9wE8"},
{"content":{"body":"I'm not a fan of that design, tbh. Its too easy for code to become entangled.","msgtype":"m.text"},"ts":1695244770794,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ffq8GytrcSodxS9IL8eu8NvNC_w9X_zsSiz9T6z0ZbE"},
{"content":{"body":"I'll be back in a bit, in a meeting for the next hour.","msgtype":"m.text"},"ts":1695244788905,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$V31jrPdY65ZnYaeQvRKwY_K8RMYzyR9_wnwr6wGjG1c"},
{"content":{"body":"the minimal version of this idea is that shared struct constructors ought to be made structured cloneable in such a way that the VM can keep the type identity correlation across agents","msgtype":"m.text"},"ts":1695244791103,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$IU9Hley0hyXSylzAUaGrSQIZa1EOeAklxXLyhXc7vTA"},
{"content":{"body":"they can be safely cloned because these constructors don't call user code","msgtype":"m.text"},"ts":1695244811523,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$sz3b8j4QRw2DuhxNH1Hi-UgbMUQkTx_Wn8YBwxVqpqw"},
{"content":{"body":"i guess that minimal version can be combined with your registry handshake. it makes the correlation of type identities automatic","msgtype":"m.text"},"ts":1695244862534,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$mDFDjwFwzGpM7dEv_celuLtRzK5LlQ6sc7t63Daeh4A"},
{"content":{"body":"I'm not sure I agree with that approach? I might need my shared struct constructor to access some per-thread configured object that may not be trivially serializable, such as accessing `threadId` in `import { threadId } from \"node:worker_threads\"` or, read from an environment variable via `sys.getEnvironmentVariable(name)`, where `sys` must be correctly initialized for within that thread. ","format":"org.matrix.custom.html","formatted_body":"I'm not sure I agree with that approach? I might need my shared struct constructor to access some per-thread configured object that may not be trivially serializable, such as accessing <code>threadId</code> in <code>import { threadId } from \"node:worker_threads\"</code> or, read from an environment variable via <code>sys.getEnvironmentVariable(name)</code>, where <code>sys</code> must be correctly initialized for within that thread.","msgtype":"m.text"},"ts":1695247586147,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8ACa9FhGkX8IvUf9nV9LuxcWmfZpE3PanDD_28e9k1E"},
{"content":{"body":"And both of these cases are present in the work I'm doing right now.","msgtype":"m.text"},"ts":1695247602545,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$p94RfGPPq1avFvDyrYGsZJCCJ0fJh51MrO9hEtJ-yGE"},
{"content":{"body":"and I definitely want to be able to run user code so that I can appropriately set up shared struct instances, including providing suitable defaults to match the types I'","msgtype":"m.text"},"ts":1695247663451,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YzBXr3muLp-Hxou4At9cki3OnJb2pL6CK6-6ARTnl80"},
{"content":{"body":" * and I definitely want to be able to run user code so that I can appropriately set up shared struct instances, including providing suitable defaults to match the types I've defined.","m.new_content":{"body":"and I definitely want to be able to run user code so that I can appropriately set up shared struct instances, including providing suitable defaults to match the types I've defined.","msgtype":"m.text"},"m.relates_to":{"event_id":"$YzBXr3muLp-Hxou4At9cki3OnJb2pL6CK6-6ARTnl80","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695247668563,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$guSKk7XOhq1oy88e_A0c3SqoRSPkiz0GtamzKVPw5Oo"},
{"content":{"body":"i think we're talking about 2 constructors","msgtype":"m.text"},"ts":1695247685143,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Si8D4x_45QdlHB7gN6xo489nKdkvDOgsQkzirMN6HkU"},
{"content":{"body":"Yes and no.","msgtype":"m.text"},"ts":1695247707869,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gQbh03wgW-Bizl76YyChXa21deVcWPS1n0sJqMaOUcU"},
{"content":{"body":"shared structs don't have user code constructors\n\n(i now also see that the README.md is incorrect)","msgtype":"m.text"},"ts":1695247709576,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$WvXsm1GTTbxzCwu7Pg9sG-s7b33pF52cb4L7OwZpAg4"},
{"content":{"body":"They don't currently, correct.","msgtype":"m.text"},"ts":1695247718891,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$W4F4ubYC3TthEWU2u53MLboCw_b_skvC_P5PgcGAX-U"},
{"content":{"body":"they just have a way to objects of the correct layout, let's call this constructor the \"minter\"","msgtype":"m.text"},"ts":1695247740267,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$luqjEl8AWyiAHoTePRMEbS2oMu2-T0BO2uGS8tmHYQk"},
{"content":{"body":"you can wrap this in a per-thread constructor that does thread-local things","msgtype":"m.text"},"ts":1695247757766,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$4XRE9FITvhehK7X2y3yRG4UIVnGSoFfJDdQPXah5FGY"},
{"content":{"body":"Sure, but you're talking about packing in the prototype members along with that, which we don't do anywhere else in JS.","msgtype":"m.text"},"ts":1695247772261,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$AqaQ1BqGqWBZX0lSJBJ0Kzi36qQxgeDoOw4e-aqxdJI"},
{"content":{"body":"sorry i switched gears","msgtype":"m.text"},"ts":1695247785676,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$OU_Y6hMN4GGKGGd_2EOIrnsp7VVevVQ7fV9_lUHii5g"},
{"content":{"body":"scratch the prototype members idea","msgtype":"m.text"},"ts":1695247790203,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6aVGILNXea0hC3Yuiwxclhn1AQND-5OYfCq2AA5b8fw"},
{"content":{"body":"the minimal version is: the minter, and the minter alone, with no transitive properties, is a cloneable function that can be cloned across worker boundaries","msgtype":"m.text"},"ts":1695247813045,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$lzpO-7Ce-aLRkLSJznJio-qkAggTtyMAj7i-pwDDBsk"},
{"content":{"body":"Ok, but then I don't see why serializing the constructor is useful.","msgtype":"m.text"},"ts":1695247819205,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZWAG2iM9E5wSwnpigi48-koqxFtHse_VKq9nYckjsyM"},
{"content":{"body":"ah, because the VM can keep tabs under the hood that it's correlated with shared structs of a particular type","msgtype":"m.text"},"ts":1695247858003,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$jO44q623GYZy4w66LhqXGwBxh9okykjAX4t2isxam1o"},
{"content":{"body":"but i guess this doesn't work for your approach because you want to be able to\n\n1. import { S } from some place\n2. _then_ correlate them","format":"org.matrix.custom.html","formatted_body":"<p>but i guess this doesn't work for your approach because you want to be able to</p>\n<ol>\n<li>import { S } from some place</li>\n<li><em>then</em> correlate them</li>\n</ol>\n","msgtype":"m.text"},"ts":1695247880979,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$-j1wq426689J6DrvQC0LRkiEbO7TEPwDGMGJGhokZ1Y"},
{"content":{"body":"instead of\n\n1. receive { S } via message from some coordination thread\n2. set up S.prototype","format":"org.matrix.custom.html","formatted_body":"<p>instead of</p>\n<ol>\n<li>receive { S } via message from some coordination thread</li>\n<li>set up S.prototype</li>\n</ol>\n","msgtype":"m.text"},"ts":1695247895435,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$HHrJ6gfU_Jusvp1ZpBngsdhtyd_oAmngD0UlMf2qIrE"},
{"content":{"body":"Those are the same thing to me","msgtype":"m.text"},"ts":1695247918832,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9dH-PDWOMPThJqrf1yVEa2R18ouiECuUnQ3ovaQjv1I"},
{"content":{"body":"Just different levels of abstraction","msgtype":"m.text"},"ts":1695247928388,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ewi8gZLpEintLE1nGm6WwpcGjuiSOIy1YJ76Ht6Jj18"},
{"content":{"body":"they aren't to me, because \"import { S } from some place\" already evaluates and binds an S that we'd need to correlate after-the-fact","msgtype":"m.text"},"ts":1695247947213,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$O-tyRIP4gxzZO0C9wlivPW4oLmRHyFJp4ETAy5aCciA"},
{"content":{"body":"where as \"receive S via message\" gets the right S beforehand with no addition coordination needed","msgtype":"m.text"},"ts":1695247960675,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$g-puXbd9qHekzSRLk_KMoEXRtcI5TBswEuQIf96jvws"},
{"content":{"body":"it's the difference between 2 copies that are correlated and 1 copy","msgtype":"m.text"},"ts":1695247993057,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$yftvjuRmR-XphBJpzObpxrgpKOzWUbPUhlURKIqMfzo"},
{"content":{"body":"Ok, fair. Then the issue I have with the 2nd approach is one of timing. ","msgtype":"m.text"},"ts":1695247998975,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DlWYTDzuecU4Kpbw_PIZ7VJ5wydD93q5_PUWBK430lM"},
{"content":{"body":"right, there is a conceptual startup barrier for all workers","msgtype":"m.text"},"ts":1695248023924,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ks20lV1N_V74x6d7PFdsz2y54WNauWkAwxbMJeC_cD0"},
{"content":{"body":"And some workers might want to be able to create instances of a shared struct type ahead of the handshake process or message or whatever","msgtype":"m.text"},"ts":1695248057487,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nfLNNhNVNSeF8ftdm_QzR2BD0VE7g7SMS8ed9YhG8Vg"},
{"content":{"body":"Because sometimes I need to set up singleton values or run code against objects that also happen to be shared.","msgtype":"m.text"},"ts":1695248079724,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BaaKTJEPBwVt4J5Dr0dtujFSDXcXZl4RuCp7uRiprf0"},
{"content":{"body":"yeah, that style is explicitly unsupported, or at least will always need to be reordered after the handshake barrier","msgtype":"m.text"},"ts":1695248092992,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zGtfTL5Ji17AXN12Gv7qWXZS8rq2XsamyzsCudl5_ZA"},
{"content":{"body":"With the approach I've been suggesting, it doesn't.","msgtype":"m.text"},"ts":1695248113440,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IhDJL1VMOZatrkrLJv8B7WZdwy608qFh4Ss6rfc8vZE"},
{"content":{"body":"I'm already doing that, sans behavior, currently.","msgtype":"m.text"},"ts":1695248132495,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jKzlZM5DUz8BidLYqfMsW5q4_O-S-Sb3e_dgzjzeljk"},
{"content":{"body":"i still don't understand how the correlation works","msgtype":"m.text"},"ts":1695248133128,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$uHBib3hPR56epGv2ptdAlQzzYEnaukyPMuaLbr1jZeM"},
{"content":{"body":"are you free? maybe we can hop on a 30 minute call and talk it through","msgtype":"m.text"},"ts":1695248144093,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$vMYKFiM5L_u0ofn2td-tBQFZd7s-8DBuza3xqagcSXc"},
{"content":{"body":"Sure","msgtype":"m.text"},"ts":1695248151168,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$qkok5ykdfoEy_9N-bHtR4Cmcxh7mPrkNDJh3pBPjIKA"},
{"content":{"body":"i'll DM","msgtype":"m.text"},"ts":1695248155619,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$IY2MMaTrz5OK4mcrSJxNUTr4F38r9u21dKKpRNJFNt4"}
]