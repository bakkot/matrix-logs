[
{"content":{"body":"- When A handshakes with M:\n  - M is able to establish that a PointA should have a PointM prototype and it will apply to every PointA it receives, from anywhere, within the scope of M's Agent.\n  - A is able to establish that a PointM should have a PointA prototype and it will apply to every PointM it receives, from anywhere, within the scope of A's Agent.\n- When B handshakes with M:\n  - M is able to establish that a PointB should have a PointM prototype and it will apply to every PointB it receives, from anywhere, within the scope of M's Agent.\n  - B is able to establish that a PointM should have a PointB prototype and it will apply to every PointM it receives, from anywhere, within the scope of B's Agent.\n\nAs such:\n- M will be able to find behavior for both rect1.topLeft and rect1.topRight, because the handshake between M-A and M-B established that.\n- B will not be able to find a behavior for rect1.topLeft because registries RA and RB are independent.\n- A will not be able to find a behavior for rect1.bottomRight because registries RA and RB are independent.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>When A handshakes with M:\n<ul>\n<li>M is able to establish that a PointA should have a PointM prototype and it will apply to every PointA it receives, from anywhere, within the scope of M's Agent.</li>\n<li>A is able to establish that a PointM should have a PointA prototype and it will apply to every PointM it receives, from anywhere, within the scope of A's Agent.</li>\n</ul>\n</li>\n<li>When B handshakes with M:\n<ul>\n<li>M is able to establish that a PointB should have a PointM prototype and it will apply to every PointB it receives, from anywhere, within the scope of M's Agent.</li>\n<li>B is able to establish that a PointM should have a PointB prototype and it will apply to every PointM it receives, from anywhere, within the scope of B's Agent.</li>\n</ul>\n</li>\n</ul>\n<p>As such:</p>\n<ul>\n<li>M will be able to find behavior for both rect1.topLeft and rect1.topRight, because the handshake between M-A and M-B established that.</li>\n<li>B will not be able to find a behavior for rect1.topLeft because registries RA and RB are independent.</li>\n<li>A will not be able to find a behavior for rect1.bottomRight because registries RA and RB are independent.</li>\n</ul>\n","msgtype":"m.text"},"ts":1695171668855,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HS0y6CUJFfulqtRL9L2OcgfY5tSBNGHpCYZly957_qU"},
{"content":{"body":"However, if you use the same registry RAB with A and B:\n- B is able to establish that a PointA should have a PointB prototype because the registry correlates both PointA and PointB with PointM.\n- A is able to establish that a PointB should have a PointA prototype because the registry correlates both PointA and PointB with PointM.","format":"org.matrix.custom.html","formatted_body":"<p>However, if you use the same registry RAB with A and B:</p>\n<ul>\n<li>B is able to establish that a PointA should have a PointB prototype because the registry correlates both PointA and PointB with PointM.</li>\n<li>A is able to establish that a PointB should have a PointA prototype because the registry correlates both PointA and PointB with PointM.</li>\n</ul>\n","msgtype":"m.text"},"ts":1695171791500,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$iH_SKy4Db-c6Ut52lbeCmsrHPr7BVP8495tzMzfkSGQ"},
{"content":{"body":"If such a prototype is initialized lazily in `[[GetPrototypeOf]]`, by the time B can receive a PointA, or that A can receive a PointB, both agents will have completed their handshake with M, so all information is known. This is another reason why my proposal uses a preload script. The preload script performs the worker side of the handshake before any other data can be shared between the worker and M, so you cannot have a stray PointA sent to B, or PointB sent to A, prior to a completed handshake on both sides.","format":"org.matrix.custom.html","formatted_body":"If such a prototype is initialized lazily in <code>[[GetPrototypeOf]]</code>, by the time B can receive a PointA, or that A can receive a PointB, both agents will have completed their handshake with M, so all information is known. This is another reason why my proposal uses a preload script. The preload script performs the worker side of the handshake before any other data can be shared between the worker and M, so you cannot have a stray PointA sent to B, or PointB sent to A, prior to a completed handshake on both sides.","msgtype":"m.text"},"ts":1695171989576,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9sHMvYsrX12hKrMZ4eVUjV1c-sfRweFv64o1smhunsg"},
{"content":{"body":"Now, we could theoretically have a global registry instead, with the `structs: {}` map only used to correlate PointM and PointA when A is established. Workers will always be part of a tree that points back to some root agent, so there's always a way to collect these things. If the handshake establishes the relationship without the ability to pass messages, would that be sufficient to address concerns about a global registry?","format":"org.matrix.custom.html","formatted_body":"Now, we could theoretically have a global registry instead, with the <code>structs: {}</code> map only used to correlate PointM and PointA when A is established. Workers will always be part of a tree that points back to some root agent, so there's always a way to collect these things. If the handshake establishes the relationship without the ability to pass messages, would that be sufficient to address concerns about a global registry?","msgtype":"m.text"},"ts":1695172399398,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Yb14-RUWWWm1TRT-STKWnZpMPIGXe1Z_ydukyqaDLUw"},
{"content":{"body":"Especially if the worker can't actually observe the exemplar during handshake, since the handshake process is handled by the runtime. We wouldn't even need communicate the actual exemplars through the handshake process, just the type identities of the exemplars. ","msgtype":"m.text"},"ts":1695172612891,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bxx9bKqbyxmNNaRcX6sZwD2o9nYv8E1i5BBstOb37d4"},
{"content":{"body":"Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars you send during the handshake must have been created by a type created in M's Agent.","msgtype":"m.text"},"ts":1695172875759,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xWuIFCyWb_mVwftQlKv4jkzhApT04mLu7S3B3anBEJg"},
{"content":{"body":" * Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars M sends during the handshake must have been created by a type created in M's Agent.","m.new_content":{"body":"Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars M sends during the handshake must have been created by a type created in M's Agent.","msgtype":"m.text"},"m.relates_to":{"event_id":"$xWuIFCyWb_mVwftQlKv4jkzhApT04mLu7S3B3anBEJg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695172893339,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$m0IQQ3IpFh4Muo0ZQSdb-Ave7xmIU-4MDmRlse2Z8r8"},
{"content":{"body":" * Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars M sends during the handshake must have been created by a type created in M's Agent","m.new_content":{"body":"Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars M sends during the handshake must have been created by a type created in M's Agent","msgtype":"m.text"},"m.relates_to":{"event_id":"$xWuIFCyWb_mVwftQlKv4jkzhApT04mLu7S3B3anBEJg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695172907742,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-gtvAasjyry0aOJR7CEpgzcN9yiXpwz8um_s3r3Tk4I"},
{"content":{"body":"and the same thing goes for A (or B) spinning up a Worker (A2) during handshake and passing off one A2's exemplar as one of its own.","msgtype":"m.text"},"ts":1695172974815,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$515_z1tSgS935DJcsmWclJ6vHtH6UK72txO_AMpqVQQ"},
{"content":{"body":" * and the same thing goes for A (or B) spinning up a Worker (A2) during handshake and passing off one A2's exemplars as one of its own.","m.new_content":{"body":"and the same thing goes for A (or B) spinning up a Worker (A2) during handshake and passing off one A2's exemplars as one of its own.","msgtype":"m.text"},"m.relates_to":{"event_id":"$515_z1tSgS935DJcsmWclJ6vHtH6UK72txO_AMpqVQQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695172983400,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$E5IgTu_vuU-PnoArLzAgWmxn1TtjKykOV3Fqb69BBe4"},
{"content":{"body":"Right I think an agent based registry can only work if:\n- the internal agent wide registry is an association from type to local behavior definition\n- there is a unique connection registry between 2 agents, and preparing a connection registry mapping (as creator or as a worker setting up), associates a connection specific string to a locally defined type only\n- you can only populate the agent wide registry through connection registries.\n\nthat means a worker A connected to a worker B through M but not sharing the same connection registry will not be able share behavior throughout. I'm still wondering about the special parent - child relationship these connection based registries seem to have, and how you can only have one connection registry between 2 agents or things fall apart. I can't explain why exactly right now, but this all feels awkward.","format":"org.matrix.custom.html","formatted_body":"<p>Right I think an agent based registry can only work if:</p>\n<ul>\n<li>the internal agent wide registry is an association from type to local behavior definition</li>\n<li>there is a unique connection registry between 2 agents, and preparing a connection registry mapping (as creator or as a worker setting up), associates a connection specific string to a locally defined type only</li>\n<li>you can only populate the agent wide registry through connection registries.</li>\n</ul>\n<p>that means a worker A connected to a worker B through M but not sharing the same connection registry will not be able share behavior throughout. I'm still wondering about the special parent - child relationship these connection based registries seem to have, and how you can only have one connection registry between 2 agents or things fall apart. I can't explain why exactly right now, but this all feels awkward.</p>\n","msgtype":"m.text"},"ts":1695179131028,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$th-UFWSdXkegxitZUoKzHWwt1lg72y0hqYbgRKXqY_s"},
{"content":{"body":"I'm wondering if we even need a connection-based registry if we can devise a global registry strategy that addresses Agoric's concerns about security. You'd discussed how a mutable global registry is a possible side channel for data exfiltration? I'm curious how serious the concern is and if you have a link to a paper or something else that could provide additional context? Is the concern related to how a Worker could abuse such a global registry, or how a script or module in the same Agent could abuse such a registry?","msgtype":"m.text"},"ts":1695213493361,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Ob1ulvj0elSC9trzwwPF2OFw4W1yJNPed4rqXh7Vv6A"},
{"content":{"body":"> <@shuyuguo:matrix.org> the two choices are:\n> \n> 1. a shared struct instance's [[Prototype]] is a shared field and holds a shared struct, with `nonshared` fields, into which you assign methods\n> 2. a shared struct instance's [[Prototype]] is a `nonshared` field and points to a per-agent local struct\n\nrbuckton: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$HTj3amOy9ic6346qUM25tQy0JsCrTg3J9KwgjiRxuIo?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br><p>the two choices are:</p>\n<ol>\n<li>a shared struct instance's [[Prototype]] is a shared field and holds a shared struct, with <code>nonshared</code> fields, into which you assign methods</li>\n<li>a shared struct instance's [[Prototype]] is a <code>nonshared</code> field and points to a per-agent local struct</li>\n</ol>\n</blockquote></mx-reply><a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better","m.relates_to":{"m.in_reply_to":{"event_id":"$HTj3amOy9ic6346qUM25tQy0JsCrTg3J9KwgjiRxuIo"}},"msgtype":"m.text"},"ts":1695227563898,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$fEo6I5ZgqR5gDOyP8Gp1RoklPWuxkiXQTa-h7YvNdmg"},
{"content":{"body":"> <@rbuckton:matrix.org> I'm wondering if we even need a connection-based registry if we can devise a global registry strategy that addresses Agoric's concerns about security. You'd discussed how a mutable global registry is a possible side channel for data exfiltration? I'm curious how serious the concern is and if you have a link to a paper or something else that could provide additional context? Is the concern related to how a Worker could abuse such a global registry, or how a script or module in the same Agent could abuse such a registry?\n\nThe concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Ob1ulvj0elSC9trzwwPF2OFw4W1yJNPed4rqXh7Vv6A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I&#39;m wondering if we even need a connection-based registry if we can devise a global registry strategy that addresses Agoric&#39;s concerns about security. You&#39;d discussed how a mutable global registry is a possible side channel for data exfiltration? I&#39;m curious how serious the concern is and if you have a link to a paper or something else that could provide additional context? Is the concern related to how a Worker could abuse such a global registry, or how a script or module in the same Agent could abuse such a registry?</blockquote></mx-reply>The concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.","m.relates_to":{"m.in_reply_to":{"event_id":"$Ob1ulvj0elSC9trzwwPF2OFw4W1yJNPed4rqXh7Vv6A"}},"msgtype":"m.text"},"ts":1695228812186,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$GmbkFyB0O4EvzGffL0gwcYX3s4sFohz7W3r--8w0hqs"},
{"content":{"body":"> <@shuyuguo:matrix.org> rbuckton: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better\n\nWould this affect subclassing or no? I imagine in a subclassing case, we would just collect all of the shared fields up front and put them on the instance, much like we do for private fields today, so I don't imagine it would.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$fEo6I5ZgqR5gDOyP8Gp1RoklPWuxkiXQTa-h7YvNdmg?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br><a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better</blockquote></mx-reply>Would this affect subclassing or no? I imagine in a subclassing case, we would just collect all of the shared fields up front and put them on the instance, much like we do for private fields today, so I don't imagine it would.","m.relates_to":{"m.in_reply_to":{"event_id":"$fEo6I5ZgqR5gDOyP8Gp1RoklPWuxkiXQTa-h7YvNdmg"}},"msgtype":"m.text"},"ts":1695228933136,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oGP9_EGgiMCWsGmV5D7nnN042KUfmuqStY4bVgmt99A"},
{"content":{"body":"rbuckton: that's not clear to me yet. one challenge here is how to express the thread-localness of a superclass","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: that's not clear to me yet. one challenge here is how to express the thread-localness of a superclass","msgtype":"m.text"},"ts":1695229051402,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$gBTW4rJOaRMSLtNrB26Dm3b8LGNF_72fIL9-frTjPv4"},
{"content":{"body":"we want the fixed layout invariant to hold, so do you say like \"shared struct A extends per-agent B\", but what is B? it could be itself a shared struct but its layout gets copied into a thread-local version of the struct the first time [[Prototype]] is accessed in a thread","msgtype":"m.text"},"ts":1695229131232,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$EWAE9X_Kh84FHoUqFDOBXD-lxXCjTdLv43qikfoj4yI"},
{"content":{"body":"should it be a non-shared struct declaration?","msgtype":"m.text"},"ts":1695229139250,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$DNKSASWQFW4fh9DfRbziynlMtwJFANyvExf01VtO9Lg"},
{"content":{"body":"(but it gets that layout copy behavior)","msgtype":"m.text"},"ts":1695229145060,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$c4fyEeBfb2IIRc1nqDbDuyOh2CALwONp4VfNemgugAY"},
{"content":{"body":"> <@mhofman:matrix.org> The concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.\n\nDo you imagine such communication is possible in this case? ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$GmbkFyB0O4EvzGffL0gwcYX3s4sFohz7W3r--8w0hqs?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>The concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.</blockquote></mx-reply>Do you imagine such communication is possible in this case?","m.relates_to":{"m.in_reply_to":{"event_id":"$GmbkFyB0O4EvzGffL0gwcYX3s4sFohz7W3r--8w0hqs"}},"msgtype":"m.text"},"ts":1695230817411,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$AOts5ehWSb6EKC8O2Tm19Mw46rA72de6q3vLYplv3Gw"},
{"content":{"body":"Lets assume you can't use the exemplar values themselves to communicate, i.e., the actual exemplars aren't exposed to user code on the other Agent.","msgtype":"m.text"},"ts":1695231010975,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dgDTfxJOScNcIaBNO4SgDPKqfzxXJ0y7DxrIg34wNec"},
{"content":{"body":"The child thread can't send or receive structs to the parent thread during handshake, and by the time handshake has completed all correlation between the parent and child is frozen.","msgtype":"m.text"},"ts":1695231136501,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$I_6BHT_vT5jTgWqTs3P7XZflCP4oj_EJNKEsI440LVk"},
{"content":{"body":"By the time A can observe a struct from B, the correlation between M, A, and B has already occurred and is frozen. You cannot dynamically attach new behavior, but we do lazily resolve the prototype based on correlation.","msgtype":"m.text"},"ts":1695231284868,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HAGHepkhQd0b5xvg12Ha_-6MpdRwMxg6z0Ffyg8EKP0"},
{"content":{"body":"Maybe there's a small possibility of a timing related exploit if I can somehow spin up multiple additional workers on M and send an existing corelated struct to A to indicate `0` and new correlated struct to A indicating `1` and somehow measure the timing? That might be mitigated if correlation happens before normal communication can occur and prototype lookup always follows the same path, but you could potentially use structs who have narrow and wide correlation sets and measure timing that way, or update an agent-local correlation registry when two agent's communicate for the first time so that you pay that cost once. ","format":"org.matrix.custom.html","formatted_body":"Maybe there's a small possibility of a timing related exploit if I can somehow spin up multiple additional workers on M and send an existing corelated struct to A to indicate <code>0</code> and new correlated struct to A indicating <code>1</code> and somehow measure the timing? That might be mitigated if correlation happens before normal communication can occur and prototype lookup always follows the same path, but you could potentially use structs who have narrow and wide correlation sets and measure timing that way, or update an agent-local correlation registry when two agent's communicate for the first time so that you pay that cost once.","msgtype":"m.text"},"ts":1695231622205,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CL-qRnjV_AMaBii8egzgkEHyp0H83dS7ZTgV389QDNA"},
{"content":{"body":"There are possibly other ways to mitigate that as well.","msgtype":"m.text"},"ts":1695231790393,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$J8k1yxrsI5gJ73S8b09y-_TFSH5QbzblsWlvqKzL6G4"},
{"content":{"body":"Within a single Agent, when worker's aren't involved, you wouldn't be able to use this registry for communication because it would be inaccessible. You can also use CSP to lock down Worker to specific scripts, or disable it entirely.","msgtype":"m.text"},"ts":1695231987824,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$o9Ib1hxb3oy-L2ywjhuZV8jYX2S_a6YiiV8q56kC1ck"},
{"content":{"body":"If `Worker` is locked down via CSP, the only way you could leverage these for a timing attack would to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","format":"org.matrix.custom.html","formatted_body":"If <code>Worker</code> is locked down via CSP, the only way you could leverage these for a timing attack would to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","msgtype":"m.text"},"ts":1695232161856,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nkh_7Bxuw7HNNSkotDK-PvxoiTUqgaz1lul-QjFG5ZA"},
{"content":{"body":" * If `Worker` is locked down via CSP, the only way you could leverage these for a timing attack would be to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","format":"org.matrix.custom.html","formatted_body":" * If <code>Worker</code> is locked down via CSP, the only way you could leverage these for a timing attack would be to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","m.new_content":{"body":"If `Worker` is locked down via CSP, the only way you could leverage these for a timing attack would be to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","format":"org.matrix.custom.html","formatted_body":"If <code>Worker</code> is locked down via CSP, the only way you could leverage these for a timing attack would be to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.","msgtype":"m.text"},"m.relates_to":{"event_id":"$nkh_7Bxuw7HNNSkotDK-PvxoiTUqgaz1lul-QjFG5ZA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1695232526727,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$LERntAEnEENQm-NhWNIyHyIeUhl0sonA1MHXhK3-UVA"},
{"content":{"body":"If you have two isolated pieces of code in the same Agent that both have access to an unrestricted `Worker`, its possible they could already communicate with each other via resource starvation and timing attacks. ","format":"org.matrix.custom.html","formatted_body":"If you have two isolated pieces of code in the same Agent that both have access to an unrestricted <code>Worker</code>, its possible they could already communicate with each other via resource starvation and timing attacks.","msgtype":"m.text"},"ts":1695232839908,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$M61_ZMA_d2kuJU_NWpfBbk24-1JbF847whPtOA7CLcc"},
{"content":{"body":"For same realm/agent, if the registry is string keyed, Alice can register \"foo\". If Bob can somehow figure out that \"foo\" is already registered, this is a one bit communication channel. There are likely multiple ways Bob could sense whether \"foo\" is registered.","msgtype":"m.text"},"ts":1695236812909,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$X4plMHlNsLYatXoHv2DlB1twMWueZpJID3XjwXhwNJE"},
{"content":{"body":"With the global registry concept, all registration within a single Agent would happen via `new SharedStructType` (or via `shared struct Foo {}`). No errors would be reported except for running out of heap space (and crashing). When setting up a `Worker`, there is a correlation step to correlate the registrations within both Agents, but this only occurs at the time of the Worker handshake and should only be observable by interacting with that Worker or a shared struct provided to the worker.","format":"org.matrix.custom.html","formatted_body":"With the global registry concept, all registration within a single Agent would happen via <code>new SharedStructType</code> (or via <code>shared struct Foo {}</code>). No errors would be reported except for running out of heap space (and crashing). When setting up a <code>Worker</code>, there is a correlation step to correlate the registrations within both Agents, but this only occurs at the time of the Worker handshake and should only be observable by interacting with that Worker or a shared struct provided to the worker.","msgtype":"m.text"},"ts":1695237653936,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rZPCiUAEx1EdYnJ6a_BYDZqTfbp68F6P_5sxahdDPTc"},
{"content":{"body":"As far as I can tell, there's no way to observe that within a single Agent/realm. You can't check if something is \"registered\" because all \"registration\" happens before the thing you would test exists.","msgtype":"m.text"},"ts":1695237758122,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ORPVJmRDAaUMTDn1GyvYZahqGIDV4nUA8wa3zgt8nxY"},
{"content":{"body":"The only way to observe correlation would be to use a Worker and a shared reference, which still only observes correlation between those two Agents.","msgtype":"m.text"},"ts":1695237840255,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$W0BIfIVIeOPx-FO5rnw_QxasoB6ZvmDS0I8nKmUfjiQ"}
]