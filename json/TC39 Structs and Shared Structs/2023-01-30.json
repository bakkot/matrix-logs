[
{"content":{"body":"Right, this is why I concluded that the only reference point we could use is the module system ","format":"org.matrix.custom.html","formatted_body":"Right, this is why I concluded that the only reference point we could use is the module system","msgtype":"m.text"},"ts":1675055498484,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$cwb7fKCf8XSNBfQRJT4FDMDAX8y0CgKdCQsCL77T8-8"},
{"content":{"body":"just like builtin modules, there'd always have to be a way to access the same functionality in Scripts - how would that work at all with the module system?","msgtype":"m.text"},"ts":1675058850422,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$gaBwSU47zI9VeCUs62jxzwkKBpH1s5zJj9QFAAuUgo0"},
{"content":{"body":"Automatically de-duping types based on module could also be difficult when the bundler inlines the defining module into separate main and worker bundles. It would need to know this module is an entry-point that should not be inlined ","format":"org.matrix.custom.html","formatted_body":"Automatically de-duping types based on module could also be difficult when the bundler inlines the defining module into separate main and worker bundles. It would need to know this module is an entry-point that should not be inlined","msgtype":"m.text"},"ts":1675067993169,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$k_W3CFnespbK7LjVR0ayiMzrhYJAOy5k6ASIX0mGVvM"},
{"content":{"body":"For manually registering a prototype:\n\n- `StructClass.adopt(orphanedInstance)` is potential the simplest to explain on its own but pre-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called ","format":"org.matrix.custom.html","formatted_body":"<p>For manually registering a prototype:</p>\n<ul>\n<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but pre-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>\n</ul>","msgtype":"m.text"},"ts":1675068205930,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$VLLTFv2v9x7XTiIdq51XLcWgwPY0EKTJu_QJoWcND1A"},
{"content":{"body":"- registering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer:  what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel?","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>registering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer:  what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel?</li>\n</ul>","msgtype":"m.text"},"ts":1675068529041,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU"},
{"content":{"body":"* or is everything automatic, for the use case rbuckton mentioned where an npm package of shared structs \"just works across workers\" with no orchestration (ignoring ensuring the bundler&server are configured as required)","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>or is everything automatic, for the use case <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a> mentioned where an npm package of shared structs &quot;just works across workers&quot; with no orchestration (ignoring ensuring the bundler&amp;server are configured as required)</li>\n</ul>","msgtype":"m.text"},"ts":1675068707875,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$DrojE317GZ8YQka9wPnExWO5aidWb2jX7If-ZaptZNE"},
{"content":{"body":"* \t•\tregistering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":"* <pre><code>•\tregistering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)\n</code></pre>","m.new_content":{"body":"\t•\tregistering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":"<pre><code>•\tregistering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)\n</code></pre>","msgtype":"m.text"},"m.relates_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675068783486,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$0fCU3UTw-8brZVnikdhWZz-tmXTSYUXzX7ebhuK2laY"},
{"content":{"body":" * •\tregistering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)","m.new_content":{"body":"•\tregistering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)","msgtype":"m.text"},"m.relates_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675068884985,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$waNolpZRADLlXcJj2UAG1pvCL-M8uQI3Dh7Q-VOyhcU"},
{"content":{"body":" * - registering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":" * <ul>\n<li>registering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)</li>\n</ul>\n","m.new_content":{"body":"- registering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>registering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675068917455,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$4e-ywNnxU_Xn7cVWKEgNVAV0t5mM31gh60MtWyP8pLc"},
{"content":{"body":" * For manually registering a prototype:\n\n- `StructClass.adopt(orphanedInstance)` is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called","format":"org.matrix.custom.html","formatted_body":" * <p>For manually registering a prototype:</p>\n<ul>\n<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>\n</ul>\n","m.new_content":{"body":"For manually registering a prototype:\n\n- `StructClass.adopt(orphanedInstance)` is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called","format":"org.matrix.custom.html","formatted_body":"<p>For manually registering a prototype:</p>\n<ul>\n<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$VLLTFv2v9x7XTiIdq51XLcWgwPY0EKTJu_QJoWcND1A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675076454011,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$PvEhiXiJ44dm1GSxo2cZa6j6_9BnyWYOIygDrByR0ys"},
{"content":{"body":" * - registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":" * <ul>\n<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)</li>\n</ul>\n","m.new_content":{"body":"- registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675076528739,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$jvgmnLF_lTyFg4-EqoUpcVr6bBnE6YnwekqTOR384YU"},
{"content":{"body":"> <@aclaymore:matrix.org> For manually registering a prototype:\n> \n> - `StructClass.adopt(orphanedInstance)` is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called\n\nThis seems infeasible for any complex, nested set of structs","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$VLLTFv2v9x7XTiIdq51XLcWgwPY0EKTJu_QJoWcND1A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br /><p>For manually registering a prototype:</p>\n<ul>\n<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>\n</ul>\n</blockquote></mx-reply>This seems infeasible for any complex, nested set of structs","m.relates_to":{"m.in_reply_to":{"event_id":"$VLLTFv2v9x7XTiIdq51XLcWgwPY0EKTJu_QJoWcND1A"}},"msgtype":"m.text"},"ts":1675090389344,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yq1PpoXy1rAk6vvXR6s-AA2BXp56f1g0zOvqeAHl53U"},
{"content":{"body":"> <@aclaymore:matrix.org> * or is everything automatic, for the use case rbuckton mentioned where an npm package of shared structs \"just works across workers\" with no orchestration (ignoring ensuring the bundler&server are configured as required)\n\nWhile this would be nice to have as a default, I don't think \"automatic only\" is feasible w/o making structs unbundleable. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$DrojE317GZ8YQka9wPnExWO5aidWb2jX7If-ZaptZNE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br /><ul>\n<li>or is everything automatic, for the use case <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a> mentioned where an npm package of shared structs &quot;just works across workers&quot; with no orchestration (ignoring ensuring the bundler&amp;server are configured as required)</li>\n</ul></blockquote></mx-reply>While this would be nice to have as a default, I don't think &quot;automatic only&quot; is feasible w/o making structs unbundleable.","m.relates_to":{"m.in_reply_to":{"event_id":"$DrojE317GZ8YQka9wPnExWO5aidWb2jX7If-ZaptZNE"}},"msgtype":"m.text"},"ts":1675090645305,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$L9pZVIRQy6cCbR3P0pBWs-yzLjdpDZRrW3lEA6SlXRE"},
{"content":{"body":"> <@aclaymore:matrix.org> - registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)\n\nOnce per realm is consistent with primitives like `Number.prototype`, `Boolean.prototype`, etc. The question is whether structs are more \"object\"-like or more \"primitive\"-like, since Objects are effectively per-Agent since you can hand one to another realm and it still walks the original prototype chain.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br><ul>\n<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)</li>\n</ul>\n</blockquote></mx-reply>Once per realm is consistent with primitives like <code>Number.prototype</code>, <code>Boolean.prototype</code>, etc. The question is whether structs are more &quot;object&quot;-like or more &quot;primitive&quot;-like, since Objects are effectively per-Agent since you can hand one to another realm and it still walks the original prototype chain.","m.relates_to":{"m.in_reply_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU"}},"msgtype":"m.text"},"ts":1675090978441,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aqrslKclGi1QiiEv3YV42ysdaT6z7cv6Xq4h-4t2L5M"},
{"content":{"body":"Once per-realm has the consequence that the value would not meet the current 'sealed'  guarantees. Maybe this is OK, but also maybe not","msgtype":"m.text"},"ts":1675091372707,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$gcsQuLiyhAG84QS1f6h4tsnpSISmCm4fBd91TCFuLVk"},
{"content":{"body":"I think regarding dynamic prototype lookup we agreed this would be a per-realm behavior like for primitives, which means whatever registry must be at most per realm","msgtype":"m.text"},"ts":1675091401229,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$O4FQ86XX2AymsJ0ioUoQi4PldohlVrR1C-iYSl_O9FU"},
{"content":{"body":"while that is 'like' primitives, it's more because primitives are not objects in the first place","msgtype":"m.text"},"ts":1675091516510,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$6Tnwq8jwFPNobRJNCCrgzCpiWrJEr-mqMx5P4e1TV60"},
{"content":{"body":"If the only realms that existed were shadow realms, objects would effectively be per realm and not per agent","msgtype":"m.text"},"ts":1675091528378,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$xFTmhhvJsSU_amGjlfIw9D6M_nwvE4RVHTDRnApLf4s"},
{"content":{"body":"so they go via toObject, an object doesn't change via toObject","msgtype":"m.text"},"ts":1675091537665,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$Z05IDXoi9HT2CxracCzKEJjKPZCYYa090kPKZPVKbk0"},
{"content":{"body":"if only!","m.relates_to":{"event_id":"$xFTmhhvJsSU_amGjlfIw9D6M_nwvE4RVHTDRnApLf4s","is_falling_back":true,"m.in_reply_to":{"event_id":"$xFTmhhvJsSU_amGjlfIw9D6M_nwvE4RVHTDRnApLf4s"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1675091556266,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$7fyLLA95nl4Ujz7MFz2Xnj5qEQsa9u4ntfRSgdq4ETQ"},
{"content":{"body":"And  because of the existence of Shadow Realm, you cannot have a mechanism which would expose objects from another realm across the callable boundary","msgtype":"m.text"},"ts":1675091600799,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$9zOu5Dm5tdIExhyhyjf1s5IwDthGwnlfi9snl8MejOA"},
{"content":{"body":"which a per agent registry would effectively do","msgtype":"m.text"},"ts":1675091615281,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$y-UEjNvXACB6sXUclxyRUTqyu6uO2aEyjZao1DzDlXc"},
{"content":{"body":"but because of same-origin-iframes and node 'vm' there would still need to be defined behavior for same-agent-cross-realm semantics","msgtype":"m.text"},"ts":1675091691090,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$xsbr962OVHM-ozH6NnvVPmJkeWB21KjT_DrQ0FeaZcg"},
{"content":{"body":"ShadowRealms is the easy case :)","msgtype":"m.text"},"ts":1675091698802,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$bCloCRxdG0JJnoeNruw-aLDxkitG3w_19lIuxMh3px8"},
{"content":{"body":"easy ~= can't pass objects, so can't pass structs","msgtype":"m.text"},"ts":1675091725103,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$UE9yPFvxf_-VKfyV4zQb8mLsYAgZ78_5vr6i3karuQo"},
{"content":{"body":"well technically can only pass struct between agents with host APIs, but we're still discussing how that works here ;)\nA host could very well add an API to pass structs between shadow realms","msgtype":"m.text"},"ts":1675091887278,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$jAdLF95623vWjkB9-K9HYK57ro1iG75mY4M79TG7ibs"},
{"content":{"body":"(I really want to get my structured clone extension mechanism ironed out, as it'd work to pass objects between shadow realms)","msgtype":"m.text"},"ts":1675091917515,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$S2UsZQA8nQ4ymGmmngdyYG8bljuNNs8PercVuMXvM6c"},
{"content":{"body":"As I said earlier, if we had a restriction that a shared struct must be a top-level declaration then most type identity registration would occur during application start up (with the exception of portions of the module graph loaded dynamically via `import()`), which means conflicts (be they intentional or unintentional) would primarily occur early. Malicious code wouldn't be able to hijack an already-registered type identity.","format":"org.matrix.custom.html","formatted_body":"As I said earlier, if we had a restriction that a shared struct must be a top-level declaration then most type identity registration would occur during application start up (with the exception of portions of the module graph loaded dynamically via <code>import()</code>), which means conflicts (be they intentional or unintentional) would primarily occur early. Malicious code wouldn't be able to hijack an already-registered type identity.","msgtype":"m.text"},"ts":1675092427769,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ApAf2VoVwuolUFSUlQkstLCUvvmT3bb2aQ7Y1OurMYI"},
{"content":{"body":"how would that restriction work in Script?","msgtype":"m.text"},"ts":1675092496862,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$NMTfZpiQ8Hfg0RDNBJzmXJGL36-33p9NY5C8tWuBubM"},
{"content":{"body":"> <@ljharb:matrix.org> how would that restriction work in Script?\n\nThey would also need to be at the top-level of a Script, so no using a function as a factory for shared struct _types_. When evaluation of the module/script body completes, the file cannot produce new struct types. Yes, this isn't 100% reliable, but is at least as reliable as the current mechanisms used today to capture intrinsics before they can be patched/modified by other code.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$NMTfZpiQ8Hfg0RDNBJzmXJGL36-33p9NY5C8tWuBubM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>how would that restriction work in Script?</blockquote></mx-reply>They would also need to be at the top-level of a Script, so no using a function as a factory for shared struct <em>types</em>. When evaluation of the module/script body completes, the file cannot produce new struct types. Yes, this isn't 100% reliable, but is at least as reliable as the current mechanisms used today to capture intrinsics before they can be patched/modified by other code.","m.relates_to":{"m.in_reply_to":{"event_id":"$NMTfZpiQ8Hfg0RDNBJzmXJGL36-33p9NY5C8tWuBubM"}},"msgtype":"m.text"},"ts":1675092655965,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mAZinCI0H32Pgj80r1c2z4a7kNbm8Iu7Oz_wrJG1E7s"},
{"content":{"body":"I think that restriction is completely unrealistic, and makes it impossible to use this feature in a lot of programs","msgtype":"m.text"},"ts":1675092735024,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$BJDIOOzKQeVZX5f71SIrIh27nEAdqhyn1IiXlcuWLnA"},
{"content":{"body":"I only suggested the restriction as a possible remediation for the concern about type identity registration being forgeable.","msgtype":"m.text"},"ts":1675092783623,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HcUpQNmxv1vOMfkmJYqlry2MzXwGVsQzzOhgiK1Gu-o"},
{"content":{"body":"Realistically, even without this restriction, a type identity registry that depends on a first-in wins mechanism is still as reliable as existing intrinsic-capturing mechanisms.","msgtype":"m.text"},"ts":1675092846611,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wMCynzkjukpicGGVedaJbbql__H7dydOqOfOGgtr4Ck"},
{"content":{"body":"Javascript is a dynamic language. That suggestion is equivalent to forbidding features from the dynamic part of the language","msgtype":"m.text"},"ts":1675092860601,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$m_aVvOADmgcxhxHf9XUG1DdrE0D6yxxIYsiUU8jjHEY"},
{"content":{"body":"We already do that with features like `export`","format":"org.matrix.custom.html","formatted_body":"We already do that with features like <code>export</code>","msgtype":"m.text"},"ts":1675092885812,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$08AZrrU9rOl7TKE86lxrPaM8XKlDIMkgkMyMDT1XkQQ"},
{"content":{"body":"And I have explained why first win semantics for a global registry is a non-starter","msgtype":"m.text"},"ts":1675092902563,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Pi3N4G0k6Y1QWeXCr4XObnbphBPjWonslp4LwQU-D1M"},
{"content":{"body":"I don't want that restriction.","msgtype":"m.text"},"ts":1675092908184,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JJQsvW3UcYUhRtbXvGxpmumP6sw4zTE4PZQP5Y32B-4"},
{"content":{"body":"> <@mhofman:matrix.org> And I have explained why first win semantics for a global registry is a non-starter\n\nPer-agent global, or cross-agent global?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Pi3N4G0k6Y1QWeXCr4XObnbphBPjWonslp4LwQU-D1M?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>And I have explained why first win semantics for a global registry is a non-starter</blockquote></mx-reply>Per-agent global, or cross-agent global?","m.relates_to":{"m.in_reply_to":{"event_id":"$Pi3N4G0k6Y1QWeXCr4XObnbphBPjWonslp4LwQU-D1M"}},"msgtype":"m.text"},"ts":1675092927544,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1AMvf0rIIBMmXL7-MeeXM0Byga9z-o-SIheoXQYt40Y"},
{"content":{"body":"even per realm","msgtype":"m.text"},"ts":1675092941942,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ZzCULuGod4w8fLBn6i1NXUOHfyRgvx4vvrzREUDrPuU"},
{"content":{"body":"`export` being first win is not a precendent, like object spread is not a precendent. Both have a local effect (module or object)","format":"org.matrix.custom.html","formatted_body":"<code>export</code> being first win is not a precendent, like object spread is not a precendent. Both have a local effect (module or object)","msgtype":"m.text"},"ts":1675093004364,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$mPaqQg9WBN1Kiy5YKLZZcOx6t5pBKjVtkGsFE_wMbkY"},
{"content":{"body":"I still am not clear on why you believe a per-agent (or per-realm) write-only registry is a non-starter. If you don't want adversarial code to register first, you register first.","msgtype":"m.text"},"ts":1675093023357,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QhPMiY0h6zc-rgyt--UktCXCEXqMZtDg0SJYmAB1IjY"},
{"content":{"body":"who is \"you\"","msgtype":"m.text"},"ts":1675093044424,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$K1zRT9vXjHoVyoVp-e134iG0FPxklXrFuPaCMcjwcyc"},
{"content":{"body":"You, the application developer.","msgtype":"m.text"},"ts":1675093056740,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Jqi6spmA6u_VLBo-FLBNj3u90INsvUUP0mtoEYMyJHw"},
{"content":{"body":"Ok what about 2 libraries that the application load. Should lib1 be able to interfere with lib2 ?","msgtype":"m.text"},"ts":1675093089622,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$eGJTCd2k8ZiOI8SVS1IU84n8YKyT5m6T9pJyUh3vATc"},
{"content":{"body":"If you are a middleware, or a plugin, or something else running in a host environment where you don't control the environment, then you ensure your type identity is sufficiently unique. If you are the host environment loading a middleware, or plugin, etc., you architect your environment to be resilient to such a conflict.","msgtype":"m.text"},"ts":1675093151738,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gzAPipkmP6jCxZDkRC1cuAloa9jBl3qQvy-TcovCRp0"},
{"content":{"body":"there is no observable global mutable state in 262, and we would 100% block anything that introduces anything like it","msgtype":"m.text"},"ts":1675093164120,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$7Nj9pqy8oqSKf9Q2_LiR4715puhV_A6Qx7KsHlSw8W0"},
{"content":{"body":"the global object isn't that?","msgtype":"m.text"},"ts":1675093179385,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$rigCjwyE6gg1gmjwUYX8Dz7BmoVE4wlXArMvGKBWP2M"},
{"content":{"body":"or do you mean across realms (bigger than global, \"universal\" maybe)","msgtype":"m.text"},"ts":1675093189271,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$-ZZoSGPtbORD31598u83UCsSuzqiw-HjhXFIcAZyvlk"},
{"content":{"body":"minus the intrinsics/primordial objects themselves","msgtype":"m.text"},"ts":1675093195465,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$lA3y2mvjJtvVmswhD6fZApZdek2icq1CVzUf0wn9e2k"},
{"content":{"body":" * or do you mean across realms (bigger than global, \"universal\" maybe)","m.new_content":{"body":"or do you mean across realms (bigger than global, \"universal\" maybe)","msgtype":"m.text"},"m.relates_to":{"event_id":"$-ZZoSGPtbORD31598u83UCsSuzqiw-HjhXFIcAZyvlk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093195915,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$hPi9Ve_bEzEySY1Tp9hC44QcUBzW7uCu2niGlwOI1bM"},
{"content":{"body":"hidden *","msgtype":"m.text"},"ts":1675093197788,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$OiwxPvXQSWt1Url4bd75vBgMsLpakxY4DKRwKZeL-Rk"},
{"content":{"body":"sorry I forgot the hidden part","msgtype":"m.text"},"ts":1675093212535,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$uDFq1NT2w3OyxbTFG7vloIm_9CXo8hw8V2zNz0acwzk"},
{"content":{"body":"there's a few of those too already, but they're all freezeable ofc","msgtype":"m.text"},"ts":1675093225196,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$IcRW4NGecjvzwJrNWvgNrB1v3iWzFz9sldHkWTK5oMI"},
{"content":{"body":"where ?","msgtype":"m.text"},"ts":1675093230537,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ahN1pYxV8nR14787vF_E49O7Nm4Bb6-OcdQ1MIT0_yQ"},
{"content":{"body":" * there's a few of those too already, but they're all freezeable ofc","m.new_content":{"body":"there's a few of those too already, but they're all freezeable ofc","msgtype":"m.text"},"m.relates_to":{"event_id":"$IcRW4NGecjvzwJrNWvgNrB1v3iWzFz9sldHkWTK5oMI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093232956,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$cAz4ik7Dpw8Yd6GcP3jlDtVmR5uY9EVDu1JFFNvDsxs"},
{"content":{"body":"`AsyncFunction` is one, no?","format":"org.matrix.custom.html","formatted_body":"<code>AsyncFunction</code> is one, no?","msgtype":"m.text"},"ts":1675093241497,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$IFM9wljlZOrFIgsIjmU7alXGbnYfYyL7tWTYiG9_tOk"},
{"content":{"body":"hidden = internal","msgtype":"m.text"},"ts":1675093248503,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$HBQKJyGNUcRvORHxya2U03rSWjalOwA0PeqV58yI8rw"},
{"content":{"body":" * hideen= internal","m.new_content":{"body":"hideen= internal","msgtype":"m.text"},"m.relates_to":{"event_id":"$HBQKJyGNUcRvORHxya2U03rSWjalOwA0PeqV58yI8rw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093255961,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$BSgQ8X99_KLZMRMEWCgMWEXauY2p8V9btYs2Y-nrb9E"},
{"content":{"body":"i.e. not impacted by being frozen","msgtype":"m.text"},"ts":1675093259208,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$pn3y-M2YkAmmiSwIRUCy4TvHRA50O8nFa8VshLKEs2k"},
{"content":{"body":"yes the hidden intrinsics, which we're trying to fix","msgtype":"m.text"},"ts":1675093262976,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$0s6B_O-EnG2xWzuug8zKk65nLdfLCNgInUHWem94P8g"},
{"content":{"body":" * i.e. not impacted by being frozen","m.new_content":{"body":"i.e. not impacted by being frozen","msgtype":"m.text"},"m.relates_to":{"event_id":"$pn3y-M2YkAmmiSwIRUCy4TvHRA50O8nFa8VshLKEs2k","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093269854,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$TMZwSw7Z-SwEFGoDQL3GxEZcTr-xi5EPsSskGlukRCw"},
{"content":{"body":" * hideen = internal","m.new_content":{"body":"hideen = internal","msgtype":"m.text"},"m.relates_to":{"event_id":"$HBQKJyGNUcRvORHxya2U03rSWjalOwA0PeqV58yI8rw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093286621,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$FlgFgQmMPeqoCrJkKuOT7kxJPAziTvG4AtRQaKaDnqo"},
{"content":{"body":" * hidden = internal","m.new_content":{"body":"hidden = internal","msgtype":"m.text"},"m.relates_to":{"event_id":"$HBQKJyGNUcRvORHxya2U03rSWjalOwA0PeqV58yI8rw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093293335,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$O-xroRalfcAHza6mhUTJ9i8NnIuoLYO9mBw158M-1DE"},
{"content":{"body":"ashley has the correct wording there, AsyncFunction is accessible to JS code","msgtype":"m.text"},"ts":1675093313426,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$NOTFKFURGX_hlMKG7JBYIjV6BWAfUcLrTah_myVy_HI"},
{"content":{"body":"> <@mhofman:matrix.org> Ok what about 2 libraries that the application load. Should lib1 be able to interfere with lib2 ?\n\nIf lib2 doesn't want _unintentional_ interference, they should use sufficiently unique type identities. If lib1 performs _intentional_ interference, that's up to the application developer/host environment to mitigate, and a best effort from the runtime to surface that information early, hence the first-in wins registry. If you can only write new unique identities to the registry, either lib1 or lib2 will fail rather than be ignorant of hijacking.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$eGJTCd2k8ZiOI8SVS1IU84n8YKyT5m6T9pJyUh3vATc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Ok what about 2 libraries that the application load. Should lib1 be able to interfere with lib2 ?</blockquote></mx-reply>If lib2 doesn't want <em>unintentional</em> interference, they should use sufficiently unique type identities. If lib1 performs <em>intentional</em> interference, that's up to the application developer/host environment to mitigate, and a best effort from the runtime to surface that information early, hence the first-in wins registry. If you can only write new unique identities to the registry, either lib1 or lib2 will fail rather than be ignorant of hijacking.","m.relates_to":{"m.in_reply_to":{"event_id":"$eGJTCd2k8ZiOI8SVS1IU84n8YKyT5m6T9pJyUh3vATc"}},"msgtype":"m.text"},"ts":1675093323365,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hjBz2rqH2ZAB9eHvhaCf8C_eedjZGoGT9txj4bUNpe0"},
{"content":{"body":"> <@aclaymore:matrix.org> i.e. not impacted by being frozen\n\ngood thing RegExp.prototype isn't a regex anymore :-p","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$pn3y-M2YkAmmiSwIRUCy4TvHRA50O8nFa8VshLKEs2k?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br>i.e. not impacted by being frozen</blockquote></mx-reply>good thing RegExp.prototype isn't a regex anymore :-p","m.relates_to":{"m.in_reply_to":{"event_id":"$pn3y-M2YkAmmiSwIRUCy4TvHRA50O8nFa8VshLKEs2k"}},"msgtype":"m.text"},"ts":1675093408848,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$S9tAclJa2rk6f0r79K-hk86NoGOyLyfkMkXMI6YtVIo"},
{"content":{"body":"If the concern is about the registry not being freezable, that could be made possible via an API as well.","msgtype":"m.text"},"ts":1675093412050,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2gFUPX_eJaIeVtScqyNo_qGmOgDvd-98ETcE0cPpT3g"},
{"content":{"body":"But again that would prevent the feature from working","msgtype":"m.text"},"ts":1675093434925,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$clFBYEWBYjMdE_AwdtQuF4mOyqgswm3ndNAy6TEYFcw"},
{"content":{"body":"Yes, if malicious code were to freeze the registry your application would stop working. Which would be a fairly good indication that there is malicious code freezing the registry (at least, with a sufficiently clear error message).","msgtype":"m.text"},"ts":1675093499068,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0r9YL9fT6HaRTiOGgq1pZYpfzWVza_6Lhl5IRIgcN4g"},
{"content":{"body":"I want any JS feature where I can dynamically load code, that will keep working regardless of previous code that was loaded and executed (if you ignore mutation to the global object and intrinsics)","msgtype":"m.text"},"ts":1675093514475,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$UmXKLHRkxIy1iqLsHXxO-IXdxRmHb1mPnPEChGOZklQ"},
{"content":{"body":"Just like some packages not working with SES when it locks down the environment.","msgtype":"m.text"},"ts":1675093518897,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mDNuWrzes42jmEs1gApmgwxuxvmICYWqEkXZcYp5f88"},
{"content":{"body":"It feels like you are arguing two opposing positions: Such a registry must be mutable so that code keeps working, but malicious code shouldn't be able to mutate it to hijack it.","msgtype":"m.text"},"ts":1675093593313,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QFlj-cEsNSjvr9TYqKRKWp95LSF4dc_fI5FJoNZwUv4"},
{"content":{"body":"No, I'm arguing this feature cannot use a global registry with forgeable keys because it'd be impossible to make it safe","msgtype":"m.text"},"ts":1675093703226,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$cx2u_Dvb-ulSkCPBRUdFggOEhu_8JSbIN2a6_mlBYl0"},
{"content":{"body":"Perhaps it would be better to outline the specific capabilities we want, the limitations of the environment and ecosystem, and the concerns we have for any given solution. From there we can better determine hard and fast requirements and find potential compromises.","msgtype":"m.text"},"ts":1675093717145,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hqIKEu2l35SdMglf89Ei2M9gzYOXsz9xOslBkxMdQII"},
{"content":{"body":"> <@mhofman:matrix.org> No, I'm arguing this feature cannot use a global registry with forgeable keys because it'd be impossible to make it safe\n\nI'm more than willing to entertain other solutions, but its important that the developer experience doesn't make the feature wholly unusable.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$cx2u_Dvb-ulSkCPBRUdFggOEhu_8JSbIN2a6_mlBYl0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>No, I&#39;m arguing this feature cannot use a global registry with forgeable keys because it&#39;d be impossible to make it safe</blockquote></mx-reply>I'm more than willing to entertain other solutions, but its important that the developer experience doesn't make the feature wholly unusable.","m.relates_to":{"m.in_reply_to":{"event_id":"$cx2u_Dvb-ulSkCPBRUdFggOEhu_8JSbIN2a6_mlBYl0"}},"msgtype":"m.text"},"ts":1675093778732,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$d2uw8bkFzYbe0k8ONNyOMjvLtElIdKz34sz5xsDoGmg"},
{"content":{"body":"you can have a global registry, as long as it cannot be used by code that hasn't been previously introduced to each other to interact.","msgtype":"m.text"},"ts":1675093796769,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$mWw0eyb7fttpr5ijs8YX4rBhdyToadTcjHHnnf31yHM"}
]