[
{"content":{"body":"Right, this is why I concluded that the only reference point we could use is the module system ","format":"org.matrix.custom.html","formatted_body":"Right, this is why I concluded that the only reference point we could use is the module system","msgtype":"m.text"},"ts":1675055498484,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$cwb7fKCf8XSNBfQRJT4FDMDAX8y0CgKdCQsCL77T8-8"},
{"content":{"body":"just like builtin modules, there'd always have to be a way to access the same functionality in Scripts - how would that work at all with the module system?","msgtype":"m.text"},"ts":1675058850422,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$gaBwSU47zI9VeCUs62jxzwkKBpH1s5zJj9QFAAuUgo0"},
{"content":{"body":"Automatically de-duping types based on module could also be difficult when the bundler inlines the defining module into separate main and worker bundles. It would need to know this module is an entry-point that should not be inlined ","format":"org.matrix.custom.html","formatted_body":"Automatically de-duping types based on module could also be difficult when the bundler inlines the defining module into separate main and worker bundles. It would need to know this module is an entry-point that should not be inlined","msgtype":"m.text"},"ts":1675067993169,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$k_W3CFnespbK7LjVR0ayiMzrhYJAOy5k6ASIX0mGVvM"},
{"content":{"body":"For manually registering a prototype:\n\n- `StructClass.adopt(orphanedInstance)` is potential the simplest to explain on its own but pre-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called ","format":"org.matrix.custom.html","formatted_body":"<p>For manually registering a prototype:</p>\n<ul>\n<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but pre-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>\n</ul>","msgtype":"m.text"},"ts":1675068205930,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$VLLTFv2v9x7XTiIdq51XLcWgwPY0EKTJu_QJoWcND1A"},
{"content":{"body":"- registering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer:  what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel?","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>registering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer:  what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel?</li>\n</ul>","msgtype":"m.text"},"ts":1675068529041,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU"},
{"content":{"body":"* or is everything automatic, for the use case rbuckton mentioned where an npm package of shared structs \"just works across workers\" with no orchestration (ignoring ensuring the bundler&server are configured as required)","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>or is everything automatic, for the use case <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a> mentioned where an npm package of shared structs &quot;just works across workers&quot; with no orchestration (ignoring ensuring the bundler&amp;server are configured as required)</li>\n</ul>","msgtype":"m.text"},"ts":1675068707875,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$DrojE317GZ8YQka9wPnExWO5aidWb2jX7If-ZaptZNE"},
{"content":{"body":"* \t•\tregistering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":"* <pre><code>•\tregistering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)\n</code></pre>","m.new_content":{"body":"\t•\tregistering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":"<pre><code>•\tregistering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)\n</code></pre>","msgtype":"m.text"},"m.relates_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675068783486,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$0fCU3UTw-8brZVnikdhWZz-tmXTSYUXzX7ebhuK2laY"},
{"content":{"body":" * •\tregistering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)","m.new_content":{"body":"•\tregistering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)","msgtype":"m.text"},"m.relates_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675068884985,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$waNolpZRADLlXcJj2UAG1pvCL-M8uQI3Dh7Q-VOyhcU"},
{"content":{"body":" * - registering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":" * <ul>\n<li>registering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)</li>\n</ul>\n","m.new_content":{"body":"- registering once per type, reduces memory and is a one time orchestration and then it could \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>registering once per type, reduces memory and is a one time orchestration and then it could &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675068917455,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$4e-ywNnxU_Xn7cVWKEgNVAV0t5mM31gh60MtWyP8pLc"},
{"content":{"body":" * For manually registering a prototype:\n\n- `StructClass.adopt(orphanedInstance)` is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called","format":"org.matrix.custom.html","formatted_body":" * <p>For manually registering a prototype:</p>\n<ul>\n<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>\n</ul>\n","m.new_content":{"body":"For manually registering a prototype:\n\n- `StructClass.adopt(orphanedInstance)` is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called","format":"org.matrix.custom.html","formatted_body":"<p>For manually registering a prototype:</p>\n<ul>\n<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$VLLTFv2v9x7XTiIdq51XLcWgwPY0EKTJu_QJoWcND1A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675076454011,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$PvEhiXiJ44dm1GSxo2cZa6j6_9BnyWYOIygDrByR0ys"},
{"content":{"body":" * - registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":" * <ul>\n<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)</li>\n</ul>\n","m.new_content":{"body":"- registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then &quot;just work&quot; from that point on. But needs to answer: what carries the &quot;type&quot; being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the &quot;transferable objects&quot; list)</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675076528739,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$jvgmnLF_lTyFg4-EqoUpcVr6bBnE6YnwekqTOR384YU"},
{"content":{"body":"> <@aclaymore:matrix.org> For manually registering a prototype:\n> \n> - `StructClass.adopt(orphanedInstance)` is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called\n\nThis seems infeasible for any complex, nested set of structs","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$VLLTFv2v9x7XTiIdq51XLcWgwPY0EKTJu_QJoWcND1A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br /><p>For manually registering a prototype:</p>\n<ul>\n<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>\n</ul>\n</blockquote></mx-reply>This seems infeasible for any complex, nested set of structs","m.relates_to":{"m.in_reply_to":{"event_id":"$VLLTFv2v9x7XTiIdq51XLcWgwPY0EKTJu_QJoWcND1A"}},"msgtype":"m.text"},"ts":1675090389344,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yq1PpoXy1rAk6vvXR6s-AA2BXp56f1g0zOvqeAHl53U"},
{"content":{"body":"> <@aclaymore:matrix.org> * or is everything automatic, for the use case rbuckton mentioned where an npm package of shared structs \"just works across workers\" with no orchestration (ignoring ensuring the bundler&server are configured as required)\n\nWhile this would be nice to have as a default, I don't think \"automatic only\" is feasible w/o making structs unbundleable. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$DrojE317GZ8YQka9wPnExWO5aidWb2jX7If-ZaptZNE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br /><ul>\n<li>or is everything automatic, for the use case <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a> mentioned where an npm package of shared structs &quot;just works across workers&quot; with no orchestration (ignoring ensuring the bundler&amp;server are configured as required)</li>\n</ul></blockquote></mx-reply>While this would be nice to have as a default, I don't think &quot;automatic only&quot; is feasible w/o making structs unbundleable.","m.relates_to":{"m.in_reply_to":{"event_id":"$DrojE317GZ8YQka9wPnExWO5aidWb2jX7If-ZaptZNE"}},"msgtype":"m.text"},"ts":1675090645305,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$L9pZVIRQy6cCbR3P0pBWs-yzLjdpDZRrW3lEA6SlXRE"},
{"content":{"body":"> <@aclaymore:matrix.org> - registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel\\*? (\\* a bit like the \"transferable objects\" list)\n\nOnce per realm is consistent with primitives like `Number.prototype`, `Boolean.prototype`, etc. The question is whether structs are more \"object\"-like or more \"primitive\"-like, since Objects are effectively per-Agent since you can hand one to another realm and it still walks the original prototype chain.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br><ul>\n<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then \"just work\" from that point on. But needs to answer: what carries the \"type\" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the \"transferable objects\" list)</li>\n</ul>\n</blockquote></mx-reply>Once per realm is consistent with primitives like <code>Number.prototype</code>, <code>Boolean.prototype</code>, etc. The question is whether structs are more &quot;object&quot;-like or more &quot;primitive&quot;-like, since Objects are effectively per-Agent since you can hand one to another realm and it still walks the original prototype chain.","m.relates_to":{"m.in_reply_to":{"event_id":"$lkahEnvQpyMKyG5RGMJHHeexgE4OmYO3Kh5GpJZfjQU"}},"msgtype":"m.text"},"ts":1675090978441,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aqrslKclGi1QiiEv3YV42ysdaT6z7cv6Xq4h-4t2L5M"},
{"content":{"body":"Once per-realm has the consequence that the value would not meet the current 'sealed'  guarantees. Maybe this is OK, but also maybe not","msgtype":"m.text"},"ts":1675091372707,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$gcsQuLiyhAG84QS1f6h4tsnpSISmCm4fBd91TCFuLVk"},
{"content":{"body":"I think regarding dynamic prototype lookup we agreed this would be a per-realm behavior like for primitives, which means whatever registry must be at most per realm","msgtype":"m.text"},"ts":1675091401229,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$O4FQ86XX2AymsJ0ioUoQi4PldohlVrR1C-iYSl_O9FU"},
{"content":{"body":"while that is 'like' primitives, it's more because primitives are not objects in the first place","msgtype":"m.text"},"ts":1675091516510,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$6Tnwq8jwFPNobRJNCCrgzCpiWrJEr-mqMx5P4e1TV60"},
{"content":{"body":"If the only realms that existed were shadow realms, objects would effectively be per realm and not per agent","msgtype":"m.text"},"ts":1675091528378,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$xFTmhhvJsSU_amGjlfIw9D6M_nwvE4RVHTDRnApLf4s"},
{"content":{"body":"so they go via toObject, an object doesn't change via toObject","msgtype":"m.text"},"ts":1675091537665,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$Z05IDXoi9HT2CxracCzKEJjKPZCYYa090kPKZPVKbk0"},
{"content":{"body":"if only!","m.relates_to":{"event_id":"$xFTmhhvJsSU_amGjlfIw9D6M_nwvE4RVHTDRnApLf4s","is_falling_back":true,"m.in_reply_to":{"event_id":"$xFTmhhvJsSU_amGjlfIw9D6M_nwvE4RVHTDRnApLf4s"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1675091556266,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$7fyLLA95nl4Ujz7MFz2Xnj5qEQsa9u4ntfRSgdq4ETQ"},
{"content":{"body":"And  because of the existence of Shadow Realm, you cannot have a mechanism which would expose objects from another realm across the callable boundary","msgtype":"m.text"},"ts":1675091600799,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$9zOu5Dm5tdIExhyhyjf1s5IwDthGwnlfi9snl8MejOA"},
{"content":{"body":"which a per agent registry would effectively do","msgtype":"m.text"},"ts":1675091615281,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$y-UEjNvXACB6sXUclxyRUTqyu6uO2aEyjZao1DzDlXc"},
{"content":{"body":"but because of same-origin-iframes and node 'vm' there would still need to be defined behavior for same-agent-cross-realm semantics","msgtype":"m.text"},"ts":1675091691090,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$xsbr962OVHM-ozH6NnvVPmJkeWB21KjT_DrQ0FeaZcg"},
{"content":{"body":"ShadowRealms is the easy case :)","msgtype":"m.text"},"ts":1675091698802,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$bCloCRxdG0JJnoeNruw-aLDxkitG3w_19lIuxMh3px8"},
{"content":{"body":"easy ~= can't pass objects, so can't pass structs","msgtype":"m.text"},"ts":1675091725103,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$UE9yPFvxf_-VKfyV4zQb8mLsYAgZ78_5vr6i3karuQo"},
{"content":{"body":"well technically can only pass struct between agents with host APIs, but we're still discussing how that works here ;)\nA host could very well add an API to pass structs between shadow realms","msgtype":"m.text"},"ts":1675091887278,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$jAdLF95623vWjkB9-K9HYK57ro1iG75mY4M79TG7ibs"},
{"content":{"body":"(I really want to get my structured clone extension mechanism ironed out, as it'd work to pass objects between shadow realms)","msgtype":"m.text"},"ts":1675091917515,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$S2UsZQA8nQ4ymGmmngdyYG8bljuNNs8PercVuMXvM6c"},
{"content":{"body":"As I said earlier, if we had a restriction that a shared struct must be a top-level declaration then most type identity registration would occur during application start up (with the exception of portions of the module graph loaded dynamically via `import()`), which means conflicts (be they intentional or unintentional) would primarily occur early. Malicious code wouldn't be able to hijack an already-registered type identity.","format":"org.matrix.custom.html","formatted_body":"As I said earlier, if we had a restriction that a shared struct must be a top-level declaration then most type identity registration would occur during application start up (with the exception of portions of the module graph loaded dynamically via <code>import()</code>), which means conflicts (be they intentional or unintentional) would primarily occur early. Malicious code wouldn't be able to hijack an already-registered type identity.","msgtype":"m.text"},"ts":1675092427769,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ApAf2VoVwuolUFSUlQkstLCUvvmT3bb2aQ7Y1OurMYI"},
{"content":{"body":"how would that restriction work in Script?","msgtype":"m.text"},"ts":1675092496862,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$NMTfZpiQ8Hfg0RDNBJzmXJGL36-33p9NY5C8tWuBubM"},
{"content":{"body":"> <@ljharb:matrix.org> how would that restriction work in Script?\n\nThey would also need to be at the top-level of a Script, so no using a function as a factory for shared struct _types_. When evaluation of the module/script body completes, the file cannot produce new struct types. Yes, this isn't 100% reliable, but is at least as reliable as the current mechanisms used today to capture intrinsics before they can be patched/modified by other code.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$NMTfZpiQ8Hfg0RDNBJzmXJGL36-33p9NY5C8tWuBubM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>how would that restriction work in Script?</blockquote></mx-reply>They would also need to be at the top-level of a Script, so no using a function as a factory for shared struct <em>types</em>. When evaluation of the module/script body completes, the file cannot produce new struct types. Yes, this isn't 100% reliable, but is at least as reliable as the current mechanisms used today to capture intrinsics before they can be patched/modified by other code.","m.relates_to":{"m.in_reply_to":{"event_id":"$NMTfZpiQ8Hfg0RDNBJzmXJGL36-33p9NY5C8tWuBubM"}},"msgtype":"m.text"},"ts":1675092655965,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mAZinCI0H32Pgj80r1c2z4a7kNbm8Iu7Oz_wrJG1E7s"},
{"content":{"body":"I think that restriction is completely unrealistic, and makes it impossible to use this feature in a lot of programs","msgtype":"m.text"},"ts":1675092735024,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$BJDIOOzKQeVZX5f71SIrIh27nEAdqhyn1IiXlcuWLnA"},
{"content":{"body":"I only suggested the restriction as a possible remediation for the concern about type identity registration being forgeable.","msgtype":"m.text"},"ts":1675092783623,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HcUpQNmxv1vOMfkmJYqlry2MzXwGVsQzzOhgiK1Gu-o"},
{"content":{"body":"Realistically, even without this restriction, a type identity registry that depends on a first-in wins mechanism is still as reliable as existing intrinsic-capturing mechanisms.","msgtype":"m.text"},"ts":1675092846611,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wMCynzkjukpicGGVedaJbbql__H7dydOqOfOGgtr4Ck"},
{"content":{"body":"Javascript is a dynamic language. That suggestion is equivalent to forbidding features from the dynamic part of the language","msgtype":"m.text"},"ts":1675092860601,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$m_aVvOADmgcxhxHf9XUG1DdrE0D6yxxIYsiUU8jjHEY"},
{"content":{"body":"We already do that with features like `export`","format":"org.matrix.custom.html","formatted_body":"We already do that with features like <code>export</code>","msgtype":"m.text"},"ts":1675092885812,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$08AZrrU9rOl7TKE86lxrPaM8XKlDIMkgkMyMDT1XkQQ"},
{"content":{"body":"And I have explained why first win semantics for a global registry is a non-starter","msgtype":"m.text"},"ts":1675092902563,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Pi3N4G0k6Y1QWeXCr4XObnbphBPjWonslp4LwQU-D1M"},
{"content":{"body":"I don't want that restriction.","msgtype":"m.text"},"ts":1675092908184,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JJQsvW3UcYUhRtbXvGxpmumP6sw4zTE4PZQP5Y32B-4"},
{"content":{"body":"> <@mhofman:matrix.org> And I have explained why first win semantics for a global registry is a non-starter\n\nPer-agent global, or cross-agent global?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Pi3N4G0k6Y1QWeXCr4XObnbphBPjWonslp4LwQU-D1M?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>And I have explained why first win semantics for a global registry is a non-starter</blockquote></mx-reply>Per-agent global, or cross-agent global?","m.relates_to":{"m.in_reply_to":{"event_id":"$Pi3N4G0k6Y1QWeXCr4XObnbphBPjWonslp4LwQU-D1M"}},"msgtype":"m.text"},"ts":1675092927544,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1AMvf0rIIBMmXL7-MeeXM0Byga9z-o-SIheoXQYt40Y"},
{"content":{"body":"even per realm","msgtype":"m.text"},"ts":1675092941942,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ZzCULuGod4w8fLBn6i1NXUOHfyRgvx4vvrzREUDrPuU"},
{"content":{"body":"`export` being first win is not a precendent, like object spread is not a precendent. Both have a local effect (module or object)","format":"org.matrix.custom.html","formatted_body":"<code>export</code> being first win is not a precendent, like object spread is not a precendent. Both have a local effect (module or object)","msgtype":"m.text"},"ts":1675093004364,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$mPaqQg9WBN1Kiy5YKLZZcOx6t5pBKjVtkGsFE_wMbkY"},
{"content":{"body":"I still am not clear on why you believe a per-agent (or per-realm) write-only registry is a non-starter. If you don't want adversarial code to register first, you register first.","msgtype":"m.text"},"ts":1675093023357,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QhPMiY0h6zc-rgyt--UktCXCEXqMZtDg0SJYmAB1IjY"},
{"content":{"body":"who is \"you\"","msgtype":"m.text"},"ts":1675093044424,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$K1zRT9vXjHoVyoVp-e134iG0FPxklXrFuPaCMcjwcyc"},
{"content":{"body":"You, the application developer.","msgtype":"m.text"},"ts":1675093056740,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Jqi6spmA6u_VLBo-FLBNj3u90INsvUUP0mtoEYMyJHw"},
{"content":{"body":"Ok what about 2 libraries that the application load. Should lib1 be able to interfere with lib2 ?","msgtype":"m.text"},"ts":1675093089622,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$eGJTCd2k8ZiOI8SVS1IU84n8YKyT5m6T9pJyUh3vATc"},
{"content":{"body":"If you are a middleware, or a plugin, or something else running in a host environment where you don't control the environment, then you ensure your type identity is sufficiently unique. If you are the host environment loading a middleware, or plugin, etc., you architect your environment to be resilient to such a conflict.","msgtype":"m.text"},"ts":1675093151738,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gzAPipkmP6jCxZDkRC1cuAloa9jBl3qQvy-TcovCRp0"},
{"content":{"body":"there is no observable global mutable state in 262, and we would 100% block anything that introduces anything like it","msgtype":"m.text"},"ts":1675093164120,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$7Nj9pqy8oqSKf9Q2_LiR4715puhV_A6Qx7KsHlSw8W0"},
{"content":{"body":"the global object isn't that?","msgtype":"m.text"},"ts":1675093179385,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$rigCjwyE6gg1gmjwUYX8Dz7BmoVE4wlXArMvGKBWP2M"},
{"content":{"body":"or do you mean across realms (bigger than global, \"universal\" maybe)","msgtype":"m.text"},"ts":1675093189271,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$-ZZoSGPtbORD31598u83UCsSuzqiw-HjhXFIcAZyvlk"},
{"content":{"body":"minus the intrinsics/primordial objects themselves","msgtype":"m.text"},"ts":1675093195465,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$lA3y2mvjJtvVmswhD6fZApZdek2icq1CVzUf0wn9e2k"},
{"content":{"body":" * or do you mean across realms (bigger than global, \"universal\" maybe)","m.new_content":{"body":"or do you mean across realms (bigger than global, \"universal\" maybe)","msgtype":"m.text"},"m.relates_to":{"event_id":"$-ZZoSGPtbORD31598u83UCsSuzqiw-HjhXFIcAZyvlk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093195915,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$hPi9Ve_bEzEySY1Tp9hC44QcUBzW7uCu2niGlwOI1bM"},
{"content":{"body":"hidden *","msgtype":"m.text"},"ts":1675093197788,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$OiwxPvXQSWt1Url4bd75vBgMsLpakxY4DKRwKZeL-Rk"},
{"content":{"body":"sorry I forgot the hidden part","msgtype":"m.text"},"ts":1675093212535,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$uDFq1NT2w3OyxbTFG7vloIm_9CXo8hw8V2zNz0acwzk"},
{"content":{"body":"there's a few of those too already, but they're all freezeable ofc","msgtype":"m.text"},"ts":1675093225196,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$IcRW4NGecjvzwJrNWvgNrB1v3iWzFz9sldHkWTK5oMI"},
{"content":{"body":"where ?","msgtype":"m.text"},"ts":1675093230537,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ahN1pYxV8nR14787vF_E49O7Nm4Bb6-OcdQ1MIT0_yQ"},
{"content":{"body":" * there's a few of those too already, but they're all freezeable ofc","m.new_content":{"body":"there's a few of those too already, but they're all freezeable ofc","msgtype":"m.text"},"m.relates_to":{"event_id":"$IcRW4NGecjvzwJrNWvgNrB1v3iWzFz9sldHkWTK5oMI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093232956,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$cAz4ik7Dpw8Yd6GcP3jlDtVmR5uY9EVDu1JFFNvDsxs"},
{"content":{"body":"`AsyncFunction` is one, no?","format":"org.matrix.custom.html","formatted_body":"<code>AsyncFunction</code> is one, no?","msgtype":"m.text"},"ts":1675093241497,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$IFM9wljlZOrFIgsIjmU7alXGbnYfYyL7tWTYiG9_tOk"},
{"content":{"body":"hidden = internal","msgtype":"m.text"},"ts":1675093248503,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$HBQKJyGNUcRvORHxya2U03rSWjalOwA0PeqV58yI8rw"},
{"content":{"body":" * hideen= internal","m.new_content":{"body":"hideen= internal","msgtype":"m.text"},"m.relates_to":{"event_id":"$HBQKJyGNUcRvORHxya2U03rSWjalOwA0PeqV58yI8rw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093255961,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$BSgQ8X99_KLZMRMEWCgMWEXauY2p8V9btYs2Y-nrb9E"},
{"content":{"body":"i.e. not impacted by being frozen","msgtype":"m.text"},"ts":1675093259208,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$pn3y-M2YkAmmiSwIRUCy4TvHRA50O8nFa8VshLKEs2k"},
{"content":{"body":"yes the hidden intrinsics, which we're trying to fix","msgtype":"m.text"},"ts":1675093262976,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$0s6B_O-EnG2xWzuug8zKk65nLdfLCNgInUHWem94P8g"},
{"content":{"body":" * i.e. not impacted by being frozen","m.new_content":{"body":"i.e. not impacted by being frozen","msgtype":"m.text"},"m.relates_to":{"event_id":"$pn3y-M2YkAmmiSwIRUCy4TvHRA50O8nFa8VshLKEs2k","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093269854,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$TMZwSw7Z-SwEFGoDQL3GxEZcTr-xi5EPsSskGlukRCw"},
{"content":{"body":" * hideen = internal","m.new_content":{"body":"hideen = internal","msgtype":"m.text"},"m.relates_to":{"event_id":"$HBQKJyGNUcRvORHxya2U03rSWjalOwA0PeqV58yI8rw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093286621,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$FlgFgQmMPeqoCrJkKuOT7kxJPAziTvG4AtRQaKaDnqo"},
{"content":{"body":" * hidden = internal","m.new_content":{"body":"hidden = internal","msgtype":"m.text"},"m.relates_to":{"event_id":"$HBQKJyGNUcRvORHxya2U03rSWjalOwA0PeqV58yI8rw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093293335,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$O-xroRalfcAHza6mhUTJ9i8NnIuoLYO9mBw158M-1DE"},
{"content":{"body":"ashley has the correct wording there, AsyncFunction is accessible to JS code","msgtype":"m.text"},"ts":1675093313426,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$NOTFKFURGX_hlMKG7JBYIjV6BWAfUcLrTah_myVy_HI"},
{"content":{"body":"> <@mhofman:matrix.org> Ok what about 2 libraries that the application load. Should lib1 be able to interfere with lib2 ?\n\nIf lib2 doesn't want _unintentional_ interference, they should use sufficiently unique type identities. If lib1 performs _intentional_ interference, that's up to the application developer/host environment to mitigate, and a best effort from the runtime to surface that information early, hence the first-in wins registry. If you can only write new unique identities to the registry, either lib1 or lib2 will fail rather than be ignorant of hijacking.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$eGJTCd2k8ZiOI8SVS1IU84n8YKyT5m6T9pJyUh3vATc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Ok what about 2 libraries that the application load. Should lib1 be able to interfere with lib2 ?</blockquote></mx-reply>If lib2 doesn't want <em>unintentional</em> interference, they should use sufficiently unique type identities. If lib1 performs <em>intentional</em> interference, that's up to the application developer/host environment to mitigate, and a best effort from the runtime to surface that information early, hence the first-in wins registry. If you can only write new unique identities to the registry, either lib1 or lib2 will fail rather than be ignorant of hijacking.","m.relates_to":{"m.in_reply_to":{"event_id":"$eGJTCd2k8ZiOI8SVS1IU84n8YKyT5m6T9pJyUh3vATc"}},"msgtype":"m.text"},"ts":1675093323365,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hjBz2rqH2ZAB9eHvhaCf8C_eedjZGoGT9txj4bUNpe0"},
{"content":{"body":"> <@aclaymore:matrix.org> i.e. not impacted by being frozen\n\ngood thing RegExp.prototype isn't a regex anymore :-p","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$pn3y-M2YkAmmiSwIRUCy4TvHRA50O8nFa8VshLKEs2k?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br>i.e. not impacted by being frozen</blockquote></mx-reply>good thing RegExp.prototype isn't a regex anymore :-p","m.relates_to":{"m.in_reply_to":{"event_id":"$pn3y-M2YkAmmiSwIRUCy4TvHRA50O8nFa8VshLKEs2k"}},"msgtype":"m.text"},"ts":1675093408848,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$S9tAclJa2rk6f0r79K-hk86NoGOyLyfkMkXMI6YtVIo"},
{"content":{"body":"If the concern is about the registry not being freezable, that could be made possible via an API as well.","msgtype":"m.text"},"ts":1675093412050,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2gFUPX_eJaIeVtScqyNo_qGmOgDvd-98ETcE0cPpT3g"},
{"content":{"body":"But again that would prevent the feature from working","msgtype":"m.text"},"ts":1675093434925,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$clFBYEWBYjMdE_AwdtQuF4mOyqgswm3ndNAy6TEYFcw"},
{"content":{"body":"Yes, if malicious code were to freeze the registry your application would stop working. Which would be a fairly good indication that there is malicious code freezing the registry (at least, with a sufficiently clear error message).","msgtype":"m.text"},"ts":1675093499068,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0r9YL9fT6HaRTiOGgq1pZYpfzWVza_6Lhl5IRIgcN4g"},
{"content":{"body":"I want any JS feature where I can dynamically load code, that will keep working regardless of previous code that was loaded and executed (if you ignore mutation to the global object and intrinsics)","msgtype":"m.text"},"ts":1675093514475,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$UmXKLHRkxIy1iqLsHXxO-IXdxRmHb1mPnPEChGOZklQ"},
{"content":{"body":"Just like some packages not working with SES when it locks down the environment.","msgtype":"m.text"},"ts":1675093518897,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mDNuWrzes42jmEs1gApmgwxuxvmICYWqEkXZcYp5f88"},
{"content":{"body":"It feels like you are arguing two opposing positions: Such a registry must be mutable so that code keeps working, but malicious code shouldn't be able to mutate it to hijack it.","msgtype":"m.text"},"ts":1675093593313,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QFlj-cEsNSjvr9TYqKRKWp95LSF4dc_fI5FJoNZwUv4"},
{"content":{"body":"No, I'm arguing this feature cannot use a global registry with forgeable keys because it'd be impossible to make it safe","msgtype":"m.text"},"ts":1675093703226,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$cx2u_Dvb-ulSkCPBRUdFggOEhu_8JSbIN2a6_mlBYl0"},
{"content":{"body":"Perhaps it would be better to outline the specific capabilities we want, the limitations of the environment and ecosystem, and the concerns we have for any given solution. From there we can better determine hard and fast requirements and find potential compromises.","msgtype":"m.text"},"ts":1675093717145,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hqIKEu2l35SdMglf89Ei2M9gzYOXsz9xOslBkxMdQII"},
{"content":{"body":"> <@mhofman:matrix.org> No, I'm arguing this feature cannot use a global registry with forgeable keys because it'd be impossible to make it safe\n\nI'm more than willing to entertain other solutions, but its important that the developer experience doesn't make the feature wholly unusable.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$cx2u_Dvb-ulSkCPBRUdFggOEhu_8JSbIN2a6_mlBYl0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>No, I&#39;m arguing this feature cannot use a global registry with forgeable keys because it&#39;d be impossible to make it safe</blockquote></mx-reply>I'm more than willing to entertain other solutions, but its important that the developer experience doesn't make the feature wholly unusable.","m.relates_to":{"m.in_reply_to":{"event_id":"$cx2u_Dvb-ulSkCPBRUdFggOEhu_8JSbIN2a6_mlBYl0"}},"msgtype":"m.text"},"ts":1675093778732,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$d2uw8bkFzYbe0k8ONNyOMjvLtElIdKz34sz5xsDoGmg"},
{"content":{"body":"you can have a global registry, as long as it cannot be used by code that hasn't been previously introduced to each other to interact.","msgtype":"m.text"},"ts":1675093796769,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$mWw0eyb7fttpr5ijs8YX4rBhdyToadTcjHHnnf31yHM"},
{"content":{"body":"Needing to patch or wire up the prototype in `onmessage` is terrible DX.","format":"org.matrix.custom.html","formatted_body":"Needing to patch or wire up the prototype in <code>onmessage</code> is terrible DX.","msgtype":"m.text"},"ts":1675093834459,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IM9WmUzOfilStNWMmapKyVrdKy20NNRrbe2KWkGMzyM"},
{"content":{"body":"How would you describe how these introductions should work?","format":"org.matrix.custom.html","formatted_body":"How would you describe how these introductions should work?","msgtype":"m.text","m.relates_to":{"m.in_reply_to":{"event_id":"$mWw0eyb7fttpr5ijs8YX4rBhdyToadTcjHHnnf31yHM"}}},"ts":1675093866321,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$phKNdyHNGWoTCiAAacCguUZl3Z18DgNDEr26MNfetT8"},
{"content":{"body":"This is the reason I would block any string based registry that you can ask the question (directly or indirectly) \"do you have this key\"","msgtype":"m.text"},"ts":1675093894116,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$suEI_lToSy4m4uiCOrimMzx0XEc-xhhby8PSCiEzEqM"},
{"content":{"body":"> <@rbuckton:matrix.org> Needing to patch or wire up the prototype in `onmessage` is terrible DX.\n\nI say this as someone who wrote a package that implements struct-like behavior backed by `SharedArrayBuffer` that does this. The only reason it works is that the \"structs\" you create are fully typed, so you don't have to walk a graph to wire up prototypes because it does that for you.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$IM9WmUzOfilStNWMmapKyVrdKy20NNRrbe2KWkGMzyM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Needing to patch or wire up the prototype in <code>onmessage</code> is terrible DX.</blockquote></mx-reply>I say this as someone who wrote a package that implements struct-like behavior backed by <code>SharedArrayBuffer</code> that does this. The only reason it works is that the &quot;structs&quot; you create are fully typed, so you don't have to walk a graph to wire up prototypes because it does that for you.","m.relates_to":{"m.in_reply_to":{"event_id":"$IM9WmUzOfilStNWMmapKyVrdKy20NNRrbe2KWkGMzyM"}},"msgtype":"m.text"},"ts":1675093935082,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0cqbp0Sw7qswUGQ4MDUQy1AGiMzzy-Cv_1fYJtbzAhE"},
{"content":{"body":"> <@mhofman:matrix.org> you can have a global registry, as long as it cannot be used by code that hasn't been previously introduced to each other to interact.\n\n * How would you describe how these introductions should work?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$mWw0eyb7fttpr5ijs8YX4rBhdyToadTcjHHnnf31yHM?via=matrix.org&amp;via=igalia.com&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>you can have a global registry, as long as it cannot be used by code that hasn't been previously introduced to each other to interact.</blockquote></mx-reply> * How would you describe how these introductions should work?","m.new_content":{"body":"How would you describe how these introductions should work?","format":"org.matrix.custom.html","formatted_body":"How would you describe how these introductions should work?","msgtype":"m.text"},"m.relates_to":{"event_id":"$phKNdyHNGWoTCiAAacCguUZl3Z18DgNDEr26MNfetT8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675093959031,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$X6IvxMLvq8MOBjABbTD0-LQaGf6hJ73Hb_HnDcKny_g"},
{"content":{"body":"> <@mhofman:matrix.org> This is the reason I would block any string based registry that you can ask the question (directly or indirectly) \"do you have this key\"\n\nHow deep does this concern extend? Agent-scoped registries, apparently, but what about realm-scoped registry?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$suEI_lToSy4m4uiCOrimMzx0XEc-xhhby8PSCiEzEqM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>This is the reason I would block any string based registry that you can ask the question (directly or indirectly) &quot;do you have this key&quot;</blockquote></mx-reply>How deep does this concern extend? Agent-scoped registries, apparently, but what about realm-scoped registry?","m.relates_to":{"m.in_reply_to":{"event_id":"$suEI_lToSy4m4uiCOrimMzx0XEc-xhhby8PSCiEzEqM"}},"msgtype":"m.text"},"ts":1675094091017,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$srm5-_soE4El0I9zV-uFF3AU0lrTHSdmQTKQv8Zc4mo"},
{"content":{"body":"realm scoped registries too","msgtype":"m.text"},"ts":1675094117766,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$6606uVfE1MDnQZqa1P6BRrVnt9SWhNNYuQQaggm87Rs"},
{"content":{"body":"To clarify, your concern is that such a string-based registry could be used as a side-channel for communication (i.e., it could be used to exfiltrate data)?","msgtype":"m.text"},"ts":1675094302001,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RbeJZJa9LctC4OaquWJPTYj3nKyPKQMyQssE5u0g8RQ"},
{"content":{"body":"hm there seems to be a lot of back and forth i've missed here, is there a tl;dr (no rush)?","msgtype":"m.text"},"ts":1675094342354,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$tcni7WDpY7835OGq9XamzzAOBgjWjXnO2ugILLYyN3k"},
{"content":{"body":"In the solution I presented, the application either has to do a manual bootstrap (sending once over postMessage the unforgeable type identifier, and wire it to the expected implementation), or give up on prototype continuity (aka an incoming shared struct's dynamic proto would not be the same object as the dynamic proto of an \"equivalent\" shared struct created locally)","msgtype":"m.text"},"ts":1675094346508,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$L70S5zgeP-aDJ5Qt2P3Fz9HMvRne1Gigu4indgncelM"},
{"content":{"body":"side channel and/or denial of service","msgtype":"m.text"},"ts":1675094387538,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$GstCwl7ql0cs1-z-I2dqTX3cgsfobUzmH40RurTU7Yk"},
{"content":{"body":"If we had module block with stable identity over postMessage, the discontinuity could be mitigated","msgtype":"m.text"},"ts":1675094476426,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$k8VxeRuLOKxQXwvqf1TVh1ansjOhOveuxBpSD3SGryU"},
{"content":{"body":"> <@mhofman:matrix.org> In the solution I presented, the application either has to do a manual bootstrap (sending once over postMessage the unforgeable type identifier, and wire it to the expected implementation), or give up on prototype continuity (aka an incoming shared struct's dynamic proto would not be the same object as the dynamic proto of an \"equivalent\" shared struct created locally)\n\nWhat if such a registry were per-channel? i.e., a `MessagePort` might have an internal registry of type-identity to prototype, and you'd have to set up that registry on each side?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$L70S5zgeP-aDJ5Qt2P3Fz9HMvRne1Gigu4indgncelM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>In the solution I presented, the application either has to do a manual bootstrap (sending once over postMessage the unforgeable type identifier, and wire it to the expected implementation), or give up on prototype continuity (aka an incoming shared struct&#39;s dynamic proto would not be the same object as the dynamic proto of an &quot;equivalent&quot; shared struct created locally)</blockquote></mx-reply>What if such a registry were per-channel? i.e., a <code>MessagePort</code> might have an internal registry of type-identity to prototype, and you'd have to set up that registry on each side?","m.relates_to":{"m.in_reply_to":{"event_id":"$L70S5zgeP-aDJ5Qt2P3Fz9HMvRne1Gigu4indgncelM"}},"msgtype":"m.text"},"ts":1675094482367,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KEqDsCdkAi0GXE_3c4z1nXzegtXZ2JNl-q2BJti96Vk"},
{"content":{"body":"> <@mhofman:matrix.org> If we had module block with stable identity over postMessage, the discontinuity could be mitigated\n\nBecause you send the module block over `postMessage` to evaluate so that both sides have the same representation? ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$k8VxeRuLOKxQXwvqf1TVh1ansjOhOveuxBpSD3SGryU?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>If we had module block with stable identity over postMessage, the discontinuity could be mitigated</blockquote></mx-reply>Because you send the module block over <code>postMessage</code> to evaluate so that both sides have the same representation?","m.relates_to":{"m.in_reply_to":{"event_id":"$k8VxeRuLOKxQXwvqf1TVh1ansjOhOveuxBpSD3SGryU"}},"msgtype":"m.text"},"ts":1675094529396,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ATWjja1R17opd-qn7AQNpBCfl2dqV5j3vHAZBs_UT90"},
{"content":{"body":"I think a per-channel registry would likely exacerbate identity discontinuity issues, but since they registration would be tied to a non-global capability, it would be acceptable to use forgeable identifiers","msgtype":"m.text"},"ts":1675094578646,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$b07NXbEOkR5d74FvZULfMnsU2NVarrwqvRbOdbHIsOE"},
{"content":{"body":"My concerns with bootstrapping with a module block is how much other information would need to be bootstrapped along with it to support code-sharing (i.e., imports and package dependencies) making it harder for the other side to ensure initialization is consistent (i.e., any registration that needs to happen, or perhaps conditional imports depending on whether the code is running in the browser main thread or in a worker, etc.).\nAnd if that were easily solvable, we could also potentially solve that by bootstrapping just with the struct type definition itself (i.e., can we do this without depending on module blocks?).","msgtype":"m.text"},"ts":1675094814381,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$6GslDFqyQQ10sWQlKxjl-NlF0RdDjINieCIHJALeu0c"},
{"content":{"body":"> <@mhofman:matrix.org> I think a per-channel registry would likely exacerbate identity discontinuity issues, but since they registration would be tied to a non-global capability, it would be acceptable to use forgeable identifiers\n\nFrom an API standpoint, I could potentially see there being some kind of built-in `SharedStructTypeIdentityRegistry` that a package could export, such that a host could import the registry and use it to configure a `MessagePort`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$b07NXbEOkR5d74FvZULfMnsU2NVarrwqvRbOdbHIsOE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I think a per-channel registry would likely exacerbate identity discontinuity issues, but since they registration would be tied to a non-global capability, it would be acceptable to use forgeable identifiers</blockquote></mx-reply>From an API standpoint, I could potentially see there being some kind of built-in <code>SharedStructTypeIdentityRegistry</code> that a package could export, such that a host could import the registry and use it to configure a <code>MessagePort</code>.","m.relates_to":{"m.in_reply_to":{"event_id":"$b07NXbEOkR5d74FvZULfMnsU2NVarrwqvRbOdbHIsOE"}},"msgtype":"m.text"},"ts":1675094916865,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dlYu0kSZnsHc7TmAAIi1I4U8AZSRX12BZ4OMB5VWrws"},
{"content":{"body":"> <@shuyuguo:matrix.org> hm there seems to be a lot of back and forth i've missed here, is there a tl;dr (no rush)?\n\nHow to manage type identity across Agents/Realms/etc. in a way that doesn't violate security concerns, but works for bundlers (so solely relying on module id/file path isn't viable).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$tcni7WDpY7835OGq9XamzzAOBgjWjXnO2ugILLYyN3k?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>hm there seems to be a lot of back and forth i&#39;ve missed here, is there a tl;dr (no rush)?</blockquote></mx-reply>How to manage type identity across Agents/Realms/etc. in a way that doesn't violate security concerns, but works for bundlers (so solely relying on module id/file path isn't viable).","m.relates_to":{"m.in_reply_to":{"event_id":"$tcni7WDpY7835OGq9XamzzAOBgjWjXnO2ugILLYyN3k"}},"msgtype":"m.text"},"ts":1675095009321,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KZ6rvM4oVJHEEqEA84JOAMHUdnOHfPQseM-sTEu39sE"},
{"content":{"body":"> <@rbuckton:matrix.org> Because you send the module block over `postMessage` to evaluate so that both sides have the same representation?\n\nKinda. Each agent could have its own type for an \"equivalent\" shared struct, but if the code declaring the struct uses a module instance to define the struct's behavior / dynamic prototype, that module instance can be automatically loaded by other realms. When receiving a struct of that type, the observed prototype object would be the same as the prototype of the locally defined struct, if the local definition used the same module instance (which required module instances to be stable across agents). The \"mostly mitigated\" part is because the constructor couldn't be on the prototype, as that is realm specific of course","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$ATWjja1R17opd-qn7AQNpBCfl2dqV5j3vHAZBs_UT90?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Because you send the module block over <code>postMessage</code> to evaluate so that both sides have the same representation?</blockquote></mx-reply>Kinda. Each agent could have its own type for an &quot;equivalent&quot; shared struct, but if the code declaring the struct uses a module instance to define the struct's behavior / dynamic prototype, that module instance can be automatically loaded by other realms. When receiving a struct of that type, the observed prototype object would be the same as the prototype of the locally defined struct, if the local definition used the same module instance (which required module instances to be stable across agents). The &quot;mostly mitigated&quot; part is because the constructor couldn't be on the prototype, as that is realm specific of course","m.relates_to":{"m.in_reply_to":{"event_id":"$ATWjja1R17opd-qn7AQNpBCfl2dqV5j3vHAZBs_UT90"}},"msgtype":"m.text"},"ts":1675095018092,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$1GIEi8xXFNVtjdDOzpqIqOjfkb6Tmyp8jwyT9KgRg1I"},
{"content":{"body":"> <@rbuckton:matrix.org> From an API standpoint, I could potentially see there being some kind of built-in `SharedStructTypeIdentityRegistry` that a package could export, such that a host could import the registry and use it to configure a `MessagePort`.\n\nI did not understand this suggestion","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$dlYu0kSZnsHc7TmAAIi1I4U8AZSRX12BZ4OMB5VWrws?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>From an API standpoint, I could potentially see there being some kind of built-in <code>SharedStructTypeIdentityRegistry</code> that a package could export, such that a host could import the registry and use it to configure a <code>MessagePort</code>.</blockquote></mx-reply>I did not understand this suggestion","m.relates_to":{"m.in_reply_to":{"event_id":"$dlYu0kSZnsHc7TmAAIi1I4U8AZSRX12BZ4OMB5VWrws"}},"msgtype":"m.text"},"ts":1675095176519,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$LC8rREsVyK83muXi0HxtGYj2U_Wr-S3yKJdccN1GQIs"},
{"content":{"body":"I'm mostly suggesting a way to simply the DX around registration, making it easier to combine registries from multiple packages, and to define the composite registry on each side of a message port. ","msgtype":"m.text"},"ts":1675095361455,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yvGK0NmnkggHITV0m3UBboQHJX9WgOn8rKV9sPaE6wU"},
{"content":{"body":"The code that runs on each side could be different for the same struct type given practices such as bundling and tree shaking, and in some cases a struct type may need a method tailored to an environment (i.e., can its methods access node-native bindings, can this method only be run in the browser), etc.","msgtype":"m.text"},"ts":1675095460454,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-E_C8trfbkHS-wFBKG61B4zRoCvXS4lm9yWYkq1gKCQ"},
{"content":{"body":"Having an observably similar prototype is profoundly useful, but mandating a similar prototype limits flexibility.","msgtype":"m.text"},"ts":1675095523447,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zZ70LQ3SaJqnBEoOeONxf--rmU2eLxsF3WLhek8y7HY"},
{"content":{"body":"TLDR here is that registration would be implicit the first time a struct of a given type is shared with another realm/agent if the struct definition used a module instance at declaration. If the same module instance loaded in 2 different agents has a stable identity, aka if `receivedModuleInstance === importedModuleInstance`, then you don't have any prototype discontinuity issues. If the bundler messes up these module identities, then the program has to first send the type identity explicitly over a `postMessage` and the receiving code has to manually do `SharedStructType.register(receivedModuleType, importedModuleInstance)`","format":"org.matrix.custom.html","formatted_body":"TLDR here is that registration would be implicit the first time a struct of a given type is shared with another realm/agent if the struct definition used a module instance at declaration. If the same module instance loaded in 2 different agents has a stable identity, aka if <code>receivedModuleInstance === importedModuleInstance</code>, then you don't have any prototype discontinuity issues. If the bundler messes up these module identities, then the program has to first send the type identity explicitly over a <code>postMessage</code> and the receiving code has to manually do <code>SharedStructType.register(receivedModuleType, importedModuleInstance)</code>","msgtype":"m.text","m.relates_to":{"m.in_reply_to":{"event_id":"$1GIEi8xXFNVtjdDOzpqIqOjfkb6Tmyp8jwyT9KgRg1I"}}},"ts":1675095633152,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$cAr61_usXIAhn6iApz4bLxFPk7sf4S50649Vzarywog"},
{"content":{"body":"> <@mhofman:matrix.org> Kinda. Each agent could have its own type for an \"equivalent\" shared struct, but if the code declaring the struct uses a module instance to define the struct's behavior / dynamic prototype, that module instance can be automatically loaded by other realms. When receiving a struct of that type, the observed prototype object would be the same as the prototype of the locally defined struct, if the local definition used the same module instance (which required module instances to be stable across agents). The \"mostly mitigated\" part is because the constructor couldn't be on the prototype, as that is realm specific of course\n\n * TLDR here is that registration would be implicit the first time a struct of a given type is shared with another realm/agent if the struct definition used a module instance at declaration. If the same module instance loaded in 2 different agents has a stable identity, aka if `receivedModuleInstance === importedModuleInstance`, then you don't have any prototype discontinuity issues. If the bundler messes up these module identities, then the program has to first send the type identity explicitly over a `postMessage` and the receiving code has to manually do `SharedStructType.register(receivedModuleType, importedModuleInstance)`","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$1GIEi8xXFNVtjdDOzpqIqOjfkb6Tmyp8jwyT9KgRg1I?via=matrix.org&amp;via=igalia.com&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Kinda. Each agent could have its own type for an \"equivalent\" shared struct, but if the code declaring the struct uses a module instance to define the struct's behavior / dynamic prototype, that module instance can be automatically loaded by other realms. When receiving a struct of that type, the observed prototype object would be the same as the prototype of the locally defined struct, if the local definition used the same module instance (which required module instances to be stable across agents). The \"mostly mitigated\" part is because the constructor couldn't be on the prototype, as that is realm specific of course</blockquote></mx-reply> * TLDR here is that registration would be implicit the first time a struct of a given type is shared with another realm/agent if the struct definition used a module instance at declaration. If the same module instance loaded in 2 different agents has a stable identity, aka if <code>receivedModuleInstance === importedModuleInstance</code>, then you don't have any prototype discontinuity issues. If the bundler messes up these module identities, then the program has to first send the type identity explicitly over a <code>postMessage</code> and the receiving code has to manually do <code>SharedStructType.register(receivedModuleType, importedModuleInstance)</code>","m.new_content":{"body":"TLDR here is that registration would be implicit the first time a struct of a given type is shared with another realm/agent if the struct definition used a module instance at declaration. If the same module instance loaded in 2 different agents has a stable identity, aka if `receivedModuleInstance === importedModuleInstance`, then you don't have any prototype discontinuity issues. If the bundler messes up these module identities, then the program has to first send the type identity explicitly over a `postMessage` and the receiving code has to manually do `SharedStructType.register(receivedModuleType, importedModuleInstance)`","format":"org.matrix.custom.html","formatted_body":"TLDR here is that registration would be implicit the first time a struct of a given type is shared with another realm/agent if the struct definition used a module instance at declaration. If the same module instance loaded in 2 different agents has a stable identity, aka if <code>receivedModuleInstance === importedModuleInstance</code>, then you don't have any prototype discontinuity issues. If the bundler messes up these module identities, then the program has to first send the type identity explicitly over a <code>postMessage</code> and the receiving code has to manually do <code>SharedStructType.register(receivedModuleType, importedModuleInstance)</code>","msgtype":"m.text"},"m.relates_to":{"event_id":"$cAr61_usXIAhn6iApz4bLxFPk7sf4S50649Vzarywog","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675095676998,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$RaU-1JQJs1rTT8HPZd8lQt16mQUfhQ1T_qtwR2WiRb8"},
{"content":{"body":"Btw, you can use string identifier over `postMessage` for the application to know what the opaque type identifier is about, restoring your string based semantics. That would be scoped to whatever is holding the string identifier registry (possibly the channel itself).","format":"org.matrix.custom.html","formatted_body":"Btw, you can use string identifier over <code>postMessage</code> for the application to know what the opaque type identifier is about, restoring your string based semantics. That would be scoped to whatever is holding the string identifier registry (possibly the channel itself).","msgtype":"m.text"},"ts":1675095940850,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$qKwIRb5UgQTW5eL84Xcyhg6HR_6jWxpoX-brw2sr-vU"},
{"content":{"body":"> <@mhofman:matrix.org> Btw, you can use string identifier over `postMessage` for the application to know what the opaque type identifier is about, restoring your string based semantics. That would be scoped to whatever is holding the string identifier registry (possibly the channel itself).\n\nThat's still a poor DX as it would significantly overcomplicate `onmessage` handlers by requiring custom scaffolding in every project to bootstrap. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$qKwIRb5UgQTW5eL84Xcyhg6HR_6jWxpoX-brw2sr-vU?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Btw, you can use string identifier over <code>postMessage</code> for the application to know what the opaque type identifier is about, restoring your string based semantics. That would be scoped to whatever is holding the string identifier registry (possibly the channel itself).</blockquote></mx-reply>That's still a poor DX as it would significantly overcomplicate <code>onmessage</code> handlers by requiring custom scaffolding in every project to bootstrap.","m.relates_to":{"m.in_reply_to":{"event_id":"$qKwIRb5UgQTW5eL84Xcyhg6HR_6jWxpoX-brw2sr-vU"}},"msgtype":"m.text"},"ts":1675096038839,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$psjrQLOVg6K6Xq_huxmB7mLCWwBtgRUwTTojKfUe9wM"},
{"content":{"body":"The `SharedStructTypeIdentityRegistry` suggestion above would handle the per-channel string identifier registry without requiring prior communication between each side of a channel.","format":"org.matrix.custom.html","formatted_body":"The <code>SharedStructTypeIdentityRegistry</code> suggestion above would handle the per-channel string identifier registry without requiring prior communication between each side of a channel.","msgtype":"m.text"},"ts":1675096123142,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XjJbDa81h4vQorIld08DnAQ4_xXWiGPFtccGtVgTMF0"},
{"content":{"body":"Consider, for example:\n\n```js\n// node_modules/threejs/src/math/Vector2.js\nimport { structRegistry } from \"../registry.js\"\n\n@structRegistry.register(\"http://threejs.com/structs/Vector2\")\nshared struct Vector2 { ... }\n\n// main.js\nimport { Vector2, structRegistry } from \"threejs\";\n\nconst worker = new Worker(\"./worker.js\", { structRegistry });\nworker.postMessage(new Vector2(0, 0));\n\n// worker.js\nimport { structRegistry } from \"threejs\";\nimport { parentPort } from \"worker_threads\";\nparentPort.addRegistry(structRegistry);\nparentPort.on(\"message\", v => {\n  v.whatever();\n});\n```","format":"org.matrix.custom.html","formatted_body":"<p>Consider, for example:</p>\n<pre><code class=\"language-js\">// node_modules/threejs/src/math/Vector2.js\nimport { structRegistry } from &quot;../registry.js&quot;\n\n@structRegistry.register(&quot;http://threejs.com/structs/Vector2&quot;)\nshared struct Vector2 { ... }\n\n// main.js\nimport { Vector2, structRegistry } from &quot;threejs&quot;;\n\nconst worker = new Worker(&quot;./worker.js&quot;, { structRegistry });\nworker.postMessage(new Vector2(0, 0));\n\n// worker.js\nimport { structRegistry } from &quot;threejs&quot;;\nimport { parentPort } from &quot;worker_threads&quot;;\nparentPort.addRegistry(structRegistry);\nparentPort.on(&quot;message&quot;, v =&gt; {\n  v.whatever();\n});\n</code></pre>\n","msgtype":"m.text"},"ts":1675096685242,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7WPehSD4GfcfQ_0UjN-fKG0PrIW3_1OOe9JA3zblrWA"},
{"content":{"body":"Both the main and worker threads load the same struct type, though they could be in different bundles and tree shaking could remove some members. They independently associate type registries with their sides of the channel.","msgtype":"m.text"},"ts":1675096759419,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hKQ1BH2T6qlX9jg85uWk1xhQoScwdKeMbDauoW031Sw"},
{"content":{"body":" * Consider, for example:\n\n```js\n// node_modules/threejs/src/registry.js\nexport const structRegistryWriter = new StructTypeRegistryWriter();\nexport const structRegistry = structRegistryWriter.registry;\n\n// node_modules/threejs/src/math/Vector2.js\nimport { structRegistryWriter } from \"../registry.js\"\n\n@structRegistry.register(\"http://threejs.com/structs/Vector2\")\nshared struct Vector2 { ... }\n\n// main.js\nimport { Vector2, structRegistry } from \"threejs\";\n\nconst worker = new Worker(\"./worker.js\", { structRegistry });\nworker.postMessage(new Vector2(0, 0));\n\n// worker.js\nimport { structRegistry } from \"threejs\";\nimport { parentPort } from \"worker_threads\";\nparentPort.addRegistry(structRegistry);\nparentPort.on(\"message\", v => {\n  v.whatever();\n});\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Consider, for example:</p>\n<pre><code class=\"language-js\">// node_modules/threejs/src/registry.js\nexport const structRegistryWriter = new StructTypeRegistryWriter();\nexport const structRegistry = structRegistryWriter.registry;\n\n// node_modules/threejs/src/math/Vector2.js\nimport { structRegistryWriter } from &quot;../registry.js&quot;\n\n@structRegistry.register(&quot;http://threejs.com/structs/Vector2&quot;)\nshared struct Vector2 { ... }\n\n// main.js\nimport { Vector2, structRegistry } from &quot;threejs&quot;;\n\nconst worker = new Worker(&quot;./worker.js&quot;, { structRegistry });\nworker.postMessage(new Vector2(0, 0));\n\n// worker.js\nimport { structRegistry } from &quot;threejs&quot;;\nimport { parentPort } from &quot;worker_threads&quot;;\nparentPort.addRegistry(structRegistry);\nparentPort.on(&quot;message&quot;, v =&gt; {\n  v.whatever();\n});\n</code></pre>\n","m.new_content":{"body":"Consider, for example:\n\n```js\n// node_modules/threejs/src/registry.js\nexport const structRegistryWriter = new StructTypeRegistryWriter();\nexport const structRegistry = structRegistryWriter.registry;\n\n// node_modules/threejs/src/math/Vector2.js\nimport { structRegistryWriter } from \"../registry.js\"\n\n@structRegistry.register(\"http://threejs.com/structs/Vector2\")\nshared struct Vector2 { ... }\n\n// main.js\nimport { Vector2, structRegistry } from \"threejs\";\n\nconst worker = new Worker(\"./worker.js\", { structRegistry });\nworker.postMessage(new Vector2(0, 0));\n\n// worker.js\nimport { structRegistry } from \"threejs\";\nimport { parentPort } from \"worker_threads\";\nparentPort.addRegistry(structRegistry);\nparentPort.on(\"message\", v => {\n  v.whatever();\n});\n```","format":"org.matrix.custom.html","formatted_body":"<p>Consider, for example:</p>\n<pre><code class=\"language-js\">// node_modules/threejs/src/registry.js\nexport const structRegistryWriter = new StructTypeRegistryWriter();\nexport const structRegistry = structRegistryWriter.registry;\n\n// node_modules/threejs/src/math/Vector2.js\nimport { structRegistryWriter } from &quot;../registry.js&quot;\n\n@structRegistry.register(&quot;http://threejs.com/structs/Vector2&quot;)\nshared struct Vector2 { ... }\n\n// main.js\nimport { Vector2, structRegistry } from &quot;threejs&quot;;\n\nconst worker = new Worker(&quot;./worker.js&quot;, { structRegistry });\nworker.postMessage(new Vector2(0, 0));\n\n// worker.js\nimport { structRegistry } from &quot;threejs&quot;;\nimport { parentPort } from &quot;worker_threads&quot;;\nparentPort.addRegistry(structRegistry);\nparentPort.on(&quot;message&quot;, v =&gt; {\n  v.whatever();\n});\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$7WPehSD4GfcfQ_0UjN-fKG0PrIW3_1OOe9JA3zblrWA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675096807731,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oAvH84cyNiZiYpwY9GYzdSLvgth4IQeH4k9UFnbHIVE"},
{"content":{"body":"While not automatic, the registration mechanism stays as out of the way as possible to simplify the developer experience.","msgtype":"m.text"},"ts":1675096854466,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$D2UnvBfEiT9KxD3qc2qJPvEuGdjNyaSz_KvCAK7GFCY"},
{"content":{"body":"Basically it'd look like \n\n```js\n// Done by all workers independently\nimport Vector2DPrototype from \"vector2dBehavior.js\" with { reflect: \"module\" };\nconst { constructor: Vector2D, type: Vector2DType } = SharedStructType.prepare([\"x\", \"y\"]);\nSharedStructType.register(Vector2DType, Vector2DPrototype);\nconst Vector2DUUID = '...';\nconst structAwareChannel = new MessageChannel();\nstructAwareChannel.register(Vector2DUUID, Vector2DType, Vector2DPrototype);\n\n// worker1.js\nconst v1 = new Vector2D({x: 1, y: 2});\nstructAwareChannel.postMessage({v1});\n\n// worker2.js\nchannel.on(\"message\", ({v1}) => {\n  console.log(v1 instanceof Vector2D); // true because prototype match even though type instance different\n});\n```","format":"org.matrix.custom.html","formatted_body":"<p>Basically it'd look like</p>\n<pre><code class=\"language-js\">// Done by all workers independently\nimport Vector2DPrototype from &quot;vector2dBehavior.js&quot; with { reflect: &quot;module&quot; };\nconst { constructor: Vector2D, type: Vector2DType } = SharedStructType.prepare([&quot;x&quot;, &quot;y&quot;]);\nSharedStructType.register(Vector2DType, Vector2DPrototype);\nconst Vector2DUUID = '...';\nconst structAwareChannel = new MessageChannel();\nstructAwareChannel.register(Vector2DUUID, Vector2DType, Vector2DPrototype);\n\n// worker1.js\nconst v1 = new Vector2D({x: 1, y: 2});\nstructAwareChannel.postMessage({v1});\n\n// worker2.js\nchannel.on(&quot;message&quot;, ({v1}) =&gt; {\n  console.log(v1 instanceof Vector2D); // true because prototype match even though type instance different\n});\n</code></pre>\n","msgtype":"m.text"},"ts":1675096902995,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Ds9CW5YaXOWLcjq8zTAZmt5MF1fIBXm4mbFZr1OKX9g"},
{"content":{"body":"That's definitely not great for the actual proposal, that seems far to easy to get wrong. Maybe ok in the prototyping stage, but not long term.","msgtype":"m.text"},"ts":1675097096334,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JqAijRE6Y64ij8p-SfbHq3lZJ-Su-plIatTd0ZTXqoI"},
{"content":{"body":"I actually don't think our approaches diverge that much","msgtype":"m.text"},"ts":1675097123084,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$7vmV4g2ZhqKv1Nyk-H4CqOcJy1225QgdU2u_rTVs3Sw"},
{"content":{"body":"What happens if `vector2dBehavior.js` requires a package already loaded on the worker? Will it import the worker version, or carry along its transitive dependencies to be re-evaluated on the worker?","format":"org.matrix.custom.html","formatted_body":"What happens if <code>vector2dBehavior.js</code> requires a package already loaded on the worker? Will it import the worker version, or carry along its transitive dependencies to be re-evaluated on the worker?","msgtype":"m.text"},"ts":1675097146644,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xb8fGFFsj_GmudVdbN7i2xthKU7csOYOvkRNuURIqIQ"},
{"content":{"body":"if the struct types are declared independently, they will have different types, and thus different constructors","msgtype":"m.text"},"ts":1675097173735,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$gzwEURtl90cVMT389Npzkx_xYrP91nyyBucU9Lbpw5E"},
{"content":{"body":"> <@rbuckton:matrix.org> What happens if `vector2dBehavior.js` requires a package already loaded on the worker? Will it import the worker version, or carry along its transitive dependencies to be re-evaluated on the worker?\n\nDoesn't matter? ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$xb8fGFFsj_GmudVdbN7i2xthKU7csOYOvkRNuURIqIQ?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>What happens if <code>vector2dBehavior.js</code> requires a package already loaded on the worker? Will it import the worker version, or carry along its transitive dependencies to be re-evaluated on the worker?</blockquote></mx-reply>Doesn't matter?","m.relates_to":{"m.in_reply_to":{"event_id":"$xb8fGFFsj_GmudVdbN7i2xthKU7csOYOvkRNuURIqIQ"}},"msgtype":"m.text"},"ts":1675097240222,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$0H6hbOSSQyxVYHBh7c5xL_8tfWNZAmIG6Nmgd0arKXA"},
{"content":{"body":"Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a `SharedStructType` constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like `with { reflect: \"module\" }` or module blocks, which are nowhere near ready for adoption.","format":"org.matrix.custom.html","formatted_body":"Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a <code>SharedStructType</code> constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like <code>with { reflect: &quot;module&quot; }</code> or module blocks, which are nowhere near ready for adoption.","msgtype":"m.text","m.relates_to":{"m.in_reply_to":{"event_id":"$7vmV4g2ZhqKv1Nyk-H4CqOcJy1225QgdU2u_rTVs3Sw"}}},"ts":1675097287353,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$m8-bzu249QqV1b9Z1GKsVeD_dGEH6LL2jniV5sybx6Q"},
{"content":{"body":"> <@mhofman:matrix.org> I actually don't think our approaches diverge that much\n\n * Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a `SharedStructType` constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like `with { reflect: \"module\" }` or module blocks, which are nowhere near ready for adoption.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$7vmV4g2ZhqKv1Nyk-H4CqOcJy1225QgdU2u_rTVs3Sw?via=matrix.org&amp;via=igalia.com&amp;via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I actually don't think our approaches diverge that much</blockquote></mx-reply> * Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a <code>SharedStructType</code> constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like <code>with { reflect: &quot;module&quot; }</code> or module blocks, which are nowhere near ready for adoption.","m.new_content":{"body":"Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a `SharedStructType` constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like `with { reflect: \"module\" }` or module blocks, which are nowhere near ready for adoption.","format":"org.matrix.custom.html","formatted_body":"Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a <code>SharedStructType</code> constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like <code>with { reflect: &quot;module&quot; }</code> or module blocks, which are nowhere near ready for adoption.","msgtype":"m.text"},"m.relates_to":{"event_id":"$m8-bzu249QqV1b9Z1GKsVeD_dGEH6LL2jniV5sybx6Q","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675097324496,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$6vfava_zb0H1Y0Iq5beuSeMGVqCklBbPbPqE7ow9vY4"},
{"content":{"body":"Yes I agree a dependency on module instances is not great, hence why I removed that from my original proposal. We can skip it here, the only effect is that you won't get implicit fallback registration","msgtype":"m.text"},"ts":1675097366184,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$NCdcRpZQ5xOeg2dbfNiUZgiIDrq1e3ToI7sl6pTMuM0"},
{"content":{"body":"> <@mhofman:matrix.org> Doesn't matter?\n\nIt matters if the dependent module has side-effects, or if it doubles the amount of runtime memory used because it depends on a large package.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$0H6hbOSSQyxVYHBh7c5xL_8tfWNZAmIG6Nmgd0arKXA?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>Doesn't matter?</blockquote></mx-reply>It matters if the dependent module has side-effects, or if it doubles the amount of runtime memory used because it depends on a large package.","m.relates_to":{"m.in_reply_to":{"event_id":"$0H6hbOSSQyxVYHBh7c5xL_8tfWNZAmIG6Nmgd0arKXA"}},"msgtype":"m.text"},"ts":1675097366229,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5VbgJgrC3J11j2WachtwJt7qNjPI1gAMnGn7eUpsvsM"},
{"content":{"body":"the behavior or loading a module instance is a general question for module import to answer, and is not really relevant for this proposal","msgtype":"m.text"},"ts":1675097405410,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Akp9YQeDnatOxzN8oyLZ0t4QegG8SYRqauiV6dy7FWc"},
{"content":{"body":"I only included it so that a behavior can be implicitly shared with other realms/agent without having to rely on a per channel registration on each side","msgtype":"m.text"},"ts":1675097444666,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$GRGux2tV1JG4h9a_58dd2A-yfbGGrh3sdT35qpcdFns"},
{"content":{"body":" * I only included it so that a behavior can be implicitly shared with other realms/agent without having to rely on a per channel registration on each side","m.new_content":{"body":"I only included it so that a behavior can be implicitly shared with other realms/agent without having to rely on a per channel registration on each side","msgtype":"m.text"},"m.relates_to":{"event_id":"$GRGux2tV1JG4h9a_58dd2A-yfbGGrh3sdT35qpcdFns","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675097461533,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$0LoCKahTTZczrrFmMjhCHPa7I95SBYPVNiRgcNjUKRQ"},
{"content":{"body":" * the behavior of loading a module instance is a general question for module import to answer, and is not really relevant for this proposal","m.new_content":{"body":"the behavior of loading a module instance is a general question for module import to answer, and is not really relevant for this proposal","msgtype":"m.text"},"m.relates_to":{"event_id":"$Akp9YQeDnatOxzN8oyLZ0t4QegG8SYRqauiV6dy7FWc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1675097498141,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$_Y-P_oR1EBtlIM0F-AP9mu56dIOs6qAl8vf1eGat4Os"},
{"content":{"body":"It would be great to find an approach that allows for the implicit import of behavior for cases that don't care about prototype continuity, yet not force a dependency on module instances","msgtype":"m.text"},"ts":1675097603660,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$1m1um8WpTwyYGOlxcyZxuLkgMLPhI6z0ihuPd9y2t6k"},
{"content":{"body":"> <@rbuckton:matrix.org> Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a `SharedStructType` constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like `with { reflect: \"module\" }` or module blocks, which are nowhere near ready for adoption.\n\nthat is accurate","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$m8-bzu249QqV1b9Z1GKsVeD_dGEH6LL2jniV5sybx6Q?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a <code>SharedStructType</code> constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like <code>with { reflect: \"module\" }</code> or module blocks, which are nowhere near ready for adoption.</blockquote></mx-reply>that is accurate","m.relates_to":{"m.in_reply_to":{"event_id":"$m8-bzu249QqV1b9Z1GKsVeD_dGEH6LL2jniV5sybx6Q"}},"msgtype":"m.text"},"ts":1675098092758,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$0TnOwnT3heavgo-sofYvrJc2fjsqgX5LLCrN-Ch0OZI"},
{"content":{"body":"I'm of two opinions on prototype continuity, each based on the overall direction we take for the proposal:\n\nIf the methods of shared structs only had access to a thread-safe locked-down global in a globally shared realm where they can only access other shared functions or shared structs or imports of the same (i.e., something like the \"shared module\" approach), then I favor prototype continuity because its easy and has an already limited surface area. \n\nIf the methods of shared structs are derived from code independently run in each Agent, then I only care about prototype continuity insomuch as a well-written program should be importing the same shared struct definition from the same file/package in each agent, and that any prototype continuity that exists will fall out naturally from that. By loosening the any restriction of prototype continuity, bundlers can take advantage of tree shaking, renaming, inlining, etc.\n\nSince we seem to be leaning towards the latter approach, I'm less concerned about prototype continuity.","msgtype":"m.text"},"ts":1675098744275,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1IvXhgfBeOC5HrNnLhaLp3X0VCunpZGkjd2V9JNVaCg"},
{"content":{"body":"I think we have a different definition of continuity here. I probably should have said \"stability\"","msgtype":"m.text"},"ts":1675100679756,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$PtDA0HYr2IKYursKjeiNpqgRyghVa81DDP8b-u1fr6Y"}
]