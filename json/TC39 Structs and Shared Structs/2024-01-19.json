[
{"content":{"body":"Thanks. With the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as `class`, except with the keywords `struct` or `shared struct` to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes. ","format":"org.matrix.custom.html","formatted_body":"Thanks. With the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as <code>class</code>, except with the keywords <code>struct</code> or <code>shared struct</code> to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","m.mentions":{},"msgtype":"m.text"},"ts":1705684467916,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lLKlgoH3DjS4nncwiVzjE2ltzdn53LoDs2nqoxkQ7ec"},
{"content":{"body":"I'd also like to include support for Decorators in the actual final grammar as the same rationale for decorators on classes applies to structs. The caveat being that we would need to decide how we would solve for private fields to be able to support `accessor` as a construct. If structs are to have behavior, I feel it is important that the MVP for this proposal not ignore Decorators.","format":"org.matrix.custom.html","formatted_body":"I'd also like to include support for Decorators in the actual final grammar as the same rationale for decorators on classes applies to structs. The caveat being that we would need to decide how we would solve for private fields to be able to support <code>accessor</code> as a construct. If structs are to have behavior, I feel it is important that the MVP for this proposal not ignore Decorators.","m.mentions":{},"msgtype":"m.text"},"ts":1705684706084,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SmAcukx_iDpoRTOPZGfNLQeaFMsqDj0VaqZodE45OvY"},
{"content":{"body":" * Thanks. Starting with the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as `class`, except with the keywords `struct` or `shared struct` to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","format":"org.matrix.custom.html","formatted_body":" * Thanks. Starting with the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as <code>class</code>, except with the keywords <code>struct</code> or <code>shared struct</code> to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","m.mentions":{},"m.new_content":{"body":"Thanks. Starting with the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as `class`, except with the keywords `struct` or `shared struct` to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","format":"org.matrix.custom.html","formatted_body":"Thanks. Starting with the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as <code>class</code>, except with the keywords <code>struct</code> or <code>shared struct</code> to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$lLKlgoH3DjS4nncwiVzjE2ltzdn53LoDs2nqoxkQ7ec","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1705684755016,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3wVwkPk2IPqGPWbHV8b5KfUbxSCCBbK4fxciOREf2dk"},
{"content":{"body":"As a result, the actual specified grammar for `struct` and `shared struct` will be fairly minimal as it will mostly borrow from _ClassDeclaration_. There are a few things we need a clear position on:\n- Will there be such a thing as a _StructExpression_, akin to _ClassExpression_? For non-shared structs, it could possibly be supported, but I don't think its viable for shared structs if we are to go the path+position route for cross-thread correlation.\n- Are we restricting _StructDeclaration_ to only be allowed at the top level of a _Script_ or _Module_? If they can be used inside of a function body, that also would break path+position for cross-thread correlation.\n- Would a _StructDeclaration_ be allowed inside of an `if` or `switch` at the top level? That would not break path+position correlation.\n- What about `for`, `while`, `do`? They could conceivably be run zero or one times, but evaluating them multiple times would break path+position correlation.\n- Would shared struct fields be allowed to have Symbol-named properties? If so, are there restrictions regarding whether those symbols are built-ins, from `Symbol()`, or from `Symbol.for()`?","format":"org.matrix.custom.html","formatted_body":"<p>As a result, the actual specified grammar for <code>struct</code> and <code>shared struct</code> will be fairly minimal as it will mostly borrow from <em>ClassDeclaration</em>. There are a few things we need a clear position on:</p>\n<ul>\n<li>Will there be such a thing as a <em>StructExpression</em>, akin to <em>ClassExpression</em>? For non-shared structs, it could possibly be supported, but I don't think its viable for shared structs if we are to go the path+position route for cross-thread correlation.</li>\n<li>Are we restricting <em>StructDeclaration</em> to only be allowed at the top level of a <em>Script</em> or <em>Module</em>? If they can be used inside of a function body, that also would break path+position for cross-thread correlation.</li>\n<li>Would a <em>StructDeclaration</em> be allowed inside of an <code>if</code> or <code>switch</code> at the top level? That would not break path+position correlation.</li>\n<li>What about <code>for</code>, <code>while</code>, <code>do</code>? They could conceivably be run zero or one times, but evaluating them multiple times would break path+position correlation.</li>\n<li>Would shared struct fields be allowed to have Symbol-named properties? If so, are there restrictions regarding whether those symbols are built-ins, from <code>Symbol()</code>, or from <code>Symbol.for()</code>?</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1705685343289,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZXk13mmygCWFe9rX5WmM1n558DztV4ga14i7PYwz4cE"},
{"content":{"body":"Also, in the doc you shared you indicate non-shared structs might be out of scope? Can you clarify what you mean about non-compositionality? Do you mean if that we only had fixed-layout shared structs, the restriction that prohibits non-shareable values in its fields would be problematic? And if so, is that be problematic for JS, WASM-GC, or both?","m.mentions":{},"msgtype":"m.text"},"ts":1705685604571,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lv88XjKcVv89zbGDTvLJaNidcPTNq0kn3RURhG3AjVY"},
{"content":{"body":"Also, you indicate that Mutex/Condition are \"Nice to have features immediately after MVP\". Are you indicating this would be a follow-on proposal, or just that these are JS-specific needs that are over and above the shared needs of JS and WASM?","m.mentions":{},"msgtype":"m.text"},"ts":1705686012425,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PiUKb0a7fA9usmeL-x_7fskxv5SfQmDrATWRpacSsME"},
{"content":{"body":"> <@rbuckton:matrix.org> Also, you indicate that Mutex/Condition are \"Nice to have features immediately after MVP\". Are you indicating this would be a follow-on proposal, or just that these are JS-specific needs that are over and above the shared needs of JS and WASM?\n\ndefinitely the latter, but i'm undecided yet about the former","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$PiUKb0a7fA9usmeL-x_7fskxv5SfQmDrATWRpacSsME?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Also, you indicate that Mutex/Condition are &quot;Nice to have features immediately after MVP&quot;. Are you indicating this would be a follow-on proposal, or just that these are JS-specific needs that are over and above the shared needs of JS and WASM?</blockquote></mx-reply>definitely the latter, but i'm undecided yet about the former","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$PiUKb0a7fA9usmeL-x_7fskxv5SfQmDrATWRpacSsME"}},"msgtype":"m.text"},"ts":1705692023735,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$XhsKrqDSpccxnIonl3ELp5_3DfFuS6oLuxdJ_Iw4FIc"},
{"content":{"body":"i feel like it shouldn't be a follow-on proposal, but bundling means slower progress for now, which may in itself be okay","m.mentions":{},"msgtype":"m.text"},"ts":1705692038945,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$1JAlJBzF3m73F2RtrjosQUywrFIdchOSjAIHF_vjdWU"},
{"content":{"body":"> <@rbuckton:matrix.org> Also, in the doc you shared you indicate non-shared structs might be out of scope? Can you clarify what you mean about non-compositionality? Do you mean if that we only had fixed-layout shared structs, the restriction that prohibits non-shareable values in its fields would be problematic? And if so, is that be problematic for JS, WASM-GC, or both?\n\nno, not that targeted. i meant something like: if we're looking at the use cases and design constraints alone, there isn't anything too compelling at this time to motivate normal structs. but that feels pretty bad from a PL design perspective and is a sharp corner. it seems like the \"fixed layout\" part should compose (with additional constraints) with the sharing, and leaving it out seems like an arbitrary non-compositionality","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$lv88XjKcVv89zbGDTvLJaNidcPTNq0kn3RURhG3AjVY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Also, in the doc you shared you indicate non-shared structs might be out of scope? Can you clarify what you mean about non-compositionality? Do you mean if that we only had fixed-layout shared structs, the restriction that prohibits non-shareable values in its fields would be problematic? And if so, is that be problematic for JS, WASM-GC, or both?</blockquote></mx-reply>no, not that targeted. i meant something like: if we're looking at the use cases and design constraints alone, there isn't anything too compelling at this time to motivate normal structs. but that feels pretty bad from a PL design perspective and is a sharp corner. it seems like the \"fixed layout\" part should compose (with additional constraints) with the sharing, and leaving it out seems like an arbitrary non-compositionality","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$lv88XjKcVv89zbGDTvLJaNidcPTNq0kn3RURhG3AjVY"}},"msgtype":"m.text"},"ts":1705692533564,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$wanGaYEm80K8QOywe34yCxIhqLLKDXzlcfvwRjdYIv0"},
{"content":{"body":"The main thing that would motivate non-shared structs is if engines felt like they could encourage developers to adopt it in exchange for lower overhead vs classes. This is a thing that JS developers widely say they want, and the question is whether engines feel like non-shared structs might provide that. Historically, engines have been skeptical of making such a promise around performance--it's not clear whether that's the right thing to be optimizing, or whether this construct will always give it when ranging across all future optimizations, so it's not clear whether a performance tradeoff can be controlled this way. [There might be other \"integrity\"-related arguments for non-shared structs, but I'm not so interested in those; IMO just use private fields if you want integrity.]","m.mentions":{},"msgtype":"m.text"},"ts":1705692802380,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$o3KMm4rAZ8DL915x5L3PBA4WZRZAyuHvhHxaG1WqX24"},
{"content":{"body":"I see, thanks. The impact regarding syntax is that if we only ever had shared structs, then I would just use `struct` to mean \"the shared, fixed-layout thing\". There would be no reason to disambiguate with a `shared` keyword.","format":"org.matrix.custom.html","formatted_body":"I see, thanks. The impact regarding syntax is that if we only ever had shared structs, then I would just use <code>struct</code> to mean \"the shared, fixed-layout thing\". There would be no reason to disambiguate with a <code>shared</code> keyword.","m.mentions":{},"msgtype":"m.text"},"ts":1705692817914,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kv7-nZXyX6-XpMOhI041ubk1ViXA52NdluPHTE6vJak"},
{"content":{"body":"I've pushed for non-shared structs for that PL design argument, and I accept that that's fairly weak.","m.mentions":{},"msgtype":"m.text"},"ts":1705692882765,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$suJLm3iOntIXEm8f6w3k-vRni5ia1I9pU33uRDu_bss"},
{"content":{"body":"> <@littledan:matrix.org> The main thing that would motivate non-shared structs is if engines felt like they could encourage developers to adopt it in exchange for lower overhead vs classes. This is a thing that JS developers widely say they want, and the question is whether engines feel like non-shared structs might provide that. Historically, engines have been skeptical of making such a promise around performance--it's not clear whether that's the right thing to be optimizing, or whether this construct will always give it when ranging across all future optimizations, so it's not clear whether a performance tradeoff can be controlled this way. [There might be other \"integrity\"-related arguments for non-shared structs, but I'm not so interested in those; IMO just use private fields if you want integrity.]\n\nwe have ideas there, but i kinda don't want them to lump those ideas into this proposal at the moment. namely, when i discussed with V8 staff, the sentiment was that explicit classes that don't change layout aren't necessarily more performant than hidden classes from a megamorphism POV, but we may have opportunities in layering additional restrictions on top to aid performance","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$o3KMm4rAZ8DL915x5L3PBA4WZRZAyuHvhHxaG1WqX24?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>The main thing that would motivate non-shared structs is if engines felt like they could encourage developers to adopt it in exchange for lower overhead vs classes. This is a thing that JS developers widely say they want, and the question is whether engines feel like non-shared structs might provide that. Historically, engines have been skeptical of making such a promise around performance--it&#39;s not clear whether that&#39;s the right thing to be optimizing, or whether this construct will always give it when ranging across all future optimizations, so it&#39;s not clear whether a performance tradeoff can be controlled this way. [There might be other &quot;integrity&quot;-related arguments for non-shared structs, but I&#39;m not so interested in those; IMO just use private fields if you want integrity.]</blockquote></mx-reply>we have ideas there, but i kinda don't want them to lump those ideas into this proposal at the moment. namely, when i discussed with V8 staff, the sentiment was that explicit classes that don't change layout aren't necessarily more performant than hidden classes from a megamorphism POV, but we may have opportunities in layering additional restrictions on top to aid performance","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$o3KMm4rAZ8DL915x5L3PBA4WZRZAyuHvhHxaG1WqX24"}},"msgtype":"m.text"},"ts":1705692967903,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$pDEQRDG5ftXqP30Rd12fnMMyrYUTUDOCl4k0kIVhemk"},
{"content":{"body":"one idea that was raised was additional restrictions on methods declared within structs, like making them always throw on instances of different types, and making them unbindable (unrelated ideas)","m.mentions":{},"msgtype":"m.text"},"ts":1705693045932,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$nfG8yzWSa6v4CMCf_OTBxJlN5e2E3hFHSne0il8_g4g"},
{"content":{"body":"though those restriction just as well applies to shared structs","m.mentions":{},"msgtype":"m.text"},"ts":1705693079038,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$DP_PsKzcpYWEkYaBoAAYJhxXYYdGl3WibkM6_rX6iQQ"}
]