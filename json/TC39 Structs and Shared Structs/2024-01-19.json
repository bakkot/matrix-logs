[
{"content":{"body":"Thanks. With the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as `class`, except with the keywords `struct` or `shared struct` to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes. ","format":"org.matrix.custom.html","formatted_body":"Thanks. With the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as <code>class</code>, except with the keywords <code>struct</code> or <code>shared struct</code> to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","m.mentions":{},"msgtype":"m.text"},"ts":1705684467916,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lLKlgoH3DjS4nncwiVzjE2ltzdn53LoDs2nqoxkQ7ec"},
{"content":{"body":"I'd also like to include support for Decorators in the actual final grammar as the same rationale for decorators on classes applies to structs. The caveat being that we would need to decide how we would solve for private fields to be able to support `accessor` as a construct. If structs are to have behavior, I feel it is important that the MVP for this proposal not ignore Decorators.","format":"org.matrix.custom.html","formatted_body":"I'd also like to include support for Decorators in the actual final grammar as the same rationale for decorators on classes applies to structs. The caveat being that we would need to decide how we would solve for private fields to be able to support <code>accessor</code> as a construct. If structs are to have behavior, I feel it is important that the MVP for this proposal not ignore Decorators.","m.mentions":{},"msgtype":"m.text"},"ts":1705684706084,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SmAcukx_iDpoRTOPZGfNLQeaFMsqDj0VaqZodE45OvY"},
{"content":{"body":" * Thanks. Starting with the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as `class`, except with the keywords `struct` or `shared struct` to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","format":"org.matrix.custom.html","formatted_body":" * Thanks. Starting with the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as <code>class</code>, except with the keywords <code>struct</code> or <code>shared struct</code> to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","m.mentions":{},"m.new_content":{"body":"Thanks. Starting with the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as `class`, except with the keywords `struct` or `shared struct` to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","format":"org.matrix.custom.html","formatted_body":"Thanks. Starting with the syntax sketch I boiled down https://gist.github.com/rbuckton/e1e8947da16f936edec1d269f00e2c53 to the things we actually need. In essence, it uses the same syntax as <code>class</code>, except with the keywords <code>struct</code> or <code>shared struct</code> to indicate how both definition evaluation and instantiation will fundamentally differ from regular classes.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$lLKlgoH3DjS4nncwiVzjE2ltzdn53LoDs2nqoxkQ7ec","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1705684755016,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3wVwkPk2IPqGPWbHV8b5KfUbxSCCBbK4fxciOREf2dk"},
{"content":{"body":"As a result, the actual specified grammar for `struct` and `shared struct` will be fairly minimal as it will mostly borrow from _ClassDeclaration_. There are a few things we need a clear position on:\n- Will there be such a thing as a _StructExpression_, akin to _ClassExpression_? For non-shared structs, it could possibly be supported, but I don't think its viable for shared structs if we are to go the path+position route for cross-thread correlation.\n- Are we restricting _StructDeclaration_ to only be allowed at the top level of a _Script_ or _Module_? If they can be used inside of a function body, that also would break path+position for cross-thread correlation.\n- Would a _StructDeclaration_ be allowed inside of an `if` or `switch` at the top level? That would not break path+position correlation.\n- What about `for`, `while`, `do`? They could conceivably be run zero or one times, but evaluating them multiple times would break path+position correlation.\n- Would shared struct fields be allowed to have Symbol-named properties? If so, are there restrictions regarding whether those symbols are built-ins, from `Symbol()`, or from `Symbol.for()`?","format":"org.matrix.custom.html","formatted_body":"<p>As a result, the actual specified grammar for <code>struct</code> and <code>shared struct</code> will be fairly minimal as it will mostly borrow from <em>ClassDeclaration</em>. There are a few things we need a clear position on:</p>\n<ul>\n<li>Will there be such a thing as a <em>StructExpression</em>, akin to <em>ClassExpression</em>? For non-shared structs, it could possibly be supported, but I don't think its viable for shared structs if we are to go the path+position route for cross-thread correlation.</li>\n<li>Are we restricting <em>StructDeclaration</em> to only be allowed at the top level of a <em>Script</em> or <em>Module</em>? If they can be used inside of a function body, that also would break path+position for cross-thread correlation.</li>\n<li>Would a <em>StructDeclaration</em> be allowed inside of an <code>if</code> or <code>switch</code> at the top level? That would not break path+position correlation.</li>\n<li>What about <code>for</code>, <code>while</code>, <code>do</code>? They could conceivably be run zero or one times, but evaluating them multiple times would break path+position correlation.</li>\n<li>Would shared struct fields be allowed to have Symbol-named properties? If so, are there restrictions regarding whether those symbols are built-ins, from <code>Symbol()</code>, or from <code>Symbol.for()</code>?</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1705685343289,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZXk13mmygCWFe9rX5WmM1n558DztV4ga14i7PYwz4cE"},
{"content":{"body":"Also, in the doc you shared you indicate non-shared structs might be out of scope? Can you clarify what you mean about non-compositionality? Do you mean if that we only had fixed-layout shared structs, the restriction that prohibits non-shareable values in its fields would be problematic? And if so, is that be problematic for JS, WASM-GC, or both?","m.mentions":{},"msgtype":"m.text"},"ts":1705685604571,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lv88XjKcVv89zbGDTvLJaNidcPTNq0kn3RURhG3AjVY"},
{"content":{"body":"Also, you indicate that Mutex/Condition are \"Nice to have features immediately after MVP\". Are you indicating this would be a follow-on proposal, or just that these are JS-specific needs that are over and above the shared needs of JS and WASM?","m.mentions":{},"msgtype":"m.text"},"ts":1705686012425,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PiUKb0a7fA9usmeL-x_7fskxv5SfQmDrATWRpacSsME"},
{"content":{"body":"> <@rbuckton:matrix.org> Also, you indicate that Mutex/Condition are \"Nice to have features immediately after MVP\". Are you indicating this would be a follow-on proposal, or just that these are JS-specific needs that are over and above the shared needs of JS and WASM?\n\ndefinitely the latter, but i'm undecided yet about the former","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$PiUKb0a7fA9usmeL-x_7fskxv5SfQmDrATWRpacSsME?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Also, you indicate that Mutex/Condition are &quot;Nice to have features immediately after MVP&quot;. Are you indicating this would be a follow-on proposal, or just that these are JS-specific needs that are over and above the shared needs of JS and WASM?</blockquote></mx-reply>definitely the latter, but i'm undecided yet about the former","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$PiUKb0a7fA9usmeL-x_7fskxv5SfQmDrATWRpacSsME"}},"msgtype":"m.text"},"ts":1705692023735,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$XhsKrqDSpccxnIonl3ELp5_3DfFuS6oLuxdJ_Iw4FIc"},
{"content":{"body":"i feel like it shouldn't be a follow-on proposal, but bundling means slower progress for now, which may in itself be okay","m.mentions":{},"msgtype":"m.text"},"ts":1705692038945,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$1JAlJBzF3m73F2RtrjosQUywrFIdchOSjAIHF_vjdWU"},
{"content":{"body":"> <@rbuckton:matrix.org> Also, in the doc you shared you indicate non-shared structs might be out of scope? Can you clarify what you mean about non-compositionality? Do you mean if that we only had fixed-layout shared structs, the restriction that prohibits non-shareable values in its fields would be problematic? And if so, is that be problematic for JS, WASM-GC, or both?\n\nno, not that targeted. i meant something like: if we're looking at the use cases and design constraints alone, there isn't anything too compelling at this time to motivate normal structs. but that feels pretty bad from a PL design perspective and is a sharp corner. it seems like the \"fixed layout\" part should compose (with additional constraints) with the sharing, and leaving it out seems like an arbitrary non-compositionality","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$lv88XjKcVv89zbGDTvLJaNidcPTNq0kn3RURhG3AjVY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Also, in the doc you shared you indicate non-shared structs might be out of scope? Can you clarify what you mean about non-compositionality? Do you mean if that we only had fixed-layout shared structs, the restriction that prohibits non-shareable values in its fields would be problematic? And if so, is that be problematic for JS, WASM-GC, or both?</blockquote></mx-reply>no, not that targeted. i meant something like: if we're looking at the use cases and design constraints alone, there isn't anything too compelling at this time to motivate normal structs. but that feels pretty bad from a PL design perspective and is a sharp corner. it seems like the \"fixed layout\" part should compose (with additional constraints) with the sharing, and leaving it out seems like an arbitrary non-compositionality","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$lv88XjKcVv89zbGDTvLJaNidcPTNq0kn3RURhG3AjVY"}},"msgtype":"m.text"},"ts":1705692533564,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$wanGaYEm80K8QOywe34yCxIhqLLKDXzlcfvwRjdYIv0"},
{"content":{"body":"The main thing that would motivate non-shared structs is if engines felt like they could encourage developers to adopt it in exchange for lower overhead vs classes. This is a thing that JS developers widely say they want, and the question is whether engines feel like non-shared structs might provide that. Historically, engines have been skeptical of making such a promise around performance--it's not clear whether that's the right thing to be optimizing, or whether this construct will always give it when ranging across all future optimizations, so it's not clear whether a performance tradeoff can be controlled this way. [There might be other \"integrity\"-related arguments for non-shared structs, but I'm not so interested in those; IMO just use private fields if you want integrity.]","m.mentions":{},"msgtype":"m.text"},"ts":1705692802380,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$o3KMm4rAZ8DL915x5L3PBA4WZRZAyuHvhHxaG1WqX24"},
{"content":{"body":"I see, thanks. The impact regarding syntax is that if we only ever had shared structs, then I would just use `struct` to mean \"the shared, fixed-layout thing\". There would be no reason to disambiguate with a `shared` keyword.","format":"org.matrix.custom.html","formatted_body":"I see, thanks. The impact regarding syntax is that if we only ever had shared structs, then I would just use <code>struct</code> to mean \"the shared, fixed-layout thing\". There would be no reason to disambiguate with a <code>shared</code> keyword.","m.mentions":{},"msgtype":"m.text"},"ts":1705692817914,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kv7-nZXyX6-XpMOhI041ubk1ViXA52NdluPHTE6vJak"},
{"content":{"body":"I've pushed for non-shared structs for that PL design argument, and I accept that that's fairly weak.","m.mentions":{},"msgtype":"m.text"},"ts":1705692882765,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$suJLm3iOntIXEm8f6w3k-vRni5ia1I9pU33uRDu_bss"},
{"content":{"body":"> <@littledan:matrix.org> The main thing that would motivate non-shared structs is if engines felt like they could encourage developers to adopt it in exchange for lower overhead vs classes. This is a thing that JS developers widely say they want, and the question is whether engines feel like non-shared structs might provide that. Historically, engines have been skeptical of making such a promise around performance--it's not clear whether that's the right thing to be optimizing, or whether this construct will always give it when ranging across all future optimizations, so it's not clear whether a performance tradeoff can be controlled this way. [There might be other \"integrity\"-related arguments for non-shared structs, but I'm not so interested in those; IMO just use private fields if you want integrity.]\n\nwe have ideas there, but i kinda don't want them to lump those ideas into this proposal at the moment. namely, when i discussed with V8 staff, the sentiment was that explicit classes that don't change layout aren't necessarily more performant than hidden classes from a megamorphism POV, but we may have opportunities in layering additional restrictions on top to aid performance","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$o3KMm4rAZ8DL915x5L3PBA4WZRZAyuHvhHxaG1WqX24?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>The main thing that would motivate non-shared structs is if engines felt like they could encourage developers to adopt it in exchange for lower overhead vs classes. This is a thing that JS developers widely say they want, and the question is whether engines feel like non-shared structs might provide that. Historically, engines have been skeptical of making such a promise around performance--it&#39;s not clear whether that&#39;s the right thing to be optimizing, or whether this construct will always give it when ranging across all future optimizations, so it&#39;s not clear whether a performance tradeoff can be controlled this way. [There might be other &quot;integrity&quot;-related arguments for non-shared structs, but I&#39;m not so interested in those; IMO just use private fields if you want integrity.]</blockquote></mx-reply>we have ideas there, but i kinda don't want them to lump those ideas into this proposal at the moment. namely, when i discussed with V8 staff, the sentiment was that explicit classes that don't change layout aren't necessarily more performant than hidden classes from a megamorphism POV, but we may have opportunities in layering additional restrictions on top to aid performance","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$o3KMm4rAZ8DL915x5L3PBA4WZRZAyuHvhHxaG1WqX24"}},"msgtype":"m.text"},"ts":1705692967903,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$pDEQRDG5ftXqP30Rd12fnMMyrYUTUDOCl4k0kIVhemk"},
{"content":{"body":"one idea that was raised was additional restrictions on methods declared within structs, like making them always throw on instances of different types, and making them unbindable (unrelated ideas)","m.mentions":{},"msgtype":"m.text"},"ts":1705693045932,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$nfG8yzWSa6v4CMCf_OTBxJlN5e2E3hFHSne0il8_g4g"},
{"content":{"body":"though those restriction just as well applies to shared structs","m.mentions":{},"msgtype":"m.text"},"ts":1705693079038,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$DP_PsKzcpYWEkYaBoAAYJhxXYYdGl3WibkM6_rX6iQQ"},
{"content":{"body":"While I doubt that structs would solve it, my biggest wish for V8 would be some mechanism to avoid megamorphism on the discriminant property an ADT union, for example: `node.kind`. Pretty much every access to `.kind` in the TS compiler is megamorphic, though we often branch on kind and those branches are *usually* monomorphic, at least with respect to the `node` used in those branches.","format":"org.matrix.custom.html","formatted_body":"While I doubt that structs would solve it, my biggest wish for V8 would be some mechanism to avoid megamorphism on the discriminant property an ADT union, for example: <code>node.kind</code>. Pretty much every access to <code>.kind</code> in the TS compiler is megamorphic, though we often branch on kind and those branches are <em>usually</em> monomorphic, at least with respect to the <code>node</code> used in those branches.","m.mentions":{},"msgtype":"m.text"},"ts":1705693271893,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xGk0uuA7jLvLX3MXRsy1yFhx-T7rqu0clbDtxpPTxR0"},
{"content":{"body":"i have been thinking about this for like 10 years","m.mentions":{},"msgtype":"m.text"},"ts":1705693331812,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Rb0DSXRzqQoQJ19XbcKTGhGimKUSZ2kdxRUvBNCLhCQ"},
{"content":{"body":"If there's a chance that fixed layout, non-shared structs could solve that, it would be a strong indication for me that they have value beyond just shared structs.","m.mentions":{},"msgtype":"m.text"},"ts":1705693334686,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$E0-xNtcAAXwjgKTqyM4Lsg9FDlQssM1KRC7M8wdl91w"},
{"content":{"body":"no idea how to solve it","m.mentions":{},"msgtype":"m.text"},"ts":1705693337133,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$UAJ-kRiT5SwUYZKWyNqPu_ZXPZf0GsumeMXdvFz79Sc"},
{"content":{"body":"the levers i know for monomorphization like that depend on duplicating code and type systems","m.mentions":{},"msgtype":"m.text"},"ts":1705693371113,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$igj6IoH11myKStTUbdaGHD1qigaNHg22ESXYvJk2-AM"},
{"content":{"body":"My hope is that a proposal like ADT enums would be a possible solution, since all branches of an ADT enum would be known at declaration time.","m.mentions":{},"msgtype":"m.text"},"ts":1705693383740,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7AGWv1iFr9YHTyCjlEA11zYhzHUT1EgUjDZuVuJWNbY"},
{"content":{"body":"but how do you know what's worth monomorphizing and what's not worth it?","m.mentions":{},"msgtype":"m.text"},"ts":1705693409209,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VgdyzlfyyAoQcvR_5AJKqQaTN2nT7JUtutlQkUUHXjE"},
{"content":{"body":"and what do you monomorphize? do you like, peel off a little chunk of code and duplicate that, parameterized around the \"arms\" of the union? do you do it at the whole function level? what if the function is really big?","m.mentions":{},"msgtype":"m.text"},"ts":1705693437990,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Gfc7nxdwkGcp5uA814iMUrNSxaaEwHrkQpq-9AxYDoI"},
{"content":{"body":"lots of art","m.mentions":{},"msgtype":"m.text"},"ts":1705693454721,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$JwNvDOydRu1gDMrO9Rfj3dO7H6oInlSppL5P4DNTBgM"},
{"content":{"body":"i.e., an ADT enum declaration could encode into its type the internal discriminant used to differentiate between each constituent of the enum and the optimizer could leverage that when encoding the IC.","m.mentions":{},"msgtype":"m.text"},"ts":1705693505619,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DGbMansFFl2Z8neLadEXJppsC0tFzTjMY-dc1y19oJI"},
{"content":{"body":"oh i see, at the IC level","m.mentions":{},"msgtype":"m.text"},"ts":1705693517270,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$XigLbfMHccKW231zjS2EElzORoTVjWbbNaWR_Kqwy3M"},
{"content":{"body":"shouldn't that already be the case?","m.mentions":{},"msgtype":"m.text"},"ts":1705693529355,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$VNZI-FGCeNsGk313AsCmyQBO5Lc6txYQAb-VCcbia3U"},
{"content":{"body":"i guess you're saying that the cut-off for when an IC goes polymorphic -> megamorphic is too low for these ADT union cases","m.mentions":{},"msgtype":"m.text"},"ts":1705693556418,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cYU-sIWm0z_VQEPWLlwh2U8LXttAXSYuUWeO3uoZ1zY"},
{"content":{"body":"and if we can tell the IC system \"actually, the number of cases is bounded, so you should just do the polymorphic thing even in this case that looks like it'll grow new type cases forever\"?","m.mentions":{},"msgtype":"m.text"},"ts":1705693583323,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$JFxk_RtBvjeB4tbnbyCFHOjDPlht8ilpPW0W2gZ-BXo"},
{"content":{"body":"```\nenum Node {\n  Identifier(text),\n  BinaryExpression(left, op, right),\n  PrefixUnaryExpression(op, operand),\n  PostfixUnaryExpression(operand, op),\n  // ...\n}\n\nmatch (node) {\n  when Node.Identifier: ...;\n  when Node.BinaryExpression: ...;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>enum Node {\n  Identifier(text),\n  BinaryExpression(left, op, right),\n  PrefixUnaryExpression(op, operand),\n  PostfixUnaryExpression(operand, op),\n  // ...\n}\n\nmatch (node) {\n  when Node.Identifier: ...;\n  when Node.BinaryExpression: ...;\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1705693601149,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fwkc0gIQ2DmOF37p1r2XdsgCi2LNeKFYuIDfnU8mYeY"},
{"content":{"body":"So checking the internal discriminant for each constituent would be monomorphic, and thus the types collected within the match leg for that case would also be monomorphic as those ICs only ever see the `Node` constituent for that branch.","format":"org.matrix.custom.html","formatted_body":"So checking the internal discriminant for each constituent would be monomorphic, and thus the types collected within the match leg for that case would also be monomorphic as those ICs only ever see the <code>Node</code> constituent for that branch.","m.mentions":{},"msgtype":"m.text"},"ts":1705693679992,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oBYHFH_T05FkkwgXaJnOU5LmD2QTg5LF__cnX-2O514"},
{"content":{"body":"You could imagine a `Node` constituent is internally represented as something like a `TaggedNode { tag, data }`. A match leg would test against the `tag` (monomorphic), but the rest of the properties are in `data`, even though the runtime perceives it as a single object.","format":"org.matrix.custom.html","formatted_body":"You could imagine a <code>Node</code> constituent is internally represented as something like a <code>TaggedNode { tag, data }</code>. A match leg would test against the <code>tag</code> (monomorphic), but the rest of the properties are in <code>data</code>, even though the runtime perceives it as a single object.","m.mentions":{},"msgtype":"m.text"},"ts":1705693776968,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wU5FUZ29LqvNGyocA3YJqLxMEYnqPaVy3xtyW1n1XWQ"}
]