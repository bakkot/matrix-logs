[
{"content":{"body":"thoughts on prohibiting computed property names in struct bodies? with structs positioned as \"restricted classes that trade expressivity for performance and analyzability\", prohibiting computed property names furthers the analyzability goal","m.mentions":{},"msgtype":"m.text"},"ts":1737507820296,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$bB7gQQaX4fMaiBhM_eazobRL_3inGb_tmIXa3Y1T4VI"},
{"content":{"body":"I would support it. If I'd had to guess without looking, I'd have assumed they were already prohibited.","m.mentions":{},"msgtype":"m.text"},"ts":1737508740372,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$eHXj-XCjpAJJr-Ew9z5emCyiEqkr_Q13KoOcFtUNb0g"},
{"content":{"body":"they are currently allowed, but not really intentionally","m.mentions":{},"msgtype":"m.text"},"ts":1737512592511,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LmsQHjHL6Gp992MzvqVx6L1cmWvUEUGmBQ2kQaNdQ2Y"},
{"content":{"body":"Would this then prohibit using symbol named properties like `Symbol.dispose`? If so, I am not in favor. ","format":"org.matrix.custom.html","formatted_body":"Would this then prohibit using symbol named properties like <code>Symbol.dispose</code>? If so, I am not in favor.","msgtype":"m.text"},"ts":1737522649989,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jnTm4LuDqzDd4DYyJXDrzlt3B83iNss2FI70LKz9bd4"},
{"content":{"body":"the principle is statically analyzable name","m.mentions":{},"msgtype":"m.text"},"ts":1737526472219,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cddzyf3bGqmRv5XljUJvCh5az-2NxFnG7_IDulzck6s"},
{"content":{"body":"i wonder if there's a way to recover well-known symbol names and retaining analyzability","m.mentions":{},"msgtype":"m.text"},"ts":1737526483818,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$sTqEhk9VeqKC127aG87kU20gg5OacuXIjcAcWRRqQQg"},
{"content":{"body":"then you also wouldn't be able to have a string property name?","m.mentions":{},"msgtype":"m.text"},"ts":1737526644491,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$zRL9euARU4VLiPjmgPdzGaJzcXulSpgNZ7bb8n_4bj4"},
{"content":{"body":"Was going to say: Well known `Symbol` fields are non-writable&non-configurable.\nso `[Symbol.iterator]` is statically known.\n expect Symbol itself could be replaced","format":"org.matrix.custom.html","formatted_body":"Was going to say: Well known `Symbol` fields are non-writable&amp;non-configurable.<br />so `[Symbol.iterator]` is statically known.<br />Â expect Symbol itself could be replaced","msgtype":"m.text"},"ts":1737555003124,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$yscvke-6cIfNTR3XdU8dTrT7sx1KjUaBi3NWlM_Pefg"},
{"content":{"body":"Allowing `[Symbol.dispose]` but not `[x]` would be inconsistent and a source of confusion for users.","format":"org.matrix.custom.html","formatted_body":"Allowing <code>[Symbol.dispose]</code> but not <code>[x]</code> would be inconsistent and a source of confusion for users.","msgtype":"m.text"},"ts":1737558089678,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9V5qINsx65RjabNYITv9yaj8vn9kSBTOPJx7utAyeUc"},
{"content":{"body":"Why is this static analyzability necessary? The shape will be locked down when the definition is evaluated. I'd be fine with implementations having fast paths for statically analyzable definitions, but not with disallowing them entirely. ","format":"org.matrix.custom.html","formatted_body":"Why is this static analyzability necessary? The shape will be locked down when the definition is evaluated. I'd be fine with implementations having fast paths for statically analyzable definitions, but not with disallowing them entirely.","msgtype":"m.text"},"ts":1737558237133,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FnptcoMJ52HZRZgNGbJxRZSJLAOXTn2pijPS_5JFf4M"},
{"content":{"body":"Static analysis for `Symbol` isn't necessarily reliable anyways given polyfills for new built in symbols, the fact you can redeclare `Symbol` in your module, and that you could have `const x = Symbol.iterator`.","format":"org.matrix.custom.html","formatted_body":"Static analysis for <code>Symbol</code> isn't necessarily reliable anyways given polyfills for new built in symbols, the fact you can redeclare <code>Symbol</code> in your module, and that you could have <code>const x = Symbol.iterator</code>.","msgtype":"m.text"},"ts":1737558361450,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$J9EQMEbP-i_s2r25Wcv02_y7qxgfPe7UVpdgUp8lI8A"},
{"content":{"body":"I also have cases where I've used vm.Context in NodeJS to replace `Symbol` with a mock, which would likely violate static analysis. ","format":"org.matrix.custom.html","formatted_body":"I also have cases where I've used vm.Context in NodeJS to replace <code>Symbol</code> with a mock, which would likely violate static analysis.","msgtype":"m.text"},"ts":1737558446611,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$j_NuYIU7poDZuMewIO4xy5m110FoG3ivk_mbijzeBPo"},
{"content":{"body":"it's not necessary for the engine, but came as a request from tooling folks internally","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$FnptcoMJ52HZRZgNGbJxRZSJLAOXTn2pijPS_5JFf4M"}},"msgtype":"m.text"},"ts":1737559368994,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$kgXyVsYAIyV4CNXByrhYb1qhb5RkOtMRs-9L7jrRlHo"},
{"content":{"body":"not sure i follow","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zRL9euARU4VLiPjmgPdzGaJzcXulSpgNZ7bb8n_4bj4"}},"msgtype":"m.text"},"ts":1737559435017,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Fll_iqPxZ44xsgTgb-H0QynfQO2UwKmXHSStMkiZPLM"},
{"content":{"body":"I would be opposed to disallowing computed properties for the reasons stated: Disallowing entirely would break important use cases (e.g., `Symbol.dispose`, `Symbol.iterator`), and only allowing a restricted set of \"statically analyzable\" computed properties would be confusing, fragile, and break user expectations. ","format":"org.matrix.custom.html","formatted_body":"I would be opposed to disallowing computed properties for the reasons stated: Disallowing entirely would break important use cases (e.g., <code>Symbol.dispose</code>, <code>Symbol.iterator</code>), and only allowing a restricted set of \"statically analyzable\" computed properties would be confusing, fragile, and break user expectations.","m.mentions":{},"msgtype":"m.text"},"ts":1737559717352,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nFSHZTp4nYpUkbnZW-lfcQ7BQFe-1Iek9CYMPnKnU3o"},
{"content":{"body":"a possibility is to disallow all computed property names for own fields, but allow it for instance fields (methods, getters), and static fields","m.mentions":{},"msgtype":"m.text"},"ts":1737559754618,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$F7xg6FJVrRL6kStNHykywq4nofovfXPfXIqjfvJRQxE"},
{"content":{"body":"since:\n\n- you get declarative instance layout with all known field names\n- all static use cases today for computed names are about symbol protocols, which are on the prototype\n- prototype shapes require analysis to get even without computed property names","format":"org.matrix.custom.html","formatted_body":"<p>since:</p>\n<ul>\n<li>you get declarative instance layout with all known field names</li>\n<li>all static use cases today for computed names are about symbol protocols, which are on the prototype</li>\n<li>prototype shapes require analysis to get even without computed property names</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1737559856892,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5FMEUDcwRdTv646zoKDDWGfhmMEgM9Yohar4toQBoOI"},
{"content":{"body":"can you elaborate on static analyzability goals? Are we going for soundness or \"works in practice\"?","m.mentions":{},"msgtype":"m.text"},"ts":1737564217751,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$djHEd75pUSPIQi6_xpCKcge8ZQ6uXhAqen6q6L_jPzs"},
{"content":{"body":"Disallowing for own fields but allowing for methods is just another source of confusion for users.","m.mentions":{},"msgtype":"m.text"},"ts":1737564737458,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$66sFBw29IGzNJDM9zMrPTLnAnaN7hRUZ9w5SAuyPaiM"},
{"content":{"body":"> all static use cases today for computed names are about symbol protocols, which are on the prototype\n\nNot all use cases today are for symbols on the prototype. NodeJS internals are rife with symbols defined on instance objects.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>all static use cases today for computed names are about symbol protocols, which are on the prototype</p>\n</blockquote>\n<p>Not all use cases today are for symbols on the prototype. NodeJS internals are rife with symbols defined on instance objects.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1737564795168,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nM_ZVKnJiiyc4lJvK4eZItdisIS_4jEqKzqCRWV9tQQ"},
{"content":{"body":"And none of those protocols _require_ those symbols be on the prototype.","format":"org.matrix.custom.html","formatted_body":"And none of those protocols <em>require</em> those symbols be on the prototype.","m.mentions":{},"msgtype":"m.text"},"ts":1737564822594,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mQdCqLMiWpH05rlKkpQh6wROEyYMSJOSOOT-o0DdoMk"},
{"content":{"body":"and is it important to support those use cases with structs?","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$nM_ZVKnJiiyc4lJvK4eZItdisIS_4jEqKzqCRWV9tQQ"}},"msgtype":"m.text"},"ts":1737565055751,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$WDfEjWJTiJYUtcZ1jzsykkFLedMZ7rYDmCC3uPIfERs"},
{"content":{"body":"\"works in practice\" for sure, but by construction than by, say, linting","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$djHEd75pUSPIQi6_xpCKcge8ZQ6uXhAqen6q6L_jPzs"}},"msgtype":"m.text"},"ts":1737565138912,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zeCRth7mpTIFAAWpNXmi6BkbdxYwlXIHDUc-tsGUwmA"},
{"content":{"body":"I believe it is, yes. ","m.mentions":{},"msgtype":"m.text"},"ts":1737565152197,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$336ZQkY7w6SE4h2BUPetoHVRvnLeuvgm_x3KNnnFB5I"},
{"content":{"body":"can you show me an example?","m.mentions":{},"msgtype":"m.text"},"ts":1737565163705,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$KIPoLPCFBqcfio1loIO97pQ-30OWmoSn8sf9duDgpfU"},
{"content":{"body":"Shortly, yes. I'm about to step into a meeting.","m.mentions":{},"msgtype":"m.text"},"ts":1737565250949,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9Hq-OQQ7Q5r2gNe7-5CNwWTeQR-KMUVKPl7ANoT-0MA"},
{"content":{"body":"I seem to recall that we were talking about source location as a mechanism for solving the coordination problem. Has that changed? If computed properties are allowed, then the same source location can define multiple distinct types.","m.mentions":{},"msgtype":"m.text"},"ts":1737565253079,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$qnOmOHtaAHpYiE09NenS9BHxmKvuXtCHZiL7y49dLO8"},
{"content":{"body":"i've been talking about unshared structs","m.mentions":{},"msgtype":"m.text"},"ts":1737565276445,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$INkkDf_P7B31t3jb36s0LaFKE_uG8HmmGZU7yQf_3m4"},
{"content":{"body":"but yeah that's a good point for the shared ones","m.mentions":{},"msgtype":"m.text"},"ts":1737565300765,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$EkPfmpalUzUk5ZWMPUWEP3brl2x-NKh6Aj_ffS0-9Qc"},
{"content":{"body":"If they didn't point to the same properties, they wouldn't match, much like how if you had two references to the same source location with different field layouts wouldn't match (say, due to a new version of the file being loaded in a worker)","m.mentions":{},"msgtype":"m.text"},"ts":1737565427132,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gMd2PcgBkSQZHU_S6ue9rZUmpZCvX46PKnYlG4WCpig"},
{"content":{"body":"the use cases all revolve around symbols. i'd like to solve that more directly","m.mentions":{},"msgtype":"m.text"},"ts":1737565441670,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$L6VRqnkceCt-QIWi9zAgEyZ2iAnVTdThHqA7r7WS6uM"},
{"content":{"body":"being declarative is a good goal; i think there's a world of difference between supporting Symbol.iterator, which is important, and supporting arbitrary computation for field names","m.mentions":{},"msgtype":"m.text"},"ts":1737565510046,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$J27a1-GvhXpipt3WtyCDj-6e4lvqd5gGq8JQ8bFrkZs"}
]