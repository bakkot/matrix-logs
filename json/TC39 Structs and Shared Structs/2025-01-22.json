[
{"content":{"body":"thoughts on prohibiting computed property names in struct bodies? with structs positioned as \"restricted classes that trade expressivity for performance and analyzability\", prohibiting computed property names furthers the analyzability goal","m.mentions":{},"msgtype":"m.text"},"ts":1737507820296,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$bB7gQQaX4fMaiBhM_eazobRL_3inGb_tmIXa3Y1T4VI"},
{"content":{"body":"I would support it. If I'd had to guess without looking, I'd have assumed they were already prohibited.","m.mentions":{},"msgtype":"m.text"},"ts":1737508740372,"senderName":"iain","senderId":"@iain:mozilla.org","id":"$eHXj-XCjpAJJr-Ew9z5emCyiEqkr_Q13KoOcFtUNb0g"},
{"content":{"body":"they are currently allowed, but not really intentionally","m.mentions":{},"msgtype":"m.text"},"ts":1737512592511,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LmsQHjHL6Gp992MzvqVx6L1cmWvUEUGmBQ2kQaNdQ2Y"},
{"content":{"body":"Would this then prohibit using symbol named properties like `Symbol.dispose`? If so, I am not in favor. ","format":"org.matrix.custom.html","formatted_body":"Would this then prohibit using symbol named properties like <code>Symbol.dispose</code>? If so, I am not in favor.","msgtype":"m.text"},"ts":1737522649989,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jnTm4LuDqzDd4DYyJXDrzlt3B83iNss2FI70LKz9bd4"},
{"content":{"body":"the principle is statically analyzable name","m.mentions":{},"msgtype":"m.text"},"ts":1737526472219,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$cddzyf3bGqmRv5XljUJvCh5az-2NxFnG7_IDulzck6s"},
{"content":{"body":"i wonder if there's a way to recover well-known symbol names and retaining analyzability","m.mentions":{},"msgtype":"m.text"},"ts":1737526483818,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$sTqEhk9VeqKC127aG87kU20gg5OacuXIjcAcWRRqQQg"},
{"content":{"body":"then you also wouldn't be able to have a string property name?","m.mentions":{},"msgtype":"m.text"},"ts":1737526644491,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$zRL9euARU4VLiPjmgPdzGaJzcXulSpgNZ7bb8n_4bj4"},
{"content":{"body":"Was going to say: Well known `Symbol` fields are non-writable&non-configurable.\nso `[Symbol.iterator]` is statically known.\n expect Symbol itself could be replaced","format":"org.matrix.custom.html","formatted_body":"Was going to say: Well known `Symbol` fields are non-writable&amp;non-configurable.<br />so `[Symbol.iterator]` is statically known.<br />Â expect Symbol itself could be replaced","msgtype":"m.text"},"ts":1737555003124,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$yscvke-6cIfNTR3XdU8dTrT7sx1KjUaBi3NWlM_Pefg"},
{"content":{"body":"Allowing `[Symbol.dispose]` but not `[x]` would be inconsistent and a source of confusion for users.","format":"org.matrix.custom.html","formatted_body":"Allowing <code>[Symbol.dispose]</code> but not <code>[x]</code> would be inconsistent and a source of confusion for users.","msgtype":"m.text"},"ts":1737558089678,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9V5qINsx65RjabNYITv9yaj8vn9kSBTOPJx7utAyeUc"},
{"content":{"body":"Why is this static analyzability necessary? The shape will be locked down when the definition is evaluated. I'd be fine with implementations having fast paths for statically analyzable definitions, but not with disallowing them entirely. ","format":"org.matrix.custom.html","formatted_body":"Why is this static analyzability necessary? The shape will be locked down when the definition is evaluated. I'd be fine with implementations having fast paths for statically analyzable definitions, but not with disallowing them entirely.","msgtype":"m.text"},"ts":1737558237133,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FnptcoMJ52HZRZgNGbJxRZSJLAOXTn2pijPS_5JFf4M"},
{"content":{"body":"Static analysis for `Symbol` isn't necessarily reliable anyways given polyfills for new built in symbols, the fact you can redeclare `Symbol` in your module, and that you could have `const x = Symbol.iterator`.","format":"org.matrix.custom.html","formatted_body":"Static analysis for <code>Symbol</code> isn't necessarily reliable anyways given polyfills for new built in symbols, the fact you can redeclare <code>Symbol</code> in your module, and that you could have <code>const x = Symbol.iterator</code>.","msgtype":"m.text"},"ts":1737558361450,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$J9EQMEbP-i_s2r25Wcv02_y7qxgfPe7UVpdgUp8lI8A"},
{"content":{"body":"I also have cases where I've used vm.Context in NodeJS to replace `Symbol` with a mock, which would likely violate static analysis. ","format":"org.matrix.custom.html","formatted_body":"I also have cases where I've used vm.Context in NodeJS to replace <code>Symbol</code> with a mock, which would likely violate static analysis.","msgtype":"m.text"},"ts":1737558446611,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$j_NuYIU7poDZuMewIO4xy5m110FoG3ivk_mbijzeBPo"},
{"content":{"body":"it's not necessary for the engine, but came as a request from tooling folks internally","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$FnptcoMJ52HZRZgNGbJxRZSJLAOXTn2pijPS_5JFf4M"}},"msgtype":"m.text"},"ts":1737559368994,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$kgXyVsYAIyV4CNXByrhYb1qhb5RkOtMRs-9L7jrRlHo"},
{"content":{"body":"not sure i follow","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$zRL9euARU4VLiPjmgPdzGaJzcXulSpgNZ7bb8n_4bj4"}},"msgtype":"m.text"},"ts":1737559435017,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Fll_iqPxZ44xsgTgb-H0QynfQO2UwKmXHSStMkiZPLM"},
{"content":{"body":"I would be opposed to disallowing computed properties for the reasons stated: Disallowing entirely would break important use cases (e.g., `Symbol.dispose`, `Symbol.iterator`), and only allowing a restricted set of \"statically analyzable\" computed properties would be confusing, fragile, and break user expectations. ","format":"org.matrix.custom.html","formatted_body":"I would be opposed to disallowing computed properties for the reasons stated: Disallowing entirely would break important use cases (e.g., <code>Symbol.dispose</code>, <code>Symbol.iterator</code>), and only allowing a restricted set of \"statically analyzable\" computed properties would be confusing, fragile, and break user expectations.","m.mentions":{},"msgtype":"m.text"},"ts":1737559717352,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nFSHZTp4nYpUkbnZW-lfcQ7BQFe-1Iek9CYMPnKnU3o"},
{"content":{"body":"a possibility is to disallow all computed property names for own fields, but allow it for instance fields (methods, getters), and static fields","m.mentions":{},"msgtype":"m.text"},"ts":1737559754618,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$F7xg6FJVrRL6kStNHykywq4nofovfXPfXIqjfvJRQxE"},
{"content":{"body":"since:\n\n- you get declarative instance layout with all known field names\n- all static use cases today for computed names are about symbol protocols, which are on the prototype\n- prototype shapes require analysis to get even without computed property names","format":"org.matrix.custom.html","formatted_body":"<p>since:</p>\n<ul>\n<li>you get declarative instance layout with all known field names</li>\n<li>all static use cases today for computed names are about symbol protocols, which are on the prototype</li>\n<li>prototype shapes require analysis to get even without computed property names</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1737559856892,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$5FMEUDcwRdTv646zoKDDWGfhmMEgM9Yohar4toQBoOI"}
]