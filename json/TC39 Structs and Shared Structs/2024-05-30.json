[
{"content":{"body":"I chatted with Mark this afternoon. First he's sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into code shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.","m.mentions":{},"msgtype":"m.text"},"ts":1717036786642,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$srVXPXHm2oj4GYlugBDqaCpXctib3BLBBGt0vGQ0rVE"},
{"content":{"body":" * I chatted with Mark this afternoon. First he's sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.","m.mentions":{},"m.new_content":{"body":"I chatted with Mark this afternoon. First he's sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$srVXPXHm2oj4GYlugBDqaCpXctib3BLBBGt0vGQ0rVE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717036809203,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$GXTIebIoYZp8TNlyxlkzuHHKY0f_q_cgP4qhu3SAk_k"},
{"content":{"body":"> <@mhofman:matrix.org> I chatted with Mark this afternoon. First he's sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.\n\nis that in reference to `static` ?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$srVXPXHm2oj4GYlugBDqaCpXctib3BLBBGt0vGQ0rVE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I chatted with Mark this afternoon. First he&#39;s sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you&#39;re roughly a &quot;shared&quot; keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.</blockquote></mx-reply>is that in reference to <code>static</code> ?","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$srVXPXHm2oj4GYlugBDqaCpXctib3BLBBGt0vGQ0rVE"}},"msgtype":"m.text"},"ts":1717041286505,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$rrDvuNzmIR2vfvzJpVvSqXXzyycj1yjxgzoR_4aaiKY"},
{"content":{"body":"static?","m.mentions":{},"msgtype":"m.text"},"ts":1717041322120,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$VpzkEVFXHctU9P9LAR5JCJqfrk1pudMkcBC_RfZaMbc"},
{"content":{"body":"I think the problem is that code written without specific handling of shared memory access is unlikely to be safe when running in multiple threads. Java and C# do not prevent object instances from being shared in the first place, so the problem in these languages is arguably worse since it's pretty much not up to the implementer of the class to enable multi-threading (at best it can document that the class is not thread safe). The current shared struct proposal does require opt-in by marking the object type and/or methods as shared, but we consider that to not be a sufficient friction point in transforming non multi-threaded code, as it's highly unlikely that simply marking a method or type as shared to be sufficient, and that explicit locking logic is likely to be required as well.","m.mentions":{},"msgtype":"m.text"},"ts":1717042077775,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ZOKEL5yjx6E2ADMSAjZcEV8LRhx2dB95GPIN6cmfsPQ"},
{"content":{"body":" * I think the problem is that code written without specific handling of shared memory access is unlikely to be safe when running in multiple threads. Java and C# do not prevent object instances from being shared in the first place, so the problem in these languages is arguably worse since it's pretty much not up to the implementer of the class to enable multi-threading (at best it can document that the class is not thread safe). The current shared struct proposal does require opt-in by marking the struct type as shared, but we consider that to not be a sufficient friction point in transforming non multi-threaded code, as it's highly unlikely that simply marking a struct as shared to be sufficient, and that explicit locking logic is likely to be required as well in the methods.","m.mentions":{},"m.new_content":{"body":"I think the problem is that code written without specific handling of shared memory access is unlikely to be safe when running in multiple threads. Java and C# do not prevent object instances from being shared in the first place, so the problem in these languages is arguably worse since it's pretty much not up to the implementer of the class to enable multi-threading (at best it can document that the class is not thread safe). The current shared struct proposal does require opt-in by marking the struct type as shared, but we consider that to not be a sufficient friction point in transforming non multi-threaded code, as it's highly unlikely that simply marking a struct as shared to be sufficient, and that explicit locking logic is likely to be required as well in the methods.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$ZOKEL5yjx6E2ADMSAjZcEV8LRhx2dB95GPIN6cmfsPQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717042273249,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$b4lpHlVxHK4F91VYRqd3BQ9Vhsveka-muHds7Cgp7mU"},
{"content":{"body":"here's a wild idea, probably misguided as I arguably don't fully grasp the complexities of properly implementing safe shared memory concurrency. Would it make sense that by default (without some kind of explicit opt-out), all methods of a shared struct would take a thread local lock on the instance. By that I mean every time a shared struct method is invoked, it'd check if the thread already has a lock on the object (in case of local re-entrancy or simply the method being called from another method), and if not, acquire a lock on the object. While that's unlikely to be sufficient to reliably protect the users of the object, it should at least make the methods implementations thread safe by default.","m.mentions":{},"msgtype":"m.text"},"ts":1717043078751,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$RZLqulPkpSMIoaFd_7yLrL-igGrMUc532sUTlWjA4e0"},
{"content":{"body":"> <@mhofman:matrix.org> static?\n\nyou mentioned java and c# -- I was asking if you are referring to the `static` keyword from those languages","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$VpzkEVFXHctU9P9LAR5JCJqfrk1pudMkcBC_RfZaMbc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>static?</blockquote></mx-reply>you mentioned java and c# -- I was asking if you are referring to the <code>static</code> keyword from those languages","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$VpzkEVFXHctU9P9LAR5JCJqfrk1pudMkcBC_RfZaMbc"}},"msgtype":"m.text"},"ts":1717043405730,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$euvoK7AR5md2TZXxZ5QHTaqZXUcHv6UII3SLrdKnbeI"}
]