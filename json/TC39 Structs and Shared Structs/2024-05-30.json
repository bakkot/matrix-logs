[
{"content":{"body":"I chatted with Mark this afternoon. First he's sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into code shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.","m.mentions":{},"msgtype":"m.text"},"ts":1717036786642,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$srVXPXHm2oj4GYlugBDqaCpXctib3BLBBGt0vGQ0rVE"},
{"content":{"body":" * I chatted with Mark this afternoon. First he's sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.","m.mentions":{},"m.new_content":{"body":"I chatted with Mark this afternoon. First he's sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$srVXPXHm2oj4GYlugBDqaCpXctib3BLBBGt0vGQ0rVE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717036809203,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$GXTIebIoYZp8TNlyxlkzuHHKY0f_q_cgP4qhu3SAk_k"},
{"content":{"body":"> <@mhofman:matrix.org> I chatted with Mark this afternoon. First he's sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.\n\nis that in reference to `static` ?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$srVXPXHm2oj4GYlugBDqaCpXctib3BLBBGt0vGQ0rVE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I chatted with Mark this afternoon. First he&#39;s sorry about not being able to make it this morning. From what I understand the biggest concern with adding prototype methods to shared structs is that it makes it too easy to transform existing single threaded code into shared memory multi-threaded code without the author realizing the implication of such a transformation. This is especially true with non-shared structs also existing as you&#39;re roughly a &quot;shared&quot; keyword away from transforming into multithreaded existing but non thread safe code. Apparently this is an issue that Java and C# both suffered from.</blockquote></mx-reply>is that in reference to <code>static</code> ?","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$srVXPXHm2oj4GYlugBDqaCpXctib3BLBBGt0vGQ0rVE"}},"msgtype":"m.text"},"ts":1717041286505,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$rrDvuNzmIR2vfvzJpVvSqXXzyycj1yjxgzoR_4aaiKY"},
{"content":{"body":"static?","m.mentions":{},"msgtype":"m.text"},"ts":1717041322120,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$VpzkEVFXHctU9P9LAR5JCJqfrk1pudMkcBC_RfZaMbc"},
{"content":{"body":"I think the problem is that code written without specific handling of shared memory access is unlikely to be safe when running in multiple threads. Java and C# do not prevent object instances from being shared in the first place, so the problem in these languages is arguably worse since it's pretty much not up to the implementer of the class to enable multi-threading (at best it can document that the class is not thread safe). The current shared struct proposal does require opt-in by marking the object type and/or methods as shared, but we consider that to not be a sufficient friction point in transforming non multi-threaded code, as it's highly unlikely that simply marking a method or type as shared to be sufficient, and that explicit locking logic is likely to be required as well.","m.mentions":{},"msgtype":"m.text"},"ts":1717042077775,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ZOKEL5yjx6E2ADMSAjZcEV8LRhx2dB95GPIN6cmfsPQ"},
{"content":{"body":" * I think the problem is that code written without specific handling of shared memory access is unlikely to be safe when running in multiple threads. Java and C# do not prevent object instances from being shared in the first place, so the problem in these languages is arguably worse since it's pretty much not up to the implementer of the class to enable multi-threading (at best it can document that the class is not thread safe). The current shared struct proposal does require opt-in by marking the struct type as shared, but we consider that to not be a sufficient friction point in transforming non multi-threaded code, as it's highly unlikely that simply marking a struct as shared to be sufficient, and that explicit locking logic is likely to be required as well in the methods.","m.mentions":{},"m.new_content":{"body":"I think the problem is that code written without specific handling of shared memory access is unlikely to be safe when running in multiple threads. Java and C# do not prevent object instances from being shared in the first place, so the problem in these languages is arguably worse since it's pretty much not up to the implementer of the class to enable multi-threading (at best it can document that the class is not thread safe). The current shared struct proposal does require opt-in by marking the struct type as shared, but we consider that to not be a sufficient friction point in transforming non multi-threaded code, as it's highly unlikely that simply marking a struct as shared to be sufficient, and that explicit locking logic is likely to be required as well in the methods.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$ZOKEL5yjx6E2ADMSAjZcEV8LRhx2dB95GPIN6cmfsPQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717042273249,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$b4lpHlVxHK4F91VYRqd3BQ9Vhsveka-muHds7Cgp7mU"},
{"content":{"body":"here's a wild idea, probably misguided as I arguably don't fully grasp the complexities of properly implementing safe shared memory concurrency. Would it make sense that by default (without some kind of explicit opt-out), all methods of a shared struct would take a thread local lock on the instance. By that I mean every time a shared struct method is invoked, it'd check if the thread already has a lock on the object (in case of local re-entrancy or simply the method being called from another method), and if not, acquire a lock on the object. While that's unlikely to be sufficient to reliably protect the users of the object, it should at least make the methods implementations thread safe by default.","m.mentions":{},"msgtype":"m.text"},"ts":1717043078751,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$RZLqulPkpSMIoaFd_7yLrL-igGrMUc532sUTlWjA4e0"},
{"content":{"body":"> <@mhofman:matrix.org> static?\n\nyou mentioned java and c# -- I was asking if you are referring to the `static` keyword from those languages","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$VpzkEVFXHctU9P9LAR5JCJqfrk1pudMkcBC_RfZaMbc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>static?</blockquote></mx-reply>you mentioned java and c# -- I was asking if you are referring to the <code>static</code> keyword from those languages","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$VpzkEVFXHctU9P9LAR5JCJqfrk1pudMkcBC_RfZaMbc"}},"msgtype":"m.text"},"ts":1717043405730,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$euvoK7AR5md2TZXxZ5QHTaqZXUcHv6UII3SLrdKnbeI"},
{"content":{"body":"from what I understand there is plenty of ways in those languages to make object instances available to multiple threads, not just the `static` keyword","format":"org.matrix.custom.html","formatted_body":"from what I understand there is plenty of ways in those languages to make object instances available to multiple threads, not just the <code>static</code> keyword","m.mentions":{},"msgtype":"m.text"},"ts":1717043467180,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$GbVX9XZ-imy3U2sxGD4duM98g4pFqPTMF0sJbmfJxCU"},
{"content":{"body":"sure.  contextually, it seemed it was in reference to 'you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code'","m.mentions":{},"msgtype":"m.text"},"ts":1717043559709,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$-TSpmYAA0Y2GW8uooL6y4ECmqAljD0q-2l0K77fU0nc"},
{"content":{"body":"In general, we remain skeptical about introducing complexity just to enable developers to use shared object as regular objects with methods","m.mentions":{},"msgtype":"m.text"},"ts":1717043647309,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$1lpgZtzGtNRE-l00QFrWc-mWOLGvVCqjRCem4UfN-pA"},
{"content":{"body":"what I am trying to understand is what specific comparisons are being made to java and c#","m.mentions":{},"msgtype":"m.text"},"ts":1717043674389,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$9LWe5Y7xxE5eYQy_jhZhyTN_M1YI-Bp4k5IXWMUOAHg"},
{"content":{"body":"> <@softwarechris:matrix.org> sure.  contextually, it seemed it was in reference to 'you're roughly a \"shared\" keyword away from transforming into multithreaded existing but non thread safe code'\n\nah yeah. I think the point I was trying to make is that it's just too easy to cause code that isn't written with thread safety in mind to execute in multiple threads","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$-TSpmYAA0Y2GW8uooL6y4ECmqAljD0q-2l0K77fU0nc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@softwarechris:matrix.org\">@softwarechris:matrix.org</a><br>sure.  contextually, it seemed it was in reference to &#39;you&#39;re roughly a &quot;shared&quot; keyword away from transforming into multithreaded existing but non thread safe code&#39;</blockquote></mx-reply>ah yeah. I think the point I was trying to make is that it's just too easy to cause code that isn't written with thread safety in mind to execute in multiple threads","m.mentions":{"user_ids":["@softwarechris:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$-TSpmYAA0Y2GW8uooL6y4ECmqAljD0q-2l0K77fU0nc"}},"msgtype":"m.text"},"ts":1717043744893,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Nsf9-7ZP5KZ67Qbm_oUE89sMAsgamy1s5BHPJvKqLdQ"},
{"content":{"body":"it certainly can be...  ask me some time about how an errant `static` nearly brought down a company","format":"org.matrix.custom.html","formatted_body":"it certainly can be...  ask me some time about how an errant <code>static</code> nearly brought down a company","m.mentions":{},"msgtype":"m.text"},"ts":1717043793449,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$4LzobqGD1SSUIMj2U-fjmVm2YYfeAGuXNb1WHgmt2Qo"},
{"content":{"body":"although java/c# folks will probably tell you that the ease of that is a feature rather than a bug","m.mentions":{},"msgtype":"m.text"},"ts":1717043819541,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$7r4nGKIdR-Ano_HJuPWKV94UPMWfaf0jA5LrxSmLQ-M"},
{"content":{"body":" * although java/c# folks will probably tell you that the ease of doing that is a feature rather than a bug","m.mentions":{},"m.new_content":{"body":"although java/c# folks will probably tell you that the ease of doing that is a feature rather than a bug","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$7r4nGKIdR-Ano_HJuPWKV94UPMWfaf0jA5LrxSmLQ-M","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717043834243,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$C7v67-yFqql60tKEC50pv9Xyj70LELIBXEdbq4NkfDk"},
{"content":{"body":"the JS proposal is marginally better as it requires an opt-in from the object's implementor, but the \"opt-in\" is still too easy in our opinion","m.mentions":{},"msgtype":"m.text"},"ts":1717043839893,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ysxIuv_KmvOfmrKSjx7aj55m_lvZJVo1qb_ksbLZLa8"},
{"content":{"body":"the headers you mean?","m.mentions":{},"msgtype":"m.text"},"ts":1717045135552,"senderName":"Chris de Almeida","senderId":"@softwarechris:matrix.org","id":"$QS9bglHBNAYkefTlTAK3zQy7P2VxwdhaC_cvb2NOrvU"},
{"content":{"body":"the headers are extremely hard to opt into, i don't understand","m.mentions":{},"msgtype":"m.text"},"ts":1717046258843,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$0VGeoUq-NYZJO3S_QtvjdOJix4TEReQALpaxHpjCYK0"},
{"content":{"body":"mark would like more syntactic friction?","m.mentions":{},"msgtype":"m.text"},"ts":1717046265367,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$_IbdsvvRAVflpy-mdrouO0JkxxINJwV1AKqftF1kM4E"},
{"content":{"body":"i don't really understand how someone can accidentally opt into multitreading","m.mentions":{},"msgtype":"m.text"},"ts":1717046307313,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$fVjOYw0sVOCPhi9rdlhWa88-VKEiYSCKqJvkhVhnLYg"},
{"content":{"body":"like, making the struct shared is a necessary but insufficient condition to actually opt into the style","m.mentions":{},"msgtype":"m.text"},"ts":1717046321374,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$rZvqG9sarQMe9guYKcOF6HIBPigazhpRtykPOD2U-8g"},
{"content":{"body":"you have to communicate it to another thread, set up the code to receive it, etc","m.mentions":{},"msgtype":"m.text"},"ts":1717046331167,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$sXvSoOZ_gsdXIPEArrfP8Rjk9tzmJWooj9zdTupuK7k"},
{"content":{"body":"this argument seems very weak to me","m.mentions":{},"msgtype":"m.text"},"ts":1717046413126,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$gakV8ajW_73U3T01AfkMbluPZQecoevwdUgbYOtXtVA"},
{"content":{"body":"> <@mhofman:matrix.org> ah yeah. I think the point I was trying to make is that it's just too easy to cause code that isn't written with thread safety in mind to execute in multiple threads\n\nthis is true, and is not a goal of this proposal","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Nsf9-7ZP5KZ67Qbm_oUE89sMAsgamy1s5BHPJvKqLdQ?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>ah yeah. I think the point I was trying to make is that it's just too easy to cause code that isn't written with thread safety in mind to execute in multiple threads</blockquote></mx-reply>this is true, and is not a goal of this proposal","m.mentions":{"user_ids":["@mhofman:matrix.org","@softwarechris:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$Nsf9-7ZP5KZ67Qbm_oUE89sMAsgamy1s5BHPJvKqLdQ"}},"msgtype":"m.text"},"ts":1717046510789,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$GJd1cWhpSsG3FvuCBqPjWPdMkX0N1_FG79T1QlLYsQk"},
{"content":{"body":"that is, it is not a goal of this proposal to be opinionated about a particular style of thread safety","m.mentions":{},"msgtype":"m.text"},"ts":1717046592068,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$gHAOiVTV19wcdCHhdXEol308J95QGS4OolglNffBpiI"},
{"content":{"body":"the syntactic friction argument doesn't hold water. if the headers aren't considered enough friction, i don't know what would be. if the headers are considered enough friction but wants it reflected at the engine level, we can choose to spec an opt-in gate that the host has to trigger, and it'll be up to Node and other runtimes to understand the intention here is that it's an opt-in feature","m.mentions":{},"msgtype":"m.text"},"ts":1717046700704,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$Qh66r2vj-TQNDAmry_HCc4kBLLUJLGtJdR0qx0F0ZYs"},
{"content":{"body":"> <@mhofman:matrix.org> here's a wild idea, probably misguided as I arguably don't fully grasp the complexities of properly implementing safe shared memory concurrency. Would it make sense that by default (without some kind of explicit opt-out), all methods of a shared struct would take a thread local lock on the instance. By that I mean every time a shared struct method is invoked, it'd check if the thread already has a lock on the object (in case of local re-entrancy or simply the method being called from another method), and if not, acquire a lock on the object. While that's unlikely to be sufficient to reliably protect the users of the object, it should at least make the methods implementations thread safe by default.\n\nthat's a non-starter","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$RZLqulPkpSMIoaFd_7yLrL-igGrMUc532sUTlWjA4e0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>here&#39;s a wild idea, probably misguided as I arguably don&#39;t fully grasp the complexities of properly implementing safe shared memory concurrency. Would it make sense that by default (without some kind of explicit opt-out), all methods of a shared struct would take a thread local lock on the instance. By that I mean every time a shared struct method is invoked, it&#39;d check if the thread already has a lock on the object (in case of local re-entrancy or simply the method being called from another method), and if not, acquire a lock on the object. While that&#39;s unlikely to be sufficient to reliably protect the users of the object, it should at least make the methods implementations thread safe by default.</blockquote></mx-reply>that's a non-starter","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$RZLqulPkpSMIoaFd_7yLrL-igGrMUc532sUTlWjA4e0"}},"msgtype":"m.text"},"ts":1717046778373,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zHJtTlyBlJiNwlnUtmqKqpBA6OMgi3rbFWX0nsrKo0I"},
{"content":{"body":"it is too costly","m.mentions":{},"msgtype":"m.text"},"ts":1717046790693,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$9RUE9oky4t4SfHNtQlskLJzCMtwHeZnUfJE82QIssZA"},
{"content":{"body":"Does it matter if the default is costly as long as there is a way to opt out of the default safety and gain performance?","msgtype":"m.text"},"ts":1717046880017,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$52f0rQdIT2vKjCAxo8MOkNPgk2kPq2c86axronoBhg0"},
{"content":{"body":"well, yes, the default is already safe (the headers aren't present by default)","m.mentions":{},"msgtype":"m.text"},"ts":1717046946370,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$nBrdVm5ocjequtQCnrK-VdN6SjXbZ46Ws7-i0lOdVrQ"},
{"content":{"body":"it also puts a requirement on implementations that there be a lock per object","m.mentions":{},"msgtype":"m.text"},"ts":1717046998078,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LIV_yrOfONuM1NBRLwDh1tDMmuXMOgBQFrHqCk1LO7g"},
{"content":{"body":"The concern in this case is not how hard it is for the application as a whole to adopt shared memory multithreading, but how not sufficiently hard it is to mark code that is not thread safe to \"support\" shared memory access. Namely add a shared keyword to a struct declaration.","msgtype":"m.text"},"ts":1717047064018,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$8ttWTGMXGDy9uY-LHqQPGECsFCKjH4-heEl6jTJUzrE"},
{"content":{"body":"what's the counterargument to what i said above?","m.mentions":{},"msgtype":"m.text"},"ts":1717047080207,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$E2duaJAt6wY9huYdvU5GjmDjX7ePa7QmzRz8sUFyW2c"},
{"content":{"body":"adding the shared keyword is a necessary but insufficient condition","m.mentions":{},"msgtype":"m.text"},"ts":1717047095154,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$STFBcYGldjmvRn5eEVmn2e0DDE0C7KKovJmpj0XRnu4"},
{"content":{"body":"you still have to write code to communicate a shared struct","m.mentions":{},"msgtype":"m.text"},"ts":1717047108258,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$WhTLdLE5cu5uX7RwqHNXTqgx_yCqOVaaTPXZOiC8Hiw"},
{"content":{"body":"It's sufficient from the implementor of the struct. Your argument assumes the author of the app and of the struct is the same.","msgtype":"m.text"},"ts":1717047154316,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$WITtDoa0d-doO-dBc5Nvzp_tbQySk7EucCmnH6dw6y0"},
{"content":{"body":"the worry is the app author downloads a library, sees that it's marked as a shared struct, and assumes it's threadsafe, but the library is buggy and it is not threadsafe?","m.mentions":{},"msgtype":"m.text"},"ts":1717047192149,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$n5NmXp0hV9Z5k5k1AWeWWgPJEHdmqzBX3lIGRDqlG4c"},
{"content":{"body":"what's different in this case vs an otherwise buggy library?","m.mentions":{},"msgtype":"m.text"},"ts":1717047261652,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$m5gwvndvP8xtp10qoiMVUZoBRkeH9QAB9FJLXe-04ko"},
{"content":{"body":"The worry is that the library authors could believe they can support multithreading by simply adding a keyword to their objects, without taking time to understand what they're actually doing","msgtype":"m.text"},"ts":1717047289513,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$-KeoqrsUo7ZDqN1I9rkurvjQu3XTe14Gs5e9sWyuzZ4"},
{"content":{"body":"that is a fully generic argument that can apply to anything that requires expertise...?","m.mentions":{},"msgtype":"m.text"},"ts":1717047317287,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$zped2QVpZDLqy6tG38VBoYWUwgXI2OBhESZs2VanTaA"},
{"content":{"body":"i'm on board with safe by default. i consider that status quo to have that because it requires the app author to do the opt in, not the library authors","m.mentions":{},"msgtype":"m.text"},"ts":1717047386079,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$P-OJ6jluIfakqw5cpGhE60I9HklJ-k9yCQESubE-0O4"},
{"content":{"body":"if the app author trusts the library authors, and that trust turned out incorrect, i see that as the normal cost of doing software development","m.mentions":{},"msgtype":"m.text"},"ts":1717047434925,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$U7xItNdSvPpMIDwtz1CtdgKw2m2yrNJJTAEnZ1uwqfA"},
{"content":{"body":"I don't know of programming concepts that are similarly hard to get right if not extremely careful.","msgtype":"m.text"},"ts":1717047460244,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$ckRnz2gKB8nC52elOunTFLsMbR7FSFg8zhpPExv_rlc"},
{"content":{"body":"i can think of several","m.mentions":{},"msgtype":"m.text"},"ts":1717047506904,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$_K3AAP-OEYpTFXf9JTlNx6F2KtUs-OVlJjIepkga9Cg"},
{"content":{"body":"manual memory management, asynchrony","m.mentions":{},"msgtype":"m.text"},"ts":1717047514294,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$oV42IDcULmtDd-_CNqccjQXF6_5RMDN1kMLZ68xPemM"},
{"content":{"body":"JITs (dynamic codegen)","m.mentions":{},"msgtype":"m.text"},"ts":1717047531401,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$2ZOLZeT-z7fIg5fzoC6pnDKkt8wVyxM236z3VI1pHgk"},
{"content":{"body":"also, what's the cost to getting it wrong?","m.mentions":{},"msgtype":"m.text"},"ts":1717047564669,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$fhl4mJqyCVBJikUI__45LLKqzWA3BtbgnZKvJlTwvgk"},
{"content":{"body":"it's not crashes","m.mentions":{},"msgtype":"m.text"},"ts":1717047567038,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$vvITLxo0eEhX_TfkzSdixYI9xccAMZTC6bKkOB8MOhg"},
{"content":{"body":"JS doesn't really have manual memory management, and I'd argue that it's maybe too easy to shoot yourself in the foot with array buffers.","msgtype":"m.text"},"ts":1717047576801,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$KkwpFv1JRUnDp6bHLIboM89_57xB56yTMYrDeWE418w"},
{"content":{"body":"it's something like \"undefined values\"","m.mentions":{},"msgtype":"m.text"},"ts":1717047580140,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$BURDAw60KcRFKb6hb73RIJpNVZ_rq5chjLzux_kET8U"},
{"content":{"body":"what i'm trying to get at it is: i don't see a principle at work here for how many layers/kinds of friction is enough, if the opt-in headers aren't","m.mentions":{},"msgtype":"m.text"},"ts":1717047642222,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$sEIUnERIY911ddVjql5hCfCukw_dkVEJnjQKIsm8GQM"},
{"content":{"body":"I agree that asynchrony and in particular re-entrancy during suspension is not always sufficiently understood. But it's easier to reason about thanks to the explicitness of await points","msgtype":"m.text"},"ts":1717047671251,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$KPtAMuQ9oA6LY80iSaTDRcd_piPzcdt0XgvmoQtVq8I"},
{"content":{"body":"i don't think \"appeasing mark\" is a good design principle for how much friction something should have","m.mentions":{},"msgtype":"m.text"},"ts":1717047700471,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$hLMrPCEFLednbrOtmxb2rzoLRUiWgic5Ya5r2BBzlhU"},
{"content":{"body":"i'd also like to better understand the consequences of getting this wrong","m.mentions":{},"msgtype":"m.text"},"ts":1717047783482,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$6JfZkGd7g9Or3NlVmqCExe5ysxp24q7VAxSnB_kocpo"},
{"content":{"body":"this = a buggy library","m.mentions":{},"msgtype":"m.text"},"ts":1717047787495,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$LJz4UW0uCUP8PMNNUk4ewTdq15vWCLSm-EXY4HcIJcI"},
{"content":{"body":"why is that assumed to be a categorically worse kind of \"wrong\" than today's bugs?","m.mentions":{},"msgtype":"m.text"},"ts":1717047802047,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$K_57ZvftoFdWqllpq61gao9NiEEIEMnoppZqPMFO6dE"},
{"content":{"body":"I have to go, sorry","msgtype":"m.text"},"ts":1717047806035,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$285NA2s6N9gs5AwXKvosUpfVbOC5-mPFZF9Qgj5L0Dc"},
{"content":{"body":"all right well, i'm pretty disappointed in the state of affairs","m.mentions":{},"msgtype":"m.text"},"ts":1717047854523,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$w73APyyHlPoF4Z_xE6Vpll-ZHADkIyjIk6TvUtKp-Wk"},
{"content":{"body":"Mathieu Hofman: here's a hypothetical when you're back. would making shared structs inaccessible outside of `shared { }` code blocks (a la `unsafe { }` blocks in rust) be considered sufficient syntactic friction?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>: here's a hypothetical when you're back. would making shared structs inaccessible outside of <code>shared { }</code> code blocks (a la <code>unsafe { }</code> blocks in rust) be considered sufficient syntactic friction?","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"msgtype":"m.text"},"ts":1717049156632,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$lM1Iln1TuOfF7GxFvZM-pkzEbVzG3LLbSMwFi97qzoE"},
{"content":{"body":"and if it isn't, i'd like to understand the reasoning","m.mentions":{},"msgtype":"m.text"},"ts":1717049204225,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$iwud_aAblg6_1LdonuYiVMwRJWX1c6ZxRRuHDlL_X1I"},
{"content":{"body":"> <@mhofman:matrix.org> I don't know of programming concepts that are similarly hard to get right if not extremely careful.\n\n`FinalizationRegistry` comes to my mind","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24ckRnz2gKB8nC52elOunTFLsMbR7FSFg8zhpPExv_rlc\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>I don't know of programming concepts that are similarly hard to get right if not extremely careful.</blockquote></mx-reply>`FinalizationRegistry` comes to my mind","m.relates_to":{"m.in_reply_to":{"event_id":"$ckRnz2gKB8nC52elOunTFLsMbR7FSFg8zhpPExv_rlc"}},"msgtype":"m.text"},"ts":1717050582055,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$Sgr3t7oECqanEz8h-bnm3Ez1TYdyPI52cLcsUehHfw0"},
{"content":{"body":"> <@shuyuguo:matrix.org> and if it isn't, i'd like to understand the reasoning\n\nI'll chat more with Mark ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$iwud_aAblg6_1LdonuYiVMwRJWX1c6ZxRRuHDlL_X1I?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br />and if it isn't, i'd like to understand the reasoning</blockquote></mx-reply>I'll chat more with Mark","m.relates_to":{"m.in_reply_to":{"event_id":"$iwud_aAblg6_1LdonuYiVMwRJWX1c6ZxRRuHDlL_X1I"}},"msgtype":"m.text"},"ts":1717051235811,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$yi52h85AvjSK2RVkMHO9rFsE49DouGmYdSIEjSiPbBA"},
{"content":{"body":"> <@aclaymore:matrix.org> `FinalizationRegistry` comes to my mind\n\nThat's actually a good example of a safer abstraction compared to destructors. Sure it's advanced, and still possible to create situations that are not optimal, but unlike destructors, it's a lot harder to cause critical bugs.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Sgr3t7oECqanEz8h-bnm3Ez1TYdyPI52cLcsUehHfw0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br />`FinalizationRegistry` comes to my mind</blockquote></mx-reply>That's actually a good example of a safer abstraction compared to destructors. Sure it's advanced, and still possible to create situations that are not optimal, but unlike destructors, it's a lot harder to cause critical bugs.","m.relates_to":{"m.in_reply_to":{"event_id":"$Sgr3t7oECqanEz8h-bnm3Ez1TYdyPI52cLcsUehHfw0"}},"msgtype":"m.text"},"ts":1717051376753,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$4wyCp6MTZRdhKZ1LwhPx9O23sFCEfdrHJvxzZ-s0xeI"}
]