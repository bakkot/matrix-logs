[
{"content":{"body":"> <@shuyuguo:matrix.org> Mathieu Hofman: here's a hypothetical when you're back. would making shared structs inaccessible outside of `shared { }` code blocks (a la `unsafe { }` blocks in rust) be considered sufficient syntactic friction?\n\nwhat do you mean by making inaccessible? I doubt you mean preventing interaction with instances of share structs outside these blocks? I don't see how could even work.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$lM1Iln1TuOfF7GxFvZM-pkzEbVzG3LLbSMwFi97qzoE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br><a href=\"https://matrix.to/#/@mhofman:matrix.org\">Mathieu Hofman</a>: here's a hypothetical when you're back. would making shared structs inaccessible outside of <code>shared { }</code> code blocks (a la <code>unsafe { }</code> blocks in rust) be considered sufficient syntactic friction?</blockquote></mx-reply>what do you mean by making inaccessible? I doubt you mean preventing interaction with instances of share structs outside these blocks? I don't see how could even work.","m.mentions":{"user_ids":["@shuyuguo:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$lM1Iln1TuOfF7GxFvZM-pkzEbVzG3LLbSMwFi97qzoE"}},"msgtype":"m.text"},"ts":1717128049847,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$EDp-YBudceMMCrAYqLXySkb5mhARI2KPD41xwEXFYbc"},
{"content":{"body":"> <@littledan:matrix.org> This is a pretty broad thing to be skeptical of. How does this fit together with rbuckton's feedback that methods were important for usability? Also, are you considering that the fundamental technology (\"TLS\") is needed for Wasm anyway, so most of the complexity will be there in the system either way?\n\nFor wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$XdVpvQJnLAtrShVaXF3kLqFyVDokbZXDxyESg9P3UbE?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>This is a pretty broad thing to be skeptical of. How does this fit together with rbuckton's feedback that methods were important for usability? Also, are you considering that the fundamental technology (\"TLS\") is needed for Wasm anyway, so most of the complexity will be there in the system either way?</blockquote></mx-reply>For wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$XdVpvQJnLAtrShVaXF3kLqFyVDokbZXDxyESg9P3UbE"}},"msgtype":"m.text"},"ts":1717128444490,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$wllYXk-jUy0Oo4sFihClkgGkZi6_1BUx-tSp5EOpiIY"},
{"content":{"body":"> <@littledan:matrix.org> even though FinalizationRegistry uses a similarly function/constructor-based API with no syntax, that doesn't really provide any meaningful friction to prevent abuse. The motivation for abuse doesn't come from convenient syntax but rather useful semantics that people misunderstand and want to get at.\n\nFinalizationRegistry is different enough from destructors that it forces you to rethink what you're actually doing. Of course that doesn't guarantee the author will get it right.\nShared structs is an improvement over SAB for complex value types. However SAB did force you to think about what you were doing when coming from an object model. The concern here is that an author can too easily take a regular non shared aware class, and transform it into a shared struct, without really thinking about what they're doing.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$mLjhyyaV1JNp1t4Nn7gD-XfNv3-ovjkLNGZ7rKt9CZc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>even though FinalizationRegistry uses a similarly function/constructor-based API with no syntax, that doesn&#39;t really provide any meaningful friction to prevent abuse. The motivation for abuse doesn&#39;t come from convenient syntax but rather useful semantics that people misunderstand and want to get at.</blockquote></mx-reply>FinalizationRegistry is different enough from destructors that it forces you to rethink what you're actually doing. Of course that doesn't guarantee the author will get it right.<br>Shared structs is an improvement over SAB for complex value types. However SAB did force you to think about what you were doing when coming from an object model. The concern here is that an author can too easily take a regular non shared aware class, and transform it into a shared struct, without really thinking about what they're doing.","m.mentions":{"user_ids":["@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$mLjhyyaV1JNp1t4Nn7gD-XfNv3-ovjkLNGZ7rKt9CZc"}},"msgtype":"m.text"},"ts":1717128875314,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$f0nokT25Pi1Rcy_nUswhtyo8yMlj-C7oXjzj8pyGNng"},
{"content":{"body":"> <@mhofman:matrix.org> For wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.\n\nThe prototype-attaching thing could be done by Proxy, if you have the TLS primitive. That is, it can be implemented just with what Wasm will already add.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24wllYXk-jUy0Oo4sFihClkgGkZi6_1BUx-tSp5EOpiIY\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>For wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.</blockquote></mx-reply>The prototype-attaching thing could be done by Proxy, if you have the TLS primitive. That is, it can be implemented just with what Wasm will already add.","m.relates_to":{"m.in_reply_to":{"event_id":"$wllYXk-jUy0Oo4sFihClkgGkZi6_1BUx-tSp5EOpiIY"}},"msgtype":"m.text"},"ts":1717156724152,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$st8L8HxJWEeW9khNw6IL_2UwXD3ztTlaLRznRUwvPj0"},
{"content":{"body":"> <@mhofman:matrix.org> For wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.\n\nFor WASM shared objects to be remotely usable from JS, you need to be able to interact with them _somehow_. If they are opaque, that only means that interactions must go through a wrapper/Proxy, as littledan said, and also likely need to be valid `WeakMap` keys so that such proxies work. As a result, opaque WASM shared objects are not inherently safer, just slower due to indirection and FFI marshaling. When I brought up having WASM shared objects be opaque entities in a prior structs meeting, the main purpose was to discuss a _worst case_ fallback position if we don't have a comprehensive story for JS shared objects. If WASM shared objects were to be introduced as ordinary JS objects and we were to want to later introduce JS shared structs with unique semantics around field reads and writes (such as what I discussed above re `unsafe`), then mutable WASM shared objects couldn't align with that approach without breaking existing consumers. Whether WASM shared objects are opaque or not has nothing to do with thread safety, only runtime semantic consistency. Thread safety is still a split responsibility between the shared object implementer and shared object consumer based on the needs of any given use case.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$wllYXk-jUy0Oo4sFihClkgGkZi6_1BUx-tSp5EOpiIY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>For wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.</blockquote></mx-reply>For WASM shared objects to be remotely usable from JS, you need to be able to interact with them <em>somehow</em>. If they are opaque, that only means that interactions must go through a wrapper/Proxy, as littledan said, and also likely need to be valid <code>WeakMap</code> keys so that such proxies work. As a result, opaque WASM shared objects are not inherently safer, just slower due to indirection and FFI marshaling. When I brought up having WASM shared objects be opaque entities in a prior structs meeting, the main purpose was to discuss a <em>worst case</em> fallback position if we don't have a comprehensive story for JS shared objects. If WASM shared objects were to be introduced as ordinary JS objects and we were to want to later introduce JS shared structs with unique semantics around field reads and writes (such as what I discussed above re <code>unsafe</code>), then mutable WASM shared objects couldn't align with that approach without breaking existing consumers. Whether WASM shared objects are opaque or not has nothing to do with thread safety, only runtime semantic consistency. Thread safety is still a split responsibility between the shared object implementer and shared object consumer based on the needs of any given use case.","m.mentions":{"user_ids":["@mhofman:matrix.org","@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$wllYXk-jUy0Oo4sFihClkgGkZi6_1BUx-tSp5EOpiIY"}},"msgtype":"m.text"},"ts":1717160322301,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wjfLL7Jn4atXhUcnnfPJjnniEdvrhGXNV5Cjc9KKlHY"},
{"content":{"body":"> <@mhofman:matrix.org> For wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.\n\nattaching prototypes is coming eventually, it's just not prioritized ahead of shared wasmgc","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$wllYXk-jUy0Oo4sFihClkgGkZi6_1BUx-tSp5EOpiIY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>For wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.</blockquote></mx-reply>attaching prototypes is coming eventually, it's just not prioritized ahead of shared wasmgc","m.mentions":{"user_ids":["@mhofman:matrix.org","@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$wllYXk-jUy0Oo4sFihClkgGkZi6_1BUx-tSp5EOpiIY"}},"msgtype":"m.text"},"ts":1717164485471,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$iXd7d4ICOHjO4-yJKzytDnoSUffeh4ktnqGxedWNqrM"},
{"content":{"body":"> <@mhofman:matrix.org> what do you mean by making inaccessible? I doubt you mean preventing interaction with instances of share structs outside these blocks? I don't see how could even work.\n\ni do mean that. like, imagine all the vtable methods like [[GetOwnProperty]] throw if you're not inside one of these blocks","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$EDp-YBudceMMCrAYqLXySkb5mhARI2KPD41xwEXFYbc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>what do you mean by making inaccessible? I doubt you mean preventing interaction with instances of share structs outside these blocks? I don't see how could even work.</blockquote></mx-reply>i do mean that. like, imagine all the vtable methods like [[GetOwnProperty]] throw if you're not inside one of these blocks","m.mentions":{"user_ids":["@mhofman:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$EDp-YBudceMMCrAYqLXySkb5mhARI2KPD41xwEXFYbc"}},"msgtype":"m.text"},"ts":1717164552668,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$1b8exNkk5KFoyqJn_ZDPiRSys3aEiVMvestq_sypEO4"},
{"content":{"body":"i said hypothetical","m.mentions":{},"msgtype":"m.text"},"ts":1717164568478,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$tf-4hI7GailaysE6eNOceSuo3lhqFAYpCEvnfsHeOxs"},
{"content":{"body":"suspend your disbelief","m.mentions":{},"msgtype":"m.text"},"ts":1717164570908,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$REfkBhgFofQASQM0uJCt6WjRXwPdirkA9Qp0vE7QLfU"},
{"content":{"body":"if it's possible, is that considered \"enough friction\"","m.mentions":{},"msgtype":"m.text"},"ts":1717164577651,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$p9Ywej_B3DjRKpRASNYA6nA8z2laD1jQe2CtPl6NPDE"},
{"content":{"body":"here's what i want to do: i'd like to get your side to articulate a greatest lower bound on what's \"enough friction\", then we analyze why that's considered enough. if there's a design principle there that's not \"because we feel like it is\", then happy to continue the discussion, otherwise not productive","m.mentions":{},"msgtype":"m.text"},"ts":1717164810829,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$u8grZbNc33AgnHZU0vOr5pStJ_FrsFh1UEb0OHg6Xi8"},
{"content":{"body":"> <@mhofman:matrix.org> For wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.\n\nanyway the real answer is that if the prototype semantics as proposed here isn't part of this proposal, it'll be done as part of the wasm/js API because we still believe that's the best semantics to bridge the shared/unshared worlds","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$wllYXk-jUy0Oo4sFihClkgGkZi6_1BUx-tSp5EOpiIY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br>For wasm shared objects, one approach is for them to be opaque obects in JS, without any fields. Afaik, there is also no proposal for attaching prototypes to non-shared wasm refs either. So I fail to see how the complexity for this JS feature would already be there.</blockquote></mx-reply>anyway the real answer is that if the prototype semantics as proposed here isn't part of this proposal, it'll be done as part of the wasm/js API because we still believe that's the best semantics to bridge the shared/unshared worlds","m.mentions":{"user_ids":["@mhofman:matrix.org","@littledan:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$wllYXk-jUy0Oo4sFihClkgGkZi6_1BUx-tSp5EOpiIY"}},"msgtype":"m.text"},"ts":1717165042973,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$CpY9fBkCOrka-_mdLGZTnosim5ThS7vu6b1yNL1iIvc"},
{"content":{"body":"If you wanted, for example, to implement something akin to Rust's `Mutex<T>`, you could do so with a `Proxy` whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to [this example](https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads) in the Rust docs (NOTE: uses module expressions):\n\n```js\n// main.js\nimport { ThreadState } from \"./thread_state.js\";\nimport { MutexValue } from \"./mutex_value.js\";\nimport { Worker } from \"node:worker_threads\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i < 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () => this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\n\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>If you wanted, for example, to implement something akin to Rust's <code>Mutex&lt;T&gt;</code>, you could do so with a <code>Proxy</code> whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to <a href=\"https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads\">this example</a> in the Rust docs (NOTE: uses module expressions):</p>\n<pre><code class=\"language-js\">// main.js\nimport { ThreadState } from \"./thread_state.js\";\nimport { MutexValue } from \"./mutex_value.js\";\nimport { Worker } from \"node:worker_threads\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i &lt; 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () =&gt; this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\n\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1717165694759,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WXhBDNBn6n1f7Jcbj0d6OMD70wRJLamqve_5J4RPM7I"},
{"content":{"body":" * If you wanted, for example, to implement something akin to Rust's `Mutex<T>`, you could do so with a `Proxy` whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to [this example](https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads) in the Rust docs (NOTE: uses module expressions):\n\n```js\n// main.js\nimport { Thread } from \"./thread.js\";\nimport { MutexValue } from \"./mutex_value.js\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i < 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () => this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\n\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>If you wanted, for example, to implement something akin to Rust's <code>Mutex&lt;T&gt;</code>, you could do so with a <code>Proxy</code> whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to <a href=\"https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads\">this example</a> in the Rust docs (NOTE: uses module expressions):</p>\n<pre><code class=\"language-js\">// main.js\nimport { Thread } from \"./thread.js\";\nimport { MutexValue } from \"./mutex_value.js\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i &lt; 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () =&gt; this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\n\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"If you wanted, for example, to implement something akin to Rust's `Mutex<T>`, you could do so with a `Proxy` whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to [this example](https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads) in the Rust docs (NOTE: uses module expressions):\n\n```js\n// main.js\nimport { Thread } from \"./thread.js\";\nimport { MutexValue } from \"./mutex_value.js\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i < 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () => this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\n\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>If you wanted, for example, to implement something akin to Rust's <code>Mutex&lt;T&gt;</code>, you could do so with a <code>Proxy</code> whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to <a href=\"https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads\">this example</a> in the Rust docs (NOTE: uses module expressions):</p>\n<pre><code class=\"language-js\">// main.js\nimport { Thread } from \"./thread.js\";\nimport { MutexValue } from \"./mutex_value.js\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i &lt; 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () =&gt; this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\n\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$WXhBDNBn6n1f7Jcbj0d6OMD70wRJLamqve_5J4RPM7I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717165773760,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$k84xtZXle_FWPzH1kM2Y1uvlXQ1Ug_e9gkIrnHSdQo8"},
{"content":{"body":" * If you wanted, for example, to implement something akin to Rust's `Mutex<T>`, you could do so with a `Proxy` whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to [this example](https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads) in the Rust docs (NOTE: uses module expressions):\n\n```js\n// main.js\nimport { Thread } from \"./thread.js\";\nimport { MutexValue } from \"./mutex_value.js\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i < 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () => this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>If you wanted, for example, to implement something akin to Rust's <code>Mutex&lt;T&gt;</code>, you could do so with a <code>Proxy</code> whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to <a href=\"https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads\">this example</a> in the Rust docs (NOTE: uses module expressions):</p>\n<pre><code class=\"language-js\">// main.js\nimport { Thread } from \"./thread.js\";\nimport { MutexValue } from \"./mutex_value.js\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i &lt; 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () =&gt; this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"If you wanted, for example, to implement something akin to Rust's `Mutex<T>`, you could do so with a `Proxy` whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to [this example](https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads) in the Rust docs (NOTE: uses module expressions):\n\n```js\n// main.js\nimport { Thread } from \"./thread.js\";\nimport { MutexValue } from \"./mutex_value.js\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i < 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () => this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>If you wanted, for example, to implement something akin to Rust's <code>Mutex&lt;T&gt;</code>, you could do so with a <code>Proxy</code> whether it's an opaque WASM shared object or a JS native shared struct. Assuming we could have methods and private state in a JS struct, you could accomplish something similar to <a href=\"https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads\">this example</a> in the Rust docs (NOTE: uses module expressions):</p>\n<pre><code class=\"language-js\">// main.js\nimport { Thread } from \"./thread.js\";\nimport { MutexValue } from \"./mutex_value.js\";\n\nfunction main() {\n  const counter = new MutexValue(0);\n  const handles = [];\n\n  for (let i = 0; i &lt; 10; i++) {\n    const handle = new Thread(module {\n      import \"./mutex_value.js\"; // correlates prototype for MutexValue\n\n      export function threadStart(counter) {\n        using lck = counter.lock();\n        const num = lck.unwrap();\n\n        num.value += 1;\n      }\n\n    }, counter);\n\n    handles.push(handle);\n  }\n\n  for (const handle of handles) {\n    handle.join();\n  }\n\n  using lck = counter.lock();\n  const num = lck.unwrap();\n  console.log(`Result: ${num.value}`);\n}\n\n// thread.js\nshared struct ThreadState {\n  #mut = new Mutex();\n  #cv = new Condition();\n  #exited = false;\n\n  exit() unsafe {\n    using void = new UniqueLock(this.#mut);\n    this.#exited = true;\n    this.#cv.notify();\n  }\n\n  join() unsafe {\n    if (this.#exited) return;\n    using lck = new UniqueLock(this.#mut);\n    this.#cv.wait(lck, () =&gt; this.#exited);\n  }\n}\n\nexport class Thread {\n  #state;\n  #worker;\n  constructor(body, threadData) {\n    this.#state = new ThreadState();\n    this.#worker = new Worker(module {\n      import \"./thread.js\"; // correlates prototype for ThreadState\n      import { workerData } from \"node:worker_threads\";\n      import { threadStart } from body;\n\n      const [threadState, threadData] = workerData;\n      try {\n        threadStart(threadData);\n      }\n      finally {\n        threadState.exit();\n      }\n    }, { workerData: [this.#state, threadData] });\n  }\n\n  join() {\n    this.#state.join();\n  }\n}\n\n// mutex_value.js\nexport shared struct MutexValue {\n  static #Lock = class {\n    #stack;\n    #ref;\n\n    constructor(owner) unsafe {\n      using stack = new DisposableStack();\n      stack.use(new UniqueLock(owner.#mutex));\n      const { proxy, revoke } = Proxy.revocable({\n        get value() { return owner.#value; },\n        set value(v) { owner.#value = v; },\n      });\n      stack.defer(revoke);\n      this.#ref = proxy;\n      this.#stack = stack.move();\n    }\n\n    unwrap() {\n      if (this.#stack.disposed) throw new ReferenceError();\n      return this.#ref;\n    }\n\n    [Symbol.dispose]() {\n      using _ = this.#stack;\n    }\n  };\n\n  #mutex = new Mutex();\n  #value;\n\n  constructor(value) {\n    this.#value = value;\n  }\n\n  lock() unsafe {\n    return new MutexValue.#Lock(this);\n  }\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$WXhBDNBn6n1f7Jcbj0d6OMD70wRJLamqve_5J4RPM7I","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1717165795528,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eleXUetY_sTqUbUKY1UuQ1B4H6iN1g3_SvrQVkADR_M"},
{"content":{"body":"It's quite frustrating and feels counterproductive that, to pursue features like this, we have to resort to these frequent \"threats\" that it will come anyway. I wish we could focus on how the design should go, rather than whether it should be cancelled.","m.mentions":{},"msgtype":"m.text"},"ts":1717175651443,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Zfsjq8d29k73sdMhalter7S1kkAt16TbUaJ4LfRHkcU"},
{"content":{"body":"This style of discourse is a barrier to inclusion. E.g., for AsyncContext, it took years until people joined Chengzhong to talk through why it wasn't a fatally bad idea with respect to SES ideals.","m.mentions":{},"msgtype":"m.text"},"ts":1717175768188,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kMRyxue1nxEkDT6qYnbSP8s3T-QSthWj4Lmefg0Gi28"},
{"content":{"body":"Many us are spending work time on these projects, and this sort of opposition also makes it more difficult to justify spending time on these investments.","m.mentions":{},"msgtype":"m.text"},"ts":1717175854403,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Cg6mQGbR-RvxJWblLWQwPld40IVTmUKgyx1DXWCNuIs"},
{"content":{"body":"Of course we shouldn't add everything to JS, but somehow we need to be able to open the discussion, talk it through, and draw a conclusion, rather than rehashing the same concerns for years.","m.mentions":{},"msgtype":"m.text"},"ts":1717175938163,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$_0qlpzGsoCVy8txvuY19n8OpXXGsv0b18hsGdhtReWA"}
]