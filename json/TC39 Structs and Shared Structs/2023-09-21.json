[
{"content":{"body":"rbuckton: wrote up https://github.com/tc39/proposal-structs/blob/main/ATTACHING-BEHAVIOR.md, PTAL","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a>: wrote up https://github.com/tc39/proposal-structs/blob/main/ATTACHING-BEHAVIOR.md, PTAL","msgtype":"m.text"},"ts":1695258408162,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$MOstM0kjZX0JuIrYNSqXqcxKNNWH7TNRgxHIPxdTZxM"},
{"content":{"body":"A quick point regarding syntax, just as I mentioned before about wanting to avoid excess ceremony, I'm hoping we can go with something far shorter than `shared struct class Foo {}`. I imagine `struct Foo {}` and `shared struct Foo {}` would be sufficient to avoid ambiguity without needing the `class` keyword, and their behavior is different enough to justify the different syntax.","format":"org.matrix.custom.html","formatted_body":"A quick point regarding syntax, just as I mentioned before about wanting to avoid excess ceremony, I'm hoping we can go with something far shorter than <code>shared struct class Foo {}</code>. I imagine <code>struct Foo {}</code> and <code>shared struct Foo {}</code> would be sufficient to avoid ambiguity without needing the <code>class</code> keyword, and their behavior is different enough to justify the different syntax.","msgtype":"m.text"},"ts":1695259432016,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WsbyLESq-zsNlEAOLKAJDdDybjjl6OzgoyaIngJ6Zfw"},
{"content":{"body":"I'm also still not to keen on using class name as a global registry key, its far too easy to have collisions (so many things would be called `Node`, for example). I'd prefer the keying mechanism be divorced from the name of the struct somehow. In earlier discussions I'd recommended using UUIDs and decorators, i.e.:\n\n```\n@RegisteredStruct(\"92057993-84c2-4015-9a4e-f1d3810db4a2\") shared struct Foo { }\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>I'm also still not to keen on using class name as a global registry key, its far too easy to have collisions (so many things would be called <code>Node</code>, for example). I'd prefer the keying mechanism be divorced from the name of the struct somehow. In earlier discussions I'd recommended using UUIDs and decorators, i.e.:</p>\n<pre><code>@RegisteredStruct(\"92057993-84c2-4015-9a4e-f1d3810db4a2\") shared struct Foo { }\n</code></pre>\n","msgtype":"m.text"},"ts":1695259668370,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Mhs2bxoBdvBDgAvMFNwwXFWxU3dNCLXlk-DLRxZlaqY"},
{"content":{"body":"`shared struct com.bloomberg.ashleys.Node {}`","format":"org.matrix.custom.html","formatted_body":"`shared struct com.bloomberg.ashleys.Node {}`","msgtype":"m.text"},"ts":1695261971795,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$34yEekd_V-_wXl3_99ibdWNzx9xB0BW4R53bDeNn0MY"},
{"content":{"body":"> <@shuyuguo:matrix.org> shared structs don't have user code constructors\n> \n> (i now also see that the README.md is incorrect)\n\nIt could be nice if fields could still have initialisers of literal values `field = 0`","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24WvXsm1GTTbxzCwu7Pg9sG-s7b33pF52cb4L7OwZpAg4\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br>shared structs don't have user code constructors\n\n(i now also see that the README.md is incorrect)</blockquote></mx-reply>It could be nice if fields could still have initialisers of literal values `field = 0`","m.relates_to":{"m.in_reply_to":{"event_id":"$WvXsm1GTTbxzCwu7Pg9sG-s7b33pF52cb4L7OwZpAg4"}},"msgtype":"m.text"},"ts":1695262293031,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$pjv-K2DFHdsJD9RdzQcc4m09tMqDFQ_uXVtI1byVTMU"},
{"content":{"body":"Ashley Claymore: noted, good idea","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@aclaymore:matrix.org\">Ashley Claymore</a>: noted, good idea","msgtype":"m.text"},"ts":1695262994470,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$qupnNsEuLxZjsIEOkB4rdJwnziUKgyeQQoOhvwsgU6Q"},
{"content":{"body":"> <@rbuckton:matrix.org> A quick point regarding syntax, just as I mentioned before about wanting to avoid excess ceremony, I'm hoping we can go with something far shorter than `shared struct class Foo {}`. I imagine `struct Foo {}` and `shared struct Foo {}` would be sufficient to avoid ambiguity without needing the `class` keyword, and their behavior is different enough to justify the different syntax.\n\nalso agreed, consider the syntax a strawperson. i don't love the keyword soup","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$WsbyLESq-zsNlEAOLKAJDdDybjjl6OzgoyaIngJ6Zfw?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>A quick point regarding syntax, just as I mentioned before about wanting to avoid excess ceremony, I'm hoping we can go with something far shorter than <code>shared struct class Foo {}</code>. I imagine <code>struct Foo {}</code> and <code>shared struct Foo {}</code> would be sufficient to avoid ambiguity without needing the <code>class</code> keyword, and their behavior is different enough to justify the different syntax.</blockquote></mx-reply>also agreed, consider the syntax a strawperson. i don't love the keyword soup","m.relates_to":{"m.in_reply_to":{"event_id":"$WsbyLESq-zsNlEAOLKAJDdDybjjl6OzgoyaIngJ6Zfw"}},"msgtype":"m.text"},"ts":1695263030523,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$yOG33ya4RzWAOih3DOew6rk64iKRr_A7ZP6HYpcIHLU"},
{"content":{"body":"> <@rbuckton:matrix.org> I'm also still not to keen on using class name as a global registry key, its far too easy to have collisions (so many things would be called `Node`, for example). I'd prefer the keying mechanism be divorced from the name of the struct somehow. In earlier discussions I'd recommended using UUIDs and decorators, i.e.:\n> \n> ```\n> @RegisteredStruct(\"92057993-84c2-4015-9a4e-f1d3810db4a2\") shared struct Foo { }\n> ```\n\ni considered that, or a programmatic API to register shared structs. the issue is i'd prefer the registration to happen _during_ evaluation instead of _after_ for implementation complexity reasons. if it happens _after_, like with a @Register or a programmatic API, that means swapping out the guts of the constructor function, which i'd like to avoid","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$Mhs2bxoBdvBDgAvMFNwwXFWxU3dNCLXlk-DLRxZlaqY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>I'm also still not to keen on using class name as a global registry key, its far too easy to have collisions (so many things would be called <code>Node</code>, for example). I'd prefer the keying mechanism be divorced from the name of the struct somehow. In earlier discussions I'd recommended using UUIDs and decorators, i.e.:</p>\n<pre><code>@RegisteredStruct(\"92057993-84c2-4015-9a4e-f1d3810db4a2\") shared struct Foo { }\n</code></pre>\n</blockquote></mx-reply>i considered that, or a programmatic API to register shared structs. the issue is i'd prefer the registration to happen <em>during</em> evaluation instead of <em>after</em> for implementation complexity reasons. if it happens <em>after</em>, like with a @Register or a programmatic API, that means swapping out the guts of the constructor function, which i'd like to avoid","m.relates_to":{"m.in_reply_to":{"event_id":"$Mhs2bxoBdvBDgAvMFNwwXFWxU3dNCLXlk-DLRxZlaqY"}},"msgtype":"m.text"},"ts":1695263093297,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$flq_yp0MzyUGkWKeO6O0g_nBJMzritRTrxp8Df8HF6Q"},
{"content":{"body":"that's not a dealbreaker, just a preference","msgtype":"m.text"},"ts":1695263113017,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$0TJBSraoxxONPl3xMU13BvPVldgjJUKEC8i-5XjkTAQ"},
{"content":{"body":"but do the broad strokes look good to you?","msgtype":"m.text"},"ts":1695263173817,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$kN6CcU3nbYbye5_wJpw0o3upSJEt92elEjFhdUSfsls"},
{"content":{"body":"i... suppose the @RegisteredStruct decorator _could_ be implemented as applying during evaluation if it's some special built-in decorator that's not implementable by user code","format":"org.matrix.custom.html","formatted_body":"i... suppose the @RegisteredStruct decorator <em>could</em> be implemented as applying during evaluation if it's some special built-in decorator that's not implementable by user code","msgtype":"m.text"},"ts":1695263879239,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$79zs4jT3sO45aa6Qpftf8uVGcMTS8fI76ixIoqr7L4A"},
{"content":{"body":"nothing in the decorator proposal precludes built-in native code decorators AFAIK","msgtype":"m.text"},"ts":1695263904004,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$OWoRIXXzRzyHOEx_CAAFZUYwfx0m7IX_pfXTDqrtNvg"},
{"content":{"body":"I've long believed there's room for built-in decorators with privileged capabilities that a runtime might be able to optimize ahead of time. For example, built in `@enumerable(true|false)`, `@writable(true|false)`, `@configurable(true|false)` decorators that can affect property descriptors since the Stage 3 proposal no longer has this capability.","format":"org.matrix.custom.html","formatted_body":"I've long believed there's room for built-in decorators with privileged capabilities that a runtime might be able to optimize ahead of time. For example, built in <code>@enumerable(true|false)</code>, <code>@writable(true|false)</code>, <code>@configurable(true|false)</code> decorators that can affect property descriptors since the Stage 3 proposal no longer has this capability.","msgtype":"m.text"},"ts":1695264593766,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$b0rphL6I75mQBBi4NpXEl4uTUcw5IT6QdlLF2jQ9k6w"},
{"content":{"body":"Assuming they are trivially analyzable. ","msgtype":"m.text"},"ts":1695264643182,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$qMGSX1GKrhNCwTzAxh5sB4J5r8eNdJye5RVdHYxe-X8"},
{"content":{"body":"But an `@RegisterStruct` decorator has the opportunity to perform constructor replacement even without native code support, but I suppose in this case you're talking about it somehow patching the constructor to produce a `this` consistent with the registry during construction.","format":"org.matrix.custom.html","formatted_body":"But an <code>@RegisterStruct</code> decorator has the opportunity to perform constructor replacement even without native code support, but I suppose in this case you're talking about it somehow patching the constructor to produce a <code>this</code> consistent with the registry during construction.","msgtype":"m.text"},"ts":1695264815070,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TU-fBX1mkaVt857ArUUU3tkVKbE9i0pRdIMAjagk8GM"},
{"content":{"body":"> When evaluated, if the class name does not exist in the registry, insert a new entry whose key is the class name, and whose value is a description of the layout (i.e. order and names of instance fields, and whether the prototype is agent-local).\n> When evaluated, if the class name already exists in the registry, check if the layout exactly matches the current evaluation's layout. If not, throw.\n\n1) that doesn't explain what happens if the name exists and the layout matches (I guess the default is do nothing, aka first one wins)\n2) as I explained, any kind of simple agent wide registry keyed on string is a no go as it's effectively global mutable state that can be observed by the program (e.g. try to evaluate a shared struct definition with a new shape, see if it throws or not)","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>When evaluated, if the class name does not exist in the registry, insert a new entry whose key is the class name, and whose value is a description of the layout (i.e. order and names of instance fields, and whether the prototype is agent-local).<br>When evaluated, if the class name already exists in the registry, check if the layout exactly matches the current evaluation's layout. If not, throw.</p>\n</blockquote>\n<ol>\n<li>that doesn't explain what happens if the name exists and the layout matches (I guess the default is do nothing, aka first one wins)</li>\n<li>as I explained, any kind of simple agent wide registry keyed on string is a no go as it's effectively global mutable state that can be observed by the program (e.g. try to evaluate a shared struct definition with a new shape, see if it throws or not)</li>\n</ol>\n","msgtype":"m.text"},"ts":1695266948805,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$b5NWWKinKMFqSSFeQtzYyvmwa0uo7DRC_Sm9QCrm2y0"}
]