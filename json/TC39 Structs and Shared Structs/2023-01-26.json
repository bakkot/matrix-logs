[
{"content":{"body":"planned agenda for tomorrow's meeting:\n\n- method sharing and prototype lookup\n- property redefinition (and freezing)\n- R&T interaction","format":"org.matrix.custom.html","formatted_body":"<p>planned agenda for tomorrow's meeting:</p>\n<ul>\n<li>method sharing and prototype lookup</li>\n<li>property redefinition (and freezing)</li>\n<li>R&amp;T interaction</li>\n</ul>\n","msgtype":"m.text"},"ts":1674695879236,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$edqxvIrFY-27kiOBw-n-ZRsaQmQNBxG0yQ8WQRRBq3Y"},
{"content":{"body":" * planned agenda for tomorrow's meeting:\n\n- method sharing and prototype lookup\n- property redefinition (and freezing)\n- R&T interaction","format":"org.matrix.custom.html","formatted_body":" * <p>planned agenda for tomorrow's meeting:</p>\n<ul>\n<li>method sharing and prototype lookup</li>\n<li>property redefinition (and freezing)</li>\n<li>R&amp;T interaction</li>\n</ul>\n","m.new_content":{"body":"planned agenda for tomorrow's meeting:\n\n- method sharing and prototype lookup\n- property redefinition (and freezing)\n- R&T interaction","format":"org.matrix.custom.html","formatted_body":"<p>planned agenda for tomorrow's meeting:</p>\n<ul>\n<li>method sharing and prototype lookup</li>\n<li>property redefinition (and freezing)</li>\n<li>R&amp;T interaction</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$edqxvIrFY-27kiOBw-n-ZRsaQmQNBxG0yQ8WQRRBq3Y","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674695892086,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$HHLDw4Wa9YkElr8jliqmTot4hTvuFNpEW2WNlji0U5w"},
{"content":{"body":"Unfortunately I don't think I will be able to attend tomorrow due to a conflicting appointment. I don't have much to report, Wasm GC is moving towards getting a formal spec (& JS API spec) so if anything relevant comes out of that I'll report in future meetings.","msgtype":"m.text","org.matrix.msc1767.text":"Unfortunately I don't think I will be able to attend tomorrow due to a conflicting appointment. I don't have much to report, Wasm GC is moving towards getting a formal spec (& JS API spec) so if anything relevant comes out of that I'll report in future meetings."},"ts":1674696348362,"senderName":"asumu","senderId":"@atakikawa:igalia.com","id":"$V5a3Cyl3cA5g_XPu5iwApSIppttTISWg-qZwAojXvfc"},
{"content":{"body":"thanks asumu","msgtype":"m.text"},"ts":1674696532881,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$AskAZo7GA0x1ls2FQXqr2xumTkiHYQG1SXPMy8cWLGM"},
{"content":{"body":"> <@aclaymore:matrix.org> Also feel free to have at the original time next week (10am PT), I'm getting an earlier train than I would usually today :)\n\n^^ if missed before. Feel free to keep the 10am time, if that works better for asumu . My clash last week was not reoccurring ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24ZdyOO9CHwPEvcn90DKy6UkYyoFpwnlRHt1KspZkffZs\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br>Also feel free to have at the original time next week (10am PT), I'm getting an earlier train than I would usually today :)</blockquote></mx-reply>^^ if missed before. Feel free to keep the 10am time, if that works better for <a href=\"https://matrix.to/#/@atakikawa:igalia.com\">asumu</a> . My clash last week was not reoccurring","m.relates_to":{"m.in_reply_to":{"event_id":"$ZdyOO9CHwPEvcn90DKy6UkYyoFpwnlRHt1KspZkffZs"}},"msgtype":"m.text"},"ts":1674699258164,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$1520TNhKBFuPRtfPehZ_FMiqdOV1vhLekRN1YO0LoKk"},
{"content":{"body":"> <@shuyuguo:matrix.org> planned agenda for tomorrow's meeting:\n> \n> - method sharing and prototype lookup\n> - property redefinition (and freezing)\n> - R&T interaction\n\nI'm also curious if we can leverage `using` with Mutex/ConditionVariable, since that was one of the reasons I focused on getting that proposal to Stage 3.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$edqxvIrFY-27kiOBw-n-ZRsaQmQNBxG0yQ8WQRRBq3Y?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br><p>planned agenda for tomorrow's meeting:</p>\n<ul>\n<li>method sharing and prototype lookup</li>\n<li>property redefinition (and freezing)</li>\n<li>R&amp;T interaction</li>\n</ul>\n</blockquote></mx-reply>I'm also curious if we can leverage <code>using</code> with Mutex/ConditionVariable, since that was one of the reasons I focused on getting that proposal to Stage 3.","m.relates_to":{"m.in_reply_to":{"event_id":"$edqxvIrFY-27kiOBw-n-ZRsaQmQNBxG0yQ8WQRRBq3Y"}},"msgtype":"m.text"},"ts":1674748474449,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$f9_gyFZ8Jblx0rzzuPGoiQs_E87BqzbvedW4kTayS1E"},
{"content":{"body":"sure, sounds good","msgtype":"m.text"},"ts":1674751852388,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$nY0C9zSY6WIoXJuWgIuUdlWKs5hGxVpAeeO7Zz9QeaI"},
{"content":{"body":"Ashley Claymore: the call is now, btw","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@aclaymore:matrix.org\">Ashley Claymore</a>: the call is now, btw","msgtype":"m.text"},"ts":1674752669034,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$OXTrXIxNfrHpGS7rgPtw2SUOw8z0-J9EBAtlEFT1soI"},
{"content":{"body":"omw","msgtype":"m.text"},"ts":1674752707721,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$dAECJvNbgFjh78uCydTh4A_LFkjpy9XtiONBTy2JySo"},
{"content":{"body":"sorry, actually 1 min","msgtype":"m.text"},"ts":1674752724982,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$isjMeihj9FFWjxx5kGt1wZZwNwsZNFfi-jrAzTX9pJI"},
{"content":{"body":"np","msgtype":"m.text"},"ts":1674752729556,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ODy7zU_yUM8HMumWhun5PoQ1muNfBk4_yB692gtJSZQ"},
{"content":{"body":"Regarding the \"shared modules\" suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.\n\nIf we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?\n\nIf we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into `globalThis`.\n\nIf we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level `await` or must otherwise be loaded asynchronously?\n\nHow and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?\n\nThe leap in logic I took to the \"shared module\" approach was to address these concerns:\n\n- \"Shared modules\" would have an identity in the module cache that could be used as part of the type identity.\n- \"Shared modules\" would promote code reuse.\n- \"Shared modules\" would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other \"shared modules\".\n- Due to the nature of the above restrictions, \"shared modules\" avoid accidental references to non-shared code.\n\nIt could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like `protobuf` today (i.e., maintaining their `protobuf` schema in a separate file).","format":"org.matrix.custom.html","formatted_body":"<p>Regarding the &quot;shared modules&quot; suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.</p>\n<p>If we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?</p>\n<p>If we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into <code>globalThis</code>.</p>\n<p>If we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level <code>await</code> or must otherwise be loaded asynchronously?</p>\n<p>How and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?</p>\n<p>The leap in logic I took to the &quot;shared module&quot; approach was to address these concerns:</p>\n<ul>\n<li>&quot;Shared modules&quot; would have an identity in the module cache that could be used as part of the type identity.</li>\n<li>&quot;Shared modules&quot; would promote code reuse.</li>\n<li>&quot;Shared modules&quot; would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other &quot;shared modules&quot;.</li>\n<li>Due to the nature of the above restrictions, &quot;shared modules&quot; avoid accidental references to non-shared code.</li>\n</ul>\n<p>It could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like <code>protobuf</code> today (i.e., maintaining their <code>protobuf</code> schema in a separate file).</p>\n","msgtype":"m.text"},"ts":1674758356884,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jFKUTlSFnP36Vc3plhvThBlWIrx5A_1y3apcWuDEhRg"},
{"content":{"body":" * Regarding the \"shared modules\" suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.\n\nIf we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?\n\nIf we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into `globalThis`.\n\nIf we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level `await` or must otherwise be loaded asynchronously?\n\nHow and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?\n\nThe leap in logic I took to the \"shared module\" approach was to address these concerns:\n\n- \"Shared modules\" would have an identity in the module cache that could be used as part of the type identity.\n- \"Shared modules\" would promote code reuse.\n- \"Shared modules\" would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other \"shared modules\".\n- Due to the nature of the above restrictions, \"shared modules\" avoid accidental references to non-shared code.\n\nIt could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like `protobuf` today (i.e., maintaining their `protobuf` schema in a separate file).","format":"org.matrix.custom.html","formatted_body":" * <p>Regarding the &quot;shared modules&quot; suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.</p>\n<p>If we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?</p>\n<p>If we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into <code>globalThis</code>.</p>\n<p>If we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level <code>await</code> or must otherwise be loaded asynchronously?</p>\n<p>How and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?</p>\n<p>The leap in logic I took to the &quot;shared module&quot; approach was to address these concerns:</p>\n<ul>\n<li>&quot;Shared modules&quot; would have an identity in the module cache that could be used as part of the type identity.</li>\n<li>&quot;Shared modules&quot; would promote code reuse.</li>\n<li>&quot;Shared modules&quot; would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other &quot;shared modules&quot;.</li>\n<li>Due to the nature of the above restrictions, &quot;shared modules&quot; avoid accidental references to non-shared code.</li>\n</ul>\n<p>It could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like <code>protobuf</code> today (i.e., maintaining their <code>protobuf</code> schema in a separate file).</p>\n","m.new_content":{"body":"Regarding the \"shared modules\" suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.\n\nIf we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?\n\nIf we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into `globalThis`.\n\nIf we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level `await` or must otherwise be loaded asynchronously?\n\nHow and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?\n\nThe leap in logic I took to the \"shared module\" approach was to address these concerns:\n\n- \"Shared modules\" would have an identity in the module cache that could be used as part of the type identity.\n- \"Shared modules\" would promote code reuse.\n- \"Shared modules\" would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other \"shared modules\".\n- Due to the nature of the above restrictions, \"shared modules\" avoid accidental references to non-shared code.\n\nIt could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like `protobuf` today (i.e., maintaining their `protobuf` schema in a separate file).","format":"org.matrix.custom.html","formatted_body":"<p>Regarding the &quot;shared modules&quot; suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.</p>\n<p>If we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?</p>\n<p>If we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into <code>globalThis</code>.</p>\n<p>If we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level <code>await</code> or must otherwise be loaded asynchronously?</p>\n<p>How and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?</p>\n<p>The leap in logic I took to the &quot;shared module&quot; approach was to address these concerns:</p>\n<ul>\n<li>&quot;Shared modules&quot; would have an identity in the module cache that could be used as part of the type identity.</li>\n<li>&quot;Shared modules&quot; would promote code reuse.</li>\n<li>&quot;Shared modules&quot; would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other &quot;shared modules&quot;.</li>\n<li>Due to the nature of the above restrictions, &quot;shared modules&quot; avoid accidental references to non-shared code.</li>\n</ul>\n<p>It could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like <code>protobuf</code> today (i.e., maintaining their <code>protobuf</code> schema in a separate file).</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$jFKUTlSFnP36Vc3plhvThBlWIrx5A_1y3apcWuDEhRg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674758388569,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dXSU_4dpDgLZEqIKtzVKXr1n-UqT0hFvh3WIcz0FLgw"},
{"content":{"body":" * Regarding the \"shared modules\" suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.\n\nIf we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?\n\nIf we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into `globalThis`.\n\nIf we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level `await` or must otherwise be loaded asynchronously?\n\nHow and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?\n\nThe leap in logic I took to the \"shared module\" approach was to address these concerns.\n\n- \"Shared modules\" would have an identity in the module cache that could be used as part of the type identity.\n- \"Shared modules\" would promote code reuse.\n- \"Shared modules\" would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other \"shared modules\".\n- Due to the nature of the above restrictions, \"shared modules\" avoid accidental references to non-shared code.\n\nIt could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like `protobuf` today (i.e., maintaining their `protobuf` schema in a separate file).","format":"org.matrix.custom.html","formatted_body":" * <p>Regarding the &quot;shared modules&quot; suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.</p>\n<p>If we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?</p>\n<p>If we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into <code>globalThis</code>.</p>\n<p>If we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level <code>await</code> or must otherwise be loaded asynchronously?</p>\n<p>How and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?</p>\n<p>The leap in logic I took to the &quot;shared module&quot; approach was to address these concerns.</p>\n<ul>\n<li>&quot;Shared modules&quot; would have an identity in the module cache that could be used as part of the type identity.</li>\n<li>&quot;Shared modules&quot; would promote code reuse.</li>\n<li>&quot;Shared modules&quot; would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other &quot;shared modules&quot;.</li>\n<li>Due to the nature of the above restrictions, &quot;shared modules&quot; avoid accidental references to non-shared code.</li>\n</ul>\n<p>It could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like <code>protobuf</code> today (i.e., maintaining their <code>protobuf</code> schema in a separate file).</p>\n","m.new_content":{"body":"Regarding the \"shared modules\" suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.\n\nIf we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?\n\nIf we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into `globalThis`.\n\nIf we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level `await` or must otherwise be loaded asynchronously?\n\nHow and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?\n\nThe leap in logic I took to the \"shared module\" approach was to address these concerns.\n\n- \"Shared modules\" would have an identity in the module cache that could be used as part of the type identity.\n- \"Shared modules\" would promote code reuse.\n- \"Shared modules\" would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other \"shared modules\".\n- Due to the nature of the above restrictions, \"shared modules\" avoid accidental references to non-shared code.\n\nIt could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like `protobuf` today (i.e., maintaining their `protobuf` schema in a separate file).","format":"org.matrix.custom.html","formatted_body":"<p>Regarding the &quot;shared modules&quot; suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.</p>\n<p>If we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?</p>\n<p>If we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into <code>globalThis</code>.</p>\n<p>If we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level <code>await</code> or must otherwise be loaded asynchronously?</p>\n<p>How and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?</p>\n<p>The leap in logic I took to the &quot;shared module&quot; approach was to address these concerns.</p>\n<ul>\n<li>&quot;Shared modules&quot; would have an identity in the module cache that could be used as part of the type identity.</li>\n<li>&quot;Shared modules&quot; would promote code reuse.</li>\n<li>&quot;Shared modules&quot; would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other &quot;shared modules&quot;.</li>\n<li>Due to the nature of the above restrictions, &quot;shared modules&quot; avoid accidental references to non-shared code.</li>\n</ul>\n<p>It could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like <code>protobuf</code> today (i.e., maintaining their <code>protobuf</code> schema in a separate file).</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$jFKUTlSFnP36Vc3plhvThBlWIrx5A_1y3apcWuDEhRg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674758426368,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$GeBRyMJByX-F_Jsy-mtTgiIgEi8JPCIMvbf3DUPKQKk"},
{"content":{"body":"My answer to this closing over/loading question was, the other side which receives the object has three options for handling module loading:\n- The receiving side already expected that the object would come, so the module where the shared struct is defined has already been loaded, and the receiving module can start using it immediately.\n- [I honestly can't think of a use case for this, but ] The receiving side sets itself up to handle objects dynamically, so it queries the object it received for the module specifier, `await import()`s that, and then can use the methods.\n- The receiving side just wants to use the plain old data, and can do so without importing anything.\n\nIn all cases, there are no particular restrictions in what is closed over (just by construction because we do this whole dance per module map). And there just is no such thing as shared code, no limitations on mutating the local copy of the shared classes, or on TLA (because no synchronous module loading is ever used, just normal async). It does depend on one or other type of identity (which could be URL, or module block, or symbol if we have a global mapping).\n\nWhat do you see as the downsides of this option?","format":"org.matrix.custom.html","formatted_body":"<p>My answer to this closing over/loading question was, the other side which receives the object has three options for handling module loading:</p>\n<ul>\n<li>The receiving side already expected that the object would come, so the module where the shared struct is defined has already been loaded, and the receiving module can start using it immediately.</li>\n<li>[I honestly can't think of a use case for this, but ] The receiving side sets itself up to handle objects dynamically, so it queries the object it received for the module specifier, <code>await import()</code>s that, and then can use the methods.</li>\n<li>The receiving side just wants to use the plain old data, and can do so without importing anything.</li>\n</ul>\n<p>In all cases, there are no particular restrictions in what is closed over (just by construction because we do this whole dance per module map). And there just is no such thing as shared code, no limitations on mutating the local copy of the shared classes, or on TLA (because no synchronous module loading is ever used, just normal async). It does depend on one or other type of identity (which could be URL, or module block, or symbol if we have a global mapping).</p>\n<p>What do you see as the downsides of this option?</p>\n","msgtype":"m.text"},"ts":1674759146457,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw"},
{"content":{"body":"> What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.?\n\nI don't have a solution to this; I was assuming that you could somehow bake this into the module.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.?</p>\n</blockquote>\n<p>I don't have a solution to this; I was assuming that you could somehow bake this into the module.</p>\n","msgtype":"m.text"},"ts":1674759183871,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$c6EPmWunn89x24E3HDGFqXSG5MbRQ58ZMWiPkotdirw"},
{"content":{"body":"(which doesn't mean necessarily bundling all recursive dependencies! it can have `import` statements like normal.)","format":"org.matrix.custom.html","formatted_body":"(which doesn't mean necessarily bundling all recursive dependencies! it can have <code>import</code> statements like normal.)","msgtype":"m.text"},"ts":1674759208662,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$d_58i7k3NJ2dImuedGzWiPLZrlW7Xron_N4-_TGTGKk"},
{"content":{"body":"I honestly don't understand how \"shared modules\" would work in detail--how they would differ from this, beyond being a subset requiring only recursive use of shared modules","msgtype":"m.text"},"ts":1674759430628,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$pneq89lelgA8yzEJjn8BQ-0JKGw2O3c2tp61Pt-YBlo"},
{"content":{"body":"> The receiving side already expected that the object would come, so the module where the shared struct is defined has already been loaded, and the receiving module can start using it immediately.\n\nThis is probably reasonable, as long as you can reliably correlate a shared struct type in both realms by module id and export name. However, that would potentially restrict shared struct definitions to only be at the top level of a _Module_, since returning them from a function call might not necessarily result in the same identity being valid.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>The receiving side already expected that the object would come, so the module where the shared struct is defined has already been loaded, and the receiving module can start using it immediately.</p>\n</blockquote>\n<p>This is probably reasonable, as long as you can reliably correlate a shared struct type in both realms by module id and export name. However, that would potentially restrict shared struct definitions to only be at the top level of a <em>Module</em>, since returning them from a function call might not necessarily result in the same identity being valid.</p>\n","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674762812432,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$f7tSyxbxpcT8JgNgBRyb2eBy1QdgJ-p4G_mQqFHfVzc"},
{"content":{"body":"> [I honestly can't think of a use case for this, but ] The receiving side sets itself up to handle objects dynamically, so it queries the object it received for the module specifier, await import()s that, and then can use the methods.\n\nThis seems like a poor developer experience. ","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>[I honestly can't think of a use case for this, but ] The receiving side sets itself up to handle objects dynamically, so it queries the object it received for the module specifier, await import()s that, and then can use the methods.</p>\n</blockquote>\n<p>This seems like a poor developer experience.</p>\n","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$f7tSyxbxpcT8JgNgBRyb2eBy1QdgJ-p4G_mQqFHfVzc"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674762851635,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ER1AgZJJmtiFXlxg8hQpIKJq3PUj1lm2yowFDeaMhVY"},
{"content":{"body":"The \"shared module\" I was imagining would be fairly restrictive so as to have the declarations only really be resident in memory once, and not reparsed/linked/evaluated per-realm. No per-realm initialization, variables limited to constant, primitive values (and trivially reduceable expressions containing primitives), only top-level declarations: structs, functions, vars, imports/exports, maybe enums (if we can find a version of that proposal that might be accepted).\nSuch a module could be accessed via module id, and reachable from any worker/realm. Evaluating functions/methods/constructors/etc. from a \"shared module\" would use the current realm.\nStruct type identity would be trivially resolvable via _module id_+_export name_, producing the correct prototype in each realm.","format":"org.matrix.custom.html","formatted_body":"The &quot;shared module&quot; I was imagining would be fairly restrictive so as to have the declarations only really be resident in memory once, and not reparsed/linked/evaluated per-realm. No per-realm initialization, variables limited to constant, primitive values (and trivially reduceable expressions containing primitives), only top-level declarations: structs, functions, vars, imports/exports, maybe enums (if we can find a version of that proposal that might be accepted).<br>Such a module could be accessed via module id, and reachable from any worker/realm. Evaluating functions/methods/constructors/etc. from a &quot;shared module&quot; would use the current realm.<br>Struct type identity would be trivially resolvable via <em>module id</em>+<em>export name</em>, producing the correct prototype in each realm.","msgtype":"m.text"},"ts":1674763472903,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aAB7F7svFxpRCyvd9DN7diHXlDWekqXX_hGapflkQ9Q"},
{"content":{"body":"A fourth approach, which I'm trying to enable with this design, is that the receiving end doesn't need to worry about running code to support the struct since its easily reachable.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$ER1AgZJJmtiFXlxg8hQpIKJq3PUj1lm2yowFDeaMhVY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674763557709,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cbLoOopalwaSSs4KDZyK_NC5eCUPwVKNR6Ch7uUSjtk"},
{"content":{"body":"Yes, the setup is more restrictive due to the limitations imposed by a \"shared module\", but it also avoids many pitfalls like developers inadvertently depending on thread-local or realm-local state in shared code. The benefit being that _consuming_ shared structs is simple and intuitive. You just send the value via `postMessage` and can use it immediately in the worker without any added fuss.","format":"org.matrix.custom.html","formatted_body":"Yes, the setup is more restrictive due to the limitations imposed by a &quot;shared module&quot;, but it also avoids many pitfalls like developers inadvertently depending on thread-local or realm-local state in shared code. The benefit being that <em>consuming</em> shared structs is simple and intuitive. You just send the value via <code>postMessage</code> and can use it immediately in the worker without any added fuss.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$cbLoOopalwaSSs4KDZyK_NC5eCUPwVKNR6Ch7uUSjtk"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674763804496,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CwZWtEW8gYVi0t7FaD1mxcv0vhUXd4GjQJDr8xHAyG0"},
{"content":{"body":"OK, so this is trying to solve the stronger version of the problem that you explained","msgtype":"m.text"},"ts":1674763925182,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$IK5yC_rMypUMMeFOPL8W--7ilXzKJmR48WOHrWQG5Vk"},
{"content":{"body":"> <@rbuckton:matrix.org> This is probably reasonable, as long as you can reliably correlate a shared struct type in both realms by module id and export name. However, that would potentially restrict shared struct definitions to only be at the top level of a _Module_, since returning them from a function call might not necessarily result in the same identity being valid.\n\nYes, shared structs which define methods that are supposed to be accessible from other agents need to be defined at the top level of a module. I agree that this is a singificant restriction.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$f7tSyxbxpcT8JgNgBRyb2eBy1QdgJ-p4G_mQqFHfVzc?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><blockquote>\n<p>The receiving side already expected that the object would come, so the module where the shared struct is defined has already been loaded, and the receiving module can start using it immediately.</p>\n</blockquote>\n<p>This is probably reasonable, as long as you can reliably correlate a shared struct type in both realms by module id and export name. However, that would potentially restrict shared struct definitions to only be at the top level of a <em>Module</em>, since returning them from a function call might not necessarily result in the same identity being valid.</p>\n</blockquote></mx-reply>Yes, shared structs which define methods that are supposed to be accessible from other agents need to be defined at the top level of a module. I agree that this is a singificant restriction.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":false,"m.in_reply_to":{"event_id":"$f7tSyxbxpcT8JgNgBRyb2eBy1QdgJ-p4G_mQqFHfVzc"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674763989999,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$vNeq8SLAphrJWHW2oF7HWiKK-H3VEStBihWDjC-H7Lw"},
{"content":{"body":"> <@rbuckton:matrix.org> This seems like a poor developer experience.\n\nIt's hard for me to evaluate how bad it is without understanding the use cases for this scenario.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$ER1AgZJJmtiFXlxg8hQpIKJq3PUj1lm2yowFDeaMhVY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><blockquote>\n<p>[I honestly can't think of a use case for this, but ] The receiving side sets itself up to handle objects dynamically, so it queries the object it received for the module specifier, await import()s that, and then can use the methods.</p>\n</blockquote>\n<p>This seems like a poor developer experience.</p>\n</blockquote></mx-reply>It's hard for me to evaluate how bad it is without understanding the use cases for this scenario.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":false,"m.in_reply_to":{"event_id":"$ER1AgZJJmtiFXlxg8hQpIKJq3PUj1lm2yowFDeaMhVY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764018472,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$sLR4LnhTu9oKHrRxmIqoeiajq1RuGt2cxe4hzFOZqCw"},
{"content":{"body":"Yes. It's trying to impose restrictions on what a shared struct can reference so as to make the rest of the system simple and intuitive.","msgtype":"m.text"},"ts":1674764019686,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$scxVFL9siegcalr4jIlEH7ltSonkP7JiAX4AZVrJOyA"},
{"content":{"body":"I just can't construct the scenario in my head where it wouldn't be natural to directly import the module defining the shared struct, when you expect to receive it in postMessage","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$sLR4LnhTu9oKHrRxmIqoeiajq1RuGt2cxe4hzFOZqCw"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764077267,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$vskWPP2_XdbAr9YAGpsFwabbrYEVOYzj8SFQix4TrFc"},
{"content":{"body":"I came at this from the perspective of: \"Lets say we wanted to implement `Number` as a shared struct, from the ground up, what would we need to do?\" (excl. operator overloading)","format":"org.matrix.custom.html","formatted_body":"I came at this from the perspective of: &quot;Lets say we wanted to implement <code>Number</code> as a shared struct, from the ground up, what would we need to do?&quot; (excl. operator overloading)","msgtype":"m.text"},"ts":1674764136735,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$D0k4QFK1xDjV-PXMvzszJbzNIwghhU6ypUdO-HiDM1M"},
{"content":{"body":"Would you want everyone to need to write `import \"std:number\";` in their module to receive a number via `postMessage`?","format":"org.matrix.custom.html","formatted_body":"Would you want everyone to need to write <code>import &quot;std:number&quot;;</code> in their module to receive a number via <code>postMessage</code>?","msgtype":"m.text"},"ts":1674764192406,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9pA6gj0w3ESPJ7hzREyfIiP7uqG5DQPkE6yNKfCqJn0"},
{"content":{"body":" * Would you want everyone to need to write `import \"std:number\";` in their module to receive a number via `postMessage`?","format":"org.matrix.custom.html","formatted_body":" * Would you want everyone to need to write <code>import &quot;std:number&quot;;</code> in their module to receive a number via <code>postMessage</code>?","m.new_content":{"body":"Would you want everyone to need to write `import \"std:number\";` in their module to receive a number via `postMessage`?","format":"org.matrix.custom.html","formatted_body":"Would you want everyone to need to write <code>import &quot;std:number&quot;;</code> in their module to receive a number via <code>postMessage</code>?","msgtype":"m.text"},"m.relates_to":{"event_id":"$9pA6gj0w3ESPJ7hzREyfIiP7uqG5DQPkE6yNKfCqJn0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674764200112,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$awyvf4KFFQ28FXgykf4Am3ooKdRbLMd8o2FSrMJ3zP8"},
{"content":{"body":"While that's an interesting lens, I like to think of those things being in an implicit \"prelude\". (The same logic applies for the operator overloading usage declarations, for example)","msgtype":"m.text"},"ts":1674764249256,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$GlLG_10O---ELgAsTED7wjix7jK-R5om_G5gbW4iqGU"},
{"content":{"body":"so I guess I would go for, \"let's see if we can implement `Number` *except* for that specific import statement\"","format":"org.matrix.custom.html","formatted_body":"so I guess I would go for, &quot;let's see if we can implement <code>Number</code> <em>except</em> for that specific import statement&quot;","msgtype":"m.text"},"ts":1674764282685,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$mbq3sKTDkxTDGYn5DZcH6djMWJxTKJ4AKGgd75dDuSk"},
{"content":{"body":"You'd need to use a side-effecting `import \"structModule\"` if you never access the constructor yourself, otherwise minifiers will tree shake it away.","format":"org.matrix.custom.html","formatted_body":"You'd need to use a side-effecting <code>import &quot;structModule&quot;</code> if you never access the constructor yourself, otherwise minifiers will tree shake it away.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$vskWPP2_XdbAr9YAGpsFwabbrYEVOYzj8SFQix4TrFc"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764284414,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vUN7uIq_PQaNS-sGq0X0pryDZVJ-rrCUwRYuazGs5V8"},
{"content":{"body":"Which just adds one more source of potential confusion when things don't work in your bundled, minified release build.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$vUN7uIq_PQaNS-sGq0X0pryDZVJ-rrCUwRYuazGs5V8"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764362280,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fSsX4vr2bmx9E3JiOfUHOHj8MG2gRLCnBJbsmEZMhfU"},
{"content":{"body":"Ah, I hadn't really considered tree shaking","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$fSsX4vr2bmx9E3JiOfUHOHj8MG2gRLCnBJbsmEZMhfU"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764374191,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$nTy-_6RV3sPyw4DcSxR5BqimLBAy0r4B4-vvQ92pS58"},
{"content":{"body":"are there any other problems that come to mind for you besides tree shaking?","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$nTy-_6RV3sPyw4DcSxR5BqimLBAy0r4B4-vvQ92pS58"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764481780,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$5ZqXM6iK5S_NZgzR-AguPhynbz95LMZuD1Mm8Hx_qHo"},
{"content":{"body":"As I mentioned in the thread above, depending on an `import` is one more shaky foundation to build on that is a potential pit of failure for developers. A tree shaking minifier might remove the `import`, or would need to perform additional static analysis to know whether its actually safe to remove the import.","format":"org.matrix.custom.html","formatted_body":"As I mentioned in the thread above, depending on an <code>import</code> is one more shaky foundation to build on that is a potential pit of failure for developers. A tree shaking minifier might remove the <code>import</code>, or would need to perform additional static analysis to know whether its actually safe to remove the import.","msgtype":"m.text"},"ts":1674764500762,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$N4aqvovzEeGEyz-k5BiEnySaUM91BAlIufmnhWfFrtQ"},
{"content":{"body":"I mean, I think we could teach tree shakers this particular thing: You can't just eliminate running an export of a shared struct, since executing that has a side effect. (We'd have to teach the tree shaker about that syntactic construct anyway!)","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$5ZqXM6iK5S_NZgzR-AguPhynbz95LMZuD1Mm8Hx_qHo"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764546646,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$jsdefpGy49VIVQYOzYrhjfCho0rvZhPmdcqCamXswN4"},
{"content":{"body":"OK, thanks for explaining; I hadn't considered that","msgtype":"m.text"},"ts":1674764599710,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$OLM5Tc6AiA51u152gowIkj0F1SYRHOzz9T1sp39aZd4"},
{"content":{"body":"- Remembering to include the `import`\n- The main process changing the data it sends to the worker (depending on how the app is structured)\n- Middleware that might run before application code is loaded.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>Remembering to include the <code>import</code></li>\n<li>The main process changing the data it sends to the worker (depending on how the app is structured)</li>\n<li>Middleware that might run before application code is loaded.</li>\n</ul>\n","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$jsdefpGy49VIVQYOzYrhjfCho0rvZhPmdcqCamXswN4"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764612353,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aFfdE8F5gDp5BxdWQ9ApJ_LgOyWec4H2q30TQk4JlyY"},
{"content":{"body":"Its not the tree shaking of the `export`, its the tree shaking of the `import`. That requires looking across files to say \"oh, this `import` is from a module that transitively imports a module containing a shared struct that I might potentially receive\", which is far more complicated.","format":"org.matrix.custom.html","formatted_body":"Its not the tree shaking of the <code>export</code>, its the tree shaking of the <code>import</code>. That requires looking across files to say &quot;oh, this <code>import</code> is from a module that transitively imports a module containing a shared struct that I might potentially receive&quot;, which is far more complicated.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$aFfdE8F5gDp5BxdWQ9ApJ_LgOyWec4H2q30TQk4JlyY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764694248,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NTNFYu0Zse9Sf6krXs-t9AxK7VEgT4rRMU1E0_PMN78"},
{"content":{"body":"> <@rbuckton:matrix.org> Its not the tree shaking of the `export`, its the tree shaking of the `import`. That requires looking across files to say \"oh, this `import` is from a module that transitively imports a module containing a shared struct that I might potentially receive\", which is far more complicated.\n\noh, I guess I assumed that this was normal stuff for tree shakers","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$NTNFYu0Zse9Sf6krXs-t9AxK7VEgT4rRMU1E0_PMN78?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Its not the tree shaking of the <code>export</code>, its the tree shaking of the <code>import</code>. That requires looking across files to say \"oh, this <code>import</code> is from a module that transitively imports a module containing a shared struct that I might potentially receive\", which is far more complicated.</blockquote></mx-reply>oh, I guess I assumed that this was normal stuff for tree shakers","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":false,"m.in_reply_to":{"event_id":"$NTNFYu0Zse9Sf6krXs-t9AxK7VEgT4rRMU1E0_PMN78"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764732784,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$CXfeaW2ple8po14o63NG_rTNCqVEk9efWNYWg6-yZGs"},
{"content":{"body":"that a module execution may be known to have a side effect and that that shouldn't be removed","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$CXfeaW2ple8po14o63NG_rTNCqVEk9efWNYWg6-yZGs"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764753602,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$CJ4RZXoJhhQr_8J44xyGo39xFVkmI9UQVJYny28FXFA"},
{"content":{"body":"If your app/package contains a single shared struct definition, imports becomes un-tree-shakable.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$CJ4RZXoJhhQr_8J44xyGo39xFVkmI9UQVJYny28FXFA"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764757065,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RxYgPxV_BDRPwA3miUnIJH44op17KPPTyAly02e1ILU"},
{"content":{"body":"right","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$RxYgPxV_BDRPwA3miUnIJH44op17KPPTyAly02e1ILU"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764764614,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$MuceJtgrXpisJoqgVEjrrRPa99lXfKJsQXGOaQ81OCE"},
{"content":{"body":"if this is an issue you could break up the module","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$MuceJtgrXpisJoqgVEjrrRPa99lXfKJsQXGOaQ81OCE"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764800538,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$twji1Z8x4_Znvme8qn0kUGdS5InP71njLjdbmOe1Z-A"},
{"content":{"body":"That seems bad.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$MuceJtgrXpisJoqgVEjrrRPa99lXfKJsQXGOaQ81OCE"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764806841,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NmsHcbgmzS41gs3LUh_PLbOs4FYXYd2et_sEklU7ZKY"},
{"content":{"body":"> <@littledan:matrix.org> if this is an issue you could break up the module\n\nWhich is basically what a \"shared module\" enforces.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$twji1Z8x4_Znvme8qn0kUGdS5InP71njLjdbmOe1Z-A?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br>if this is an issue you could break up the module</blockquote></mx-reply>Which is basically what a &quot;shared module&quot; enforces.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":false,"m.in_reply_to":{"event_id":"$twji1Z8x4_Znvme8qn0kUGdS5InP71njLjdbmOe1Z-A"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764830284,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZiawIjXc8eas9A0eiMT38ewneq0UDa2aoqnnnNscmpw"},
{"content":{"body":"> <@rbuckton:matrix.org> - Remembering to include the `import`\n> - The main process changing the data it sends to the worker (depending on how the app is structured)\n> - Middleware that might run before application code is loaded.\n\nOK, I guess the badness of that, together with the badness of this comment I'm replying to, is something which I don't have sufficient intuition into.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$aFfdE8F5gDp5BxdWQ9ApJ_LgOyWec4H2q30TQk4JlyY?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><ul>\n<li>Remembering to include the <code>import</code></li>\n<li>The main process changing the data it sends to the worker (depending on how the app is structured)</li>\n<li>Middleware that might run before application code is loaded.</li>\n</ul>\n</blockquote></mx-reply>OK, I guess the badness of that, together with the badness of this comment I'm replying to, is something which I don't have sufficient intuition into.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":false,"m.in_reply_to":{"event_id":"$aFfdE8F5gDp5BxdWQ9ApJ_LgOyWec4H2q30TQk4JlyY"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764844082,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$lVsmOin0wVgC7QZm1xyGBf1zCY63AxNFLuPK4BGWq38"},
{"content":{"body":"or sufficient practical experience of the negative consequences","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$lVsmOin0wVgC7QZm1xyGBf1zCY63AxNFLuPK4BGWq38"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764854513,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hx1wSNmIPzyNJwiEE8KL55X7jckrz9OL-GrvDaQE2Ag"},
{"content":{"body":"Due to their restrictions, \"shared modules\" have no Evaluation step when the module is loaded. Dependency order becomes far less important (excluding decorators, which I'd have to think more on), so you could just surface the shared module imports in place of whatever other import you might have used that was otherwise removed.","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$hx1wSNmIPzyNJwiEE8KL55X7jckrz9OL-GrvDaQE2Ag"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674764953733,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FxHoKYMsXzjQRCDEMH8LWzk1yVnpUIq430CxVfCt6kg"},
{"content":{"body":"computed property names also do stuff when evaluated, as do, you know, the RHS of an `export const`... I'm pretty skeptical that it'd be practical to articulate a usable-enough subset of JS which doesn't have side effects when loaded. This would be very useful if possible, of course! It'd handle the lazy module loading issue","format":"org.matrix.custom.html","formatted_body":"computed property names also do stuff when evaluated, as do, you know, the RHS of an <code>export const</code>... I'm pretty skeptical that it'd be practical to articulate a usable-enough subset of JS which doesn't have side effects when loaded. This would be very useful if possible, of course! It'd handle the lazy module loading issue","m.relates_to":{"event_id":"$XFWPWTT0CuMxNh7WJS82zS57oFfpPjsTs6uQRb8S4Sw","is_falling_back":true,"m.in_reply_to":{"event_id":"$FxHoKYMsXzjQRCDEMH8LWzk1yVnpUIq430CxVfCt6kg"},"rel_type":"m.thread"},"msgtype":"m.text"},"ts":1674765863311,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$9Z16I6x2xq-T76jNWyfjfz_YroOUmeJEJ_Y-Ajcxud4"},
{"content":{"body":"unrelated sidebar: matrix has threads??","msgtype":"m.text"},"ts":1674774287631,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$eIKr9LPwCx4sU6zMNGhTGcMUV7lDgyPfi0NLveOTcOk"},
{"content":{"body":"is this a new feature?","msgtype":"m.text"},"ts":1674774289620,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$BqbHWKOT9EbTDxn98N07YWYRE5m_JRLum7VucU5ZGa8"},
{"content":{"body":"i was wondering why it was showing the channel as having 25 unread messages until i found the thread above","msgtype":"m.text"},"ts":1674774304960,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$QyOAUwAprQLHiB4kTNunyk8uNJG9xwRq67QCCWNVVAw"}
]