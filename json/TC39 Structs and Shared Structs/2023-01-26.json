[
{"content":{"body":"planned agenda for tomorrow's meeting:\n\n- method sharing and prototype lookup\n- property redefinition (and freezing)\n- R&T interaction","format":"org.matrix.custom.html","formatted_body":"<p>planned agenda for tomorrow's meeting:</p>\n<ul>\n<li>method sharing and prototype lookup</li>\n<li>property redefinition (and freezing)</li>\n<li>R&amp;T interaction</li>\n</ul>\n","msgtype":"m.text"},"ts":1674695879236,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$edqxvIrFY-27kiOBw-n-ZRsaQmQNBxG0yQ8WQRRBq3Y"},
{"content":{"body":" * planned agenda for tomorrow's meeting:\n\n- method sharing and prototype lookup\n- property redefinition (and freezing)\n- R&T interaction","format":"org.matrix.custom.html","formatted_body":" * <p>planned agenda for tomorrow's meeting:</p>\n<ul>\n<li>method sharing and prototype lookup</li>\n<li>property redefinition (and freezing)</li>\n<li>R&amp;T interaction</li>\n</ul>\n","m.new_content":{"body":"planned agenda for tomorrow's meeting:\n\n- method sharing and prototype lookup\n- property redefinition (and freezing)\n- R&T interaction","format":"org.matrix.custom.html","formatted_body":"<p>planned agenda for tomorrow's meeting:</p>\n<ul>\n<li>method sharing and prototype lookup</li>\n<li>property redefinition (and freezing)</li>\n<li>R&amp;T interaction</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$edqxvIrFY-27kiOBw-n-ZRsaQmQNBxG0yQ8WQRRBq3Y","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674695892086,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$HHLDw4Wa9YkElr8jliqmTot4hTvuFNpEW2WNlji0U5w"},
{"content":{"body":"Unfortunately I don't think I will be able to attend tomorrow due to a conflicting appointment. I don't have much to report, Wasm GC is moving towards getting a formal spec (& JS API spec) so if anything relevant comes out of that I'll report in future meetings.","msgtype":"m.text","org.matrix.msc1767.text":"Unfortunately I don't think I will be able to attend tomorrow due to a conflicting appointment. I don't have much to report, Wasm GC is moving towards getting a formal spec (& JS API spec) so if anything relevant comes out of that I'll report in future meetings."},"ts":1674696348362,"senderName":"asumu","senderId":"@atakikawa:igalia.com","id":"$V5a3Cyl3cA5g_XPu5iwApSIppttTISWg-qZwAojXvfc"},
{"content":{"body":"thanks asumu","msgtype":"m.text"},"ts":1674696532881,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$AskAZo7GA0x1ls2FQXqr2xumTkiHYQG1SXPMy8cWLGM"},
{"content":{"body":"> <@aclaymore:matrix.org> Also feel free to have at the original time next week (10am PT), I'm getting an earlier train than I would usually today :)\n\n^^ if missed before. Feel free to keep the 10am time, if that works better for asumu . My clash last week was not reoccurring ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24ZdyOO9CHwPEvcn90DKy6UkYyoFpwnlRHt1KspZkffZs\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br>Also feel free to have at the original time next week (10am PT), I'm getting an earlier train than I would usually today :)</blockquote></mx-reply>^^ if missed before. Feel free to keep the 10am time, if that works better for <a href=\"https://matrix.to/#/@atakikawa:igalia.com\">asumu</a> . My clash last week was not reoccurring","m.relates_to":{"m.in_reply_to":{"event_id":"$ZdyOO9CHwPEvcn90DKy6UkYyoFpwnlRHt1KspZkffZs"}},"msgtype":"m.text"},"ts":1674699258164,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$1520TNhKBFuPRtfPehZ_FMiqdOV1vhLekRN1YO0LoKk"},
{"content":{"body":"> <@shuyuguo:matrix.org> planned agenda for tomorrow's meeting:\n> \n> - method sharing and prototype lookup\n> - property redefinition (and freezing)\n> - R&T interaction\n\nI'm also curious if we can leverage `using` with Mutex/ConditionVariable, since that was one of the reasons I focused on getting that proposal to Stage 3.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$edqxvIrFY-27kiOBw-n-ZRsaQmQNBxG0yQ8WQRRBq3Y?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">@shuyuguo:matrix.org</a><br><p>planned agenda for tomorrow's meeting:</p>\n<ul>\n<li>method sharing and prototype lookup</li>\n<li>property redefinition (and freezing)</li>\n<li>R&amp;T interaction</li>\n</ul>\n</blockquote></mx-reply>I'm also curious if we can leverage <code>using</code> with Mutex/ConditionVariable, since that was one of the reasons I focused on getting that proposal to Stage 3.","m.relates_to":{"m.in_reply_to":{"event_id":"$edqxvIrFY-27kiOBw-n-ZRsaQmQNBxG0yQ8WQRRBq3Y"}},"msgtype":"m.text"},"ts":1674748474449,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$f9_gyFZ8Jblx0rzzuPGoiQs_E87BqzbvedW4kTayS1E"},
{"content":{"body":"sure, sounds good","msgtype":"m.text"},"ts":1674751852388,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$nY0C9zSY6WIoXJuWgIuUdlWKs5hGxVpAeeO7Zz9QeaI"},
{"content":{"body":"Ashley Claymore: the call is now, btw","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@aclaymore:matrix.org\">Ashley Claymore</a>: the call is now, btw","msgtype":"m.text"},"ts":1674752669034,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$OXTrXIxNfrHpGS7rgPtw2SUOw8z0-J9EBAtlEFT1soI"},
{"content":{"body":"omw","msgtype":"m.text"},"ts":1674752707721,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$dAECJvNbgFjh78uCydTh4A_LFkjpy9XtiONBTy2JySo"},
{"content":{"body":"sorry, actually 1 min","msgtype":"m.text"},"ts":1674752724982,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$isjMeihj9FFWjxx5kGt1wZZwNwsZNFfi-jrAzTX9pJI"},
{"content":{"body":"np","msgtype":"m.text"},"ts":1674752729556,"senderName":"shu","senderId":"@shuyuguo:matrix.org","id":"$ODy7zU_yUM8HMumWhun5PoQ1muNfBk4_yB692gtJSZQ"},
{"content":{"body":"Regarding the \"shared modules\" suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.\n\nIf we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?\n\nIf we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into `globalThis`.\n\nIf we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level `await` or must otherwise be loaded asynchronously?\n\nHow and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?\n\nThe leap in logic I took to the \"shared module\" approach was to address these concerns:\n\n- \"Shared modules\" would have an identity in the module cache that could be used as part of the type identity.\n- \"Shared modules\" would promote code reuse.\n- \"Shared modules\" would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other \"shared modules\".\n- Due to the nature of the above restrictions, \"shared modules\" avoid accidental references to non-shared code.\n\nIt could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like `protobuf` today (i.e., maintaining their `protobuf` schema in a separate file).","format":"org.matrix.custom.html","formatted_body":"<p>Regarding the &quot;shared modules&quot; suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.</p>\n<p>If we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?</p>\n<p>If we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into <code>globalThis</code>.</p>\n<p>If we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level <code>await</code> or must otherwise be loaded asynchronously?</p>\n<p>How and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?</p>\n<p>The leap in logic I took to the &quot;shared module&quot; approach was to address these concerns:</p>\n<ul>\n<li>&quot;Shared modules&quot; would have an identity in the module cache that could be used as part of the type identity.</li>\n<li>&quot;Shared modules&quot; would promote code reuse.</li>\n<li>&quot;Shared modules&quot; would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other &quot;shared modules&quot;.</li>\n<li>Due to the nature of the above restrictions, &quot;shared modules&quot; avoid accidental references to non-shared code.</li>\n</ul>\n<p>It could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like <code>protobuf</code> today (i.e., maintaining their <code>protobuf</code> schema in a separate file).</p>\n","msgtype":"m.text"},"ts":1674758356884,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jFKUTlSFnP36Vc3plhvThBlWIrx5A_1y3apcWuDEhRg"},
{"content":{"body":" * Regarding the \"shared modules\" suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.\n\nIf we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?\n\nIf we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into `globalThis`.\n\nIf we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level `await` or must otherwise be loaded asynchronously?\n\nHow and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?\n\nThe leap in logic I took to the \"shared module\" approach was to address these concerns:\n\n- \"Shared modules\" would have an identity in the module cache that could be used as part of the type identity.\n- \"Shared modules\" would promote code reuse.\n- \"Shared modules\" would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other \"shared modules\".\n- Due to the nature of the above restrictions, \"shared modules\" avoid accidental references to non-shared code.\n\nIt could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like `protobuf` today (i.e., maintaining their `protobuf` schema in a separate file).","format":"org.matrix.custom.html","formatted_body":" * <p>Regarding the &quot;shared modules&quot; suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.</p>\n<p>If we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?</p>\n<p>If we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into <code>globalThis</code>.</p>\n<p>If we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level <code>await</code> or must otherwise be loaded asynchronously?</p>\n<p>How and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?</p>\n<p>The leap in logic I took to the &quot;shared module&quot; approach was to address these concerns:</p>\n<ul>\n<li>&quot;Shared modules&quot; would have an identity in the module cache that could be used as part of the type identity.</li>\n<li>&quot;Shared modules&quot; would promote code reuse.</li>\n<li>&quot;Shared modules&quot; would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other &quot;shared modules&quot;.</li>\n<li>Due to the nature of the above restrictions, &quot;shared modules&quot; avoid accidental references to non-shared code.</li>\n</ul>\n<p>It could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like <code>protobuf</code> today (i.e., maintaining their <code>protobuf</code> schema in a separate file).</p>\n","m.new_content":{"body":"Regarding the \"shared modules\" suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.\n\nIf we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?\n\nIf we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into `globalThis`.\n\nIf we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level `await` or must otherwise be loaded asynchronously?\n\nHow and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?\n\nThe leap in logic I took to the \"shared module\" approach was to address these concerns:\n\n- \"Shared modules\" would have an identity in the module cache that could be used as part of the type identity.\n- \"Shared modules\" would promote code reuse.\n- \"Shared modules\" would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other \"shared modules\".\n- Due to the nature of the above restrictions, \"shared modules\" avoid accidental references to non-shared code.\n\nIt could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like `protobuf` today (i.e., maintaining their `protobuf` schema in a separate file).","format":"org.matrix.custom.html","formatted_body":"<p>Regarding the &quot;shared modules&quot; suggestion. I may have jumped a few steps ahead in my reasoning without explaining how I got there, so I'll take a few steps back.</p>\n<p>If we imagine an implementation of shared structs that contains some form of methods, what can those methods close over? Only globals? What about functions that are siblings to the shared struct? What about imports?</p>\n<p>If we do not close over these things, the methods of shared structs won't be able to reuse useful utilities such as common vector math operations you might use in a 3D graphics library, that aren't somehow patched into <code>globalThis</code>.</p>\n<p>If we do close over these things, how do we ensure the module graph has been instantiated on the worker thread? What about initialization logic that might be needed that wires together some of these modules, applies polyfills, etc.? What if these modules contain top-level <code>await</code> or must otherwise be loaded asynchronously?</p>\n<p>How and when do we instantiate the thread-local (or per-realm?) prototype for each struct, especially if doing so might kick off this kind of module loading in the worker?</p>\n<p>The leap in logic I took to the &quot;shared module&quot; approach was to address these concerns:</p>\n<ul>\n<li>&quot;Shared modules&quot; would have an identity in the module cache that could be used as part of the type identity.</li>\n<li>&quot;Shared modules&quot; would promote code reuse.</li>\n<li>&quot;Shared modules&quot; would be restricted to containing only those things that can safely be shared, i.e. references to globals (which would be re-bound per realm), local functions, variables, shared structs, and imports/exports from other &quot;shared modules&quot;.</li>\n<li>Due to the nature of the above restrictions, &quot;shared modules&quot; avoid accidental references to non-shared code.</li>\n</ul>\n<p>It could be that the idea of isolating shared code to its own file is overkill, but many developers are already used to doing this with things like <code>protobuf</code> today (i.e., maintaining their <code>protobuf</code> schema in a separate file).</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$jFKUTlSFnP36Vc3plhvThBlWIrx5A_1y3apcWuDEhRg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674758388569,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dXSU_4dpDgLZEqIKtzVKXr1n-UqT0hFvh3WIcz0FLgw"}
]