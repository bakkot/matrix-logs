[
{"content":{"body":"> <@rbuckton:matrix.org> All of the decorators serve the same purpose as a keyword might. There was a strong sentiment in the past by some committee members that once Decorators is at Stage 4 we should avoid adding new keywords for things if a decorator would suffice. While I'm not sure I 100% agree, decorators could be used for this. \n\nThis very much has to be a case by case thing. I think Shu has technical reasons here why decorators don’t work. (Also I don’t know why your decorators have ()—that has never been needed in any draft proposal that I saw for decorators, and isn’t needed in Stage 3 or TS decorators)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk%3Amatrix.org/%24KrLRYUuqHHjRwlFNrimZCTBZgS80MESX6m70VxOJbV4\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>All of the decorators serve the same purpose as a keyword might. There was a strong sentiment in the past by some committee members that once Decorators is at Stage 4 we should avoid adding new keywords for things if a decorator would suffice. While I'm not sure I 100% agree, decorators could be used for this. </blockquote></mx-reply>This very much has to be a case by case thing. I think Shu has technical reasons here why decorators don’t work. (Also I don’t know why your decorators have ()—that has never been needed in any draft proposal that I saw for decorators, and isn’t needed in Stage 3 or TS decorators)","m.relates_to":{"m.in_reply_to":{"event_id":"$KrLRYUuqHHjRwlFNrimZCTBZgS80MESX6m70VxOJbV4"}},"msgtype":"m.text"},"ts":1692403239403,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kqPP8QbRElU3wB7XSYQFETiZzncHWLgHX1UBmkBorNU"},
{"content":{"body":"That's fair, though I'","msgtype":"m.text"},"ts":1692403332394,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$myIxoD-pyZ41i7oPMsEPMe577bs1tZUBD_aKTGgC6-c"},
{"content":{"body":" * That's fair, though I'll admit that in the TS experiment I'm using decorators so that I can use `class` so that TypeScript understands the types produced. The `@Shared` decorator itself is somewhat complex, but I can very easily write definitions like the following:\n\n```ts\n@Shared()\nexport class SharedTypeParameterDeclaration extends SharedNodeWithJSDoc<SyntaxKind.TypeParameter> {\n    @Shared() readonly modifiers!: SharedNodeArray<SharedModifier> | undefined;\n    @Shared() readonly name!: SharedIdentifier;\n    @Shared() readonly constraint!: SharedTypeNode | undefined;\n    @Shared() readonly default!: SharedTypeNode | undefined;\n    @Shared() readonly expression!: SharedExpression | undefined;\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>That's fair, though I'll admit that in the TS experiment I'm using decorators so that I can use <code>class</code> so that TypeScript understands the types produced. The <code>@Shared</code> decorator itself is somewhat complex, but I can very easily write definitions like the following:</p>\n<pre><code class=\"language-ts\">@Shared()\nexport class SharedTypeParameterDeclaration extends SharedNodeWithJSDoc&lt;SyntaxKind.TypeParameter&gt; {\n    @Shared() readonly modifiers!: SharedNodeArray&lt;SharedModifier&gt; | undefined;\n    @Shared() readonly name!: SharedIdentifier;\n    @Shared() readonly constraint!: SharedTypeNode | undefined;\n    @Shared() readonly default!: SharedTypeNode | undefined;\n    @Shared() readonly expression!: SharedExpression | undefined;\n}\n</code></pre>\n","m.new_content":{"body":"That's fair, though I'll admit that in the TS experiment I'm using decorators so that I can use `class` so that TypeScript understands the types produced. The `@Shared` decorator itself is somewhat complex, but I can very easily write definitions like the following:\n\n```ts\n@Shared()\nexport class SharedTypeParameterDeclaration extends SharedNodeWithJSDoc<SyntaxKind.TypeParameter> {\n    @Shared() readonly modifiers!: SharedNodeArray<SharedModifier> | undefined;\n    @Shared() readonly name!: SharedIdentifier;\n    @Shared() readonly constraint!: SharedTypeNode | undefined;\n    @Shared() readonly default!: SharedTypeNode | undefined;\n    @Shared() readonly expression!: SharedExpression | undefined;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>That's fair, though I'll admit that in the TS experiment I'm using decorators so that I can use <code>class</code> so that TypeScript understands the types produced. The <code>@Shared</code> decorator itself is somewhat complex, but I can very easily write definitions like the following:</p>\n<pre><code class=\"language-ts\">@Shared()\nexport class SharedTypeParameterDeclaration extends SharedNodeWithJSDoc&lt;SyntaxKind.TypeParameter&gt; {\n    @Shared() readonly modifiers!: SharedNodeArray&lt;SharedModifier&gt; | undefined;\n    @Shared() readonly name!: SharedIdentifier;\n    @Shared() readonly constraint!: SharedTypeNode | undefined;\n    @Shared() readonly default!: SharedTypeNode | undefined;\n    @Shared() readonly expression!: SharedExpression | undefined;\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$myIxoD-pyZ41i7oPMsEPMe577bs1tZUBD_aKTGgC6-c","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1692403429770,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ZGDHG5OEjznCpwHHKGylXvDElecF98Tn5X-trVinl1Q"},
{"content":{"body":"So I'd argue that there aren't technical reasons why decorators won't work, at least not with the origin trial.","msgtype":"m.text"},"ts":1692403462564,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$q5c12s32K_MbF_xFyg05OOl9G1ALV7R4WLDX54j-uTY"},
{"content":{"body":"Let me walk that last statement back somewhat. Its technically feasible to implement using decorators, but may not have intended performance characteristics due to potential limitations in static analysis.","msgtype":"m.text"},"ts":1692404395674,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fIW2JIdV_BHp93Chhe_ayCKzF0B1hmHwfadbgLIxwtk"}
]