[
{"content":{"body":"So a shared struct instance has a stable identity across `postMessage`, right? To expand on my earlier idea, I think we don't need any stable identity for module blocks or even symbols, we can just use shared structs themselves to dynamically attach behavior to a shared struct kind, given some built-in wiring. Here is a gist where I explore that approach: https://gist.github.com/mhofman/aa23fcc88e1ccd031a3c34f88577eaf7\n\nIt does not require any new syntax, or extra magic in postMessage (like module blocks, or symbol identities being preserved). It only requires an automatically generated static property on shared struct classes that represent the kind, and some built-in behavior, plus the dynamic prototype lookup we discussed of course. I'm actually wondering if this could be prototyped (pun intented) in the current experiment.","format":"org.matrix.custom.html","formatted_body":"<p>So a shared struct instance has a stable identity across <code>postMessage</code>, right? To expand on my earlier idea, I think we don't need any stable identity for module blocks or even symbols, we can just use shared structs themselves to dynamically attach behavior to a shared struct kind, given some built-in wiring. Here is a gist where I explore that approach: https://gist.github.com/mhofman/aa23fcc88e1ccd031a3c34f88577eaf7</p>\n<p>It does not require any new syntax, or extra magic in postMessage (like module blocks, or symbol identities being preserved). It only requires an automatically generated static property on shared struct classes that represent the kind, and some built-in behavior, plus the dynamic prototype lookup we discussed of course. I'm actually wondering if this could be prototyped (pun intented) in the current experiment.</p>\n","msgtype":"m.text"},"ts":1674782260197,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$-uuI3KEqPrIQ_hFWvtbvtQ-FZSD0-ztDNtuRDLkY6sM"},
{"content":{"body":"Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type'.\n'type' here being the identity created by the `shared struct class` syntax (the fan-out case).\nFor the fan-in case, where a farm of workers start up on their own, each creating their own separate `shared struct class` (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker. ","format":"org.matrix.custom.html","formatted_body":"Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type'.<br>'type' here being the identity created by the <code>shared struct class</code> syntax (the fan-out case).<br>For the fan-in case, where a farm of workers start up on their own, each creating their own separate <code>shared struct class</code> (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","msgtype":"m.text"},"ts":1674815953491,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$Qr9M_P68WAnrPBa5u7RhRsl3u-NN_aAhyW4Au6mUakg"},
{"content":{"body":" * Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type' to get the capability of method dispatch. (also method chaining, but `|>` operator would also give that).\n'type' here being the identity created by the `shared struct class` syntax (the fan-out case).\nFor the fan-in case, where a farm of workers start up on their own, each creating their own separate `shared struct class` (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","format":"org.matrix.custom.html","formatted_body":" * Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type' to get the capability of method dispatch. (also method chaining, but <code>|&gt;</code> operator would also give that).<br>'type' here being the identity created by the <code>shared struct class</code> syntax (the fan-out case).<br>For the fan-in case, where a farm of workers start up on their own, each creating their own separate <code>shared struct class</code> (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","m.new_content":{"body":"Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type' to get the capability of method dispatch. (also method chaining, but `|>` operator would also give that).\n'type' here being the identity created by the `shared struct class` syntax (the fan-out case).\nFor the fan-in case, where a farm of workers start up on their own, each creating their own separate `shared struct class` (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","format":"org.matrix.custom.html","formatted_body":"Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type' to get the capability of method dispatch. (also method chaining, but <code>|&gt;</code> operator would also give that).<br>'type' here being the identity created by the <code>shared struct class</code> syntax (the fan-out case).<br>For the fan-in case, where a farm of workers start up on their own, each creating their own separate <code>shared struct class</code> (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","msgtype":"m.text"},"m.relates_to":{"event_id":"$Qr9M_P68WAnrPBa5u7RhRsl3u-NN_aAhyW4Au6mUakg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674816023011,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$lZdVzR-WY0TcuB2m5FtL-jNyd3kBy4V6do6BUeta4qo"},
{"content":{"body":"Right the fan in case would work too, there jsut would be different constructors and kinds, that each would have to be set to use the same prototype maker, or prototype implementation if the prototype doesn't care about exposing the realm local constructor.\n\nYou're right at the end of the day this boils down to the capability of setting the dynamic prototype to use for instances.","msgtype":"m.text"},"ts":1674820470010,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$51AwujArkzEHaxpK902sTbrTx16zEnOAOKDjnoVezf0"},
{"content":{"body":"and to also capture a bit of what was discussed on the call last night:","msgtype":"m.text"},"ts":1674822061015,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$9wrTX5-kXU7_lsgsZDHYORycbTIwlGRJa1kQ4cqB_vo"},
{"content":{"body":"- the goal is to have: the instance of a shared struct to exist in shared memory, and the reference to this is passed around directly. There is not a per-agent wrapper adding a layer of indirection for prop access.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>the goal is to have: the instance of a shared struct to exist in shared memory, and the reference to this is passed around directly. There is not a per-agent wrapper adding a layer of indirection for prop access.</li>\n</ul>\n","msgtype":"m.text"},"ts":1674822065879,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$HAngt-C3rkzatIKyCNB_YuNahWMs0Qb4KPJdyrxRdNs"},
{"content":{"body":"- if there is a dynamic lookup when \\[\\[prototype\\]\\] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by `getPrototypeOf` can observably change, which violates the current description of the sealed integrity level.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>if there is a dynamic lookup when [[prototype]] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by <code>getPrototypeOf</code> can observably change, which violates the current description of the sealed integrity level.</li>\n</ul>\n","msgtype":"m.text"},"ts":1674822257314,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$NryxlRbBfI4m5ZbvlKEy76vU1VGPhu566EMDjEi4l4g"},
{"content":{"body":" * - if there is a dynamic lookup when \\[\\[prototype\\]\\] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by `getPrototypeOf` can observably change, which violates the current description of the sealed integrity level.","format":"org.matrix.custom.html","formatted_body":" * <ul>\n<li>if there is a dynamic lookup when [[prototype]] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by <code>getPrototypeOf</code> can observably change, which violates the current description of the sealed integrity level.</li>\n</ul>\n","m.new_content":{"body":"- if there is a dynamic lookup when \\[\\[prototype\\]\\] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by `getPrototypeOf` can observably change, which violates the current description of the sealed integrity level.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>if there is a dynamic lookup when [[prototype]] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by <code>getPrototypeOf</code> can observably change, which violates the current description of the sealed integrity level.</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$NryxlRbBfI4m5ZbvlKEy76vU1VGPhu566EMDjEi4l4g","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674822287285,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$5ZNWcRhQ2A3_9PHFXhJ_Vq1MTAXnXxPL1eN-_cotHW8"},
{"content":{"body":"- cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache</li>\n</ul>\n","msgtype":"m.text"},"ts":1674822373169,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$1H5eoQfYYwF14jYxgh4m0iWB_5ay-gVj64_TC4uX5I0"},
{"content":{"body":" * - cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache","format":"org.matrix.custom.html","formatted_body":" * <ul>\n<li>cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache</li>\n</ul>\n","m.new_content":{"body":"- cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$1H5eoQfYYwF14jYxgh4m0iWB_5ay-gVj64_TC4uX5I0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674822388092,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$y8NeDC5sk-F4REWVpClyofOUMpX5WTThR0lFxxEn8V0"},
{"content":{"body":"> <@aclaymore:matrix.org> - the goal is to have: the instance of a shared struct to exist in shared memory, and the reference to this is passed around directly. There is not a per-agent wrapper adding a layer of indirection for prop access.\n\nI have actually been wondering about that, and whether that's an observable thing from the 262 spec point of view. The only program observable aspect of this is the preservation of identity through cross agent interactions, which is host defined anyway.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$HAngt-C3rkzatIKyCNB_YuNahWMs0Qb4KPJdyrxRdNs?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br /><ul>\n<li>the goal is to have: the instance of a shared struct to exist in shared memory, and the reference to this is passed around directly. There is not a per-agent wrapper adding a layer of indirection for prop access.</li>\n</ul>\n</blockquote></mx-reply>I have actually been wondering about that, and whether that's an observable thing from the 262 spec point of view. The only program observable aspect of this is the preservation of identity through cross agent interactions, which is host defined anyway.","m.relates_to":{"m.in_reply_to":{"event_id":"$HAngt-C3rkzatIKyCNB_YuNahWMs0Qb4KPJdyrxRdNs"}},"msgtype":"m.text"},"ts":1674822394204,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Z0_9WM1V-jSW8z-5s-5k7_cKZMtXYRtkZbYBVsvjygw"},
{"content":{"body":"yes unlikely to be observable, but if that is an implementation goal then it limits which semantics are performant/simple/memory-efficient etc","msgtype":"m.text"},"ts":1674822460352,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$sWEybKoUki-o0BBlx4HhOGcQXzLmh1pn9sv06Pfb2nU"},
{"content":{"body":" * yes unlikely to be observable, but if that is an implementation goal then it limits which semantics are performant/simple/memory-efficient etc","m.new_content":{"body":"yes unlikely to be observable, but if that is an implementation goal then it limits which semantics are performant/simple/memory-efficient etc","msgtype":"m.text"},"m.relates_to":{"event_id":"$sWEybKoUki-o0BBlx4HhOGcQXzLmh1pn9sv06Pfb2nU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674822493069,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$h1cNG77CFYMdw24QylRQg6bzOFU7ZOo7RGy_yv9kMpY"},
{"content":{"body":"> <@aclaymore:matrix.org> - cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache\n\nNot really. If the prototype is set once and maybe throws when accessed before, then it's arguably sealed for that agent. As I mentioned, the fact there is a single reference shared between agents is an implementation detail IMO","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$1H5eoQfYYwF14jYxgh4m0iWB_5ay-gVj64_TC4uX5I0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br /><ul>\n<li>cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache</li>\n</ul>\n</blockquote></mx-reply>Not really. If the prototype is set once and maybe throws when accessed before, then it's arguably sealed for that agent. As I mentioned, the fact there is a single reference shared between agents is an implementation detail IMO","m.relates_to":{"m.in_reply_to":{"event_id":"$1H5eoQfYYwF14jYxgh4m0iWB_5ay-gVj64_TC4uX5I0"}},"msgtype":"m.text"},"ts":1674822501568,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$2wbijuwi750WD41R-whbN3gsqv7emHXr7_yL_ia0N_o"},
{"content":{"body":"Quoted the wrong message","msgtype":"m.text"},"ts":1674822538036,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$lVL6mmQ2a2FnjC_Oz9d7evtiW1a3SYPcItYGietZoys"},
{"content":{"body":"As for per instance memory, i believe it'd only be per kind / type memory, not per instance ","msgtype":"m.text"},"ts":1674822576116,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$9oznH4P2LF9tExE8TaktyiMShCwlvHGrGV-oSpaT0Y4"},
{"content":{"body":"> <@mhofman:matrix.org> So a shared struct instance has a stable identity across `postMessage`, right? To expand on my earlier idea, I think we don't need any stable identity for module blocks or even symbols, we can just use shared structs themselves to dynamically attach behavior to a shared struct kind, given some built-in wiring. Here is a gist where I explore that approach: https://gist.github.com/mhofman/aa23fcc88e1ccd031a3c34f88577eaf7\n> \n> It does not require any new syntax, or extra magic in postMessage (like module blocks, or symbol identities being preserved). It only requires an automatically generated static property on shared struct classes that represent the kind, and some built-in behavior, plus the dynamic prototype lookup we discussed of course. I'm actually wondering if this could be prototyped (pun intented) in the current experiment.\n\nIs there a reason the identity needs to be a static property, or surfaced to the user at all, as opposed to an internal slot?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$-uuI3KEqPrIQ_hFWvtbvtQ-FZSD0-ztDNtuRDLkY6sM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br><p>So a shared struct instance has a stable identity across <code>postMessage</code>, right? To expand on my earlier idea, I think we don't need any stable identity for module blocks or even symbols, we can just use shared structs themselves to dynamically attach behavior to a shared struct kind, given some built-in wiring. Here is a gist where I explore that approach: https://gist.github.com/mhofman/aa23fcc88e1ccd031a3c34f88577eaf7</p>\n<p>It does not require any new syntax, or extra magic in postMessage (like module blocks, or symbol identities being preserved). It only requires an automatically generated static property on shared struct classes that represent the kind, and some built-in behavior, plus the dynamic prototype lookup we discussed of course. I'm actually wondering if this could be prototyped (pun intented) in the current experiment.</p>\n</blockquote></mx-reply>Is there a reason the identity needs to be a static property, or surfaced to the user at all, as opposed to an internal slot?","m.relates_to":{"m.in_reply_to":{"event_id":"$-uuI3KEqPrIQ_hFWvtbvtQ-FZSD0-ztDNtuRDLkY6sM"}},"msgtype":"m.text"},"ts":1674834364610,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$c3F7zrnNoc0PLhRf6LXug28Mw4n32kmrUvntGIZBe5s"},
{"content":{"body":"allows more userland solutions/experimentation maybe?","msgtype":"m.text"},"ts":1674835080843,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$He_N_LVCZRLhB4muyxSFYqklWGNaea7VLfrTNP2R0-A"},
{"content":{"body":" * allows more userland solutions/experimentation maybe?","m.new_content":{"body":"allows more userland solutions/experimentation maybe?","msgtype":"m.text"},"m.relates_to":{"event_id":"$He_N_LVCZRLhB4muyxSFYqklWGNaea7VLfrTNP2R0-A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674835090670,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$0fZbGiexsT7ciZH--M4z8i2jjbDcE43AEXpN1lwywCE"},
{"content":{"body":"though I guess that itself can be done in userland\n\n```\nconst id = new shared struct class ID{}\n\nshared struct class SSC {\n  __type__ = id\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>though I guess that itself can be done in userland</p>\n<pre><code>const id = new shared struct class ID{}\n\nshared struct class SSC {\n  __type__ = id\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1674835140390,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$_QAyn8VetGLxyoy8vCNH5njC2djkJ2HjUG-a5vafFYo"},
{"content":{"body":"I'm not certain that's necessary, at least not for an MVP. ","msgtype":"m.text"},"ts":1674835146900,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$hwKvbMgZo8VCwXb1-z_ZGCUxpE07vmeUqAZytZr0x8E"},
{"content":{"body":"I did this so the program could attach the dynamic prototype without magic","msgtype":"m.text"},"ts":1674835181625,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$XoFMuQn7dcJ69XQh408Q4QfdWoG3wG6mP1tqOVP9Ve0"},
{"content":{"body":"We can always try to find more ergonomic ways, but this is flexible for experimenting ","msgtype":"m.text"},"ts":1674835208095,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$nymI9hNgWV45z0fmpD2dF-3oHJ4gSm1U1ibMxwowhOc"},
{"content":{"body":"It just seems a bit like an overcomplication, IMO.","msgtype":"m.text"},"ts":1674835241259,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dnOEnUEtyxPMOMimNjtWSTcv2xLHwilj6xHN1XPxLos"},
{"content":{"body":"If you have an alternative I'm all ears","msgtype":"m.text"},"ts":1674835290464,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$XwpYyYbOHB1JWhbD6jF6Oos00vPJzX0Q3cqdZ-J7omA"},
{"content":{"body":"All the solutions I've heard so far rely on more syntax that doesn't exist today ","msgtype":"m.text"},"ts":1674835351153,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$c1-qJCAWwdmE1qI1BjdxoX1B4HmTertCU8UVIqhwXRs"},
{"content":{"body":"> <@aclaymore:matrix.org> though I guess that itself can be done in userland\n> \n> ```\n> const id = new shared struct class ID{}\n> \n> shared struct class SSC {\n>   __type__ = id\n> }\n> ```\n\nBtw, the set shared/dynamic prototype is the critical part, which cannot be done in userland. And since this is leveraging shared stuct itself to describe the type for its identity preserving feature, the whole thing needs to be bootstrapped in the engine too","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$_QAyn8VetGLxyoy8vCNH5njC2djkJ2HjUG-a5vafFYo?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br><p>though I guess that itself can be done in userland</p>\n<pre><code>const id = new shared struct class ID{}\n\nshared struct class SSC {\n  __type__ = id\n}\n</code></pre>\n</blockquote></mx-reply>Btw, the set shared/dynamic prototype is the critical part, which cannot be done in userland. And since this is leveraging shared stuct itself to describe the type for its identity preserving feature, the whole thing needs to be bootstrapped in the engine too","m.relates_to":{"m.in_reply_to":{"event_id":"$_QAyn8VetGLxyoy8vCNH5njC2djkJ2HjUG-a5vafFYo"}},"msgtype":"m.text"},"ts":1674837832229,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$eJ0dzD8nswKxKpnfEGn_Ev5s2BS-46u4vslNM-iRefk"},
{"content":{"body":"yep. I was imagining a userland experimental library where the prototype is registered with the library, and then the shared-struct is passed to a `wrap` function that returns a proxy wrapper for it which adds the proto look up (but loses the ability to be structured clone)","format":"org.matrix.custom.html","formatted_body":"yep. I was imagining a userland experimental library where the prototype is registered with the library, and then the shared-struct is passed to a <code>wrap</code> function that returns a proxy wrapper for it which adds the proto look up (but loses the ability to be structured clone)","msgtype":"m.text"},"ts":1674838074839,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$kwi1WzS-cMKb0uejfXztuQzYnnHMoMWBGbXhEqBqarc"},
{"content":{"body":"Oh yeah you can totally do this in userland with Proxies","msgtype":"m.text"},"ts":1674838103122,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CIjnR4I1HSm6l18tZsRPo6fj2d0iALBhLMullyhaeJk"},
{"content":{"body":"at the expense of per realm proxy instances ","msgtype":"m.text"},"ts":1674838122274,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$CmAhOTxZowtOGlhs23sPQrv5r_2GA0iLp13kz5S1IwQ"},
{"content":{"body":"and code wouldn't be able to magically pass that proxied wrapper to another agent, they would know it needs to be unwrapped again","msgtype":"m.text"},"ts":1674838174811,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$DPYYQkwmvJccqHyfurLYAZBW_fh_Xp3wA_G1EDUbn2s"},
{"content":{"body":"minus the postMessage identity preserving logic, but that can be emulated by wrapping postMessage, which gets hairy quickly, and makes it impossible to do cross agent gc of course","msgtype":"m.text"},"ts":1674838199554,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$b6oQWl9xRUwiub_RECb0X6PjcdLzNVtHN4HmVg_zEg0"},
{"content":{"body":"or structuredClone would need a new handler similar to `toJSON` where it can extract out the struct automatically","format":"org.matrix.custom.html","formatted_body":"or structuredClone would need a new handler similar to <code>toJSON</code> where it can extract out the struct automatically","msgtype":"m.text"},"ts":1674838211219,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$0ZNusY7ExU-k548RCUu5ZhNEK1Uxk9pPBOctNSTobaA"},
{"content":{"body":"aka no cycle collection. if no cycle, you can use weakrefs","msgtype":"m.text"},"ts":1674838217952,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$d6v9n9YCjpAhZ7rOt2wQjuqqTOS2YsvK6vHjQRhRND0"},
{"content":{"body":"nah that really needs to be in the engine (at least until I get to propose my API to support distributed GC)","msgtype":"m.text"},"ts":1674838248668,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$vR7scDzgENaf9WXk5RK0M7Tqkw-KPtf-DDInZLupekE"},
{"content":{"body":"I have been toying with identity preservation through postMessage for a few years now, that's what got me interested in TC39 in the first place","msgtype":"m.text"},"ts":1674838295618,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$h0YRBeZzPXF4pGEtgxvnC6xYmPKHnq72cUA9IoTslP4"},
{"content":{"body":"(yes I know different standard groups, but the gc API needs to be in the language)","msgtype":"m.text"},"ts":1674838329209,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$SeP38E-PE4bUAH48beTwgQbNYySpk2Ob9mpvPEjcJtE"},
{"content":{"body":"wrapping postMessage is no fun, it's very inception","msgtype":"m.text"},"ts":1674838366512,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$0SJA-BjYl9aoO0Zyx9ZWJNDnXyh2PzBZKCp7oUznz-Q"},
{"content":{"body":"right now I kinda like the idea that shared structs that want a prototype are top-level-const exported `export shared struct class Foo {}` , and the module they are declared is what is 'attached' to the 'type' as an internal slot. for other agents to load. It could have an overlap with the import-defer-eval proposal, where the module is sync loaded on the first prototype access to be lazy and reduce the cost when the methods are not accessed by other agents","format":"org.matrix.custom.html","formatted_body":"right now I kinda like the idea that shared structs that want a prototype are top-level-const exported <code>export shared struct class Foo {}</code> , and the module they are declared is what is 'attached' to the 'type' as an internal slot. for other agents to load. It could have an overlap with the import-defer-eval proposal, where the module is sync loaded on the first prototype access to be lazy and reduce the cost when the methods are not accessed by other agents","msgtype":"m.text"},"ts":1674838393745,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$hakkfY_KURIVWsyw1RiRSL7zuKlbbrRvZ4j5LzuOOX8"},
{"content":{"body":"yeah maybe that's what the ergonomic solution ends up looking like, but module blocks and/or import defer do not exist today if shu want to experiment with something right away. My proposal is about enabling this with what we have today, and the dynamic prototype lookup we'll need anyway","format":"org.matrix.custom.html","formatted_body":"yeah maybe that's what the ergonomic solution ends up looking like, but module blocks and/or import defer do not exist today if <a href=\"https://matrix.to/#/@shuyuguo:matrix.org\">shu</a> want to experiment with something right away. My proposal is about enabling this with what we have today, and the dynamic prototype lookup we'll need anyway","msgtype":"m.text"},"ts":1674838538741,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$_BE3kr9DEGsFBBuKZMBi7tHexZUJaVblWoKlVv9H35Y"},
{"content":{"body":"no need to mess with module logic","msgtype":"m.text"},"ts":1674838553438,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$BaYy4P6Oh59C33LjtKAmfSBMAH7yISUmtA0B61J00GU"},
{"content":{"body":"(I don't think) this would need module blocks, the part that is attached to the internal slot can be, as littledan said, a URL string","format":"org.matrix.custom.html","formatted_body":"(I don't think) this would need module blocks, the part that is attached to the internal slot can be, as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> said, a URL string","msgtype":"m.text"},"ts":1674838575249,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$BtvyT2AryuR2gNOEK4ipg27BxzlyfH2sdsTT8DdzhpA"},
{"content":{"body":" * (I don't think) this wouldn't need module blocks, the part that is attached to the internal slot can be, as littledan said, a URL string","format":"org.matrix.custom.html","formatted_body":" * (I don't think) this wouldn't need module blocks, the part that is attached to the internal slot can be, as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> said, a URL string","m.new_content":{"body":"(I don't think) this wouldn't need module blocks, the part that is attached to the internal slot can be, as littledan said, a URL string","format":"org.matrix.custom.html","formatted_body":"(I don't think) this wouldn't need module blocks, the part that is attached to the internal slot can be, as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> said, a URL string","msgtype":"m.text"},"m.relates_to":{"event_id":"$BtvyT2AryuR2gNOEK4ipg27BxzlyfH2sdsTT8DdzhpA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674838632561,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$lJ-ukSJHsGTxkm0l5ViFcToyfmrAy8t5cp8qnA3HhaY"},
{"content":{"body":" * (I don't think) this would need module blocks, the part that is attached to the internal slot can be, as littledan said, a URL string","format":"org.matrix.custom.html","formatted_body":" * (I don't think) this would need module blocks, the part that is attached to the internal slot can be, as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> said, a URL string","m.new_content":{"body":"(I don't think) this would need module blocks, the part that is attached to the internal slot can be, as littledan said, a URL string","format":"org.matrix.custom.html","formatted_body":"(I don't think) this would need module blocks, the part that is attached to the internal slot can be, as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> said, a URL string","msgtype":"m.text"},"m.relates_to":{"event_id":"$BtvyT2AryuR2gNOEK4ipg27BxzlyfH2sdsTT8DdzhpA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674838639214,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$VsmwwUTP6GLBOhwLPBSzYb77K6t7uC746scWcsW5jAk"},
{"content":{"body":"I'm personally not a fan of tying module specifier strings into the solution","msgtype":"m.text"},"ts":1674838717349,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$4aUFbpnvIO0YZ8NNLDNx4Agknx8P4XxePtLDPO0X1q4"},
{"content":{"body":"Is there any reason the origin trial API couldn't be extended to provide a registration mechanism for the shared struct type with a user-provided unique ID (just a string, but could contain a URI, UUID, etc.) and the thread-local prototype to use?\n\n```js\n// + fairly flexible\n// - requires setup on receiver end, correlation of struct type identity.\n// - requires encapsulation for constructor logic\n\n// data.js\n// data only structs don't require registration and have no shared type identity.\nexport const DataOnly = new SharedStructType([\"foo\"]);\n\n// vector2d.js\n// data+behavior structs require registration to define type identity\nconst { type: _Vector2D, register } = SharedStructType.prepare([\"x\", \"y\"]);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n    const _this = Reflect.construct(_Vector2D, [], new.target);\n    _this.x = x;\n    _this.y = y;\n    return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n    const dx = this.x - v.x;\n    const dy = this.y - v.y;\n    return Math.sqrt(dx * dx + dy * dy);\n};\n\n// Register the type identity, constructor, and prototype to use for this struct type in this thread.\n// NOTE: register(id, constructor [, prototype])\nregister(\"e3a9bd1f-0f64-4848-b255-3c629d0c44a3\", Vector2D, Vector2D.prototype);\n\nexport { Vector2D };\n\n// main.js\nimport { DataOnly } from \"./data.js\";\nimport { Vector2D } from \"./vector2d.js\";\nconst data = new DataOnly();\ndata.foo = \"data only, no behavior\";\n\nconst v1 = new Vector2D(1, 2);\nconst v2 = new Vector2D(3, 4);\nconst worker1 = new Worker(\"worker1.js\");\nworker1.postMessage([data, v1, v2]);\n\nconst worker2 = new Worker(\"worker2.js\");\nworker2.postMessage([data, v1, v2]);\n\n// worker1.js\n// worker1 does not import Vector2D, so can only access its data.\nparentPort.on(\"message\", ([data, v1, v2]) => {\n    data.foo; // \"data only, no behavior\"\n    v1.x; // 1\n    v2.y; // 4\n    // NOTE: prototype not registered. This could mean an invalid prototype chain (thus every non-data\n    // member acces would throw), or a default prototype chain (where prototype methods throw by nature\n    // of them just being `undefined`).0\n    v1.distanceTo(v2); // error\n    v1.toString(); // error?\n});\n\n// worker2.js\n// worker2 imports Vector2D, which causes registration as a side-effect.\nimport \"./vector2d.js\";\nparentPort.on(\"message\", ([data, v1, v2]) => {\n    data.foo; // \"data only, no behavior\"\n    v1.x; // 1\n    v2.y; // 4\n    v1.distanceTo(v2); // ok\n    v1.toString(); // ok\n});\n```\n\nThe user-supplied type identity would allow the user to define the same struct in different bundles, and the registry wouldn't be global, but would rather be thread-local, so there'd be no global mutable registry to worry about. It also doesn't really matter if the prototypes differ slightly between realms/threads, since they all access the same underlying data.\n\nWe could eventually extend this to syntax, possibly even using decorators:\n\n```js\n// data.js\nexport shared struct DataOnly {\n    foo;\n\n    // NOTE: constructors don't necessarily require registration\n    constructor(foo) {\n        this.foo = foo;\n    }\n}\n\n// vector2d.js\n// a syntactic declaration doesn't necessarily need to set a type identity, since\n// we could infer one for it based on path to the containing file and its offset within\n// the file. However, we could still allow the user to explicitly specify type identity\n// for use with bundlers, or other cases where the inferred type identity might not\n// be sufficient.\n\n@struct.id(\"e3a9bd1f-0f64-4848-b255-3c629d0c44a3\")\n// or: @struct.id(\"https://babylonjs.com/5.0/Vector2D\")\nexport shared struct Vector2D {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    distanceTo(v) {\n        const dx = this.x - v.x;\n        const dy = this.y - v.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>Is there any reason the origin trial API couldn't be extended to provide a registration mechanism for the shared struct type with a user-provided unique ID (just a string, but could contain a URI, UUID, etc.) and the thread-local prototype to use?</p>\n<pre><code class=\"language-js\">// + fairly flexible\n// - requires setup on receiver end, correlation of struct type identity.\n// - requires encapsulation for constructor logic\n\n// data.js\n// data only structs don't require registration and have no shared type identity.\nexport const DataOnly = new SharedStructType([&quot;foo&quot;]);\n\n// vector2d.js\n// data+behavior structs require registration to define type identity\nconst { type: _Vector2D, register } = SharedStructType.prepare([&quot;x&quot;, &quot;y&quot;]);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n    const _this = Reflect.construct(_Vector2D, [], new.target);\n    _this.x = x;\n    _this.y = y;\n    return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n    const dx = this.x - v.x;\n    const dy = this.y - v.y;\n    return Math.sqrt(dx * dx + dy * dy);\n};\n\n// Register the type identity, constructor, and prototype to use for this struct type in this thread.\n// NOTE: register(id, constructor [, prototype])\nregister(&quot;e3a9bd1f-0f64-4848-b255-3c629d0c44a3&quot;, Vector2D, Vector2D.prototype);\n\nexport { Vector2D };\n\n// main.js\nimport { DataOnly } from &quot;./data.js&quot;;\nimport { Vector2D } from &quot;./vector2d.js&quot;;\nconst data = new DataOnly();\ndata.foo = &quot;data only, no behavior&quot;;\n\nconst v1 = new Vector2D(1, 2);\nconst v2 = new Vector2D(3, 4);\nconst worker1 = new Worker(&quot;worker1.js&quot;);\nworker1.postMessage([data, v1, v2]);\n\nconst worker2 = new Worker(&quot;worker2.js&quot;);\nworker2.postMessage([data, v1, v2]);\n\n// worker1.js\n// worker1 does not import Vector2D, so can only access its data.\nparentPort.on(&quot;message&quot;, ([data, v1, v2]) =&gt; {\n    data.foo; // &quot;data only, no behavior&quot;\n    v1.x; // 1\n    v2.y; // 4\n    // NOTE: prototype not registered. This could mean an invalid prototype chain (thus every non-data\n    // member acces would throw), or a default prototype chain (where prototype methods throw by nature\n    // of them just being `undefined`).0\n    v1.distanceTo(v2); // error\n    v1.toString(); // error?\n});\n\n// worker2.js\n// worker2 imports Vector2D, which causes registration as a side-effect.\nimport &quot;./vector2d.js&quot;;\nparentPort.on(&quot;message&quot;, ([data, v1, v2]) =&gt; {\n    data.foo; // &quot;data only, no behavior&quot;\n    v1.x; // 1\n    v2.y; // 4\n    v1.distanceTo(v2); // ok\n    v1.toString(); // ok\n});\n</code></pre>\n<p>The user-supplied type identity would allow the user to define the same struct in different bundles, and the registry wouldn't be global, but would rather be thread-local, so there'd be no global mutable registry to worry about. It also doesn't really matter if the prototypes differ slightly between realms/threads, since they all access the same underlying data.</p>\n<p>We could eventually extend this to syntax, possibly even using decorators:</p>\n<pre><code class=\"language-js\">// data.js\nexport shared struct DataOnly {\n    foo;\n\n    // NOTE: constructors don't necessarily require registration\n    constructor(foo) {\n        this.foo = foo;\n    }\n}\n\n// vector2d.js\n// a syntactic declaration doesn't necessarily need to set a type identity, since\n// we could infer one for it based on path to the containing file and its offset within\n// the file. However, we could still allow the user to explicitly specify type identity\n// for use with bundlers, or other cases where the inferred type identity might not\n// be sufficient.\n\n@struct.id(&quot;e3a9bd1f-0f64-4848-b255-3c629d0c44a3&quot;)\n// or: @struct.id(&quot;https://babylonjs.com/5.0/Vector2D&quot;)\nexport shared struct Vector2D {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    distanceTo(v) {\n        const dx = this.x - v.x;\n        const dy = this.y - v.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1674840085615,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$T7lJ_d9e4rdOniomYC_gdDSMSfMS_DMoa-h4R_NYiuU"},
{"content":{"body":"I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the `SharedStructType.prepare` call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.","format":"org.matrix.custom.html","formatted_body":"I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the <code>SharedStructType.prepare</code> call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.","msgtype":"m.text"},"ts":1674842560619,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$8i7J9kQJhb-XbStTTn401OKkz212u1VY28tQRprdg9A"},
{"content":{"body":"Btw, the prototype attaching I suggested can be made to have a shape more similar to your suggestion above","msgtype":"m.text"},"ts":1674842587028,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$034nBUJbM1-b2YIF0EEjgrAZBa4eopbRC4fsSnAD15w"},
{"content":{"body":"```js\n// vector2d.js\n// Each shared struct type, whether data only or \"prepared\" has its own unique type\nexport const vector2Dtype = SharedStructType.prepare([\"x\", \"y\"]);\n\nconst _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n  const _this = Reflect.construct(_Vector2D, [], new.target);\n  _this.x = x;\n  _this.y = y;\n  return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n  const dx = this.x - v.x;\n  const dy = this.y - v.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nSharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n\n// main.js\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\nconst v1 = new Vector2D(1, 2);\nconst worker = new Worker(\"worker.js\");\nworker.postMessage([vector2DType, v1]);\n\n// worker.js\n// worker imports Vector2D, which causes registration as a side-effect.\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\n\nconst v2 = new Vector2D(3, 4);\n\nparentPort.on(\"message\", ([mainVector2DType, v1]) => {\n  SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n  assert(mainVector2DType !== vector2DType);\n  assert(\n    SharedStructType.getConstructor(mainVector2DType) !==\n      SharedStructType.getConstructor(vector2Dtype)\n  );\n  assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n  v1.x; // 1\n  v1.distanceTo(v2); // ok\n  v1.toString(); // ok\n});\n\n```\n\nSharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.\n\nIf the engine had to deduplicate itself, you'd either need a user provided type identifier at \"prepare\" time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?\n\nBy having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">// vector2d.js\n// Each shared struct type, whether data only or &quot;prepared&quot; has its own unique type\nexport const vector2Dtype = SharedStructType.prepare([&quot;x&quot;, &quot;y&quot;]);\n\nconst _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n  const _this = Reflect.construct(_Vector2D, [], new.target);\n  _this.x = x;\n  _this.y = y;\n  return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n  const dx = this.x - v.x;\n  const dy = this.y - v.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nSharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n\n// main.js\nimport { Vector2D, vector2DType } from &quot;./vector2d.js&quot;;\nconst v1 = new Vector2D(1, 2);\nconst worker = new Worker(&quot;worker.js&quot;);\nworker.postMessage([vector2DType, v1]);\n\n// worker.js\n// worker imports Vector2D, which causes registration as a side-effect.\nimport { Vector2D, vector2DType } from &quot;./vector2d.js&quot;;\n\nconst v2 = new Vector2D(3, 4);\n\nparentPort.on(&quot;message&quot;, ([mainVector2DType, v1]) =&gt; {\n  SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n  assert(mainVector2DType !== vector2DType);\n  assert(\n    SharedStructType.getConstructor(mainVector2DType) !==\n      SharedStructType.getConstructor(vector2Dtype)\n  );\n  assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n  v1.x; // 1\n  v1.distanceTo(v2); // ok\n  v1.toString(); // ok\n});\n\n</code></pre>\n<p>SharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.</p>\n<p>If the engine had to deduplicate itself, you'd either need a user provided type identifier at &quot;prepare&quot; time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?</p>\n<p>By having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.</p>\n","msgtype":"m.text"},"ts":1674845352002,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$hvjgknJMdDSzY0wT0tSfVQQAC1aW1pyprtBZ9Phn2ss"},
{"content":{"body":" * ```js\n// vector2d.js\n// Each shared struct type, whether data only or \"prepared\" has its own unique type\nexport const vector2Dtype = SharedStructType.prepare([\"x\", \"y\"]);\n\nconst _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n  const _this = Reflect.construct(_Vector2D, [], new.target);\n  _this.x = x;\n  _this.y = y;\n  return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n  const dx = this.x - v.x;\n  const dy = this.y - v.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nSharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n\n// main.js\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\nconst v1 = new Vector2D(1, 2);\nconst worker = new Worker(\"worker.js\");\nworker.postMessage([vector2DType, v1]);\n\n// worker.js\n// worker imports Vector2D, which causes registration as a side-effect.\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\n\nconst v2 = new Vector2D(3, 4);\n\nparentPort.on(\"message\", ([mainVector2DType, v1]) => {\n  SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n  assert(mainVector2DType !== vector2DType);\n  assert(\n    SharedStructType.getConstructor(mainVector2DType) !==\n      SharedStructType.getConstructor(vector2Dtype)\n  );\n  assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n  v1.x; // 1\n  v1.distanceTo(v2); // ok\n  v1.toString(); // ok\n});\n\n```\n\nSharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.\n\nIf the engine had to deduplicate itself, you'd either need a user provided type identifier at \"prepare\" time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?\n\nBy having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.","format":"org.matrix.custom.html","formatted_body":" * <pre><code class=\"language-js\">// vector2d.js\n// Each shared struct type, whether data only or &quot;prepared&quot; has its own unique type\nexport const vector2Dtype = SharedStructType.prepare([&quot;x&quot;, &quot;y&quot;]);\n\nconst _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n  const _this = Reflect.construct(_Vector2D, [], new.target);\n  _this.x = x;\n  _this.y = y;\n  return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n  const dx = this.x - v.x;\n  const dy = this.y - v.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nSharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n\n// main.js\nimport { Vector2D, vector2DType } from &quot;./vector2d.js&quot;;\nconst v1 = new Vector2D(1, 2);\nconst worker = new Worker(&quot;worker.js&quot;);\nworker.postMessage([vector2DType, v1]);\n\n// worker.js\n// worker imports Vector2D, which causes registration as a side-effect.\nimport { Vector2D, vector2DType } from &quot;./vector2d.js&quot;;\n\nconst v2 = new Vector2D(3, 4);\n\nparentPort.on(&quot;message&quot;, ([mainVector2DType, v1]) =&gt; {\n  SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n  assert(mainVector2DType !== vector2DType);\n  assert(\n    SharedStructType.getConstructor(mainVector2DType) !==\n      SharedStructType.getConstructor(vector2Dtype)\n  );\n  assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n  v1.x; // 1\n  v1.distanceTo(v2); // ok\n  v1.toString(); // ok\n});\n\n</code></pre>\n<p>SharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.</p>\n<p>If the engine had to deduplicate itself, you'd either need a user provided type identifier at &quot;prepare&quot; time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?</p>\n<p>By having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.</p>\n","m.new_content":{"body":"```js\n// vector2d.js\n// Each shared struct type, whether data only or \"prepared\" has its own unique type\nexport const vector2Dtype = SharedStructType.prepare([\"x\", \"y\"]);\n\nconst _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n  const _this = Reflect.construct(_Vector2D, [], new.target);\n  _this.x = x;\n  _this.y = y;\n  return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n  const dx = this.x - v.x;\n  const dy = this.y - v.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nSharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n\n// main.js\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\nconst v1 = new Vector2D(1, 2);\nconst worker = new Worker(\"worker.js\");\nworker.postMessage([vector2DType, v1]);\n\n// worker.js\n// worker imports Vector2D, which causes registration as a side-effect.\nimport { Vector2D, vector2DType } from \"./vector2d.js\";\n\nconst v2 = new Vector2D(3, 4);\n\nparentPort.on(\"message\", ([mainVector2DType, v1]) => {\n  SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n  assert(mainVector2DType !== vector2DType);\n  assert(\n    SharedStructType.getConstructor(mainVector2DType) !==\n      SharedStructType.getConstructor(vector2Dtype)\n  );\n  assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n  v1.x; // 1\n  v1.distanceTo(v2); // ok\n  v1.toString(); // ok\n});\n\n```\n\nSharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.\n\nIf the engine had to deduplicate itself, you'd either need a user provided type identifier at \"prepare\" time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?\n\nBy having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">// vector2d.js\n// Each shared struct type, whether data only or &quot;prepared&quot; has its own unique type\nexport const vector2Dtype = SharedStructType.prepare([&quot;x&quot;, &quot;y&quot;]);\n\nconst _Vector2D = SharedStructType.getConstructor(vector2Dtype);\n\n// custom construction behavior\nexport function Vector2D(x = 0, y = 0) {\n  const _this = Reflect.construct(_Vector2D, [], new.target);\n  _this.x = x;\n  _this.y = y;\n  return _this;\n}\n\n// prototype methods\nVector2D.prototype.distanceTo = function (v) {\n  const dx = this.x - v.x;\n  const dy = this.y - v.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nSharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);\n\n// main.js\nimport { Vector2D, vector2DType } from &quot;./vector2d.js&quot;;\nconst v1 = new Vector2D(1, 2);\nconst worker = new Worker(&quot;worker.js&quot;);\nworker.postMessage([vector2DType, v1]);\n\n// worker.js\n// worker imports Vector2D, which causes registration as a side-effect.\nimport { Vector2D, vector2DType } from &quot;./vector2d.js&quot;;\n\nconst v2 = new Vector2D(3, 4);\n\nparentPort.on(&quot;message&quot;, ([mainVector2DType, v1]) =&gt; {\n  SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);\n  assert(mainVector2DType !== vector2DType);\n  assert(\n    SharedStructType.getConstructor(mainVector2DType) !==\n      SharedStructType.getConstructor(vector2Dtype)\n  );\n  assert(v1 instanceof Vector2D); // by virtue of sharing a prototype\n  v1.x; // 1\n  v1.distanceTo(v2); // ok\n  v1.toString(); // ok\n});\n\n</code></pre>\n<p>SharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.</p>\n<p>If the engine had to deduplicate itself, you'd either need a user provided type identifier at &quot;prepare&quot; time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?</p>\n<p>By having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$hvjgknJMdDSzY0wT0tSfVQQAC1aW1pyprtBZ9Phn2ss","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674845367279,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$nwPfbpGGFIunrabPcmAPjoMfQnZWdsUvdx1rVzdDI9I"}
]