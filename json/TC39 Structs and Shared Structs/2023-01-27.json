[
{"content":{"body":"So a shared struct instance has a stable identity across `postMessage`, right? To expand on my earlier idea, I think we don't need any stable identity for module blocks or even symbols, we can just use shared structs themselves to dynamically attach behavior to a shared struct kind, given some built-in wiring. Here is a gist where I explore that approach: https://gist.github.com/mhofman/aa23fcc88e1ccd031a3c34f88577eaf7\n\nIt does not require any new syntax, or extra magic in postMessage (like module blocks, or symbol identities being preserved). It only requires an automatically generated static property on shared struct classes that represent the kind, and some built-in behavior, plus the dynamic prototype lookup we discussed of course. I'm actually wondering if this could be prototyped (pun intented) in the current experiment.","format":"org.matrix.custom.html","formatted_body":"<p>So a shared struct instance has a stable identity across <code>postMessage</code>, right? To expand on my earlier idea, I think we don't need any stable identity for module blocks or even symbols, we can just use shared structs themselves to dynamically attach behavior to a shared struct kind, given some built-in wiring. Here is a gist where I explore that approach: https://gist.github.com/mhofman/aa23fcc88e1ccd031a3c34f88577eaf7</p>\n<p>It does not require any new syntax, or extra magic in postMessage (like module blocks, or symbol identities being preserved). It only requires an automatically generated static property on shared struct classes that represent the kind, and some built-in behavior, plus the dynamic prototype lookup we discussed of course. I'm actually wondering if this could be prototyped (pun intented) in the current experiment.</p>\n","msgtype":"m.text"},"ts":1674782260197,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$-uuI3KEqPrIQ_hFWvtbvtQ-FZSD0-ztDNtuRDLkY6sM"},
{"content":{"body":"Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type'.\n'type' here being the identity created by the `shared struct class` syntax (the fan-out case).\nFor the fan-in case, where a farm of workers start up on their own, each creating their own separate `shared struct class` (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker. ","format":"org.matrix.custom.html","formatted_body":"Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type'.<br>'type' here being the identity created by the <code>shared struct class</code> syntax (the fan-out case).<br>For the fan-in case, where a farm of workers start up on their own, each creating their own separate <code>shared struct class</code> (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","msgtype":"m.text"},"ts":1674815953491,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$Qr9M_P68WAnrPBa5u7RhRsl3u-NN_aAhyW4Au6mUakg"},
{"content":{"body":" * Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type' to get the capability of method dispatch. (also method chaining, but `|>` operator would also give that).\n'type' here being the identity created by the `shared struct class` syntax (the fan-out case).\nFor the fan-in case, where a farm of workers start up on their own, each creating their own separate `shared struct class` (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","format":"org.matrix.custom.html","formatted_body":" * Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type' to get the capability of method dispatch. (also method chaining, but <code>|&gt;</code> operator would also give that).<br>'type' here being the identity created by the <code>shared struct class</code> syntax (the fan-out case).<br>For the fan-in case, where a farm of workers start up on their own, each creating their own separate <code>shared struct class</code> (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","m.new_content":{"body":"Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type' to get the capability of method dispatch. (also method chaining, but `|>` operator would also give that).\n'type' here being the identity created by the `shared struct class` syntax (the fan-out case).\nFor the fan-in case, where a farm of workers start up on their own, each creating their own separate `shared struct class` (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","format":"org.matrix.custom.html","formatted_body":"Right, that would be similar to having 'known' static functions that operate on the type and each agent individually imports the module to use those functions, except with the power to per-realm/per-agent register those functions as the prototype to use for that 'type' to get the capability of method dispatch. (also method chaining, but <code>|&gt;</code> operator would also give that).<br>'type' here being the identity created by the <code>shared struct class</code> syntax (the fan-out case).<br>For the fan-in case, where a farm of workers start up on their own, each creating their own separate <code>shared struct class</code> (from the same module URL), as they are sent to a sink, the sink would need to register that one 'prototype' with the multiple 'type's that are received from each worker.","msgtype":"m.text"},"m.relates_to":{"event_id":"$Qr9M_P68WAnrPBa5u7RhRsl3u-NN_aAhyW4Au6mUakg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674816023011,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$lZdVzR-WY0TcuB2m5FtL-jNyd3kBy4V6do6BUeta4qo"},
{"content":{"body":"Right the fan in case would work too, there jsut would be different constructors and kinds, that each would have to be set to use the same prototype maker, or prototype implementation if the prototype doesn't care about exposing the realm local constructor.\n\nYou're right at the end of the day this boils down to the capability of setting the dynamic prototype to use for instances.","msgtype":"m.text"},"ts":1674820470010,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$51AwujArkzEHaxpK902sTbrTx16zEnOAOKDjnoVezf0"},
{"content":{"body":"and to also capture a bit of what was discussed on the call last night:","msgtype":"m.text"},"ts":1674822061015,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$9wrTX5-kXU7_lsgsZDHYORycbTIwlGRJa1kQ4cqB_vo"},
{"content":{"body":"- the goal is to have: the instance of a shared struct to exist in shared memory, and the reference to this is passed around directly. There is not a per-agent wrapper adding a layer of indirection for prop access.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>the goal is to have: the instance of a shared struct to exist in shared memory, and the reference to this is passed around directly. There is not a per-agent wrapper adding a layer of indirection for prop access.</li>\n</ul>\n","msgtype":"m.text"},"ts":1674822065879,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$HAngt-C3rkzatIKyCNB_YuNahWMs0Qb4KPJdyrxRdNs"},
{"content":{"body":"- if there is a dynamic lookup when \\[\\[prototype\\]\\] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by `getPrototypeOf` can observably change, which violates the current description of the sealed integrity level.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>if there is a dynamic lookup when [[prototype]] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by <code>getPrototypeOf</code> can observably change, which violates the current description of the sealed integrity level.</li>\n</ul>\n","msgtype":"m.text"},"ts":1674822257314,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$NryxlRbBfI4m5ZbvlKEy76vU1VGPhu566EMDjEi4l4g"},
{"content":{"body":" * - if there is a dynamic lookup when \\[\\[prototype\\]\\] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by `getPrototypeOf` can observably change, which violates the current description of the sealed integrity level.","format":"org.matrix.custom.html","formatted_body":" * <ul>\n<li>if there is a dynamic lookup when [[prototype]] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by <code>getPrototypeOf</code> can observably change, which violates the current description of the sealed integrity level.</li>\n</ul>\n","m.new_content":{"body":"- if there is a dynamic lookup when \\[\\[prototype\\]\\] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by `getPrototypeOf` can observably change, which violates the current description of the sealed integrity level.","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>if there is a dynamic lookup when [[prototype]] is accessed, if returned functions come from the calling realm then this means that a shared-struct passed between realms (node-VM, or same-origin-iframe, etc) then that means the value returned by <code>getPrototypeOf</code> can observably change, which violates the current description of the sealed integrity level.</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$NryxlRbBfI4m5ZbvlKEy76vU1VGPhu566EMDjEi4l4g","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674822287285,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$5ZNWcRhQ2A3_9PHFXhJ_Vq1MTAXnXxPL1eN-_cotHW8"},
{"content":{"body":"- cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache</li>\n</ul>\n","msgtype":"m.text"},"ts":1674822373169,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$1H5eoQfYYwF14jYxgh4m0iWB_5ay-gVj64_TC4uX5I0"},
{"content":{"body":" * - cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache","format":"org.matrix.custom.html","formatted_body":" * <ul>\n<li>cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache</li>\n</ul>\n","m.new_content":{"body":"- cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache","format":"org.matrix.custom.html","formatted_body":"<ul>\n<li>cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$1H5eoQfYYwF14jYxgh4m0iWB_5ay-gVj64_TC4uX5I0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674822388092,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$y8NeDC5sk-F4REWVpClyofOUMpX5WTThR0lFxxEn8V0"},
{"content":{"body":"> <@aclaymore:matrix.org> - the goal is to have: the instance of a shared struct to exist in shared memory, and the reference to this is passed around directly. There is not a per-agent wrapper adding a layer of indirection for prop access.\n\nI have actually been wondering about that, and whether that's an observable thing from the 262 spec point of view. The only program observable aspect of this is the preservation of identity through cross agent interactions, which is host defined anyway.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$HAngt-C3rkzatIKyCNB_YuNahWMs0Qb4KPJdyrxRdNs?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br /><ul>\n<li>the goal is to have: the instance of a shared struct to exist in shared memory, and the reference to this is passed around directly. There is not a per-agent wrapper adding a layer of indirection for prop access.</li>\n</ul>\n</blockquote></mx-reply>I have actually been wondering about that, and whether that's an observable thing from the 262 spec point of view. The only program observable aspect of this is the preservation of identity through cross agent interactions, which is host defined anyway.","m.relates_to":{"m.in_reply_to":{"event_id":"$HAngt-C3rkzatIKyCNB_YuNahWMs0Qb4KPJdyrxRdNs"}},"msgtype":"m.text"},"ts":1674822394204,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$Z0_9WM1V-jSW8z-5s-5k7_cKZMtXYRtkZbYBVsvjygw"},
{"content":{"body":"yes unlikely to be observable, but if that is an implementation goal then it limits which semantics are performant/simple/memory-efficient etc","msgtype":"m.text"},"ts":1674822460352,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$sWEybKoUki-o0BBlx4HhOGcQXzLmh1pn9sv06Pfb2nU"},
{"content":{"body":" * yes unlikely to be observable, but if that is an implementation goal then it limits which semantics are performant/simple/memory-efficient etc","m.new_content":{"body":"yes unlikely to be observable, but if that is an implementation goal then it limits which semantics are performant/simple/memory-efficient etc","msgtype":"m.text"},"m.relates_to":{"event_id":"$sWEybKoUki-o0BBlx4HhOGcQXzLmh1pn9sv06Pfb2nU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1674822493069,"senderName":"Ashley Claymore","senderId":"@aclaymore:matrix.org","id":"$h1cNG77CFYMdw24QylRQg6bzOFU7ZOo7RGy_yv9kMpY"},
{"content":{"body":"> <@aclaymore:matrix.org> - cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache\n\nNot really. If the prototype is set once and maybe throws when accessed before, then it's arguably sealed for that agent. As I mentioned, the fact there is a single reference shared between agents is an implementation detail IMO","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$1H5eoQfYYwF14jYxgh4m0iWB_5ay-gVj64_TC4uX5I0?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@aclaymore:matrix.org\">@aclaymore:matrix.org</a><br /><ul>\n<li>cont: if the lookup is 'cached' per-agent, maybe on first read, then this implies there is additional memory usage for a per-agent-per-instance cache</li>\n</ul>\n</blockquote></mx-reply>Not really. If the prototype is set once and maybe throws when accessed before, then it's arguably sealed for that agent. As I mentioned, the fact there is a single reference shared between agents is an implementation detail IMO","m.relates_to":{"m.in_reply_to":{"event_id":"$1H5eoQfYYwF14jYxgh4m0iWB_5ay-gVj64_TC4uX5I0"}},"msgtype":"m.text"},"ts":1674822501568,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$2wbijuwi750WD41R-whbN3gsqv7emHXr7_yL_ia0N_o"},
{"content":{"body":"Quoted the wrong message","msgtype":"m.text"},"ts":1674822538036,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$lVL6mmQ2a2FnjC_Oz9d7evtiW1a3SYPcItYGietZoys"},
{"content":{"body":"As for per instance memory, i believe it'd only be per kind / type memory, not per instance ","msgtype":"m.text"},"ts":1674822576116,"senderName":"Mathieu Hofman","senderId":"@mhofman:matrix.org","id":"$9oznH4P2LF9tExE8TaktyiMShCwlvHGrGV-oSpaT0Y4"},
{"content":{"body":"> <@mhofman:matrix.org> So a shared struct instance has a stable identity across `postMessage`, right? To expand on my earlier idea, I think we don't need any stable identity for module blocks or even symbols, we can just use shared structs themselves to dynamically attach behavior to a shared struct kind, given some built-in wiring. Here is a gist where I explore that approach: https://gist.github.com/mhofman/aa23fcc88e1ccd031a3c34f88577eaf7\n> \n> It does not require any new syntax, or extra magic in postMessage (like module blocks, or symbol identities being preserved). It only requires an automatically generated static property on shared struct classes that represent the kind, and some built-in behavior, plus the dynamic prototype lookup we discussed of course. I'm actually wondering if this could be prototyped (pun intented) in the current experiment.\n\nIs there a reason the identity needs to be a static property, or surfaced to the user at all, as opposed to an internal slot?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!fmLqwwrfASaCrzNjAk:matrix.org/$-uuI3KEqPrIQ_hFWvtbvtQ-FZSD0-ztDNtuRDLkY6sM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@mhofman:matrix.org\">@mhofman:matrix.org</a><br><p>So a shared struct instance has a stable identity across <code>postMessage</code>, right? To expand on my earlier idea, I think we don't need any stable identity for module blocks or even symbols, we can just use shared structs themselves to dynamically attach behavior to a shared struct kind, given some built-in wiring. Here is a gist where I explore that approach: https://gist.github.com/mhofman/aa23fcc88e1ccd031a3c34f88577eaf7</p>\n<p>It does not require any new syntax, or extra magic in postMessage (like module blocks, or symbol identities being preserved). It only requires an automatically generated static property on shared struct classes that represent the kind, and some built-in behavior, plus the dynamic prototype lookup we discussed of course. I'm actually wondering if this could be prototyped (pun intented) in the current experiment.</p>\n</blockquote></mx-reply>Is there a reason the identity needs to be a static property, or surfaced to the user at all, as opposed to an internal slot?","m.relates_to":{"m.in_reply_to":{"event_id":"$-uuI3KEqPrIQ_hFWvtbvtQ-FZSD0-ztDNtuRDLkY6sM"}},"msgtype":"m.text"},"ts":1674834364610,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$c3F7zrnNoc0PLhRf6LXug28Mw4n32kmrUvntGIZBe5s"}
]