[
{"content":{"body":"jschoi: Oh man, this diagram is great.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: Oh man, this diagram is great.","msgtype":"m.text"},"ts":1641319060857,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$dntKbrvTkdxgz69Mr4GmSPn5nGSitWPOHOuqk3_qB7Y"},
{"content":{"body":"Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?","format":"org.matrix.custom.html","formatted_body":"Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?","msgtype":"m.text"},"ts":1641319253632,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64"},
{"content":{"body":"> <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nAccording to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","msgtype":"m.text","m.relates_to":{"m.in_reply_to":{"event_id":"$mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64"}}},"ts":1641319442427,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$fxGFAtfuoEbGzu6Wa3BBQR4gfRvmEZ7oebL84zUF6A0"},
{"content":{"body":"* > <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nThe trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"* <mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>The trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","m.new_content":{"body":"> <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nThe trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>The trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","msgtype":"m.text"},"m.relates_to":{"event_id":"$fxGFAtfuoEbGzu6Wa3BBQR4gfRvmEZ7oebL84zUF6A0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641319452521,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$Gp33C5go4wXsxF-wJa1exlJnF7sPUjQo6dkeV6DiOG4"},
{"content":{"body":"* > <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nAccording to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"* <mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","m.new_content":{"body":"> <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nAccording to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","msgtype":"m.text"},"m.relates_to":{"event_id":"$fxGFAtfuoEbGzu6Wa3BBQR4gfRvmEZ7oebL84zUF6A0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641319468087,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$hO2LNwL_0H2ANSpxC4FCa8Oj_n6ja3mgnJZ97jRd-c4"},
{"content":{"body":"I'm talking at a higher level of parsing, before evaluation occurs.","msgtype":"m.text"},"ts":1641319477857,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$SH63RFy_ddD8NMMy2XpbBLPzub1tM8ZJ7vC0q9jfSbM"},
{"content":{"body":"Oh wait I see. ","format":"org.matrix.custom.html","formatted_body":"Oh wait I see.","msgtype":"m.text"},"ts":1641319483781,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$t3dq0rFOSTEVZopAtn7Hel0sESdplh4QBaG7avHjvgI"},
{"content":{"body":"Yeah, I see. ","format":"org.matrix.custom.html","formatted_body":"Yeah, I see.","msgtype":"m.text"},"ts":1641319490854,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$a635-6M_uhfQQ9Tf-nw66fTEjw2VNL5kgV8e6G834E4"},
{"content":{"body":"The ?: trinary really poisons single-colon usage.","msgtype":"m.text"},"ts":1641319507756,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$xyyxWbAPwe3WdpEg0dUgXWE-0MJ_qrx9HXBJ7x4q97Q"},
{"content":{"body":"TS and Flow are a nightmare to parse because of their usage of : for return type annotations (especially of arrow functions)","msgtype":"m.text"},"ts":1641319838200,"senderName":"Nicolò","senderId":"@nribaudo:igalia.com","id":"$J2w0bXtiCs7HEjytKP9h14QAN4RKKf2BCJMvBYvyXZE"},
{"content":{"body":"Hrmmm, Extension's `obj::foo = 1` syntax for setters doesn't generalize. `obj::foo::bar = 1` will call `foo` as a getter, then `bar` as a setter, meaning you still can't use it for functional data structures, which need to unfold the earlier parts of the assignment chain into get/set pairs.","format":"org.matrix.custom.html","formatted_body":"Hrmmm, Extension's <code>obj::foo = 1</code> syntax for setters doesn't generalize. <code>obj::foo::bar = 1</code> will call <code>foo</code> as a getter, then <code>bar</code> as a setter, meaning you still can't use it for functional data structures, which need to unfold the earlier parts of the assignment chain into get/set pairs.","msgtype":"m.text"},"ts":1641320356455,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$sAnFyEaCVZKFb26In4NvnrOcrvpgaHkSfk8FSOnm_9k"},
{"content":{"body":"Regarding `x?y::z:f()`, I figure that it would be a SyntaxError to include an unparenthesized trinary extensions expression inside a trinary conditional expression.\n\nRegarding `obj::foo::bar = 1`, yeah, that is a problem, and I don’t know how it could actually work.\n\nCC: HE Shi-Jun \n\n","format":"org.matrix.custom.html","formatted_body":"<p>Regarding <code>x?y::z:f()</code>, I figure that it would be a SyntaxError to include an unparenthesized trinary extensions expression inside a trinary conditional expression.</p>\n<p>Regarding <code>obj::foo::bar = 1</code>, yeah, that is a problem, and I don’t know how it could actually work.</p>\n<p>CC: <a href=\"https://matrix.to/#/@haxjs:matrix.org\">HE Shi-Jun</a></p>\n","msgtype":"m.text"},"ts":1641320589446,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$S6iayPT4Arrp5ugIf4aZMb7LuO5_vz4lyT1r5mRdmg8"},
{"content":{"body":"(By the way, Nicolò: if babel/babel#13973 looks good to you, I’m going to start work on `@[]`/`@{}` syntax for tuples/records soon based on that pull request.)","format":"org.matrix.custom.html","formatted_body":"(By the way, <a href=\"https://matrix.to/#/@nribaudo:igalia.com\">Nicolò</a>: if babel/babel#13973 looks good to you, I’m going to start work on <code>@[]</code>/<code>@{}</code> syntax for tuples/records soon based on that pull request.)","msgtype":"m.text"},"ts":1641320649896,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$4rDWBB7dFFvPZyCyFqKviSKZEiXPoVGAr_cK49hP2Pc"},
{"content":{"body":"Okay yeah, looking over it freshly and in depth now, I think Extension's only real wins are (a) reusing methods that happen to be generic enough to be useful on arbitrary objects (relatively rare outside of Array), and (b) adding getters/setters to objects without having to screw with the prototype.","msgtype":"m.text"},"ts":1641322472182,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$B17RqWHFWkjEbJ-iPLlhO65-BKsLTEcOiFSeg79BgUk"},
{"content":{"body":"The NS polymorphism letting you define a `function foo(arg0, arg1)` and then call it as `arg0::NS:meth(arg1)` isn't any better than pipe's `arg0 |> NS.meth(##, arg1)`, and pipe has less magic going on in that case.","format":"org.matrix.custom.html","formatted_body":"The NS polymorphism letting you define a <code>function foo(arg0, arg1)</code> and then call it as <code>arg0::NS:meth(arg1)</code> isn't any better than pipe's <code>arg0 |&gt; NS.meth(##, arg1)</code>, and pipe has less magic going on in that case.","msgtype":"m.text"},"ts":1641322526343,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$HKwih9fCJUw2j_azyydsiK2sCfAn6lq3ACpetPtNTMg"},
{"content":{"body":"The \"add a *method* to an existing class without screwing with the prototype\" use-case is handled just as well by pipe, as above.","format":"org.matrix.custom.html","formatted_body":"The &quot;add a <em>method</em> to an existing class without screwing with the prototype&quot; use-case is handled just as well by pipe, as above.","msgtype":"m.text"},"ts":1641322586184,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$dpq8pM8FqsV6jUKuSi6lpI34uUSgWE_cxx6vyFRbzDo"},
{"content":{"body":"And yeah, just confirmed for myself that existing getters/setters don't handle functional data structures well either; `x.foo.bar.baz` just calls the \"foo\" and \"bar\" getters then the \"baz\" setter and nothing else","format":"org.matrix.custom.html","formatted_body":"And yeah, just confirmed for myself that existing getters/setters don't handle functional data structures well either; <code>x.foo.bar.baz</code> just calls the &quot;foo&quot; and &quot;bar&quot; getters then the &quot;baz&quot; setter and nothing else","msgtype":"m.text"},"ts":1641322975858,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$UBBPvxO4sfAkb67_Hyke5uJC4pDK1GiLJRxEM-RMxqE"}
]