[
{"content":{"body":"jschoi: Oh man, this diagram is great.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: Oh man, this diagram is great.","msgtype":"m.text"},"ts":1641319060857,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$dntKbrvTkdxgz69Mr4GmSPn5nGSitWPOHOuqk3_qB7Y"},
{"content":{"body":"Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?","format":"org.matrix.custom.html","formatted_body":"Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?","msgtype":"m.text"},"ts":1641319253632,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64"},
{"content":{"body":"> <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nAccording to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","msgtype":"m.text","m.relates_to":{"m.in_reply_to":{"event_id":"$mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64"}}},"ts":1641319442427,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$fxGFAtfuoEbGzu6Wa3BBQR4gfRvmEZ7oebL84zUF6A0"},
{"content":{"body":"* > <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nThe trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"* <mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>The trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","m.new_content":{"body":"> <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nThe trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>The trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","msgtype":"m.text"},"m.relates_to":{"event_id":"$fxGFAtfuoEbGzu6Wa3BBQR4gfRvmEZ7oebL84zUF6A0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641319452521,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$Gp33C5go4wXsxF-wJa1exlJnF7sPUjQo6dkeV6DiOG4"},
{"content":{"body":"* > <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nAccording to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"* <mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","m.new_content":{"body":"> <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?\n\nAccording to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU%3Amatrix.org/%24mF_952EznCuNAuFEMxMVr8xrLthmYG0iUnU5UyPt-64\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is <code>x?y::z:f()</code> equal to <code>x ? (y::z:f())</code> or <code>x ? (y::z) : f()</code>? Does it depend on whether there's a trailing <code>: elseVal</code> afterwards?</blockquote></mx-reply>According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not.","msgtype":"m.text"},"m.relates_to":{"event_id":"$fxGFAtfuoEbGzu6Wa3BBQR4gfRvmEZ7oebL84zUF6A0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641319468087,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$hO2LNwL_0H2ANSpxC4FCa8Oj_n6ja3mgnJZ97jRd-c4"},
{"content":{"body":"I'm talking at a higher level of parsing, before evaluation occurs.","msgtype":"m.text"},"ts":1641319477857,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$SH63RFy_ddD8NMMy2XpbBLPzub1tM8ZJ7vC0q9jfSbM"},
{"content":{"body":"Oh wait I see. ","format":"org.matrix.custom.html","formatted_body":"Oh wait I see.","msgtype":"m.text"},"ts":1641319483781,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$t3dq0rFOSTEVZopAtn7Hel0sESdplh4QBaG7avHjvgI"},
{"content":{"body":"Yeah, I see. ","format":"org.matrix.custom.html","formatted_body":"Yeah, I see.","msgtype":"m.text"},"ts":1641319490854,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$a635-6M_uhfQQ9Tf-nw66fTEjw2VNL5kgV8e6G834E4"},
{"content":{"body":"The ?: trinary really poisons single-colon usage.","msgtype":"m.text"},"ts":1641319507756,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$xyyxWbAPwe3WdpEg0dUgXWE-0MJ_qrx9HXBJ7x4q97Q"},
{"content":{"body":"TS and Flow are a nightmare to parse because of their usage of : for return type annotations (especially of arrow functions)","msgtype":"m.text"},"ts":1641319838200,"senderName":"Nicolò","senderId":"@nribaudo:igalia.com","id":"$J2w0bXtiCs7HEjytKP9h14QAN4RKKf2BCJMvBYvyXZE"},
{"content":{"body":"Hrmmm, Extension's `obj::foo = 1` syntax for setters doesn't generalize. `obj::foo::bar = 1` will call `foo` as a getter, then `bar` as a setter, meaning you still can't use it for functional data structures, which need to unfold the earlier parts of the assignment chain into get/set pairs.","format":"org.matrix.custom.html","formatted_body":"Hrmmm, Extension's <code>obj::foo = 1</code> syntax for setters doesn't generalize. <code>obj::foo::bar = 1</code> will call <code>foo</code> as a getter, then <code>bar</code> as a setter, meaning you still can't use it for functional data structures, which need to unfold the earlier parts of the assignment chain into get/set pairs.","msgtype":"m.text"},"ts":1641320356455,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$sAnFyEaCVZKFb26In4NvnrOcrvpgaHkSfk8FSOnm_9k"},
{"content":{"body":"Regarding `x?y::z:f()`, I figure that it would be a SyntaxError to include an unparenthesized trinary extensions expression inside a trinary conditional expression.\n\nRegarding `obj::foo::bar = 1`, yeah, that is a problem, and I don’t know how it could actually work.\n\nCC: HE Shi-Jun \n\n","format":"org.matrix.custom.html","formatted_body":"<p>Regarding <code>x?y::z:f()</code>, I figure that it would be a SyntaxError to include an unparenthesized trinary extensions expression inside a trinary conditional expression.</p>\n<p>Regarding <code>obj::foo::bar = 1</code>, yeah, that is a problem, and I don’t know how it could actually work.</p>\n<p>CC: <a href=\"https://matrix.to/#/@haxjs:matrix.org\">HE Shi-Jun</a></p>\n","msgtype":"m.text"},"ts":1641320589446,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$S6iayPT4Arrp5ugIf4aZMb7LuO5_vz4lyT1r5mRdmg8"},
{"content":{"body":"(By the way, Nicolò: if babel/babel#13973 looks good to you, I’m going to start work on `@[]`/`@{}` syntax for tuples/records soon based on that pull request.)","format":"org.matrix.custom.html","formatted_body":"(By the way, <a href=\"https://matrix.to/#/@nribaudo:igalia.com\">Nicolò</a>: if babel/babel#13973 looks good to you, I’m going to start work on <code>@[]</code>/<code>@{}</code> syntax for tuples/records soon based on that pull request.)","msgtype":"m.text"},"ts":1641320649896,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$4rDWBB7dFFvPZyCyFqKviSKZEiXPoVGAr_cK49hP2Pc"},
{"content":{"body":"Okay yeah, looking over it freshly and in depth now, I think Extension's only real wins are (a) reusing methods that happen to be generic enough to be useful on arbitrary objects (relatively rare outside of Array), and (b) adding getters/setters to objects without having to screw with the prototype.","msgtype":"m.text"},"ts":1641322472182,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$B17RqWHFWkjEbJ-iPLlhO65-BKsLTEcOiFSeg79BgUk"},
{"content":{"body":"The NS polymorphism letting you define a `function foo(arg0, arg1)` and then call it as `arg0::NS:meth(arg1)` isn't any better than pipe's `arg0 |> NS.meth(##, arg1)`, and pipe has less magic going on in that case.","format":"org.matrix.custom.html","formatted_body":"The NS polymorphism letting you define a <code>function foo(arg0, arg1)</code> and then call it as <code>arg0::NS:meth(arg1)</code> isn't any better than pipe's <code>arg0 |&gt; NS.meth(##, arg1)</code>, and pipe has less magic going on in that case.","msgtype":"m.text"},"ts":1641322526343,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$HKwih9fCJUw2j_azyydsiK2sCfAn6lq3ACpetPtNTMg"},
{"content":{"body":"The \"add a *method* to an existing class without screwing with the prototype\" use-case is handled just as well by pipe, as above.","format":"org.matrix.custom.html","formatted_body":"The &quot;add a <em>method</em> to an existing class without screwing with the prototype&quot; use-case is handled just as well by pipe, as above.","msgtype":"m.text"},"ts":1641322586184,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$dpq8pM8FqsV6jUKuSi6lpI34uUSgWE_cxx6vyFRbzDo"},
{"content":{"body":"And yeah, just confirmed for myself that existing getters/setters don't handle functional data structures well either; `x.foo.bar.baz` just calls the \"foo\" and \"bar\" getters then the \"baz\" setter and nothing else","format":"org.matrix.custom.html","formatted_body":"And yeah, just confirmed for myself that existing getters/setters don't handle functional data structures well either; <code>x.foo.bar.baz</code> just calls the &quot;foo&quot; and &quot;bar&quot; getters then the &quot;baz&quot; setter and nothing else","msgtype":"m.text"},"ts":1641322975858,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$UBBPvxO4sfAkb67_Hyke5uJC4pDK1GiLJRxEM-RMxqE"},
{"content":{"body":"I imagine that whatever “property descriptor” objects that extensions use would actually have to be a new kind of recursive “reference record” object, but Hax might have something else to say about this.","msgtype":"m.text"},"ts":1641326646570,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$lKZB0LXtPWTXnxfnQOF-mtS2bDa8f7j9pMTAyoTzjus"},
{"content":{"body":"I wonder if it would be worth carving out January plenary time to present this diagram and discuss all of these proposals at once…","msgtype":"m.text"},"ts":1641326667052,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$fmZ6VssYGQ_ktpfgOlw7eit7FmryOTyqfW-2Dj1lxR0"},
{"content":{"body":"I think it would be, yeah","msgtype":"m.text"},"ts":1641327971731,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$GzKjiFlQVaFpcyUl8SHcfEL9wueg5T6BsLIjoaBk7w0"},
{"content":{"body":"Wrote up my thoughts after digesting this: https://gist.github.com/tabatkins/60d831d3e304e3e7316d473f5c1f269b","msgtype":"m.text"},"ts":1641327980427,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$-BIgtMvN6FM6P-Hqj2aqrQ1yQ8FzIoXqjszo0AQgdxg"},
{"content":{"body":"IIRC, ljharb's main desired use-case for bind-this was method extraction - I forget, was it for reliable use on objects of the type it was extracted from (just protecting against prototype mutation) or for calling on different types of objects?","format":"org.matrix.custom.html","formatted_body":"IIRC, <a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>'s main desired use-case for bind-this was method extraction - I forget, was it for reliable use on objects of the type it was extracted from (just protecting against prototype mutation) or for calling on different types of objects?","msgtype":"m.text"},"ts":1641328086088,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$DABDs_YdIEBKxx8p3wVrAeXE4Sg8Otr5DscWNNFT23w"},
{"content":{"body":"it's for whatever it takes for me to robustly invoke a function while providing the receiver\n\nmethod extraction + normal invocation achieves this. so too would syntax to call with a receiver.","msgtype":"m.text"},"ts":1641328402742,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$HRA1bISNVwU2e_pRCofUUar9biHppPx7j9kvfIDm0as"},
{"content":{"body":"My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)","msgtype":"m.text"},"ts":1641328418075,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$tbZoKpOT6veyCjzq5w7hYp3QH3c6P2LdGkhx3HWN1LQ"},
{"content":{"body":" * it's for whatever it takes for me to robustly invoke a function while providing the receiver\n\nmethod extraction + normal invocation achieves this. so too would syntax to call with a receiver.","m.new_content":{"body":"it's for whatever it takes for me to robustly invoke a function while providing the receiver\n\nmethod extraction + normal invocation achieves this. so too would syntax to call with a receiver.","msgtype":"m.text"},"m.relates_to":{"event_id":"$HRA1bISNVwU2e_pRCofUUar9biHppPx7j9kvfIDm0as","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328437267,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$FxMget8hfJarYAR4atFTt7lQE8KTO9I0BhjZK8lS5AE"},
{"content":{"body":"* My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)","m.new_content":{"body":"My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)","msgtype":"m.text"},"m.relates_to":{"event_id":"$tbZoKpOT6veyCjzq5w7hYp3QH3c6P2LdGkhx3HWN1LQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328462879,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$qFW3o7m42DITE4ZD-i5fMx0OqrdIhOTkEqlZbims2I4"},
{"content":{"body":"The sheer frequency of already-extant .call occurrences alone suggests that .call may be worth optimizing for better word order and conciseness. The pipe operator solves .call’s word order but not .call’s conciseness.","msgtype":"m.text"},"ts":1641328530048,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$EuntgU84uTyChnnBzdu8-6diYWVbbKIal3UHk9GguHo"},
{"content":{"body":"* My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined; they exceed even console.log occurrences. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)","m.new_content":{"body":"My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined; they exceed even console.log occurrences. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)","msgtype":"m.text"},"m.relates_to":{"event_id":"$tbZoKpOT6veyCjzq5w7hYp3QH3c6P2LdGkhx3HWN1LQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328549828,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$cFnfxqRNGeVbzjyx6a9Ogn79ITkY0FSCYELdqkn0R4w"},
{"content":{"body":"* My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined; .call occurrences exceed even console.log occurrences. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)","m.new_content":{"body":"My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined; .call occurrences exceed even console.log occurrences. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)","msgtype":"m.text"},"m.relates_to":{"event_id":"$tbZoKpOT6veyCjzq5w7hYp3QH3c6P2LdGkhx3HWN1LQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328558788,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$_XanQ1_q9IU4nm_pxK-3-H5Q-Fm0WZLuKPwZsL1wRhg"},
{"content":{"body":"* The sheer frequency of already-extant .call occurrences suggests that .call may be worth optimizing for better word order and conciseness. The pipe operator solves .call’s word order but not .call’s conciseness.","m.new_content":{"body":"The sheer frequency of already-extant .call occurrences suggests that .call may be worth optimizing for better word order and conciseness. The pipe operator solves .call’s word order but not .call’s conciseness.","msgtype":"m.text"},"m.relates_to":{"event_id":"$EuntgU84uTyChnnBzdu8-6diYWVbbKIal3UHk9GguHo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328642369,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$-8hZydKJNPJ3qCmGdiVWVGuI_f_uCMELeuvidHvM1Lk"},
{"content":{"body":"* The sheer frequency of already-extant .call occurrences alone suggests that .call may be worth optimizing for better word order and conciseness. The pipe operator solves .call’s word order but not .call’s conciseness.","m.new_content":{"body":"The sheer frequency of already-extant .call occurrences alone suggests that .call may be worth optimizing for better word order and conciseness. The pipe operator solves .call’s word order but not .call’s conciseness.","msgtype":"m.text"},"m.relates_to":{"event_id":"$EuntgU84uTyChnnBzdu8-6diYWVbbKIal3UHk9GguHo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328657523,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$wSxomdOJVKMdvzKKHFju9SlUq2qpDp2gI4DeoCpvjNc"},
{"content":{"body":"Some more details about found extant use cases for .call can be found starting at https://github.com/tc39/proposal-bind-this/issues/12#issuecomment-939400362.","msgtype":"m.text"},"ts":1641328733343,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$XMGl_CqlLLqxInhHHVFbpJeyOt1Q6p1p_XQ9ElVgEOE"},
{"content":{"body":"…which resulted in the results listed in https://github.com/tc39/proposal-bind-this/blob/main/README.md#bind-and-call-are-very-common.","msgtype":"m.text"},"ts":1641328787390,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$vN8FgfoO5A0AeOXJhzRQtmsh0uM7s68hRAyuqchtyYA"},
{"content":{"body":"To sum up, I think that the second and third use cases that you list for bind-this in the Gist are (perhaps surprisingly) not rare; they are in fact very frequent in existing code, and therefore they may be worth optimizing for. So I disagree with that part of the Gist, although this reasoning is obviously motivated by the fact that I am bind-this’s champion, haha.","msgtype":"m.text"},"ts":1641328855098,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$V2fYKVJxOlxP2OQ5p73wubL_ttLA3T0nAzLv-CQAc3s"},
{"content":{"body":"I think the rest of the Gist makes sense; great job in general.","msgtype":"m.text"},"ts":1641328861434,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$F8uo9B_WmA1l-CJX19WfBOp2dkN82hB2Vag8pJQzEGw"},
{"content":{"body":"* To sum up, I think that the second and third use cases that you list for bind-this in the Gist are (perhaps surprisingly) not rare; they are very frequent in existing code. So I disagree with that part of the Gist, although this reasoning is obviously motivated by the fact that I am bind-this’s champion, haha.","m.new_content":{"body":"To sum up, I think that the second and third use cases that you list for bind-this in the Gist are (perhaps surprisingly) not rare; they are very frequent in existing code. So I disagree with that part of the Gist, although this reasoning is obviously motivated by the fact that I am bind-this’s champion, haha.","msgtype":"m.text"},"m.relates_to":{"event_id":"$V2fYKVJxOlxP2OQ5p73wubL_ttLA3T0nAzLv-CQAc3s","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328878286,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$bjR28c1TXrEOI2o6CUPL4Tbevn_bh8AMAm2fT9rCiMo"},
{"content":{"body":"* I think the rest of the Gist makes sense; great job in general.","m.new_content":{"body":"I think the rest of the Gist makes sense; great job in general.","msgtype":"m.text"},"m.relates_to":{"event_id":"$F8uo9B_WmA1l-CJX19WfBOp2dkN82hB2Vag8pJQzEGw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328884788,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$lcZMyee7YFeWFTIF31dz-E1qVsBUC6xLuOR32p3ck5Y"},
{"content":{"body":"* To sum up, I think that the second and third use cases that you list for bind-this in the Gist are (perhaps surprisingly) not rare; they are in fact very frequent in existing code, and therefore they may be worth optimizing for. So I disagree with that part of the Gist, although this reasoning is obviously motivated by the fact that I am bind-this’s champion, haha.","m.new_content":{"body":"To sum up, I think that the second and third use cases that you list for bind-this in the Gist are (perhaps surprisingly) not rare; they are in fact very frequent in existing code, and therefore they may be worth optimizing for. So I disagree with that part of the Gist, although this reasoning is obviously motivated by the fact that I am bind-this’s champion, haha.","msgtype":"m.text"},"m.relates_to":{"event_id":"$V2fYKVJxOlxP2OQ5p73wubL_ttLA3T0nAzLv-CQAc3s","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328900766,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$WURcYFTsEvGNcEPmZrlK-tcgkzwKeuUd7F08dZBN8z4"},
{"content":{"body":"* My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined; .call occurrences exceed even console.log occurrences. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (You say that your second use case is rare, but it actually occurs quite frequently in the NPM dataset, from what I recall, but I’d need to recheck.)","m.new_content":{"body":"My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined; .call occurrences exceed even console.log occurrences. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (You say that your second use case is rare, but it actually occurs quite frequently in the NPM dataset, from what I recall, but I’d need to recheck.)","msgtype":"m.text"},"m.relates_to":{"event_id":"$tbZoKpOT6veyCjzq5w7hYp3QH3c6P2LdGkhx3HWN1LQ","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641328927006,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$bACbKKDJD5XcB2PmmxEj0KOPdXp3kypKTCCL4CwPSaQ"}
]