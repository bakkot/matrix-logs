[
{"content":{"body":"Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers, not `@`). \n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` decorators, and require parentheses to distinguish `@ as (class {})` and `@ as (function () {})`.","format":"org.matrix.custom.html","formatted_body":"<p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> decorators, and require parentheses to distinguish <code>@ as (class {})</code> and <code>@ as (function () {})</code>.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers, not `@`). \n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` decorators, and require parentheses to distinguish `@ as (class {})` and `@ as (function () {})`.","mimetype":"text/plain"},{"body":"<p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> decorators, and require parentheses to distinguish <code>@ as (class {})</code> and <code>@ as (function () {})</code>.</p>\n","mimetype":"text/html"}]},"ts":1648755175341,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$NUI_NMtcgeGohBKuFJecp1NRP0ow0q_JFZpFHbxk2FM"},
{"content":{"body":" * Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers or destructuring forms, not `@`).\n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` decorators, and require parentheses to distinguish `@ as (class {})` and `@ as (function () {})`.","format":"org.matrix.custom.html","formatted_body":" * <p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers or destructuring forms, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> decorators, and require parentheses to distinguish <code>@ as (class {})</code> and <code>@ as (function () {})</code>.</p>\n","m.new_content":{"body":"Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers or destructuring forms, not `@`).\n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` decorators, and require parentheses to distinguish `@ as (class {})` and `@ as (function () {})`.","format":"org.matrix.custom.html","formatted_body":"<p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers or destructuring forms, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> decorators, and require parentheses to distinguish <code>@ as (class {})</code> and <code>@ as (function () {})</code>.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers or destructuring forms, not `@`).\n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` decorators, and require parentheses to distinguish `@ as (class {})` and `@ as (function () {})`.","mimetype":"text/plain"},{"body":"<p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers or destructuring forms, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> decorators, and require parentheses to distinguish <code>@ as (class {})</code> and <code>@ as (function () {})</code>.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$NUI_NMtcgeGohBKuFJecp1NRP0ow0q_JFZpFHbxk2FM","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers or destructuring forms, not `@`).\n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` decorators, and require parentheses to distinguish `@ as (class {})` and `@ as (function () {})`.","mimetype":"text/plain"},{"body":" * <p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers or destructuring forms, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> decorators, and require parentheses to distinguish <code>@ as (class {})</code> and <code>@ as (function () {})</code>.</p>\n","mimetype":"text/html"}]},"ts":1648755695448,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$ZXNgfOK7NJe3f37vi_qG6WhhvGh8fwnDdqivmKPVIiQ"},
{"content":{"body":" * Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers or destructuring forms, not `@`).\n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` as decorator expressions, and we can require parentheses to distinguish them from `@ as (class {})` and `@ as (function () {})` using lookahead. There’s an example grammar in https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912.","format":"org.matrix.custom.html","formatted_body":" * <p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers or destructuring forms, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> as decorator expressions, and we can require parentheses to distinguish them from <code>@ as (class {})</code> and <code>@ as (function () {})</code> using lookahead. There’s an example grammar in https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912.</p>\n","m.new_content":{"body":"Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers or destructuring forms, not `@`).\n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` as decorator expressions, and we can require parentheses to distinguish them from `@ as (class {})` and `@ as (function () {})` using lookahead. There’s an example grammar in https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912.","format":"org.matrix.custom.html","formatted_body":"<p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers or destructuring forms, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> as decorator expressions, and we can require parentheses to distinguish them from <code>@ as (class {})</code> and <code>@ as (function () {})</code> using lookahead. There’s an example grammar in https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers or destructuring forms, not `@`).\n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` as decorator expressions, and we can require parentheses to distinguish them from `@ as (class {})` and `@ as (function () {})` using lookahead. There’s an example grammar in https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912.","mimetype":"text/plain"},{"body":"<p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers or destructuring forms, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> as decorator expressions, and we can require parentheses to distinguish them from <code>@ as (class {})</code> and <code>@ as (function () {})</code> using lookahead. There’s an example grammar in https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$NUI_NMtcgeGohBKuFJecp1NRP0ow0q_JFZpFHbxk2FM","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are `of` and `as`).\n\nThankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of `of` in `for` statements can only be identifiers or destructuring forms, not `@`).\n\nThe biggest issue is with any future infix operators that are also valid identifiers (like `as`), and we can just keep `@ as class {}` and `@ as function () {}` as decorator expressions, and we can require parentheses to distinguish them from `@ as (class {})` and `@ as (function () {})` using lookahead. There’s an example grammar in https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912.","mimetype":"text/plain"},{"body":" * <p>Waldemar made a comment showing his concerns at https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1084946624. They’re about distinguishing decorators from topic-then-infix-operators-that-are-also-valid-identifiers (examples he gave are <code>of</code> and <code>as</code>).</p>\n<p>Thankfully, as far as I can tell, they are not a problem; the example he gave already has a SyntaxError (the LHS of <code>of</code> in <code>for</code> statements can only be identifiers or destructuring forms, not <code>@</code>).</p>\n<p>The biggest issue is with any future infix operators that are also valid identifiers (like <code>as</code>), and we can just keep <code>@ as class {}</code> and <code>@ as function () {}</code> as decorator expressions, and we can require parentheses to distinguish them from <code>@ as (class {})</code> and <code>@ as (function () {})</code> using lookahead. There’s an example grammar in https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912.</p>\n","mimetype":"text/html"}]},"ts":1648755960282,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$lghE5SHmDvnjXlr5clTnjBYZXmTXfYtHnslPKIfb1cI"},
{"content":{"body":"jschoi: I think `@in x` is currently valid and it would be quite surprising if it wasn't! The lexical grammar in the spec (ignoring oddities like regexps) eagerly consumes the tokens as long as they match, so `@in x` is tokenized as `@`,`in`,`x`. Then the syntactic grammar sees `@`,`in` and `x`, without any whitespace knowledge.\n\nThere are only two places where witespaces matter:\n- in private identifiers, because `#foo` is parsed as a single token\n- between an identifier and a keyword, because the tokenizer is eager and would parse it as a single identifier","format":"org.matrix.custom.html","formatted_body":"<p><a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: I think <code>@in x</code> is currently valid and it would be quite surprising if it wasn't! The lexical grammar in the spec (ignoring oddities like regexps) eagerly consumes the tokens as long as they match, so <code>@in x</code> is tokenized as <code>@</code>,<code>in</code>,<code>x</code>. Then the syntactic grammar sees <code>@</code>,<code>in</code> and <code>x</code>, without any whitespace knowledge.</p>\n<p>There are only two places where witespaces matter:</p>\n<ul>\n<li>in private identifiers, because <code>#foo</code> is parsed as a single token</li>\n<li>between an identifier and a keyword, because the tokenizer is eager and would parse it as a single identifier</li>\n</ul>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"jschoi: I think `@in x` is currently valid and it would be quite surprising if it wasn't! The lexical grammar in the spec (ignoring oddities like regexps) eagerly consumes the tokens as long as they match, so `@in x` is tokenized as `@`,`in`,`x`. Then the syntactic grammar sees `@`,`in` and `x`, without any whitespace knowledge.\n\nThere are only two places where witespaces matter:\n- in private identifiers, because `#foo` is parsed as a single token\n- between an identifier and a keyword, because the tokenizer is eager and would parse it as a single identifier","mimetype":"text/plain"},{"body":"<p><a href=\"https://matrix.to/#/@jschoi:matrix.org\">jschoi</a>: I think <code>@in x</code> is currently valid and it would be quite surprising if it wasn't! The lexical grammar in the spec (ignoring oddities like regexps) eagerly consumes the tokens as long as they match, so <code>@in x</code> is tokenized as <code>@</code>,<code>in</code>,<code>x</code>. Then the syntactic grammar sees <code>@</code>,<code>in</code> and <code>x</code>, without any whitespace knowledge.</p>\n<p>There are only two places where witespaces matter:</p>\n<ul>\n<li>in private identifiers, because <code>#foo</code> is parsed as a single token</li>\n<li>between an identifier and a keyword, because the tokenizer is eager and would parse it as a single identifier</li>\n</ul>\n","mimetype":"text/html"}]},"ts":1648765710895,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$-o6pFM4zXtHKSwisym7XIIuZkbsVl-4aU1oznSXoJVc"}
]