[
{"content":{"body":"> Call-this + pipe have the advantage of no overlap,\n\nI think I just refuted that.","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>Call-this + pipe have the advantage of no overlap,</p>\n</blockquote>\n<p>I think I just refuted that.</p>\n","msgtype":"m.text"},"ts":1641513638671,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$uS30BK5s58tBu-oFnELbV2T4acFkIweiR2MOKUby-io"},
{"content":{"body":"It exactly overlaps with pipeline+uncurry","msgtype":"m.text"},"ts":1641513651802,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$zbwkifdHAJdveIQCdMZxFSXVblxaFVQjR6LVccL1Yls"},
{"content":{"body":"No? You said call-this overlaps with uncurry.","msgtype":"m.text"},"ts":1641513654218,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$0dfoOnfc3IVownESu0_g8d2krfk9DtLA9O3khWrTWqw"},
{"content":{"body":"Right, because call-this and uncurry are the same thing in different syntaxes.","msgtype":"m.text"},"ts":1641513667738,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$VodLjIZM36P4otm6pBa-C8-ULgA1GA6-AI9iQ281Ya4"},
{"content":{"body":"My goal here is to allow fluent APIs with acceptable synatx","msgtype":"m.text"},"ts":1641513786991,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$BS7OL8PCiI8dG_piHIFCbHBfO0nV1v7zKQrDaDiRruE"},
{"content":{"body":"is heading home for the day, will have to continue later","msgtype":"m.emote"},"ts":1641513801016,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$4tu9pAIvnKqFJSlEYxv2TCiWN42OdqKUrIVN43OBmIM"},
{"content":{"body":"I don't think pipeline and normal methods looks appealing","msgtype":"m.text"},"ts":1641513822637,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$7oSo1onqtZke9skKfKKJ9fvLVv13X8MOh7fyJm5yii0"},
{"content":{"body":"Pipeline as a chain of free functions is fine","msgtype":"m.text"},"ts":1641513830492,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$EB7sL3Cq4gDFk0vMA02FBMxpXkZhxel_snJP9_wgr1k"},
{"content":{"body":"But mixing in a chained method on an object in the pipe and it starts to have warts","msgtype":"m.text"},"ts":1641513845942,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$ZcQo2xfpM5Yn14SkPQBoJfemC5xF6e06FVyg16cQnwk"},
{"content":{"body":"Mixing methods and bind-ops works perfectly","msgtype":"m.text"},"ts":1641513860806,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$CIg9a2qVfnBy_fSO2CJEMlkfLavQ8OXpW8mTcrFCUtI"},
{"content":{"body":"pipeline can’t handle call-this/uncurry without a special operator ","format":"org.matrix.custom.html","formatted_body":"pipeline can’t handle call-this/uncurry without a special operator","msgtype":"m.text"},"ts":1641531221666,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$O5Bb9g0ySjmmBJ8Kq2QAn1UBdpLTryKo9jT-KVsPxxA"},
{"content":{"body":"the operator could be call-this, or bind-this, or something else, but it can’t be done with pipeline alone ","format":"org.matrix.custom.html","formatted_body":"the operator could be call-this, or bind-this, or something else, but it can’t be done with pipeline alone","msgtype":"m.text"},"ts":1641531240935,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$zRxSV0hSqH4FivB_ImkPD0M1jd0ZpZBUxWQbmDIPdEU"},
{"content":{"body":"i agree that bind-this is the one that fits into an OOP method chain without pipeline, which is useful.","msgtype":"m.text"},"ts":1641531305477,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$LXFLSsoCY7YPpI8Zv-uBx1Hi_ILhpyPuyTTHzsGPqBw"},
{"content":{"body":"So the issue that's gonna continue to bite is that, from the feedback we've gotten, having bind-this able to do essentially the same thing as pipe is a Problem. It might turn out to be sufficiently okay to look past, but as it is this is the precise sort of overlap that has been called out as making committee members uncomfortable.","msgtype":"m.text"},"ts":1641586049792,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$GVZ9cjTT0133nUyYjGzgqCVeL2OUxloMkbioNsoxLfo"},
{"content":{"body":"And the arguments against \"fluent API via bind-this\" are *precisely* the same arguments against \"fluent API via F# pipe\", which is that it will encourage authors to write libraries intended specifically to be called this way, which means they're harder or awkward to call in the traditional way, and won't work with any other feature that expects functions, like something that takes callbacks - they'll have to be wrapped in an arrow func instead. (For example, it won't work with PFA, if you want the receiver to be the thing placehold'd.)","format":"org.matrix.custom.html","formatted_body":"And the arguments against &quot;fluent API via bind-this&quot; are <em>precisely</em> the same arguments against &quot;fluent API via F# pipe&quot;, which is that it will encourage authors to write libraries intended specifically to be called this way, which means they're harder or awkward to call in the traditional way, and won't work with any other feature that expects functions, like something that takes callbacks - they'll have to be wrapped in an arrow func instead. (For example, it won't work with PFA, if you want the receiver to be the thing placehold'd.)","msgtype":"m.text"},"ts":1641586217268,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$3W9mT68SwCgv5i_B9u9o1CBPvc8PGsxTU1rkx8Mdjs4"},
{"content":{"body":"Part of the reason we fought so hard for Hack pipes is precisely because it works reasonably well for *all* of these cases. Yes, it's not the local minimum for fluent APIs, but it's hovering just outside of it, and without the additional downsides that come from seeking that minimum.","format":"org.matrix.custom.html","formatted_body":"Part of the reason we fought so hard for Hack pipes is precisely because it works reasonably well for <em>all</em> of these cases. Yes, it's not the local minimum for fluent APIs, but it's hovering just outside of it, and without the additional downsides that come from seeking that minimum.","msgtype":"m.text"},"ts":1641586287079,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$VDOliHjWtrFDTQvH9mqngYlXOlQ9K5iBwOr6cv3fHsA"},
{"content":{"body":"And I'll note that in the previous code sample, the pipe code was written badly. When done correctly, it's roughly identical to the bind-this code:\n\n```js\narray\n  .filter(...)\n  |> uniq(##)\n  .find(...)\n  .something();\n```","format":"org.matrix.custom.html","formatted_body":"<p>And I'll note that in the previous code sample, the pipe code was written badly. When done correctly, it's roughly identical to the bind-this code:</p>\n<pre><code class=\"language-js\">array\n  .filter(...)\n  |&gt; uniq(##)\n  .find(...)\n  .something();\n</code></pre>\n","msgtype":"m.text"},"ts":1641586442385,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$aB6TUqFjWvGZ-ZK6vclGD3VmZTK8tuPJcZtt8of8ZI4"},
{"content":{"body":"The only difference (an unavoidable one) is, as always, having to put the topic value in the arglist, rather than it being passed implicitly in some way. But that's it, vs the extra code and additional indentation that the previous code sample unnecessarily burdened it with.","msgtype":"m.text"},"ts":1641586514283,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$mFcHMPbh-MOx6BcKl012pxodhHdgTwwu8u7-uqhGcTc"},
{"content":{"body":"that pipe example is fine with me, to be sure. however, if `uniq` expects a `this` value then you'd have to (with your proposal) do this:\n```\narray\n  .filter(...)\n  |> uniq::(##)\n  .find(...)\n  .something();\n```\n\ninstead of, as with the bind-this proposal:\n```\narray\n  .filter(...)\n  |> ##::uniq()\n  .find(...)\n  .something();\n```","format":"org.matrix.custom.html","formatted_body":"<p>that pipe example is fine with me, to be sure. however, if <code>uniq</code> expects a <code>this</code> value then you'd have to (with your proposal) do this:</p>\n<pre><code>array\n  .filter(...)\n  |&gt; uniq::(##)\n  .find(...)\n  .something();\n</code></pre>\n<p>instead of, as with the bind-this proposal:</p>\n<pre><code>array\n  .filter(...)\n  |&gt; ##::uniq()\n  .find(...)\n  .something();\n</code></pre>\n","msgtype":"m.text"},"ts":1641588991538,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$K1XjM30iFHrtFi3DxqzH8W3N2Qop6udrjaVdj6EPxkk"},
{"content":{"body":"Yes, so you, of course, would not write a library with `export function uniq() { return [...new Set(this)]; }`, you'd write it as `export function uniq(arr) {...}`","format":"org.matrix.custom.html","formatted_body":"Yes, so you, of course, would not write a library with <code>export function uniq() { return [...new Set(this)]; }</code>, you'd write it as <code>export function uniq(arr) {...}</code>","msgtype":"m.text"},"ts":1641592476779,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$NCFXpo92Nl1vdYlXZygOteRr8wwyEzFpVy8fjY-qNWI"},
{"content":{"body":"Rather than there now being *three* potential ways to write a function (as a method, as a this-using free fucntion, or as a this-less free function), we stick with the two that we currently  have.","format":"org.matrix.custom.html","formatted_body":"Rather than there now being <em>three</em> potential ways to write a function (as a method, as a this-using free fucntion, or as a this-less free function), we stick with the two that we currently  have.","msgtype":"m.text"},"ts":1641592519879,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$qxkxHv2FLPmc88Y7FzJ91giHi-lxwKt0tWx7OeazvgQ"},
{"content":{"body":"But if you'd extracted `uniq()` from a class because of robustness, then yes, you'd write it in the first style with the call-this operator.","format":"org.matrix.custom.html","formatted_body":"But if you'd extracted <code>uniq()</code> from a class because of robustness, then yes, you'd write it in the first style with the call-this operator.","msgtype":"m.text"},"ts":1641593308802,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$SNQ71bnmbHOhsBZXtmBbs1e6CXjr9B3Ytlj7zWCOJWA"},
{"content":{"body":"The alternative is an uncurry operator that just produces a fresh function a la `fn.call.bind(fn)`","format":"org.matrix.custom.html","formatted_body":"The alternative is an uncurry operator that just produces a fresh function a la <code>fn.call.bind(fn)</code>","msgtype":"m.text"},"ts":1641593368714,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$VqdgoKNo4tRi-QKxrkwiQfBpRUc1ib82mO5rFt_yyAo"},
{"content":{"body":"Then it's just `|> uniq(##)`","format":"org.matrix.custom.html","formatted_body":"Then it's just <code>|&gt; uniq(##)</code>","msgtype":"m.text"},"ts":1641593378567,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$WpOPxZRi87F0zQsW5v1XY-07iyzky_ckxiS4wbb5jgY"},
{"content":{"body":"I am neutral between bind-this `receiver |> #::fn()` and call-this `receiver |> fn@(#)`, but I rather have either than a demethodize operator. ","format":"org.matrix.custom.html","formatted_body":"I am neutral between bind-this <code>receiver |&gt; #::fn()</code> and call-this <code>receiver |&gt; fn@(#)</code>, but I rather have either than a demethodize operator.","msgtype":"m.text"},"ts":1641593772629,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$0PWSNdu6h1JTi8KAUiViHxLkV9IycgK1jGUPZzjNYG4"},
{"content":{"body":"Those three already exist","msgtype":"m.text"},"ts":1641595156162,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$TWdvbTMWAgPIPxgzdH6ojAVlxDhukwuY1jlDr3Z6eJI"},
{"content":{"body":"You can't just say things like that when you mean \"you can do these by calling Function methods\" ^_^","msgtype":"m.text"},"ts":1641595228563,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$9bsLOhhqzyB9tW7g1i657S9MAa5G55DywMXCzQwghqQ"},
{"content":{"body":"* (I am neutral between a bind-this operator `receiver |> #::fn()` and a call-this operator `receiver |> fn::(#)`, but I would rather have either than a demethodize operator `receiver |> (::fn)(#)`.)","format":"org.matrix.custom.html","formatted_body":"* (I am neutral between a bind-this operator <code>receiver |&gt; #::fn()</code> and a call-this operator <code>receiver |&gt; fn::(#)</code>, but I would rather have either than a demethodize operator <code>receiver |&gt; (::fn)(#)</code>.)","m.new_content":{"body":"(I am neutral between a bind-this operator `receiver |> #::fn()` and a call-this operator `receiver |> fn::(#)`, but I would rather have either than a demethodize operator `receiver |> (::fn)(#)`.)","format":"org.matrix.custom.html","formatted_body":"(I am neutral between a bind-this operator <code>receiver |&gt; #::fn()</code> and a call-this operator <code>receiver |&gt; fn::(#)</code>, but I would rather have either than a demethodize operator <code>receiver |&gt; (::fn)(#)</code>.)","msgtype":"m.text"},"m.relates_to":{"event_id":"$0PWSNdu6h1JTi8KAUiViHxLkV9IycgK1jGUPZzjNYG4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1641598612385,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$rZPClXmQfcAxZ9hsD6QxrVV_fyw-Ba06XLoc-ZTvMi4"},
{"content":{"body":"> <@tabatkins:matrix.org> And I'll note that in the previous code sample, the pipe code was written badly. When done correctly, it's roughly identical to the bind-this code:\n> \n> ```js\n> array\n>   .filter(...)\n>   |> uniq(##)\n>   .find(...)\n>   .something();\n> ```\n\nOk, that looks a little better.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU:matrix.org/$aB6TUqFjWvGZ-ZK6vclGD3VmZTK8tuPJcZtt8of8ZI4?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br><p>And I'll note that in the previous code sample, the pipe code was written badly. When done correctly, it's roughly identical to the bind-this code:</p>\n<pre><code class=\"language-js\">array\n  .filter(...)\n  |&gt; uniq(##)\n  .find(...)\n  .something();\n</code></pre>\n</blockquote></mx-reply>Ok, that looks a little better.","m.relates_to":{"m.in_reply_to":{"event_id":"$aB6TUqFjWvGZ-ZK6vclGD3VmZTK8tuPJcZtt8of8ZI4"}},"msgtype":"m.text"},"ts":1641598669361,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$22U50j0Y_csKs7J0qp_LBnSORIYwmAaF6u14-wWpa0M"},
{"content":{"body":"> <@tabatkins:matrix.org> And the arguments against \"fluent API via bind-this\" are *precisely* the same arguments against \"fluent API via F# pipe\", which is that it will encourage authors to write libraries intended specifically to be called this way, which means they're harder or awkward to call in the traditional way, and won't work with any other feature that expects functions, like something that takes callbacks - they'll have to be wrapped in an arrow func instead. (For example, it won't work with PFA, if you want the receiver to be the thing placehold'd.)\n\nI don't think this is true. F# coded a very specific (very restrictive) only-one-arg style that Hack style avoids. Bind-op doesn't suffer from this, since args can be passed. It just happens that Bind-op also doesn't require a topic token to run.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!mjlgwjKxWUpgSgeCQU:matrix.org/$3W9mT68SwCgv5i_B9u9o1CBPvc8PGsxTU1rkx8Mdjs4?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>And the arguments against \"fluent API via bind-this\" are <em>precisely</em> the same arguments against \"fluent API via F# pipe\", which is that it will encourage authors to write libraries intended specifically to be called this way, which means they're harder or awkward to call in the traditional way, and won't work with any other feature that expects functions, like something that takes callbacks - they'll have to be wrapped in an arrow func instead. (For example, it won't work with PFA, if you want the receiver to be the thing placehold'd.)</blockquote></mx-reply>I don't think this is true. F# coded a very specific (very restrictive) only-one-arg style that Hack style avoids. Bind-op doesn't suffer from this, since args can be passed. It just happens that Bind-op also doesn't require a topic token to run.","m.relates_to":{"m.in_reply_to":{"event_id":"$3W9mT68SwCgv5i_B9u9o1CBPvc8PGsxTU1rkx8Mdjs4"}},"msgtype":"m.text"},"ts":1641598828959,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$cV38rE9kcpogcGm-CeuCGmzah0VjFW65UzF53jnrLa0"},
{"content":{"body":"No, F#-style just requires your function to *accept* one of its arguments as a second, unary call. There's no fundamental difference between `fn(a, b)(c)` and `c::fn(a, b)`, they're both just accepting one of their arguments in a special way that's not part of the arglist.","format":"org.matrix.custom.html","formatted_body":"No, F#-style just requires your function to <em>accept</em> one of its arguments as a second, unary call. There's no fundamental difference between <code>fn(a, b)(c)</code> and <code>c::fn(a, b)</code>, they're both just accepting one of their arguments in a special way that's not part of the arglist.","msgtype":"m.text"},"ts":1641598907324,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$OvPpcsajfebIVUNTrDWwLEMCb0YBXHzh5hrsG0HlDGE"},
{"content":{"body":"There's a huge difference with creating a closure and passing arguments to a single function.","msgtype":"m.text"},"ts":1641598954289,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$Y2K29WahEQPLbKQKf6xUgxnrzYJFg17hOAB8m33vSHM"},
{"content":{"body":"`function fn(a, b) { this=>{...}}` can even have the exact same body as a this-using function. ^_^","format":"org.matrix.custom.html","formatted_body":"<code>function fn(a, b) { this=&gt;{...}}</code> can even have the exact same body as a this-using function. ^_^","msgtype":"m.text"},"ts":1641598983479,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$GmFeoMBd0adN31vdqNpLVQ48LBCzX7o38PH8-QIQGhY"},
{"content":{"body":"There's not really? Like, sure, yeah, they're different, and there's internal stuff. But semantically they're the same. JS distinguishes them; Haskell doesn't; it's just a syntax choice.","msgtype":"m.text"},"ts":1641599041891,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$tK3O-Nf1rQ8vY646gJr3lu7KPDbdzA1Auf-g8qlz1KA"},
{"content":{"body":"We shot down F# because of the temporary closures it requires to do anything non-trivial. Even if the runtime output would be the same, I don't think it's fair to compare bind-op to F#.","msgtype":"m.text"},"ts":1641599208578,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$PWOEkkPSlaggZCDtuEHqUgyEcsIFjZKa4Mi5H9cUxYE"}
]