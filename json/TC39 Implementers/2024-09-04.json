[
{"content":{"body":"> <@ljharb:matrix.org> i would assume that whatever hasOwnProperty does to check that the object has the property is the same thing hasOwn would do\n\nyeah not sure about that, a bit strange","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!eHkwtWesRXuxHVBgDG:matrix.org/$8zN3SVnrGQe6VRGD6X_W2ahyExEXhk-4cW0H3j6BbM4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>i would assume that whatever hasOwnProperty does to check that the object has the property is the same thing hasOwn would do</blockquote></mx-reply>yeah not sure about that, a bit strange","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$8zN3SVnrGQe6VRGD6X_W2ahyExEXhk-4cW0H3j6BbM4"}},"msgtype":"m.text"},"ts":1725408101813,"senderName":"canadahonk","senderId":"@canadahonk:matrix.org","id":"$HTO85DslIhQs4JtngVCNf8-qhwNA6S1sP7oAv4JX0nM"},
{"content":{"body":"the two are basically identical per spec iirc","m.mentions":{},"msgtype":"m.text"},"ts":1725408156584,"senderName":"canadahonk","senderId":"@canadahonk:matrix.org","id":"$UIAwHdrGI3o-BOz0ZUTlmpm1ocEFF7kWXNwT7CKM5cw"},
{"content":{"body":"yeah (https://tc39.es/ecma262/#sec-object.hasown, https://tc39.es/ecma262/#sec-object.prototype.hasownproperty)","m.mentions":{},"msgtype":"m.text"},"ts":1725408178473,"senderName":"canadahonk","senderId":"@canadahonk:matrix.org","id":"$BJRPm9ucYtrzv73aXFywMIVEtCHYXW4WNEnDFz_FVCs"},
{"content":{"body":"I think that’s just a very peculiar case of Node.js core where there isn’t much benefit to change existing code to use Object.hasOwn() - if the code was written from scratch it probably would’ve used ObjectHasOwn because why not, the perf difference doesn’t really matter. But then if the code has always been using ObjectPrototypeHasOwnProperty then you also get the why if you want to change it, and the usual reasons you give to user code doesn’t apply to Node.js core: you use it to prevent a prototype lookup, well but in Node.js core that is already prevented with the primordials machinery, what’s more the machinery is built into a snapshot so the bind was done in build time, not runtime. This doesn’t generalize to normal user code, and isn’t much motivation for the VM to do anything per-se. ","format":"org.matrix.custom.html","formatted_body":"I think that’s just a very peculiar case of Node.js core where there isn’t much benefit to change existing code to use Object.hasOwn() - if the code was written from scratch it probably would’ve used ObjectHasOwn because why not, the perf difference doesn’t really matter. But then if the code has always been using ObjectPrototypeHasOwnProperty then you also get the why if you want to change it, and the usual reasons you give to user code doesn’t apply to Node.js core: you use it to prevent a prototype lookup, well but in Node.js core that is already prevented with the primordials machinery, what’s more the machinery is built into a snapshot so the bind was done in build time, not runtime. This doesn’t generalize to normal user code, and isn’t much motivation for the VM to do anything per-se.","msgtype":"m.text"},"ts":1725415809413,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$XIas7NAAEP6yrPKPx8_HoinV7gEK-pPuSIDV-VQuWY0"},
{"content":{"body":"Also mass refactoring in Node.js core has a uncommon demotivating cost which is the LTS backport cost (imagine the conflicts this can cause when back porting the patch and any patch that touch related lines to v18, v20 and v22). This cost doesn’t generalize to uh…any software that doesn’t need to maintain three simultaneous LTS releases that will be alive for years. So it’s just an odd one out.","msgtype":"m.text"},"ts":1725416581835,"senderName":"joyee","senderId":"@qzhang:igalia.com","id":"$FyigABRYB99WPqMhQMQ-uovws2GOF7YijzuidE6W9y8"}
]