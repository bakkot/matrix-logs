[
{"content":{"body":"Jack Works: I also don't think we actually need the note about `document.all` there in InvokeCustomMatcher; it's a bizarre legacy piece of the web platform that produces weird behavior *everywhere*. We're not particularly special here. ^_^","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@jackworks:matrix.org\">Jack Works</a>: I also don't think we actually need the note about <code>document.all</code> there in InvokeCustomMatcher; it's a bizarre legacy piece of the web platform that produces weird behavior <em>everywhere</em>. We're not particularly special here. ^_^","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"msgtype":"m.text"},"ts":1706227544370,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$RV1sRxQLNk1BAB2vpLFkSh8Kigxsj8PgMOB0RRFj9hs"},
{"content":{"body":"(Tho also, in that example the second `if()` will only match if you write `null is f(let html, ...)`, since there will be more elements in the iterator than just the html element.)","format":"org.matrix.custom.html","formatted_body":"(Tho also, in that example the second <code>if()</code> will only match if you write <code>null is f(let html, ...)</code>, since there will be more elements in the iterator than just the html element.)","m.mentions":{},"msgtype":"m.text"},"ts":1706227609125,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$lZQrEhct3VpvPDMSZu1p5-3V6feRHNT3xGLk22ipGcg"},
{"content":{"body":"> <@rbuckton:matrix.org> What is the purpose of `receiver` in a custom matcher? \n\nthis is required to make dotted custom matchers working correctly.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$TL581_dIUR49BuPkZmm5u1vyKPI0OO7JBRYNBOArD5Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />What is the purpose of <code>receiver</code> in a custom matcher?</blockquote></mx-reply>this is required to make dotted custom matchers working correctly.","m.relates_to":{"m.in_reply_to":{"event_id":"$TL581_dIUR49BuPkZmm5u1vyKPI0OO7JBRYNBOArD5Q"}},"msgtype":"m.text"},"ts":1706234837039,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$w9yieBPPJ0Kjg65xe9MKMYpnPOnUqDWbNsTGgXcQvXo"},
{"content":{"body":"for code `when A.B(let c):`, we do `let receiver = A.B; let matcher = Get(receiver, Symbol.customMatcher)`, then `Call(matcher, receiver, args)`. If we don't have receiver, all custom matchers will be called without `this`.","format":"org.matrix.custom.html","formatted_body":"for code <code>when A.B(let c):</code>, we do <code>let receiver = A.B; let matcher = Get(receiver, Symbol.customMatcher)</code>, then <code>Call(matcher, receiver, args)</code>. If we don't have receiver, all custom matchers will be called without <code>this</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1706234982572,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$oUvBktev4zQ-8BPgzC6hOuxVVur5xLVC9Vw5dAbNGwI"},
{"content":{"body":"> <@jackworks:matrix.org> this is required to make dotted custom matchers working correctly.\n\nI'm not sure I agree that's correct. If you equate this to `Symbol.iterator`, we don't forward a receiver if you do\n```js\nfor (const x of foo.bar) {\n}\n```\nso why would we do that here? Carrying over the receiver isn't something you'll normally need, and if you need to preserve the receiver, you would make `[Symbol.customMatcher]` into a getter that returns a bound function.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$w9yieBPPJ0Kjg65xe9MKMYpnPOnUqDWbNsTGgXcQvXo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>this is required to make dotted custom matchers working correctly.</blockquote></mx-reply><p>I'm not sure I agree that's correct. If you equate this to <code>Symbol.iterator</code>, we don't forward a receiver if you do</p>\n<pre><code class=\"language-js\">for (const x of foo.bar) {\n}\n</code></pre>\n<p>so why would we do that here? Carrying over the receiver isn't something you'll normally need, and if you need to preserve the receiver, you would make <code>[Symbol.customMatcher]</code> into a getter that returns a bound function.</p>\n","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$w9yieBPPJ0Kjg65xe9MKMYpnPOnUqDWbNsTGgXcQvXo"}},"msgtype":"m.text"},"ts":1706235008136,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vUUSA0wxK4AaOu1C0wn91Gjs28hR5S0WGDPbe4y9QW4"},
{"content":{"body":"I wouldn't expect `when A.B(let c)` to preserve the receiver unless maybe `A.B` is just a plain function.","format":"org.matrix.custom.html","formatted_body":"I wouldn't expect <code>when A.B(let c)</code> to preserve the receiver unless maybe <code>A.B</code> is just a plain function.","m.mentions":{},"msgtype":"m.text"},"ts":1706235059372,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TYshAuWYwBpzOJItlXlHJSFOlrKgBYoyW1f51_MIQgE"},
{"content":{"body":"this is not in the initial spec, it was found as a bug to fix","m.mentions":{},"msgtype":"m.text"},"ts":1706235066476,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$oQYgQXY5RqJneI67c0a45guKivenpPadC1WL2V_MNIE"},
{"content":{"body":"if you don't like it, we can discuss to remove receiver","m.mentions":{},"msgtype":"m.text"},"ts":1706235076327,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$473ykbbunJRHyXfsw1bVhwktPtSttalD8yR3lvkwPAw"},
{"content":{"body":"I'm not certain I agree its a bug?","m.mentions":{},"msgtype":"m.text"},"ts":1706235082168,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YI7eVUCQxWiUtP2Ei9e6sJ5QK0IFCavohxrJxKMBNMQ"},
{"content":{"body":"You normally only pass around a receiver if you're working with proxies/reflect. I don't think I've seen that anywhere else in the spec.","m.mentions":{},"msgtype":"m.text"},"ts":1706235137103,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PT3MFgRQmXsUhQxNNG2M7FssZENdCRmsIk-BLuVBeIU"},
{"content":{"body":"That's just the nature of JS. I wouldn't want to do something specific here that would be incompatible with some other proposal like bind-this","m.mentions":{},"msgtype":"m.text"},"ts":1706235187706,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vtQ-rUhlgef625OGNDs8QgoSH-iAcjaxdjwvrQw8F90"},
{"content":{"body":"A one-off fix here could hurt us more down the line","m.mentions":{},"msgtype":"m.text"},"ts":1706235208500,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$v4kzSVcyoWSQYeESfBdif4G0OFXvpX0By5oY8gh0i08"},
{"content":{"body":"it may be annoying, but changing it is inconsistent with the rest of the language.","m.mentions":{},"msgtype":"m.text"},"ts":1706235266549,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lDz6PUgLjBjhp-4id9e6Q8lCKsVHFflBwIv8p0eK2hM"},
{"content":{"body":"Oh, seeing the notes reminds me the use case. If you want to use a boolean tester like `something.equal` (which means `something.equal(matchTopic)`), it will be impossible if receiver is not passed, but we can discuss it on the design meeting anyway.","format":"org.matrix.custom.html","formatted_body":"Oh, seeing the notes reminds me the use case. If you want to use a boolean tester like <code>something.equal</code> (which means <code>something.equal(matchTopic)</code>), it will be impossible if receiver is not passed, but we can discuss it on the design meeting anyway.","m.mentions":{},"msgtype":"m.text"},"ts":1706235279393,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$RyiQF-RrvbdwfSYLp9j0SOxBwZV8esjJUh7NOwqv-Sg"},
{"content":{"body":"> <@rbuckton:matrix.org> it may be annoying, but changing it is inconsistent with the rest of the language.\n\nAnd I guess this reflects what function calls do. `a.b(c)` brings `a` as receiver, so extractors do the same.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$lDz6PUgLjBjhp-4id9e6Q8lCKsVHFflBwIv8p0eK2hM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>it may be annoying, but changing it is inconsistent with the rest of the language.</blockquote></mx-reply>And I guess this reflects what function calls do. <code>a.b(c)</code> brings <code>a</code> as receiver, so extractors do the same.","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$lDz6PUgLjBjhp-4id9e6Q8lCKsVHFflBwIv8p0eK2hM"}},"msgtype":"m.text"},"ts":1706235351547,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$q5usoRyAhaxHgvpV0f-l36vBWc8WQ-ItIu07rbac3j8"},
{"content":{"body":"I can see carrying the receiver as `this` for `something.equal` when it's just a predicate function and not a custom matcher. The inconsistency is that we chose to have this weird case where we allow either one. Then again, if you equate this to DOM event handlers, there's no `this` preservation when you pass it a function and not a `{ handleEvent(evt) {} }` object.","format":"org.matrix.custom.html","formatted_body":"I can see carrying the receiver as <code>this</code> for <code>something.equal</code> when it's just a predicate function and not a custom matcher. The inconsistency is that we chose to have this weird case where we allow either one. Then again, if you equate this to DOM event handlers, there's no <code>this</code> preservation when you pass it a function and not a <code>{ handleEvent(evt) {} }</code> object.","m.mentions":{},"msgtype":"m.text"},"ts":1706235443955,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VRWGOtFAmg_wjP2KgSdfkt3RIaMvlauN90ytLVyf9IM"},
{"content":{"body":"Extractors aren't 100% like functions. They appear to be the inverse of function application, but they're actually more like the inverse of construction, and `new Foo.Bar()` doesn't preserve `Foo` as the receiver.","format":"org.matrix.custom.html","formatted_body":"Extractors aren't 100% like functions. They appear to be the inverse of function application, but they're actually more like the inverse of construction, and <code>new Foo.Bar()</code> doesn't preserve <code>Foo</code> as the receiver.","m.mentions":{},"msgtype":"m.text"},"ts":1706235500210,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Lu9NHUPqs62hCdHWm4cEdrdca9QSapM44-qbf_5MioQ"},
{"content":{"body":"If, for example, we had a bind-this proposal, i.e. `::foo.bar`, then I would say we would use the bound `this` via that syntax, i.e. `when ::obj.equals`. ","format":"org.matrix.custom.html","formatted_body":"If, for example, we had a bind-this proposal, i.e. <code>::foo.bar</code>, then I would say we would use the bound <code>this</code> via that syntax, i.e. <code>when ::obj.equals</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1706235592012,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2SC3EUd2h8Obju1u9DxCk9G-Fpau6dEZQyOwNLtduoA"},
{"content":{"body":"https://github.com/tc39/proposal-call-this hit Stage 1, but hasn't had much movement in awhile. https://github.com/tc39/proposal-bind-operator is sitting at Stage 0.","m.mentions":{},"msgtype":"m.text"},"ts":1706235806301,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JIiNvdmARDA70CQSxdPQDYjD2eLxFsZv6hZKMzsGsG0"},
{"content":{"body":" * I can _maybe_ see carrying the receiver as `this` for `something.equal` when it's just a predicate function and not a custom matcher. The inconsistency is that we chose to have this weird case where we allow either one. Then again, if you equate this to DOM event handlers, there's no `this` preservation when you pass it a function and not a `{ handleEvent(evt) {} }` object.","format":"org.matrix.custom.html","formatted_body":" * I can <em>maybe</em> see carrying the receiver as <code>this</code> for <code>something.equal</code> when it's just a predicate function and not a custom matcher. The inconsistency is that we chose to have this weird case where we allow either one. Then again, if you equate this to DOM event handlers, there's no <code>this</code> preservation when you pass it a function and not a <code>{ handleEvent(evt) {} }</code> object.","m.mentions":{},"m.new_content":{"body":"I can _maybe_ see carrying the receiver as `this` for `something.equal` when it's just a predicate function and not a custom matcher. The inconsistency is that we chose to have this weird case where we allow either one. Then again, if you equate this to DOM event handlers, there's no `this` preservation when you pass it a function and not a `{ handleEvent(evt) {} }` object.","format":"org.matrix.custom.html","formatted_body":"I can <em>maybe</em> see carrying the receiver as <code>this</code> for <code>something.equal</code> when it's just a predicate function and not a custom matcher. The inconsistency is that we chose to have this weird case where we allow either one. Then again, if you equate this to DOM event handlers, there's no <code>this</code> preservation when you pass it a function and not a <code>{ handleEvent(evt) {} }</code> object.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$VRWGOtFAmg_wjP2KgSdfkt3RIaMvlauN90ytLVyf9IM","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706235837810,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NztwZpFODjRiy402A6smDCiw9_Q5ddOl4L1B7HV-fI8"},
{"content":{"body":"> <@rbuckton:matrix.org> In the slide you point to, I have to add a number of extra conditions around return values to align with `InvokeCustomMatcher` just doing a ToBoolean on the result when the hint is boolean, and I'm not a huge fan of return type inconsistency.\n\nsorry can you rephrase this part? ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$3V4K2HX-65smJ8mkc7bT_xwFh9_jSXB3Rx6ZBv0oCSs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />In the slide you point to, I have to add a number of extra conditions around return values to align with <code>InvokeCustomMatcher</code> just doing a ToBoolean on the result when the hint is boolean, and I'm not a huge fan of return type inconsistency.</blockquote></mx-reply>sorry can you rephrase this part?","m.relates_to":{"m.in_reply_to":{"event_id":"$3V4K2HX-65smJ8mkc7bT_xwFh9_jSXB3Rx6ZBv0oCSs"}},"msgtype":"m.text"},"ts":1706235881224,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$EjvjADrmKf7k8pmswFdNmKq0OvsmZm5lyM9pUGKJ9wk"},
{"content":{"body":"> <@jackworks:matrix.org> sorry can you rephrase this part?\n\nIgnore that. A few messages later I realized I was in error.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$EjvjADrmKf7k8pmswFdNmKq0OvsmZm5lyM9pUGKJ9wk?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>sorry can you rephrase this part?</blockquote></mx-reply>Ignore that. A few messages later I realized I was in error.","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$EjvjADrmKf7k8pmswFdNmKq0OvsmZm5lyM9pUGKJ9wk"}},"msgtype":"m.text"},"ts":1706235907906,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ln8wg3TQXA0T2C9mrGps8PdwPO2f78bE9T_tC9vnHBQ"},
{"content":{"body":"I was trying to reconcile `hint === \"boolean\"` with returning a `{matched: false }` that would coerce to `true`, but had missed the part where MatchResult was dropped in favor of just returning an iterable object.","format":"org.matrix.custom.html","formatted_body":"I was trying to reconcile <code>hint === \"boolean\"</code> with returning a <code>{matched: false }</code> that would coerce to <code>true</code>, but had missed the part where MatchResult was dropped in favor of just returning an iterable object.","m.mentions":{},"msgtype":"m.text"},"ts":1706235976270,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2sSo56a_BEitZ7iEsXFU_1NbFbCbwoqmmEiiyRhqjaQ"},
{"content":{"body":"But the `receiver` thing makes me a little more uncomfortable with the decision to support predicates by default. ","format":"org.matrix.custom.html","formatted_body":"But the <code>receiver</code> thing makes me a little more uncomfortable with the decision to support predicates by default.","m.mentions":{},"msgtype":"m.text"},"ts":1706236328911,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PNmzlXq1atMaKShYGeqC04BNr0-5uFyuBtkizEiiuXk"},
{"content":{"body":"`instanceof` fits better with how the actual runtime semantics play out.","format":"org.matrix.custom.html","formatted_body":"<code>instanceof</code> fits better with how the actual runtime semantics play out.","m.mentions":{},"msgtype":"m.text"},"ts":1706236380000,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UrokHwrKdWGn7dcvxh2zWZKxuiO17Lp-n9dikj5gqRM"},
{"content":{"body":"`obj instanceof x.y` doesn't preserve `x` as a receiver when calling `[Symbol.hasInstance]`, much like how `obj is x.y` doesn't preserve `x` as the receiver when calling `[Symbol.customMatcher]`.","format":"org.matrix.custom.html","formatted_body":"<code>obj instanceof x.y</code> doesn't preserve <code>x</code> as a receiver when calling <code>[Symbol.hasInstance]</code>, much like how <code>obj is x.y</code> doesn't preserve <code>x</code> as the receiver when calling <code>[Symbol.customMatcher]</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1706236449253,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YYBo7HeVWTdLGoNO5f7NLZb_X6XftZrj_JmBrcr72jc"},
{"content":{"body":"> <@tabatkins:matrix.org> Jack Works: I don't understand how InvokeCustomMatcher works. You check for kind==BOOLEAN in step 8, and return the bool-ized result immediately, but then you check for kind==BOOLEAN *again* in step 11.\n\nyes you're right this is a bug. I'm fixing this right now.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$MYbZ0DMPYuVinm_f3Od_mt6IIxbOyXAHwZHq95V2tEE?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br><a href=\"https://matrix.to/#/@jackworks:matrix.org\">Jack Works</a>: I don't understand how InvokeCustomMatcher works. You check for kind==BOOLEAN in step 8, and return the bool-ized result immediately, but then you check for kind==BOOLEAN <em>again</em> in step 11.</blockquote></mx-reply>yes you're right this is a bug. I'm fixing this right now.","m.mentions":{"user_ids":["@tabatkins:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$MYbZ0DMPYuVinm_f3Od_mt6IIxbOyXAHwZHq95V2tEE"}},"msgtype":"m.text"},"ts":1706236569588,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$kgvyPU26VBZYfud3YEZbdv7B-b1nEc5Oo3wsCSYaVlA"},
{"content":{"body":"To me that argues for having a *different* syntax for predicates: either a `match`-specific disambiguator or just not passing the receiver and adoption some future bind-this syntax to enable that in the future.","format":"org.matrix.custom.html","formatted_body":"To me that argues for having a <em>different</em> syntax for predicates: either a <code>match</code>-specific disambiguator or just not passing the receiver and adoption some future bind-this syntax to enable that in the future.","m.mentions":{},"msgtype":"m.text"},"ts":1706236598377,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rNSTXwDTtWFbZBMKPXyvZCNnHhsE3GZgMeAyGZGjjNA"},
{"content":{"body":" * To me that argues for having a _different_ syntax for predicates: either a `match`-specific disambiguator or just not passing the receiver and adopting some future bind-this syntax to enable that in the future.","format":"org.matrix.custom.html","formatted_body":" * To me that argues for having a <em>different</em> syntax for predicates: either a <code>match</code>-specific disambiguator or just not passing the receiver and adopting some future bind-this syntax to enable that in the future.","m.mentions":{},"m.new_content":{"body":"To me that argues for having a _different_ syntax for predicates: either a `match`-specific disambiguator or just not passing the receiver and adopting some future bind-this syntax to enable that in the future.","format":"org.matrix.custom.html","formatted_body":"To me that argues for having a <em>different</em> syntax for predicates: either a <code>match</code>-specific disambiguator or just not passing the receiver and adopting some future bind-this syntax to enable that in the future.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rNSTXwDTtWFbZBMKPXyvZCNnHhsE3GZgMeAyGZGjjNA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706236615696,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$evwQCnvKzFzzf18xZ5J6UsRB5xcoyCVf3g7CVot8PS8"},
{"content":{"body":" * To me that argues for having a _different_ syntax for predicates: either a `match`-specific disambiguator or just not passing the receiver and adopting some future bind-this syntax to enable that when it becomes available.","format":"org.matrix.custom.html","formatted_body":" * To me that argues for having a <em>different</em> syntax for predicates: either a <code>match</code>-specific disambiguator or just not passing the receiver and adopting some future bind-this syntax to enable that when it becomes available.","m.mentions":{},"m.new_content":{"body":"To me that argues for having a _different_ syntax for predicates: either a `match`-specific disambiguator or just not passing the receiver and adopting some future bind-this syntax to enable that when it becomes available.","format":"org.matrix.custom.html","formatted_body":"To me that argues for having a <em>different</em> syntax for predicates: either a <code>match</code>-specific disambiguator or just not passing the receiver and adopting some future bind-this syntax to enable that when it becomes available.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$rNSTXwDTtWFbZBMKPXyvZCNnHhsE3GZgMeAyGZGjjNA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706236626482,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mOpTL3WFSpeAAWvIB045-uEFQR93-NPuD9fxxpFIpJI"},
{"content":{"body":"I'll also add a note that `receiver` is not a consensus yet.","format":"org.matrix.custom.html","formatted_body":"I'll also add a note that <code>receiver</code> is not a consensus yet.","m.mentions":{},"msgtype":"m.text"},"ts":1706236635138,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$zW3uooB1CMyl7I3Jv24mrelY8ZwGqtR0KOC1sXuQCRU"},
{"content":{"body":"And in the mean time, user's can always just pull out `obj.equal` into a temp variable before the pattern, e.g. \n```js\nconst equal = x => obj.equal(x);\nmatch (value) {\n  when equal: ...;\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>And in the mean time, user's can always just pull out <code>obj.equal</code> into a temp variable before the pattern, e.g.</p>\n<pre><code class=\"language-js\">const equal = x =&gt; obj.equal(x);\nmatch (value) {\n  when equal: ...;\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1706236813650,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tvdhj-eZV08gcltZbBv-SKu5Z2DTF9aSswd3SgjdJtU"},
{"content":{"body":"> <@rbuckton:matrix.org> After further reflection, _hint_ here isn't so bad since I don't need to differentiate between a `{ matched: false }` and a `{ matched: true }` anymore. I still think it would be nice to be able to optimize for the unary-extractor case in some way.\n\nYes, it's possible (via MatchResult object), but we need to think if we really gonna do that in the specification. For example, we can make Arrays destructing not calling iterator protocol but with `length` and index access directly, but we do that for mental model simplicity (I guess) (which means everything go by iterator protocol, there is no special cases)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$lY908TRYKdIkT8PMmCswej3GNKqAOYvFm_n7jHTPJPg?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>After further reflection, <em>hint</em> here isn't so bad since I don't need to differentiate between a <code>{ matched: false }</code> and a <code>{ matched: true }</code> anymore. I still think it would be nice to be able to optimize for the unary-extractor case in some way.</blockquote></mx-reply>Yes, it's possible (via MatchResult object), but we need to think if we really gonna do that in the specification. For example, we can make Arrays destructing not calling iterator protocol but with <code>length</code> and index access directly, but we do that for mental model simplicity (I guess) (which means everything go by iterator protocol, there is no special cases)","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$lY908TRYKdIkT8PMmCswej3GNKqAOYvFm_n7jHTPJPg"}},"msgtype":"m.text"},"ts":1706237237192,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$evXU0gXVj9Z6EZk0BfOjfrvtXVhF-YT_25UuOVqbd9o"},
{"content":{"body":"> <@jackworks:matrix.org> Yes, it's possible (via MatchResult object), but we need to think if we really gonna do that in the specification. For example, we can make Arrays destructing not calling iterator protocol but with `length` and index access directly, but we do that for mental model simplicity (I guess) (which means everything go by iterator protocol, there is no special cases)\n\nI don't think a one-off break from iterator destructuring makes sense. It would just be surprising to some users. The ADT enum result suggestion continues to leverage iterator destructuring, but has well-defined branches for the unary extractor case.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$evXU0gXVj9Z6EZk0BfOjfrvtXVhF-YT_25UuOVqbd9o?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>Yes, it's possible (via MatchResult object), but we need to think if we really gonna do that in the specification. For example, we can make Arrays destructing not calling iterator protocol but with <code>length</code> and index access directly, but we do that for mental model simplicity (I guess) (which means everything go by iterator protocol, there is no special cases)</blockquote></mx-reply>I don't think a one-off break from iterator destructuring makes sense. It would just be surprising to some users. The ADT enum result suggestion continues to leverage iterator destructuring, but has well-defined branches for the unary extractor case.","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$evXU0gXVj9Z6EZk0BfOjfrvtXVhF-YT_25UuOVqbd9o"}},"msgtype":"m.text"},"ts":1706237380111,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7d6PiTLfb7e3mMsx_Yxdm6HZ3ebSAoIHUurt9DHJoW4"},
{"content":{"body":"if we want to support unary or multiple, we need to bring MatchResult object back (otherwise a test around iterator protocol looks like a footgun). do you want to add a note about this?","m.mentions":{},"msgtype":"m.text"},"ts":1706237483383,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$FF-bYPkOkci1HFmjawAcQfaUrB4XIXtQGIS7OGdEwsA"},
{"content":{"body":"Possibly, or at least we should discuss it at the next meeting. To be clear, it's not that I'm advocating for the entire `MatchResult` ADT enum thing, but more that I'm wondering if there is an optimization we can make for the unary-extractor case.","format":"org.matrix.custom.html","formatted_body":"Possibly, or at least we should discuss it at the next meeting. To be clear, it's not that I'm advocating for the entire <code>MatchResult</code> ADT enum thing, but more that I'm wondering if there is an optimization we can make for the unary-extractor case.","m.mentions":{},"msgtype":"m.text"},"ts":1706237618286,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CyYLeSwIg0hGLqPjn4XUsi_wubd_quFEGND6SIweDWc"},
{"content":{"body":"https://raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html#sec-invoke-custom-matcher\n\nbug fixed (you may need clear browser cache) cc TabAtkins ","format":"org.matrix.custom.html","formatted_body":"<p>https://raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html#sec-invoke-custom-matcher</p>\n<p>bug fixed (you may need clear browser cache) cc <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">TabAtkins</a></p>\n","m.mentions":{"user_ids":["@tabatkins:matrix.org"]},"msgtype":"m.text"},"ts":1706238075908,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$04GTKbi--3j0fOsExmDtDfm6V4brEpLKbaEnX0__LJI"},
{"content":{"body":"For example, we could have a rule for return values such that:\n- A successful n-ary match has the shape `{ kind: \"values\", values: iterator }`\n- A successful unary match has the shape `{ kind: \"value\", value: value }`\n- A successful nullary match is indicated by the value `true`. Such a result cannot be extracted.\n- A failed match is indicated by `false`.\n- If the result is an Object but does not have a `kind`, it is lifted to `{ kind: \"values\", values: result }`. As such, any object that does not have a `kind` must be iterable.\n- Otherwise, the result is lifted to `ToBoolean(result)`.\n\n","format":"org.matrix.custom.html","formatted_body":"<p>For example, we could have a rule for return values such that:</p>\n<ul>\n<li>A successful n-ary match has the shape <code>{ kind: \"values\", values: iterator }</code></li>\n<li>A successful unary match has the shape <code>{ kind: \"value\", value: value }</code></li>\n<li>A successful nullary match is indicated by the value <code>true</code>. Such a result cannot be extracted.</li>\n<li>A failed match is indicated by <code>false</code>.</li>\n<li>If the result is an Object but does not have a <code>kind</code>, it is lifted to <code>{ kind: \"values\", values: result }</code>. As such, any object that does not have a <code>kind</code> must be iterable.</li>\n<li>Otherwise, the result is lifted to <code>ToBoolean(result)</code>.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1706238111664,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$w63JCar7fcS0tqk35Yv1hMFraJC7bUteSHwqlC55ro8"},
{"content":{"body":"essentially, it's an ADT union of:\n```\ntype MatchResult = \n  | { kind: \"values\", values: Iterable }\n  | { kind: \"value\", value: any }\n  | { kind: \"pass\" }\n  | { kind: \"fail\" }\n  | Iterable // coerced to { kind: \"values\", values: Iterable }\n  | true // coerced to { kind: \"pass\" }\n  | false // coerced to { kind: \"fail\" }\n  | undefined // coerced to { kind: \"fail\" }\n```","format":"org.matrix.custom.html","formatted_body":"<p>essentially, it's an ADT union of:</p>\n<pre><code>type MatchResult = \n  | { kind: \"values\", values: Iterable }\n  | { kind: \"value\", value: any }\n  | { kind: \"pass\" }\n  | { kind: \"fail\" }\n  | Iterable // coerced to { kind: \"values\", values: Iterable }\n  | true // coerced to { kind: \"pass\" }\n  | false // coerced to { kind: \"fail\" }\n  | undefined // coerced to { kind: \"fail\" }\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1706238275296,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$f9rMJz7jXwaL7LIBQ-x2_yneQ_ZfaX6auUXj5HgK4Tk"},
{"content":{"body":"I'm not hung up on how it looks or is implemented, I'm just more interested in the idea of an optimization that reduces overhead for the `when Point({ x, y })` case.","format":"org.matrix.custom.html","formatted_body":"I'm not hung up on how it looks or is implemented, I'm just more interested in the idea of an optimization that reduces overhead for the <code>when Point({ x, y })</code> case.","m.mentions":{},"msgtype":"m.text"},"ts":1706238347267,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HU2AHetR2JoQBRGY5-KGwtjtQ5GcohsIf62U2bdb9y0"},
{"content":{"body":"it's possible and performance good, but I think the protocol looks too complicated now","m.mentions":{},"msgtype":"m.text"},"ts":1706238367186,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$ead_z_m5FYypuKVrxZ8KeZQ9M_gvCHnTDT7Q9Lvncus"},
{"content":{"body":"I'd have wanted something similar if we had `when Point{ x, y }`","format":"org.matrix.custom.html","formatted_body":"I'd have wanted something similar if we had <code>when Point{ x, y }</code>","m.mentions":{},"msgtype":"m.text"},"ts":1706238370631,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$LTWVGWVArukYMs58hrHCtMtMEawB1oGtAHlovmWTaRo"},
{"content":{"body":"current protocol:\n\n```\ntype MatchBooleanResult = any // ToBoolean semantics\ntype MatchListResult = false | Iterable<any>\n```","format":"org.matrix.custom.html","formatted_body":"<p>current protocol:</p>\n<pre><code>type MatchBooleanResult = any // ToBoolean semantics\ntype MatchListResult = false | Iterable&lt;any&gt;\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1706238413279,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$ziO8oQRN_xfhNPdNAswQSfKy7MKzYcnJaSJd7ZaJjGk"},
{"content":{"body":"It doesn't seem complex to me. The actual protocol could be simplified:\n\n```ts\ntype MatchResult = { kind: \"list\" | \"one\" | \"pass\" | \"fail\", value?: any };\n```\n\nAnd the coercion rules just indicate how anything that is not an object with a `kind` is converted to an object with a `kind`.","format":"org.matrix.custom.html","formatted_body":"<p>It doesn't seem complex to me. The actual protocol could be simplified:</p>\n<pre><code class=\"language-ts\">type MatchResult = { kind: \"list\" | \"one\" | \"pass\" | \"fail\", value?: any };\n</code></pre>\n<p>And the coercion rules just indicate how anything that is not an object with a <code>kind</code> is converted to an object with a <code>kind</code>.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1706238525346,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YQ3OE8iLogdtzNTE3iemUofh9IxVsvKcwqjoqhW8mNo"},
{"content":{"body":" * It doesn't seem complex to me. The actual protocol could be simplified:\n\n```ts\ntype MatchResult = { kind: \"list\" | \"one\" | \"pass\" | \"fail\", value?: any };\n```\n\nAnd the coercion rules just indicate how anything that is not an object with a `kind` is converted to an object with a `kind` (or errors)","format":"org.matrix.custom.html","formatted_body":" * <p>It doesn't seem complex to me. The actual protocol could be simplified:</p>\n<pre><code class=\"language-ts\">type MatchResult = { kind: \"list\" | \"one\" | \"pass\" | \"fail\", value?: any };\n</code></pre>\n<p>And the coercion rules just indicate how anything that is not an object with a <code>kind</code> is converted to an object with a <code>kind</code> (or errors)</p>\n","m.mentions":{},"m.new_content":{"body":"It doesn't seem complex to me. The actual protocol could be simplified:\n\n```ts\ntype MatchResult = { kind: \"list\" | \"one\" | \"pass\" | \"fail\", value?: any };\n```\n\nAnd the coercion rules just indicate how anything that is not an object with a `kind` is converted to an object with a `kind` (or errors)","format":"org.matrix.custom.html","formatted_body":"<p>It doesn't seem complex to me. The actual protocol could be simplified:</p>\n<pre><code class=\"language-ts\">type MatchResult = { kind: \"list\" | \"one\" | \"pass\" | \"fail\", value?: any };\n</code></pre>\n<p>And the coercion rules just indicate how anything that is not an object with a <code>kind</code> is converted to an object with a <code>kind</code> (or errors)</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$YQ3OE8iLogdtzNTE3iemUofh9IxVsvKcwqjoqhW8mNo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706238540177,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XhMXJu-1VoAfbDSGx3t3fL_iiTPp0tUU380Sa4rdyWQ"},
{"content":{"body":" * It doesn't seem complex to me. The actual protocol could be simplified:\n\n```ts\ntype MatchResult = { kind: \"list\" | \"value\" | \"pass\" | \"fail\", value?: any };\n```\n\nAnd the coercion rules just indicate how anything that is not an object with a `kind` is converted to an object with a `kind` (or errors)","format":"org.matrix.custom.html","formatted_body":" * <p>It doesn't seem complex to me. The actual protocol could be simplified:</p>\n<pre><code class=\"language-ts\">type MatchResult = { kind: \"list\" | \"value\" | \"pass\" | \"fail\", value?: any };\n</code></pre>\n<p>And the coercion rules just indicate how anything that is not an object with a <code>kind</code> is converted to an object with a <code>kind</code> (or errors)</p>\n","m.mentions":{},"m.new_content":{"body":"It doesn't seem complex to me. The actual protocol could be simplified:\n\n```ts\ntype MatchResult = { kind: \"list\" | \"value\" | \"pass\" | \"fail\", value?: any };\n```\n\nAnd the coercion rules just indicate how anything that is not an object with a `kind` is converted to an object with a `kind` (or errors)","format":"org.matrix.custom.html","formatted_body":"<p>It doesn't seem complex to me. The actual protocol could be simplified:</p>\n<pre><code class=\"language-ts\">type MatchResult = { kind: \"list\" | \"value\" | \"pass\" | \"fail\", value?: any };\n</code></pre>\n<p>And the coercion rules just indicate how anything that is not an object with a <code>kind</code> is converted to an object with a <code>kind</code> (or errors)</p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$YQ3OE8iLogdtzNTE3iemUofh9IxVsvKcwqjoqhW8mNo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706238576243,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_avSUNC4WI0gDkIruR_oE_TgCTT2Qwnfgdxz2n12Gts"},
{"content":{"body":" * essentially, it's an ADT union of:\n\n```\ntype MatchResult = \n  | { kind: \"list\", value: Iterable }\n  | { kind: \"value\", value: any }\n  | { kind: \"pass\" }\n  | { kind: \"fail\" }\n  | Iterable // coerced to { kind: \"list\", value: Iterable }\n  | true // coerced to { kind: \"pass\" }\n  | false // coerced to { kind: \"fail\" }\n  | undefined // coerced to { kind: \"fail\" }\n```","format":"org.matrix.custom.html","formatted_body":" * <p>essentially, it's an ADT union of:</p>\n<pre><code>type MatchResult = \n  | { kind: \"list\", value: Iterable }\n  | { kind: \"value\", value: any }\n  | { kind: \"pass\" }\n  | { kind: \"fail\" }\n  | Iterable // coerced to { kind: \"list\", value: Iterable }\n  | true // coerced to { kind: \"pass\" }\n  | false // coerced to { kind: \"fail\" }\n  | undefined // coerced to { kind: \"fail\" }\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"essentially, it's an ADT union of:\n\n```\ntype MatchResult = \n  | { kind: \"list\", value: Iterable }\n  | { kind: \"value\", value: any }\n  | { kind: \"pass\" }\n  | { kind: \"fail\" }\n  | Iterable // coerced to { kind: \"list\", value: Iterable }\n  | true // coerced to { kind: \"pass\" }\n  | false // coerced to { kind: \"fail\" }\n  | undefined // coerced to { kind: \"fail\" }\n```","format":"org.matrix.custom.html","formatted_body":"<p>essentially, it's an ADT union of:</p>\n<pre><code>type MatchResult = \n  | { kind: \"list\", value: Iterable }\n  | { kind: \"value\", value: any }\n  | { kind: \"pass\" }\n  | { kind: \"fail\" }\n  | Iterable // coerced to { kind: \"list\", value: Iterable }\n  | true // coerced to { kind: \"pass\" }\n  | false // coerced to { kind: \"fail\" }\n  | undefined // coerced to { kind: \"fail\" }\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$f9rMJz7jXwaL7LIBQ-x2_yneQ_ZfaX6auUXj5HgK4Tk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706238767763,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$pt3AMSxh2yeDtrLnxH1Akg0bUCyfz8jA-MiE40fdpak"},
{"content":{"body":" * For example, we could have a rule for return values such that:\n\n- A successful n-ary match has the shape `{ kind: \"list\", value: Iterable }`\n- A successful unary match has the shape `{ kind: \"value\", value: any }`\n- A successful nullary match has the shape `{ kind: \"pass\" }`. Such a result cannot be extracted.\n- A failed match has the shape `{ kind: \"fail\" }`.\n- If the result is an Object and has a `kind`, but it is not one of `\"list\"`, `\"value\"`, `\"pass\"`, or `\"fail\"`, throw a TypeError.\n- If the result is an Object but does not have a `kind`, it is lifted to `{ kind: \"list\", value: result }`. As such, any Object that does not have a `kind` must be iterable.\n- Otherwise, the result is lifted to `ToBoolean(result)`:\n  - If the new result is `true`, it is lifted to `{ kind: \"pass\" }`.\n  - If the new result is `false`, it is lifted to `{ kind: \"fail\" }`.","format":"org.matrix.custom.html","formatted_body":" * <p>For example, we could have a rule for return values such that:</p>\n<ul>\n<li>A successful n-ary match has the shape <code>{ kind: \"list\", value: Iterable }</code></li>\n<li>A successful unary match has the shape <code>{ kind: \"value\", value: any }</code></li>\n<li>A successful nullary match has the shape <code>{ kind: \"pass\" }</code>. Such a result cannot be extracted.</li>\n<li>A failed match has the shape <code>{ kind: \"fail\" }</code>.</li>\n<li>If the result is an Object and has a <code>kind</code>, but it is not one of <code>\"list\"</code>, <code>\"value\"</code>, <code>\"pass\"</code>, or <code>\"fail\"</code>, throw a TypeError.</li>\n<li>If the result is an Object but does not have a <code>kind</code>, it is lifted to <code>{ kind: \"list\", value: result }</code>. As such, any Object that does not have a <code>kind</code> must be iterable.</li>\n<li>Otherwise, the result is lifted to <code>ToBoolean(result)</code>:\n<ul>\n<li>If the new result is <code>true</code>, it is lifted to <code>{ kind: \"pass\" }</code>.</li>\n<li>If the new result is <code>false</code>, it is lifted to <code>{ kind: \"fail\" }</code>.</li>\n</ul>\n</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"For example, we could have a rule for return values such that:\n\n- A successful n-ary match has the shape `{ kind: \"list\", value: Iterable }`\n- A successful unary match has the shape `{ kind: \"value\", value: any }`\n- A successful nullary match has the shape `{ kind: \"pass\" }`. Such a result cannot be extracted.\n- A failed match has the shape `{ kind: \"fail\" }`.\n- If the result is an Object and has a `kind`, but it is not one of `\"list\"`, `\"value\"`, `\"pass\"`, or `\"fail\"`, throw a TypeError.\n- If the result is an Object but does not have a `kind`, it is lifted to `{ kind: \"list\", value: result }`. As such, any Object that does not have a `kind` must be iterable.\n- Otherwise, the result is lifted to `ToBoolean(result)`:\n  - If the new result is `true`, it is lifted to `{ kind: \"pass\" }`.\n  - If the new result is `false`, it is lifted to `{ kind: \"fail\" }`.","format":"org.matrix.custom.html","formatted_body":"<p>For example, we could have a rule for return values such that:</p>\n<ul>\n<li>A successful n-ary match has the shape <code>{ kind: \"list\", value: Iterable }</code></li>\n<li>A successful unary match has the shape <code>{ kind: \"value\", value: any }</code></li>\n<li>A successful nullary match has the shape <code>{ kind: \"pass\" }</code>. Such a result cannot be extracted.</li>\n<li>A failed match has the shape <code>{ kind: \"fail\" }</code>.</li>\n<li>If the result is an Object and has a <code>kind</code>, but it is not one of <code>\"list\"</code>, <code>\"value\"</code>, <code>\"pass\"</code>, or <code>\"fail\"</code>, throw a TypeError.</li>\n<li>If the result is an Object but does not have a <code>kind</code>, it is lifted to <code>{ kind: \"list\", value: result }</code>. As such, any Object that does not have a <code>kind</code> must be iterable.</li>\n<li>Otherwise, the result is lifted to <code>ToBoolean(result)</code>:\n<ul>\n<li>If the new result is <code>true</code>, it is lifted to <code>{ kind: \"pass\" }</code>.</li>\n<li>If the new result is <code>false</code>, it is lifted to <code>{ kind: \"fail\" }</code>.</li>\n</ul>\n</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$w63JCar7fcS0tqk35Yv1hMFraJC7bUteSHwqlC55ro8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706238961524,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JO6-o96EqyRe-EY8Qr_pNpbiqb2j32Fue5oYuJl63KQ"},
{"content":{"body":"But I agree, `Iterable | boolean` is simpler.","format":"org.matrix.custom.html","formatted_body":"But I agree, <code>Iterable | boolean</code> is simpler.","m.mentions":{},"msgtype":"m.text"},"ts":1706239075843,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$anA3hk8JsyHEm8yaqO7cMYqQBIjl1IUvRxpBs0ej1l0"},
{"content":{"body":"Maybe if we add an `Iterator.once(value)` static method we could add optimizations for it directly in the spec like we do for native `Promise`. ","format":"org.matrix.custom.html","formatted_body":"Maybe if we add an <code>Iterator.once(value)</code> static method we could add optimizations for it directly in the spec like we do for native <code>Promise</code>.","m.mentions":{},"msgtype":"m.text"},"ts":1706239216399,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cx6-Dr8Si5O_SWx0yDEkDFDuLT8orxytiCWDJ6N_ZCw"},
{"content":{"body":"On the other hand, runtimes could chose to internally optimize a match result of `[value]` to avoid iterator destructuring and just reach for the value, though I imagine there'd need to be a lot of heavy usage of unary extractors before it would be worth writing up an optimization for that case.","format":"org.matrix.custom.html","formatted_body":"On the other hand, runtimes could chose to internally optimize a match result of <code>[value]</code> to avoid iterator destructuring and just reach for the value, though I imagine there'd need to be a lot of heavy usage of unary extractors before it would be worth writing up an optimization for that case.","m.mentions":{},"msgtype":"m.text"},"ts":1706239495162,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$6LSM92PCxi0NUI4glOu58xpVrNeIczf7dRCFpK5EJ2w"},
{"content":{"body":"> <@rbuckton:matrix.org> On the other hand, runtimes could chose to internally optimize a match result of `[value]` to avoid iterator destructuring and just reach for the value, though I imagine there'd need to be a lot of heavy usage of unary extractors before it would be worth writing up an optimization for that case.\n\ndo they optimize for `const [state, setState] = useState()`?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$6LSM92PCxi0NUI4glOu58xpVrNeIczf7dRCFpK5EJ2w?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>On the other hand, runtimes could chose to internally optimize a match result of <code>[value]</code> to avoid iterator destructuring and just reach for the value, though I imagine there'd need to be a lot of heavy usage of unary extractors before it would be worth writing up an optimization for that case.</blockquote></mx-reply>do they optimize for <code>const [state, setState] = useState()</code>?","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$6LSM92PCxi0NUI4glOu58xpVrNeIczf7dRCFpK5EJ2w"}},"msgtype":"m.text"},"ts":1706242574231,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$9JenmLvd3En0VSdCQhnzHRm6m7t1YC5gCxcl0JDeReE"},
{"content":{"body":"I","m.mentions":{},"msgtype":"m.text"},"ts":1706242597062,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FcaOvHkHbY9hn2oZI6sso7bJBiaDreg_1Y7FWGHl2q4"},
{"content":{"body":" * I'm not sure, offhand. ","m.mentions":{},"m.new_content":{"body":"I'm not sure, offhand. ","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$FcaOvHkHbY9hn2oZI6sso7bJBiaDreg_1Y7FWGHl2q4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706242626251,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3stwRMWkcCwZG14ZDH-X4hL24b3aD_sBl4FSdctPolw"},
{"content":{"body":"do we have a list of agenda items so we can write down what we need to discuss in the next meeting?","m.mentions":{},"msgtype":"m.text"},"ts":1706259179408,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$DXqRiuwNdvz5cPKX4lH7Mle6nmqtjM6_lXuYlfDfYh0"}
]