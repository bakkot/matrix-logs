[
{"content":{"body":"> <@jackworks:matrix.org> hello, rbuckton will you consider update how customMatchers are written in https://onedrive.live.com/view.aspx?resid=934F1675ED4C1638%21299428&authkey=!AEyZcVuri5fJLbQ (page 17)? It does not match what pattern matching using now in raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html\n\nWhat is the purpose of `receiver` in a custom matcher? ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$fhj0z9ktZ8CUQduZAFtD_aiRjuZRfFwvF7WGiDdm7-c?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>hello, <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a> will you consider update how customMatchers are written in https://onedrive.live.com/view.aspx?resid=934F1675ED4C1638%21299428&amp;authkey=!AEyZcVuri5fJLbQ (page 17)? It does not match what pattern matching using now in raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html</blockquote></mx-reply>What is the purpose of <code>receiver</code> in a custom matcher?","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$fhj0z9ktZ8CUQduZAFtD_aiRjuZRfFwvF7WGiDdm7-c"}},"msgtype":"m.text"},"ts":1706137090639,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TL581_dIUR49BuPkZmm5u1vyKPI0OO7JBRYNBOArD5Q"},
{"content":{"body":"I'm not sure I'm a fan of how InvokeCustomMatcher makes custom matcher implementations more complicated.","m.mentions":{},"msgtype":"m.text"},"ts":1706137364750,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HWHF4_AprNKgol_co7kP6MPXubGKswb8nk_q1WDHykA"},
{"content":{"body":"In the slide you point to, I have to add a number of extra conditions around return values to align with `InvokeCustomMatcher` just doing a ToBoolean on the result when the hint is boolean, and I'm not a huge fan of return type inconsistency.","format":"org.matrix.custom.html","formatted_body":"In the slide you point to, I have to add a number of extra conditions around return values to align with <code>InvokeCustomMatcher</code> just doing a ToBoolean on the result when the hint is boolean, and I'm not a huge fan of return type inconsistency.","m.mentions":{},"msgtype":"m.text"},"ts":1706137490158,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3V4K2HX-65smJ8mkc7bT_xwFh9_jSXB3Rx6ZBv0oCSs"},
{"content":{"body":"In my opinion, a \"hint\" should primarily inform the method as to whether it does or does not need to perform additional computation/allocation when it isn't necessary. Having to check `hint` to ensure my `return { match: false }` isn't interpreted as `true` doesn't really match with the idea of a hint.","format":"org.matrix.custom.html","formatted_body":"In my opinion, a \"hint\" should primarily inform the method as to whether it does or does not need to perform additional computation/allocation when it isn't necessary. Having to check <code>hint</code> to ensure my <code>return { match: false }</code> isn't interpreted as <code>true</code> doesn't really match with the idea of a hint.","m.mentions":{},"msgtype":"m.text"},"ts":1706137874989,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$v_MnSx_1UgwBSzsCV5oty7NB4B4kPuOVmKLCnnsJJQU"},
{"content":{"body":"Is there a reason we consider anything other than `MatchResult | boolean | undefined` to be a valid result? If we restricted the result to just those cases, then we can have simpler custom matcher bodies that only need to elide the `value` portion if it won't be used.","format":"org.matrix.custom.html","formatted_body":"Is there a reason we consider anything other than <code>MatchResult | boolean | undefined</code> to be a valid result? If we restricted the result to just those cases, then we can have simpler custom matcher bodies that only need to elide the <code>value</code> portion if it won't be used.","m.mentions":{},"msgtype":"m.text"},"ts":1706138006109,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$p3Nlkac-guKPolgRa06_nelKgZduiA9afRhgoo2kkB4"},
{"content":{"body":"Ah, I guess it's just boolean or Iterable now?","m.mentions":{},"msgtype":"m.text"},"ts":1706138281352,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ME3bp_rHZa-5wD0E9Zz6bTWN3vmLiCf-ZxXkNwZ82hU"},
{"content":{"body":"To be honest, if we had ADT enums, I'd have suggested we have something like:\n\n```\nenum MatchResult {\n  Fail,\n}","format":"org.matrix.custom.html","formatted_body":"<p>To be honest, if we had ADT enums, I'd have suggested we have something like:</p>\n<pre><code>enum MatchResult {\n  Fail,\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1706138317521,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jeYbyWjY2jyH8xDG3Wu3Wk0z-9dicsKvQP0DvbdFnlk"},
{"content":{"body":" * To be honest, if we had ADT enums, I'd have suggested we have something like:\n\n```\nenum MatchResult {\n  Fail,\n  Pass,\n  One(result),\n  Many(...results)\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>To be honest, if we had ADT enums, I'd have suggested we have something like:</p>\n<pre><code>enum MatchResult {\n  Fail,\n  Pass,\n  One(result),\n  Many(...results)\n}\n</code></pre>\n","m.mentions":{},"m.new_content":{"body":"To be honest, if we had ADT enums, I'd have suggested we have something like:\n\n```\nenum MatchResult {\n  Fail,\n  Pass,\n  One(result),\n  Many(...results)\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>To be honest, if we had ADT enums, I'd have suggested we have something like:</p>\n<pre><code>enum MatchResult {\n  Fail,\n  Pass,\n  One(result),\n  Many(...results)\n}\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$jeYbyWjY2jyH8xDG3Wu3Wk0z-9dicsKvQP0DvbdFnlk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706138330059,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3RMbrRraPVVzMGCJ-KifVuAYPaEGgHkKFKucmkKj3Vo"},
{"content":{"body":"So that we don't need a full iterator protocol for a unary extractor like `when Point({ x, y })`, just to wrap the `{ x, y }` result that will be further destructured.","format":"org.matrix.custom.html","formatted_body":"So that we don't need a full iterator protocol for a unary extractor like <code>when Point({ x, y })</code>, just to wrap the <code>{ x, y }</code> result that will be further destructured.","m.mentions":{},"msgtype":"m.text"},"ts":1706138380321,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NmWzTp3rKbjjKJ8DsS-pJDcrwl3xQiP4P2SjaZ0C568"},
{"content":{"body":" * To be honest, if we had ADT enums, I'd have suggested we have something like:\n\n```\nenum MatchResult {\n  Fail,\n  Pass,\n  One(result),\n  Many(...results)\n}\n```\n\nAnd have a custom matcher return `MatchResult | boolean | undefined`","format":"org.matrix.custom.html","formatted_body":" * <p>To be honest, if we had ADT enums, I'd have suggested we have something like:</p>\n<pre><code>enum MatchResult {\n  Fail,\n  Pass,\n  One(result),\n  Many(...results)\n}\n</code></pre>\n<p>And have a custom matcher return <code>MatchResult | boolean | undefined</code></p>\n","m.mentions":{},"m.new_content":{"body":"To be honest, if we had ADT enums, I'd have suggested we have something like:\n\n```\nenum MatchResult {\n  Fail,\n  Pass,\n  One(result),\n  Many(...results)\n}\n```\n\nAnd have a custom matcher return `MatchResult | boolean | undefined`","format":"org.matrix.custom.html","formatted_body":"<p>To be honest, if we had ADT enums, I'd have suggested we have something like:</p>\n<pre><code>enum MatchResult {\n  Fail,\n  Pass,\n  One(result),\n  Many(...results)\n}\n</code></pre>\n<p>And have a custom matcher return <code>MatchResult | boolean | undefined</code></p>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$jeYbyWjY2jyH8xDG3Wu3Wk0z-9dicsKvQP0DvbdFnlk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706138430043,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$s8LxnyECsCU-lElV0K8ryBj0etmg18hOnolwSjBbvmE"},
{"content":{"body":" * With `MatchResut.One(result)` so that we don't need a full iterator protocol for a unary extractor like `when Point({ x, y })`, just to wrap the `{ x, y }` result that will be further destructured.","format":"org.matrix.custom.html","formatted_body":" * With <code>MatchResut.One(result)</code> so that we don't need a full iterator protocol for a unary extractor like <code>when Point({ x, y })</code>, just to wrap the <code>{ x, y }</code> result that will be further destructured.","m.mentions":{},"m.new_content":{"body":"With `MatchResut.One(result)` so that we don't need a full iterator protocol for a unary extractor like `when Point({ x, y })`, just to wrap the `{ x, y }` result that will be further destructured.","format":"org.matrix.custom.html","formatted_body":"With <code>MatchResut.One(result)</code> so that we don't need a full iterator protocol for a unary extractor like <code>when Point({ x, y })</code>, just to wrap the <code>{ x, y }</code> result that will be further destructured.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$NmWzTp3rKbjjKJ8DsS-pJDcrwl3xQiP4P2SjaZ0C568","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706138461808,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eEeKLIIlDwsPk4BbwdODBr9S8oHRSNayUP5tUzuQYIs"},
{"content":{"body":" * With `MatchResut.One(result)` so that we don't need a full iterator protocol for a unary extractor like `when Point({ x, y })` just to wrap the `{ x, y }` result that will be further destructured.","format":"org.matrix.custom.html","formatted_body":" * With <code>MatchResut.One(result)</code> so that we don't need a full iterator protocol for a unary extractor like <code>when Point({ x, y })</code> just to wrap the <code>{ x, y }</code> result that will be further destructured.","m.mentions":{},"m.new_content":{"body":"With `MatchResut.One(result)` so that we don't need a full iterator protocol for a unary extractor like `when Point({ x, y })` just to wrap the `{ x, y }` result that will be further destructured.","format":"org.matrix.custom.html","formatted_body":"With <code>MatchResut.One(result)</code> so that we don't need a full iterator protocol for a unary extractor like <code>when Point({ x, y })</code> just to wrap the <code>{ x, y }</code> result that will be further destructured.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$NmWzTp3rKbjjKJ8DsS-pJDcrwl3xQiP4P2SjaZ0C568","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1706138466500,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$zKGnx21KMGwGErX56IaTUeq77fXj5HZcf4YQi50df1w"},
{"content":{"body":"> <@rbuckton:matrix.org> In my opinion, a \"hint\" should primarily inform the method as to whether it does or does not need to perform additional computation/allocation when it isn't necessary. Having to check `hint` to ensure my `return { match: false }` isn't interpreted as `true` doesn't really match with the idea of a hint.\n\nAfter further reflection, _hint_ here isn't so bad since I don't need to differentiate between a `{ matched: false }` and a `{ matched: true }` anymore. I still think it would be nice to be able to optimize for the unary-extractor case in some way.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$v_MnSx_1UgwBSzsCV5oty7NB4B4kPuOVmKLCnnsJJQU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>In my opinion, a \"hint\" should primarily inform the method as to whether it does or does not need to perform additional computation/allocation when it isn't necessary. Having to check <code>hint</code> to ensure my <code>return { match: false }</code> isn't interpreted as <code>true</code> doesn't really match with the idea of a hint.</blockquote></mx-reply>After further reflection, <em>hint</em> here isn't so bad since I don't need to differentiate between a <code>{ matched: false }</code> and a <code>{ matched: true }</code> anymore. I still think it would be nice to be able to optimize for the unary-extractor case in some way.","m.mentions":{},"m.relates_to":{"m.in_reply_to":{"event_id":"$v_MnSx_1UgwBSzsCV5oty7NB4B4kPuOVmKLCnnsJJQU"}},"msgtype":"m.text"},"ts":1706138682420,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lY908TRYKdIkT8PMmCswej3GNKqAOYvFm_n7jHTPJPg"}
]