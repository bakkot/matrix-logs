[
{"content":{"body":"> <@ljharb:matrix.org> having it look almost exactly like an object literal seems very hard to teach\n\nIt doesn't seem so bad to me, and there's nothing keeping us from using a different token than `:`. That said, I'm still fine with `when` as a clause indicator inside of `match`. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$7jBriv0s_uuCyqfCEyAzFPZUTshAjmQkejSxnPLIW8Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br />having it look almost exactly like an object literal seems very hard to teach</blockquote></mx-reply>It doesn't seem so bad to me, and there's nothing keeping us from using a different token than <code>:</code>. That said, I'm still fine with <code>when</code> as a clause indicator inside of <code>match</code>.","m.relates_to":{"m.in_reply_to":{"event_id":"$7jBriv0s_uuCyqfCEyAzFPZUTshAjmQkejSxnPLIW8Q"}},"msgtype":"m.text"},"ts":1680225980443,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$cESUibJT3qNXvj-4dFdvrXcPeqUkQFtTkjpEdNPgD-4"},
{"content":{"body":"rbuckton-pto: Was your suggestion for `let` with a destructure, a matcher in a trinary, and an object literal a serious suggestion? Or were you shitposting? I'm finding it hard to respond to that in text without seeming incredulous and/or rude, apologies.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton-pto</a>: Was your suggestion for <code>let</code> with a destructure, a matcher in a trinary, and an object literal a serious suggestion? Or were you shitposting? I'm finding it hard to respond to that in text without seeming incredulous and/or rude, apologies.","msgtype":"m.text"},"ts":1680284437836,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$gKXlt-HwYlUw1q5nz8JzfxdnoKP-18rK3foyg4AhQHM"},
{"content":{"body":"> having it look almost exactly like an object literal seems very hard to teach\n\nIt doesn't, tho? If anything, it looks like a switch(). ^_^","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>having it look almost exactly like an object literal seems very hard to teach</p>\n</blockquote>\n<p>It doesn't, tho? If anything, it looks like a switch(). ^_^</p>\n","msgtype":"m.text"},"ts":1680284496142,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$9W07YSrKGXsdIj36kMm_Xcqp2zsoGuCwvUmr-t-5Ud8"},
{"content":{"body":"But my interest really is just in making sure that matchers are used in as similar a fashion as possible across their usage sites. If match() wraps them in a when(), then everywhere else probably should as well. If everywhere else doesn't, then match() probably shouldn't either. I think this is necessary to make the proposal as a whole feel smooth and easy to digest.","msgtype":"m.text"},"ts":1680284591309,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$_Tft6PmtonpZJaxxYUANYMeNkSjRW2z8A8r1_Qmc5_0"},
{"content":{"body":"And inside of `match()` is perhaps the location *least* requiring of a special wrapper to indicate context, since it's a brand new construct which can *only* contain that one thing! So \"a `when()` inside of `match()`, but naked everywhere else\" is exactly backwards, I think. ^_^","format":"org.matrix.custom.html","formatted_body":"And inside of <code>match()</code> is perhaps the location <em>least</em> requiring of a special wrapper to indicate context, since it's a brand new construct which can <em>only</em> contain that one thing! So &quot;a <code>when()</code> inside of <code>match()</code>, but naked everywhere else&quot; is exactly backwards, I think. ^_^","msgtype":"m.text"},"ts":1680284658787,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$aqOpFkPohnpKAQccuHgvjBrLBdzSnLItjAWfocx_k1I"},
{"content":{"body":"> <@tabatkins:matrix.org> rbuckton-pto: Was your suggestion for `let` with a destructure, a matcher in a trinary, and an object literal a serious suggestion? Or were you shitposting? I'm finding it hard to respond to that in text without seeming incredulous and/or rude, apologies.\n\nNot shitposting, and not sure what seems out of place. I'm not advocating for `assert(val is Point(let x, let y))`, but that would be feasible with `is`.\n\nI don`t find `let when(pattern) = y` useful because we already have destructuring, which has parallels between `let [x] = y` and `[x] = y`. The `let when` syntax has no parallel in expression space. Extractors would also have parallel syntax in binding and assignment patterns.\n\nMatching is somewhat different, however. Matching is a conditional operation, destructuring is not. `let` is not conditional either, so `let when` feels out of place. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$gKXlt-HwYlUw1q5nz8JzfxdnoKP-18rK3foyg4AhQHM?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br /><a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton-pto</a>: Was your suggestion for <code>let</code> with a destructure, a matcher in a trinary, and an object literal a serious suggestion? Or were you shitposting? I'm finding it hard to respond to that in text without seeming incredulous and/or rude, apologies.</blockquote></mx-reply><p>Not shitposting, and not sure what seems out of place. I'm not advocating for <code>assert(val is Point(let x, let y))</code>, but that would be feasible with <code>is</code>.</p>\n<p>I don<code>t find </code>let when(pattern) = y<code>useful because we already have destructuring, which has parallels between</code>let [x] = y<code>and</code>[x] = y<code>. The </code>let when` syntax has no parallel in expression space. Extractors would also have parallel syntax in binding and assignment patterns.</p>\n<p>Matching is somewhat different, however. Matching is a conditional operation, destructuring is not. <code>let</code> is not conditional either, so <code>let when</code> feels out of place.</p>","m.relates_to":{"m.in_reply_to":{"event_id":"$gKXlt-HwYlUw1q5nz8JzfxdnoKP-18rK3foyg4AhQHM"}},"msgtype":"m.text"},"ts":1680286715620,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$3m41pBEu4uwcoEMvu4m50_9ovcnxZk8YGeLhBHegj9g"},
{"content":{"body":"What seemed out of place was just that it was *ridiculously* verbose. You have to name each binding *three times* to smuggle it out. Considering the objections to my earlier syntax suggestions based on the verbosity of an extra `match` and `when()`, it seemed somewhat contradictory to suggest such a pattern is best spelled so roundabout and verbosely. ^_^","format":"org.matrix.custom.html","formatted_body":"What seemed out of place was just that it was <em>ridiculously</em> verbose. You have to name each binding <em>three times</em> to smuggle it out. Considering the objections to my earlier syntax suggestions based on the verbosity of an extra <code>match</code> and <code>when()</code>, it seemed somewhat contradictory to suggest such a pattern is best spelled so roundabout and verbosely. ^_^","msgtype":"m.text"},"ts":1680286852144,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$ZWOEPK2l9dRAzTsZAUh4SBjTzjMOrsdR_RvMjNZh2do"},
{"content":{"body":"Re: the parallel between expression and destructuring: Matchers also have `[]` and `{}`, tho. And I'm coming around pretty well to the extractor pattern being the primary way to do custom matchers (but still having ${} as an escape hatch, possibly), so that also matches up. ","format":"org.matrix.custom.html","formatted_body":"Re: the parallel between expression and destructuring: Matchers also have <code>[]</code> and <code>{}</code>, tho. And I'm coming around pretty well to the extractor pattern being the primary way to do custom matchers (but still having ${} as an escape hatch, possibly), so that also matches up.","msgtype":"m.text"},"ts":1680286965381,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$c4Vdw-TgLkygBiep3BpdilEcWtLafQYe2f-1RwDobik"},
{"content":{"body":"So I'm not sure I understand - is it just that matchers can be *more powerful* than that? Even tho the common case is not, and they'll usually very closely resemble destructuring?","format":"org.matrix.custom.html","formatted_body":"So I'm not sure I understand - is it just that matchers can be <em>more powerful</em> than that? Even tho the common case is not, and they'll usually very closely resemble destructuring?","msgtype":"m.text"},"ts":1680287003049,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$YThBoEGjrCfnVnRKpzCo7buIHYIZj8WO_4Bxw0T7v14"},
{"content":{"body":"The `let { x, y } =` example is verbose, yes, but uses what could otherwise be regular js in the initializer. ","format":"org.matrix.custom.html","formatted_body":"The <code>let { x, y } =</code> example is verbose, yes, but uses what could otherwise be regular js in the initializer.","msgtype":"m.text"},"ts":1680287177119,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$EAle9zVrVs2voKTVsqSHIlkfcF01zBmLSOaptZwRhZI"},
{"content":{"body":"I don't understand why that's a benefit here, considering we're talking about new syntax.","msgtype":"m.text"},"ts":1680287240888,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$FPswgBvUEw0hjuU3a7wWgO7dYXIOI41wz-TmCDqMyTA"},
{"content":{"body":"In a way it's meant to illustrate that a `let` statement isn't a good fit for pattern matching itself, because matching is conditional and `let` is not. ","format":"org.matrix.custom.html","formatted_body":"In a way it's meant to illustrate that a <code>let</code> statement isn't a good fit for pattern matching itself, because matching is conditional and <code>let</code> is not.","msgtype":"m.text"},"ts":1680287245151,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$NF1gtEb3f_FFDIyq_gTWxutAWLP8GDZK0Y5vFfcF-uE"},
{"content":{"body":"The closest you get to a useful example is the `assert` one, because you need to validate the condition was successful. ","format":"org.matrix.custom.html","formatted_body":"The closest you get to a useful example is the <code>assert</code> one, because you need to validate the condition was successful.","msgtype":"m.text"},"ts":1680287285909,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$umfyQ1HES91CmGxtY-iGosOF7ljnQSa9u7Q8NU2cMsw"},
{"content":{"body":"Let's discuss that point directly, then, rather than trying to insinuate it via intentionally bad examples. ^_^","msgtype":"m.text"},"ts":1680287328167,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$K3eTC2QB0qO-4iHCDA0l6wpkzFcfkZFlXey1nXX1qF4"},
{"content":{"body":"It's hard to have this conversation right now. My PC is disconnected for a move and my laptop is packed. I'm currently on matrix from my phone","msgtype":"m.text"},"ts":1680287386299,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$25P3jPUaVDT0jZEat34Kkat_rYMK-zfo0_uVAr6UJFA"},
{"content":{"body":"Not a problem. ^_^ go! be on vacation! stop responding!","msgtype":"m.text"},"ts":1680287413262,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$nVWw3HlDrsiL_-wsmov8_v44vjgemN0HaS0eWQQ1L-w"},
{"content":{"body":"The `let { x, y }` example seems like a bad example, but it isn't far from a real world example in many pattern matching languages. In a lot of cases, you will see a value branch on different patterns using something like `match`, but may need to provide more than one result. Consider this example that uses a combination of `match`, extractors, and ADT enums to represent movement in a 2D game\n\n```js\nconst { dx, dy } = match (action) {\n  when Action.Move({ direction: \"north\", distance: let dist }): { dx: 0, dy: dist },\n  when Action.Move({ direction: \"south\", distance: let dist }): { dx: 0, dy: -dist },\n  when Action.Move({ direction: \"east\", distance: let dist }): { dx: dist, dy: 0 },\n  when Action.Move({ direction: \"west\", distance: let dist }): { dx: -dist, dy: 0 } \n};\n```\n\nThis is a perfectly reasonable pattern, and exhibits the exact same behavior as my other example.","format":"org.matrix.custom.html","formatted_body":"<p>The <code>let { x, y }</code> example seems like a bad example, but it isn't far from a real world example in many pattern matching languages. In a lot of cases, you will see a value branch on different patterns using something like <code>match</code>, but may need to provide more than one result. Consider this example that uses a combination of <code>match</code>, extractors, and ADT enums to represent movement in a 2D game</p>\n<pre><code class=\"language-js\">const { dx, dy } = match (action) {\n  when Action.Move({ direction: &quot;north&quot;, distance: let dist }): { dx: 0, dy: dist },\n  when Action.Move({ direction: &quot;south&quot;, distance: let dist }): { dx: 0, dy: -dist },\n  when Action.Move({ direction: &quot;east&quot;, distance: let dist }): { dx: dist, dy: 0 },\n  when Action.Move({ direction: &quot;west&quot;, distance: let dist }): { dx: -dist, dy: 0 } \n};\n</code></pre>\n<p>This is a perfectly reasonable pattern, and exhibits the exact same behavior as my other example.</p>\n","msgtype":"m.text"},"ts":1680288561978,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$uEtIfn4cRmn_CkkxCHFFsU9Usybko87LD6Nsy5R8W1A"},
{"content":{"body":" * The `let { x, y }` example seems like a bad example, but it isn't far from a real world example in many pattern matching languages. In a lot of cases, you will see a value branch on different patterns using something like `match`, but may need to provide more than one result. Consider this example that uses a combination of `match`, extractors/ADT enums to represent movement in a 2D game\n\n```js\nconst { dx, dy } = match (action) {\n  when Action.Move({ direction: \"north\", distance: let dist }): { dx: 0, dy: dist },\n  when Action.Move({ direction: \"south\", distance: let dist }): { dx: 0, dy: -dist },\n  when Action.Move({ direction: \"east\", distance: let dist }): { dx: dist, dy: 0 },\n  when Action.Move({ direction: \"west\", distance: let dist }): { dx: -dist, dy: 0 } \n};\n```\n\nThis is a perfectly reasonable pattern, and exhibits the exact same behavior as my other example.","format":"org.matrix.custom.html","formatted_body":" * <p>The <code>let { x, y }</code> example seems like a bad example, but it isn't far from a real world example in many pattern matching languages. In a lot of cases, you will see a value branch on different patterns using something like <code>match</code>, but may need to provide more than one result. Consider this example that uses a combination of <code>match</code>, extractors/ADT enums to represent movement in a 2D game</p>\n<pre><code class=\"language-js\">const { dx, dy } = match (action) {\n  when Action.Move({ direction: &quot;north&quot;, distance: let dist }): { dx: 0, dy: dist },\n  when Action.Move({ direction: &quot;south&quot;, distance: let dist }): { dx: 0, dy: -dist },\n  when Action.Move({ direction: &quot;east&quot;, distance: let dist }): { dx: dist, dy: 0 },\n  when Action.Move({ direction: &quot;west&quot;, distance: let dist }): { dx: -dist, dy: 0 } \n};\n</code></pre>\n<p>This is a perfectly reasonable pattern, and exhibits the exact same behavior as my other example.</p>\n","m.new_content":{"body":"The `let { x, y }` example seems like a bad example, but it isn't far from a real world example in many pattern matching languages. In a lot of cases, you will see a value branch on different patterns using something like `match`, but may need to provide more than one result. Consider this example that uses a combination of `match`, extractors/ADT enums to represent movement in a 2D game\n\n```js\nconst { dx, dy } = match (action) {\n  when Action.Move({ direction: \"north\", distance: let dist }): { dx: 0, dy: dist },\n  when Action.Move({ direction: \"south\", distance: let dist }): { dx: 0, dy: -dist },\n  when Action.Move({ direction: \"east\", distance: let dist }): { dx: dist, dy: 0 },\n  when Action.Move({ direction: \"west\", distance: let dist }): { dx: -dist, dy: 0 } \n};\n```\n\nThis is a perfectly reasonable pattern, and exhibits the exact same behavior as my other example.","format":"org.matrix.custom.html","formatted_body":"<p>The <code>let { x, y }</code> example seems like a bad example, but it isn't far from a real world example in many pattern matching languages. In a lot of cases, you will see a value branch on different patterns using something like <code>match</code>, but may need to provide more than one result. Consider this example that uses a combination of <code>match</code>, extractors/ADT enums to represent movement in a 2D game</p>\n<pre><code class=\"language-js\">const { dx, dy } = match (action) {\n  when Action.Move({ direction: &quot;north&quot;, distance: let dist }): { dx: 0, dy: dist },\n  when Action.Move({ direction: &quot;south&quot;, distance: let dist }): { dx: 0, dy: -dist },\n  when Action.Move({ direction: &quot;east&quot;, distance: let dist }): { dx: dist, dy: 0 },\n  when Action.Move({ direction: &quot;west&quot;, distance: let dist }): { dx: -dist, dy: 0 } \n};\n</code></pre>\n<p>This is a perfectly reasonable pattern, and exhibits the exact same behavior as my other example.</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$uEtIfn4cRmn_CkkxCHFFsU9Usybko87LD6Nsy5R8W1A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1680288599526,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$a9KtIYV6w90HsfFoCVNnsFFmaeY9pNOPLsY_ZSx0a84"},
{"content":{"body":"Which could also be composed with `is` (and something like throw expressions):\n\n```js\nconst { dx, dy } = \n  action is Action.Move({ direction: \"north\", distance: let dist }) ? { dx: 0, dy: dist } :\n  action is Action.Move({ direction: \"south\", distance: let dist }) ? { dx: 0, dy: -dist } :\n  action is Action.Move({ direction: \"east\", distance: let dist }) ? { dx: dist, dy: 0 } :\n  action is Action.Move({ direction: \"west\", distance: let dist }): { dx: -dist, dy: 0 } :\n  (throw new MatchError());\n```","format":"org.matrix.custom.html","formatted_body":"<p>Which could also be composed with <code>is</code> (and something like throw expressions):</p>\n<pre><code class=\"language-js\">const { dx, dy } = \n  action is Action.Move({ direction: &quot;north&quot;, distance: let dist }) ? { dx: 0, dy: dist } :\n  action is Action.Move({ direction: &quot;south&quot;, distance: let dist }) ? { dx: 0, dy: -dist } :\n  action is Action.Move({ direction: &quot;east&quot;, distance: let dist }) ? { dx: dist, dy: 0 } :\n  action is Action.Move({ direction: &quot;west&quot;, distance: let dist }): { dx: -dist, dy: 0 } :\n  (throw new MatchError());\n</code></pre>\n","msgtype":"m.text"},"ts":1680288735240,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$uaLo4Tq8BluJFxqdVpOPGQil5vBCLbbQTnCR_Lks824"},
{"content":{"body":"(I pulled out my laptop to write that up)","msgtype":"m.text"},"ts":1680288758597,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$fJFhvIwsuwBM3gzD-qCgnd4QnkH6eZZTA1mlvl1M1Mk"},
{"content":{"body":"Ok, now I'll break for a bit. I'll catch up more next week.","msgtype":"m.text"},"ts":1680288794254,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$TOWt-NNqYlMTMobpqgtDbLvyUCksMT_OOOVQug4_auE"},
{"content":{"body":" * Which could also be composed with `is` (and something like throw expressions):\n\n```js\nconst { dx, dy } = \n  action is Action.Move({ direction: \"north\", distance: let dist }) ? { dx: 0, dy: dist } :\n  action is Action.Move({ direction: \"south\", distance: let dist }) ? { dx: 0, dy: -dist } :\n  action is Action.Move({ direction: \"east\", distance: let dist }) ? { dx: dist, dy: 0 } :\n  action is Action.Move({ direction: \"west\", distance: let dist }) ? { dx: -dist, dy: 0 } :\n  (throw new MatchError());\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Which could also be composed with <code>is</code> (and something like throw expressions):</p>\n<pre><code class=\"language-js\">const { dx, dy } = \n  action is Action.Move({ direction: &quot;north&quot;, distance: let dist }) ? { dx: 0, dy: dist } :\n  action is Action.Move({ direction: &quot;south&quot;, distance: let dist }) ? { dx: 0, dy: -dist } :\n  action is Action.Move({ direction: &quot;east&quot;, distance: let dist }) ? { dx: dist, dy: 0 } :\n  action is Action.Move({ direction: &quot;west&quot;, distance: let dist }) ? { dx: -dist, dy: 0 } :\n  (throw new MatchError());\n</code></pre>\n","m.new_content":{"body":"Which could also be composed with `is` (and something like throw expressions):\n\n```js\nconst { dx, dy } = \n  action is Action.Move({ direction: \"north\", distance: let dist }) ? { dx: 0, dy: dist } :\n  action is Action.Move({ direction: \"south\", distance: let dist }) ? { dx: 0, dy: -dist } :\n  action is Action.Move({ direction: \"east\", distance: let dist }) ? { dx: dist, dy: 0 } :\n  action is Action.Move({ direction: \"west\", distance: let dist }) ? { dx: -dist, dy: 0 } :\n  (throw new MatchError());\n```","format":"org.matrix.custom.html","formatted_body":"<p>Which could also be composed with <code>is</code> (and something like throw expressions):</p>\n<pre><code class=\"language-js\">const { dx, dy } = \n  action is Action.Move({ direction: &quot;north&quot;, distance: let dist }) ? { dx: 0, dy: dist } :\n  action is Action.Move({ direction: &quot;south&quot;, distance: let dist }) ? { dx: 0, dy: -dist } :\n  action is Action.Move({ direction: &quot;east&quot;, distance: let dist }) ? { dx: dist, dy: 0 } :\n  action is Action.Move({ direction: &quot;west&quot;, distance: let dist }) ? { dx: -dist, dy: 0 } :\n  (throw new MatchError());\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$uaLo4Tq8BluJFxqdVpOPGQil5vBCLbbQTnCR_Lks824","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1680288801199,"senderName":"rbuckton-pto","senderId":"@rbuckton:matrix.org","id":"$LpTUjc8Ofm64sZ3Ho3Cxas49tSvbS8Ty4-0-VHDG-w4"},
{"content":{"body":"Yes, that's more reasonable when there are many branches, because you're also communicating what parts of the potentially-quite-different patterns are being condensed into the set of common bindings. That's useful to communicate in the code!","msgtype":"m.text"},"ts":1680289441452,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$yLhmqddRIMoF6fVGHg0XtK270T2hwCZziSllx-3hJ7o"},
{"content":{"body":"But that's not a relevant concern when you're evaluating one single branch.","msgtype":"m.text"},"ts":1680289461109,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$4rGSS9ThzWz3YaseUoSPq2e4gndThqRprSQ4Y1zrK4A"}
]