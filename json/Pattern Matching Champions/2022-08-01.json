[
{"content":{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","format":"org.matrix.custom.html","formatted_body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/plain"},{"body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/html"}]},"ts":1659361858951,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$Vqs7t7HFbsyu9HxQATUWcaZvT_pAi1pHl7aYer7yki0"},
{"content":{"body":"I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions","msgtype":"m.text","org.matrix.msc1767.text":"I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions"},"ts":1659361909431,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$1k3DL-ho4zGMxKO7xgQEl7dFrh_poADrsPqZX3CXIFo"},
{"content":{"body":" * why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions","format":"org.matrix.custom.html","formatted_body":" * why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions","m.new_content":{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions","format":"org.matrix.custom.html","formatted_body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions","mimetype":"text/plain"},{"body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$Vqs7t7HFbsyu9HxQATUWcaZvT_pAi1pHl7aYer7yki0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions","mimetype":"text/plain"},{"body":" * why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions","mimetype":"text/html"}]},"ts":1659361951937,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$e0S4rak2qzkao2q_1qWp4PxyEKCDxotjlvLwjjmncrY"},
{"content":{"body":" * why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","format":"org.matrix.custom.html","formatted_body":" * why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","m.new_content":{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","format":"org.matrix.custom.html","formatted_body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/plain"},{"body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$Vqs7t7HFbsyu9HxQATUWcaZvT_pAi1pHl7aYer7yki0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/plain"},{"body":" * why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/html"}]},"ts":1659361963089,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$N_CctHwvV1HbRmnZLwnH165K_ffDnIBgYciG7dZtWPA"},
{"content":{"body":"I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","format":"org.matrix.custom.html","formatted_body":"<p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","mimetype":"text/plain"},{"body":"<p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","mimetype":"text/html"}]},"ts":1659368774608,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-_u8_N8LM7ffk8v1UibcxzYWMSc0X2CQ52uJvvNQpIc"},
{"content":{"body":" * I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","format":"org.matrix.custom.html","formatted_body":" * <p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","m.new_content":{"body":"I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","format":"org.matrix.custom.html","formatted_body":"<p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","mimetype":"text/plain"},{"body":"<p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$-_u8_N8LM7ffk8v1UibcxzYWMSc0X2CQ52uJvvNQpIc","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","mimetype":"text/plain"},{"body":" * <p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","mimetype":"text/html"}]},"ts":1659368813113,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UikZkr11U5rYrjR4tmA9VJ8Ob6wY7n6BKIBGiTA6E_8"},
{"content":{"body":"> <@yulia:mozilla.org> I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions\n\nIn my list above I reference function and parameter decorators as needing to have *some* knowledge of overloads, which is a further complication especially in regards to proposals such as Decorator Metadata.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$1k3DL-ho4zGMxKO7xgQEl7dFrh_poADrsPqZX3CXIFo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@yulia:mozilla.org\">@yulia:mozilla.org</a><br>I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions</blockquote></mx-reply>In my list above I reference function and parameter decorators as needing to have <em>some</em> knowledge of overloads, which is a further complication especially in regards to proposals such as Decorator Metadata.","m.relates_to":{"m.in_reply_to":{"event_id":"$1k3DL-ho4zGMxKO7xgQEl7dFrh_poADrsPqZX3CXIFo"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@yulia:mozilla.org> I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions\n\nIn my list above I reference function and parameter decorators as needing to have *some* knowledge of overloads, which is a further complication especially in regards to proposals such as Decorator Metadata.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$1k3DL-ho4zGMxKO7xgQEl7dFrh_poADrsPqZX3CXIFo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@yulia:mozilla.org\">@yulia:mozilla.org</a><br>I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions</blockquote></mx-reply>In my list above I reference function and parameter decorators as needing to have <em>some</em> knowledge of overloads, which is a further complication especially in regards to proposals such as Decorator Metadata.","mimetype":"text/html"}]},"ts":1659368950448,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5szA4CXP5I44JAUO3l_-0gfUVKrgRSx-TNiMza4AdU0"}
]