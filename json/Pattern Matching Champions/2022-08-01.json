[
{"content":{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","format":"org.matrix.custom.html","formatted_body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/plain"},{"body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/html"}]},"ts":1659361858951,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$Vqs7t7HFbsyu9HxQATUWcaZvT_pAi1pHl7aYer7yki0"},
{"content":{"body":"I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions","msgtype":"m.text","org.matrix.msc1767.text":"I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions"},"ts":1659361909431,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$1k3DL-ho4zGMxKO7xgQEl7dFrh_poADrsPqZX3CXIFo"},
{"content":{"body":" * why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions","format":"org.matrix.custom.html","formatted_body":" * why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions","m.new_content":{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions","format":"org.matrix.custom.html","formatted_body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions","mimetype":"text/plain"},{"body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$Vqs7t7HFbsyu9HxQATUWcaZvT_pAi1pHl7aYer7yki0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions","mimetype":"text/plain"},{"body":" * why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions","mimetype":"text/html"}]},"ts":1659361951937,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$e0S4rak2qzkao2q_1qWp4PxyEKCDxotjlvLwjjmncrY"},
{"content":{"body":" * why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","format":"org.matrix.custom.html","formatted_body":" * why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","m.new_content":{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","format":"org.matrix.custom.html","formatted_body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/plain"},{"body":"why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$Vqs7t7HFbsyu9HxQATUWcaZvT_pAi1pHl7aYer7yki0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * why is this potentially a bad path? I am not sure I understand your example with `f.toString` ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/plain"},{"body":" * why is this potentially a bad path? I am not sure I understand your example with <code>f.toString</code> ? Is it an issue if we do something custom here? It can include multiple definitions. That is the case for other languages such as idris iirc","mimetype":"text/html"}]},"ts":1659361963089,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$N_CctHwvV1HbRmnZLwnH165K_ffDnIBgYciG7dZtWPA"},
{"content":{"body":"I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","format":"org.matrix.custom.html","formatted_body":"<p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","mimetype":"text/plain"},{"body":"<p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","mimetype":"text/html"}]},"ts":1659368774608,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-_u8_N8LM7ffk8v1UibcxzYWMSc0X2CQ52uJvvNQpIc"},
{"content":{"body":" * I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","format":"org.matrix.custom.html","formatted_body":" * <p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","m.new_content":{"body":"I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","format":"org.matrix.custom.html","formatted_body":"<p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","mimetype":"text/plain"},{"body":"<p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$-_u8_N8LM7ffk8v1UibcxzYWMSc0X2CQ52uJvvNQpIc","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:\n\n- Would each overload be an independent function reference, or are they somehow nested inside the function?\n- How would this apply to `F.p.bind`? Do we match during `.bind` or when the final function is invoked?\n- How would this apply to `Proxy`?\n- How would this affect `new F()` and the resulting `new.target`, prototypes, etc.\n- If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n- How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?\n\nGiven that its easy enough to write `(x) => match(x) { ... }` or `function f(x) { return match(x) { ... } }`, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.","mimetype":"text/plain"},{"body":" * <p>I am concerned we could be jumping the gun introducing overloads purely for pattern matching purposes, with Type Annotations on the table. True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future. There are a number of questions we could ask now whose answers could change dramatically in 3-5 years:</p>\n<ul>\n<li>Would each overload be an independent function reference, or are they somehow nested inside the function?</li>\n<li>How would this apply to <code>F.p.bind</code>? Do we match during <code>.bind</code> or when the final function is invoked?</li>\n<li>How would this apply to <code>Proxy</code>?</li>\n<li>How would this affect <code>new F()</code> and the resulting <code>new.target</code>, prototypes, etc.</li>\n<li>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</li>\n<li>How would this be impacted by a potential future including type annotations, metadata, reflection, binary AST, etc?</li>\n</ul>\n<p>Given that its easy enough to write <code>(x) =&gt; match(x) { ... }</code> or <code>function f(x) { return match(x) { ... } }</code>, I don't think introducing overloads this early in the game would be advisable. At the very least, it shouldn't be tied to a v1 of pattern matching as I believe that would result in the feature sitting in limbo for a decade while we try to sort out cross-cutting concerns.</p>\n","mimetype":"text/html"}]},"ts":1659368813113,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UikZkr11U5rYrjR4tmA9VJ8Ob6wY7n6BKIBGiTA6E_8"},
{"content":{"body":"> <@yulia:mozilla.org> I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions\n\nIn my list above I reference function and parameter decorators as needing to have *some* knowledge of overloads, which is a further complication especially in regards to proposals such as Decorator Metadata.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$1k3DL-ho4zGMxKO7xgQEl7dFrh_poADrsPqZX3CXIFo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@yulia:mozilla.org\">@yulia:mozilla.org</a><br>I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions</blockquote></mx-reply>In my list above I reference function and parameter decorators as needing to have <em>some</em> knowledge of overloads, which is a further complication especially in regards to proposals such as Decorator Metadata.","m.relates_to":{"m.in_reply_to":{"event_id":"$1k3DL-ho4zGMxKO7xgQEl7dFrh_poADrsPqZX3CXIFo"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@yulia:mozilla.org> I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions\n\nIn my list above I reference function and parameter decorators as needing to have *some* knowledge of overloads, which is a further complication especially in regards to proposals such as Decorator Metadata.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$1k3DL-ho4zGMxKO7xgQEl7dFrh_poADrsPqZX3CXIFo?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@yulia:mozilla.org\">@yulia:mozilla.org</a><br>I am also not sure that this will be a problem with decorators on parameters. This is the same as having internal functions</blockquote></mx-reply>In my list above I reference function and parameter decorators as needing to have <em>some</em> knowledge of overloads, which is a further complication especially in regards to proposals such as Decorator Metadata.","mimetype":"text/html"}]},"ts":1659368950448,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5szA4CXP5I44JAUO3l_-0gfUVKrgRSx-TNiMza4AdU0"},
{"content":{"body":"Method decorators are already stage 3 and have no concept of overloads. Introducing overloads that point to the same function reference would cause issues if decorator libraries aren't written to handle that case, and most won't be. ","msgtype":"m.text","org.matrix.msc1767.text":"Method decorators are already stage 3 and have no concept of overloads. Introducing overloads that point to the same function reference would cause issues if decorator libraries aren't written to handle that case, and most won't be. "},"ts":1659369051068,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NGHc4yv1aEyr5uTApHQVotByR42sQ7Ped_wScBY4YpI"},
{"content":{"body":"Consider a class built to handle server-side HTTP routes:\n\n```js\nclass HttpRoutes {\n  @route(\"GET\", \"/products\")\n  getProducts(req) { ... }\n\n  @route(\"GET\", \"/products/{id}\")\n  getProduct(req) { ... }\n}\n```\n\nThe route might attach metadata to the method that would be used to pick the method to execute when a request is handled. Then we introduce overloads for pattern matching and someone else decides to write:\n\n```js\nclass HttpRoutes {\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n}\n```\nWithout updating the decorator library, the metadata for `get` might be overwritten, or might be potentially unreachable if each method is nested internally.","format":"org.matrix.custom.html","formatted_body":"<p>Consider a class built to handle server-side HTTP routes:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  getProducts(req) { ... }\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  getProduct(req) { ... }\n}\n</code></pre>\n<p>The route might attach metadata to the method that would be used to pick the method to execute when a request is handled. Then we introduce overloads for pattern matching and someone else decides to write:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n}\n</code></pre>\n<p>Without updating the decorator library, the metadata for <code>get</code> might be overwritten, or might be potentially unreachable if each method is nested internally.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Consider a class built to handle server-side HTTP routes:\n\n```js\nclass HttpRoutes {\n  @route(\"GET\", \"/products\")\n  getProducts(req) { ... }\n\n  @route(\"GET\", \"/products/{id}\")\n  getProduct(req) { ... }\n}\n```\n\nThe route might attach metadata to the method that would be used to pick the method to execute when a request is handled. Then we introduce overloads for pattern matching and someone else decides to write:\n\n```js\nclass HttpRoutes {\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n}\n```\nWithout updating the decorator library, the metadata for `get` might be overwritten, or might be potentially unreachable if each method is nested internally.","mimetype":"text/plain"},{"body":"<p>Consider a class built to handle server-side HTTP routes:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  getProducts(req) { ... }\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  getProduct(req) { ... }\n}\n</code></pre>\n<p>The route might attach metadata to the method that would be used to pick the method to execute when a request is handled. Then we introduce overloads for pattern matching and someone else decides to write:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n}\n</code></pre>\n<p>Without updating the decorator library, the metadata for <code>get</code> might be overwritten, or might be potentially unreachable if each method is nested internally.</p>\n","mimetype":"text/html"}]},"ts":1659369391202,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wqaWYDk_fOu1gVrRxRQgDB9YZSJC7Dy7fux2889-EHs"},
{"content":{"body":"So you then run into a versioning and/or documentation problem.","msgtype":"m.text","org.matrix.msc1767.text":"So you then run into a versioning and/or documentation problem."},"ts":1659369412498,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$GO-KEdyrCT6u2xDc8XMmTNtZ5bwuPUtXU7WRsHNr63Q"},
{"content":{"body":"Also, let me know if there's a better way to handle this discussion given the issues with your wrist. I had a comminuted fracture in my left wrist about 15 years ago, and daily pain ever since (worse on some days than others), so I can at least partially relate to how difficult typing can be at times.","msgtype":"m.text","org.matrix.msc1767.text":"Also, let me know if there's a better way to handle this discussion given the issues with your wrist. I had a comminuted fracture in my left wrist about 15 years ago, and daily pain ever since (worse on some days than others), so I can at least partially relate to how difficult typing can be at times."},"ts":1659369725799,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2t_gxgu-_tYMmFXf2zKdUzHY2AnlK-LootYnO7KHP4Y"},
{"content":{"body":" * Also, let me know if there's a better way to handle this discussion given the issues with your wrist. I had a comminuted fracture in my left wrist about 15 years ago, and daily pain ever since (worse on some days than others), so I can at least partially relate to how difficult typing can be at times.","m.new_content":{"body":"Also, let me know if there's a better way to handle this discussion given the issues with your wrist. I had a comminuted fracture in my left wrist about 15 years ago, and daily pain ever since (worse on some days than others), so I can at least partially relate to how difficult typing can be at times.","msgtype":"m.text","org.matrix.msc1767.text":"Also, let me know if there's a better way to handle this discussion given the issues with your wrist. I had a comminuted fracture in my left wrist about 15 years ago, and daily pain ever since (worse on some days than others), so I can at least partially relate to how difficult typing can be at times."},"m.relates_to":{"event_id":"$2t_gxgu-_tYMmFXf2zKdUzHY2AnlK-LootYnO7KHP4Y","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * Also, let me know if there's a better way to handle this discussion given the issues with your wrist. I had a comminuted fracture in my left wrist about 15 years ago, and daily pain ever since (worse on some days than others), so I can at least partially relate to how difficult typing can be at times."},"ts":1659369885117,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JMfGPARUn2SvDSVBU6Emmf6F8UP0XZVZ4QPM-6kScaU"},
{"content":{"body":"ahaha yeah it would be better to have a call","msgtype":"m.text","org.matrix.msc1767.text":"ahaha yeah it would be better to have a call"},"ts":1659370187980,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$zO9Bl-tx3b4jyOhl9f7MXOydqXjaQfqUDgNBnJ8GYZE"},
{"content":{"body":"but, i already typed this up so","msgtype":"m.text","org.matrix.msc1767.text":"but, i already typed this up so"},"ts":1659370196152,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$oeRvbFQTEjcb3rWZi04yFyPYALDwv_dpIoGtQBoyTCs"},
{"content":{"body":"> with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\nFrom the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards. \n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<p>From the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards.</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\nFrom the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards. \n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","mimetype":"text/plain"},{"body":"<blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<p>From the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards.</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","mimetype":"text/html"}]},"ts":1659370403909,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$qyZqgiIk2KVR5Lv3kwEk3hk34okoLwOYvHVA40nZVOI"},
{"content":{"body":" * > with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","m.new_content":{"body":"> with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","mimetype":"text/plain"},{"body":"<blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$qyZqgiIk2KVR5Lv3kwEk3hk34okoLwOYvHVA40nZVOI","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * > with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","mimetype":"text/plain"},{"body":" * <blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","mimetype":"text/html"}]},"ts":1659370426675,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$_LuPXA77uzFEn6KNC99DHxrn30Ai0ns1qvGO5gG0vVU"},
{"content":{"body":" * > with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\nFrom the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards. \n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","format":"org.matrix.custom.html","formatted_body":" * <blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<p>From the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards.</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","m.new_content":{"body":"> with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\nFrom the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards. \n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<p>From the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards.</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\nFrom the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards. \n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","mimetype":"text/plain"},{"body":"<blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<p>From the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards.</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$qyZqgiIk2KVR5Lv3kwEk3hk34okoLwOYvHVA40nZVOI","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * > with Type Annotations on the table\n\n(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an _very interesting_ companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.\n\nbin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.\n\n> True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future\n\nI rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.\n\n> Would each overload be an independent function reference, or are they somehow nested inside the function?\n\nThis is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.\n\n> How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?\n\nyes, if we take the table approach, then\n\n```js\nfunction foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n```\n\n(but really, the interesting thing is when you _dont_ have the default case.)\n\nFrom the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards. \n\n> How would this apply to Proxy?\n\nwhat precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\n> How would this affect new F() and the resulting new.target, prototypes, etc.\n\nOne way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.\n\n> If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nAn decorator would apply to its direct shaped function. So, for example:\n\n```js\nclass HttpRoutes {\n\n  @route(\"GET\", \"/products\")\n  get(req when { url: \"/products\" }) { ...}\n\n  @route(\"GET\", \"/products/{id}\")\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(\"GET\", \"/products\")\n  _internal_shapedget_1(req when { url: \"/products\" }) { ...}\n\n    @route(\"GET\", \"/products/{id}\")\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: \"/products\" }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n```\n\nand, you can likely imagine what would happen if the default behavior had a decorator\n\n> If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?\n\nHopefully the above answers this question?","mimetype":"text/plain"},{"body":" * <blockquote>\n<p>with Type Annotations on the table</p>\n</blockquote>\n<p>(you also mentioned bin ast, and other things here so ill try to answer everything... but i lost it) I believe this is an <em>very interesting</em> companion to type annotations. In fact, I was thinking that it may be interesting to have matchers written via the interface keyword. This may allow us to share both runtime behavior (that, due to being able to throw, can have interesting implications for both safety and optimization) and static information. I don't see this as in opposition and have been chatting with the typescript folks. They don't hate it so far. These may work very well together in fact.</p>\n<p>bin-ast doesn't have much support at the moment. I am not sure why this would be in opposition to metadata or reflection. Maybe you have an example i can consider.</p>\n<blockquote>\n<p>True static typing may not be on the table now, but designing overloads purely for pattern matching could put us in a poor position in the future</p>\n</blockquote>\n<p>I rather strongly disagree. In fact i think the opposite. This has been described to me as one of the weaknesses of typescript -- that they have no impact at run time. What guards and typed objects were proposed to be were runtime checks that can also be used as static information.</p>\n<blockquote>\n<p>Would each overload be an independent function reference, or are they somehow nested inside the function?</p>\n</blockquote>\n<p>This is open for discussion. A reasonable implementation would to have a match inside of an intermediate function. Effectively pointing to a table that then routes you to the correct functionality.</p>\n<blockquote>\n<p>How would this apply to F.p.bind? Do we match during .bind or when the final function is invoked?</p>\n</blockquote>\n<p>yes, if we take the table approach, then</p>\n<pre><code class=\"language-js\">function foo(x when a) { /*...*/} \n\nfunction foo( x when b) { /*...*/}\n\nfunction foo( x) { /*...*/ }\n\n\n// under the hood, so to speak\n\nfunction foo (x) {\n  match(x) {\n    when a: _internal_shapedFoo_1(x)\n    when b: _internal_shapedFoo_2(x)\n    default : _internal_Foo_default(x)\n  }\n}\n</code></pre>\n<p>(but really, the interesting thing is when you <em>dont</em> have the default case.)</p>\n<p>From the engine perspective, if we see that everything is shaped, we might be able to remove the intermediary function. This can possibly result in more assumptions being made (similar to what was being attempted by the guard proposal). This shares a lot of features with guards.</p>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n<blockquote>\n<p>How would this affect new F() and the resulting new.target, prototypes, etc.</p>\n</blockquote>\n<p>One way to answer this might be: What happens when you have a match statement in the constructor of F? another way to answer it (though I am still absorbing it) is your comment here: https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1199706022 for the new Book example.</p>\n<blockquote>\n<p>If a function decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>An decorator would apply to its direct shaped function. So, for example:</p>\n<pre><code class=\"language-js\">class HttpRoutes {\n\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  get(req when { url: &quot;/products&quot; }) { ...}\n\n  @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  get(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  // internal engine functions\n  @route(&quot;GET&quot;, &quot;/products&quot;)\n  _internal_shapedget_1(req when { url: &quot;/products&quot; }) { ...}\n\n    @route(&quot;GET&quot;, &quot;/products/{id}&quot;)\n  _internal_shapedget_2(req when { url: /\\/products\\/\\d+/ }) { ... }\n\n  implementation_get(req) { \n    match(req) {\n       when { url: &quot;/products&quot; }: // ...\n       when { url: /\\/products\\/\\d+/ }: // ... \n       default : // throw no such function\n    }\n  }\n}\n\n</code></pre>\n<p>and, you can likely imagine what would happen if the default behavior had a decorator</p>\n<blockquote>\n<p>If a parameter decorator is applied to only one overload, what function does it get? If they're all the same function, how would we differentiate overloads in the decorator?</p>\n</blockquote>\n<p>Hopefully the above answers this question?</p>\n","mimetype":"text/html"}]},"ts":1659370500403,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$Eg3pkT7Vcb6Nsqui7gwGJz30SXXclwfZ4KagaQfqhds"},
{"content":{"body":"i joyfully have an inflamed tendon sheath and a popped ganglion cyst so its not bone, its tissue. Will take a long time to heal but i also can't stop myself from talking because i am so darn chatty. I had no idea i was this chatty until i couldn't type for 5 days at all","msgtype":"m.text","org.matrix.msc1767.text":"i joyfully have an inflamed tendon sheath and a popped ganglion cyst so its not bone, its tissue. Will take a long time to heal but i also can't stop myself from talking because i am so darn chatty. I had no idea i was this chatty until i couldn't type for 5 days at all"},"ts":1659370676535,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$EvzrfgK-YDB62T5a0yr8kQ4s4LkEV00zWrmhCd6dg7k"},
{"content":{"body":"calling is... preferred, but then we lose the history here and people can't engage async","msgtype":"m.text","org.matrix.msc1767.text":"calling is... preferred, but then we lose the history here and people can't engage async"},"ts":1659370810065,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$i4aIh1pRlCMuKbvvSmD90nsonfMy7iaT6ZXtX4v7jvg"},
{"content":{"body":"(this all said -- it doesn't have to happen before or as a part of pattern matching. I think it could be, and it could be really nice. I also think leaving the door open is important)","msgtype":"m.text","org.matrix.msc1767.text":"(this all said -- it doesn't have to happen before or as a part of pattern matching. I think it could be, and it could be really nice. I also think leaving the door open is important)"},"ts":1659371026927,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$zkvOseCJ2IY3C7MZSZ701iyD8riPE31r0sD_02XA7dk"},
{"content":{"body":" * (this all said -- it doesn't have to happen before or as a part of pattern matching. I think leaving the door open is important)","m.new_content":{"body":"(this all said -- it doesn't have to happen before or as a part of pattern matching. I think leaving the door open is important)","msgtype":"m.text","org.matrix.msc1767.text":"(this all said -- it doesn't have to happen before or as a part of pattern matching. I think leaving the door open is important)"},"m.relates_to":{"event_id":"$zkvOseCJ2IY3C7MZSZ701iyD8riPE31r0sD_02XA7dk","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * (this all said -- it doesn't have to happen before or as a part of pattern matching. I think leaving the door open is important)"},"ts":1659371045692,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$r06fW6d6LXrOOWyayh8WkrglsKQZ2IcGC81cmYNVkbw"},
{"content":{"body":" * (this all said -- it doesn't have to happen before or as a part of pattern matching. I think it could be, and it could be really nice. I also think leaving the door open is important)","m.new_content":{"body":"(this all said -- it doesn't have to happen before or as a part of pattern matching. I think it could be, and it could be really nice. I also think leaving the door open is important)","msgtype":"m.text","org.matrix.msc1767.text":"(this all said -- it doesn't have to happen before or as a part of pattern matching. I think it could be, and it could be really nice. I also think leaving the door open is important)"},"m.relates_to":{"event_id":"$zkvOseCJ2IY3C7MZSZ701iyD8riPE31r0sD_02XA7dk","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * (this all said -- it doesn't have to happen before or as a part of pattern matching. I think it could be, and it could be really nice. I also think leaving the door open is important)"},"ts":1659371068515,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$7GU9gNRfmu50LsINUJSrwtY3iWUmavKXajqnIBVdgko"},
{"content":{"body":">> How would this apply to Proxy?\n>\n> what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\nSpecifically, function identities passed via the call and construct traps. Its essentially similar to the question around F.p.bind, but reframed to an overlapping problem space.\n\nI'm also concerned about evaluation order and side effects. Consider something like this:\n\n```js\nlet counter = 0;\nfunction g() {\n  return counter++;\n}\n\nfunction f({ [g()]: a }, b when Number) { ... }\nfunction f({ [g()]: a }, b when String) { ... }\n\nf([\"foo\", \"bar\"], \"baz\");\n```\nWhat should we expect that `a` is in `f`? This is a contrived example, but showcases how side effects could introduce unintended or unexpected consequences in function evaluation. Whereas, with a non-overloaded function the caller doesn't have to be concerned about side effects in the call:\n\n```js\nfunction f({ [g()]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<blockquote>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n</blockquote>\n<p>Specifically, function identities passed via the call and construct traps. Its essentially similar to the question around F.p.bind, but reframed to an overlapping problem space.</p>\n<p>I'm also concerned about evaluation order and side effects. Consider something like this:</p>\n<pre><code class=\"language-js\">let counter = 0;\nfunction g() {\n  return counter++;\n}\n\nfunction f({ [g()]: a }, b when Number) { ... }\nfunction f({ [g()]: a }, b when String) { ... }\n\nf([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;);\n</code></pre>\n<p>What should we expect that <code>a</code> is in <code>f</code>? This is a contrived example, but showcases how side effects could introduce unintended or unexpected consequences in function evaluation. Whereas, with a non-overloaded function the caller doesn't have to be concerned about side effects in the call:</p>\n<pre><code class=\"language-js\">function f({ [g()]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":">> How would this apply to Proxy?\n>\n> what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.\n\nSpecifically, function identities passed via the call and construct traps. Its essentially similar to the question around F.p.bind, but reframed to an overlapping problem space.\n\nI'm also concerned about evaluation order and side effects. Consider something like this:\n\n```js\nlet counter = 0;\nfunction g() {\n  return counter++;\n}\n\nfunction f({ [g()]: a }, b when Number) { ... }\nfunction f({ [g()]: a }, b when String) { ... }\n\nf([\"foo\", \"bar\"], \"baz\");\n```\nWhat should we expect that `a` is in `f`? This is a contrived example, but showcases how side effects could introduce unintended or unexpected consequences in function evaluation. Whereas, with a non-overloaded function the caller doesn't have to be concerned about side effects in the call:\n\n```js\nfunction f({ [g()]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n```","mimetype":"text/plain"},{"body":"<blockquote>\n<blockquote>\n<p>How would this apply to Proxy?</p>\n</blockquote>\n<p>what precisely do you mean? can you give an example? Proxies is kind of a big region for me so I am not immediately grasping the issue you are pointing out.</p>\n</blockquote>\n<p>Specifically, function identities passed via the call and construct traps. Its essentially similar to the question around F.p.bind, but reframed to an overlapping problem space.</p>\n<p>I'm also concerned about evaluation order and side effects. Consider something like this:</p>\n<pre><code class=\"language-js\">let counter = 0;\nfunction g() {\n  return counter++;\n}\n\nfunction f({ [g()]: a }, b when Number) { ... }\nfunction f({ [g()]: a }, b when String) { ... }\n\nf([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;);\n</code></pre>\n<p>What should we expect that <code>a</code> is in <code>f</code>? This is a contrived example, but showcases how side effects could introduce unintended or unexpected consequences in function evaluation. Whereas, with a non-overloaded function the caller doesn't have to be concerned about side effects in the call:</p>\n<pre><code class=\"language-js\">function f({ [g()]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659371500799,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$isuw5UQyS5axM3dxi2_dksPR5nmRBouFcgZq17N8W0E"},
{"content":{"body":"hm, interesting. Wouldn't this also be an issue in the current pattern matching proposal? Especially if you have a global counter like this","msgtype":"m.text","org.matrix.msc1767.text":"hm, interesting. Wouldn't this also be an issue in the current pattern matching proposal? Especially if you have a global counter like this"},"ts":1659371607891,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$VonDs5QMCcPfNgFOiHH7Iq89blsWUxz7gMmEQqRKaiA"},
{"content":{"body":"There's also the potential for side effects in the destructuring itself.","msgtype":"m.text","org.matrix.msc1767.text":"There's also the potential for side effects in the destructuring itself."},"ts":1659371613611,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9nIUPJk-rWMKa6_iiHKoh4o0r78XkCOkUtFnswzXMkY"},
{"content":{"body":"```js\nfunction f({ [g()]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n```\n\nthis is currently not legal js syntax yes? I guess you mean\n```js\nfunction f({ [${g()}]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">function f({ [g()]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n<p>this is currently not legal js syntax yes? I guess you mean</p>\n<pre><code class=\"language-js\">function f({ [${g()}]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"```js\nfunction f({ [g()]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n```\n\nthis is currently not legal js syntax yes? I guess you mean\n```js\nfunction f({ [${g()}]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n```","mimetype":"text/plain"},{"body":"<pre><code class=\"language-js\">function f({ [g()]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n<p>this is currently not legal js syntax yes? I guess you mean</p>\n<pre><code class=\"language-js\">function f({ [${g()}]: a }, b) {\n  match (b) {\n    when (Number): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659371685676,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$JLtSx27esB2ITSzeQ4CmSGQ7vqxJcsxJRkL-cZ1MYpk"},
{"content":{"body":"Side-effecting code like this is bad anyways, but the example tries to make it more obvious. A less obvious and potentially more likely case would be passing an object as the first argument whose getter can observe the attempt to bind each overload during destructuring","msgtype":"m.text","org.matrix.msc1767.text":"Side-effecting code like this is bad anyways, but the example tries to make it more obvious. A less obvious and potentially more likely case would be passing an object as the first argument whose getter can observe the attempt to bind each overload during destructuring"},"ts":1659371708899,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$d70PQ6Nq553rEwozZ3Sf2UoGdZnlqwlHh7CVmWYMttA"},
{"content":{"body":"No, this is already legal syntax. Binding patterns can have computed property names.","msgtype":"m.text","org.matrix.msc1767.text":"No, this is already legal syntax. Binding patterns can have computed property names."},"ts":1659371764156,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$R9Vya5PTi6ZzwOGaEuWR-qBghtoiFvWct_Vwwv7Sgw4"},
{"content":{"body":"Oh, right -- sorry i missed the `:`","format":"org.matrix.custom.html","formatted_body":"Oh, right -- sorry i missed the <code>:</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Oh, right -- sorry i missed the `:`","mimetype":"text/plain"},{"body":"Oh, right -- sorry i missed the <code>:</code>","mimetype":"text/html"}]},"ts":1659371774388,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$RKcyuSQcI6t2wgnng5uQwtDiieB0FOCU8VcjdyHVtdk"},
{"content":{"body":"so that is an alias to a, am i reading that right?","msgtype":"m.text","org.matrix.msc1767.text":"so that is an alias to a, am i reading that right?"},"ts":1659371807733,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$L4TvBUF43hv5RUM0I2ZP1yNQgw78FeSIYxXISL6T43A"},
{"content":{"body":"That's binding the property to `a`, just like you might do `({ foo: bar }) => bar`","format":"org.matrix.custom.html","formatted_body":"That's binding the property to <code>a</code>, just like you might do <code>({ foo: bar }) =&gt; bar</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"That's binding the property to `a`, just like you might do `({ foo: bar }) => bar`","mimetype":"text/plain"},{"body":"That's binding the property to <code>a</code>, just like you might do <code>({ foo: bar }) =&gt; bar</code>","mimetype":"text/html"}]},"ts":1659371849612,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-8RGbDSTdzfmsJk9Q0UeMrnr4mHokmEc8QXhFGqX17E"},
{"content":{"body":"yep","msgtype":"m.text","org.matrix.msc1767.text":"yep"},"ts":1659371855178,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$x0HooR9n98A2j8JwC0ondUALYK_RAGl2jHe0e1Xm_dk"},
{"content":{"body":"i really dislike that syntax, it is so hard to read","msgtype":"m.text","org.matrix.msc1767.text":"i really dislike that syntax, it is so hard to read"},"ts":1659371862623,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$Ku9lW9r7m1npJdcVdbOe6-giEfQSvxM4hERc-bkOvMU"},
{"content":{"body":"but anyway","msgtype":"m.text","org.matrix.msc1767.text":"but anyway"},"ts":1659371866848,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$slmGTnLV7RMGzwhjpm5L3UVf14HLwHS8tR8UbmJdzDE"},
{"content":{"body":"it seems like an issue we already have to be honest","msgtype":"m.text","org.matrix.msc1767.text":"it seems like an issue we already have to be honest"},"ts":1659371897129,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$fDWmQbmmvlTga30L9jsweI2D3qFWCR4jhB98hCgQ0rE"},
{"content":{"body":"But we're introducing it in a new and unexpected place. Injecting something in between `f(x)` and the evaluation of the parameter list/function body.","format":"org.matrix.custom.html","formatted_body":"But we're introducing it in a new and unexpected place. Injecting something in between <code>f(x)</code> and the evaluation of the parameter list/function body.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"But we're introducing it in a new and unexpected place. Injecting something in between `f(x)` and the evaluation of the parameter list/function body.","mimetype":"text/plain"},{"body":"But we're introducing it in a new and unexpected place. Injecting something in between <code>f(x)</code> and the evaluation of the parameter list/function body.","mimetype":"text/html"}]},"ts":1659371975546,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eOidvbLSMFbbceoRNWns1weqBUjba38-P7rVamyLzHw"},
{"content":{"body":"so, `g` gets evaluated on every call","format":"org.matrix.custom.html","formatted_body":"so, <code>g</code> gets evaluated on every call","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"so, `g` gets evaluated on every call","mimetype":"text/plain"},{"body":"so, <code>g</code> gets evaluated on every call","mimetype":"text/html"}]},"ts":1659372105859,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$R1xHPkDaUfw-VgwcwqjXHqOdZfNAllXTdnS7wBUImxY"},
{"content":{"body":"I am not sure... what the difference would really be here","msgtype":"m.text","org.matrix.msc1767.text":"I am not sure... what the difference would really be here"},"ts":1659372114019,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$L2kuUkr61ReD487QRJrJsTrMErQHlYou8inn8em04uY"},
{"content":{"body":"yes, you would have the same counter for all matches, but that could be intentional","msgtype":"m.text","org.matrix.msc1767.text":"yes, you would have the same counter for all matches, but that could be intentional"},"ts":1659372143288,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$jpJK6fyAv3S79W2tmB8SJ039LeN3j3svqgycNpFl4_k"},
{"content":{"body":"Consider this less-contrived example instead:\n\n```js\nclass Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() => { ... });\nf(obj, 0);\n```\n\nThis would print `true` when the author might have expected it to print `false`.","format":"org.matrix.custom.html","formatted_body":"<p>Consider this less-contrived example instead:</p>\n<pre><code class=\"language-js\">class Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() =&gt; { ... });\nf(obj, 0);\n</code></pre>\n<p>This would print <code>true</code> when the author might have expected it to print <code>false</code>.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Consider this less-contrived example instead:\n\n```js\nclass Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() => { ... });\nf(obj, 0);\n```\n\nThis would print `true` when the author might have expected it to print `false`.","mimetype":"text/plain"},{"body":"<p>Consider this less-contrived example instead:</p>\n<pre><code class=\"language-js\">class Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() =&gt; { ... });\nf(obj, 0);\n</code></pre>\n<p>This would print <code>true</code> when the author might have expected it to print <code>false</code>.</p>\n","mimetype":"text/html"}]},"ts":1659372168819,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dzfmy0xuW78TrUznjZD-wOVMUgBjkZsmdZHGZFS1DFw"},
{"content":{"body":" * Consider this less-contrived example instead:\n\n```js\nclass Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() => { ... });\nf(obj, 0);\n```\n\nThis would print `true` when the author might have expected it to print `false`.","format":"org.matrix.custom.html","formatted_body":" * <p>Consider this less-contrived example instead:</p>\n<pre><code class=\"language-js\">class Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() =&gt; { ... });\nf(obj, 0);\n</code></pre>\n<p>This would print <code>true</code> when the author might have expected it to print <code>false</code>.</p>\n","m.new_content":{"body":"Consider this less-contrived example instead:\n\n```js\nclass Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() => { ... });\nf(obj, 0);\n```\n\nThis would print `true` when the author might have expected it to print `false`.","format":"org.matrix.custom.html","formatted_body":"<p>Consider this less-contrived example instead:</p>\n<pre><code class=\"language-js\">class Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() =&gt; { ... });\nf(obj, 0);\n</code></pre>\n<p>This would print <code>true</code> when the author might have expected it to print <code>false</code>.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Consider this less-contrived example instead:\n\n```js\nclass Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() => { ... });\nf(obj, 0);\n```\n\nThis would print `true` when the author might have expected it to print `false`.","mimetype":"text/plain"},{"body":"<p>Consider this less-contrived example instead:</p>\n<pre><code class=\"language-js\">class Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() =&gt; { ... });\nf(obj, 0);\n</code></pre>\n<p>This would print <code>true</code> when the author might have expected it to print <code>false</code>.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$dzfmy0xuW78TrUznjZD-wOVMUgBjkZsmdZHGZFS1DFw","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Consider this less-contrived example instead:\n\n```js\nclass Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() => { ... });\nf(obj, 0);\n```\n\nThis would print `true` when the author might have expected it to print `false`.","mimetype":"text/plain"},{"body":" * <p>Consider this less-contrived example instead:</p>\n<pre><code class=\"language-js\">class Lazy {\n  constructor(factoryfn) { ... }\n  get hasValue() { ... }\n  get value() { ... } // getting `value` invokes `factoryfn` and changes `hasValue` from `false` to `true`\n}\n\nfunction f({ hasValue, value }, b when String) { console.log(hasValue); }\nfunction f({ hasValue, value }, b when Number) { console.log(hasValue); }\n\nconst obj = new Lazy(() =&gt; { ... });\nf(obj, 0);\n</code></pre>\n<p>This would print <code>true</code> when the author might have expected it to print <code>false</code>.</p>\n","mimetype":"text/html"}]},"ts":1659372214949,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KCqMwZLNIpOBeyksd2k8zB9vqIYCayBsf2Lr2AsS1cI"},
{"content":{"body":"but, the same is true if you call f twice","msgtype":"m.text","org.matrix.msc1767.text":"but, the same is true if you call f twice"},"ts":1659372232097,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$LjqeAUa07Y_sMjtA9ME5lnm3POXloixH6ExRT-yI9NA"},
{"content":{"body":"and you are basically calling f twice","msgtype":"m.text","org.matrix.msc1767.text":"and you are basically calling f twice"},"ts":1659372236304,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$Gqu9BTppLBxpvULvqsEDg-Ohl8_teTtXSRGd-3DIh84"},
{"content":{"body":"oh i see","msgtype":"m.text","org.matrix.msc1767.text":"oh i see"},"ts":1659372247375,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$wlN9BMJlxwiS_9BrscgRmNTDmEq-c9YVRzx32CVsQfY"},
{"content":{"body":"With the same `obj`, sure, but that could be expected *without* the overload.","format":"org.matrix.custom.html","formatted_body":"With the same <code>obj</code>, sure, but that could be expected <em>without</em> the overload.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With the same `obj`, sure, but that could be expected *without* the overload.","mimetype":"text/plain"},{"body":"With the same <code>obj</code>, sure, but that could be expected <em>without</em> the overload.","mimetype":"text/html"}]},"ts":1659372259129,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PtNEFKcgpnrARIYD1hqNky7Rnp9ilXwvqt8g0izL-70"},
{"content":{"body":"with the overload, you never get the right answer for the 2nd+ overloads","msgtype":"m.text","org.matrix.msc1767.text":"with the overload, you never get the right answer for the 2nd+ overloads"},"ts":1659372278925,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$moka3OhrfSYJbtkxnIYRplnT7A3oMf_HgV5PoCtyKJ8"},
{"content":{"body":"My overarching concern is that there are a lot of corner cases with overloads that make me very reticent to pursue them as part of a pattern matching proposal.","msgtype":"m.text","org.matrix.msc1767.text":"My overarching concern is that there are a lot of corner cases with overloads that make me very reticent to pursue them as part of a pattern matching proposal."},"ts":1659372355953,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TsfiBbswhCKiVFFIGlo0jbsT55xj2pNB4Hdioq4UhRE"},
{"content":{"body":"wait, no","msgtype":"m.text","org.matrix.msc1767.text":"wait, no"},"ts":1659372427692,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$YaMgzdCB8U97kMEZmMuvoacMg3IJHomHJGNETM2HlTw"},
{"content":{"body":"thats not right","msgtype":"m.text","org.matrix.msc1767.text":"thats not right"},"ts":1659372430245,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$EoCxawVKMac16Kmbtkbv52EKnHvZ92teYpTjQnXTpCI"},
{"content":{"body":"ok, i just tested -- hasValue is not triggered on definition","msgtype":"m.text","org.matrix.msc1767.text":"ok, i just tested -- hasValue is not triggered on definition"},"ts":1659372585300,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$iiKZ4sQI8tmFfhvwvog8tnBUyP0lnGLnQCwcF29w4b4"},
{"content":{"body":"its called only on execution","msgtype":"m.text","org.matrix.msc1767.text":"its called only on execution"},"ts":1659372589699,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$K9etQkalxVCS6CirnQp-V9sCpGqMtWZCzhwPYddWksw"},
{"content":{"body":"so you would need to call f at least once, even in the overload case","msgtype":"m.text","org.matrix.msc1767.text":"so you would need to call f at least once, even in the overload case"},"ts":1659372606384,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$zDjm6kRxG1HcDUDj--iBr2pBbZLzSxO1DgRkwHkBYUk"},
{"content":{"body":"so you would get the right answer","msgtype":"m.text","org.matrix.msc1767.text":"so you would get the right answer"},"ts":1659372611281,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$VLKbDeq8DdM_97yqhIZZeAWCsXtrOje7Ul8N6bOMe6k"},
{"content":{"body":"it is the same case as having two different functions with that same definition. \n\n```js\nfunction f({ hasValue, value }, b) { console.log(hasValue); }\nfunction h({ hasValue, value }, b) { console.log(hasValue); }\n```","format":"org.matrix.custom.html","formatted_body":"<p>it is the same case as having two different functions with that same definition.</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) { console.log(hasValue); }\nfunction h({ hasValue, value }, b) { console.log(hasValue); }\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"it is the same case as having two different functions with that same definition. \n\n```js\nfunction f({ hasValue, value }, b) { console.log(hasValue); }\nfunction h({ hasValue, value }, b) { console.log(hasValue); }\n```","mimetype":"text/plain"},{"body":"<p>it is the same case as having two different functions with that same definition.</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) { console.log(hasValue); }\nfunction h({ hasValue, value }, b) { console.log(hasValue); }\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659372653070,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$V4GOylSh1nSQil7ggaRZuxLL5K0ihTQZNbATOz7osRk"},
{"content":{"body":"Except that calling an overloaded `f` *is* like calling it twice, but bailing early in the first call.","format":"org.matrix.custom.html","formatted_body":"Except that calling an overloaded <code>f</code> <em>is</em> like calling it twice, but bailing early in the first call.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Except that calling an overloaded `f` *is* like calling it twice, but bailing early in the first call.","mimetype":"text/plain"},{"body":"Except that calling an overloaded <code>f</code> <em>is</em> like calling it twice, but bailing early in the first call.","mimetype":"text/html"}]},"ts":1659372799598,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$n7OA8iU164iRQt2-PfL-p84SIUYfquIF4ssL9vvAI5I"},
{"content":{"body":"but we do the test first and then the assignment?","msgtype":"m.text","org.matrix.msc1767.text":"but we do the test first and then the assignment?"},"ts":1659372826634,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$8i9jxZ1n0WxCEJ23VoujAzR9sptAzOTuY27mRyW67QM"},
{"content":{"body":"you could have side effects in the test though","msgtype":"m.text","org.matrix.msc1767.text":"you could have side effects in the test though"},"ts":1659372848620,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$cSMEO7Tn5vD5-n_NJwIr7k5DwNE0l0SwiXxD_Y6gQNQ"},
{"content":{"body":"Not if we want interpolation to work.","msgtype":"m.text","org.matrix.msc1767.text":"Not if we want interpolation to work."},"ts":1659372851140,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KsPkual7TvWwp-1WKbjhrdOm-assC04IbdDDY1xDfYw"},
{"content":{"body":"er","msgtype":"m.text","org.matrix.msc1767.text":"er"},"ts":1659372876323,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$KU93sXneSYgn5p47MSr9qpGUcDu9LcPqw29X0eE6fKs"},
{"content":{"body":"i don't know what you mean there exactly","msgtype":"m.text","org.matrix.msc1767.text":"i don't know what you mean there exactly"},"ts":1659372880303,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$R8u9wZ6Y6dyO9KJrnocTqfW7teMea5vZJjMWlCxyurs"},
{"content":{"body":"```js\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n```\n\netc.","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">function f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n</code></pre>\n<p>etc.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"```js\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n```\n\netc.","mimetype":"text/plain"},{"body":"<pre><code class=\"language-js\">function f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n</code></pre>\n<p>etc.</p>\n","mimetype":"text/html"}]},"ts":1659372888518,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$M7RPgBx3H9CPz6LRJEd-sN_YSNuHubXItci-yvM3Kz0"},
{"content":{"body":"you mean, function calls for the test","msgtype":"m.text","org.matrix.msc1767.text":"you mean, function calls for the test"},"ts":1659372888789,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$QuuW3Xf-axZFtmKnbSb6_Ohc1Mm7w2a0-2LKX2qmBCM"},
{"content":{"body":" * ```js\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n```\n\netc.","format":"org.matrix.custom.html","formatted_body":" * <pre><code class=\"language-js\">function f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n</code></pre>\n<p>etc.</p>\n","m.new_content":{"body":"```js\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n```\n\netc.","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">function f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n</code></pre>\n<p>etc.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"```js\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n```\n\netc.","mimetype":"text/plain"},{"body":"<pre><code class=\"language-js\">function f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n</code></pre>\n<p>etc.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$M7RPgBx3H9CPz6LRJEd-sN_YSNuHubXItci-yvM3Kz0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * ```js\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n```\n\netc.","mimetype":"text/plain"},{"body":" * <pre><code class=\"language-js\">function f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\nfunction f({ hasValue, value }, b when String) { ... }\n</code></pre>\n<p>etc.</p>\n","mimetype":"text/html"}]},"ts":1659372898643,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lhe9UIqSsMVWm1dgCFQ5awOzg9w_705xxtTfrbZqEKw"},
{"content":{"body":"If you call an overloaded `f`, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","format":"org.matrix.custom.html","formatted_body":"If you call an overloaded <code>f</code>, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"If you call an overloaded `f`, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","mimetype":"text/plain"},{"body":"If you call an overloaded <code>f</code>, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","mimetype":"text/html"}]},"ts":1659372948052,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MGEvRRvg0aw0SghfBGSzc_WE_zrbj1tmdHJub6XPd8E"},
{"content":{"body":" * If you call an overloaded `f`, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","format":"org.matrix.custom.html","formatted_body":" * If you call an overloaded <code>f</code>, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","m.new_content":{"body":"If you call an overloaded `f`, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","format":"org.matrix.custom.html","formatted_body":"If you call an overloaded <code>f</code>, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"If you call an overloaded `f`, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","mimetype":"text/plain"},{"body":"If you call an overloaded <code>f</code>, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$MGEvRRvg0aw0SghfBGSzc_WE_zrbj1tmdHJub6XPd8E","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * If you call an overloaded `f`, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","mimetype":"text/plain"},{"body":" * If you call an overloaded <code>f</code>, you have to process each parameter in each overload (until you find a match) to properly bind it and choose the correct function body to execute.","mimetype":"text/html"}]},"ts":1659372970400,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Vyv8mJG05174bs5skk1NRiP29m9aYZKBfZBkLvqf-r8"},
{"content":{"body":"but why is this different then writing it as a match statement?","msgtype":"m.text","org.matrix.msc1767.text":"but why is this different then writing it as a match statement?"},"ts":1659373005897,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$GcbUwqYpWUpBgScuOq8DSr1ya9FBucYklQraqPHMMeM"},
{"content":{"body":"Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and >= ${value}): ...;\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and &gt;= ${value}): ...;\n  }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and >= ${value}): ...;\n  }\n}\n```","mimetype":"text/plain"},{"body":"<p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and &gt;= ${value}): ...;\n  }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659373052468,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5ftTDFcyy6ThMZNm7WrB-fMKaYCphkEiS5N8ZO6yks4"},
{"content":{"body":" * Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (Number and >= ${value}): ...;\n    when (String): ...;\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (Number and &gt;= ${value}): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n","m.new_content":{"body":"Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (Number and >= ${value}): ...;\n    when (String): ...;\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (Number and &gt;= ${value}): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (Number and >= ${value}): ...;\n    when (String): ...;\n  }\n}\n```","mimetype":"text/plain"},{"body":"<p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (Number and &gt;= ${value}): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$5ftTDFcyy6ThMZNm7WrB-fMKaYCphkEiS5N8ZO6yks4","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (Number and >= ${value}): ...;\n    when (String): ...;\n  }\n}\n```","mimetype":"text/plain"},{"body":" * <p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (Number and &gt;= ${value}): ...;\n    when (String): ...;\n  }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659373078813,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$o30DSB5bixLKe-P1TgJ24C3MJKFVKTmbrpfaqblpfk0"},
{"content":{"body":"Overloads would hide this potential side effect","msgtype":"m.text","org.matrix.msc1767.text":"Overloads would hide this potential side effect"},"ts":1659373094139,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gLmIcTSmXaIk_x6CZZT85Z-7KNXujat607N-5exo8yQ"},
{"content":{"body":"this will still have the same side effect","msgtype":"m.text","org.matrix.msc1767.text":"this will still have the same side effect"},"ts":1659373118047,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$yD0ScjxBwM374z00Ub2-Uqpf9WALmH8kqkw3QL9KYZ0"},
{"content":{"body":"that will be hidden","msgtype":"m.text","org.matrix.msc1767.text":"that will be hidden"},"ts":1659373120066,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$QszJ_HrPLGHCZrC1deX1xJFB25zpLBGOdKyVSOuAPAo"},
{"content":{"body":"the problem is falling through to String","msgtype":"m.text","org.matrix.msc1767.text":"the problem is falling through to String"},"ts":1659373146138,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$_oU63QjmjPs45VbbNrP7FqYlgLTH5-66IwuLQooeliU"},
{"content":{"body":"with value set","msgtype":"m.text","org.matrix.msc1767.text":"with value set"},"ts":1659373152447,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$YdXVu3Wqpoic7DdO5DBJdwrRsj_ijZtfzmNitwnn2aA"},
{"content":{"body":"and that will happen here","msgtype":"m.text","org.matrix.msc1767.text":"and that will happen here"},"ts":1659373154804,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$Lc9Nh5B8xXDyHSuvquh-edO2e_cEbUFpoDq4U91S5kg"},
{"content":{"body":" * Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and >= ${value}): ...;\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and &gt;= ${value}): ...;\n  }\n}\n</code></pre>\n","m.new_content":{"body":"Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and >= ${value}): ...;\n  }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and &gt;= ${value}): ...;\n  }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and >= ${value}): ...;\n  }\n}\n```","mimetype":"text/plain"},{"body":"<p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and &gt;= ${value}): ...;\n  }\n}\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$5ftTDFcyy6ThMZNm7WrB-fMKaYCphkEiS5N8ZO6yks4","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Because if I write it as a match statement, I can handle the first argument on its own:\n\n```js\nfunction f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and >= ${value}): ...;\n  }\n}\n```","mimetype":"text/plain"},{"body":" * <p>Because if I write it as a match statement, I can handle the first argument on its own:</p>\n<pre><code class=\"language-js\">function f({ hasValue, value }, b) {\n  match (b) {\n    when (String): ...;\n    when (Number and &gt;= ${value}): ...;\n  }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659373169071,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XmPbT6qGul1wKJz8XCaBDHEwPDY4dDg-0kZu-0UHxmI"},
{"content":{"body":"ok, but when you edit it like that, the same can be done for function ordering","msgtype":"m.text","org.matrix.msc1767.text":"ok, but when you edit it like that, the same can be done for function ordering"},"ts":1659373181669,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$IEtbhsUVqJpV0ITSC3c4RzZulRsRI7j2oDeMyz1v6Vs"},
{"content":{"body":"Except that calling `f(obj, 0)` would have the intended result and wouldn't evaluate `obj.value` twice.","format":"org.matrix.custom.html","formatted_body":"Except that calling <code>f(obj, 0)</code> would have the intended result and wouldn't evaluate <code>obj.value</code> twice.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Except that calling `f(obj, 0)` would have the intended result and wouldn't evaluate `obj.value` twice.","mimetype":"text/plain"},{"body":"Except that calling <code>f(obj, 0)</code> would have the intended result and wouldn't evaluate <code>obj.value</code> twice.","mimetype":"text/html"}]},"ts":1659373185372,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KNMD0DtmgpzbpVsuUcU0ixi1e7RqqLdB3rE2om_T01M"},
{"content":{"body":"ok, but you have to consistently edit both cases","msgtype":"m.text","org.matrix.msc1767.text":"ok, but you have to consistently edit both cases"},"ts":1659373203668,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$SLubagkbXk1-OIVHnhDa7fXcbONE4q2J_2IljLlmSeU"},
{"content":{"body":"Sorry, trying to align the order with the original order I mentioned further up.","msgtype":"m.text","org.matrix.msc1767.text":"Sorry, trying to align the order with the original order I mentioned further up."},"ts":1659373205667,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vdeOfSuAvdMshU4SHce0d-xU0BtMTlqy-wJ9bgnvkSg"},
{"content":{"body":" * ```js\nfunction f({ hasValue, value }, b when String) { ... }\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\n```\n\netc.","format":"org.matrix.custom.html","formatted_body":" * <pre><code class=\"language-js\">function f({ hasValue, value }, b when String) { ... }\nfunction f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\n</code></pre>\n<p>etc.</p>\n","m.new_content":{"body":"```js\nfunction f({ hasValue, value }, b when String) { ... }\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\n```\n\netc.","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">function f({ hasValue, value }, b when String) { ... }\nfunction f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\n</code></pre>\n<p>etc.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"```js\nfunction f({ hasValue, value }, b when String) { ... }\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\n```\n\netc.","mimetype":"text/plain"},{"body":"<pre><code class=\"language-js\">function f({ hasValue, value }, b when String) { ... }\nfunction f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\n</code></pre>\n<p>etc.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$M7RPgBx3H9CPz6LRJEd-sN_YSNuHubXItci-yvM3Kz0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * ```js\nfunction f({ hasValue, value }, b when String) { ... }\nfunction f({ hasValue, value }, b when Number and >= ${value}) { ... }\n```\n\netc.","mimetype":"text/plain"},{"body":" * <pre><code class=\"language-js\">function f({ hasValue, value }, b when String) { ... }\nfunction f({ hasValue, value }, b when Number and &gt;= ${value}) { ... }\n</code></pre>\n<p>etc.</p>\n","mimetype":"text/html"}]},"ts":1659373215830,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$b930fJH51DtDeqUJmN00fo4veCIA_EIulJhXWR7Pc3g"},
{"content":{"body":"the behavior between those two, in the case that `b` is a string, will be the same","format":"org.matrix.custom.html","formatted_body":"the behavior between those two, in the case that <code>b</code> is a string, will be the same","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"the behavior between those two, in the case that `b` is a string, will be the same","mimetype":"text/plain"},{"body":"the behavior between those two, in the case that <code>b</code> is a string, will be the same","mimetype":"text/html"}]},"ts":1659373229175,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$S_xDEqwr8vcRyj4LRlIKiZ5iqA3A1AMtVpcyJaJhAaA"},
{"content":{"body":"> <@yulia:mozilla.org> ok, but you have to consistently edit both cases\n\ndone","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$SLubagkbXk1-OIVHnhDa7fXcbONE4q2J_2IljLlmSeU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@yulia:mozilla.org\">@yulia:mozilla.org</a><br>ok, but you have to consistently edit both cases</blockquote></mx-reply>done","m.relates_to":{"m.in_reply_to":{"event_id":"$SLubagkbXk1-OIVHnhDa7fXcbONE4q2J_2IljLlmSeU"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@yulia:mozilla.org> ok, but you have to consistently edit both cases\n\ndone","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$SLubagkbXk1-OIVHnhDa7fXcbONE4q2J_2IljLlmSeU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@yulia:mozilla.org\">@yulia:mozilla.org</a><br>ok, but you have to consistently edit both cases</blockquote></mx-reply>done","mimetype":"text/html"}]},"ts":1659373229901,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0vCCH1bWt7SeK38cHJJ567VcJFPcx53yWc5MnTCt6bI"},
{"content":{"body":"Yes, but my point is that calling when `b` is a Number would be inconsistent.","format":"org.matrix.custom.html","formatted_body":"Yes, but my point is that calling when <code>b</code> is a Number would be inconsistent.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Yes, but my point is that calling when `b` is a Number would be inconsistent.","mimetype":"text/plain"},{"body":"Yes, but my point is that calling when <code>b</code> is a Number would be inconsistent.","mimetype":"text/html"}]},"ts":1659373250528,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$D6YRwYSXLB65_LkyZhsiJgE_G1ubgAAecuf0xz43Ctg"},
{"content":{"body":"yes, and my argument here is its the same for the match statement ;)","msgtype":"m.text","org.matrix.msc1767.text":"yes, and my argument here is its the same for the match statement ;)"},"ts":1659373269542,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$IUKk316HTFFTCKNFqUgkAGWfbpxR11e9TzFEtY2pV0E"},
{"content":{"body":"it isn't part of the nature of it being in the function definition","msgtype":"m.text","org.matrix.msc1767.text":"it isn't part of the nature of it being in the function definition"},"ts":1659373281773,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$CXyvIa10LZE5CjR1ur1rWwphnYXm19o7KkvLQpDAWF0"},
{"content":{"body":"It is if we make it part of the function definition via overloads. Developer's aren't used to overloads in JS, so it just becomes a new hazard to trip over.","msgtype":"m.text","org.matrix.msc1767.text":"It is if we make it part of the function definition via overloads. Developer's aren't used to overloads in JS, so it just becomes a new hazard to trip over."},"ts":1659373326372,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$h5Iv46vD78uYDiH1B3XsXCECDOcDDN4IOiZWvfN9jV8"},
{"content":{"body":"this is generally true of matches with side effects.","msgtype":"m.text","org.matrix.msc1767.text":"this is generally true of matches with side effects."},"ts":1659373326847,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$A6dyj1uZ7FAjwQrPic_y44jFgYmH31BdxfDugyMQj3E"},
{"content":{"body":"In a `match` its at least a statement context, so its expected. ","format":"org.matrix.custom.html","formatted_body":"In a <code>match</code> its at least a statement context, so its expected.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"In a `match` its at least a statement context, so its expected. ","mimetype":"text/plain"},{"body":"In a <code>match</code> its at least a statement context, so its expected.","mimetype":"text/html"}]},"ts":1659373362345,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9jjnH4y1O8XiKn0AAH_MBdahgLMOaVvVrQ8hUdCBS_I"},
{"content":{"body":"Sure, this is a small concern, but I have a *lot* of small concerns with overloads ","format":"org.matrix.custom.html","formatted_body":"Sure, this is a small concern, but I have a <em>lot</em> of small concerns with overloads","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Sure, this is a small concern, but I have a *lot* of small concerns with overloads ","mimetype":"text/plain"},{"body":"Sure, this is a small concern, but I have a <em>lot</em> of small concerns with overloads","mimetype":"text/html"}]},"ts":1659373427350,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eUYM_I02EeL-ZIVuopASHfvUmVKbM38qnI3RTBZ1A2Y"},
{"content":{"body":"it will also be true of anything that has valueOf set -- including in current functions. this relies on implicit behavior that is already present and we cannot get rid of","msgtype":"m.text","org.matrix.msc1767.text":"it will also be true of anything that has valueOf set -- including in current functions. this relies on implicit behavior that is already present and we cannot get rid of"},"ts":1659373452229,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$O6gQ8IT37QPFctaanASIHPvE9xxUwHWlF5BtPZruyEw"},
{"content":{"body":"otherwise, this should have been an argument against destructuring in function definitions","msgtype":"m.text","org.matrix.msc1767.text":"otherwise, this should have been an argument against destructuring in function definitions"},"ts":1659373463350,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$g1QBVuWoMJSypRUAz5iLLk0B0RNDCX05AjeHj42Unv4"},
{"content":{"body":"Except that \"destructuring in function definitions\" is \"the JavaScript way of having named arguments\", according to many in plenary.","msgtype":"m.text","org.matrix.msc1767.text":"Except that \"destructuring in function definitions\" is \"the JavaScript way of having named arguments\", according to many in plenary."},"ts":1659373494694,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mbWhpN97YSjEeoka6Gl1FPsGhDo19BmPIvra6iSz1vo"},
{"content":{"body":"its certainly one way. the example you gave explictly relies on hiding an implicit function execution","msgtype":"m.text","org.matrix.msc1767.text":"its certainly one way. the example you gave explictly relies on hiding an implicit function execution"},"ts":1659373536157,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$uY71KDz5rqFxtJlw_M6nv4L5XuzuSHlzpq5yFzmL-XA"},
{"content":{"body":"there are many ways to do weird behavior with that","msgtype":"m.text","org.matrix.msc1767.text":"there are many ways to do weird behavior with that"},"ts":1659373548789,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$-E9Y-TLDp8c2kl4KarzuFCjcwISoHmqM6Et33wAiA_0"},
{"content":{"body":" * its certainly one way. the example you gave explictly relies on hiding an implicit function execution","m.new_content":{"body":"its certainly one way. the example you gave explictly relies on hiding an implicit function execution","msgtype":"m.text","org.matrix.msc1767.text":"its certainly one way. the example you gave explictly relies on hiding an implicit function execution"},"m.relates_to":{"event_id":"$uY71KDz5rqFxtJlw_M6nv4L5XuzuSHlzpq5yFzmL-XA","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * its certainly one way. the example you gave explictly relies on hiding an implicit function execution"},"ts":1659373560303,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$CNRCr_XM_8lEcFcOGz5cCYLY_hBWokprnIp6hLCXV2A"},
{"content":{"body":"(like implementing scheme in js)","msgtype":"m.text","org.matrix.msc1767.text":"(like implementing scheme in js)"},"ts":1659373583723,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$heQ_cGoXy2MiPpzPbfMeLqfMErB_a9v1jxuy1JVoH9E"},
{"content":{"body":"(with the js parser)","msgtype":"m.text","org.matrix.msc1767.text":"(with the js parser)"},"ts":1659373592098,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$q3jXdf8TopDXfGm15AAW2na0xTEcGEW1OJss8r-fhX0"},
{"content":{"body":"I'd just rather not add yet another weird behavior, especially one that could be a significant stumbling block for advancing pattern matching.","msgtype":"m.text","org.matrix.msc1767.text":"I'd just rather not add yet another weird behavior, especially one that could be a significant stumbling block for advancing pattern matching."},"ts":1659373597507,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WZe3DRgwQmwFRXt8SwbULH1_LN3HogyjyGqXIOK0A7s"},
{"content":{"body":"i would say that this isn't \"another weird behavior\". it is \"existing weird behavior\"","msgtype":"m.text","org.matrix.msc1767.text":"i would say that this isn't \"another weird behavior\". it is \"existing weird behavior\""},"ts":1659373616137,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$zVF7L8GdSEJem14vUJUnMSA8L-0bReBhtz1whtBIlNc"},
{"content":{"body":"I am not proposing to introduce valueOf","msgtype":"m.text","org.matrix.msc1767.text":"I am not proposing to introduce valueOf"},"ts":1659373625207,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$qqsbuSEUSVlToAlckvX0VTGpA7w2A8YcBCLJ1Z8PFGw"},
{"content":{"body":"It extends an existing weird behavior to a new location, namely the space between `f(x)` and evaluation of the function body","format":"org.matrix.custom.html","formatted_body":"It extends an existing weird behavior to a new location, namely the space between <code>f(x)</code> and evaluation of the function body","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"It extends an existing weird behavior to a new location, namely the space between `f(x)` and evaluation of the function body","mimetype":"text/plain"},{"body":"It extends an existing weird behavior to a new location, namely the space between <code>f(x)</code> and evaluation of the function body","mimetype":"text/html"}]},"ts":1659373662698,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$sti3ZQLm3zfgOnxqM-YNDUbIVE7OB1w_vPqUdmL3yuI"},
{"content":{"body":"no. it does not. that already exists, as we discussed","msgtype":"m.text","org.matrix.msc1767.text":"no. it does not. that already exists, as we discussed"},"ts":1659373686453,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$DiH-ZcYA-7hDRqaI3IgORrVSHX1eOHciCFVmyImlaZ0"},
{"content":{"body":"Today, that weird behavior can happen at most once when calling `f(x)`, now it can potentially happen `n-1` number of times based on `n` overloads","format":"org.matrix.custom.html","formatted_body":"Today, that weird behavior can happen at most once when calling <code>f(x)</code>, now it can potentially happen <code>n-1</code> number of times based on <code>n</code> overloads","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Today, that weird behavior can happen at most once when calling `f(x)`, now it can potentially happen `n-1` number of times based on `n` overloads","mimetype":"text/plain"},{"body":"Today, that weird behavior can happen at most once when calling <code>f(x)</code>, now it can potentially happen <code>n-1</code> number of times based on <code>n</code> overloads","mimetype":"text/html"}]},"ts":1659373709265,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$u4pe0PEpEaH3kidSi_zRcUGwk4VBb3nRYslzlaTAvMc"},
{"content":{"body":"ok, so we agree that the weird behavior exists","msgtype":"m.text","org.matrix.msc1767.text":"ok, so we agree that the weird behavior exists"},"ts":1659373745495,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$PU1BEuGunkuMeEI1NfyDvDzDI3eYOsE2B_3IhbFymA8"},
{"content":{"body":"we agree that this has the exact same behavior as the `match` statement","format":"org.matrix.custom.html","formatted_body":"we agree that this has the exact same behavior as the <code>match</code> statement","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"we agree that this has the exact same behavior as the `match` statement","mimetype":"text/plain"},{"body":"we agree that this has the exact same behavior as the <code>match</code> statement","mimetype":"text/html"}]},"ts":1659373774140,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$u5DQKcXoimuBycu9-4d4kb-7o6LHFGWteXe2aCgNPmY"},
{"content":{"body":"Yes and no, parameter lists have some other weird behaviors tied in as well (such as scoping) that don't precisely apply to `match`.","format":"org.matrix.custom.html","formatted_body":"Yes and no, parameter lists have some other weird behaviors tied in as well (such as scoping) that don't precisely apply to <code>match</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Yes and no, parameter lists have some other weird behaviors tied in as well (such as scoping) that don't precisely apply to `match`.","mimetype":"text/plain"},{"body":"Yes and no, parameter lists have some other weird behaviors tied in as well (such as scoping) that don't precisely apply to <code>match</code>.","mimetype":"text/html"}]},"ts":1659373845626,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Wq168i4PP60hjsLJVsxfkD5X1sjiUVXQmMaCDipgwUY"},
{"content":{"body":"I can construct a case, where the evaluation will happen a number of times between function evaluation and function body","msgtype":"m.text","org.matrix.msc1767.text":"I can construct a case, where the evaluation will happen a number of times between function evaluation and function body"},"ts":1659373860678,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$WTt8axSdiWk_U9WgZHaCrHXbxi8dQ-uHdlIF3PAClGg"},
{"content":{"body":"via `{ [value]: { [value]: {[value]: ....}}}`","format":"org.matrix.custom.html","formatted_body":"via <code>{ [value]: { [value]: {[value]: ....}}}</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"via `{ [value]: { [value]: {[value]: ....}}}`","mimetype":"text/plain"},{"body":"via <code>{ [value]: { [value]: {[value]: ....}}}</code>","mimetype":"text/html"}]},"ts":1659373903850,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$oFJg66mmiXn51xg1xHp15gFpNl3HyXLJ_CIBYE1Eplw"},
{"content":{"body":"in a single function","msgtype":"m.text","org.matrix.msc1767.text":"in a single function"},"ts":1659373917311,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$6LynccnvLdN14HMMEE642LVVwEYmH1GW4kk2Eb47Cdo"},
{"content":{"body":"And there *is* a difference between:\n```js\nfunction f({ x }, b when C1) { ... }\nfunction f({ x }, b when C2) { ... }\n```\nand\n```js\nfunction f({ x }, b) {\n  match (b) {\n    when C1: ...;\n    when C2: ...;\n  }\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>And there <em>is</em> a difference between:</p>\n<pre><code class=\"language-js\">function f({ x }, b when C1) { ... }\nfunction f({ x }, b when C2) { ... }\n</code></pre>\n<p>and</p>\n<pre><code class=\"language-js\">function f({ x }, b) {\n  match (b) {\n    when C1: ...;\n    when C2: ...;\n  }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"And there *is* a difference between:\n```js\nfunction f({ x }, b when C1) { ... }\nfunction f({ x }, b when C2) { ... }\n```\nand\n```js\nfunction f({ x }, b) {\n  match (b) {\n    when C1: ...;\n    when C2: ...;\n  }\n}\n```\n","mimetype":"text/plain"},{"body":"<p>And there <em>is</em> a difference between:</p>\n<pre><code class=\"language-js\">function f({ x }, b when C1) { ... }\nfunction f({ x }, b when C2) { ... }\n</code></pre>\n<p>and</p>\n<pre><code class=\"language-js\">function f({ x }, b) {\n  match (b) {\n    when C1: ...;\n    when C2: ...;\n  }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659373946028,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$alEFQA-jLEpj70xYZ1tQ_8B-0eolNiPp9VqcuEWqv2s"},
{"content":{"body":"sure, and for that you wouldn't use the overloading","msgtype":"m.text","org.matrix.msc1767.text":"sure, and for that you wouldn't use the overloading"},"ts":1659373969524,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$bfKhSPkQrEzh6WGST2A8le9_FRAwRGa0YINcUrXtFCo"},
{"content":{"body":"hm, but i am curious to hear what you have to say, sorry for interrupting","msgtype":"m.text","org.matrix.msc1767.text":"hm, but i am curious to hear what you have to say, sorry for interrupting"},"ts":1659374012880,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$6P6UTfcmlTw7q-hyNHea7xg3qXnTphNKJNJ-EZBuzMI"},
{"content":{"body":"It may not be obvious at first glance to a developer when you *shouldn't* use overloads, as it requires more knowledge about what the expected inputs are and how they're used than a linter or even a type checker can generally provide.","format":"org.matrix.custom.html","formatted_body":"It may not be obvious at first glance to a developer when you <em>shouldn't</em> use overloads, as it requires more knowledge about what the expected inputs are and how they're used than a linter or even a type checker can generally provide.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"It may not be obvious at first glance to a developer when you *shouldn't* use overloads, as it requires more knowledge about what the expected inputs are and how they're used than a linter or even a type checker can generally provide.","mimetype":"text/plain"},{"body":"It may not be obvious at first glance to a developer when you <em>shouldn't</em> use overloads, as it requires more knowledge about what the expected inputs are and how they're used than a linter or even a type checker can generally provide.","mimetype":"text/html"}]},"ts":1659374086814,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-LFt1K80HdRmL3jeVd48YrxauOjyI58-S5qdalBB30s"}
]