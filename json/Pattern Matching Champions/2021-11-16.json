[
{"content":{"body":"I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:\n```js\nSymbol.destructure // symbol\n\nenum Option of ADT {\n  Some(value),\n  None\n}\n \nconst x = Option.Some(1);\nconst Option.Some(y) = x;\ny; // 1\n \nmatch (x) {\n  when Option.Some(y) { ... }\n  when None { ... }\n}\n```\nWhere an `Option.Some` instance has a `@@destructure` method:\n```js\n// return the actual value to destructure\nOption.Some.prototype[Symbol.destructure] = function () { return [this.value]; }\n```\nAnd _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)","format":"org.matrix.custom.html","formatted_body":"<p>I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a <code>Deconstruct</code>-named method. It got me to thinking whether we might be able to propose something similar:</p>\n<pre><code class=\"language-js\">Symbol.destructure // symbol\n\nenum Option of ADT {\n  Some(value),\n  None\n}\n \nconst x = Option.Some(1);\nconst Option.Some(y) = x;\ny; // 1\n \nmatch (x) {\n  when Option.Some(y) { ... }\n  when None { ... }\n}\n</code></pre>\n<p>Where an <code>Option.Some</code> instance has a <code>@@destructure</code> method:</p>\n<pre><code class=\"language-js\">// return the actual value to destructure\nOption.Some.prototype[Symbol.destructure] = function () { return [this.value]; }\n</code></pre>\n<p>And <em>BindingPattern</em> could evolve to allow <code>QualifiedName(BindingElementList)</code> and <code>QualifiedName{BindingPropertyList}</code> (where <em>QualifiedName</em> is something like <code>a.b.c</code>, etc.)</p>\n","msgtype":"m.text"},"ts":1637096515865,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_ZLC9F8YBCeiZJIal4ibecWsyYh5vTagMcyWHASw95g"},
{"content":{"body":"`match (x) { .. }` would recognize the `QualifiedName(BindingElementList)`/`QualifiedName{BindingPropertyList}` syntax and do the following: \n1. Throw if _QualifiedName_ does not have a `@@destructure` method.\n2. Match if `x` is an instance of _QualifiedName_ and the result of the destructure method matches the rest of the pattern specified by _BindingElementList_/_BindingPropertyList_.","format":"org.matrix.custom.html","formatted_body":"<p><code>match (x) { .. }</code> would recognize the <code>QualifiedName(BindingElementList)</code>/<code>QualifiedName{BindingPropertyList}</code> syntax and do the following:</p>\n<ol>\n<li>Throw if <em>QualifiedName</em> does not have a <code>@@destructure</code> method.</li>\n<li>Match if <code>x</code> is an instance of <em>QualifiedName</em> and the result of the destructure method matches the rest of the pattern specified by <em>BindingElementList</em>/<em>BindingPropertyList</em>.</li>\n</ol>\n","msgtype":"m.text"},"ts":1637096701800,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kG8nmT96U0dggSTi1y1x39I62deqAbPHQLCa3krFEWk"},
{"content":{"body":"`let`/`const`/`var` would do the same except it would throw if (2) isn't a match.","format":"org.matrix.custom.html","formatted_body":"<code>let</code>/<code>const</code>/<code>var</code> would do the same except it would throw if (2) isn't a match.","msgtype":"m.text"},"ts":1637096752528,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9oTJheidFypUUPZrr7SLXhwogeMQYdsUIHe9DZZKS1Y"},
{"content":{"body":"That would make for a nice parallel syntax for ADT-style enums for construction and deconstruction (i.e., `x = Option.Some(y)` -> `Option.Some(y) = x`)","format":"org.matrix.custom.html","formatted_body":"That would make for a nice parallel syntax for ADT-style enums for construction and deconstruction (i.e., <code>x = Option.Some(y)</code> -&gt; <code>Option.Some(y) = x</code>)","msgtype":"m.text"},"ts":1637096867703,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SiMH4oOlhOIJK7c19bGxlK3q_3Z_XEg81nyNnkgf73w"},
{"content":{"body":" * I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:\n```js\nSymbol.destructure // symbol\n\nenum Option of ADT {\n  Some(value),\n  None\n}\n \nconst x = Option.Some(1);\nconst Option.Some(y) = x;\ny; // 1\n \nmatch (x) {\n  when Option.Some(y) { ... }\n  when Option.None { ... }\n}\n```\n\nWhere an `Option.Some` instance has a `@@destructure` method:\n```js\n// return the actual value to destructure\nOption.Some.prototype[Symbol.destructure] = function () { return [this.value]; }\n```\n\nAnd _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)","format":"org.matrix.custom.html","formatted_body":" * <p>I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a <code>Deconstruct</code>-named method. It got me to thinking whether we might be able to propose something similar:</p>\n<pre><code class=\"language-js\">Symbol.destructure // symbol\n\nenum Option of ADT {\n  Some(value),\n  None\n}\n \nconst x = Option.Some(1);\nconst Option.Some(y) = x;\ny; // 1\n \nmatch (x) {\n  when Option.Some(y) { ... }\n  when Option.None { ... }\n}\n</code></pre>\n<p>Where an <code>Option.Some</code> instance has a <code>@@destructure</code> method:</p>\n<pre><code class=\"language-js\">// return the actual value to destructure\nOption.Some.prototype[Symbol.destructure] = function () { return [this.value]; }\n</code></pre>\n<p>And <em>BindingPattern</em> could evolve to allow <code>QualifiedName(BindingElementList)</code> and <code>QualifiedName{BindingPropertyList}</code> (where <em>QualifiedName</em> is something like <code>a.b.c</code>, etc.)</p>\n","m.new_content":{"body":"I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:\n```js\nSymbol.destructure // symbol\n\nenum Option of ADT {\n  Some(value),\n  None\n}\n \nconst x = Option.Some(1);\nconst Option.Some(y) = x;\ny; // 1\n \nmatch (x) {\n  when Option.Some(y) { ... }\n  when Option.None { ... }\n}\n```\n\nWhere an `Option.Some` instance has a `@@destructure` method:\n```js\n// return the actual value to destructure\nOption.Some.prototype[Symbol.destructure] = function () { return [this.value]; }\n```\n\nAnd _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)","format":"org.matrix.custom.html","formatted_body":"<p>I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a <code>Deconstruct</code>-named method. It got me to thinking whether we might be able to propose something similar:</p>\n<pre><code class=\"language-js\">Symbol.destructure // symbol\n\nenum Option of ADT {\n  Some(value),\n  None\n}\n \nconst x = Option.Some(1);\nconst Option.Some(y) = x;\ny; // 1\n \nmatch (x) {\n  when Option.Some(y) { ... }\n  when Option.None { ... }\n}\n</code></pre>\n<p>Where an <code>Option.Some</code> instance has a <code>@@destructure</code> method:</p>\n<pre><code class=\"language-js\">// return the actual value to destructure\nOption.Some.prototype[Symbol.destructure] = function () { return [this.value]; }\n</code></pre>\n<p>And <em>BindingPattern</em> could evolve to allow <code>QualifiedName(BindingElementList)</code> and <code>QualifiedName{BindingPropertyList}</code> (where <em>QualifiedName</em> is something like <code>a.b.c</code>, etc.)</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$_ZLC9F8YBCeiZJIal4ibecWsyYh5vTagMcyWHASw95g","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1637096886738,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$h7bHqHmW17E9X6M0jDzN6SIzsWiDrVOfo3VNGXHsMy0"}
]