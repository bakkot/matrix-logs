[
{"content":{"body":"> <@rbuckton:matrix.org> I've amended the proposal to align more with scala extractor objects (i.e., no built-in instanceof check, renamed `@@destructure` to `@@unapply` and moved it off the instance and onto the _QualifiedName_, dropped `QualifiedName{x,y}` and only have `QualifiedName(x)`). There's plenty of places I could see this being useful as it allows you to apply custom logic during destructuring:\n> ```js\n> const MapExtractor = {\n>   [Symbol.unapply](value) { \n>     const obj = {};\n>     for (const [key, value] of map) {\n>       obj[typeof key === \"symbol\" ? key : `${key}`] = value;\n>     }\n>     return [obj];\n>   }\n> }\n> \n> const obj = {\n>   map: new Map().set(\"a\", 1).set(\"b\", 2)\n> };\n> \n> const { map: MapExtractor({ a, b }) } = obj;\n> ```\n> \n> The ability to evaluate custom logic in the middle of a destructuring is something I've often wanted.\n\nIf you dropped the {} form, how it works with ADT objects? Match on the 1st argument? That creates a syntax irsymmetry","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$CJ1R5Jd277SlGJTik4kccNQMtiBLMdEEr9QMXxg9CZc?via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br /><p>I've amended the proposal to align more with scala extractor objects (i.e., no built-in instanceof check, renamed <code>@@destructure</code> to <code>@@unapply</code> and moved it off the instance and onto the <em>QualifiedName</em>, dropped <code>QualifiedName{x,y}</code> and only have <code>QualifiedName(x)</code>). There's plenty of places I could see this being useful as it allows you to apply custom logic during destructuring:</p>\n<pre><code class=\"language-js\">const MapExtractor = {\n  [Symbol.unapply](value) { \n    const obj = {};\n    for (const [key, value] of map) {\n      obj[typeof key === &quot;symbol&quot; ? key : `${key}`] = value;\n    }\n    return [obj];\n  }\n}\n\nconst obj = {\n  map: new Map().set(&quot;a&quot;, 1).set(&quot;b&quot;, 2)\n};\n\nconst { map: MapExtractor({ a, b }) } = obj;\n</code></pre>\n<p>The ability to evaluate custom logic in the middle of a destructuring is something I've often wanted.</p>\n</blockquote></mx-reply>If you dropped the {} form, how it works with ADT objects? Match on the 1st argument? That creates a syntax irsymmetry","m.relates_to":{"m.in_reply_to":{"event_id":"$CJ1R5Jd277SlGJTik4kccNQMtiBLMdEEr9QMXxg9CZc"}},"msgtype":"m.text"},"ts":1637199623443,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$f57mQgeAdZDFr8moXQMAg4nuUqcO9PRp-Arb5SztDqQ"},
{"content":{"body":"> <@rbuckton:matrix.org> Also, `@@unapply` isn't too different from `@@matcher`. An `@@unapply` method could just return null/undefined in place of a `matched` property, and instead of `^Expr as { x, y }` you would use `Expr({ x, y})`\n\nSo why not merging them? ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$h19Zsczra1KfkWVv1kqJgvBE3Q-BIUaUW6eNkAgktHE?via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />Also, <code>@@unapply</code> isn't too different from <code>@@matcher</code>. An <code>@@unapply</code> method could just return null/undefined in place of a <code>matched</code> property, and instead of <code>^Expr as { x, y }</code> you would use <code>Expr({ x, y})</code></blockquote></mx-reply>So why not merging them? ","m.relates_to":{"m.in_reply_to":{"event_id":"$h19Zsczra1KfkWVv1kqJgvBE3Q-BIUaUW6eNkAgktHE"}},"msgtype":"m.text"},"ts":1637199764125,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$OAZzedrxGZbFsgxXv1H9dlhQzuaB8Cs_yNSONKCwm5U"},
{"content":{"body":"There's no syntax asymmetry for usage/extraction:\n\n```js\nenum Message of ADT {\n   Move{x, y},\n}\n\nconst msg = Message.Move({ x: 1, y: 1 });\nconst Message.Move({ x, y }) = msg;\n```","format":"org.matrix.custom.html","formatted_body":"<p>There's no syntax asymmetry for usage/extraction:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n   Move{x, y},\n}\n\nconst msg = Message.Move({ x: 1, y: 1 });\nconst Message.Move({ x, y }) = msg;\n</code></pre>\n","msgtype":"m.text"},"ts":1637199768070,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cjz9yHTjprYtYoBXGFjCBgv2IW908LhZDoMAUvFrXPM"},
{"content":{"body":"It might even make sense to drop `PropertyName{x, y}` from ADT enums in favor of `PropertyName({x, y})` for declaration symmetry","format":"org.matrix.custom.html","formatted_body":"It might even make sense to drop <code>PropertyName{x, y}</code> from ADT enums in favor of <code>PropertyName({x, y})</code> for declaration symmetry","msgtype":"m.text"},"ts":1637199843541,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ehhEpMBKVMBSe_uOAqouw1VLkktKZsB6rZ7tDbA-PPM"},
{"content":{"body":"```js\nenum Message of ADT {\n  Write(message),\n  Move({ x, y })\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">enum Message of ADT {\n  Write(message),\n  Move({ x, y })\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1637199872293,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wJ8FbI0R3NOcijRieXVFEPz9_hHk8leAKWezazDVBeU"},
{"content":{"body":"> <@rbuckton:matrix.org> There's no syntax asymmetry for usage/extraction:\n> \n> ```js\n> enum Message of ADT {\n>    Move{x, y},\n> }\n> \n> const msg = Message.Move({ x: 1, y: 1 });\n> const Message.Move({ x, y }) = msg;\n> ```\n\nHmm this is interesting. I was thinking of the definition body in the Enum and deconstruction syntax is asymmerty","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$cjz9yHTjprYtYoBXGFjCBgv2IW908LhZDoMAUvFrXPM?via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br /><p>There's no syntax asymmetry for usage/extraction:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n   Move{x, y},\n}\n\nconst msg = Message.Move({ x: 1, y: 1 });\nconst Message.Move({ x, y }) = msg;\n</code></pre>\n</blockquote></mx-reply>Hmm this is interesting. I was thinking of the definition body in the Enum and deconstruction syntax is asymmerty","m.relates_to":{"m.in_reply_to":{"event_id":"$cjz9yHTjprYtYoBXGFjCBgv2IW908LhZDoMAUvFrXPM"}},"msgtype":"m.text"},"ts":1637199873450,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$PgdOciH7zxYH-SqmNUkycbPUPw5EfbDAHK5CcSSyJXc"},
{"content":{"body":"In your proposal, ADT enum value construction uses `Foo.Bar({ x, y })` as well","format":"org.matrix.custom.html","formatted_body":"In your proposal, ADT enum value construction uses <code>Foo.Bar({ x, y })</code> as well","msgtype":"m.text"},"ts":1637199914383,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ITg4voTZrNMlFZVAS4PJl_Rr54Oz9HOKTzNKSNziMX0"},
{"content":{"body":"> <@rbuckton:matrix.org> It might even make sense to drop `PropertyName{x, y}` from ADT enums in favor of `PropertyName({x, y})` for declaration symmetry\n\nBut if that's the case, will you allow Prop({ a: { b }})?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$ehhEpMBKVMBSe_uOAqouw1VLkktKZsB6rZ7tDbA-PPM?via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />It might even make sense to drop <code>PropertyName{x, y}</code> from ADT enums in favor of <code>PropertyName({x, y})</code> for declaration symmetry</blockquote></mx-reply>But if that's the case, will you allow Prop({ a: { b }})?","m.relates_to":{"m.in_reply_to":{"event_id":"$ehhEpMBKVMBSe_uOAqouw1VLkktKZsB6rZ7tDbA-PPM"}},"msgtype":"m.text"},"ts":1637199939877,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$e4M-_9CXugW6ydPF1Y4qaJ2RkMqGUgiIj6L1a9l1Sp8"},
{"content":{"body":"That might be a bridge too far, to be honest. ","msgtype":"m.text"},"ts":1637200029865,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3H8YigHm3DViDA1u6-z4co-ra26yW1BMuG-Jd44lCS4"},
{"content":{"body":"I don't think that would be allowed either but developers might think it can","msgtype":"m.text"},"ts":1637206810585,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$0h6-7YMFG7qV3Zhw5ywF8sSV1KpmmHvqpn2wB6P2sEg"},
{"content":{"body":"It wouldn't be allowed for the declaration, but would be allowed for construction and deconstruction. I don't think its so bad to disallow it at declaration, since enums would be a new feature and thus require learning the syntax to be able to use it.","msgtype":"m.text"},"ts":1637257695983,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$c-Lpj6OBIF4c4A9Tq_GPkmByCqAkFeL_JwLmnlXNm9Y"},
{"content":{"body":"… what is an \"ADT enum\" and why is this concept important for enums and/or pattern matching?","msgtype":"m.text"},"ts":1637265002917,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$YaqfHyPzP39OJGo0FDuG7aKs3sh4SYG9lbMcNa_8yTs"},
{"content":{"body":"to me an enum is just a closed set of explicitly named values (any distinct values) that conceptually enumerates some domain","msgtype":"m.text"},"ts":1637265168873,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$o9yOHLSVNGD5i5BruEg9gbg3qljTfy9aJ1l1cQP4YF4"},
{"content":{"body":"> <@ljharb:matrix.org> … what is an \"ADT enum\" and why is this concept important for enums and/or pattern matching?\n\nADT = https://en.wikipedia.org/wiki/Generalized_algebraic_data_type in this case, I believe. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD%3Amatrix.org/%24YaqfHyPzP39OJGo0FDuG7aKs3sh4SYG9lbMcNa_8yTs\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>… what is an \"ADT enum\" and why is this concept important for enums and/or pattern matching?</blockquote></mx-reply>ADT = https://en.wikipedia.org/wiki/Generalized_algebraic_data_type in this case, I believe.","m.relates_to":{"m.in_reply_to":{"event_id":"$YaqfHyPzP39OJGo0FDuG7aKs3sh4SYG9lbMcNa_8yTs"}},"msgtype":"m.text"},"ts":1637269374432,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$-g-ZeV_neIcppJjw2oOpn-oUFrxdwmbLQuKNKj5BLWc"},
{"content":{"body":"See also https://github.com/rbuckton/proposal-enum/issues/6","msgtype":"m.text"},"ts":1637269378716,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$LsTSEj-JpXQjUltLmTbC4r--BySeb752RYgz2QbazPQ"},
{"content":{"body":"They’re essentially structs with predefined categories. Or enums with additional payloads. Haskell, Rust, and Swift have them. They can use pattern matching on them. ","format":"org.matrix.custom.html","formatted_body":"They’re essentially structs with predefined categories. Or enums with additional payloads. Haskell, Rust, and Swift have them. They can use pattern matching on them.","msgtype":"m.text"},"ts":1637269431153,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$UOxRKebq74mGRq7_ZZPeNB1AkcPqlxQWSwFA6SXZ9hs"},
{"content":{"body":"* They’re essentially structs with predefined categories. Or enums with payload. Haskell, Rust, and Swift have them. They can use pattern matching on them. ","format":"org.matrix.custom.html","formatted_body":"* They’re essentially structs with predefined categories. Or enums with payload. Haskell, Rust, and Swift have them. They can use pattern matching on them.","m.new_content":{"body":"They’re essentially structs with predefined categories. Or enums with payload. Haskell, Rust, and Swift have them. They can use pattern matching on them. ","format":"org.matrix.custom.html","formatted_body":"They’re essentially structs with predefined categories. Or enums with payload. Haskell, Rust, and Swift have them. They can use pattern matching on them.","msgtype":"m.text"},"m.relates_to":{"event_id":"$UOxRKebq74mGRq7_ZZPeNB1AkcPqlxQWSwFA6SXZ9hs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1637269447486,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$4SOEVaBwJv_AwSZkjZ83f9-R5Iheom5poBVzynLxWes"},
{"content":{"body":"* They’re essentially structs with predefined categories. Or enums with additional payloads. Haskell, Rust, and Swift have them. They can use pattern matching on them. ","format":"org.matrix.custom.html","formatted_body":"* They’re essentially structs with predefined categories. Or enums with additional payloads. Haskell, Rust, and Swift have them. They can use pattern matching on them.","m.new_content":{"body":"They’re essentially structs with predefined categories. Or enums with additional payloads. Haskell, Rust, and Swift have them. They can use pattern matching on them. ","format":"org.matrix.custom.html","formatted_body":"They’re essentially structs with predefined categories. Or enums with additional payloads. Haskell, Rust, and Swift have them. They can use pattern matching on them.","msgtype":"m.text"},"m.relates_to":{"event_id":"$UOxRKebq74mGRq7_ZZPeNB1AkcPqlxQWSwFA6SXZ9hs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1637269490384,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$QaihxczxxeTJZmGa49ghXcWuWihVXDARM_tIXbKMMG8"},
{"content":{"body":"Like a Result type being made of the union of a Failure() singleton and a Success(value) type, after which Result values could be pattern matched between Failure() and Success(value) values, with value automatically being extracted in the Success branch. That’s probably what they’re talking about.  ","format":"org.matrix.custom.html","formatted_body":"Like a Result type being made of the union of a Failure() singleton and a Success(value) type, after which Result values could be pattern matched between Failure() and Success(value) values, with value automatically being extracted in the Success branch. That’s probably what they’re talking about.","msgtype":"m.text"},"ts":1637269715135,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$HJL_yRS7M05IEDkbHsh58YzlxtJRL_7HfOvjnELOEDk"},
{"content":{"body":"ok, but you can already do that with pattern matching wiht objects","msgtype":"m.text"},"ts":1637270050575,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$1k_VdO8Of1tVNuyr1WFIwHoUJwMy1cvAYIZbmxmHErU"},
{"content":{"body":"so sure, that should work, but that just means enums would need a very obvious and intuitive matcher protocol, right?","msgtype":"m.text"},"ts":1637270070837,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$b44oaZkVHF_hxTxDhxFeiS0BQ5QXJv4S1p54XaTYLPc"},
{"content":{"body":"Yes, as far as I can tell, but perhaps I’m missing something. ","format":"org.matrix.custom.html","formatted_body":"Yes, as far as I can tell, but perhaps I’m missing something.","msgtype":"m.text"},"ts":1637270132845,"senderName":"jschoi","senderId":"@jschoi:matrix.org","id":"$ouDvjrtYV1Y5vp_cZNnhF5lphWdsrXjbtcjUdUrEJMQ"},
{"content":{"body":"> <@ljharb:matrix.org> so sure, that should work, but that just means enums would need a very obvious and intuitive matcher protocol, right?\n\nADT enums would, yes. That's what `@@unapply` or (`@@matcher`) would give you.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$b44oaZkVHF_hxTxDhxFeiS0BQ5QXJv4S1p54XaTYLPc?via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>so sure, that should work, but that just means enums would need a very obvious and intuitive matcher protocol, right?</blockquote></mx-reply>ADT enums would, yes. That's what <code>@@unapply</code> or (<code>@@matcher</code>) would give you.","m.relates_to":{"m.in_reply_to":{"event_id":"$b44oaZkVHF_hxTxDhxFeiS0BQ5QXJv4S1p54XaTYLPc"}},"msgtype":"m.text"},"ts":1637277913751,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$GlIacub78TuQrAgjSEvPu0Kd7YtP1LxN-EbDZQzwsEg"},
{"content":{"body":"From what I've seen, languages that have ADT enums make heavy use of them alongside pattern matching as almost the majority use case.","msgtype":"m.text"},"ts":1637278076475,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mdY-_7A2OBJD2rjjdhYTsgp72nL1zgrfxRUeSmxyypA"},
{"content":{"body":"oh hm - we'd have to special-case enums in pattern matching tho somehow, because you'd want `when (enum.FOO)` to match, but the matcher protocol couldn't exist on, say, `1`","format":"org.matrix.custom.html","formatted_body":"oh hm - we'd have to special-case enums in pattern matching tho somehow, because you'd want <code>when (enum.FOO)</code> to match, but the matcher protocol couldn't exist on, say, <code>1</code>","msgtype":"m.text"},"ts":1637279676231,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$enVIbYNAwGKJO1HNjRJtiiZhQ1nR0KVNZ0metzsTYeU"},
{"content":{"body":"or actually `enum.FOO` would just be the runtime value, so there's not even a matcher protocol needed?","format":"org.matrix.custom.html","formatted_body":"or actually <code>enum.FOO</code> would just be the runtime value, so there's not even a matcher protocol needed?","msgtype":"m.text"},"ts":1637279703215,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$WanG_rktuyuniV2hgZR7I6xDhtaj67DQoc3-F4oI1ks"}
]