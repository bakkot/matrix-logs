[
{"content":{"body":"Just because it sounds like there's some hesitation - the meeting's still at noon today, right?","msgtype":"m.text","org.matrix.msc1767.text":"Just because it sounds like there's some hesitation - the meeting's still at noon today, right?"},"ts":1661274525618,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$OGE7Ez3qdNlwF6u8tL_jOEn_HDycu0HRAQcOIcTyi8s"},
{"content":{"body":"Sorry, 12pm pacific","msgtype":"m.text","org.matrix.msc1767.text":"Sorry, 12pm pacific"},"ts":1661274532865,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$G9dGnYoeDYNsEoiUJhPFYFBeTy3mLmyO2iMFXxT6EmM"},
{"content":{"body":"Yes, no change","msgtype":"m.text"},"ts":1661276151661,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$CQPn3bA1Y6W4MI1b4EyFSBeNGvM84RiT2ilzS0s5bt8"},
{"content":{"body":"yeah","msgtype":"m.text","org.matrix.msc1767.text":"yeah"},"ts":1661276440315,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Eaw_uFafgmn5AYXBNRiwqNa_XonUFPs_6JpAZbu1bPs"},
{"content":{"body":"meeting's starting","msgtype":"m.text","org.matrix.msc1767.text":"meeting's starting"},"ts":1661281257826,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$3ysmaRwfNw3pqvuecUn6itq80jblMkb8cYEpUnetNbY"},
{"content":{"body":"The version of pattern matching I'd love to see in the language essentially looks like this:\n- `match` expressions with multiple branches: `match (expr) { when Pattern: ...; default: ...; }`\n- `is` expressions with no branching, returning true/false: `expr is Pattern`\n- a flexible pattern syntax:\n  - Inline constant patterns (`true`, `false`, `0`, `\"foo\"`, `null`, etc.)\n  - Identifier reference patterns (`x`, `NaN`, `Infinity`, `undefined`, etc.)\n  - Prefix unary patterns (`+0`, `+Infinity`, etc.)\n  - Object patterns (`{ x: Pattern, y: Pattern }`, etc.)\n  - Array/Iterator patterns (`[Pattern, Pattern]`, `[Pattern, ...]`, etc.)\n  - Parenthesized patterns (`(Pattern)`)\n  - Conjunctive patterns (`Pattern and Pattern`)\n  - Disjunctive patterns (`Pattern or Pattern`)\n  - Negation patterns (`not Pattern`)\n  - Relational patterns (`> 0`, `<= \"Z\"`, etc.)\n  - Lexical declaration patterns (`let x`, `const x`)\n  - Custom matchers\n  - Extractor patterns (`Option.Some(Pattern)`, `Message.Move{ x: Pattern, y: Pattern }`)\n\nThis provides a fair amount of flexibility:\n\n```\n// simple pattern testing using `is`\nconst { body } = request is Ok ? request : {};\n\n// using `is` with control flow statements:\nif (obj is Map) ...;\nif (obj is { x: Number }) ...;\n\nwhile (requests.pop() is not (null or undefined) and let request) ...;\n\n// using `match` for branching:\nconst result = match (value) {\n  when Option.Some(let value): Option.Some(value + 1);\n  when Option.None: Option.Some(0);\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>The version of pattern matching I'd love to see in the language essentially looks like this:</p>\n<ul>\n<li><code>match</code> expressions with multiple branches: <code>match (expr) { when Pattern: ...; default: ...; }</code></li>\n<li><code>is</code> expressions with no branching, returning true/false: <code>expr is Pattern</code></li>\n<li>a flexible pattern syntax:\n<ul>\n<li>Inline constant patterns (<code>true</code>, <code>false</code>, <code>0</code>, <code>&quot;foo&quot;</code>, <code>null</code>, etc.)</li>\n<li>Identifier reference patterns (<code>x</code>, <code>NaN</code>, <code>Infinity</code>, <code>undefined</code>, etc.)</li>\n<li>Prefix unary patterns (<code>+0</code>, <code>+Infinity</code>, etc.)</li>\n<li>Object patterns (<code>{ x: Pattern, y: Pattern }</code>, etc.)</li>\n<li>Array/Iterator patterns (<code>[Pattern, Pattern]</code>, <code>[Pattern, ...]</code>, etc.)</li>\n<li>Parenthesized patterns (<code>(Pattern)</code>)</li>\n<li>Conjunctive patterns (<code>Pattern and Pattern</code>)</li>\n<li>Disjunctive patterns (<code>Pattern or Pattern</code>)</li>\n<li>Negation patterns (<code>not Pattern</code>)</li>\n<li>Relational patterns (<code>&gt; 0</code>, <code>&lt;= &quot;Z&quot;</code>, etc.)</li>\n<li>Lexical declaration patterns (<code>let x</code>, <code>const x</code>)</li>\n<li>Custom matchers</li>\n<li>Extractor patterns (<code>Option.Some(Pattern)</code>, <code>Message.Move{ x: Pattern, y: Pattern }</code>)</li>\n</ul>\n</li>\n</ul>\n<p>This provides a fair amount of flexibility:</p>\n<pre><code>// simple pattern testing using `is`\nconst { body } = request is Ok ? request : {};\n\n// using `is` with control flow statements:\nif (obj is Map) ...;\nif (obj is { x: Number }) ...;\n\nwhile (requests.pop() is not (null or undefined) and let request) ...;\n\n// using `match` for branching:\nconst result = match (value) {\n  when Option.Some(let value): Option.Some(value + 1);\n  when Option.None: Option.Some(0);\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The version of pattern matching I'd love to see in the language essentially looks like this:\n- `match` expressions with multiple branches: `match (expr) { when Pattern: ...; default: ...; }`\n- `is` expressions with no branching, returning true/false: `expr is Pattern`\n- a flexible pattern syntax:\n  - Inline constant patterns (`true`, `false`, `0`, `\"foo\"`, `null`, etc.)\n  - Identifier reference patterns (`x`, `NaN`, `Infinity`, `undefined`, etc.)\n  - Prefix unary patterns (`+0`, `+Infinity`, etc.)\n  - Object patterns (`{ x: Pattern, y: Pattern }`, etc.)\n  - Array/Iterator patterns (`[Pattern, Pattern]`, `[Pattern, ...]`, etc.)\n  - Parenthesized patterns (`(Pattern)`)\n  - Conjunctive patterns (`Pattern and Pattern`)\n  - Disjunctive patterns (`Pattern or Pattern`)\n  - Negation patterns (`not Pattern`)\n  - Relational patterns (`> 0`, `<= \"Z\"`, etc.)\n  - Lexical declaration patterns (`let x`, `const x`)\n  - Custom matchers\n  - Extractor patterns (`Option.Some(Pattern)`, `Message.Move{ x: Pattern, y: Pattern }`)\n\nThis provides a fair amount of flexibility:\n\n```\n// simple pattern testing using `is`\nconst { body } = request is Ok ? request : {};\n\n// using `is` with control flow statements:\nif (obj is Map) ...;\nif (obj is { x: Number }) ...;\n\nwhile (requests.pop() is not (null or undefined) and let request) ...;\n\n// using `match` for branching:\nconst result = match (value) {\n  when Option.Some(let value): Option.Some(value + 1);\n  when Option.None: Option.Some(0);\n}\n```","mimetype":"text/plain"},{"body":"<p>The version of pattern matching I'd love to see in the language essentially looks like this:</p>\n<ul>\n<li><code>match</code> expressions with multiple branches: <code>match (expr) { when Pattern: ...; default: ...; }</code></li>\n<li><code>is</code> expressions with no branching, returning true/false: <code>expr is Pattern</code></li>\n<li>a flexible pattern syntax:\n<ul>\n<li>Inline constant patterns (<code>true</code>, <code>false</code>, <code>0</code>, <code>&quot;foo&quot;</code>, <code>null</code>, etc.)</li>\n<li>Identifier reference patterns (<code>x</code>, <code>NaN</code>, <code>Infinity</code>, <code>undefined</code>, etc.)</li>\n<li>Prefix unary patterns (<code>+0</code>, <code>+Infinity</code>, etc.)</li>\n<li>Object patterns (<code>{ x: Pattern, y: Pattern }</code>, etc.)</li>\n<li>Array/Iterator patterns (<code>[Pattern, Pattern]</code>, <code>[Pattern, ...]</code>, etc.)</li>\n<li>Parenthesized patterns (<code>(Pattern)</code>)</li>\n<li>Conjunctive patterns (<code>Pattern and Pattern</code>)</li>\n<li>Disjunctive patterns (<code>Pattern or Pattern</code>)</li>\n<li>Negation patterns (<code>not Pattern</code>)</li>\n<li>Relational patterns (<code>&gt; 0</code>, <code>&lt;= &quot;Z&quot;</code>, etc.)</li>\n<li>Lexical declaration patterns (<code>let x</code>, <code>const x</code>)</li>\n<li>Custom matchers</li>\n<li>Extractor patterns (<code>Option.Some(Pattern)</code>, <code>Message.Move{ x: Pattern, y: Pattern }</code>)</li>\n</ul>\n</li>\n</ul>\n<p>This provides a fair amount of flexibility:</p>\n<pre><code>// simple pattern testing using `is`\nconst { body } = request is Ok ? request : {};\n\n// using `is` with control flow statements:\nif (obj is Map) ...;\nif (obj is { x: Number }) ...;\n\nwhile (requests.pop() is not (null or undefined) and let request) ...;\n\n// using `match` for branching:\nconst result = match (value) {\n  when Option.Some(let value): Option.Some(value + 1);\n  when Option.None: Option.Some(0);\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1661288498222,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$y71ipuf3nJzmiuFbQ3-ASoO0hN5WaDZ0BrImkEwLfjw"},
{"content":{"body":"With inline `let/const`, bindings are explicit and free identifiers can just be looked up in scope:\n```\n// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n```","format":"org.matrix.custom.html","formatted_body":"<p>With inline <code>let/const</code>, bindings are explicit and free identifiers can just be looked up in scope:</p>\n<pre><code>// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With inline `let/const`, bindings are explicit and free identifiers can just be looked up in scope:\n```\n// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n```","mimetype":"text/plain"},{"body":"<p>With inline <code>let/const</code>, bindings are explicit and free identifiers can just be looked up in scope:</p>\n<pre><code>// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n</code></pre>\n","mimetype":"text/html"}]},"ts":1661288691713,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$f80QRGP6qaR9zbUhspMDVJACC4cOye7UNXr4NRr-EMk"},
{"content":{"body":" * With inline `let/const`, bindings are explicit and free identifiers can just be looked up in scope:\n\n```\n// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map and { size: 0 } // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n```","format":"org.matrix.custom.html","formatted_body":" * <p>With inline <code>let/const</code>, bindings are explicit and free identifiers can just be looked up in scope:</p>\n<pre><code>// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map and { size: 0 } // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n</code></pre>\n","m.new_content":{"body":"With inline `let/const`, bindings are explicit and free identifiers can just be looked up in scope:\n\n```\n// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map and { size: 0 } // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n```","format":"org.matrix.custom.html","formatted_body":"<p>With inline <code>let/const</code>, bindings are explicit and free identifiers can just be looked up in scope:</p>\n<pre><code>// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map and { size: 0 } // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With inline `let/const`, bindings are explicit and free identifiers can just be looked up in scope:\n\n```\n// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map and { size: 0 } // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n```","mimetype":"text/plain"},{"body":"<p>With inline <code>let/const</code>, bindings are explicit and free identifiers can just be looked up in scope:</p>\n<pre><code>// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map and { size: 0 } // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$f80QRGP6qaR9zbUhspMDVJACC4cOye7UNXr4NRr-EMk","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * With inline `let/const`, bindings are explicit and free identifiers can just be looked up in scope:\n\n```\n// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map and { size: 0 } // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n```","mimetype":"text/plain"},{"body":" * <p>With inline <code>let/const</code>, bindings are explicit and free identifiers can just be looked up in scope:</p>\n<pre><code>// identifiers are lookups\nobj is +Infinity // look up `Infinity` in scope, just as with the rest of JS\nobj is null or undefined // look up `undefined` in scope, just as with the rest of JS\nobj is Map and { size: 0 } // look up `Map`\nobj is { x: Number, y: Number } // look up `Number`\n\n// declarations are explicit\nif (obj is { x: Number and let x, y: Number and let y }) console.log(x, y);\n</code></pre>\n","mimetype":"text/html"}]},"ts":1661288927577,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1MC9_vyL-ILjXISxgo5Mag7weza2Pt7-Vkdh_FMqzgA"}
]