[
{"content":{"body":"I believe it's rare to have a full \"escape back to normal expression syntax\" switch. It seems that most just allow for idents and possibly identifier descent (dotted/etc), referring to bindings visible from the outside.","msgtype":"m.text","org.matrix.msc1767.text":"I believe it's rare to have a full \"escape back to normal expression syntax\" switch. It seems that most just allow for idents and possibly identifier descent (dotted/etc), referring to bindings visible from the outside."},"ts":1662571193652,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$6Asa6lxqCZrDmLCABOnAN9AYeLpObrbT0nVuYASc3VA"},
{"content":{"body":"Tho note that interpolation *mostly* exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on *since* we have a well-defined boundary (and it's what the syntax does in template strings).","format":"org.matrix.custom.html","formatted_body":"Tho note that interpolation <em>mostly</em> exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on <em>since</em> we have a well-defined boundary (and it's what the syntax does in template strings).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Tho note that interpolation *mostly* exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on *since* we have a well-defined boundary (and it's what the syntax does in template strings).","mimetype":"text/plain"},{"body":"Tho note that interpolation <em>mostly</em> exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on <em>since</em> we have a well-defined boundary (and it's what the syntax does in template strings).","mimetype":"text/html"}]},"ts":1662571273254,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$zPRq7dBA1jkPYzjzOivIgu5Jz24SpHYDpSrBDYiDQfQ"},
{"content":{"body":"I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:\n\n```\nwhen (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n```\nThere's no ambiguity here: Bindings are explicit (via `let`/`const` patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.","format":"org.matrix.custom.html","formatted_body":"<p>I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:</p>\n<pre><code>when (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n</code></pre>\n<p>There's no ambiguity here: Bindings are explicit (via <code>let</code>/<code>const</code> patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:\n\n```\nwhen (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n```\nThere's no ambiguity here: Bindings are explicit (via `let`/`const` patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.","mimetype":"text/plain"},{"body":"<p>I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:</p>\n<pre><code>when (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n</code></pre>\n<p>There's no ambiguity here: Bindings are explicit (via <code>let</code>/<code>const</code> patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.</p>\n","mimetype":"text/html"}]},"ts":1662590449450,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dGpSdNnTKVgmGBcV_W6w1EHpaCGMW-24_dH1mDBbWuc"},
{"content":{"body":"Alternatively, there's also Rust's `@`-like syntax for bindings:\n```\nwhen ({ x@x }): ...; // bind `x` property to variable `x`\n```\nBut I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about `@` conflicting with some other future decorator target.","format":"org.matrix.custom.html","formatted_body":"<p>Alternatively, there's also Rust's <code>@</code>-like syntax for bindings:</p>\n<pre><code>when ({ x@x }): ...; // bind `x` property to variable `x`\n</code></pre>\n<p>But I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about <code>@</code> conflicting with some other future decorator target.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Alternatively, there's also Rust's `@`-like syntax for bindings:\n```\nwhen ({ x@x }): ...; // bind `x` property to variable `x`\n```\nBut I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about `@` conflicting with some other future decorator target.","mimetype":"text/plain"},{"body":"<p>Alternatively, there's also Rust's <code>@</code>-like syntax for bindings:</p>\n<pre><code>when ({ x@x }): ...; // bind `x` property to variable `x`\n</code></pre>\n<p>But I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about <code>@</code> conflicting with some other future decorator target.</p>\n","mimetype":"text/html"}]},"ts":1662590597354,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WKyKYpuSqrxfjgJ2FXwJ0vuOOpD4116sgWNoWksWAXo"},
{"content":{"body":"Those last three are all primitive matchers, but otherwise yes, if we move irrefutable matchers to a separate syntax then we can resolve idents by as references instead.","msgtype":"m.text","org.matrix.msc1767.text":"Those last three are all primitive matchers, but otherwise yes, if we move irrefutable matchers to a separate syntax then we can resolve idents by as references instead."},"ts":1662590672129,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$3sFY-oPi_V2viVbNnFQlwu0GbwS8_0zBX0A2iQr0Sus"},
{"content":{"body":"Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","format":"org.matrix.custom.html","formatted_body":"Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","mimetype":"text/plain"},{"body":"Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","mimetype":"text/html"}]},"ts":1662590702124,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$nKrjaUzlB9WcV2lJ7dFqf_r5_8v6gK88K87a-j12kXA"},
{"content":{"body":"I don't think it makes sense to treat `Infinity`, `NaN`, or `undefined` any differently than any other Identifier, since that's how resolution works everywhere else.","format":"org.matrix.custom.html","formatted_body":"I don't think it makes sense to treat <code>Infinity</code>, <code>NaN</code>, or <code>undefined</code> any differently than any other Identifier, since that's how resolution works everywhere else.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I don't think it makes sense to treat `Infinity`, `NaN`, or `undefined` any differently than any other Identifier, since that's how resolution works everywhere else.","mimetype":"text/plain"},{"body":"I don't think it makes sense to treat <code>Infinity</code>, <code>NaN</code>, or <code>undefined</code> any differently than any other Identifier, since that's how resolution works everywhere else.","mimetype":"text/html"}]},"ts":1662590719246,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ugwevnU3U-1-fOCPoLzYW0KIAePqc21i27sG7C89XXA"},
{"content":{"body":"> <@tabatkins:matrix.org> Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.\n\nI definitely want qualified named (i.e., `a.b`) as well. And I'm fine with preparing matchers beforehand. I'd rather not have `when ({ x: ${value => arbitraryCondition} }): ...;` as it significantly reduces readability.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$nKrjaUzlB9WcV2lJ7dFqf_r5_8v6gK88K87a-j12kXA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.</blockquote></mx-reply>I definitely want qualified named (i.e., <code>a.b</code>) as well. And I'm fine with preparing matchers beforehand. I'd rather not have <code>when ({ x: ${value =&gt; arbitraryCondition} }): ...;</code> as it significantly reduces readability.","m.relates_to":{"m.in_reply_to":{"event_id":"$nKrjaUzlB9WcV2lJ7dFqf_r5_8v6gK88K87a-j12kXA"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@tabatkins:matrix.org> Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.\n\nI definitely want qualified named (i.e., `a.b`) as well. And I'm fine with preparing matchers beforehand. I'd rather not have `when ({ x: ${value => arbitraryCondition} }): ...;` as it significantly reduces readability.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$nKrjaUzlB9WcV2lJ7dFqf_r5_8v6gK88K87a-j12kXA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.</blockquote></mx-reply>I definitely want qualified named (i.e., <code>a.b</code>) as well. And I'm fine with preparing matchers beforehand. I'd rather not have <code>when ({ x: ${value =&gt; arbitraryCondition} }): ...;</code> as it significantly reduces readability.","mimetype":"text/html"}]},"ts":1662590837157,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Zr1YnvY1RGsrLz3R1aI65PATbTAmWZbge4p3wtcRMxw"},
{"content":{"body":"Well, `-Infinity` needs to be treated specially, since it's *not* an identifier, it's an unary-minus expression whose argument is `Infinity`.","format":"org.matrix.custom.html","formatted_body":"Well, <code>-Infinity</code> needs to be treated specially, since it's <em>not</em> an identifier, it's an unary-minus expression whose argument is <code>Infinity</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Well, `-Infinity` needs to be treated specially, since it's *not* an identifier, it's an unary-minus expression whose argument is `Infinity`.","mimetype":"text/plain"},{"body":"Well, <code>-Infinity</code> needs to be treated specially, since it's <em>not</em> an identifier, it's an unary-minus expression whose argument is <code>Infinity</code>.","mimetype":"text/html"}]},"ts":1662591450357,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$Sll_rfN7zfzNrhlUDJKwa7Np_fvSErrD04zspRMe3LE"},
{"content":{"body":"(Same for all negative numbers, in fact.)","msgtype":"m.text","org.matrix.msc1767.text":"(Same for all negative numbers, in fact.)"},"ts":1662591463171,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$-TKGOg54VBvOvUb_BUK3U12ROiTI99z1M7bigeevmEk"},
{"content":{"body":"And so either we treat `-Infinity` as a baked-in pattern (and for consistency, do the same for `Infinity`), or we have to recognize unary-minus expressions *in general*, so `-foo` is also valid.","format":"org.matrix.custom.html","formatted_body":"And so either we treat <code>-Infinity</code> as a baked-in pattern (and for consistency, do the same for <code>Infinity</code>), or we have to recognize unary-minus expressions <em>in general</em>, so <code>-foo</code> is also valid.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"And so either we treat `-Infinity` as a baked-in pattern (and for consistency, do the same for `Infinity`), or we have to recognize unary-minus expressions *in general*, so `-foo` is also valid.","mimetype":"text/plain"},{"body":"And so either we treat <code>-Infinity</code> as a baked-in pattern (and for consistency, do the same for <code>Infinity</code>), or we have to recognize unary-minus expressions <em>in general</em>, so <code>-foo</code> is also valid.","mimetype":"text/html"}]},"ts":1662591530978,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$YLTjMATWafYs_Y3sVkDkvZmgUoyKUFh0QnvVWWfpesw"},
{"content":{"body":"(unary-plus as well)","msgtype":"m.text","org.matrix.msc1767.text":"(unary-plus as well)"},"ts":1662591608319,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$xjyNz8s6QqG6uIEmE8ZgktaL8WdgwCYEFybyjGhXFoo"},
{"content":{"body":"While stashing functions into the interpolation pattern isn't great (you should indeed just extract that and give it a name), things like `${foo+\"bar\"}` aren't unreasonable to match against, I think.","format":"org.matrix.custom.html","formatted_body":"While stashing functions into the interpolation pattern isn't great (you should indeed just extract that and give it a name), things like <code>${foo+&quot;bar&quot;}</code> aren't unreasonable to match against, I think.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"While stashing functions into the interpolation pattern isn't great (you should indeed just extract that and give it a name), things like `${foo+\"bar\"}` aren't unreasonable to match against, I think.","mimetype":"text/plain"},{"body":"While stashing functions into the interpolation pattern isn't great (you should indeed just extract that and give it a name), things like <code>${foo+&quot;bar&quot;}</code> aren't unreasonable to match against, I think.","mimetype":"text/html"}]},"ts":1662591674264,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$pnfL2xA-_XCQ31hhmLdZMSYYzKZMm423TIm0ggHwBvw"},
{"content":{"body":"Also, being able to call functions, or refer to things with `[]` syntax, both seem reasonable to me.","format":"org.matrix.custom.html","formatted_body":"Also, being able to call functions, or refer to things with <code>[]</code> syntax, both seem reasonable to me.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Also, being able to call functions, or refer to things with `[]` syntax, both seem reasonable to me.","mimetype":"text/plain"},{"body":"Also, being able to call functions, or refer to things with <code>[]</code> syntax, both seem reasonable to me.","mimetype":"text/html"}]},"ts":1662591749391,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$_Qhf9R-Iusk02UTgB1LnbyfoXo3BP68_ZjEbv2neN-0"},
{"content":{"body":"`-Infinity` could be `` `-` SomeMoreRestrictiveMatchPattern `` that allows numeric literals and identifiers, and just performs a `ToNumber` on the identifiers.","format":"org.matrix.custom.html","formatted_body":"<code>-Infinity</code> could be <code>`-` SomeMoreRestrictiveMatchPattern</code> that allows numeric literals and identifiers, and just performs a <code>ToNumber</code> on the identifiers.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`-Infinity` could be `` `-` SomeMoreRestrictiveMatchPattern `` that allows numeric literals and identifiers, and just performs a `ToNumber` on the identifiers.","mimetype":"text/plain"},{"body":"<code>-Infinity</code> could be <code>`-` SomeMoreRestrictiveMatchPattern</code> that allows numeric literals and identifiers, and just performs a <code>ToNumber</code> on the identifiers.","mimetype":"text/html"}]},"ts":1662592150259,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SHW3S7ttuJk9h_LzFkbnySYpRQ6uJmfdRFbuFXwrCE0"}
]