[
{"content":{"body":"I believe it's rare to have a full \"escape back to normal expression syntax\" switch. It seems that most just allow for idents and possibly identifier descent (dotted/etc), referring to bindings visible from the outside.","msgtype":"m.text","org.matrix.msc1767.text":"I believe it's rare to have a full \"escape back to normal expression syntax\" switch. It seems that most just allow for idents and possibly identifier descent (dotted/etc), referring to bindings visible from the outside."},"ts":1662571193652,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$6Asa6lxqCZrDmLCABOnAN9AYeLpObrbT0nVuYASc3VA"},
{"content":{"body":"Tho note that interpolation *mostly* exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on *since* we have a well-defined boundary (and it's what the syntax does in template strings).","format":"org.matrix.custom.html","formatted_body":"Tho note that interpolation <em>mostly</em> exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on <em>since</em> we have a well-defined boundary (and it's what the syntax does in template strings).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Tho note that interpolation *mostly* exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on *since* we have a well-defined boundary (and it's what the syntax does in template strings).","mimetype":"text/plain"},{"body":"Tho note that interpolation <em>mostly</em> exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on <em>since</em> we have a well-defined boundary (and it's what the syntax does in template strings).","mimetype":"text/html"}]},"ts":1662571273254,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$zPRq7dBA1jkPYzjzOivIgu5Jz24SpHYDpSrBDYiDQfQ"},
{"content":{"body":"I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:\n\n```\nwhen (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n```\nThere's no ambiguity here: Bindings are explicit (via `let`/`const` patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.","format":"org.matrix.custom.html","formatted_body":"<p>I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:</p>\n<pre><code>when (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n</code></pre>\n<p>There's no ambiguity here: Bindings are explicit (via <code>let</code>/<code>const</code> patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:\n\n```\nwhen (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n```\nThere's no ambiguity here: Bindings are explicit (via `let`/`const` patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.","mimetype":"text/plain"},{"body":"<p>I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:</p>\n<pre><code>when (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n</code></pre>\n<p>There's no ambiguity here: Bindings are explicit (via <code>let</code>/<code>const</code> patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.</p>\n","mimetype":"text/html"}]},"ts":1662590449450,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dGpSdNnTKVgmGBcV_W6w1EHpaCGMW-24_dH1mDBbWuc"},
{"content":{"body":"Alternatively, there's also Rust's `@`-like syntax for bindings:\n```\nwhen ({ x@x }): ...; // bind `x` property to variable `x`\n```\nBut I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about `@` conflicting with some other future decorator target.","format":"org.matrix.custom.html","formatted_body":"<p>Alternatively, there's also Rust's <code>@</code>-like syntax for bindings:</p>\n<pre><code>when ({ x@x }): ...; // bind `x` property to variable `x`\n</code></pre>\n<p>But I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about <code>@</code> conflicting with some other future decorator target.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Alternatively, there's also Rust's `@`-like syntax for bindings:\n```\nwhen ({ x@x }): ...; // bind `x` property to variable `x`\n```\nBut I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about `@` conflicting with some other future decorator target.","mimetype":"text/plain"},{"body":"<p>Alternatively, there's also Rust's <code>@</code>-like syntax for bindings:</p>\n<pre><code>when ({ x@x }): ...; // bind `x` property to variable `x`\n</code></pre>\n<p>But I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about <code>@</code> conflicting with some other future decorator target.</p>\n","mimetype":"text/html"}]},"ts":1662590597354,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WKyKYpuSqrxfjgJ2FXwJ0vuOOpD4116sgWNoWksWAXo"},
{"content":{"body":"Those last three are all primitive matchers, but otherwise yes, if we move irrefutable matchers to a separate syntax then we can resolve idents by as references instead.","msgtype":"m.text","org.matrix.msc1767.text":"Those last three are all primitive matchers, but otherwise yes, if we move irrefutable matchers to a separate syntax then we can resolve idents by as references instead."},"ts":1662590672129,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$3sFY-oPi_V2viVbNnFQlwu0GbwS8_0zBX0A2iQr0Sus"},
{"content":{"body":"Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","format":"org.matrix.custom.html","formatted_body":"Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","mimetype":"text/plain"},{"body":"Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","mimetype":"text/html"}]},"ts":1662590702124,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$nKrjaUzlB9WcV2lJ7dFqf_r5_8v6gK88K87a-j12kXA"}
]