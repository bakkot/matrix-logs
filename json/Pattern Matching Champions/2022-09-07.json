[
{"content":{"body":"I believe it's rare to have a full \"escape back to normal expression syntax\" switch. It seems that most just allow for idents and possibly identifier descent (dotted/etc), referring to bindings visible from the outside.","msgtype":"m.text","org.matrix.msc1767.text":"I believe it's rare to have a full \"escape back to normal expression syntax\" switch. It seems that most just allow for idents and possibly identifier descent (dotted/etc), referring to bindings visible from the outside."},"ts":1662571193652,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$6Asa6lxqCZrDmLCABOnAN9AYeLpObrbT0nVuYASc3VA"},
{"content":{"body":"Tho note that interpolation *mostly* exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on *since* we have a well-defined boundary (and it's what the syntax does in template strings).","format":"org.matrix.custom.html","formatted_body":"Tho note that interpolation <em>mostly</em> exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on <em>since</em> we have a well-defined boundary (and it's what the syntax does in template strings).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Tho note that interpolation *mostly* exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on *since* we have a well-defined boundary (and it's what the syntax does in template strings).","mimetype":"text/plain"},{"body":"Tho note that interpolation <em>mostly</em> exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on <em>since</em> we have a well-defined boundary (and it's what the syntax does in template strings).","mimetype":"text/html"}]},"ts":1662571273254,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$zPRq7dBA1jkPYzjzOivIgu5Jz24SpHYDpSrBDYiDQfQ"},
{"content":{"body":"I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:\n\n```\nwhen (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n```\nThere's no ambiguity here: Bindings are explicit (via `let`/`const` patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.","format":"org.matrix.custom.html","formatted_body":"<p>I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:</p>\n<pre><code>when (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n</code></pre>\n<p>There's no ambiguity here: Bindings are explicit (via <code>let</code>/<code>const</code> patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:\n\n```\nwhen (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n```\nThere's no ambiguity here: Bindings are explicit (via `let`/`const` patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.","mimetype":"text/plain"},{"body":"<p>I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:</p>\n<pre><code>when (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)\nwhen ({ x }): ...; // either a syntax error, or merely tests for the presence of the property\nwhen ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)\nwhen ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)\nwhen ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.\nwhen ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.\nwhen ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.\n</code></pre>\n<p>There's no ambiguity here: Bindings are explicit (via <code>let</code>/<code>const</code> patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.</p>\n","mimetype":"text/html"}]},"ts":1662590449450,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dGpSdNnTKVgmGBcV_W6w1EHpaCGMW-24_dH1mDBbWuc"},
{"content":{"body":"Alternatively, there's also Rust's `@`-like syntax for bindings:\n```\nwhen ({ x@x }): ...; // bind `x` property to variable `x`\n```\nBut I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about `@` conflicting with some other future decorator target.","format":"org.matrix.custom.html","formatted_body":"<p>Alternatively, there's also Rust's <code>@</code>-like syntax for bindings:</p>\n<pre><code>when ({ x@x }): ...; // bind `x` property to variable `x`\n</code></pre>\n<p>But I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about <code>@</code> conflicting with some other future decorator target.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Alternatively, there's also Rust's `@`-like syntax for bindings:\n```\nwhen ({ x@x }): ...; // bind `x` property to variable `x`\n```\nBut I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about `@` conflicting with some other future decorator target.","mimetype":"text/plain"},{"body":"<p>Alternatively, there's also Rust's <code>@</code>-like syntax for bindings:</p>\n<pre><code>when ({ x@x }): ...; // bind `x` property to variable `x`\n</code></pre>\n<p>But I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about <code>@</code> conflicting with some other future decorator target.</p>\n","mimetype":"text/html"}]},"ts":1662590597354,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WKyKYpuSqrxfjgJ2FXwJ0vuOOpD4116sgWNoWksWAXo"},
{"content":{"body":"Those last three are all primitive matchers, but otherwise yes, if we move irrefutable matchers to a separate syntax then we can resolve idents by as references instead.","msgtype":"m.text","org.matrix.msc1767.text":"Those last three are all primitive matchers, but otherwise yes, if we move irrefutable matchers to a separate syntax then we can resolve idents by as references instead."},"ts":1662590672129,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$3sFY-oPi_V2viVbNnFQlwu0GbwS8_0zBX0A2iQr0Sus"},
{"content":{"body":"Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","format":"org.matrix.custom.html","formatted_body":"Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","mimetype":"text/plain"},{"body":"Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.","mimetype":"text/html"}]},"ts":1662590702124,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$nKrjaUzlB9WcV2lJ7dFqf_r5_8v6gK88K87a-j12kXA"},
{"content":{"body":"I don't think it makes sense to treat `Infinity`, `NaN`, or `undefined` any differently than any other Identifier, since that's how resolution works everywhere else.","format":"org.matrix.custom.html","formatted_body":"I don't think it makes sense to treat <code>Infinity</code>, <code>NaN</code>, or <code>undefined</code> any differently than any other Identifier, since that's how resolution works everywhere else.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I don't think it makes sense to treat `Infinity`, `NaN`, or `undefined` any differently than any other Identifier, since that's how resolution works everywhere else.","mimetype":"text/plain"},{"body":"I don't think it makes sense to treat <code>Infinity</code>, <code>NaN</code>, or <code>undefined</code> any differently than any other Identifier, since that's how resolution works everywhere else.","mimetype":"text/html"}]},"ts":1662590719246,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ugwevnU3U-1-fOCPoLzYW0KIAePqc21i27sG7C89XXA"},
{"content":{"body":"> <@tabatkins:matrix.org> Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.\n\nI definitely want qualified named (i.e., `a.b`) as well. And I'm fine with preparing matchers beforehand. I'd rather not have `when ({ x: ${value => arbitraryCondition} }): ...;` as it significantly reduces readability.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$nKrjaUzlB9WcV2lJ7dFqf_r5_8v6gK88K87a-j12kXA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.</blockquote></mx-reply>I definitely want qualified named (i.e., <code>a.b</code>) as well. And I'm fine with preparing matchers beforehand. I'd rather not have <code>when ({ x: ${value =&gt; arbitraryCondition} }): ...;</code> as it significantly reduces readability.","m.relates_to":{"m.in_reply_to":{"event_id":"$nKrjaUzlB9WcV2lJ7dFqf_r5_8v6gK88K87a-j12kXA"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@tabatkins:matrix.org> Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.\n\nI definitely want qualified named (i.e., `a.b`) as well. And I'm fine with preparing matchers beforehand. I'd rather not have `when ({ x: ${value => arbitraryCondition} }): ...;` as it significantly reduces readability.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$nKrjaUzlB9WcV2lJ7dFqf_r5_8v6gK88K87a-j12kXA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Tho that limits us to <em>just</em> idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.</blockquote></mx-reply>I definitely want qualified named (i.e., <code>a.b</code>) as well. And I'm fine with preparing matchers beforehand. I'd rather not have <code>when ({ x: ${value =&gt; arbitraryCondition} }): ...;</code> as it significantly reduces readability.","mimetype":"text/html"}]},"ts":1662590837157,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Zr1YnvY1RGsrLz3R1aI65PATbTAmWZbge4p3wtcRMxw"},
{"content":{"body":"Well, `-Infinity` needs to be treated specially, since it's *not* an identifier, it's an unary-minus expression whose argument is `Infinity`.","format":"org.matrix.custom.html","formatted_body":"Well, <code>-Infinity</code> needs to be treated specially, since it's <em>not</em> an identifier, it's an unary-minus expression whose argument is <code>Infinity</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Well, `-Infinity` needs to be treated specially, since it's *not* an identifier, it's an unary-minus expression whose argument is `Infinity`.","mimetype":"text/plain"},{"body":"Well, <code>-Infinity</code> needs to be treated specially, since it's <em>not</em> an identifier, it's an unary-minus expression whose argument is <code>Infinity</code>.","mimetype":"text/html"}]},"ts":1662591450357,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$Sll_rfN7zfzNrhlUDJKwa7Np_fvSErrD04zspRMe3LE"},
{"content":{"body":"(Same for all negative numbers, in fact.)","msgtype":"m.text","org.matrix.msc1767.text":"(Same for all negative numbers, in fact.)"},"ts":1662591463171,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$-TKGOg54VBvOvUb_BUK3U12ROiTI99z1M7bigeevmEk"},
{"content":{"body":"And so either we treat `-Infinity` as a baked-in pattern (and for consistency, do the same for `Infinity`), or we have to recognize unary-minus expressions *in general*, so `-foo` is also valid.","format":"org.matrix.custom.html","formatted_body":"And so either we treat <code>-Infinity</code> as a baked-in pattern (and for consistency, do the same for <code>Infinity</code>), or we have to recognize unary-minus expressions <em>in general</em>, so <code>-foo</code> is also valid.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"And so either we treat `-Infinity` as a baked-in pattern (and for consistency, do the same for `Infinity`), or we have to recognize unary-minus expressions *in general*, so `-foo` is also valid.","mimetype":"text/plain"},{"body":"And so either we treat <code>-Infinity</code> as a baked-in pattern (and for consistency, do the same for <code>Infinity</code>), or we have to recognize unary-minus expressions <em>in general</em>, so <code>-foo</code> is also valid.","mimetype":"text/html"}]},"ts":1662591530978,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$YLTjMATWafYs_Y3sVkDkvZmgUoyKUFh0QnvVWWfpesw"},
{"content":{"body":"(unary-plus as well)","msgtype":"m.text","org.matrix.msc1767.text":"(unary-plus as well)"},"ts":1662591608319,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$xjyNz8s6QqG6uIEmE8ZgktaL8WdgwCYEFybyjGhXFoo"},
{"content":{"body":"While stashing functions into the interpolation pattern isn't great (you should indeed just extract that and give it a name), things like `${foo+\"bar\"}` aren't unreasonable to match against, I think.","format":"org.matrix.custom.html","formatted_body":"While stashing functions into the interpolation pattern isn't great (you should indeed just extract that and give it a name), things like <code>${foo+&quot;bar&quot;}</code> aren't unreasonable to match against, I think.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"While stashing functions into the interpolation pattern isn't great (you should indeed just extract that and give it a name), things like `${foo+\"bar\"}` aren't unreasonable to match against, I think.","mimetype":"text/plain"},{"body":"While stashing functions into the interpolation pattern isn't great (you should indeed just extract that and give it a name), things like <code>${foo+&quot;bar&quot;}</code> aren't unreasonable to match against, I think.","mimetype":"text/html"}]},"ts":1662591674264,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$pnfL2xA-_XCQ31hhmLdZMSYYzKZMm423TIm0ggHwBvw"},
{"content":{"body":"Also, being able to call functions, or refer to things with `[]` syntax, both seem reasonable to me.","format":"org.matrix.custom.html","formatted_body":"Also, being able to call functions, or refer to things with <code>[]</code> syntax, both seem reasonable to me.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Also, being able to call functions, or refer to things with `[]` syntax, both seem reasonable to me.","mimetype":"text/plain"},{"body":"Also, being able to call functions, or refer to things with <code>[]</code> syntax, both seem reasonable to me.","mimetype":"text/html"}]},"ts":1662591749391,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$_Qhf9R-Iusk02UTgB1LnbyfoXo3BP68_ZjEbv2neN-0"},
{"content":{"body":"`-Infinity` could be `` `-` SomeMoreRestrictiveMatchPattern `` that allows numeric literals and identifiers, and just performs a `ToNumber` on the identifiers.","format":"org.matrix.custom.html","formatted_body":"<code>-Infinity</code> could be <code>`-` SomeMoreRestrictiveMatchPattern</code> that allows numeric literals and identifiers, and just performs a <code>ToNumber</code> on the identifiers.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`-Infinity` could be `` `-` SomeMoreRestrictiveMatchPattern `` that allows numeric literals and identifiers, and just performs a `ToNumber` on the identifiers.","mimetype":"text/plain"},{"body":"<code>-Infinity</code> could be <code>`-` SomeMoreRestrictiveMatchPattern</code> that allows numeric literals and identifiers, and just performs a <code>ToNumber</code> on the identifiers.","mimetype":"text/html"}]},"ts":1662592150259,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SHW3S7ttuJk9h_LzFkbnySYpRQ6uJmfdRFbuFXwrCE0"},
{"content":{"body":"I don't see why `-foo` shouldn't be viable. Lets say we allow identifier patterns to reference anything in scope, and that non-Object values match using SameValue (or SameValueZero), while Object values match as custom matchers. Why wouldn't you want to allow:\n```js\nconst SOME_CONSTANT = 1;\nmatch (input) {\n  when (SOME_CONSTANT): ...;\n  when (-SOME_CONSTANT): ...;\n}\n```\nI don't think it makes sense to extend any further than prefix `+`/`-`, though maybe bitmasks/bit shifts could maybe be a thing?","format":"org.matrix.custom.html","formatted_body":"<p>I don't see why <code>-foo</code> shouldn't be viable. Lets say we allow identifier patterns to reference anything in scope, and that non-Object values match using SameValue (or SameValueZero), while Object values match as custom matchers. Why wouldn't you want to allow:</p>\n<pre><code class=\"language-js\">const SOME_CONSTANT = 1;\nmatch (input) {\n  when (SOME_CONSTANT): ...;\n  when (-SOME_CONSTANT): ...;\n}\n</code></pre>\n<p>I don't think it makes sense to extend any further than prefix <code>+</code>/<code>-</code>, though maybe bitmasks/bit shifts could maybe be a thing?</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I don't see why `-foo` shouldn't be viable. Lets say we allow identifier patterns to reference anything in scope, and that non-Object values match using SameValue (or SameValueZero), while Object values match as custom matchers. Why wouldn't you want to allow:\n```js\nconst SOME_CONSTANT = 1;\nmatch (input) {\n  when (SOME_CONSTANT): ...;\n  when (-SOME_CONSTANT): ...;\n}\n```\nI don't think it makes sense to extend any further than prefix `+`/`-`, though maybe bitmasks/bit shifts could maybe be a thing?","mimetype":"text/plain"},{"body":"<p>I don't see why <code>-foo</code> shouldn't be viable. Lets say we allow identifier patterns to reference anything in scope, and that non-Object values match using SameValue (or SameValueZero), while Object values match as custom matchers. Why wouldn't you want to allow:</p>\n<pre><code class=\"language-js\">const SOME_CONSTANT = 1;\nmatch (input) {\n  when (SOME_CONSTANT): ...;\n  when (-SOME_CONSTANT): ...;\n}\n</code></pre>\n<p>I don't think it makes sense to extend any further than prefix <code>+</code>/<code>-</code>, though maybe bitmasks/bit shifts could maybe be a thing?</p>\n","mimetype":"text/html"}]},"ts":1662592466370,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$G2VDjMlimRHNo5eHd1fsTv2zoMieCA8k41Va2qHUIYA"},
{"content":{"body":"bitmasks could be kind of useful with numeric enums, i.e.:\n```js\nmatch (node.modifierFlags) {\n  when (ModifierFlags.Export | ModifierFlags.Default): ...; // default export\n  when (ModifierFlags.Export): ...; // named export\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>bitmasks could be kind of useful with numeric enums, i.e.:</p>\n<pre><code class=\"language-js\">match (node.modifierFlags) {\n  when (ModifierFlags.Export | ModifierFlags.Default): ...; // default export\n  when (ModifierFlags.Export): ...; // named export\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"bitmasks could be kind of useful with numeric enums, i.e.:\n```js\nmatch (node.modifierFlags) {\n  when (ModifierFlags.Export | ModifierFlags.Default): ...; // default export\n  when (ModifierFlags.Export): ...; // named export\n}\n```","mimetype":"text/plain"},{"body":"<p>bitmasks could be kind of useful with numeric enums, i.e.:</p>\n<pre><code class=\"language-js\">match (node.modifierFlags) {\n  when (ModifierFlags.Export | ModifierFlags.Default): ...; // default export\n  when (ModifierFlags.Export): ...; // named export\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1662592553310,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3C_ZpXzT2sND6iWfkpRGqHDy5AQtR6-LrYIZwuKZnIg"},
{"content":{"body":"But that would also be possible with a guard, so its not that much of an issue.","msgtype":"m.text","org.matrix.msc1767.text":"But that would also be possible with a guard, so its not that much of an issue."},"ts":1662592709101,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$68DAJZyKcgR64LnMNGFpsnrsZCy8Mz5zrAUhhPRq71A"},
{"content":{"body":"Right, this is the slippery slope I'd prefer to not get into. Mixing expression syntax into pattern syntax will make things a *lot* more complicate.d","format":"org.matrix.custom.html","formatted_body":"Right, this is the slippery slope I'd prefer to not get into. Mixing expression syntax into pattern syntax will make things a <em>lot</em> more complicate.d","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Right, this is the slippery slope I'd prefer to not get into. Mixing expression syntax into pattern syntax will make things a *lot* more complicate.d","mimetype":"text/plain"},{"body":"Right, this is the slippery slope I'd prefer to not get into. Mixing expression syntax into pattern syntax will make things a <em>lot</em> more complicate.d","mimetype":"text/html"}]},"ts":1662593220786,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$ZHnHo7jD0foWmQKsKhTGnr8pWEHj2LOugrux9RIu20k"},
{"content":{"body":"I put together a document detailing five core tenets that I believe could serve as a guide to discussions about pattern matching syntax and semantics. I've intentionally avoided using any syntax from the current pattern matching proposal or yulia's suggestions to instead focus on the underlying driving principles of pattern matching. All examples instead use syntax from Rust, Scala, C#, or F# for reference. I'd appreciate commentary and feedback and whether this makes sense to adopt as a set of principles for the proposal: https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b","format":"org.matrix.custom.html","formatted_body":"I put together a document detailing five core tenets that I believe could serve as a guide to discussions about pattern matching syntax and semantics. I've intentionally avoided using any syntax from the current pattern matching proposal or <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia</a>'s suggestions to instead focus on the underlying driving principles of pattern matching. All examples instead use syntax from Rust, Scala, C#, or F# for reference. I'd appreciate commentary and feedback and whether this makes sense to adopt as a set of principles for the proposal: https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I put together a document detailing five core tenets that I believe could serve as a guide to discussions about pattern matching syntax and semantics. I've intentionally avoided using any syntax from the current pattern matching proposal or yulia's suggestions to instead focus on the underlying driving principles of pattern matching. All examples instead use syntax from Rust, Scala, C#, or F# for reference. I'd appreciate commentary and feedback and whether this makes sense to adopt as a set of principles for the proposal: https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b","mimetype":"text/plain"},{"body":"I put together a document detailing five core tenets that I believe could serve as a guide to discussions about pattern matching syntax and semantics. I've intentionally avoided using any syntax from the current pattern matching proposal or <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia</a>'s suggestions to instead focus on the underlying driving principles of pattern matching. All examples instead use syntax from Rust, Scala, C#, or F# for reference. I'd appreciate commentary and feedback and whether this makes sense to adopt as a set of principles for the proposal: https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b","mimetype":"text/html"}]},"ts":1662593305723,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SvRt8lK41N7pY7CDo8OkSrS-GCtJ-hqp5sehcEu9iik"},
{"content":{"body":"I think it could be useful as a reference for any future discussion about pattern matching syntax or potential layering.","msgtype":"m.text","org.matrix.msc1767.text":"I think it could be useful as a reference for any future discussion about pattern matching syntax or potential layering."},"ts":1662593383128,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$z305471VsdKTNjveZpn4uA8RGCYBPWgVQI-nG8-6l-k"}
]