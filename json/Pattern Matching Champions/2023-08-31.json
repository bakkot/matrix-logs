[
{"content":{"body":"I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. Languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. Languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1693490078082,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ev3ez5PRf6LXtcKzWa_kHfwa5ZR85jj5NxdQfMwYGQY"},
{"content":{"body":" * I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","m.new_content":{"body":"I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$ev3ez5PRf6LXtcKzWa_kHfwa5ZR85jj5NxdQfMwYGQY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693490105617,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$k2zQ4HLm7953vR1QjS6sif8ufD5ErhpgbD_BLXFRqd4"},
{"content":{"body":" * I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","m.new_content":{"body":"I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$ev3ez5PRf6LXtcKzWa_kHfwa5ZR85jj5NxdQfMwYGQY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693491276955,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aiya9jyTQHYdX5Y4-F7AHh3E6Z6-lnnJ8flG1KXhyjg"},
{"content":{"body":"This was the feedback that Anders shared with me regarding the use of `do` expressions for cases like this:\n> I would also argue that `do` expressions attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem `do` expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.","format":"org.matrix.custom.html","formatted_body":"<p>This was the feedback that Anders shared with me regarding the use of <code>do</code> expressions for cases like this:</p>\n<blockquote>\n<p>I would also argue that <code>do</code> expressions attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem <code>do</code> expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.</p>\n</blockquote>\n","msgtype":"m.text"},"ts":1693493117016,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TNQLIHquiFjhyiO2CuAbSIEzlV5-HaWWpITJo8sKfpk"},
{"content":{"body":" * This was the feedback that Anders shared with me regarding the use of `do` expressions for cases like this:\n\n> I would also argue that `do` [expressions] attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem `do` expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.","format":"org.matrix.custom.html","formatted_body":" * <p>This was the feedback that Anders shared with me regarding the use of <code>do</code> expressions for cases like this:</p>\n<blockquote>\n<p>I would also argue that <code>do</code> [expressions] attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem <code>do</code> expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.</p>\n</blockquote>\n","m.new_content":{"body":"This was the feedback that Anders shared with me regarding the use of `do` expressions for cases like this:\n\n> I would also argue that `do` [expressions] attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem `do` expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.","format":"org.matrix.custom.html","formatted_body":"<p>This was the feedback that Anders shared with me regarding the use of <code>do</code> expressions for cases like this:</p>\n<blockquote>\n<p>I would also argue that <code>do</code> [expressions] attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem <code>do</code> expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.</p>\n</blockquote>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$TNQLIHquiFjhyiO2CuAbSIEzlV5-HaWWpITJo8sKfpk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693493126488,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tA6siTPvYe4Y0sto6O_eC3faJdo-TiykWoSpqlzHCGo"},
{"content":{"body":"> <@tabatkins:matrix.org> I'm writing up the PR now, and I'm suddenly struck by an idea: instead of `when` as the branch introducer, should we use `is`? That makes it perfectly match up with the boolean form, just with an implicit LHS coming from the match block itself.\n\nI'm ok with both. I don't know how native english speakers see this","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$5XoduhewQlDLANpVo3ZiwXmoeg2tS6Fw7Gx4_CjN4yA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>I'm writing up the PR now, and I'm suddenly struck by an idea: instead of <code>when</code> as the branch introducer, should we use <code>is</code>? That makes it perfectly match up with the boolean form, just with an implicit LHS coming from the match block itself.</blockquote></mx-reply>I'm ok with both. I don't know how native english speakers see this","m.relates_to":{"m.in_reply_to":{"event_id":"$5XoduhewQlDLANpVo3ZiwXmoeg2tS6Fw7Gx4_CjN4yA"}},"msgtype":"m.text"},"ts":1693494849927,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$orHeHmhnQFt1-TFmQ5_wQPYPe_V6ttxOg2I5OUIcofw"},
{"content":{"body":"> <@tabatkins:matrix.org> Yeah it does.\n\nreally? why `x is y` introduce binding? IMO for `const x = y is [let z]` it does not introduce binding (at least outside of the pattern), and in `if (y is [let z])` it introduce binding but you need a `let `","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$1W6d6tdRg7OD8qhrCMBYPSHe-BzOnyY55oOZLDp81fs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Yeah it does.</blockquote></mx-reply>really? why <code>x is y</code> introduce binding? IMO for <code>const x = y is [let z]</code> it does not introduce binding (at least outside of the pattern), and in <code>if (y is [let z])</code> it introduce binding but you need a <code>let </code>","m.relates_to":{"m.in_reply_to":{"event_id":"$1W6d6tdRg7OD8qhrCMBYPSHe-BzOnyY55oOZLDp81fs"}},"msgtype":"m.text"},"ts":1693495027273,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$K9WZjzHegdzj6ZkNMf54I3OFk7afcxltc4TtRxuTNs8"},
{"content":{"body":"> <@ljharb:matrix.org> i think it would be *super* weird for a lone boolean test to produce bindings\n\nyes, but for consistency I'd expect the binding can be used in the pattern. `let isTwoItemsEqual = expr is [let a, a]` this should work (as it should work inside match expression)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$1mMMSIAHkpgponMSQLWB9weWRdNFdsP2J6bsRQ8Rj-o?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>i think it would be <em>super</em> weird for a lone boolean test to produce bindings</blockquote></mx-reply>yes, but for consistency I'd expect the binding can be used in the pattern. <code>let isTwoItemsEqual = expr is [let a, a]</code> this should work (as it should work inside match expression)","m.relates_to":{"m.in_reply_to":{"event_id":"$1mMMSIAHkpgponMSQLWB9weWRdNFdsP2J6bsRQ8Rj-o"}},"msgtype":"m.text"},"ts":1693495884516,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$OMhbLTEVmA0VDjSuFCmBikFWQPGuUFc_nK_mOvx-Zow"}
]