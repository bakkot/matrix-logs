[
{"content":{"body":"I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. Languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. Languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1693490078082,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ev3ez5PRf6LXtcKzWa_kHfwa5ZR85jj5NxdQfMwYGQY"},
{"content":{"body":" * I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","m.new_content":{"body":"I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$ev3ez5PRf6LXtcKzWa_kHfwa5ZR85jj5NxdQfMwYGQY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693490105617,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$k2zQ4HLm7953vR1QjS6sif8ufD5ErhpgbD_BLXFRqd4"}
]