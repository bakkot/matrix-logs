[
{"content":{"body":"I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. Languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. Languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1693490078082,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ev3ez5PRf6LXtcKzWa_kHfwa5ZR85jj5NxdQfMwYGQY"},
{"content":{"body":" * I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","m.new_content":{"body":"I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n        addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$ev3ez5PRf6LXtcKzWa_kHfwa5ZR85jj5NxdQfMwYGQY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693490105617,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$k2zQ4HLm7953vR1QjS6sif8ufD5ErhpgbD_BLXFRqd4"},
{"content":{"body":" * I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","m.new_content":{"body":"I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, `let..in` expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (`x := y`). C# even has this capability as well with variable patterns (much like the `let` patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.\n\nAn example from the TypeScript compiler that Anders mentioned is this one:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nThis requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n```\n\nWhere the `propType` variable can be declared `const` and doesn't require lifting the declaration out of the expression.\n\nI'm still waiting on his feedback regarding `do`-expressions, but my take is that `do` doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType && addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n```\n\nWhile `x is let y`/`x is const y` isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:\n\n```ts\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>I've reached out to Anders to get a better understanding of his interest and motivations in introducing variables in expressions, and will follow up when I have more information. From the short conversation we had yesterday, his primary interest has to do with functional programming. In languages like Haskell, Scheme, and ML, <code>let..in</code> expressions provide variables that are scoped to sub expressions. Python has something similar as well in the form of assignment expressions (<code>x := y</code>). C# even has this capability as well with variable patterns (much like the <code>let</code> patterns I've proposed), though it's not as ideal: https://dotnetfiddle.net/g4Zf13.</p>\n<p>An example from the TypeScript compiler that Anders mentioned is this one:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    let propType;\n    return getTypeOfPropertyOfType(type, name) ||\n        (propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>This requires declaring a mutable variable at the statement level. He believes something like the following would be an improvement for FP-style development:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (const propType = getApplicableIndexInfoForName(type, name)?.type) &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n}\n</code></pre>\n<p>Where the <code>propType</code> variable can be declared <code>const</code> and doesn't require lifting the declaration out of the expression.</p>\n<p>I'm still waiting on his feedback regarding <code>do</code>-expressions, but my take is that <code>do</code> doesn't make this expression any more succinct or clear, it just introduces a confusing statement scope in the middle of an expression:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n  return getTypeOfPropertyOfType(type, name) ||\n    do {\n      const propType = getApplicableIndexInfoForName(type, name)?.type;\n      propType &amp;&amp; addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true);\n    };\n}\n</code></pre>\n<p>While <code>x is let y</code>/<code>x is const y</code> isn't necessarily an ideal solution, it remains concise and is possibly even more powerful since it's combined with pattern matching:</p>\n<pre><code class=\"language-ts\">function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$ev3ez5PRf6LXtcKzWa_kHfwa5ZR85jj5NxdQfMwYGQY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693491276955,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aiya9jyTQHYdX5Y4-F7AHh3E6Z6-lnnJ8flG1KXhyjg"},
{"content":{"body":"This was the feedback that Anders shared with me regarding the use of `do` expressions for cases like this:\n> I would also argue that `do` expressions attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem `do` expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.","format":"org.matrix.custom.html","formatted_body":"<p>This was the feedback that Anders shared with me regarding the use of <code>do</code> expressions for cases like this:</p>\n<blockquote>\n<p>I would also argue that <code>do</code> expressions attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem <code>do</code> expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.</p>\n</blockquote>\n","msgtype":"m.text"},"ts":1693493117016,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$TNQLIHquiFjhyiO2CuAbSIEzlV5-HaWWpITJo8sKfpk"},
{"content":{"body":" * This was the feedback that Anders shared with me regarding the use of `do` expressions for cases like this:\n\n> I would also argue that `do` [expressions] attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem `do` expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.","format":"org.matrix.custom.html","formatted_body":" * <p>This was the feedback that Anders shared with me regarding the use of <code>do</code> expressions for cases like this:</p>\n<blockquote>\n<p>I would also argue that <code>do</code> [expressions] attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem <code>do</code> expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.</p>\n</blockquote>\n","m.new_content":{"body":"This was the feedback that Anders shared with me regarding the use of `do` expressions for cases like this:\n\n> I would also argue that `do` [expressions] attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem `do` expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.","format":"org.matrix.custom.html","formatted_body":"<p>This was the feedback that Anders shared with me regarding the use of <code>do</code> expressions for cases like this:</p>\n<blockquote>\n<p>I would also argue that <code>do</code> [expressions] attempt to solve a problem I don't have, i.e. full statement bodies in the middle of an expression. Once you need full statement blocks, you're probably better off not being in an expression context. In other words, the only problem <code>do</code> expressions would solve for me is that of giving names to sub-expressions, but they're so clumsy that I'd avoid them and advise my team to do so as well.</p>\n</blockquote>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$TNQLIHquiFjhyiO2CuAbSIEzlV5-HaWWpITJo8sKfpk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693493126488,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tA6siTPvYe4Y0sto6O_eC3faJdo-TiykWoSpqlzHCGo"},
{"content":{"body":"> <@tabatkins:matrix.org> I'm writing up the PR now, and I'm suddenly struck by an idea: instead of `when` as the branch introducer, should we use `is`? That makes it perfectly match up with the boolean form, just with an implicit LHS coming from the match block itself.\n\nI'm ok with both. I don't know how native english speakers see this","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$5XoduhewQlDLANpVo3ZiwXmoeg2tS6Fw7Gx4_CjN4yA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>I'm writing up the PR now, and I'm suddenly struck by an idea: instead of <code>when</code> as the branch introducer, should we use <code>is</code>? That makes it perfectly match up with the boolean form, just with an implicit LHS coming from the match block itself.</blockquote></mx-reply>I'm ok with both. I don't know how native english speakers see this","m.relates_to":{"m.in_reply_to":{"event_id":"$5XoduhewQlDLANpVo3ZiwXmoeg2tS6Fw7Gx4_CjN4yA"}},"msgtype":"m.text"},"ts":1693494849927,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$orHeHmhnQFt1-TFmQ5_wQPYPe_V6ttxOg2I5OUIcofw"},
{"content":{"body":"> <@tabatkins:matrix.org> Yeah it does.\n\nreally? why `x is y` introduce binding? IMO for `const x = y is [let z]` it does not introduce binding (at least outside of the pattern), and in `if (y is [let z])` it introduce binding but you need a `let `","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$1W6d6tdRg7OD8qhrCMBYPSHe-BzOnyY55oOZLDp81fs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>Yeah it does.</blockquote></mx-reply>really? why <code>x is y</code> introduce binding? IMO for <code>const x = y is [let z]</code> it does not introduce binding (at least outside of the pattern), and in <code>if (y is [let z])</code> it introduce binding but you need a <code>let </code>","m.relates_to":{"m.in_reply_to":{"event_id":"$1W6d6tdRg7OD8qhrCMBYPSHe-BzOnyY55oOZLDp81fs"}},"msgtype":"m.text"},"ts":1693495027273,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$K9WZjzHegdzj6ZkNMf54I3OFk7afcxltc4TtRxuTNs8"},
{"content":{"body":"> <@ljharb:matrix.org> i think it would be *super* weird for a lone boolean test to produce bindings\n\nyes, but for consistency I'd expect the binding can be used in the pattern. `let isTwoItemsEqual = expr is [let a, a]` this should work (as it should work inside match expression)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$1mMMSIAHkpgponMSQLWB9weWRdNFdsP2J6bsRQ8Rj-o?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>i think it would be <em>super</em> weird for a lone boolean test to produce bindings</blockquote></mx-reply>yes, but for consistency I'd expect the binding can be used in the pattern. <code>let isTwoItemsEqual = expr is [let a, a]</code> this should work (as it should work inside match expression)","m.relates_to":{"m.in_reply_to":{"event_id":"$1mMMSIAHkpgponMSQLWB9weWRdNFdsP2J6bsRQ8Rj-o"}},"msgtype":"m.text"},"ts":1693495884516,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$OMhbLTEVmA0VDjSuFCmBikFWQPGuUFc_nK_mOvx-Zow"},
{"content":{"body":"> <@rbuckton:matrix.org> Plus there's been a long standing request from Anders Hejlsberg that JavaScript needs some way to introduce variables in-situ in expressions. He hasn't been partial to `do` expressions, so I'm hoping this would address that as well. `x is let y` could theoretically fill the same role as a `let..in` expression in other languages:\n> \n> ```\n> // PowerQuery\n> x = let a = foo() in\n>     let b = a.b in\n>     [a, b];\n> \n> // OpenSCAD\n> x = let (a = foo())\n>     let (b = a[0])\n>     [a, b];\n> ```\n> \n> vs.\n> \n> ```\n> // same thing with `let` patterns:\n> x = foo() is let a,\n>     a.b is let b,\n>     [a, b];\n> ```\n\nI like the `if let` part but I'm a little uncomfortable with binding in tenary `expr is [let a] ? a : b`. I know it's useful but it give me a feeling of non-JS","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$Xva49IaU4zcea5PwvUiVhivLEzz3tm0BWaZci6SKlQc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>Plus there's been a long standing request from Anders Hejlsberg that JavaScript needs some way to introduce variables in-situ in expressions. He hasn't been partial to <code>do</code> expressions, so I'm hoping this would address that as well. <code>x is let y</code> could theoretically fill the same role as a <code>let..in</code> expression in other languages:</p>\n<pre><code>// PowerQuery\nx = let a = foo() in\n    let b = a.b in\n    [a, b];\n\n// OpenSCAD\nx = let (a = foo())\n    let (b = a[0])\n    [a, b];\n</code></pre>\n<p>vs.</p>\n<pre><code>// same thing with `let` patterns:\nx = foo() is let a,\n    a.b is let b,\n    [a, b];\n</code></pre>\n</blockquote></mx-reply>I like the <code>if let</code> part but I'm a little uncomfortable with binding in tenary <code>expr is [let a] ? a : b</code>. I know it's useful but it give me a feeling of non-JS","m.relates_to":{"m.in_reply_to":{"event_id":"$Xva49IaU4zcea5PwvUiVhivLEzz3tm0BWaZci6SKlQc"}},"msgtype":"m.text"},"ts":1693496184392,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$yzqpzCWspPDNm892jSStHoCEZbo9k4xMO_b_zGYqtIc"},
{"content":{"body":"> <@tabatkins:matrix.org> I'm writing up the PR now, and I'm suddenly struck by an idea: instead of `when` as the branch introducer, should we use `is`? That makes it perfectly match up with the boolean form, just with an implicit LHS coming from the match block itself.\n\nHonestly, I think `when` reads better, and has precedent in many other languages. If anything I still think `else` is better than `default` because its shorter and lines up visually:\n\n```\nmatch (foo) {\n  when pattern1: ...;\n  when pattern2: ...;\n  else: ...;\n}\n```\n\nAlso, in English, the word \"when\" at the start of a sentence can imply either a statement of fact, or begin a question. While \"is\" at the start of a sentence can only imply a question.\n\nSo `match (foo) { when pattern: ... }` would generally be interpreted as: \"**When** _foo_ is _pattern_ then ...\", while `is` would generally be interpreted as: \"If _foo_ **is** _pattern_ then ...\", which is a bit of cognitive overhead, imo.\n\nThat's why `is` makes sense as an infix expression form, since it has the infix position in the statement above. For example: `if (x is String) ...` reads as \"If _x_ **is** a String, then ...\".","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$5XoduhewQlDLANpVo3ZiwXmoeg2tS6Fw7Gx4_CjN4yA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>I'm writing up the PR now, and I'm suddenly struck by an idea: instead of <code>when</code> as the branch introducer, should we use <code>is</code>? That makes it perfectly match up with the boolean form, just with an implicit LHS coming from the match block itself.</blockquote></mx-reply><p>Honestly, I think <code>when</code> reads better, and has precedent in many other languages. If anything I still think <code>else</code> is better than <code>default</code> because its shorter and lines up visually:</p>\n<pre><code>match (foo) {\n  when pattern1: ...;\n  when pattern2: ...;\n  else: ...;\n}\n</code></pre>\n<p>Also, in English, the word \"when\" at the start of a sentence can imply either a statement of fact, or begin a question. While \"is\" at the start of a sentence can only imply a question.</p>\n<p>So <code>match (foo) { when pattern: ... }</code> would generally be interpreted as: \"<strong>When</strong> <em>foo</em> is <em>pattern</em> then ...\", while <code>is</code> would generally be interpreted as: \"If <em>foo</em> <strong>is</strong> <em>pattern</em> then ...\", which is a bit of cognitive overhead, imo.</p>\n<p>That's why <code>is</code> makes sense as an infix expression form, since it has the infix position in the statement above. For example: <code>if (x is String) ...</code> reads as \"If <em>x</em> <strong>is</strong> a String, then ...\".</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$5XoduhewQlDLANpVo3ZiwXmoeg2tS6Fw7Gx4_CjN4yA"}},"msgtype":"m.text"},"ts":1693496773826,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ex56Z_OyabkMpTC13O3sykvyVNh4b1KbyEH5ZVPYh2E"},
{"content":{"body":"> <@tabatkins:matrix.org> I definitely think that use-case is just better done with a do-expr. Like, if pattern-matching ends up accidentally allowing it, whatever, but taking that as an explicit use-case to take is something I'd disagree with, do-exprs are absolutely the right way to do that sort of thing.\n\nI heard that the author of do-expr don't want to push it anymore (but he also won't block it if anyone want to move on).\nI hope we can have (1) statement have their expression version, instead of do expression (e.g. `let a = if (expr) { b } else { c }` or `let a = for (let x of y) y` produces an array) (2) not be able to break/return/continue inside an expression (do expr currently allows this)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$tBmvqzmA4x-C10i81bJm0Mb7aGkSRrDCwc-yC9kV86g?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br>I definitely think that use-case is just better done with a do-expr. Like, if pattern-matching ends up accidentally allowing it, whatever, but taking that as an explicit use-case to take is something I&#39;d disagree with, do-exprs are absolutely the right way to do that sort of thing.</blockquote></mx-reply>I heard that the author of do-expr don't want to push it anymore (but he also won't block it if anyone want to move on).<br>I hope we can have (1) statement have their expression version, instead of do expression (e.g. <code>let a = if (expr) { b } else { c }</code> or <code>let a = for (let x of y) y</code> produces an array) (2) not be able to break/return/continue inside an expression (do expr currently allows this)","m.relates_to":{"m.in_reply_to":{"event_id":"$tBmvqzmA4x-C10i81bJm0Mb7aGkSRrDCwc-yC9kV86g"}},"msgtype":"m.text"},"ts":1693496776681,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$EAj2rd7AdAcEry4P9mYwn8wPUKvUOSXLF7xquL_8Vls"},
{"content":{"body":"> <@rbuckton:matrix.org> Honestly, I think `when` reads better, and has precedent in many other languages. If anything I still think `else` is better than `default` because its shorter and lines up visually:\n> \n> ```\n> match (foo) {\n>   when pattern1: ...;\n>   when pattern2: ...;\n>   else: ...;\n> }\n> ```\n> \n> Also, in English, the word \"when\" at the start of a sentence can imply either a statement of fact, or begin a question. While \"is\" at the start of a sentence can only imply a question.\n> \n> So `match (foo) { when pattern: ... }` would generally be interpreted as: \"**When** _foo_ is _pattern_ then ...\", while `is` would generally be interpreted as: \"If _foo_ **is** _pattern_ then ...\", which is a bit of cognitive overhead, imo.\n> \n> That's why `is` makes sense as an infix expression form, since it has the infix position in the statement above. For example: `if (x is String) ...` reads as \"If _x_ **is** a String, then ...\".\n\nthe reason we choose `default` not `else` is because of we used to have `if` matchers and `else` cause serious ambiguous problem. Looks like we don't have it in the current proposal so it's ok to reconsider it.\n\n```js\n// previous version\nmatch (e) {\n    when (pattern) -> z,\n    if (expr) -> a,\n    else -> b // is it `else` of `if`, or `else` of `match`?\n}\n```","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$ex56Z_OyabkMpTC13O3sykvyVNh4b1KbyEH5ZVPYh2E?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br><p>Honestly, I think <code>when</code> reads better, and has precedent in many other languages. If anything I still think <code>else</code> is better than <code>default</code> because its shorter and lines up visually:</p>\n<pre><code>match (foo) {\n  when pattern1: ...;\n  when pattern2: ...;\n  else: ...;\n}\n</code></pre>\n<p>Also, in English, the word \"when\" at the start of a sentence can imply either a statement of fact, or begin a question. While \"is\" at the start of a sentence can only imply a question.</p>\n<p>So <code>match (foo) { when pattern: ... }</code> would generally be interpreted as: \"<strong>When</strong> <em>foo</em> is <em>pattern</em> then ...\", while <code>is</code> would generally be interpreted as: \"If <em>foo</em> <strong>is</strong> <em>pattern</em> then ...\", which is a bit of cognitive overhead, imo.</p>\n<p>That's why <code>is</code> makes sense as an infix expression form, since it has the infix position in the statement above. For example: <code>if (x is String) ...</code> reads as \"If <em>x</em> <strong>is</strong> a String, then ...\".</p>\n</blockquote></mx-reply><p>the reason we choose <code>default</code> not <code>else</code> is because of we used to have <code>if</code> matchers and <code>else</code> cause serious ambiguous problem. Looks like we don't have it in the current proposal so it's ok to reconsider it.</p>\n<pre><code class=\"language-js\">// previous version\nmatch (e) {\n    when (pattern) -&gt; z,\n    if (expr) -&gt; a,\n    else -&gt; b // is it `else` of `if`, or `else` of `match`?\n}\n</code></pre>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$ex56Z_OyabkMpTC13O3sykvyVNh4b1KbyEH5ZVPYh2E"}},"msgtype":"m.text"},"ts":1693497145321,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$cEoDwFrTvBk2r8UjFE34pMwiuly2dPl3JwK5LK-EpiE"}
]