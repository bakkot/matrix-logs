[
{"content":{"body":"Why does an iterable make sense? A match should only be comparing to one pattern/value","msgtype":"m.text"},"ts":1637374369569,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$iy1m9jP5guTQ276M1PSQ5y2YjxNZThuZMw0AeNgX0dU"},
{"content":{"body":"For unapply, it's because it's essentially extracting arguments. I was considering `const Foo{x,y} = z` in addition to `const Foo(x, y) = z`, but there's no parallel construction syntax and I was concerned (incorrectly) that there was a syntax conflict in `match`. ","msgtype":"m.text"},"ts":1637377059445,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$37H2QORDATLWPMvmdNA5DdvILZGKm1F9yMd-kOZyux4"},
{"content":{"body":"(I thought a `when` clause was paren-less)","msgtype":"m.text"},"ts":1637377113957,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$uSpPrfRDKYAOjO1zO-43tiLQaBwkDAGWOnjZ24W3UAI"},
{"content":{"body":"atm it's only parenless with the pin operator's parenless form, but all that's still up in the air","msgtype":"m.text"},"ts":1637387118718,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$OP2NPV3Ly-W9c8TXAPdFSc0e1t3QUMaRlRz8w0_gtEc"},
{"content":{"body":"Very late to this conversation, but here's my $0.02:\n- I _love_ ADT enums in Rust, but JS isn't Rust. JS has easy / quick objects, Rust doesn't. Rust has a robust type system, JS doesn't. I think ADT enums are the right solution for Rust given those differences; I don't really see what they offer us in JS beyond what already exists.\n- I'm also a bit confused about `@@unapply` returning an iterable. It seems to me that there are two use-cases for `@@unapply`: one is tuple-like and one is record-like. I'm a bit skeptical of to solve both of those by returning an iterable, but maybe I'm missing something? Why not just have it return an array for the tuple-like case or an object for the record-like case?\n- Speaking of the differences between JS and Rust, I think we should also keep in mind the relative complexity of both languages. Rust has a much higher bar to entry than JS; both languages have their place, to be sure, but I worry that introducing full-fat ADT enums would increase JS's bar to entry.","format":"org.matrix.custom.html","formatted_body":"<p>Very late to this conversation, but here's my $0.02:</p>\n<ul>\n<li>I <em>love</em> ADT enums in Rust, but JS isn't Rust. JS has easy / quick objects, Rust doesn't. Rust has a robust type system, JS doesn't. I think ADT enums are the right solution for Rust given those differences; I don't really see what they offer us in JS beyond what already exists.</li>\n<li>I'm also a bit confused about <code>@@unapply</code> returning an iterable. It seems to me that there are two use-cases for <code>@@unapply</code>: one is tuple-like and one is record-like. I'm a bit skeptical of to solve both of those by returning an iterable, but maybe I'm missing something? Why not just have it return an array for the tuple-like case or an object for the record-like case?</li>\n<li>Speaking of the differences between JS and Rust, I think we should also keep in mind the relative complexity of both languages. Rust has a much higher bar to entry than JS; both languages have their place, to be sure, but I worry that introducing full-fat ADT enums would increase JS's bar to entry.</li>\n</ul>\n","msgtype":"m.text"},"ts":1637394620029,"senderName":"mpcsh","senderId":"@mpcsh_:matrix.org","id":"$cLT-rbU9fM_UEEl3sOXN2dYtMsmKtS2Vzhoj60J5ryE"},
{"content":{"body":" * Very late to this conversation, but here's my $0.02:\n- I _love_ ADT enums in Rust, but JS isn't Rust. JS has easy / quick objects, Rust doesn't. Rust has a robust type system, JS doesn't. I think ADT enums are the right solution for Rust given those differences; I don't really see what they offer us in JS beyond what already exists.\n- I'm also a bit confused about `@@unapply` returning an iterable. It seems to me that there are two use-cases for `@@unapply`: one is tuple-like and one is record-like. I'm a bit skeptical of to solve both of those by returning an iterable, but maybe I'm missing something? Why not just have it return an array for the tuple-like case or an object for the record-like case?\n- Speaking of the differences between JS and Rust, I think we should also keep in mind the relative complexity of both languages. Rust has a much higher bar to entry than JS; both languages have their place, to be sure, but I worry that introducing full-fat ADT enums would increase JS's bar to entry.","format":"org.matrix.custom.html","formatted_body":" * <p>Very late to this conversation, but here's my $0.02:</p>\n<ul>\n<li>I <em>love</em> ADT enums in Rust, but JS isn't Rust. JS has easy / quick objects, Rust doesn't. Rust has a robust type system, JS doesn't. I think ADT enums are the right solution for Rust given those differences; I don't really see what they offer us in JS beyond what already exists.</li>\n<li>I'm also a bit confused about <code>@@unapply</code> returning an iterable. It seems to me that there are two use-cases for <code>@@unapply</code>: one is tuple-like and one is record-like. I'm a bit skeptical of to solve both of those by returning an iterable, but maybe I'm missing something? Why not just have it return an array for the tuple-like case or an object for the record-like case?</li>\n<li>Speaking of the differences between JS and Rust, I think we should also keep in mind the relative complexity of both languages. Rust has a much higher bar to entry than JS; both languages have their place, to be sure, but I worry that introducing full-fat ADT enums would increase JS's bar to entry.</li>\n</ul>\n","m.new_content":{"body":"Very late to this conversation, but here's my $0.02:\n- I _love_ ADT enums in Rust, but JS isn't Rust. JS has easy / quick objects, Rust doesn't. Rust has a robust type system, JS doesn't. I think ADT enums are the right solution for Rust given those differences; I don't really see what they offer us in JS beyond what already exists.\n- I'm also a bit confused about `@@unapply` returning an iterable. It seems to me that there are two use-cases for `@@unapply`: one is tuple-like and one is record-like. I'm a bit skeptical of to solve both of those by returning an iterable, but maybe I'm missing something? Why not just have it return an array for the tuple-like case or an object for the record-like case?\n- Speaking of the differences between JS and Rust, I think we should also keep in mind the relative complexity of both languages. Rust has a much higher bar to entry than JS; both languages have their place, to be sure, but I worry that introducing full-fat ADT enums would increase JS's bar to entry.","format":"org.matrix.custom.html","formatted_body":"<p>Very late to this conversation, but here's my $0.02:</p>\n<ul>\n<li>I <em>love</em> ADT enums in Rust, but JS isn't Rust. JS has easy / quick objects, Rust doesn't. Rust has a robust type system, JS doesn't. I think ADT enums are the right solution for Rust given those differences; I don't really see what they offer us in JS beyond what already exists.</li>\n<li>I'm also a bit confused about <code>@@unapply</code> returning an iterable. It seems to me that there are two use-cases for <code>@@unapply</code>: one is tuple-like and one is record-like. I'm a bit skeptical of to solve both of those by returning an iterable, but maybe I'm missing something? Why not just have it return an array for the tuple-like case or an object for the record-like case?</li>\n<li>Speaking of the differences between JS and Rust, I think we should also keep in mind the relative complexity of both languages. Rust has a much higher bar to entry than JS; both languages have their place, to be sure, but I worry that introducing full-fat ADT enums would increase JS's bar to entry.</li>\n</ul>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$cLT-rbU9fM_UEEl3sOXN2dYtMsmKtS2Vzhoj60J5ryE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1637394628296,"senderName":"mpcsh","senderId":"@mpcsh_:matrix.org","id":"$J4eJ1XpVM1ODdwRl6aDPTy-3Wr77wlN8SYp0GyhWrM4"}
]