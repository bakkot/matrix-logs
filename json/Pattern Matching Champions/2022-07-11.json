[
{"content":{"body":"Yeah that feedback doesn't look unreasonable. I feel very safe ignoring \"overengineered\", since we're actually triangulating reasonably well on a minimal (but complete) feature set; that is indeed just people not realizing the use-cases we're trying to hit.","msgtype":"m.text","org.matrix.msc1767.text":"Yeah that feedback doesn't look unreasonable. I feel very safe ignoring \"overengineered\", since we're actually triangulating reasonably well on a minimal (but complete) feature set; that is indeed just people not realizing the use-cases we're trying to hit."},"ts":1657507249797,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$xi7EMNMRQxTLEmv4HhdT5I6i_EKoP3C64eqmS46anbE"},
{"content":{"body":"I'm still unhappy that `${x}` would likely block extractors in the future because of the `id{x}` conflict with `$` as a legal identifier. I'm hoping to present on extractors and the relation to pattern matching and ADT enums in a future TC39, but I'm in the middle of a cross-country move currently so I didn't have much time to prepare anything for next week's plenary. ","format":"org.matrix.custom.html","formatted_body":"I'm still unhappy that <code>${x}</code> would likely block extractors in the future because of the <code>id{x}</code> conflict with <code>$</code> as a legal identifier. I'm hoping to present on extractors and the relation to pattern matching and ADT enums in a future TC39, but I'm in the middle of a cross-country move currently so I didn't have much time to prepare anything for next week's plenary.","msgtype":"m.text"},"ts":1657509541218,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$0BHq_xaa0MBM5dv078P4NMa-RLDXBLZMGXsnCbOBMIo"},
{"content":{"body":"Do you have a link to extractors again? ","msgtype":"m.text","org.matrix.msc1767.text":"Do you have a link to extractors again? "},"ts":1657509819975,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$d8RBQfqlkAs1lg1NgoNULk7mPnAN7Xkkvhn2GDNsTro"},
{"content":{"body":"I was thinking about putting together an extractor proposal that just relied on `Symbol.matcher` rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses `with`:\n```js\nconst result = Option.Some{ value: 10 };\nconst Option.Some{ value } = result; // extractor is dual/inverse of constructor\n...\nmatch (result) {\n  when Option.Some{ value }: console.log(value); // also dual/inverse here\n  when Option.None: console.log(\"none\");\n}\n```\n\n","format":"org.matrix.custom.html","formatted_body":"<p>I was thinking about putting together an extractor proposal that just relied on <code>Symbol.matcher</code> rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses <code>with</code>:</p>\n<pre><code class=\"language-js\">const result = Option.Some{ value: 10 };\nconst Option.Some{ value } = result; // extractor is dual/inverse of constructor\n...\nmatch (result) {\n  when Option.Some{ value }: console.log(value); // also dual/inverse here\n  when Option.None: console.log(&quot;none&quot;);\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I was thinking about putting together an extractor proposal that just relied on `Symbol.matcher` rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses `with`:\n```js\nconst result = Option.Some{ value: 10 };\nconst Option.Some{ value } = result; // extractor is dual/inverse of constructor\n...\nmatch (result) {\n  when Option.Some{ value }: console.log(value); // also dual/inverse here\n  when Option.None: console.log(\"none\");\n}\n```\n\n","mimetype":"text/plain"},{"body":"<p>I was thinking about putting together an extractor proposal that just relied on <code>Symbol.matcher</code> rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses <code>with</code>:</p>\n<pre><code class=\"language-js\">const result = Option.Some{ value: 10 };\nconst Option.Some{ value } = result; // extractor is dual/inverse of constructor\n...\nmatch (result) {\n  when Option.Some{ value }: console.log(value); // also dual/inverse here\n  when Option.None: console.log(&quot;none&quot;);\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1657509884775,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$1PzYavvZjCLYROPesG5xREtSRilATE3X8zyfO6DFQes"},
{"content":{"body":"I haven't updated it in a bit, but the gist is here: https://gist.github.com/rbuckton/ae46b33f383ba69880c7138c49b5e799","msgtype":"m.text","org.matrix.msc1767.text":"I haven't updated it in a bit, but the gist is here: https://gist.github.com/rbuckton/ae46b33f383ba69880c7138c49b5e799"},"ts":1657509920731,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$yhvmTQ4shBXJ7bDFBnw2TAtQulZoDki53crx0XeQLyY"},
{"content":{"body":"One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","format":"org.matrix.custom.html","formatted_body":"<p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","mimetype":"text/plain"},{"body":"<p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","mimetype":"text/html"}]},"ts":1657510360595,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$wKA5V51ywfU2cmo_z2vN0WF7O7dcOeK8bojYgwPgqSM"},
{"content":{"body":" * One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","format":"org.matrix.custom.html","formatted_body":" * <p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","m.new_content":{"body":"One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","format":"org.matrix.custom.html","formatted_body":"<p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","mimetype":"text/plain"},{"body":"<p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$wKA5V51ywfU2cmo_z2vN0WF7O7dcOeK8bojYgwPgqSM","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","mimetype":"text/plain"},{"body":" * <p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","mimetype":"text/html"}]},"ts":1657510449983,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$GdciPjsnRXInkikIAqEj7TkBzLsQDlsUqnD7PS_fQXk"},
{"content":{"body":"The `id{}` syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:\n```js\nelement.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; \n```","format":"org.matrix.custom.html","formatted_body":"<p>The <code>id{}</code> syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:</p>\n<pre><code class=\"language-js\">element.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; \n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The `id{}` syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:\n```js\nelement.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; \n```","mimetype":"text/plain"},{"body":"<p>The <code>id{}</code> syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:</p>\n<pre><code class=\"language-js\">element.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; \n</code></pre>\n","mimetype":"text/html"}]},"ts":1657510645713,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$xDY1SDKY-8EVbGuovSks9SYfERu13XHX2ZP3icARERc"},
{"content":{"body":"`${}` doesn't \"have\" to block `id{}`, since `id {}` could still be legal, but it would be confusing to allow `x{}`, `x {}`, and `$ {}` but not `${}` because of its collision with `${}` in `match`.","format":"org.matrix.custom.html","formatted_body":"<code>${}</code> doesn't &quot;have&quot; to block <code>id{}</code>, since <code>id {}</code> could still be legal, but it would be confusing to allow <code>x{}</code>, <code>x {}</code>, and <code>$ {}</code> but not <code>${}</code> because of its collision with <code>${}</code> in <code>match</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`${}` doesn't \"have\" to block `id{}`, since `id {}` could still be legal, but it would be confusing to allow `x{}`, `x {}`, and `$ {}` but not `${}` because of its collision with `${}` in `match`.","mimetype":"text/plain"},{"body":"<code>${}</code> doesn't &quot;have&quot; to block <code>id{}</code>, since <code>id {}</code> could still be legal, but it would be confusing to allow <code>x{}</code>, <code>x {}</code>, and <code>$ {}</code> but not <code>${}</code> because of its collision with <code>${}</code> in <code>match</code>.","mimetype":"text/html"}]},"ts":1657511002757,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$Z0v8tDsScAzn21JSDKsbu_frX4YKUEGGrxFscD7AYs0"},
{"content":{"body":"rbuckton (PTO: 7/5 - 7/16): So for extractors, I'm still eh on the {} arglist part even separate from this `${}` conflict. Having a keyword-only constructor seems just as annoying as having the indexed-only constructors we have today. I'd rather pursue a keyword+ arglist syntax, a la Python's.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton (PTO: 7/5 - 7/16)</a>: So for extractors, I'm still eh on the {} arglist part even separate from this <code>${}</code> conflict. Having a keyword-only constructor seems just as annoying as having the indexed-only constructors we have today. I'd rather pursue a keyword+ arglist syntax, a la Python's.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"rbuckton (PTO: 7/5 - 7/16): So for extractors, I'm still eh on the {} arglist part even separate from this `${}` conflict. Having a keyword-only constructor seems just as annoying as having the indexed-only constructors we have today. I'd rather pursue a keyword+ arglist syntax, a la Python's.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton (PTO: 7/5 - 7/16)</a>: So for extractors, I'm still eh on the {} arglist part even separate from this <code>${}</code> conflict. Having a keyword-only constructor seems just as annoying as having the indexed-only constructors we have today. I'd rather pursue a keyword+ arglist syntax, a la Python's.","mimetype":"text/html"}]},"ts":1657551591148,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$W8R6spGpLPwnWXpLTaDqHH6o7O6k50jprM3pfaoM-7w"},
{"content":{"body":"But I do see the reason you have it existing - as a parallel to the `{}` destructuring pattern.","format":"org.matrix.custom.html","formatted_body":"But I do see the reason you have it existing - as a parallel to the <code>{}</code> destructuring pattern.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"But I do see the reason you have it existing - as a parallel to the `{}` destructuring pattern.","mimetype":"text/plain"},{"body":"But I do see the reason you have it existing - as a parallel to the <code>{}</code> destructuring pattern.","mimetype":"text/html"}]},"ts":1657551593774,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$awAmvhQy18IglDPvHtdHdRVFIFc44bQPn2gcrxXLIYk"},
{"content":{"body":"And your nested-extractors example is compelling for why going with something similar to match's `with` syntax isn't great.","format":"org.matrix.custom.html","formatted_body":"And your nested-extractors example is compelling for why going with something similar to match's <code>with</code> syntax isn't great.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"And your nested-extractors example is compelling for why going with something similar to match's `with` syntax isn't great.","mimetype":"text/plain"},{"body":"And your nested-extractors example is compelling for why going with something similar to match's <code>with</code> syntax isn't great.","mimetype":"text/html"}]},"ts":1657551731595,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$2iAWOtdtvzCy5tr3lzAO3qereZ7sQ_LA9yb0Mu5FNZ8"},
{"content":{"body":"I'm not clear on what you mean by \"keyword only constructor\"","msgtype":"m.text","org.matrix.msc1767.text":"I'm not clear on what you mean by \"keyword only constructor\""},"ts":1657551811094,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$txPR-2bucWu2gMJzNIkVx-G9E4dXCXHN5T9MDZBh04k"},
{"content":{"body":"`Move{x:1, y:1}` - listed as an enum constructor and possibly a normal-object constructor","format":"org.matrix.custom.html","formatted_body":"<code>Move{x:1, y:1}</code> - listed as an enum constructor and possibly a normal-object constructor","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`Move{x:1, y:1}` - listed as an enum constructor and possibly a normal-object constructor","mimetype":"text/plain"},{"body":"<code>Move{x:1, y:1}</code> - listed as an enum constructor and possibly a normal-object constructor","mimetype":"text/html"}]},"ts":1657552132474,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$D1H50fpBDReoetwZSfyGBTwJ_OgLZvjCLbkl_6CP_dM"},
{"content":{"body":"And hm, not *ideal*, but I suppose today's answer for keyword args - just pass an object - would work for extracting too. Just return a single-item array from unapply containing the object.","format":"org.matrix.custom.html","formatted_body":"And hm, not <em>ideal</em>, but I suppose today's answer for keyword args - just pass an object - would work for extracting too. Just return a single-item array from unapply containing the object.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"And hm, not *ideal*, but I suppose today's answer for keyword args - just pass an object - would work for extracting too. Just return a single-item array from unapply containing the object.","mimetype":"text/plain"},{"body":"And hm, not <em>ideal</em>, but I suppose today's answer for keyword args - just pass an object - would work for extracting too. Just return a single-item array from unapply containing the object.","mimetype":"text/html"}]},"ts":1657552352861,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$4zz3nvpr5-l1B3ZsZr_-oCBxAM-BHvYL1Fw-dzyGbSw"}
]