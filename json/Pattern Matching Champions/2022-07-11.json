[
{"content":{"body":"Yeah that feedback doesn't look unreasonable. I feel very safe ignoring \"overengineered\", since we're actually triangulating reasonably well on a minimal (but complete) feature set; that is indeed just people not realizing the use-cases we're trying to hit.","msgtype":"m.text","org.matrix.msc1767.text":"Yeah that feedback doesn't look unreasonable. I feel very safe ignoring \"overengineered\", since we're actually triangulating reasonably well on a minimal (but complete) feature set; that is indeed just people not realizing the use-cases we're trying to hit."},"ts":1657507249797,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$xi7EMNMRQxTLEmv4HhdT5I6i_EKoP3C64eqmS46anbE"},
{"content":{"body":"I'm still unhappy that `${x}` would likely block extractors in the future because of the `id{x}` conflict with `$` as a legal identifier. I'm hoping to present on extractors and the relation to pattern matching and ADT enums in a future TC39, but I'm in the middle of a cross-country move currently so I didn't have much time to prepare anything for next week's plenary. ","format":"org.matrix.custom.html","formatted_body":"I'm still unhappy that <code>${x}</code> would likely block extractors in the future because of the <code>id{x}</code> conflict with <code>$</code> as a legal identifier. I'm hoping to present on extractors and the relation to pattern matching and ADT enums in a future TC39, but I'm in the middle of a cross-country move currently so I didn't have much time to prepare anything for next week's plenary.","msgtype":"m.text"},"ts":1657509541218,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$0BHq_xaa0MBM5dv078P4NMa-RLDXBLZMGXsnCbOBMIo"},
{"content":{"body":"Do you have a link to extractors again? ","msgtype":"m.text","org.matrix.msc1767.text":"Do you have a link to extractors again? "},"ts":1657509819975,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$d8RBQfqlkAs1lg1NgoNULk7mPnAN7Xkkvhn2GDNsTro"},
{"content":{"body":"I was thinking about putting together an extractor proposal that just relied on `Symbol.matcher` rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses `with`:\n```js\nconst result = Option.Some{ value: 10 };\nconst Option.Some{ value } = result; // extractor is dual/inverse of constructor\n...\nmatch (result) {\n  when Option.Some{ value }: console.log(value); // also dual/inverse here\n  when Option.None: console.log(\"none\");\n}\n```\n\n","format":"org.matrix.custom.html","formatted_body":"<p>I was thinking about putting together an extractor proposal that just relied on <code>Symbol.matcher</code> rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses <code>with</code>:</p>\n<pre><code class=\"language-js\">const result = Option.Some{ value: 10 };\nconst Option.Some{ value } = result; // extractor is dual/inverse of constructor\n...\nmatch (result) {\n  when Option.Some{ value }: console.log(value); // also dual/inverse here\n  when Option.None: console.log(&quot;none&quot;);\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I was thinking about putting together an extractor proposal that just relied on `Symbol.matcher` rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses `with`:\n```js\nconst result = Option.Some{ value: 10 };\nconst Option.Some{ value } = result; // extractor is dual/inverse of constructor\n...\nmatch (result) {\n  when Option.Some{ value }: console.log(value); // also dual/inverse here\n  when Option.None: console.log(\"none\");\n}\n```\n\n","mimetype":"text/plain"},{"body":"<p>I was thinking about putting together an extractor proposal that just relied on <code>Symbol.matcher</code> rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses <code>with</code>:</p>\n<pre><code class=\"language-js\">const result = Option.Some{ value: 10 };\nconst Option.Some{ value } = result; // extractor is dual/inverse of constructor\n...\nmatch (result) {\n  when Option.Some{ value }: console.log(value); // also dual/inverse here\n  when Option.None: console.log(&quot;none&quot;);\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1657509884775,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$1PzYavvZjCLYROPesG5xREtSRilATE3X8zyfO6DFQes"},
{"content":{"body":"I haven't updated it in a bit, but the gist is here: https://gist.github.com/rbuckton/ae46b33f383ba69880c7138c49b5e799","msgtype":"m.text","org.matrix.msc1767.text":"I haven't updated it in a bit, but the gist is here: https://gist.github.com/rbuckton/ae46b33f383ba69880c7138c49b5e799"},"ts":1657509920731,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$yhvmTQ4shBXJ7bDFBnw2TAtQulZoDki53crx0XeQLyY"},
{"content":{"body":"One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","format":"org.matrix.custom.html","formatted_body":"<p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","mimetype":"text/plain"},{"body":"<p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","mimetype":"text/html"}]},"ts":1657510360595,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$wKA5V51ywfU2cmo_z2vN0WF7O7dcOeK8bojYgwPgqSM"},
{"content":{"body":" * One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","format":"org.matrix.custom.html","formatted_body":" * <p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","m.new_content":{"body":"One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","format":"org.matrix.custom.html","formatted_body":"<p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","mimetype":"text/plain"},{"body":"<p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$wKA5V51ywfU2cmo_z2vN0WF7O7dcOeK8bojYgwPgqSM","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:\n\n```js\nenum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n```\n\nWhere the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`","mimetype":"text/plain"},{"body":" * <p>One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:</p>\n<pre><code class=\"language-js\">enum Message of ADT {\n  Quit,\n  Move{ x, y },\n  Write(message)\n}\n\nconst msg = Message.Move{ x: 10, y: 10 };\nconst Message.Move{ x, y } = msg; // ok, declares x and y and initializes values\nconst Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)\n\nmatch (msg) {\n  when Message.Quit: process.exit();\n  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);\n  when Message.Write(message): console.log(message); \n}\n</code></pre>\n<p>Where the declaration <code>Move{ x, y }</code> matches construction <code>Message.Move{ x: 10, y: 10 }</code>, destructuring <code>const Message.Move{x, y} = ...</code>, and pattern matching: <code>when Message.Move{ x, y }: ...</code></p>\n","mimetype":"text/html"}]},"ts":1657510449983,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$GdciPjsnRXInkikIAqEj7TkBzLsQDlsUqnD7PS_fQXk"},
{"content":{"body":"The `id{}` syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:\n```js\nelement.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; \n```","format":"org.matrix.custom.html","formatted_body":"<p>The <code>id{}</code> syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:</p>\n<pre><code class=\"language-js\">element.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; \n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The `id{}` syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:\n```js\nelement.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; \n```","mimetype":"text/plain"},{"body":"<p>The <code>id{}</code> syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:</p>\n<pre><code class=\"language-js\">element.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; \n</code></pre>\n","mimetype":"text/html"}]},"ts":1657510645713,"senderName":"rbuckton (PTO: 7/5 - 7/16)","senderId":"@rbuckton:matrix.org","id":"$xDY1SDKY-8EVbGuovSks9SYfERu13XHX2ZP3icARERc"}
]