[
{"content":{"body":"Sorry, I clicked Yes on the invite but didn't actually ping the room - yeah, this morning is great.","m.mentions":{},"msgtype":"m.text"},"ts":1725637022656,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$h2eWxTW1ZnUWI2gZ3Oyz2rOzsCtBfAZHTE6ZAo4ifSY"},
{"content":{"body":"@room just in case anyone else is joining, meeting is starting now","m.mentions":{},"msgtype":"m.text"},"ts":1725638744699,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$s-gafpojImJQM95hyTCkaKgQTmKjl27DZXrnILTGefo"},
{"content":{"body":"@room just in case anyone else is joing, meeting is starting now","m.mentions":{"room":true},"msgtype":"m.text"},"ts":1725638760475,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$JON-KKBpxHrExtw_Rc--oDcU761AJHL2LfZRwVklcUQ"},
{"content":{"body":"meeting notes: https://github.com/tc39/proposal-pattern-matching/issues/332","m.mentions":{},"msgtype":"m.text"},"ts":1725641015901,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$KzuImNS8prtnWQ9p-huKVjKIJAlvw-SUx-p3mBUuNRE"},
{"content":{"body":"Regarding the contextual keyword issue, it's not that having both prefix and infix contextual keywords is impossible, but that they introduce complexity that must be managed, and that complexity could easily grow out of control. When new syntax would introduce an ambiguous parse, we must always choose an approach that favors backwards compatibility. \n\nGiven the example:\n```\nfor (using is of and [not/a+\"/g]; b++; [/\"/g, 5])\n```\n\nWe would have to break down the grammar to align with ECMAScript syntax roll-out:\n- `for..of` shipped before `using`\n- `using` will probably ship before `is`\n\nPrior to pattern matching, the above parse would treat `is` as an identifier and `and [not/a+\"/g]; b++; [/\"/g, 5]` as an expression. Therefore we would need to maintain that behavior. As waldemar points out, this is a complex issue that will resurface each time a proposal seeks to add a new feature. Unfortunately, I don't think just choosing `~=` is a solution to the overarching problem. There are a limited set of punctuators, and combining punctuators in more and more obscure ways will do little to convey their meaning, whereas contextual keywords give us a far wider space for future proposals to leverage. IMO, finding solutions to make it easier to address the prefix/infix complexity, such as automated validators, may be worth pursuing.","format":"org.matrix.custom.html","formatted_body":"<p>Regarding the contextual keyword issue, it's not that having both prefix and infix contextual keywords is impossible, but that they introduce complexity that must be managed, and that complexity could easily grow out of control. When new syntax would introduce an ambiguous parse, we must always choose an approach that favors backwards compatibility.</p>\n<p>Given the example:</p>\n<pre><code>for (using is of and [not/a+\"/g]; b++; [/\"/g, 5])\n</code></pre>\n<p>We would have to break down the grammar to align with ECMAScript syntax roll-out:</p>\n<ul>\n<li><code>for..of</code> shipped before <code>using</code></li>\n<li><code>using</code> will probably ship before <code>is</code></li>\n</ul>\n<p>Prior to pattern matching, the above parse would treat <code>is</code> as an identifier and <code>and [not/a+\"/g]; b++; [/\"/g, 5]</code> as an expression. Therefore we would need to maintain that behavior. As waldemar points out, this is a complex issue that will resurface each time a proposal seeks to add a new feature. Unfortunately, I don't think just choosing <code>~=</code> is a solution to the overarching problem. There are a limited set of punctuators, and combining punctuators in more and more obscure ways will do little to convey their meaning, whereas contextual keywords give us a far wider space for future proposals to leverage. IMO, finding solutions to make it easier to address the prefix/infix complexity, such as automated validators, may be worth pursuing.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1725642094253,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2_AAo1XNqKAOtrYzAqePRgBLz6IUd3i-HQ9PG0ZwtLQ"},
{"content":{"body":"I'm still giggling over the fact that `for(of of of)` is valid today.","format":"org.matrix.custom.html","formatted_body":"I'm still giggling over the fact that <code>for(of of of)</code> is valid today.","m.mentions":{},"msgtype":"m.text"},"ts":1725643585333,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$Il5oBHTSYnrGloK7CsH3dfxurv8QBT6inQeRaHh9Zm8"},
{"content":{"body":"```js\nvar of = [1,2,3];\nfor(of of of) console.log(of);\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">var of = [1,2,3];\nfor(of of of) console.log(of);\n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1725643603987,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$b2lirpChuDJOZAdcmP2G176BQtZQxyg9f96oQu5dxF8"},
{"content":{"body":"personally i think we won't be adding so many keywords of either type that the complexity is a problem","m.mentions":{},"msgtype":"m.text"},"ts":1725650391187,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$yNcOOnFsMcOyF_IoMRTy20GOAXjPiJye8dA-CXQgGuA"},
{"content":{"body":"The issue isn't convincing you, tho, it's convincing the committee.","m.mentions":{},"msgtype":"m.text"},"ts":1725651993986,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$rNmqIopUIrW1zezxe9I7Ljlt6qkqOCQM3o8Xi44LMyc"}
]