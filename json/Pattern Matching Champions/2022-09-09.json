[
{"content":{"body":"I just put up another gist of some explorations I've been doing into different ways to introduce pattern matching to JS: https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb its not exhaustive, but covers a lot of the topics from yulia | OOO until sept 26th's layering proposal. \n\nI didn't go into great detail on the `match` expression, because that's fairly well covered by the current proposal. This document explores several interesting themes, however:\n\n- Building pattern matching into destructuring (i.e., \"any assignment is a pattern\" like in Rust and Scala)\n- Borrowing `if-let` and `while-let` from Rust\n- Various mechanisms of gradually introducing pattern matching via `switch`\n- `function` overloading (similar to what Yulia has discussed)\n- `catch` guards\n- infix `is` expressions (i.e., `expr is pattern`)\n- `let` patterns\n\nNot all of the explored syntax alternatives are compatible with each other, though some are interrelated.\n\nFrom that exploration, I see two different paths:\n- Reuse destructuring for pattern matching (similar to Rust/Scala)\n- Treat pattern matching as something distinct from destructuring (similar to current proposal)\n\nIn general I'd favor choosing one path over trying to implement some amalgamation of both.","format":"org.matrix.custom.html","formatted_body":"<p>I just put up another gist of some explorations I've been doing into different ways to introduce pattern matching to JS: https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb its not exhaustive, but covers a lot of the topics from <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia | OOO until sept 26th</a>'s layering proposal.</p>\n<p>I didn't go into great detail on the <code>match</code> expression, because that's fairly well covered by the current proposal. This document explores several interesting themes, however:</p>\n<ul>\n<li>Building pattern matching into destructuring (i.e., &quot;any assignment is a pattern&quot; like in Rust and Scala)</li>\n<li>Borrowing <code>if-let</code> and <code>while-let</code> from Rust</li>\n<li>Various mechanisms of gradually introducing pattern matching via <code>switch</code></li>\n<li><code>function</code> overloading (similar to what Yulia has discussed)</li>\n<li><code>catch</code> guards</li>\n<li>infix <code>is</code> expressions (i.e., <code>expr is pattern</code>)</li>\n<li><code>let</code> patterns</li>\n</ul>\n<p>Not all of the explored syntax alternatives are compatible with each other, though some are interrelated.</p>\n<p>From that exploration, I see two different paths:</p>\n<ul>\n<li>Reuse destructuring for pattern matching (similar to Rust/Scala)</li>\n<li>Treat pattern matching as something distinct from destructuring (similar to current proposal)</li>\n</ul>\n<p>In general I'd favor choosing one path over trying to implement some amalgamation of both.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I just put up another gist of some explorations I've been doing into different ways to introduce pattern matching to JS: https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb its not exhaustive, but covers a lot of the topics from yulia | OOO until sept 26th's layering proposal. \n\nI didn't go into great detail on the `match` expression, because that's fairly well covered by the current proposal. This document explores several interesting themes, however:\n\n- Building pattern matching into destructuring (i.e., \"any assignment is a pattern\" like in Rust and Scala)\n- Borrowing `if-let` and `while-let` from Rust\n- Various mechanisms of gradually introducing pattern matching via `switch`\n- `function` overloading (similar to what Yulia has discussed)\n- `catch` guards\n- infix `is` expressions (i.e., `expr is pattern`)\n- `let` patterns\n\nNot all of the explored syntax alternatives are compatible with each other, though some are interrelated.\n\nFrom that exploration, I see two different paths:\n- Reuse destructuring for pattern matching (similar to Rust/Scala)\n- Treat pattern matching as something distinct from destructuring (similar to current proposal)\n\nIn general I'd favor choosing one path over trying to implement some amalgamation of both.","mimetype":"text/plain"},{"body":"<p>I just put up another gist of some explorations I've been doing into different ways to introduce pattern matching to JS: https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb its not exhaustive, but covers a lot of the topics from <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia | OOO until sept 26th</a>'s layering proposal.</p>\n<p>I didn't go into great detail on the <code>match</code> expression, because that's fairly well covered by the current proposal. This document explores several interesting themes, however:</p>\n<ul>\n<li>Building pattern matching into destructuring (i.e., &quot;any assignment is a pattern&quot; like in Rust and Scala)</li>\n<li>Borrowing <code>if-let</code> and <code>while-let</code> from Rust</li>\n<li>Various mechanisms of gradually introducing pattern matching via <code>switch</code></li>\n<li><code>function</code> overloading (similar to what Yulia has discussed)</li>\n<li><code>catch</code> guards</li>\n<li>infix <code>is</code> expressions (i.e., <code>expr is pattern</code>)</li>\n<li><code>let</code> patterns</li>\n</ul>\n<p>Not all of the explored syntax alternatives are compatible with each other, though some are interrelated.</p>\n<p>From that exploration, I see two different paths:</p>\n<ul>\n<li>Reuse destructuring for pattern matching (similar to Rust/Scala)</li>\n<li>Treat pattern matching as something distinct from destructuring (similar to current proposal)</li>\n</ul>\n<p>In general I'd favor choosing one path over trying to implement some amalgamation of both.</p>\n","mimetype":"text/html"}]},"ts":1662752032786,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Q5nFK3xt_kbfq6aaI79AG2krq7hBIrsQN3IMrDgOLZo"},
{"content":{"body":"While I generally favor the \"keep it distinct\" path, there are some interesting features of the \"reuse destructuring\" path that are compelling.","msgtype":"m.text","org.matrix.msc1767.text":"While I generally favor the \"keep it distinct\" path, there are some interesting features of the \"reuse destructuring\" path that are compelling."},"ts":1662752077752,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yxpZP2afgLL1v0otOnod9VPABXKdVfAvPPy0VOZsdZw"}
]