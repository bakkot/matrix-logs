[
{"content":{"body":"I just put up another gist of some explorations I've been doing into different ways to introduce pattern matching to JS: https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb its not exhaustive, but covers a lot of the topics from yulia | OOO until sept 26th's layering proposal. \n\nI didn't go into great detail on the `match` expression, because that's fairly well covered by the current proposal. This document explores several interesting themes, however:\n\n- Building pattern matching into destructuring (i.e., \"any assignment is a pattern\" like in Rust and Scala)\n- Borrowing `if-let` and `while-let` from Rust\n- Various mechanisms of gradually introducing pattern matching via `switch`\n- `function` overloading (similar to what Yulia has discussed)\n- `catch` guards\n- infix `is` expressions (i.e., `expr is pattern`)\n- `let` patterns\n\nNot all of the explored syntax alternatives are compatible with each other, though some are interrelated.\n\nFrom that exploration, I see two different paths:\n- Reuse destructuring for pattern matching (similar to Rust/Scala)\n- Treat pattern matching as something distinct from destructuring (similar to current proposal)\n\nIn general I'd favor choosing one path over trying to implement some amalgamation of both.","format":"org.matrix.custom.html","formatted_body":"<p>I just put up another gist of some explorations I've been doing into different ways to introduce pattern matching to JS: https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb its not exhaustive, but covers a lot of the topics from <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia | OOO until sept 26th</a>'s layering proposal.</p>\n<p>I didn't go into great detail on the <code>match</code> expression, because that's fairly well covered by the current proposal. This document explores several interesting themes, however:</p>\n<ul>\n<li>Building pattern matching into destructuring (i.e., &quot;any assignment is a pattern&quot; like in Rust and Scala)</li>\n<li>Borrowing <code>if-let</code> and <code>while-let</code> from Rust</li>\n<li>Various mechanisms of gradually introducing pattern matching via <code>switch</code></li>\n<li><code>function</code> overloading (similar to what Yulia has discussed)</li>\n<li><code>catch</code> guards</li>\n<li>infix <code>is</code> expressions (i.e., <code>expr is pattern</code>)</li>\n<li><code>let</code> patterns</li>\n</ul>\n<p>Not all of the explored syntax alternatives are compatible with each other, though some are interrelated.</p>\n<p>From that exploration, I see two different paths:</p>\n<ul>\n<li>Reuse destructuring for pattern matching (similar to Rust/Scala)</li>\n<li>Treat pattern matching as something distinct from destructuring (similar to current proposal)</li>\n</ul>\n<p>In general I'd favor choosing one path over trying to implement some amalgamation of both.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I just put up another gist of some explorations I've been doing into different ways to introduce pattern matching to JS: https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb its not exhaustive, but covers a lot of the topics from yulia | OOO until sept 26th's layering proposal. \n\nI didn't go into great detail on the `match` expression, because that's fairly well covered by the current proposal. This document explores several interesting themes, however:\n\n- Building pattern matching into destructuring (i.e., \"any assignment is a pattern\" like in Rust and Scala)\n- Borrowing `if-let` and `while-let` from Rust\n- Various mechanisms of gradually introducing pattern matching via `switch`\n- `function` overloading (similar to what Yulia has discussed)\n- `catch` guards\n- infix `is` expressions (i.e., `expr is pattern`)\n- `let` patterns\n\nNot all of the explored syntax alternatives are compatible with each other, though some are interrelated.\n\nFrom that exploration, I see two different paths:\n- Reuse destructuring for pattern matching (similar to Rust/Scala)\n- Treat pattern matching as something distinct from destructuring (similar to current proposal)\n\nIn general I'd favor choosing one path over trying to implement some amalgamation of both.","mimetype":"text/plain"},{"body":"<p>I just put up another gist of some explorations I've been doing into different ways to introduce pattern matching to JS: https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb its not exhaustive, but covers a lot of the topics from <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia | OOO until sept 26th</a>'s layering proposal.</p>\n<p>I didn't go into great detail on the <code>match</code> expression, because that's fairly well covered by the current proposal. This document explores several interesting themes, however:</p>\n<ul>\n<li>Building pattern matching into destructuring (i.e., &quot;any assignment is a pattern&quot; like in Rust and Scala)</li>\n<li>Borrowing <code>if-let</code> and <code>while-let</code> from Rust</li>\n<li>Various mechanisms of gradually introducing pattern matching via <code>switch</code></li>\n<li><code>function</code> overloading (similar to what Yulia has discussed)</li>\n<li><code>catch</code> guards</li>\n<li>infix <code>is</code> expressions (i.e., <code>expr is pattern</code>)</li>\n<li><code>let</code> patterns</li>\n</ul>\n<p>Not all of the explored syntax alternatives are compatible with each other, though some are interrelated.</p>\n<p>From that exploration, I see two different paths:</p>\n<ul>\n<li>Reuse destructuring for pattern matching (similar to Rust/Scala)</li>\n<li>Treat pattern matching as something distinct from destructuring (similar to current proposal)</li>\n</ul>\n<p>In general I'd favor choosing one path over trying to implement some amalgamation of both.</p>\n","mimetype":"text/html"}]},"ts":1662752032786,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Q5nFK3xt_kbfq6aaI79AG2krq7hBIrsQN3IMrDgOLZo"},
{"content":{"body":"While I generally favor the \"keep it distinct\" path, there are some interesting features of the \"reuse destructuring\" path that are compelling.","msgtype":"m.text","org.matrix.msc1767.text":"While I generally favor the \"keep it distinct\" path, there are some interesting features of the \"reuse destructuring\" path that are compelling."},"ts":1662752077752,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yxpZP2afgLL1v0otOnod9VPABXKdVfAvPPy0VOZsdZw"},
{"content":{"body":"The downside of reusing destructuring is that such patterns would not have strict property or element checks by default (i.e., `const { x, y } = { x: 0, y: 1, z: 2 };` needs to continue to work), as well as that you need mechanisms for distinguishing from introducing a binding vs referencing an identifier (i.e., `const { x: Infinity } = { x: 0 }` is already legal). But the upside is that we could have a single unified pattern syntax that we could easily shoehorn into `catch` guards and `function` overloads if we so wished.","format":"org.matrix.custom.html","formatted_body":"The downside of reusing destructuring is that such patterns would not have strict property or element checks by default (i.e., <code>const { x, y } = { x: 0, y: 1, z: 2 };</code> needs to continue to work), as well as that you need mechanisms for distinguishing from introducing a binding vs referencing an identifier (i.e., <code>const { x: Infinity } = { x: 0 }</code> is already legal). But the upside is that we could have a single unified pattern syntax that we could easily shoehorn into <code>catch</code> guards and <code>function</code> overloads if we so wished.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The downside of reusing destructuring is that such patterns would not have strict property or element checks by default (i.e., `const { x, y } = { x: 0, y: 1, z: 2 };` needs to continue to work), as well as that you need mechanisms for distinguishing from introducing a binding vs referencing an identifier (i.e., `const { x: Infinity } = { x: 0 }` is already legal). But the upside is that we could have a single unified pattern syntax that we could easily shoehorn into `catch` guards and `function` overloads if we so wished.","mimetype":"text/plain"},{"body":"The downside of reusing destructuring is that such patterns would not have strict property or element checks by default (i.e., <code>const { x, y } = { x: 0, y: 1, z: 2 };</code> needs to continue to work), as well as that you need mechanisms for distinguishing from introducing a binding vs referencing an identifier (i.e., <code>const { x: Infinity } = { x: 0 }</code> is already legal). But the upside is that we could have a single unified pattern syntax that we could easily shoehorn into <code>catch</code> guards and <code>function</code> overloads if we so wished.","mimetype":"text/html"}]},"ts":1662752221709,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vbQfneXq74z9J7hfgvX5oO2x6VGNQ_oHp-et190G5eU"},
{"content":{"body":"Some examples of the \"reuse destructuring\" approach:\n\n```js\nlet { x: 0, y } = obj; // match obj.x to 0, bind y to obj.y, loose property matching\nlet {| x: 0, y |} = obj; // match obj.x to 0, match obj.y to anything, no extra properties, bind y to obj.y\nlet { x: x@0, y } = obj; // rust-style `@` binding. match obj.x to 0, bind x to obj.x, bind y to obj.y\n\nif (let Option.Some(value) = opt) ...; // `if-let` + extractors\nwhile (let Option.Some(message) = getNext()) ...; // `while-let` + extractors\n \nif (let x = foo(); x.bar) ...; // `if-let` plus C++ 17's `if-with-initializer` syntax\nwhile (let x = foo(); x.bar) ...; // `while-let` plus C++ 17's `if-with-initializer` syntax\n\ntry { ... }\ncatch (e@FileNotFoundError) { ... } // rust-style `@` and custom matcher\ncatch (@TypeError) { ... } // `@` without binding and custom matcher. Needed to distinguish from id\ncatch (HttpError{ statusCode: 404 }) { ... } // no need for `@` due to extractor syntax\ncatch (Error{ cause: e@ReferenceError }) { ... } // `@` binding and extractors\n```\n\nIt's very compelling, but requires workarounds like `@` to be backwards compatible, making it easy to make mistakes (like `{ x: NaN }`).","format":"org.matrix.custom.html","formatted_body":"<p>Some examples of the &quot;reuse destructuring&quot; approach:</p>\n<pre><code class=\"language-js\">let { x: 0, y } = obj; // match obj.x to 0, bind y to obj.y, loose property matching\nlet {| x: 0, y |} = obj; // match obj.x to 0, match obj.y to anything, no extra properties, bind y to obj.y\nlet { x: x@0, y } = obj; // rust-style `@` binding. match obj.x to 0, bind x to obj.x, bind y to obj.y\n\nif (let Option.Some(value) = opt) ...; // `if-let` + extractors\nwhile (let Option.Some(message) = getNext()) ...; // `while-let` + extractors\n \nif (let x = foo(); x.bar) ...; // `if-let` plus C++ 17's `if-with-initializer` syntax\nwhile (let x = foo(); x.bar) ...; // `while-let` plus C++ 17's `if-with-initializer` syntax\n\ntry { ... }\ncatch (e@FileNotFoundError) { ... } // rust-style `@` and custom matcher\ncatch (@TypeError) { ... } // `@` without binding and custom matcher. Needed to distinguish from id\ncatch (HttpError{ statusCode: 404 }) { ... } // no need for `@` due to extractor syntax\ncatch (Error{ cause: e@ReferenceError }) { ... } // `@` binding and extractors\n</code></pre>\n<p>It's very compelling, but requires workarounds like <code>@</code> to be backwards compatible, making it easy to make mistakes (like <code>{ x: NaN }</code>).</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Some examples of the \"reuse destructuring\" approach:\n\n```js\nlet { x: 0, y } = obj; // match obj.x to 0, bind y to obj.y, loose property matching\nlet {| x: 0, y |} = obj; // match obj.x to 0, match obj.y to anything, no extra properties, bind y to obj.y\nlet { x: x@0, y } = obj; // rust-style `@` binding. match obj.x to 0, bind x to obj.x, bind y to obj.y\n\nif (let Option.Some(value) = opt) ...; // `if-let` + extractors\nwhile (let Option.Some(message) = getNext()) ...; // `while-let` + extractors\n \nif (let x = foo(); x.bar) ...; // `if-let` plus C++ 17's `if-with-initializer` syntax\nwhile (let x = foo(); x.bar) ...; // `while-let` plus C++ 17's `if-with-initializer` syntax\n\ntry { ... }\ncatch (e@FileNotFoundError) { ... } // rust-style `@` and custom matcher\ncatch (@TypeError) { ... } // `@` without binding and custom matcher. Needed to distinguish from id\ncatch (HttpError{ statusCode: 404 }) { ... } // no need for `@` due to extractor syntax\ncatch (Error{ cause: e@ReferenceError }) { ... } // `@` binding and extractors\n```\n\nIt's very compelling, but requires workarounds like `@` to be backwards compatible, making it easy to make mistakes (like `{ x: NaN }`).","mimetype":"text/plain"},{"body":"<p>Some examples of the &quot;reuse destructuring&quot; approach:</p>\n<pre><code class=\"language-js\">let { x: 0, y } = obj; // match obj.x to 0, bind y to obj.y, loose property matching\nlet {| x: 0, y |} = obj; // match obj.x to 0, match obj.y to anything, no extra properties, bind y to obj.y\nlet { x: x@0, y } = obj; // rust-style `@` binding. match obj.x to 0, bind x to obj.x, bind y to obj.y\n\nif (let Option.Some(value) = opt) ...; // `if-let` + extractors\nwhile (let Option.Some(message) = getNext()) ...; // `while-let` + extractors\n \nif (let x = foo(); x.bar) ...; // `if-let` plus C++ 17's `if-with-initializer` syntax\nwhile (let x = foo(); x.bar) ...; // `while-let` plus C++ 17's `if-with-initializer` syntax\n\ntry { ... }\ncatch (e@FileNotFoundError) { ... } // rust-style `@` and custom matcher\ncatch (@TypeError) { ... } // `@` without binding and custom matcher. Needed to distinguish from id\ncatch (HttpError{ statusCode: 404 }) { ... } // no need for `@` due to extractor syntax\ncatch (Error{ cause: e@ReferenceError }) { ... } // `@` binding and extractors\n</code></pre>\n<p>It's very compelling, but requires workarounds like <code>@</code> to be backwards compatible, making it easy to make mistakes (like <code>{ x: NaN }</code>).</p>\n","mimetype":"text/html"}]},"ts":1662752930139,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HXMyc8xF5HHFQd99biJl5k7F_8Bt07Hn816JkFEGGTw"},
{"content":{"body":"Another thing I explored is the possibility of gradually introducing pattern matching to existing syntax so as not to require complete refactors. this included ways to gradually introduce pattern matching to `switch` without requiring a complete refactor to `match` (though ljharb seems opposed to this). The \"keep pattern matching distinct\" version of this looks like:\n\n```js\n// adds a `case?` clause to a normal `switch` that performs pattern matching\nswitch (expr) {\n  case 0: ...; // normal case\n  case? { x: 1 }: ...; // pattern matching case (block scoped, no fall-through in or out)\n}\n```\n\nWhile the \"reuse destructuring\" version looks like the following, instead:\n```js\n// adds a `case let` clause (to match `if-let`, `while-let`):\nswitch (expr) {\n  case 0: ...; // normal case\n  case let { x: 1 }: ...; // pattern matching case (block scoped, no fall-through in or out)\n}\n```\n\nThis would *not* change the semantics of `switch` (i.e., `switch` can still be non-exhaustive, normal cases can still have fall-through, etc.).","format":"org.matrix.custom.html","formatted_body":"<p>Another thing I explored is the possibility of gradually introducing pattern matching to existing syntax so as not to require complete refactors. this included ways to gradually introduce pattern matching to <code>switch</code> without requiring a complete refactor to <code>match</code> (though <a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a> seems opposed to this). The &quot;keep pattern matching distinct&quot; version of this looks like:</p>\n<pre><code class=\"language-js\">// adds a `case?` clause to a normal `switch` that performs pattern matching\nswitch (expr) {\n  case 0: ...; // normal case\n  case? { x: 1 }: ...; // pattern matching case (block scoped, no fall-through in or out)\n}\n</code></pre>\n<p>While the &quot;reuse destructuring&quot; version looks like the following, instead:</p>\n<pre><code class=\"language-js\">// adds a `case let` clause (to match `if-let`, `while-let`):\nswitch (expr) {\n  case 0: ...; // normal case\n  case let { x: 1 }: ...; // pattern matching case (block scoped, no fall-through in or out)\n}\n</code></pre>\n<p>This would <em>not</em> change the semantics of <code>switch</code> (i.e., <code>switch</code> can still be non-exhaustive, normal cases can still have fall-through, etc.).</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Another thing I explored is the possibility of gradually introducing pattern matching to existing syntax so as not to require complete refactors. this included ways to gradually introduce pattern matching to `switch` without requiring a complete refactor to `match` (though ljharb seems opposed to this). The \"keep pattern matching distinct\" version of this looks like:\n\n```js\n// adds a `case?` clause to a normal `switch` that performs pattern matching\nswitch (expr) {\n  case 0: ...; // normal case\n  case? { x: 1 }: ...; // pattern matching case (block scoped, no fall-through in or out)\n}\n```\n\nWhile the \"reuse destructuring\" version looks like the following, instead:\n```js\n// adds a `case let` clause (to match `if-let`, `while-let`):\nswitch (expr) {\n  case 0: ...; // normal case\n  case let { x: 1 }: ...; // pattern matching case (block scoped, no fall-through in or out)\n}\n```\n\nThis would *not* change the semantics of `switch` (i.e., `switch` can still be non-exhaustive, normal cases can still have fall-through, etc.).","mimetype":"text/plain"},{"body":"<p>Another thing I explored is the possibility of gradually introducing pattern matching to existing syntax so as not to require complete refactors. this included ways to gradually introduce pattern matching to <code>switch</code> without requiring a complete refactor to <code>match</code> (though <a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a> seems opposed to this). The &quot;keep pattern matching distinct&quot; version of this looks like:</p>\n<pre><code class=\"language-js\">// adds a `case?` clause to a normal `switch` that performs pattern matching\nswitch (expr) {\n  case 0: ...; // normal case\n  case? { x: 1 }: ...; // pattern matching case (block scoped, no fall-through in or out)\n}\n</code></pre>\n<p>While the &quot;reuse destructuring&quot; version looks like the following, instead:</p>\n<pre><code class=\"language-js\">// adds a `case let` clause (to match `if-let`, `while-let`):\nswitch (expr) {\n  case 0: ...; // normal case\n  case let { x: 1 }: ...; // pattern matching case (block scoped, no fall-through in or out)\n}\n</code></pre>\n<p>This would <em>not</em> change the semantics of <code>switch</code> (i.e., <code>switch</code> can still be non-exhaustive, normal cases can still have fall-through, etc.).</p>\n","mimetype":"text/html"}]},"ts":1662753422438,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$6LVmgwxHafX69uy4Cb_SICdPIjTu2Ssnd0PKhn24yPY"},
{"content":{"body":"(there *is* a potential parser ambiguity with `case let[x]` in non-strict mode, however)","format":"org.matrix.custom.html","formatted_body":"(there <em>is</em> a potential parser ambiguity with <code>case let[x]</code> in non-strict mode, however)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"(there *is* a potential parser ambiguity with `case let[x]` in non-strict mode, however)","mimetype":"text/plain"},{"body":"(there <em>is</em> a potential parser ambiguity with <code>case let[x]</code> in non-strict mode, however)","mimetype":"text/html"}]},"ts":1662753493761,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mGtv4WwQJtpWIberGVD2liKliXeM419ZXHnKT_I7p9I"},
{"content":{"body":"While I agree with and appreciate a lot of the other stuff you're talking about, I'm still strongly with Jordan on the \"switch is entirely unredeemable and we should barely mention it except as a warning of how not to design such a feature\". ^_^","msgtype":"m.text","org.matrix.msc1767.text":"While I agree with and appreciate a lot of the other stuff you're talking about, I'm still strongly with Jordan on the \"switch is entirely unredeemable and we should barely mention it except as a warning of how not to design such a feature\". ^_^"},"ts":1662762479890,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$fgGdd8KbiOzvRpYk2ouirGiMWObptRhjDJJ2TqjPJlQ"},
{"content":{"body":"\"Reusing destructuring\" is similarly a no-go for precisely the reason you gave. If something as basic as an object pattern *doesn't actually test for the existence of the specified properties*, then that's not pattern-matching and isn't fit for purpose.","format":"org.matrix.custom.html","formatted_body":"&quot;Reusing destructuring&quot; is similarly a no-go for precisely the reason you gave. If something as basic as an object pattern <em>doesn't actually test for the existence of the specified properties</em>, then that's not pattern-matching and isn't fit for purpose.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"\"Reusing destructuring\" is similarly a no-go for precisely the reason you gave. If something as basic as an object pattern *doesn't actually test for the existence of the specified properties*, then that's not pattern-matching and isn't fit for purpose.","mimetype":"text/plain"},{"body":"&quot;Reusing destructuring&quot; is similarly a no-go for precisely the reason you gave. If something as basic as an object pattern <em>doesn't actually test for the existence of the specified properties</em>, then that's not pattern-matching and isn't fit for purpose.","mimetype":"text/html"}]},"ts":1662762840623,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$pvJFEzT95aXTQa4mXSthRU49ijvRAuvSlJEt-xKk-7o"},
{"content":{"body":"Reading thru your gist, I think the complexities with the \"extend destructuring\" really are quite bad. It sticks us with the current \"{x: y} means binding to y\" behavior, and gives us the weird/bad \"{x: Infinity} just binds to Infinity, doesn't test against Infinity\" stuff unless you remember to write it out, while `{x: 0}` properly tests by default. We really need an explicit flag to indicate we're in pattern syntax, not destructuring syntax, like the `match` keyword from Yulia's docs.","format":"org.matrix.custom.html","formatted_body":"Reading thru your gist, I think the complexities with the &quot;extend destructuring&quot; really are quite bad. It sticks us with the current &quot;{x: y} means binding to y&quot; behavior, and gives us the weird/bad &quot;{x: Infinity} just binds to Infinity, doesn't test against Infinity&quot; stuff unless you remember to write it out, while <code>{x: 0}</code> properly tests by default. We really need an explicit flag to indicate we're in pattern syntax, not destructuring syntax, like the <code>match</code> keyword from Yulia's docs.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Reading thru your gist, I think the complexities with the \"extend destructuring\" really are quite bad. It sticks us with the current \"{x: y} means binding to y\" behavior, and gives us the weird/bad \"{x: Infinity} just binds to Infinity, doesn't test against Infinity\" stuff unless you remember to write it out, while `{x: 0}` properly tests by default. We really need an explicit flag to indicate we're in pattern syntax, not destructuring syntax, like the `match` keyword from Yulia's docs.","mimetype":"text/plain"},{"body":"Reading thru your gist, I think the complexities with the &quot;extend destructuring&quot; really are quite bad. It sticks us with the current &quot;{x: y} means binding to y&quot; behavior, and gives us the weird/bad &quot;{x: Infinity} just binds to Infinity, doesn't test against Infinity&quot; stuff unless you remember to write it out, while <code>{x: 0}</code> properly tests by default. We really need an explicit flag to indicate we're in pattern syntax, not destructuring syntax, like the <code>match</code> keyword from Yulia's docs.","mimetype":"text/html"}]},"ts":1662764763285,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$Ve_5RbNfE9-VtP_vwTFUAAFDPyWHQI_xcJ5mwyZ62SM"},
{"content":{"body":"Oh gosh and \"reuse destructuring\" means that `{x:Infinity}` gets us the no-op binding (technically binds to `Infinity`, but that doesn't actually accomplish anything), but `{x:-Infinity}` gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","format":"org.matrix.custom.html","formatted_body":"Oh gosh and &quot;reuse destructuring&quot; means that <code>{x:Infinity}</code> gets us the no-op binding (technically binds to <code>Infinity</code>, but that doesn't actually accomplish anything), but <code>{x:-Infinity}</code> gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Oh gosh and \"reuse destructuring\" means that `{x:Infinity}` gets us the no-op binding (technically binds to `Infinity`, but that doesn't actually accomplish anything), but `{x:-Infinity}` gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","mimetype":"text/plain"},{"body":"Oh gosh and &quot;reuse destructuring&quot; means that <code>{x:Infinity}</code> gets us the no-op binding (technically binds to <code>Infinity</code>, but that doesn't actually accomplish anything), but <code>{x:-Infinity}</code> gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","mimetype":"text/html"}]},"ts":1662765219186,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$oyZqXHs2Pq082QqWXUB4o_Ah-U5gMZTJHOFmxqA0sE8"},
{"content":{"body":" * Oh gosh and \"reuse destructuring\" means that `{x:Infinity}` gets us the no-op binding (technically binds to `Infinity`, but that doesn't actually accomplish anything), but `{x:-Infinity}` gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","format":"org.matrix.custom.html","formatted_body":" * Oh gosh and &quot;reuse destructuring&quot; means that <code>{x:Infinity}</code> gets us the no-op binding (technically binds to <code>Infinity</code>, but that doesn't actually accomplish anything), but <code>{x:-Infinity}</code> gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","m.new_content":{"body":"Oh gosh and \"reuse destructuring\" means that `{x:Infinity}` gets us the no-op binding (technically binds to `Infinity`, but that doesn't actually accomplish anything), but `{x:-Infinity}` gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","format":"org.matrix.custom.html","formatted_body":"Oh gosh and &quot;reuse destructuring&quot; means that <code>{x:Infinity}</code> gets us the no-op binding (technically binds to <code>Infinity</code>, but that doesn't actually accomplish anything), but <code>{x:-Infinity}</code> gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Oh gosh and \"reuse destructuring\" means that `{x:Infinity}` gets us the no-op binding (technically binds to `Infinity`, but that doesn't actually accomplish anything), but `{x:-Infinity}` gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","mimetype":"text/plain"},{"body":"Oh gosh and &quot;reuse destructuring&quot; means that <code>{x:Infinity}</code> gets us the no-op binding (technically binds to <code>Infinity</code>, but that doesn't actually accomplish anything), but <code>{x:-Infinity}</code> gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$oyZqXHs2Pq082QqWXUB4o_Ah-U5gMZTJHOFmxqA0sE8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Oh gosh and \"reuse destructuring\" means that `{x:Infinity}` gets us the no-op binding (technically binds to `Infinity`, but that doesn't actually accomplish anything), but `{x:-Infinity}` gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","mimetype":"text/plain"},{"body":" * Oh gosh and &quot;reuse destructuring&quot; means that <code>{x:Infinity}</code> gets us the no-op binding (technically binds to <code>Infinity</code>, but that doesn't actually accomplish anything), but <code>{x:-Infinity}</code> gets us a value test (since it's an invalid destructuring pattern). Yeah this is just completely and totally a no-go.","mimetype":"text/html"}]},"ts":1662765250835,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$lO5mOiQLgltKigOGJxaiwCZVuxrjeghvVoKyidiSf1k"}
]