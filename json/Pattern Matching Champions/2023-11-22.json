[
{"content":{"body":"yes, match against arr[0] is a legit use case","msgtype":"m.text"},"ts":1700612343485,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$hoOJCThAwdf1MtQPWRMPaWFPJ2tJnGkFk8qcO3Y-m-Y"},
{"content":{"body":"> <@rbuckton:matrix.org> `is` is not a MemberExpression, so `x is a and {}.toString` would just be a syntax error\n\nok...? I do not quite understand how this works, can you explain more? now it is a relational expression, that already makes x is {}. toString illegal?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$O9Q23kbpDXZ1vPZFPnrdE044R-m5mhe-YyTmB1FtgHA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br /><code>is</code> is not a MemberExpression, so <code>x is a and {}.toString</code> would just be a syntax error</blockquote></mx-reply>ok...? I do not quite understand how this works, can you explain more? now it is a relational expression, that already makes x is {}. toString illegal?","m.relates_to":{"m.in_reply_to":{"event_id":"$O9Q23kbpDXZ1vPZFPnrdE044R-m5mhe-YyTmB1FtgHA"}},"msgtype":"m.text"},"ts":1700612432524,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$EQvaPYQ9udxjJvn2gheOmioxQrORh02ZoHQCDgMdQ4g"},
{"content":{"body":"Yes, if `is` is in RelationalExpression, then `is {}.anything` is illegal","format":"org.matrix.custom.html","formatted_body":"Yes, if <code>is</code> is in RelationalExpression, then <code>is {}.anything</code> is illegal","msgtype":"m.text"},"ts":1700613190904,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RSZzvEd9nx4HgoKDuhgiFT38kixecf7Uvt8Z0eSCNO4"},
{"content":{"body":"`a in b.c` is legal because the right-hand side of `in` allows MemberExpression. ","format":"org.matrix.custom.html","formatted_body":"<code>a in b.c</code> is legal because the right-hand side of <code>in</code> allows MemberExpression.","msgtype":"m.text"},"ts":1700613233924,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$iMzLkvqDqf92ybjKBuq8tH7p9N618CpAcLJok9RxsNo"},
{"content":{"body":"`a is pattern` doesn't parse a MemberExpression on the right, it parses a MatchPattern, so it only allows a\t`.` if it is specified in syntax","format":"org.matrix.custom.html","formatted_body":"<code>a is pattern</code> doesn't parse a MemberExpression on the right, it parses a MatchPattern, so it only allows a\t<code>.</code> if it is specified in syntax","msgtype":"m.text"},"ts":1700613314861,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5yGot4viaD1OUex11Wp-H81wf54SHn3Kxj5wetf86Ng"},
{"content":{"body":"ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”","msgtype":"m.text"},"ts":1700613411770,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$xSEtYT2Frt83VDsMWcyy_mc4F-NSPC4fv8pgE3sYOFQ"},
{"content":{"body":"We allow `a is b.c` because you've explicitly specified PatternMatchingMemberExpression: https://raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html#prod-PatternMatchingMemberExpression","format":"org.matrix.custom.html","formatted_body":"We allow <code>a is b.c</code> because you've explicitly specified PatternMatchingMemberExpression: https://raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html#prod-PatternMatchingMemberExpression","m.mentions":{},"msgtype":"m.text"},"ts":1700613451603,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9_QOQHOj69eLExw8VfqgFQD3Q0rxMBanDQ1vzGdKEh8"},
{"content":{"body":"that's interesting, what is legal to follow a relational expression directly?","msgtype":"m.text"},"ts":1700613459879,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$U_anfAsVizWDizgaoBj0fkHcFhungU7V6fXzy2c9FjA"},
{"content":{"body":"I want to make sure nothing is visually confusing","msgtype":"m.text"},"ts":1700613506672,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$0wtRGQo_mBfL_xec0qwSP1EdKkRfbKW2a3T5BGBqc2Q"},
{"content":{"body":"there are two ways to think about \"to the right\":\n1. When parsing a _RelationalExpression_, what can be parsed for any given production on the right of a relational operator. For example, in `` RelationalExpression `<` ShiftExpression ``, what kind of things can be parsed if you only look at _ShiftExpression_.\n2. When parsing productions top-down, if a production contains a _RelationalExpression_, what kind of things can you parse after the RelationalExpression itself is finished.\n\nFor (1), given `A < B`, `B` can be anything that can be parsed in a _ShiftExpression_:\n- ShiftExpression: `<<`, `>>`, `>>>` (i.e., `A < B << C` is parsed as `A < (B << C)`)\n- AdditiveExpression: `+`, `-` (i.e., `A < B + C` is parsed as `A < (B + C)`)\n- MultiplicativeExpression: `*`, `/`, `%` (i.e., `A < B * C` is parsed as `A < (B * C)`)\n- UpdateExpression: postfix `++`, `--`\n- LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: `?.`, `[`, `.`, `` ` ``\n\nFor (2), you look at anything that can _contain_ a RelationalExpression on the left of some other terminal/nonterminal:\n- RelationalExpression: `<`, `<=`, `>`, `>=`, `instanceof`, `in` (i.e., in `A < B`, `A` can be a RelationalExpression, so it can be followed by `<`, etc.)\n- EqualityExpression: `==`, `===`, `!=`, `!==`\n- BitwiseANDExpression: `&`\n- BitwiseXORExpression: `^`\n- BitwiseORExpression: `|`\n- LogicalANDExpression: `&&`\n- LogicalORExpression: `||`\n- CoalesceExpression: `??`\n- ConditionalExpression: `?`, `:`\n- AssignmentExpression: `=`, `+=`, `-=`, etc.\n\n","format":"org.matrix.custom.html","formatted_body":"<p>there are two ways to think about \"to the right\":</p>\n<ol>\n<li>When parsing a <em>RelationalExpression</em>, what can be parsed for any given production on the right of a relational operator. For example, in <code>RelationalExpression `&lt;` ShiftExpression</code>, what kind of things can be parsed if you only look at <em>ShiftExpression</em>.</li>\n<li>When parsing productions top-down, if a production contains a <em>RelationalExpression</em>, what kind of things can you parse after the RelationalExpression itself is finished.</li>\n</ol>\n<p>For (1), given <code>A &lt; B</code>, <code>B</code> can be anything that can be parsed in a <em>ShiftExpression</em>:</p>\n<ul>\n<li>ShiftExpression: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> (i.e., <code>A &lt; B &lt;&lt; C</code> is parsed as <code>A &lt; (B &lt;&lt; C)</code>)</li>\n<li>AdditiveExpression: <code>+</code>, <code>-</code> (i.e., <code>A &lt; B + C</code> is parsed as <code>A &lt; (B + C)</code>)</li>\n<li>MultiplicativeExpression: <code>*</code>, <code>/</code>, <code>%</code> (i.e., <code>A &lt; B * C</code> is parsed as <code>A &lt; (B * C)</code>)</li>\n<li>UpdateExpression: postfix <code>++</code>, <code>--</code></li>\n<li>LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: <code>?.</code>, <code>[</code>, <code>.</code>, <code>`</code></li>\n</ul>\n<p>For (2), you look at anything that can <em>contain</em> a RelationalExpression on the left of some other terminal/nonterminal:</p>\n<ul>\n<li>RelationalExpression: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>instanceof</code>, <code>in</code> (i.e., in <code>A &lt; B</code>, <code>A</code> can be a RelationalExpression, so it can be followed by <code>&lt;</code>, etc.)</li>\n<li>EqualityExpression: <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code></li>\n<li>BitwiseANDExpression: <code>&amp;</code></li>\n<li>BitwiseXORExpression: <code>^</code></li>\n<li>BitwiseORExpression: <code>|</code></li>\n<li>LogicalANDExpression: <code>&amp;&amp;</code></li>\n<li>LogicalORExpression: <code>||</code></li>\n<li>CoalesceExpression: <code>??</code></li>\n<li>ConditionalExpression: <code>?</code>, <code>:</code></li>\n<li>AssignmentExpression: <code>=</code>, <code>+=</code>, <code>-=</code>, etc.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700614633937,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FoLtZLI1zbErXWCirevbNoDrlJO6b4jEVQ8xmk_jphw"},
{"content":{"body":" * there are two ways to think about \"to the right\":\n\n1. When parsing a _RelationalExpression_, what can be parsed for any given production on the right of a relational operator. For example, in ``RelationalExpression `<` ShiftExpression``, what kind of things can be parsed if you only look at _ShiftExpression_.\n2. When parsing productions top-down, if a production contains a _RelationalExpression_, what kind of things can you parse after the RelationalExpression itself is finished.\n\nFor (1), given `A < B`, `B` can be anything that can be parsed in a _ShiftExpression_:\n\n- ShiftExpression: `<<`, `>>`, `>>>` (i.e., `A < B << C` is parsed as `A < (B << C)`)\n- AdditiveExpression: `+`, `-` (i.e., `A < B + C` is parsed as `A < (B + C)`)\n- MultiplicativeExpression: `*`, `/`, `%` (i.e., `A < B * C` is parsed as `A < (B * C)`)\n- UpdateExpression: postfix `++`, `--`\n- LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: `?.`, `[`, `.`, `````\n\nFor (2), you look at anything that can _contain_ a RelationalExpression on the left of some other terminal/nonterminal:\n\n- RelationalExpression: `<`, `<=`, `>`, `>=`, `instanceof`, `in` (i.e., in `A < B`, `A` can be a RelationalExpression, so it can be followed by `<`, etc.)\n- EqualityExpression: `==`, `===`, `!=`, `!==`\n- BitwiseANDExpression: `&`\n- BitwiseXORExpression: `^`\n- BitwiseORExpression: `|`\n- LogicalANDExpression: `&&`\n- LogicalORExpression: `||`\n- CoalesceExpression: `??`\n- ConditionalExpression: `?`, `:`\n- AssignmentExpression: `=`, `+=`, `-=`, etc.\n- Expression: `,`\n- Anything that follows where Expression can be used","format":"org.matrix.custom.html","formatted_body":" * <p>there are two ways to think about \"to the right\":</p>\n<ol>\n<li>When parsing a <em>RelationalExpression</em>, what can be parsed for any given production on the right of a relational operator. For example, in <code>RelationalExpression `&lt;` ShiftExpression</code>, what kind of things can be parsed if you only look at <em>ShiftExpression</em>.</li>\n<li>When parsing productions top-down, if a production contains a <em>RelationalExpression</em>, what kind of things can you parse after the RelationalExpression itself is finished.</li>\n</ol>\n<p>For (1), given <code>A &lt; B</code>, <code>B</code> can be anything that can be parsed in a <em>ShiftExpression</em>:</p>\n<ul>\n<li>ShiftExpression: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> (i.e., <code>A &lt; B &lt;&lt; C</code> is parsed as <code>A &lt; (B &lt;&lt; C)</code>)</li>\n<li>AdditiveExpression: <code>+</code>, <code>-</code> (i.e., <code>A &lt; B + C</code> is parsed as <code>A &lt; (B + C)</code>)</li>\n<li>MultiplicativeExpression: <code>*</code>, <code>/</code>, <code>%</code> (i.e., <code>A &lt; B * C</code> is parsed as <code>A &lt; (B * C)</code>)</li>\n<li>UpdateExpression: postfix <code>++</code>, <code>--</code></li>\n<li>LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: <code>?.</code>, <code>[</code>, <code>.</code>, `````</li>\n</ul>\n<p>For (2), you look at anything that can <em>contain</em> a RelationalExpression on the left of some other terminal/nonterminal:</p>\n<ul>\n<li>RelationalExpression: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>instanceof</code>, <code>in</code> (i.e., in <code>A &lt; B</code>, <code>A</code> can be a RelationalExpression, so it can be followed by <code>&lt;</code>, etc.)</li>\n<li>EqualityExpression: <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code></li>\n<li>BitwiseANDExpression: <code>&amp;</code></li>\n<li>BitwiseXORExpression: <code>^</code></li>\n<li>BitwiseORExpression: <code>|</code></li>\n<li>LogicalANDExpression: <code>&amp;&amp;</code></li>\n<li>LogicalORExpression: <code>||</code></li>\n<li>CoalesceExpression: <code>??</code></li>\n<li>ConditionalExpression: <code>?</code>, <code>:</code></li>\n<li>AssignmentExpression: <code>=</code>, <code>+=</code>, <code>-=</code>, etc.</li>\n<li>Expression: <code>,</code></li>\n<li>Anything that follows where Expression can be used</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"there are two ways to think about \"to the right\":\n\n1. When parsing a _RelationalExpression_, what can be parsed for any given production on the right of a relational operator. For example, in ``RelationalExpression `<` ShiftExpression``, what kind of things can be parsed if you only look at _ShiftExpression_.\n2. When parsing productions top-down, if a production contains a _RelationalExpression_, what kind of things can you parse after the RelationalExpression itself is finished.\n\nFor (1), given `A < B`, `B` can be anything that can be parsed in a _ShiftExpression_:\n\n- ShiftExpression: `<<`, `>>`, `>>>` (i.e., `A < B << C` is parsed as `A < (B << C)`)\n- AdditiveExpression: `+`, `-` (i.e., `A < B + C` is parsed as `A < (B + C)`)\n- MultiplicativeExpression: `*`, `/`, `%` (i.e., `A < B * C` is parsed as `A < (B * C)`)\n- UpdateExpression: postfix `++`, `--`\n- LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: `?.`, `[`, `.`, `````\n\nFor (2), you look at anything that can _contain_ a RelationalExpression on the left of some other terminal/nonterminal:\n\n- RelationalExpression: `<`, `<=`, `>`, `>=`, `instanceof`, `in` (i.e., in `A < B`, `A` can be a RelationalExpression, so it can be followed by `<`, etc.)\n- EqualityExpression: `==`, `===`, `!=`, `!==`\n- BitwiseANDExpression: `&`\n- BitwiseXORExpression: `^`\n- BitwiseORExpression: `|`\n- LogicalANDExpression: `&&`\n- LogicalORExpression: `||`\n- CoalesceExpression: `??`\n- ConditionalExpression: `?`, `:`\n- AssignmentExpression: `=`, `+=`, `-=`, etc.\n- Expression: `,`\n- Anything that follows where Expression can be used","format":"org.matrix.custom.html","formatted_body":"<p>there are two ways to think about \"to the right\":</p>\n<ol>\n<li>When parsing a <em>RelationalExpression</em>, what can be parsed for any given production on the right of a relational operator. For example, in <code>RelationalExpression `&lt;` ShiftExpression</code>, what kind of things can be parsed if you only look at <em>ShiftExpression</em>.</li>\n<li>When parsing productions top-down, if a production contains a <em>RelationalExpression</em>, what kind of things can you parse after the RelationalExpression itself is finished.</li>\n</ol>\n<p>For (1), given <code>A &lt; B</code>, <code>B</code> can be anything that can be parsed in a <em>ShiftExpression</em>:</p>\n<ul>\n<li>ShiftExpression: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> (i.e., <code>A &lt; B &lt;&lt; C</code> is parsed as <code>A &lt; (B &lt;&lt; C)</code>)</li>\n<li>AdditiveExpression: <code>+</code>, <code>-</code> (i.e., <code>A &lt; B + C</code> is parsed as <code>A &lt; (B + C)</code>)</li>\n<li>MultiplicativeExpression: <code>*</code>, <code>/</code>, <code>%</code> (i.e., <code>A &lt; B * C</code> is parsed as <code>A &lt; (B * C)</code>)</li>\n<li>UpdateExpression: postfix <code>++</code>, <code>--</code></li>\n<li>LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: <code>?.</code>, <code>[</code>, <code>.</code>, `````</li>\n</ul>\n<p>For (2), you look at anything that can <em>contain</em> a RelationalExpression on the left of some other terminal/nonterminal:</p>\n<ul>\n<li>RelationalExpression: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>instanceof</code>, <code>in</code> (i.e., in <code>A &lt; B</code>, <code>A</code> can be a RelationalExpression, so it can be followed by <code>&lt;</code>, etc.)</li>\n<li>EqualityExpression: <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code></li>\n<li>BitwiseANDExpression: <code>&amp;</code></li>\n<li>BitwiseXORExpression: <code>^</code></li>\n<li>BitwiseORExpression: <code>|</code></li>\n<li>LogicalANDExpression: <code>&amp;&amp;</code></li>\n<li>LogicalORExpression: <code>||</code></li>\n<li>CoalesceExpression: <code>??</code></li>\n<li>ConditionalExpression: <code>?</code>, <code>:</code></li>\n<li>AssignmentExpression: <code>=</code>, <code>+=</code>, <code>-=</code>, etc.</li>\n<li>Expression: <code>,</code></li>\n<li>Anything that follows where Expression can be used</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$FoLtZLI1zbErXWCirevbNoDrlJO6b4jEVQ8xmk_jphw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1700614820571,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Aqf9UvRnu6aAJ7uLVa8tYDRX_4cFdH3CGPF564fxkDs"},
{"content":{"body":"So in `A < B`, if `B` is just an identifier, the following tokens could legally follow it:\n- From (1): `<<`, `>>`, `>>>`, `+`, `-`, `*`, `/`, `%`, `++`, `--`, `?.`, `[`, `.`, `(`, `` ` ``\n- From (2): `<`, `<=`, `>`, `>=`, `==`, `===`, `!=`, `!==`, `&`, `^`, `|`, `&&`, `||`, `??`, `?`, `:`, `=`, `+=` (and other compound ops), `,`, plus anything that can follow _Expression_ in the grammar.","format":"org.matrix.custom.html","formatted_body":"<p>So in <code>A &lt; B</code>, if <code>B</code> is just an identifier, the following tokens could legally follow it:</p>\n<ul>\n<li>From (1): <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>++</code>, <code>--</code>, <code>?.</code>, <code>[</code>, <code>.</code>, <code>(</code>, <code>`</code></li>\n<li>From (2): <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code>, <code>&amp;</code>, <code>^</code>, <code>|</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>??</code>, <code>?</code>, <code>:</code>, <code>=</code>, <code>+=</code> (and other compound ops), <code>,</code>, plus anything that can follow <em>Expression</em> in the grammar.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700614835392,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MsdQaNVVOK_cGW92yALVzdm738wZhW32LoiqZ01izxo"},
{"content":{"body":"Everything that comes from (1) is only legal because it is specifically part of the grammar defined for _RelationalExpression_. Everything that comes from (2) is legal because some other production defines it as following a _RelationalExpression_.","format":"org.matrix.custom.html","formatted_body":"Everything that comes from (1) is only legal because it is specifically part of the grammar defined for <em>RelationalExpression</em>. Everything that comes from (2) is legal because some other production defines it as following a <em>RelationalExpression</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1700614894267,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dsIiOU_bLEtVH0yn2hkPZyRgAoaPvQDKjLqrwdUB9CI"},
{"content":{"body":"So for an `is` pattern, you will always contend with (2), but the grammar you supply for MatchPattern will define (1). The caveat, of course, being ASI and how it applies to ambiguous tokens like `+`, `-`, `(`, and `[` that can start a new statement.","format":"org.matrix.custom.html","formatted_body":"So for an <code>is</code> pattern, you will always contend with (2), but the grammar you supply for MatchPattern will define (1). The caveat, of course, being ASI and how it applies to ambiguous tokens like <code>+</code>, <code>-</code>, <code>(</code>, and <code>[</code> that can start a new statement.","m.mentions":{},"msgtype":"m.text"},"ts":1700615007212,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1lZAvR3oomaVSXIQds6G3ebE-wX2LwBHffqb38ctqkY"},
{"content":{"body":"thanks, this is very helpful","m.mentions":{},"msgtype":"m.text"},"ts":1700615043029,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$GQc32EOXAMS_XZCRP44YZ2TzADkNWNO43zrBlh7C1b0"},
{"content":{"body":"Since `.` is defined in (1) for a given RelationalExpression, it only really has the meaning we ascribe to it given the syntax we define.","format":"org.matrix.custom.html","formatted_body":"Since <code>.</code> is defined in (1) for a given RelationalExpression, it only really has the meaning we ascribe to it given the syntax we define.","m.mentions":{},"msgtype":"m.text"},"ts":1700615054122,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KIRRt-43aMGo7Y7z40op59T85hF8TBNUxv437Fd_Stk"},
{"content":{"body":"for is expression, the only valid set is from (2)","m.mentions":{},"msgtype":"m.text"},"ts":1700615084156,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Hk42_qVPfY95xvhXz6f6d97EA4e0HbaNPJuxdp4W_nQ"},
{"content":{"body":"so, a confusing case (especially for JSX users) will be `x is < y > z ...`","format":"org.matrix.custom.html","formatted_body":"so, a confusing case (especially for JSX users) will be <code>x is &lt; y &gt; z ...</code>","m.mentions":{},"msgtype":"m.text"},"ts":1700615128288,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$dD10ZwysH4bYZ1HP-FDdj8fkN4pPVyaA_5V7063dhwQ"},
{"content":{"body":"Correct. Per the pattern grammar, `a is b.c` is legal only because we define it as part of PatternMatchingMemberExpression, which limits what can be the starting token to Identifier, `this`, `super`, and a MetaProperty (like `new.target`)","format":"org.matrix.custom.html","formatted_body":"Correct. Per the pattern grammar, <code>a is b.c</code> is legal only because we define it as part of PatternMatchingMemberExpression, which limits what can be the starting token to Identifier, <code>this</code>, <code>super</code>, and a MetaProperty (like <code>new.target</code>)","m.mentions":{},"msgtype":"m.text"},"ts":1700615200208,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2MjPLiv93t4Wb8jWgvE1oZfxmEUBEwTyMA--2uNV7V0"},
{"content":{"body":"and it is visually confusing, no parse confusing because JSX element is not a pattern","m.mentions":{},"msgtype":"m.text"},"ts":1700615225047,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$tP74kw_rmihs3ebLXHnFyoPKXdOcNJ53M43xdGWx5D0"},
{"content":{"body":"Yes. In regular JS, it would be parsed as `(x is < y) > z` since _RelationalPattern_ can appear on the left. ","format":"org.matrix.custom.html","formatted_body":"Yes. In regular JS, it would be parsed as <code>(x is &lt; y) &gt; z</code> since <em>RelationalPattern</em> can appear on the left.","m.mentions":{},"msgtype":"m.text"},"ts":1700615279011,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nE6k_FZMZOi_o_hL_AG0aq0PneoIDenZK8gzwaFz8Ns"},
{"content":{"body":"JSX has its own set of parsing concerns, given that JSX also looks like valid JS when you consider ASI, and requires either infinite lookahead or a fairly aggressive cover grammar to address:\n```js\na\n<b>c \n```","format":"org.matrix.custom.html","formatted_body":"<p>JSX has its own set of parsing concerns, given that JSX also looks like valid JS when you consider ASI, and requires either infinite lookahead or a fairly aggressive cover grammar to address:</p>\n<pre><code class=\"language-js\">a\n&lt;b&gt;c \n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700615401867,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$sKc0ky9pHF6BlUcMsHzfvdhNZz7oTAlZA0oWel-UDt0"},
{"content":{"body":"That visual confusion can be addressed via linters or limitations on JSX syntax. Also, `x is < y > z` is somewhat meaningless because its rare to compare booleans relationally.","format":"org.matrix.custom.html","formatted_body":"That visual confusion can be addressed via linters or limitations on JSX syntax. Also, <code>x is &lt; y &gt; z</code> is somewhat meaningless because its rare to compare booleans relationally.","m.mentions":{},"msgtype":"m.text"},"ts":1700615481715,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-DOL7JWcpxcEX9KfgeivoqPHqjoeMjk2TEJJGR1HsW4"},
{"content":{"body":"another case I can think of is developers might forgot to add `and` and let it becomes `x is > 10 < 20` (should be `x is > 10 and < 20`), but I think it's not a problem we need to care about","format":"org.matrix.custom.html","formatted_body":"another case I can think of is developers might forgot to add <code>and</code> and let it becomes <code>x is &gt; 10 &lt; 20</code> (should be <code>x is &gt; 10 and &lt; 20</code>), but I think it's not a problem we need to care about","m.mentions":{},"msgtype":"m.text"},"ts":1700615533081,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$z22dTaDMC3gnutl-UUoXJxzpO5T3gcXaPBS3nm2cXt4"},
{"content":{"body":"I also wouldn't expect that `x is <y>` would be meaningful in a file that had both JSX and pattern matching, I could never see it as a blessed syntax.","format":"org.matrix.custom.html","formatted_body":"I also wouldn't expect that <code>x is &lt;y&gt;</code> would be meaningful in a file that had both JSX and pattern matching, I could never see it as a blessed syntax.","m.mentions":{},"msgtype":"m.text"},"ts":1700615546050,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YwWr2UXyGrjVko4lrDyu5HvDcen5mAmU3CsgXCo7uJ0"},
{"content":{"body":"> <@jackworks:matrix.org> another case I can think of is developers might forgot to add `and` and let it becomes `x is > 10 < 20` (should be `x is > 10 and < 20`), but I think it's not a problem we need to care about\n\nThis seems like something a type system could catch (i.e., `boolean` and `number` are not comparable)","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$z22dTaDMC3gnutl-UUoXJxzpO5T3gcXaPBS3nm2cXt4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>another case I can think of is developers might forgot to add <code>and</code> and let it becomes <code>x is &gt; 10 &lt; 20</code> (should be <code>x is &gt; 10 and &lt; 20</code>), but I think it's not a problem we need to care about</blockquote></mx-reply>This seems like something a type system could catch (i.e., <code>boolean</code> and <code>number</code> are not comparable)","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$z22dTaDMC3gnutl-UUoXJxzpO5T3gcXaPBS3nm2cXt4"}},"msgtype":"m.text"},"ts":1700615596374,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$BAZcSpyAsgEh0zUQfbdEsc5Xerw7Bsy8bBCREfGCP6c"},
{"content":{"body":"I think `is` expression is ok now","format":"org.matrix.custom.html","formatted_body":"I think <code>is</code> expression is ok now","m.mentions":{},"msgtype":"m.text"},"ts":1700615653205,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$-RyQmFsU8NtyKLnxvIH6e61ssKbgTjTatft3qwH2PLg"},
{"content":{"body":"we should discuss about do-expression like semantics in the next meeting","m.mentions":{},"msgtype":"m.text"},"ts":1700615677871,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$iZPK_e62bpF2-6NKlnRiKJfjU-OT87ZBzoSTn3-n24A"},
{"content":{"body":" * we should discuss about do-expression like semantics (for match clauses) in the next meeting","m.mentions":{},"m.new_content":{"body":"we should discuss about do-expression like semantics (for match clauses) in the next meeting","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$iZPK_e62bpF2-6NKlnRiKJfjU-OT87ZBzoSTn3-n24A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1700615687790,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Urt57Q8fmmAFRf1Y1UvGIYXw65nr6D6IvHbhXLhCCJ8"},
{"content":{"body":"Fyi, I have a concern with the editors note here: https://raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html#prod-MemberExpressionPattern:~:text=All%20productions%20except,can%20be%20removed.\n\nI would argue that `` PatternMatchingMemberExpression `.` IdentifierName `` is also a minimum requirement, otherwise this will not meet my needs for Extractors and ADT enums. I think `?.` could be dropped, as DecoratorMemberExpression does not support it and I'm not even clear on what matching against an optional chain should even mean.","format":"org.matrix.custom.html","formatted_body":"<p>Fyi, I have a concern with the editors note here: https://raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html#prod-MemberExpressionPattern:~:text=All%20productions%20except,can%20be%20removed.</p>\n<p>I would argue that <code>PatternMatchingMemberExpression `.` IdentifierName</code> is also a minimum requirement, otherwise this will not meet my needs for Extractors and ADT enums. I think <code>?.</code> could be dropped, as DecoratorMemberExpression does not support it and I'm not even clear on what matching against an optional chain should even mean.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700615973252,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wp3QUubWI7HaAaULMkTwPKYZd2d7t8NUsv5dztsI7Y8"},
{"content":{"body":"matches when both sides are undefined?","m.mentions":{},"msgtype":"m.text"},"ts":1700616124725,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$ZDEZEbiNald0VsvhbKdx0yQFi4q1_dfjsY7eXZ6aAa8"},
{"content":{"body":" * matches when both sides are undefined or the same value?","m.mentions":{},"m.new_content":{"body":"matches when both sides are undefined or the same value?","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$ZDEZEbiNald0VsvhbKdx0yQFi4q1_dfjsY7eXZ6aAa8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1700616136750,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$uVCtn5gy33KBVeaO3GQtfKPXU4XkTy7CE46ZaFmkMh8"},
{"content":{"body":"There's a conflicting interpretation that it could mean \"if the property isn't present, don't throw *AND* don't match\". ","format":"org.matrix.custom.html","formatted_body":"There's a conflicting interpretation that it could mean \"if the property isn't present, don't throw <em>AND</em> don't match\".","m.mentions":{},"msgtype":"m.text"},"ts":1700616311425,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_j4u87S9Sd8u-4znjr-6w9zdK4tZsCUmHkD-auqOxr8"},
{"content":{"body":"vs \"if the property isn't present, don't throw and _match `undefined`\"","format":"org.matrix.custom.html","formatted_body":"vs \"if the property isn't present, don't throw and _match <code>undefined</code>\"","m.mentions":{},"msgtype":"m.text"},"ts":1700616331749,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$n18y2B06ZzWiFrFk8ek4USFTgLjLKLDaEA23NQ9-Odg"},
{"content":{"body":" * vs \"if the property isn't present, don't throw and \\_match `undefined`_\"","format":"org.matrix.custom.html","formatted_body":" * vs \"if the property isn't present, don't throw and _match <code>undefined</code>_\"","m.mentions":{},"m.new_content":{"body":"vs \"if the property isn't present, don't throw and \\_match `undefined`_\"","format":"org.matrix.custom.html","formatted_body":"vs \"if the property isn't present, don't throw and _match <code>undefined</code>_\"","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$n18y2B06ZzWiFrFk8ek4USFTgLjLKLDaEA23NQ9-Odg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1700616335418,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XfPTl5HcO31XBRG9yHXZ50tTDp1bT4x_hEJvq6CQOno"},
{"content":{"body":" * vs \"if the property isn't present, don't throw and _match `undefined`_\"","format":"org.matrix.custom.html","formatted_body":" * vs \"if the property isn't present, don't throw and <em>match <code>undefined</code></em>\"","m.mentions":{},"m.new_content":{"body":"vs \"if the property isn't present, don't throw and _match `undefined`_\"","format":"org.matrix.custom.html","formatted_body":"vs \"if the property isn't present, don't throw and <em>match <code>undefined</code></em>\"","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$n18y2B06ZzWiFrFk8ek4USFTgLjLKLDaEA23NQ9-Odg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1700616341432,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2KsOVcMlSNcR0HrVaXsWKcwHm1bbZbzCO28nm1T5O5g"},
{"content":{"body":" * There's a conflicting interpretation that it could mean \"if the property isn't present, don't throw and _don't match_\".","format":"org.matrix.custom.html","formatted_body":" * There's a conflicting interpretation that it could mean \"if the property isn't present, don't throw and <em>don't match</em>\".","m.mentions":{},"m.new_content":{"body":"There's a conflicting interpretation that it could mean \"if the property isn't present, don't throw and _don't match_\".","format":"org.matrix.custom.html","formatted_body":"There's a conflicting interpretation that it could mean \"if the property isn't present, don't throw and <em>don't match</em>\".","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$_j4u87S9Sd8u-4znjr-6w9zdK4tZsCUmHkD-auqOxr8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1700616353003,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$CSe48aeOxHRqopzRh-sB2jJvDcet775nbDiTLebLFx4"},
{"content":{"body":"I think both are equally valid interpretations, and I'd much rather just err on the side of \"don't support this\"","m.mentions":{},"msgtype":"m.text"},"ts":1700616394865,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$6UUq_BtbTkgAeGdNOknhFjEA3l5pMFOv6Bn1VPxuAcI"},
{"content":{"body":"ok, I'll remove this","m.mentions":{},"msgtype":"m.text"},"ts":1700616407925,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$pCBPJfTb-VKIfA7Z474CDvPQM6hUIaDfZ53mugdN9o4"},
{"content":{"body":"I'll also add `x[Expression]` as a valid PatternMatchingMemberExpression","format":"org.matrix.custom.html","formatted_body":"I'll also add <code>x[Expression]</code> as a valid PatternMatchingMemberExpression","m.mentions":{},"msgtype":"m.text"},"ts":1700616887747,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$7LZ0GVR85xlmNtbJ5x8uBMQ-E5gzrbNSCxp1ZZ2yq5A"}
]