[
{"content":{"body":"yes, match against arr[0] is a legit use case","msgtype":"m.text"},"ts":1700612343485,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$hoOJCThAwdf1MtQPWRMPaWFPJ2tJnGkFk8qcO3Y-m-Y"},
{"content":{"body":"> <@rbuckton:matrix.org> `is` is not a MemberExpression, so `x is a and {}.toString` would just be a syntax error\n\nok...? I do not quite understand how this works, can you explain more? now it is a relational expression, that already makes x is {}. toString illegal?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$O9Q23kbpDXZ1vPZFPnrdE044R-m5mhe-YyTmB1FtgHA?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br /><code>is</code> is not a MemberExpression, so <code>x is a and {}.toString</code> would just be a syntax error</blockquote></mx-reply>ok...? I do not quite understand how this works, can you explain more? now it is a relational expression, that already makes x is {}. toString illegal?","m.relates_to":{"m.in_reply_to":{"event_id":"$O9Q23kbpDXZ1vPZFPnrdE044R-m5mhe-YyTmB1FtgHA"}},"msgtype":"m.text"},"ts":1700612432524,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$EQvaPYQ9udxjJvn2gheOmioxQrORh02ZoHQCDgMdQ4g"},
{"content":{"body":"Yes, if `is` is in RelationalExpression, then `is {}.anything` is illegal","format":"org.matrix.custom.html","formatted_body":"Yes, if <code>is</code> is in RelationalExpression, then <code>is {}.anything</code> is illegal","msgtype":"m.text"},"ts":1700613190904,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RSZzvEd9nx4HgoKDuhgiFT38kixecf7Uvt8Z0eSCNO4"},
{"content":{"body":"`a in b.c` is legal because the right-hand side of `in` allows MemberExpression. ","format":"org.matrix.custom.html","formatted_body":"<code>a in b.c</code> is legal because the right-hand side of <code>in</code> allows MemberExpression.","msgtype":"m.text"},"ts":1700613233924,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$iMzLkvqDqf92ybjKBuq8tH7p9N618CpAcLJok9RxsNo"},
{"content":{"body":"`a is pattern` doesn't parse a MemberExpression on the right, it parses a MatchPattern, so it only allows a\t`.` if it is specified in syntax","format":"org.matrix.custom.html","formatted_body":"<code>a is pattern</code> doesn't parse a MemberExpression on the right, it parses a MatchPattern, so it only allows a\t<code>.</code> if it is specified in syntax","msgtype":"m.text"},"ts":1700613314861,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5yGot4viaD1OUex11Wp-H81wf54SHn3Kxj5wetf86Ng"},
{"content":{"body":"ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”ðŸ¤”","msgtype":"m.text"},"ts":1700613411770,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$xSEtYT2Frt83VDsMWcyy_mc4F-NSPC4fv8pgE3sYOFQ"},
{"content":{"body":"We allow `a is b.c` because you've explicitly specified PatternMatchingMemberExpression: https://raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html#prod-PatternMatchingMemberExpression","format":"org.matrix.custom.html","formatted_body":"We allow <code>a is b.c</code> because you've explicitly specified PatternMatchingMemberExpression: https://raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html#prod-PatternMatchingMemberExpression","m.mentions":{},"msgtype":"m.text"},"ts":1700613451603,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9_QOQHOj69eLExw8VfqgFQD3Q0rxMBanDQ1vzGdKEh8"},
{"content":{"body":"that's interesting, what is legal to follow a relational expression directly?","msgtype":"m.text"},"ts":1700613459879,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$U_anfAsVizWDizgaoBj0fkHcFhungU7V6fXzy2c9FjA"},
{"content":{"body":"I want to make sure nothing is visually confusing","msgtype":"m.text"},"ts":1700613506672,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$0wtRGQo_mBfL_xec0qwSP1EdKkRfbKW2a3T5BGBqc2Q"},
{"content":{"body":"there are two ways to think about \"to the right\":\n1. When parsing a _RelationalExpression_, what can be parsed for any given production on the right of a relational operator. For example, in `` RelationalExpression `<` ShiftExpression ``, what kind of things can be parsed if you only look at _ShiftExpression_.\n2. When parsing productions top-down, if a production contains a _RelationalExpression_, what kind of things can you parse after the RelationalExpression itself is finished.\n\nFor (1), given `A < B`, `B` can be anything that can be parsed in a _ShiftExpression_:\n- ShiftExpression: `<<`, `>>`, `>>>` (i.e., `A < B << C` is parsed as `A < (B << C)`)\n- AdditiveExpression: `+`, `-` (i.e., `A < B + C` is parsed as `A < (B + C)`)\n- MultiplicativeExpression: `*`, `/`, `%` (i.e., `A < B * C` is parsed as `A < (B * C)`)\n- UpdateExpression: postfix `++`, `--`\n- LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: `?.`, `[`, `.`, `` ` ``\n\nFor (2), you look at anything that can _contain_ a RelationalExpression on the left of some other terminal/nonterminal:\n- RelationalExpression: `<`, `<=`, `>`, `>=`, `instanceof`, `in` (i.e., in `A < B`, `A` can be a RelationalExpression, so it can be followed by `<`, etc.)\n- EqualityExpression: `==`, `===`, `!=`, `!==`\n- BitwiseANDExpression: `&`\n- BitwiseXORExpression: `^`\n- BitwiseORExpression: `|`\n- LogicalANDExpression: `&&`\n- LogicalORExpression: `||`\n- CoalesceExpression: `??`\n- ConditionalExpression: `?`, `:`\n- AssignmentExpression: `=`, `+=`, `-=`, etc.\n\n","format":"org.matrix.custom.html","formatted_body":"<p>there are two ways to think about \"to the right\":</p>\n<ol>\n<li>When parsing a <em>RelationalExpression</em>, what can be parsed for any given production on the right of a relational operator. For example, in <code>RelationalExpression `&lt;` ShiftExpression</code>, what kind of things can be parsed if you only look at <em>ShiftExpression</em>.</li>\n<li>When parsing productions top-down, if a production contains a <em>RelationalExpression</em>, what kind of things can you parse after the RelationalExpression itself is finished.</li>\n</ol>\n<p>For (1), given <code>A &lt; B</code>, <code>B</code> can be anything that can be parsed in a <em>ShiftExpression</em>:</p>\n<ul>\n<li>ShiftExpression: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> (i.e., <code>A &lt; B &lt;&lt; C</code> is parsed as <code>A &lt; (B &lt;&lt; C)</code>)</li>\n<li>AdditiveExpression: <code>+</code>, <code>-</code> (i.e., <code>A &lt; B + C</code> is parsed as <code>A &lt; (B + C)</code>)</li>\n<li>MultiplicativeExpression: <code>*</code>, <code>/</code>, <code>%</code> (i.e., <code>A &lt; B * C</code> is parsed as <code>A &lt; (B * C)</code>)</li>\n<li>UpdateExpression: postfix <code>++</code>, <code>--</code></li>\n<li>LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: <code>?.</code>, <code>[</code>, <code>.</code>, <code>`</code></li>\n</ul>\n<p>For (2), you look at anything that can <em>contain</em> a RelationalExpression on the left of some other terminal/nonterminal:</p>\n<ul>\n<li>RelationalExpression: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>instanceof</code>, <code>in</code> (i.e., in <code>A &lt; B</code>, <code>A</code> can be a RelationalExpression, so it can be followed by <code>&lt;</code>, etc.)</li>\n<li>EqualityExpression: <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code></li>\n<li>BitwiseANDExpression: <code>&amp;</code></li>\n<li>BitwiseXORExpression: <code>^</code></li>\n<li>BitwiseORExpression: <code>|</code></li>\n<li>LogicalANDExpression: <code>&amp;&amp;</code></li>\n<li>LogicalORExpression: <code>||</code></li>\n<li>CoalesceExpression: <code>??</code></li>\n<li>ConditionalExpression: <code>?</code>, <code>:</code></li>\n<li>AssignmentExpression: <code>=</code>, <code>+=</code>, <code>-=</code>, etc.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700614633937,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$FoLtZLI1zbErXWCirevbNoDrlJO6b4jEVQ8xmk_jphw"},
{"content":{"body":" * there are two ways to think about \"to the right\":\n\n1. When parsing a _RelationalExpression_, what can be parsed for any given production on the right of a relational operator. For example, in ``RelationalExpression `<` ShiftExpression``, what kind of things can be parsed if you only look at _ShiftExpression_.\n2. When parsing productions top-down, if a production contains a _RelationalExpression_, what kind of things can you parse after the RelationalExpression itself is finished.\n\nFor (1), given `A < B`, `B` can be anything that can be parsed in a _ShiftExpression_:\n\n- ShiftExpression: `<<`, `>>`, `>>>` (i.e., `A < B << C` is parsed as `A < (B << C)`)\n- AdditiveExpression: `+`, `-` (i.e., `A < B + C` is parsed as `A < (B + C)`)\n- MultiplicativeExpression: `*`, `/`, `%` (i.e., `A < B * C` is parsed as `A < (B * C)`)\n- UpdateExpression: postfix `++`, `--`\n- LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: `?.`, `[`, `.`, `````\n\nFor (2), you look at anything that can _contain_ a RelationalExpression on the left of some other terminal/nonterminal:\n\n- RelationalExpression: `<`, `<=`, `>`, `>=`, `instanceof`, `in` (i.e., in `A < B`, `A` can be a RelationalExpression, so it can be followed by `<`, etc.)\n- EqualityExpression: `==`, `===`, `!=`, `!==`\n- BitwiseANDExpression: `&`\n- BitwiseXORExpression: `^`\n- BitwiseORExpression: `|`\n- LogicalANDExpression: `&&`\n- LogicalORExpression: `||`\n- CoalesceExpression: `??`\n- ConditionalExpression: `?`, `:`\n- AssignmentExpression: `=`, `+=`, `-=`, etc.\n- Expression: `,`\n- Anything that follows where Expression can be used","format":"org.matrix.custom.html","formatted_body":" * <p>there are two ways to think about \"to the right\":</p>\n<ol>\n<li>When parsing a <em>RelationalExpression</em>, what can be parsed for any given production on the right of a relational operator. For example, in <code>RelationalExpression `&lt;` ShiftExpression</code>, what kind of things can be parsed if you only look at <em>ShiftExpression</em>.</li>\n<li>When parsing productions top-down, if a production contains a <em>RelationalExpression</em>, what kind of things can you parse after the RelationalExpression itself is finished.</li>\n</ol>\n<p>For (1), given <code>A &lt; B</code>, <code>B</code> can be anything that can be parsed in a <em>ShiftExpression</em>:</p>\n<ul>\n<li>ShiftExpression: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> (i.e., <code>A &lt; B &lt;&lt; C</code> is parsed as <code>A &lt; (B &lt;&lt; C)</code>)</li>\n<li>AdditiveExpression: <code>+</code>, <code>-</code> (i.e., <code>A &lt; B + C</code> is parsed as <code>A &lt; (B + C)</code>)</li>\n<li>MultiplicativeExpression: <code>*</code>, <code>/</code>, <code>%</code> (i.e., <code>A &lt; B * C</code> is parsed as <code>A &lt; (B * C)</code>)</li>\n<li>UpdateExpression: postfix <code>++</code>, <code>--</code></li>\n<li>LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: <code>?.</code>, <code>[</code>, <code>.</code>, `````</li>\n</ul>\n<p>For (2), you look at anything that can <em>contain</em> a RelationalExpression on the left of some other terminal/nonterminal:</p>\n<ul>\n<li>RelationalExpression: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>instanceof</code>, <code>in</code> (i.e., in <code>A &lt; B</code>, <code>A</code> can be a RelationalExpression, so it can be followed by <code>&lt;</code>, etc.)</li>\n<li>EqualityExpression: <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code></li>\n<li>BitwiseANDExpression: <code>&amp;</code></li>\n<li>BitwiseXORExpression: <code>^</code></li>\n<li>BitwiseORExpression: <code>|</code></li>\n<li>LogicalANDExpression: <code>&amp;&amp;</code></li>\n<li>LogicalORExpression: <code>||</code></li>\n<li>CoalesceExpression: <code>??</code></li>\n<li>ConditionalExpression: <code>?</code>, <code>:</code></li>\n<li>AssignmentExpression: <code>=</code>, <code>+=</code>, <code>-=</code>, etc.</li>\n<li>Expression: <code>,</code></li>\n<li>Anything that follows where Expression can be used</li>\n</ul>\n","m.mentions":{},"m.new_content":{"body":"there are two ways to think about \"to the right\":\n\n1. When parsing a _RelationalExpression_, what can be parsed for any given production on the right of a relational operator. For example, in ``RelationalExpression `<` ShiftExpression``, what kind of things can be parsed if you only look at _ShiftExpression_.\n2. When parsing productions top-down, if a production contains a _RelationalExpression_, what kind of things can you parse after the RelationalExpression itself is finished.\n\nFor (1), given `A < B`, `B` can be anything that can be parsed in a _ShiftExpression_:\n\n- ShiftExpression: `<<`, `>>`, `>>>` (i.e., `A < B << C` is parsed as `A < (B << C)`)\n- AdditiveExpression: `+`, `-` (i.e., `A < B + C` is parsed as `A < (B + C)`)\n- MultiplicativeExpression: `*`, `/`, `%` (i.e., `A < B * C` is parsed as `A < (B * C)`)\n- UpdateExpression: postfix `++`, `--`\n- LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: `?.`, `[`, `.`, `````\n\nFor (2), you look at anything that can _contain_ a RelationalExpression on the left of some other terminal/nonterminal:\n\n- RelationalExpression: `<`, `<=`, `>`, `>=`, `instanceof`, `in` (i.e., in `A < B`, `A` can be a RelationalExpression, so it can be followed by `<`, etc.)\n- EqualityExpression: `==`, `===`, `!=`, `!==`\n- BitwiseANDExpression: `&`\n- BitwiseXORExpression: `^`\n- BitwiseORExpression: `|`\n- LogicalANDExpression: `&&`\n- LogicalORExpression: `||`\n- CoalesceExpression: `??`\n- ConditionalExpression: `?`, `:`\n- AssignmentExpression: `=`, `+=`, `-=`, etc.\n- Expression: `,`\n- Anything that follows where Expression can be used","format":"org.matrix.custom.html","formatted_body":"<p>there are two ways to think about \"to the right\":</p>\n<ol>\n<li>When parsing a <em>RelationalExpression</em>, what can be parsed for any given production on the right of a relational operator. For example, in <code>RelationalExpression `&lt;` ShiftExpression</code>, what kind of things can be parsed if you only look at <em>ShiftExpression</em>.</li>\n<li>When parsing productions top-down, if a production contains a <em>RelationalExpression</em>, what kind of things can you parse after the RelationalExpression itself is finished.</li>\n</ol>\n<p>For (1), given <code>A &lt; B</code>, <code>B</code> can be anything that can be parsed in a <em>ShiftExpression</em>:</p>\n<ul>\n<li>ShiftExpression: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code> (i.e., <code>A &lt; B &lt;&lt; C</code> is parsed as <code>A &lt; (B &lt;&lt; C)</code>)</li>\n<li>AdditiveExpression: <code>+</code>, <code>-</code> (i.e., <code>A &lt; B + C</code> is parsed as <code>A &lt; (B + C)</code>)</li>\n<li>MultiplicativeExpression: <code>*</code>, <code>/</code>, <code>%</code> (i.e., <code>A &lt; B * C</code> is parsed as <code>A &lt; (B * C)</code>)</li>\n<li>UpdateExpression: postfix <code>++</code>, <code>--</code></li>\n<li>LeftHandSideExpression/OptionalExpression/MemberExpression/CallExpression: <code>?.</code>, <code>[</code>, <code>.</code>, `````</li>\n</ul>\n<p>For (2), you look at anything that can <em>contain</em> a RelationalExpression on the left of some other terminal/nonterminal:</p>\n<ul>\n<li>RelationalExpression: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>instanceof</code>, <code>in</code> (i.e., in <code>A &lt; B</code>, <code>A</code> can be a RelationalExpression, so it can be followed by <code>&lt;</code>, etc.)</li>\n<li>EqualityExpression: <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code></li>\n<li>BitwiseANDExpression: <code>&amp;</code></li>\n<li>BitwiseXORExpression: <code>^</code></li>\n<li>BitwiseORExpression: <code>|</code></li>\n<li>LogicalANDExpression: <code>&amp;&amp;</code></li>\n<li>LogicalORExpression: <code>||</code></li>\n<li>CoalesceExpression: <code>??</code></li>\n<li>ConditionalExpression: <code>?</code>, <code>:</code></li>\n<li>AssignmentExpression: <code>=</code>, <code>+=</code>, <code>-=</code>, etc.</li>\n<li>Expression: <code>,</code></li>\n<li>Anything that follows where Expression can be used</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$FoLtZLI1zbErXWCirevbNoDrlJO6b4jEVQ8xmk_jphw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1700614820571,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Aqf9UvRnu6aAJ7uLVa8tYDRX_4cFdH3CGPF564fxkDs"},
{"content":{"body":"So in `A < B`, if `B` is just an identifier, the following tokens could legally follow it:\n- From (1): `<<`, `>>`, `>>>`, `+`, `-`, `*`, `/`, `%`, `++`, `--`, `?.`, `[`, `.`, `(`, `` ` ``\n- From (2): `<`, `<=`, `>`, `>=`, `==`, `===`, `!=`, `!==`, `&`, `^`, `|`, `&&`, `||`, `??`, `?`, `:`, `=`, `+=` (and other compound ops), `,`, plus anything that can follow _Expression_ in the grammar.","format":"org.matrix.custom.html","formatted_body":"<p>So in <code>A &lt; B</code>, if <code>B</code> is just an identifier, the following tokens could legally follow it:</p>\n<ul>\n<li>From (1): <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>++</code>, <code>--</code>, <code>?.</code>, <code>[</code>, <code>.</code>, <code>(</code>, <code>`</code></li>\n<li>From (2): <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code>, <code>&amp;</code>, <code>^</code>, <code>|</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>??</code>, <code>?</code>, <code>:</code>, <code>=</code>, <code>+=</code> (and other compound ops), <code>,</code>, plus anything that can follow <em>Expression</em> in the grammar.</li>\n</ul>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700614835392,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MsdQaNVVOK_cGW92yALVzdm738wZhW32LoiqZ01izxo"},
{"content":{"body":"Everything that comes from (1) is only legal because it is specifically part of the grammar defined for _RelationalExpression_. Everything that comes from (2) is legal because some other production defines it as following a _RelationalExpression_.","format":"org.matrix.custom.html","formatted_body":"Everything that comes from (1) is only legal because it is specifically part of the grammar defined for <em>RelationalExpression</em>. Everything that comes from (2) is legal because some other production defines it as following a <em>RelationalExpression</em>.","m.mentions":{},"msgtype":"m.text"},"ts":1700614894267,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dsIiOU_bLEtVH0yn2hkPZyRgAoaPvQDKjLqrwdUB9CI"},
{"content":{"body":"So for an `is` pattern, you will always contend with (2), but the grammar you supply for MatchPattern will define (1). The caveat, of course, being ASI and how it applies to ambiguous tokens like `+`, `-`, `(`, and `[` that can start a new statement.","format":"org.matrix.custom.html","formatted_body":"So for an <code>is</code> pattern, you will always contend with (2), but the grammar you supply for MatchPattern will define (1). The caveat, of course, being ASI and how it applies to ambiguous tokens like <code>+</code>, <code>-</code>, <code>(</code>, and <code>[</code> that can start a new statement.","m.mentions":{},"msgtype":"m.text"},"ts":1700615007212,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1lZAvR3oomaVSXIQds6G3ebE-wX2LwBHffqb38ctqkY"},
{"content":{"body":"thanks, this is very helpful","m.mentions":{},"msgtype":"m.text"},"ts":1700615043029,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$GQc32EOXAMS_XZCRP44YZ2TzADkNWNO43zrBlh7C1b0"},
{"content":{"body":"Since `.` is defined in (1) for a given RelationalExpression, it only really has the meaning we ascribe to it given the syntax we define.","format":"org.matrix.custom.html","formatted_body":"Since <code>.</code> is defined in (1) for a given RelationalExpression, it only really has the meaning we ascribe to it given the syntax we define.","m.mentions":{},"msgtype":"m.text"},"ts":1700615054122,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KIRRt-43aMGo7Y7z40op59T85hF8TBNUxv437Fd_Stk"},
{"content":{"body":"for is expression, the only valid set is from (2)","m.mentions":{},"msgtype":"m.text"},"ts":1700615084156,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Hk42_qVPfY95xvhXz6f6d97EA4e0HbaNPJuxdp4W_nQ"},
{"content":{"body":"so, a confusing case (especially for JSX users) will be `x is < y > z ...`","format":"org.matrix.custom.html","formatted_body":"so, a confusing case (especially for JSX users) will be <code>x is &lt; y &gt; z ...</code>","m.mentions":{},"msgtype":"m.text"},"ts":1700615128288,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$dD10ZwysH4bYZ1HP-FDdj8fkN4pPVyaA_5V7063dhwQ"},
{"content":{"body":"Correct. Per the pattern grammar, `a is b.c` is legal only because we define it as part of PatternMatchingMemberExpression, which limits what can be the starting token to Identifier, `this`, `super`, and a MetaProperty (like `new.target`)","format":"org.matrix.custom.html","formatted_body":"Correct. Per the pattern grammar, <code>a is b.c</code> is legal only because we define it as part of PatternMatchingMemberExpression, which limits what can be the starting token to Identifier, <code>this</code>, <code>super</code>, and a MetaProperty (like <code>new.target</code>)","m.mentions":{},"msgtype":"m.text"},"ts":1700615200208,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2MjPLiv93t4Wb8jWgvE1oZfxmEUBEwTyMA--2uNV7V0"},
{"content":{"body":"and it is visually confusing, no parse confusing because JSX element is not a pattern","m.mentions":{},"msgtype":"m.text"},"ts":1700615225047,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$tP74kw_rmihs3ebLXHnFyoPKXdOcNJ53M43xdGWx5D0"},
{"content":{"body":"Yes. In regular JS, it would be parsed as `(x is < y) > z` since _RelationalPattern_ can appear on the left. ","format":"org.matrix.custom.html","formatted_body":"Yes. In regular JS, it would be parsed as <code>(x is &lt; y) &gt; z</code> since <em>RelationalPattern</em> can appear on the left.","m.mentions":{},"msgtype":"m.text"},"ts":1700615279011,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nE6k_FZMZOi_o_hL_AG0aq0PneoIDenZK8gzwaFz8Ns"},
{"content":{"body":"JSX has its own set of parsing concerns, given that JSX also looks like valid JS when you consider ASI, and requires either infinite lookahead or a fairly aggressive cover grammar to address:\n```js\na\n<b>c \n```","format":"org.matrix.custom.html","formatted_body":"<p>JSX has its own set of parsing concerns, given that JSX also looks like valid JS when you consider ASI, and requires either infinite lookahead or a fairly aggressive cover grammar to address:</p>\n<pre><code class=\"language-js\">a\n&lt;b&gt;c \n</code></pre>\n","m.mentions":{},"msgtype":"m.text"},"ts":1700615401867,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$sKc0ky9pHF6BlUcMsHzfvdhNZz7oTAlZA0oWel-UDt0"}
]