[
{"content":{"body":"so what's next? change `{ a }` from direct match to `{ a: let a }`? is this valid? `{ a: let {x, y} }`?","format":"org.matrix.custom.html","formatted_body":"so what's next? change <code>{ a }</code> from direct match to <code>{ a: let a }</code>? is this valid? <code>{ a: let {x, y} }</code>?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"so what's next? change `{ a }` from direct match to `{ a: let a }`? is this valid? `{ a: let {x, y} }`?","mimetype":"text/plain"},{"body":"so what's next? change <code>{ a }</code> from direct match to <code>{ a: let a }</code>? is this valid? <code>{ a: let {x, y} }</code>?","mimetype":"text/html"}]},"ts":1666361742035,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$K4nw6yRWdT2RoGCYJIIp9_HQWoLgmWDDdMtb9_xX97A"},
{"content":{"body":"i'm still not comfortable with that direction, especially including let and/or const (and/or var)","msgtype":"m.text","org.matrix.msc1767.text":"i'm still not comfortable with that direction, especially including let and/or const (and/or var)"},"ts":1666370778898,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$pSSBdcFbeicXsQDpoo4xA9yk3cagGWGxRm2dNYKk2wE"},
{"content":{"body":" * i'm still not comfortable with that direction, especially including let and/or const (and/or var)","m.new_content":{"body":"i'm still not comfortable with that direction, especially including let and/or const (and/or var)","msgtype":"m.text","org.matrix.msc1767.text":"i'm still not comfortable with that direction, especially including let and/or const (and/or var)"},"m.relates_to":{"event_id":"$pSSBdcFbeicXsQDpoo4xA9yk3cagGWGxRm2dNYKk2wE","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * i'm still not comfortable with that direction, especially including let and/or const (and/or var)"},"ts":1666370781972,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$wwhuYzEoVu2yUiHedE8v9VOFLPku6iNyP2jraoKTQhI"},
{"content":{"body":"I'm open to other ideas, though I'm not in favor of completely divorcing declarations from pattern matching. ","format":"org.matrix.custom.html","formatted_body":"I'm open to other ideas, though I'm not in favor of completely divorcing declarations from pattern matching.","msgtype":"m.text"},"ts":1666379370337,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JUfDMRpdumBesvuH2a-d4ldnKn1PtX2eM8C2SrhEgrU"},
{"content":{"body":"While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","format":"org.matrix.custom.html","formatted_body":"While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","mimetype":"text/plain"},{"body":"While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","mimetype":"text/html"}]},"ts":1666379419072,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$d1ckVDtL01qGypqELHKBcwRDZ7onEK4AO6BjKyVjGxo"},
{"content":{"body":" * While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","format":"org.matrix.custom.html","formatted_body":" * While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","m.new_content":{"body":"While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","format":"org.matrix.custom.html","formatted_body":"While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","mimetype":"text/plain"},{"body":"While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$d1ckVDtL01qGypqELHKBcwRDZ7onEK4AO6BjKyVjGxo","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","mimetype":"text/plain"},{"body":" * While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","mimetype":"text/html"}]},"ts":1666379542821,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oC43JmuKQyHeHfqfoFAtJK01N-imSXCcYoiFyY4P8HA"},
{"content":{"body":"I know `::` was under discussion at some point, but I found the examples confusing. I'm also concerned about using `::` when there have been multiple proposals considering it for call-like behavior that could potentially apply to Extractors as well (i.e., `when { a: foo::Message(b) }` could potentially be a thing)","format":"org.matrix.custom.html","formatted_body":"I know <code>::</code> was under discussion at some point, but I found the examples confusing. I'm also concerned about using <code>::</code> when there have been multiple proposals considering it for call-like behavior that could potentially apply to Extractors as well (i.e., <code>when { a: foo::Message(b) }</code> could potentially be a thing)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I know `::` was under discussion at some point, but I found the examples confusing. I'm also concerned about using `::` when there have been multiple proposals considering it for call-like behavior that could potentially apply to Extractors as well (i.e., `when { a: foo::Message(b) }` could potentially be a thing)","mimetype":"text/plain"},{"body":"I know <code>::</code> was under discussion at some point, but I found the examples confusing. I'm also concerned about using <code>::</code> when there have been multiple proposals considering it for call-like behavior that could potentially apply to Extractors as well (i.e., <code>when { a: foo::Message(b) }</code> could potentially be a thing)","mimetype":"text/html"}]},"ts":1666379731495,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$GVMNI_P4n7K_Lln8Gxg8bV1xQjtESHZyLzh9dBssaJI"},
{"content":{"body":"(I also could never actually quite decipher the `::` examples that were produced, at least not in a consistent way.)","format":"org.matrix.custom.html","formatted_body":"(I also could never actually quite decipher the <code>::</code> examples that were produced, at least not in a consistent way.)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"(I also could never actually quite decipher the `::` examples that were produced, at least not in a consistent way.)","mimetype":"text/plain"},{"body":"(I also could never actually quite decipher the <code>::</code> examples that were produced, at least not in a consistent way.)","mimetype":"text/html"}]},"ts":1666384290821,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$1-SWX93ZD8XDAAxtgcwUPiGjehmb8jkCY988TtY05jc"},
{"content":{"body":"But yeah I don't have a strong opinion on how the irrefutable pattern is spelled.","msgtype":"m.text","org.matrix.msc1767.text":"But yeah I don't have a strong opinion on how the irrefutable pattern is spelled."},"ts":1666384346389,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$3-LOFPypGNXPMFmUDu-A66ZnVsvZChHg0cV144qtiY8"},
{"content":{"body":"The Rust `@` pattern requires you to still specify a pattern, right? You can't just say \"bind to this name, no further checks\"?","format":"org.matrix.custom.html","formatted_body":"The Rust <code>@</code> pattern requires you to still specify a pattern, right? You can't just say &quot;bind to this name, no further checks&quot;?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The Rust `@` pattern requires you to still specify a pattern, right? You can't just say \"bind to this name, no further checks\"?","mimetype":"text/plain"},{"body":"The Rust <code>@</code> pattern requires you to still specify a pattern, right? You can't just say &quot;bind to this name, no further checks&quot;?","mimetype":"text/html"}]},"ts":1666384386140,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$GzHQWhLpxjt6KyBK_3mQbgc3_Va4Le_lqZd21AJGJJo"},
{"content":{"body":"Rust binds by default unless you specify a pattern or identifier that already exists, in which case it treats it as a pattern.","msgtype":"m.text","org.matrix.msc1767.text":"Rust binds by default unless you specify a pattern or identifier that already exists, in which case it treats it as a pattern."},"ts":1666386169331,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$pRK_3jvd7irTMvZ3dd3I3x31ozb8KlwUKpGDGvp0rzE"},
{"content":{"body":"that kind of ambiguity wouldn't work well in JS though.","msgtype":"m.text","org.matrix.msc1767.text":"that kind of ambiguity wouldn't work well in JS though."},"ts":1666386206964,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gyDNvj4TGVjGuw3KoCvcjFs6VGrfOFUvLUnwzT3xLq4"},
{"content":{"body":"If we did use `@`, it would probably need to be necessary for all bindings. So `when { x: y }` would _always_ treat `y` as a pattern, meaning you'd need to write `when { x: y @ }` to introduce a binding. ","format":"org.matrix.custom.html","formatted_body":"If we did use <code>@</code>, it would probably need to be necessary for all bindings. So <code>when { x: y }</code> would <em>always</em> treat <code>y</code> as a pattern, meaning you'd need to write <code>when { x: y @ }</code> to introduce a binding.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"If we did use `@`, it would probably need to be necessary for all bindings. So `when { x: y }` would _always_ treat `y` as a pattern, meaning you'd need to write `when { x: y @ }` to introduce a binding. ","mimetype":"text/plain"},{"body":"If we did use <code>@</code>, it would probably need to be necessary for all bindings. So <code>when { x: y }</code> would <em>always</em> treat <code>y</code> as a pattern, meaning you'd need to write <code>when { x: y @ }</code> to introduce a binding.","mimetype":"text/html"}]},"ts":1666386399559,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2jlEo4o_uSBZcZwUXHPdpSnuQkfuuurWcTtp8CqZfsc"},
{"content":{"body":"That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y & pattern }` to bind *and* match. The `let` syntax is not as terse, but its much less ambiguous.","format":"org.matrix.custom.html","formatted_body":"That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y &amp; pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y & pattern }` to bind *and* match. The `let` syntax is not as terse, but its much less ambiguous.","mimetype":"text/plain"},{"body":"That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y &amp; pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","mimetype":"text/html"}]},"ts":1666386483040,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RSXWV59LHjOW6z1tlZzZr0O19scpqSyBF2p2shXyn_c"},
{"content":{"body":"Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n```js\nwhen { x: let a & let b }: [++a, --b],\nwhen { y: const originalY & let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\nYou can't really do that with `@`","format":"org.matrix.custom.html","formatted_body":"<p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a &amp; let b }: [++a, --b],\nwhen { y: const originalY &amp; let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n```js\nwhen { x: let a & let b }: [++a, --b],\nwhen { y: const originalY & let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\nYou can't really do that with `@`","mimetype":"text/plain"},{"body":"<p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a &amp; let b }: [++a, --b],\nwhen { y: const originalY &amp; let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","mimetype":"text/html"}]},"ts":1666386676898,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$C1y36OxNjhqtb4eMpBhYZ9oao-cLBeMnppN3qFzcMeU"},
{"content":{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","format":"org.matrix.custom.html","formatted_body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","mimetype":"text/plain"},{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","mimetype":"text/html"}]},"ts":1666386882983,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JA_-Md1d8vQROieaK47z9ZpyAcqU-PfoDZCUsM5vV_8"},
{"content":{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","format":"org.matrix.custom.html","formatted_body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","m.new_content":{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","format":"org.matrix.custom.html","formatted_body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","mimetype":"text/plain"},{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$JA_-Md1d8vQROieaK47z9ZpyAcqU-PfoDZCUsM5vV_8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","mimetype":"text/plain"},{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","mimetype":"text/html"}]},"ts":1666386893871,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8jM_doc9kzOeaBIgK-3QMEWRav0jQ30v5TvJK76zs10"},
{"content":{"body":" * Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n\n```js\nwhen { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\n\nYou can't really do that with `@`","format":"org.matrix.custom.html","formatted_body":" * <p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","m.new_content":{"body":"Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n\n```js\nwhen { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\n\nYou can't really do that with `@`","format":"org.matrix.custom.html","formatted_body":"<p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n\n```js\nwhen { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\n\nYou can't really do that with `@`","mimetype":"text/plain"},{"body":"<p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$C1y36OxNjhqtb4eMpBhYZ9oao-cLBeMnppN3qFzcMeU","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n\n```js\nwhen { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\n\nYou can't really do that with `@`","mimetype":"text/plain"},{"body":" * <p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","mimetype":"text/html"}]},"ts":1666387157244,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ox4yM3GKKj6Ya5KiNCVtX9X9pC6uEHoT3o8zG3IS8Uk"},
{"content":{"body":" * That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y and pattern }` to bind _and_ match. The `let` syntax is not as terse, but its much less ambiguous.","format":"org.matrix.custom.html","formatted_body":" * That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y and pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","m.new_content":{"body":"That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y and pattern }` to bind _and_ match. The `let` syntax is not as terse, but its much less ambiguous.","format":"org.matrix.custom.html","formatted_body":"That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y and pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y and pattern }` to bind _and_ match. The `let` syntax is not as terse, but its much less ambiguous.","mimetype":"text/plain"},{"body":"That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y and pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$RSXWV59LHjOW6z1tlZzZr0O19scpqSyBF2p2shXyn_c","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y and pattern }` to bind _and_ match. The `let` syntax is not as terse, but its much less ambiguous.","mimetype":"text/plain"},{"body":" * That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y and pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","mimetype":"text/html"}]},"ts":1666387164099,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mLoAKvHgMN-jKHIxrWEWULf5B5LwW2Ok55kkzSQP0bk"},
{"content":{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a and Number }` though.","format":"org.matrix.custom.html","formatted_body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a and Number }</code> though.","m.new_content":{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a and Number }` though.","format":"org.matrix.custom.html","formatted_body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a and Number }</code> though.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a and Number }` though.","mimetype":"text/plain"},{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a and Number }</code> though.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$JA_-Md1d8vQROieaK47z9ZpyAcqU-PfoDZCUsM5vV_8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a and Number }` though.","mimetype":"text/plain"},{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a and Number }</code> though.","mimetype":"text/html"}]},"ts":1666387176726,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JO9mbiVRa1FZVqC8hV8ngkb18vr0RMc4h4js_RPbmZ4"},
{"content":{"body":"`let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","mimetype":"text/plain"},{"body":"<p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1666387378221,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7HdVQMpMp0Qh509CkMvaS6myVLPkdeWBCBPMICEKM_o"},
{"content":{"body":" * `let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","m.new_content":{"body":"`let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","mimetype":"text/plain"},{"body":"<p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$7HdVQMpMp0Qh509CkMvaS6myVLPkdeWBCBPMICEKM_o","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * `let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","mimetype":"text/plain"},{"body":" * <p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1666387386950,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4XbXve-1NUMW5Lp11XNXSaBPOXyGinzBnne1Cj6Usmw"},
{"content":{"body":"i mean, regardless, imo the pattern must come first","msgtype":"m.text","org.matrix.msc1767.text":"i mean, regardless, imo the pattern must come first"},"ts":1666388216651,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$mXdIU5wl3dRuJUS3yOIeQLOnziNip1TXqy9GdMl-YHY"},
{"content":{"body":"since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern","msgtype":"m.text","org.matrix.msc1767.text":"since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern"},"ts":1666388231129,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$g4MGHmXXmW0KWvkK9Gvw6O8oFQtkMX2_GZLjCohPLUA"},
{"content":{"body":"using `let` would be fine if we only had one way to make vars, but we have 3, and it's very weird and confusing and inconsistent if we have 1 but not all 3 - and regardless, it forces the linting community to come up with a convention, or adapt existing linting rules, and creates another source of style arguments for no benefit i can see","format":"org.matrix.custom.html","formatted_body":"using <code>let</code> would be fine if we only had one way to make vars, but we have 3, and it's very weird and confusing and inconsistent if we have 1 but not all 3 - and regardless, it forces the linting community to come up with a convention, or adapt existing linting rules, and creates another source of style arguments for no benefit i can see","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"using `let` would be fine if we only had one way to make vars, but we have 3, and it's very weird and confusing and inconsistent if we have 1 but not all 3 - and regardless, it forces the linting community to come up with a convention, or adapt existing linting rules, and creates another source of style arguments for no benefit i can see","mimetype":"text/plain"},{"body":"using <code>let</code> would be fine if we only had one way to make vars, but we have 3, and it's very weird and confusing and inconsistent if we have 1 but not all 3 - and regardless, it forces the linting community to come up with a convention, or adapt existing linting rules, and creates another source of style arguments for no benefit i can see","mimetype":"text/html"}]},"ts":1666388276684,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$pUfSv9tMmlPjrE_hLEmbCPXNC_Jp54Jx-Nnb04Cm7Ko"},
{"content":{"body":"i'm perfectly comfortable with a syntactic marker for bindings, it's just that the language has no precedent for that besides let/const/var, or \"nothing/everything\", a la destructuring (where there's a marker outside the pattern but not inline on individual bindings)","msgtype":"m.text","org.matrix.msc1767.text":"i'm perfectly comfortable with a syntactic marker for bindings, it's just that the language has no precedent for that besides let/const/var, or \"nothing/everything\", a la destructuring (where there's a marker outside the pattern but not inline on individual bindings)"},"ts":1666388332566,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$IL0_GNH1APwvkcruDjlo129X1BO2y6fcPbseTCfUcHM"},
{"content":{"body":"When I talk about adding `let` bindings, I am also including `const`. I don't have a preference on `var`.","format":"org.matrix.custom.html","formatted_body":"When I talk about adding <code>let</code> bindings, I am also including <code>const</code>. I don't have a preference on <code>var</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"When I talk about adding `let` bindings, I am also including `const`. I don't have a preference on `var`.","mimetype":"text/plain"},{"body":"When I talk about adding <code>let</code> bindings, I am also including <code>const</code>. I don't have a preference on <code>var</code>.","mimetype":"text/html"}]},"ts":1666389697077,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$S4T3XCjk0TiZLDOxYkp04xL5KbE4WD6wH-77KSorJEI"},
{"content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}],"m.relates_to":{"m.in_reply_to":{"event_id":"$g4MGHmXXmW0KWvkK9Gvw6O8oFQtkMX2_GZLjCohPLUA"}}},"ts":1666389846314,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY"},
{"content":{"body":"> <@ljharb:matrix.org> since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern\n\n * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }`and`when { a: Number and let x }` are pretty much the same. With Rust's`@`syntax, the binding comes first, i.e.`when { x: Binding @ Pattern }\\`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$g4MGHmXXmW0KWvkK9Gvw6O8oFQtkMX2_GZLjCohPLUA?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern</blockquote></mx-reply> * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }<code>and</code>when { a: Number and let x }<code> are pretty much the same. With Rust's</code>@<code>syntax, the binding comes first, i.e.</code>when { x: Binding @ Pattern }`.","m.new_content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }`and`when { a: Number and let x }` are pretty much the same. With Rust's`@`syntax, the binding comes first, i.e.`when { x: Binding @ Pattern }\\`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }<code>and</code>when { a: Number and let x }<code> are pretty much the same. With Rust's</code>@<code>syntax, the binding comes first, i.e.</code>when { x: Binding @ Pattern }`.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }`and`when { a: Number and let x }` are pretty much the same. With Rust's`@`syntax, the binding comes first, i.e.`when { x: Binding @ Pattern }\\`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }<code>and</code>when { a: Number and let x }<code> are pretty much the same. With Rust's</code>@<code>syntax, the binding comes first, i.e.</code>when { x: Binding @ Pattern }`.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@ljharb:matrix.org> since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern\n\n * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }`and`when { a: Number and let x }` are pretty much the same. With Rust's`@`syntax, the binding comes first, i.e.`when { x: Binding @ Pattern }\\`.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$g4MGHmXXmW0KWvkK9Gvw6O8oFQtkMX2_GZLjCohPLUA?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern</blockquote></mx-reply> * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }<code>and</code>when { a: Number and let x }<code> are pretty much the same. With Rust's</code>@<code>syntax, the binding comes first, i.e.</code>when { x: Binding @ Pattern }`.","mimetype":"text/html"}]},"ts":1666389851399,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-M_bUVvhJL8px0lq6boAKGeesBZ4mCv7b17n0NWtlC8"},
{"content":{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's`@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's<code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","m.new_content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's`@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's<code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's`@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's<code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's`@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's<code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"ts":1666389872621,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8IAFnESJbs8KpF6oLoo3joQmY67ZIsEbXCZYcR-Qj_U"},
{"content":{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","m.new_content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"ts":1666389878579,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IpWy-_nxhijfqFi__gKErPnP_IPFDAiYoXq3qw3j_LQ"},
{"content":{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","m.new_content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"ts":1666389897003,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vC0K3FQRvfWnHHUnPwklPv8-B23wdKtYA2QRFdpZEJo"},
{"content":{"body":"for an inline `let` i think that's probably fine","format":"org.matrix.custom.html","formatted_body":"for an inline <code>let</code> i think that's probably fine","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"for an inline `let` i think that's probably fine","mimetype":"text/plain"},{"body":"for an inline <code>let</code> i think that's probably fine","mimetype":"text/html"}]},"ts":1666389915399,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$vFKDGdXL58dF5IkLe75t_osQ6eGtzYRkbHNeuj-g2Q4"},
{"content":{"body":"my ordering reaction is more to the `when let` suggestions, where there's a \"binding space\" and a \"pattern space\"","format":"org.matrix.custom.html","formatted_body":"my ordering reaction is more to the <code>when let</code> suggestions, where there's a &quot;binding space&quot; and a &quot;pattern space&quot;","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"my ordering reaction is more to the `when let` suggestions, where there's a \"binding space\" and a \"pattern space\"","mimetype":"text/plain"},{"body":"my ordering reaction is more to the <code>when let</code> suggestions, where there's a &quot;binding space&quot; and a &quot;pattern space&quot;","mimetype":"text/html"}]},"ts":1666389931575,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$sYbF12xJWzfS74dRhIvmd15ydDZ5lH_5Llr9ulsYtgc"},
{"content":{"body":"but including var is problematic because of scoping, and including const/let would be \"fine\" but weird to omit var and also would create those style debates that would be best avoided","msgtype":"m.text","org.matrix.msc1767.text":"but including var is problematic because of scoping, and including const/let would be \"fine\" but weird to omit var and also would create those style debates that would be best avoided"},"ts":1666389967148,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$jLcES12p7GEaoWB5YrmQwmGw3SY6l8RM9nz-vPFEDJE"},
{"content":{"body":"The `when let` example above is still a pattern, i.e.: `when (Number and (let x = init)):`, etc.","format":"org.matrix.custom.html","formatted_body":"The <code>when let</code> example above is still a pattern, i.e.: <code>when (Number and (let x = init)):</code>, etc.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The `when let` example above is still a pattern, i.e.: `when (Number and (let x = init)):`, etc.","mimetype":"text/plain"},{"body":"The <code>when let</code> example above is still a pattern, i.e.: <code>when (Number and (let x = init)):</code>, etc.","mimetype":"text/html"}]},"ts":1666390006934,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PYviAp43nIc0O_SAFCQjBeN4ZMnsohiovxweJ2qJ088"},
{"content":{"body":"I don't think its too terrible to omit `var` in this case, but even if we left it in scoping for `var` wouldn't change.","format":"org.matrix.custom.html","formatted_body":"I don't think its too terrible to omit <code>var</code> in this case, but even if we left it in scoping for <code>var</code> wouldn't change.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I don't think its too terrible to omit `var` in this case, but even if we left it in scoping for `var` wouldn't change.","mimetype":"text/plain"},{"body":"I don't think its too terrible to omit <code>var</code> in this case, but even if we left it in scoping for <code>var</code> wouldn't change.","mimetype":"text/html"}]},"ts":1666390053295,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cIRscXRixOfGEGjTQPx670vDeskii-YpmywJd-_I54w"},
{"content":{"body":"(i.e., it would hoist and be overwritten if the pattern matches)","msgtype":"m.text","org.matrix.msc1767.text":"(i.e., it would hoist and be overwritten if the pattern matches)"},"ts":1666390068174,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QO0XBmW9EeN-feF38oSlVu77Jq73to7hIRdm9YerNHA"},
{"content":{"body":"pattern matching will have more than its own share of style debates, so that's a lost cause, IMO.","msgtype":"m.text","org.matrix.msc1767.text":"pattern matching will have more than its own share of style debates, so that's a lost cause, IMO."},"ts":1666390098342,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$abgm_cX1DGOBDB9ZlGI8UHIOnUGKY6lkLXowJWPZXBA"},
{"content":{"body":"The bindings dont' ahve to come before the name. they don't today, where the \"binding\" is a pattern itself - you can equally write `a and [...]` or `[...] and a`.","format":"org.matrix.custom.html","formatted_body":"The bindings dont' ahve to come before the name. they don't today, where the &quot;binding&quot; is a pattern itself - you can equally write <code>a and [...]</code> or <code>[...] and a</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The bindings dont' ahve to come before the name. they don't today, where the \"binding\" is a pattern itself - you can equally write `a and [...]` or `[...] and a`.","mimetype":"text/plain"},{"body":"The bindings dont' ahve to come before the name. they don't today, where the &quot;binding&quot; is a pattern itself - you can equally write <code>a and [...]</code> or <code>[...] and a</code>.","mimetype":"text/html"}]},"ts":1666390592060,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$wbh_Y_-SVyap_deZtiwW2gu2CH1rg_VWhbzNXspsxpo"},
{"content":{"body":"And that would continue to be true since `let x` or whatever is just our new spelling for irrefutable matchers","format":"org.matrix.custom.html","formatted_body":"And that would continue to be true since <code>let x</code> or whatever is just our new spelling for irrefutable matchers","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"And that would continue to be true since `let x` or whatever is just our new spelling for irrefutable matchers","mimetype":"text/plain"},{"body":"And that would continue to be true since <code>let x</code> or whatever is just our new spelling for irrefutable matchers","mimetype":"text/html"}]},"ts":1666390621249,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$5kH5L4sDAPnGNhDZ8nTY3WYbtzYIzFl-DGjnfsW6CSY"},
{"content":{"body":"I still think going with `as X` for the spelling is best, akin to imports.","format":"org.matrix.custom.html","formatted_body":"I still think going with <code>as X</code> for the spelling is best, akin to imports.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I still think going with `as X` for the spelling is best, akin to imports.","mimetype":"text/plain"},{"body":"I still think going with <code>as X</code> for the spelling is best, akin to imports.","mimetype":"text/html"}]},"ts":1666390662979,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$uBY-ijkCpx-dRYvZJhxbov4VwoY08CMocKKDZvdj-lI"},
{"content":{"body":"I suspect that if we ever do unify destructuring with import syntax, it'll be done precisely by adding the `as X` syntax to destructuring","format":"org.matrix.custom.html","formatted_body":"I suspect that if we ever do unify destructuring with import syntax, it'll be done precisely by adding the <code>as X</code> syntax to destructuring","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I suspect that if we ever do unify destructuring with import syntax, it'll be done precisely by adding the `as X` syntax to destructuring","mimetype":"text/plain"},{"body":"I suspect that if we ever do unify destructuring with import syntax, it'll be done precisely by adding the <code>as X</code> syntax to destructuring","mimetype":"text/html"}]},"ts":1666390692105,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$kuxieiVlzT7ga1mL8wdjdx0wGI29_4cY9DrRH5waF34"},
{"content":{"body":"(And yeah, I feel like `{x: y@}` looks a little weird; I'd prefer to stick with the model that it's just an irrefutable matcher if we can, as then it works automatically with everything without us having to add any more cases to the grammar.)","format":"org.matrix.custom.html","formatted_body":"(And yeah, I feel like <code>{x: y@}</code> looks a little weird; I'd prefer to stick with the model that it's just an irrefutable matcher if we can, as then it works automatically with everything without us having to add any more cases to the grammar.)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"(And yeah, I feel like `{x: y@}` looks a little weird; I'd prefer to stick with the model that it's just an irrefutable matcher if we can, as then it works automatically with everything without us having to add any more cases to the grammar.)","mimetype":"text/plain"},{"body":"(And yeah, I feel like <code>{x: y@}</code> looks a little weird; I'd prefer to stick with the model that it's just an irrefutable matcher if we can, as then it works automatically with everything without us having to add any more cases to the grammar.)","mimetype":"text/html"}]},"ts":1666390777069,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$jEolL9dBYlE3L9qDlpBP5sWpcGByDaZCADYza7pS5M0"},
{"content":{"body":"`as X` doesn't let you specify mutability though, or let us open the door to other variable types like `using` (not sure I would allow `using` in there, but there could be others).","format":"org.matrix.custom.html","formatted_body":"<code>as X</code> doesn't let you specify mutability though, or let us open the door to other variable types like <code>using</code> (not sure I would allow <code>using</code> in there, but there could be others).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`as X` doesn't let you specify mutability though, or let us open the door to other variable types like `using` (not sure I would allow `using` in there, but there could be others).","mimetype":"text/plain"},{"body":"<code>as X</code> doesn't let you specify mutability though, or let us open the door to other variable types like <code>using</code> (not sure I would allow <code>using</code> in there, but there could be others).","mimetype":"text/html"}]},"ts":1666390833593,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$aXukpK5DrkpokwglKUKN_U7zA3whn7CpY-gIcs1coyc"},
{"content":{"body":"why bother with reassignable variables at all tho (assignment !== mutability :-p )","msgtype":"m.text","org.matrix.msc1767.text":"why bother with reassignable variables at all tho (assignment !== mutability :-p )"},"ts":1666390860037,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$5nejs1JKMJW8DZeVVa3e3X4viqmO6KcbnRSXsGiyTC8"},
{"content":{"body":"you can do `let x = y;` in the RHS if you really need that","format":"org.matrix.custom.html","formatted_body":"you can do <code>let x = y;</code> in the RHS if you really need that","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"you can do `let x = y;` in the RHS if you really need that","mimetype":"text/plain"},{"body":"you can do <code>let x = y;</code> in the RHS if you really need that","mimetype":"text/html"}]},"ts":1666390870631,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$UWVvBGO3c7DmO1HLjwgGttp1gdXh10GoIQlsr3SsD30"},
{"content":{"body":"yeah just make them all const bindings imo","msgtype":"m.text","org.matrix.msc1767.text":"yeah just make them all const bindings imo"},"ts":1666390881400,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$uFzHR6Si2CLLBTNjC9aJymuOdo294aTeYq8LvPhpVpY"},
{"content":{"body":"(binding mutability, i.e. Rust's `let` is a constant binding, but `let mut` is a mutable binding).","format":"org.matrix.custom.html","formatted_body":"(binding mutability, i.e. Rust's <code>let</code> is a constant binding, but <code>let mut</code> is a mutable binding).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"(binding mutability, i.e. Rust's `let` is a constant binding, but `let mut` is a mutable binding).","mimetype":"text/plain"},{"body":"(binding mutability, i.e. Rust's <code>let</code> is a constant binding, but <code>let mut</code> is a mutable binding).","mimetype":"text/html"}]},"ts":1666390896873,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HtsyLCbT_wLAc4UbPHRJFVQC-4hPotVSJ5eK_n7dGzg"},
{"content":{"body":"> <@ljharb:matrix.org> you can do `let x = y;` in the RHS if you really need that\n\nBut only once we get `do` expressions.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$UWVvBGO3c7DmO1HLjwgGttp1gdXh10GoIQlsr3SsD30?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>you can do <code>let x = y;</code> in the RHS if you really need that</blockquote></mx-reply>But only once we get <code>do</code> expressions.","m.relates_to":{"m.in_reply_to":{"event_id":"$UWVvBGO3c7DmO1HLjwgGttp1gdXh10GoIQlsr3SsD30"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@ljharb:matrix.org> you can do `let x = y;` in the RHS if you really need that\n\nBut only once we get `do` expressions.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$UWVvBGO3c7DmO1HLjwgGttp1gdXh10GoIQlsr3SsD30?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>you can do <code>let x = y;</code> in the RHS if you really need that</blockquote></mx-reply>But only once we get <code>do</code> expressions.","mimetype":"text/html"}]},"ts":1666390919588,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2q1ekhL3oHiPOxqAyohOBLjPHglaW9hEpyGbxfkz96s"},
{"content":{"body":"which we will!","msgtype":"m.text","org.matrix.msc1767.text":"which we will!"},"ts":1666390930115,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$jCyIrohyb1IrvDMD1hY1aVJi3AlV8F6dsC4tqhxbZhA"},
{"content":{"body":"or, annoyingly, with an iiafe","msgtype":"m.text","org.matrix.msc1767.text":"or, annoyingly, with an iiafe"},"ts":1666390945211,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$cH-6A36840gA8j-j4KMPjOLd4h5OyQlicM1d7erDHVQ"},
{"content":{"body":"(still wants `throw` expressions)","format":"org.matrix.custom.html","formatted_body":"(still wants <code>throw</code> expressions)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"(still wants `throw` expressions)","mimetype":"text/plain"},{"body":"(still wants <code>throw</code> expressions)","mimetype":"text/html"}]},"ts":1666390949955,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$93BQ2caLZScZs9SPcls3jnWJEvuwYp9GtHRCCkTs6Q0"},
{"content":{"body":"right, pattern matching is an expression solely because we're assuming do expressions advance","msgtype":"m.text","org.matrix.msc1767.text":"right, pattern matching is an expression solely because we're assuming do expressions advance"},"ts":1666390959439,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$hIBqYIxRCfKlLvxuJ2z4dTdanv3HtvCnRl2u6yMX6Ro"},
{"content":{"body":"still not a huge fan of `as`, but its better than `@` and has the same meaning. `when { x: as y }` isn't much different than `when { x: let y }`, but it definitely means TypeScript won't be able to use `as` as a cast in a pattern (which is potentially a thing we'd need with custom matchers).","format":"org.matrix.custom.html","formatted_body":"still not a huge fan of <code>as</code>, but its better than <code>@</code> and has the same meaning. <code>when { x: as y }</code> isn't much different than <code>when { x: let y }</code>, but it definitely means TypeScript won't be able to use <code>as</code> as a cast in a pattern (which is potentially a thing we'd need with custom matchers).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"still not a huge fan of `as`, but its better than `@` and has the same meaning. `when { x: as y }` isn't much different than `when { x: let y }`, but it definitely means TypeScript won't be able to use `as` as a cast in a pattern (which is potentially a thing we'd need with custom matchers).","mimetype":"text/plain"},{"body":"still not a huge fan of <code>as</code>, but its better than <code>@</code> and has the same meaning. <code>when { x: as y }</code> isn't much different than <code>when { x: let y }</code>, but it definitely means TypeScript won't be able to use <code>as</code> as a cast in a pattern (which is potentially a thing we'd need with custom matchers).","mimetype":"text/html"}]},"ts":1666391111159,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rNqq1HqXVlIVihGIxFWI_TQXMc0PxRSz4r2x-qHgJsY"},
{"content":{"body":"We definitely don't want to use `<T>x` as a cast, since I hope we one day have relational patterns even if it's not in the MVP.","format":"org.matrix.custom.html","formatted_body":"We definitely don't want to use <code>&lt;T&gt;x</code> as a cast, since I hope we one day have relational patterns even if it's not in the MVP.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"We definitely don't want to use `<T>x` as a cast, since I hope we one day have relational patterns even if it's not in the MVP.","mimetype":"text/plain"},{"body":"We definitely don't want to use <code>&lt;T&gt;x</code> as a cast, since I hope we one day have relational patterns even if it's not in the MVP.","mimetype":"text/html"}]},"ts":1666391144189,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$yvOqIzMiL_Tm1_R4h3uU0QQiZyPxtEZkkHdZh4RQ7rk"},
{"content":{"body":"ugh, yeah TS overlap is annoying.","msgtype":"m.text","org.matrix.msc1767.text":"ugh, yeah TS overlap is annoying."},"ts":1666391159430,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$lCtHzkqpRglLQPIlDZq9sgG-Mam0IfH3XxYa3QSXJtg"},
{"content":{"body":"It's not so bad for `import`/`export`, but if you want to extend `as` to destructuring we could have serious issues.","format":"org.matrix.custom.html","formatted_body":"It's not so bad for <code>import</code>/<code>export</code>, but if you want to extend <code>as</code> to destructuring we could have serious issues.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"It's not so bad for `import`/`export`, but if you want to extend `as` to destructuring we could have serious issues.","mimetype":"text/plain"},{"body":"It's not so bad for <code>import</code>/<code>export</code>, but if you want to extend <code>as</code> to destructuring we could have serious issues.","mimetype":"text/html"}]},"ts":1666391195497,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kz1bv5TYaQVZxqEXtApaAgW1oyt6-HF44VvkEYBM4ZU"},
{"content":{"body":"we=TypeScript","msgtype":"m.text","org.matrix.msc1767.text":"we=TypeScript"},"ts":1666391209114,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ngd8i6zdZGnbKDi951n7LoqQMiyYZOvaKN0U4_UQ14A"},
{"content":{"body":"Since we allow casts of simple assignment targets:\n\n````ts\nlet x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n````","format":"org.matrix.custom.html","formatted_body":"<p>Since we allow casts of simple assignment targets:</p>\n<pre><code class=\"language-ts\">let x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Since we allow casts of simple assignment targets:\n\n````ts\nlet x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n````","mimetype":"text/plain"},{"body":"<p>Since we allow casts of simple assignment targets:</p>\n<pre><code class=\"language-ts\">let x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n</code></pre>\n","mimetype":"text/html"}]},"ts":1666391310230,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YbLn95BnWI964HcS0rV-VZUNnLLFlXFtc0TFYBtUFi0"},
{"content":{"body":" * Since we allow casts of simple assignment targets:\n\n````ts\nlet x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n````","format":"org.matrix.custom.html","formatted_body":" * <p>Since we allow casts of simple assignment targets:</p>\n<pre><code class=\"language-ts\">let x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n</code></pre>\n","m.new_content":{"body":"Since we allow casts of simple assignment targets:\n\n````ts\nlet x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n````","format":"org.matrix.custom.html","formatted_body":"<p>Since we allow casts of simple assignment targets:</p>\n<pre><code class=\"language-ts\">let x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Since we allow casts of simple assignment targets:\n\n````ts\nlet x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n````","mimetype":"text/plain"},{"body":"<p>Since we allow casts of simple assignment targets:</p>\n<pre><code class=\"language-ts\">let x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$YbLn95BnWI964HcS0rV-VZUNnLLFlXFtc0TFYBtUFi0","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Since we allow casts of simple assignment targets:\n\n````ts\nlet x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n````","mimetype":"text/plain"},{"body":" * <p>Since we allow casts of simple assignment targets:</p>\n<pre><code class=\"language-ts\">let x: any;\n(x as number) = 1;\n[x as number] = [1];\n({ x: x as number } = { x: 1 });\n</code></pre>\n","mimetype":"text/html"}]},"ts":1666391314219,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$idws_FLLAkDhilgZnD_9QdenE89Fcr0t0MMZs4RiRYM"},
{"content":{"body":"oh, funky, ok","msgtype":"m.text","org.matrix.msc1767.text":"oh, funky, ok"},"ts":1666391349016,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$ujFjKKACLtMYzP-Cd3RBY8OjlT84GtzyLhu7U4oGAhs"},
{"content":{"body":"python does that by just having you mention the variable beforehand","msgtype":"m.text","org.matrix.msc1767.text":"python does that by just having you mention the variable beforehand"},"ts":1666391365191,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$gCNvfzFltqOsIfFYUM2AtVs7PCEZpjyXbeBSDdtKAI4"}
]