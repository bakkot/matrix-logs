[
{"content":{"body":"so what's next? change `{ a }` from direct match to `{ a: let a }`? is this valid? `{ a: let {x, y} }`?","format":"org.matrix.custom.html","formatted_body":"so what's next? change <code>{ a }</code> from direct match to <code>{ a: let a }</code>? is this valid? <code>{ a: let {x, y} }</code>?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"so what's next? change `{ a }` from direct match to `{ a: let a }`? is this valid? `{ a: let {x, y} }`?","mimetype":"text/plain"},{"body":"so what's next? change <code>{ a }</code> from direct match to <code>{ a: let a }</code>? is this valid? <code>{ a: let {x, y} }</code>?","mimetype":"text/html"}]},"ts":1666361742035,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$K4nw6yRWdT2RoGCYJIIp9_HQWoLgmWDDdMtb9_xX97A"},
{"content":{"body":"i'm still not comfortable with that direction, especially including let and/or const (and/or var)","msgtype":"m.text","org.matrix.msc1767.text":"i'm still not comfortable with that direction, especially including let and/or const (and/or var)"},"ts":1666370778898,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$pSSBdcFbeicXsQDpoo4xA9yk3cagGWGxRm2dNYKk2wE"},
{"content":{"body":" * i'm still not comfortable with that direction, especially including let and/or const (and/or var)","m.new_content":{"body":"i'm still not comfortable with that direction, especially including let and/or const (and/or var)","msgtype":"m.text","org.matrix.msc1767.text":"i'm still not comfortable with that direction, especially including let and/or const (and/or var)"},"m.relates_to":{"event_id":"$pSSBdcFbeicXsQDpoo4xA9yk3cagGWGxRm2dNYKk2wE","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * i'm still not comfortable with that direction, especially including let and/or const (and/or var)"},"ts":1666370781972,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$wwhuYzEoVu2yUiHedE8v9VOFLPku6iNyP2jraoKTQhI"},
{"content":{"body":"I'm open to other ideas, though I'm not in favor of completely divorcing declarations from pattern matching. ","format":"org.matrix.custom.html","formatted_body":"I'm open to other ideas, though I'm not in favor of completely divorcing declarations from pattern matching.","msgtype":"m.text"},"ts":1666379370337,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JUfDMRpdumBesvuH2a-d4ldnKn1PtX2eM8C2SrhEgrU"},
{"content":{"body":"While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","format":"org.matrix.custom.html","formatted_body":"While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","mimetype":"text/plain"},{"body":"While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","mimetype":"text/html"}]},"ts":1666379419072,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$d1ckVDtL01qGypqELHKBcwRDZ7onEK4AO6BjKyVjGxo"},
{"content":{"body":" * While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","format":"org.matrix.custom.html","formatted_body":" * While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","m.new_content":{"body":"While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","format":"org.matrix.custom.html","formatted_body":"While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","mimetype":"text/plain"},{"body":"While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$d1ckVDtL01qGypqELHKBcwRDZ7onEK4AO6BjKyVjGxo","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)","mimetype":"text/plain"},{"body":" * While I prefer the explicit <code>let</code>, I'm also partial to Rust-like <code>@</code> bindings (i.e., <code>when { a: Number, b: c @ String }: c</code>)","mimetype":"text/html"}]},"ts":1666379542821,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$oC43JmuKQyHeHfqfoFAtJK01N-imSXCcYoiFyY4P8HA"},
{"content":{"body":"I know `::` was under discussion at some point, but I found the examples confusing. I'm also concerned about using `::` when there have been multiple proposals considering it for call-like behavior that could potentially apply to Extractors as well (i.e., `when { a: foo::Message(b) }` could potentially be a thing)","format":"org.matrix.custom.html","formatted_body":"I know <code>::</code> was under discussion at some point, but I found the examples confusing. I'm also concerned about using <code>::</code> when there have been multiple proposals considering it for call-like behavior that could potentially apply to Extractors as well (i.e., <code>when { a: foo::Message(b) }</code> could potentially be a thing)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I know `::` was under discussion at some point, but I found the examples confusing. I'm also concerned about using `::` when there have been multiple proposals considering it for call-like behavior that could potentially apply to Extractors as well (i.e., `when { a: foo::Message(b) }` could potentially be a thing)","mimetype":"text/plain"},{"body":"I know <code>::</code> was under discussion at some point, but I found the examples confusing. I'm also concerned about using <code>::</code> when there have been multiple proposals considering it for call-like behavior that could potentially apply to Extractors as well (i.e., <code>when { a: foo::Message(b) }</code> could potentially be a thing)","mimetype":"text/html"}]},"ts":1666379731495,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$GVMNI_P4n7K_Lln8Gxg8bV1xQjtESHZyLzh9dBssaJI"},
{"content":{"body":"(I also could never actually quite decipher the `::` examples that were produced, at least not in a consistent way.)","format":"org.matrix.custom.html","formatted_body":"(I also could never actually quite decipher the <code>::</code> examples that were produced, at least not in a consistent way.)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"(I also could never actually quite decipher the `::` examples that were produced, at least not in a consistent way.)","mimetype":"text/plain"},{"body":"(I also could never actually quite decipher the <code>::</code> examples that were produced, at least not in a consistent way.)","mimetype":"text/html"}]},"ts":1666384290821,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$1-SWX93ZD8XDAAxtgcwUPiGjehmb8jkCY988TtY05jc"},
{"content":{"body":"But yeah I don't have a strong opinion on how the irrefutable pattern is spelled.","msgtype":"m.text","org.matrix.msc1767.text":"But yeah I don't have a strong opinion on how the irrefutable pattern is spelled."},"ts":1666384346389,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$3-LOFPypGNXPMFmUDu-A66ZnVsvZChHg0cV144qtiY8"},
{"content":{"body":"The Rust `@` pattern requires you to still specify a pattern, right? You can't just say \"bind to this name, no further checks\"?","format":"org.matrix.custom.html","formatted_body":"The Rust <code>@</code> pattern requires you to still specify a pattern, right? You can't just say &quot;bind to this name, no further checks&quot;?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The Rust `@` pattern requires you to still specify a pattern, right? You can't just say \"bind to this name, no further checks\"?","mimetype":"text/plain"},{"body":"The Rust <code>@</code> pattern requires you to still specify a pattern, right? You can't just say &quot;bind to this name, no further checks&quot;?","mimetype":"text/html"}]},"ts":1666384386140,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$GzHQWhLpxjt6KyBK_3mQbgc3_Va4Le_lqZd21AJGJJo"},
{"content":{"body":"Rust binds by default unless you specify a pattern or identifier that already exists, in which case it treats it as a pattern.","msgtype":"m.text","org.matrix.msc1767.text":"Rust binds by default unless you specify a pattern or identifier that already exists, in which case it treats it as a pattern."},"ts":1666386169331,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$pRK_3jvd7irTMvZ3dd3I3x31ozb8KlwUKpGDGvp0rzE"},
{"content":{"body":"that kind of ambiguity wouldn't work well in JS though.","msgtype":"m.text","org.matrix.msc1767.text":"that kind of ambiguity wouldn't work well in JS though."},"ts":1666386206964,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$gyDNvj4TGVjGuw3KoCvcjFs6VGrfOFUvLUnwzT3xLq4"},
{"content":{"body":"If we did use `@`, it would probably need to be necessary for all bindings. So `when { x: y }` would _always_ treat `y` as a pattern, meaning you'd need to write `when { x: y @ }` to introduce a binding. ","format":"org.matrix.custom.html","formatted_body":"If we did use <code>@</code>, it would probably need to be necessary for all bindings. So <code>when { x: y }</code> would <em>always</em> treat <code>y</code> as a pattern, meaning you'd need to write <code>when { x: y @ }</code> to introduce a binding.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"If we did use `@`, it would probably need to be necessary for all bindings. So `when { x: y }` would _always_ treat `y` as a pattern, meaning you'd need to write `when { x: y @ }` to introduce a binding. ","mimetype":"text/plain"},{"body":"If we did use <code>@</code>, it would probably need to be necessary for all bindings. So <code>when { x: y }</code> would <em>always</em> treat <code>y</code> as a pattern, meaning you'd need to write <code>when { x: y @ }</code> to introduce a binding.","mimetype":"text/html"}]},"ts":1666386399559,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$2jlEo4o_uSBZcZwUXHPdpSnuQkfuuurWcTtp8CqZfsc"},
{"content":{"body":"That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y & pattern }` to bind *and* match. The `let` syntax is not as terse, but its much less ambiguous.","format":"org.matrix.custom.html","formatted_body":"That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y &amp; pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y & pattern }` to bind *and* match. The `let` syntax is not as terse, but its much less ambiguous.","mimetype":"text/plain"},{"body":"That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y &amp; pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","mimetype":"text/html"}]},"ts":1666386483040,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RSXWV59LHjOW6z1tlZzZr0O19scpqSyBF2p2shXyn_c"},
{"content":{"body":"Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n```js\nwhen { x: let a & let b }: [++a, --b],\nwhen { y: const originalY & let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\nYou can't really do that with `@`","format":"org.matrix.custom.html","formatted_body":"<p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a &amp; let b }: [++a, --b],\nwhen { y: const originalY &amp; let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n```js\nwhen { x: let a & let b }: [++a, --b],\nwhen { y: const originalY & let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\nYou can't really do that with `@`","mimetype":"text/plain"},{"body":"<p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a &amp; let b }: [++a, --b],\nwhen { y: const originalY &amp; let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","mimetype":"text/html"}]},"ts":1666386676898,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$C1y36OxNjhqtb4eMpBhYZ9oao-cLBeMnppN3qFzcMeU"},
{"content":{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","format":"org.matrix.custom.html","formatted_body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","mimetype":"text/plain"},{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","mimetype":"text/html"}]},"ts":1666386882983,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JA_-Md1d8vQROieaK47z9ZpyAcqU-PfoDZCUsM5vV_8"},
{"content":{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","format":"org.matrix.custom.html","formatted_body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","m.new_content":{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","format":"org.matrix.custom.html","formatted_body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","mimetype":"text/plain"},{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$JA_-Md1d8vQROieaK47z9ZpyAcqU-PfoDZCUsM5vV_8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a & Number }` though.","mimetype":"text/plain"},{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a &amp; Number }</code> though.","mimetype":"text/html"}]},"ts":1666386893871,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8jM_doc9kzOeaBIgK-3QMEWRav0jQ30v5TvJK76zs10"},
{"content":{"body":" * Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n\n```js\nwhen { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\n\nYou can't really do that with `@`","format":"org.matrix.custom.html","formatted_body":" * <p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","m.new_content":{"body":"Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n\n```js\nwhen { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\n\nYou can't really do that with `@`","format":"org.matrix.custom.html","formatted_body":"<p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n\n```js\nwhen { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\n\nYou can't really do that with `@`","mimetype":"text/plain"},{"body":"<p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$C1y36OxNjhqtb4eMpBhYZ9oao-cLBeMnppN3qFzcMeU","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * Plus, `let` is more flexible. with `let` you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:\n\n```js\nwhen { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n```\n\nYou can't really do that with `@`","mimetype":"text/plain"},{"body":" * <p>Plus, <code>let</code> is more flexible. with <code>let</code> you can create multiple bindings for the same value, or a mutable and immutable binding, i.e.:</p>\n<pre><code class=\"language-js\">when { x: let a and let b }: [++a, --b],\nwhen { y: const originalY and let changedY }: originalY === (changedY %= 10) ? changedY : originalY,\n</code></pre>\n<p>You can't really do that with <code>@</code></p>\n","mimetype":"text/html"}]},"ts":1666387157244,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ox4yM3GKKj6Ya5KiNCVtX9X9pC6uEHoT3o8zG3IS8Uk"},
{"content":{"body":" * That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y and pattern }` to bind _and_ match. The `let` syntax is not as terse, but its much less ambiguous.","format":"org.matrix.custom.html","formatted_body":" * That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y and pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","m.new_content":{"body":"That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y and pattern }` to bind _and_ match. The `let` syntax is not as terse, but its much less ambiguous.","format":"org.matrix.custom.html","formatted_body":"That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y and pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y and pattern }` to bind _and_ match. The `let` syntax is not as terse, but its much less ambiguous.","mimetype":"text/plain"},{"body":"That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y and pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$RSXWV59LHjOW6z1tlZzZr0O19scpqSyBF2p2shXyn_c","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y and pattern }` to bind _and_ match. The `let` syntax is not as terse, but its much less ambiguous.","mimetype":"text/plain"},{"body":" * That syntax seems a little awkward, which is why I still prefer <code>when { x: let y }</code> to introduce a binding and <code>when { x: let y and pattern }</code> to bind <em>and</em> match. The <code>let</code> syntax is not as terse, but its much less ambiguous.","mimetype":"text/html"}]},"ts":1666387164099,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mLoAKvHgMN-jKHIxrWEWULf5B5LwW2Ok55kkzSQP0bk"},
{"content":{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a and Number }` though.","format":"org.matrix.custom.html","formatted_body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a and Number }</code> though.","m.new_content":{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a and Number }` though.","format":"org.matrix.custom.html","formatted_body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a and Number }</code> though.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a and Number }` though.","mimetype":"text/plain"},{"body":"I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a and Number }</code> though.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$JA_-Md1d8vQROieaK47z9ZpyAcqU-PfoDZCUsM5vV_8","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against `when { a: let { x, y } }`. I could potentially see `when { a: { let x, let y } }` as a shorthand for `when { a: { x: let x, y: let y } }`, as well as `when { let a: Number }` as a shorthand for `when { a: let a and Number }` though.","mimetype":"text/plain"},{"body":" * I'm a bit wary of mixing pattern matching and destructuring, so I'm weakly against <code>when { a: let { x, y } }</code>. I could potentially see <code>when { a: { let x, let y } }</code> as a shorthand for <code>when { a: { x: let x, y: let y } }</code>, as well as <code>when { let a: Number }</code> as a shorthand for <code>when { a: let a and Number }</code> though.","mimetype":"text/html"}]},"ts":1666387176726,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$JO9mbiVRa1FZVqC8hV8ngkb18vr0RMc4h4js_RPbmZ4"},
{"content":{"body":"`let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","mimetype":"text/plain"},{"body":"<p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1666387378221,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7HdVQMpMp0Qh509CkMvaS6myVLPkdeWBCBPMICEKM_o"},
{"content":{"body":" * `let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","m.new_content":{"body":"`let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","mimetype":"text/plain"},{"body":"<p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$7HdVQMpMp0Qh509CkMvaS6myVLPkdeWBCBPMICEKM_o","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * `let` also gives you a convenient place to attach an initializer:\n\n```js\nmatch (x) {\n  when { kind: \"a\" }: ...,\n  when { kind: \"b\" }: ...,\n  when { kind: let kind = \"<missing>\" }: print(`unknown kind: ${kind}`),\n  when let other = \"<missing>\": print(`unknown input: ${other}`)\n}\n```","mimetype":"text/plain"},{"body":" * <p><code>let</code> also gives you a convenient place to attach an initializer:</p>\n<pre><code class=\"language-js\">match (x) {\n  when { kind: &quot;a&quot; }: ...,\n  when { kind: &quot;b&quot; }: ...,\n  when { kind: let kind = &quot;&lt;missing&gt;&quot; }: print(`unknown kind: ${kind}`),\n  when let other = &quot;&lt;missing&gt;&quot;: print(`unknown input: ${other}`)\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1666387386950,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4XbXve-1NUMW5Lp11XNXSaBPOXyGinzBnne1Cj6Usmw"},
{"content":{"body":"i mean, regardless, imo the pattern must come first","msgtype":"m.text","org.matrix.msc1767.text":"i mean, regardless, imo the pattern must come first"},"ts":1666388216651,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$mXdIU5wl3dRuJUS3yOIeQLOnziNip1TXqy9GdMl-YHY"},
{"content":{"body":"since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern","msgtype":"m.text","org.matrix.msc1767.text":"since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern"},"ts":1666388231129,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$g4MGHmXXmW0KWvkK9Gvw6O8oFQtkMX2_GZLjCohPLUA"},
{"content":{"body":"using `let` would be fine if we only had one way to make vars, but we have 3, and it's very weird and confusing and inconsistent if we have 1 but not all 3 - and regardless, it forces the linting community to come up with a convention, or adapt existing linting rules, and creates another source of style arguments for no benefit i can see","format":"org.matrix.custom.html","formatted_body":"using <code>let</code> would be fine if we only had one way to make vars, but we have 3, and it's very weird and confusing and inconsistent if we have 1 but not all 3 - and regardless, it forces the linting community to come up with a convention, or adapt existing linting rules, and creates another source of style arguments for no benefit i can see","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"using `let` would be fine if we only had one way to make vars, but we have 3, and it's very weird and confusing and inconsistent if we have 1 but not all 3 - and regardless, it forces the linting community to come up with a convention, or adapt existing linting rules, and creates another source of style arguments for no benefit i can see","mimetype":"text/plain"},{"body":"using <code>let</code> would be fine if we only had one way to make vars, but we have 3, and it's very weird and confusing and inconsistent if we have 1 but not all 3 - and regardless, it forces the linting community to come up with a convention, or adapt existing linting rules, and creates another source of style arguments for no benefit i can see","mimetype":"text/html"}]},"ts":1666388276684,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$pUfSv9tMmlPjrE_hLEmbCPXNC_Jp54Jx-Nnb04Cm7Ko"},
{"content":{"body":"i'm perfectly comfortable with a syntactic marker for bindings, it's just that the language has no precedent for that besides let/const/var, or \"nothing/everything\", a la destructuring (where there's a marker outside the pattern but not inline on individual bindings)","msgtype":"m.text","org.matrix.msc1767.text":"i'm perfectly comfortable with a syntactic marker for bindings, it's just that the language has no precedent for that besides let/const/var, or \"nothing/everything\", a la destructuring (where there's a marker outside the pattern but not inline on individual bindings)"},"ts":1666388332566,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$IL0_GNH1APwvkcruDjlo129X1BO2y6fcPbseTCfUcHM"},
{"content":{"body":"When I talk about adding `let` bindings, I am also including `const`. I don't have a preference on `var`.","format":"org.matrix.custom.html","formatted_body":"When I talk about adding <code>let</code> bindings, I am also including <code>const</code>. I don't have a preference on <code>var</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"When I talk about adding `let` bindings, I am also including `const`. I don't have a preference on `var`.","mimetype":"text/plain"},{"body":"When I talk about adding <code>let</code> bindings, I am also including <code>const</code>. I don't have a preference on <code>var</code>.","mimetype":"text/html"}]},"ts":1666389697077,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$S4T3XCjk0TiZLDOxYkp04xL5KbE4WD6wH-77KSorJEI"},
{"content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}],"m.relates_to":{"m.in_reply_to":{"event_id":"$g4MGHmXXmW0KWvkK9Gvw6O8oFQtkMX2_GZLjCohPLUA"}}},"ts":1666389846314,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY"},
{"content":{"body":"> <@ljharb:matrix.org> since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern\n\n * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }`and`when { a: Number and let x }` are pretty much the same. With Rust's`@`syntax, the binding comes first, i.e.`when { x: Binding @ Pattern }\\`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$g4MGHmXXmW0KWvkK9Gvw6O8oFQtkMX2_GZLjCohPLUA?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern</blockquote></mx-reply> * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }<code>and</code>when { a: Number and let x }<code> are pretty much the same. With Rust's</code>@<code>syntax, the binding comes first, i.e.</code>when { x: Binding @ Pattern }`.","m.new_content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }`and`when { a: Number and let x }` are pretty much the same. With Rust's`@`syntax, the binding comes first, i.e.`when { x: Binding @ Pattern }\\`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }<code>and</code>when { a: Number and let x }<code> are pretty much the same. With Rust's</code>@<code>syntax, the binding comes first, i.e.</code>when { x: Binding @ Pattern }`.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }`and`when { a: Number and let x }` are pretty much the same. With Rust's`@`syntax, the binding comes first, i.e.`when { x: Binding @ Pattern }\\`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }<code>and</code>when { a: Number and let x }<code> are pretty much the same. With Rust's</code>@<code>syntax, the binding comes first, i.e.</code>when { x: Binding @ Pattern }`.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@ljharb:matrix.org> since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern\n\n * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }`and`when { a: Number and let x }` are pretty much the same. With Rust's`@`syntax, the binding comes first, i.e.`when { x: Binding @ Pattern }\\`.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$g4MGHmXXmW0KWvkK9Gvw6O8oFQtkMX2_GZLjCohPLUA?via=matrix.org&amp;via=mozilla.org&amp;via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>since the bindings are not bound unless the pattern matches, it wouldn't make sense to have the bindings come before the pattern</blockquote></mx-reply> * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when { a: let x and Number }<code>and</code>when { a: Number and let x }<code> are pretty much the same. With Rust's</code>@<code>syntax, the binding comes first, i.e.</code>when { x: Binding @ Pattern }`.","mimetype":"text/html"}]},"ts":1666389851399,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-M_bUVvhJL8px0lq6boAKGeesBZ4mCv7b17n0NWtlC8"},
{"content":{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's`@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's<code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","m.new_content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's`@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's<code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's`@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's<code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's`@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's<code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"ts":1666389872621,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8IAFnESJbs8KpF6oLoo3joQmY67ZIsEbXCZYcR-Qj_U"},
{"content":{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","m.new_content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. when `{ a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. when <code>{ a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"ts":1666389878579,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IpWy-_nxhijfqFi__gKErPnP_IPFDAiYoXq3qw3j_LQ"},
{"content":{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","m.new_content":{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","format":"org.matrix.custom.html","formatted_body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":"With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$425YxF9l0bI0kZBKgVX_Mg49feuk0TtpHH-44wHzoMY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * With `let` bindings, the `let x` _is_ a pattern (an irrefutable one that always matches), so order doesn't matter. `when { a: let x and Number }` and `when { a: Number and let x }` are pretty much the same. With Rust's `@` syntax, the binding comes first, i.e. `when { x: Binding @ Pattern }`.","mimetype":"text/plain"},{"body":" * With <code>let</code> bindings, the <code>let x</code> <em>is</em> a pattern (an irrefutable one that always matches), so order doesn't matter. <code>when { a: let x and Number }</code> and <code>when { a: Number and let x }</code> are pretty much the same. With Rust's <code>@</code> syntax, the binding comes first, i.e. <code>when { x: Binding @ Pattern }</code>.","mimetype":"text/html"}]},"ts":1666389897003,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vC0K3FQRvfWnHHUnPwklPv8-B23wdKtYA2QRFdpZEJo"},
{"content":{"body":"for an inline `let` i think that's probably fine","format":"org.matrix.custom.html","formatted_body":"for an inline <code>let</code> i think that's probably fine","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"for an inline `let` i think that's probably fine","mimetype":"text/plain"},{"body":"for an inline <code>let</code> i think that's probably fine","mimetype":"text/html"}]},"ts":1666389915399,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$vFKDGdXL58dF5IkLe75t_osQ6eGtzYRkbHNeuj-g2Q4"},
{"content":{"body":"my ordering reaction is more to the `when let` suggestions, where there's a \"binding space\" and a \"pattern space\"","format":"org.matrix.custom.html","formatted_body":"my ordering reaction is more to the <code>when let</code> suggestions, where there's a &quot;binding space&quot; and a &quot;pattern space&quot;","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"my ordering reaction is more to the `when let` suggestions, where there's a \"binding space\" and a \"pattern space\"","mimetype":"text/plain"},{"body":"my ordering reaction is more to the <code>when let</code> suggestions, where there's a &quot;binding space&quot; and a &quot;pattern space&quot;","mimetype":"text/html"}]},"ts":1666389931575,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$sYbF12xJWzfS74dRhIvmd15ydDZ5lH_5Llr9ulsYtgc"},
{"content":{"body":"but including var is problematic because of scoping, and including const/let would be \"fine\" but weird to omit var and also would create those style debates that would be best avoided","msgtype":"m.text","org.matrix.msc1767.text":"but including var is problematic because of scoping, and including const/let would be \"fine\" but weird to omit var and also would create those style debates that would be best avoided"},"ts":1666389967148,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$jLcES12p7GEaoWB5YrmQwmGw3SY6l8RM9nz-vPFEDJE"},
{"content":{"body":"The `when let` example above is still a pattern, i.e.: `when (Number and (let x = init)):`, etc.","format":"org.matrix.custom.html","formatted_body":"The <code>when let</code> example above is still a pattern, i.e.: <code>when (Number and (let x = init)):</code>, etc.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The `when let` example above is still a pattern, i.e.: `when (Number and (let x = init)):`, etc.","mimetype":"text/plain"},{"body":"The <code>when let</code> example above is still a pattern, i.e.: <code>when (Number and (let x = init)):</code>, etc.","mimetype":"text/html"}]},"ts":1666390006934,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PYviAp43nIc0O_SAFCQjBeN4ZMnsohiovxweJ2qJ088"},
{"content":{"body":"I don't think its too terrible to omit `var` in this case, but even if we left it in scoping for `var` wouldn't change.","format":"org.matrix.custom.html","formatted_body":"I don't think its too terrible to omit <code>var</code> in this case, but even if we left it in scoping for <code>var</code> wouldn't change.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I don't think its too terrible to omit `var` in this case, but even if we left it in scoping for `var` wouldn't change.","mimetype":"text/plain"},{"body":"I don't think its too terrible to omit <code>var</code> in this case, but even if we left it in scoping for <code>var</code> wouldn't change.","mimetype":"text/html"}]},"ts":1666390053295,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cIRscXRixOfGEGjTQPx670vDeskii-YpmywJd-_I54w"},
{"content":{"body":"(i.e., it would hoist and be overwritten if the pattern matches)","msgtype":"m.text","org.matrix.msc1767.text":"(i.e., it would hoist and be overwritten if the pattern matches)"},"ts":1666390068174,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QO0XBmW9EeN-feF38oSlVu77Jq73to7hIRdm9YerNHA"},
{"content":{"body":"pattern matching will have more than its own share of style debates, so that's a lost cause, IMO.","msgtype":"m.text","org.matrix.msc1767.text":"pattern matching will have more than its own share of style debates, so that's a lost cause, IMO."},"ts":1666390098342,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$abgm_cX1DGOBDB9ZlGI8UHIOnUGKY6lkLXowJWPZXBA"}
]