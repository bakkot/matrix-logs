[
{"content":{"body":"TabAtkins: I posted a reply to your comment on #281 (https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1487092535), but think it might be better to go into more detail here. I have some concerns about the the proposed grammar in your gist. Some of it seems unnecessary and it is quite heavy-handed with the use of `when`. ","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@tabatkins:matrix.org\">TabAtkins</a>: I posted a reply to your comment on #281 (https://github.com/tc39/proposal-pattern-matching/issues/281#issuecomment-1487092535), but think it might be better to go into more detail here. I have some concerns about the the proposed grammar in your gist. Some of it seems unnecessary and it is quite heavy-handed with the use of <code>when</code>.","msgtype":"m.text"},"ts":1680017603772,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Pjoeu1WzwkE6h7HuWAS-G5EY6WBxRDMFnf6YBJS-YWY"},
{"content":{"body":"JS syntax is essentially designed to be read in a way that is a rough approximation of English grammar rules, so a phrase like:\n```\nif match(when(pattern) = expression) {\n}\n```\nReads like: \"If match when pattern equals expression, then ...\"\n\nWhile:\n```\nif (expression is pattern) {\n}\n```\nIs far easier to interpret as the English phrase \"If expression is pattern, then\"","format":"org.matrix.custom.html","formatted_body":"<p>JS syntax is essentially designed to be read in a way that is a rough approximation of English grammar rules, so a phrase like:</p>\n<pre><code>if match(when(pattern) = expression) {\n}\n</code></pre>\n<p>Reads like: &quot;If match when pattern equals expression, then ...&quot;</p>\n<p>While:</p>\n<pre><code>if (expression is pattern) {\n}\n</code></pre>\n<p>Is far easier to interpret as the English phrase &quot;If expression is pattern, then&quot;</p>\n","msgtype":"m.text"},"ts":1680017821820,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0dTHfVq5QBuEXgz9qN5bijnXuu3w74T5JhTXsmYlpeM"},
{"content":{"body":"Yeah I'm drafting a response","msgtype":"m.text"},"ts":1680017951234,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$wCq7IbRpjnwhwWl0i9_y_blCpqoVYWtwwsNZ1Erw0BQ"},
{"content":{"body":"`match` works well as an expression form on its own since it also follows English grammar rules:\n\n```\nlet x = match (expression) {\n  when true: doA();\n  when false: doB();\n};\n```\nWhich can be read as: \"Let `x` [be the result of] match[ing] expression.\nWhen [`x` is] `true`, [then] `doA()`.\nWhen [`x` is] `false`, [then] `doB()`.\n[Otherwise, throw an error]\"","format":"org.matrix.custom.html","formatted_body":"<p><code>match</code> works well as an expression form on its own since it also follows English grammar rules:</p>\n<pre><code>let x = match (expression) {\n  when true: doA();\n  when false: doB();\n};\n</code></pre>\n<p>Which can be read as: &quot;Let <code>x</code> [be the result of] match[ing] expression.<br>When [<code>x</code> is] <code>true</code>, [then] <code>doA()</code>.<br>When [<code>x</code> is] <code>false</code>, [then] <code>doB()</code>.<br>[Otherwise, throw an error]&quot;</p>\n","msgtype":"m.text"},"ts":1680018010207,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$MTkgDDIKK-JdmTyq6FEob09xEgg2aBczv1GkM66ul8s"},
{"content":{"body":" * `match` works well as an expression form on its own since it also follows English grammar rules:\n\n```\nlet x = match (expression) {\n  when true: doA();\n  when false: doB();\n};\n```\n\nWhich can be read as: \"Let `x` \\[be the result of\\] match\\[ing\\] `expression`.\nWhen \\[`x` is\\] `true`, \\[then\\] `doA()`.\nWhen \\[`x` is\\] `false`, \\[then\\] `doB()`.\n\\[Otherwise, throw an error\\]\"","format":"org.matrix.custom.html","formatted_body":" * <p><code>match</code> works well as an expression form on its own since it also follows English grammar rules:</p>\n<pre><code>let x = match (expression) {\n  when true: doA();\n  when false: doB();\n};\n</code></pre>\n<p>Which can be read as: &quot;Let <code>x</code> [be the result of] match[ing] <code>expression</code>.<br>When [<code>x</code> is] <code>true</code>, [then] <code>doA()</code>.<br>When [<code>x</code> is] <code>false</code>, [then] <code>doB()</code>.<br>[Otherwise, throw an error]&quot;</p>\n","m.new_content":{"body":"`match` works well as an expression form on its own since it also follows English grammar rules:\n\n```\nlet x = match (expression) {\n  when true: doA();\n  when false: doB();\n};\n```\n\nWhich can be read as: \"Let `x` \\[be the result of\\] match\\[ing\\] `expression`.\nWhen \\[`x` is\\] `true`, \\[then\\] `doA()`.\nWhen \\[`x` is\\] `false`, \\[then\\] `doB()`.\n\\[Otherwise, throw an error\\]\"","format":"org.matrix.custom.html","formatted_body":"<p><code>match</code> works well as an expression form on its own since it also follows English grammar rules:</p>\n<pre><code>let x = match (expression) {\n  when true: doA();\n  when false: doB();\n};\n</code></pre>\n<p>Which can be read as: &quot;Let <code>x</code> [be the result of] match[ing] <code>expression</code>.<br>When [<code>x</code> is] <code>true</code>, [then] <code>doA()</code>.<br>When [<code>x</code> is] <code>false</code>, [then] <code>doB()</code>.<br>[Otherwise, throw an error]&quot;</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$MTkgDDIKK-JdmTyq6FEob09xEgg2aBczv1GkM66ul8s","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1680018023607,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$nEBa7cQJfqXYLkz8QoK1zn5qecB31CpiDFirhavGq4o"},
{"content":{"body":"My biggest concern with your proposed syntax is that it isn't very \"grok\"-able, which was something yulia wanted to make sure we considered.","format":"org.matrix.custom.html","formatted_body":"My biggest concern with your proposed syntax is that it isn't very &quot;grok&quot;-able, which was something <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia</a> wanted to make sure we considered.","msgtype":"m.text"},"ts":1680018083815,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0y9nfziW_o6WPgSvqQjVI21g1alNEPvtk7rnhjXHSSU"},
{"content":{"body":"I've not had time to read that thread properly but I will say from a quick glance that `*if* match(*when*` did make me feel like \"well that won't work\"","format":"org.matrix.custom.html","formatted_body":"I've not had time to read that thread properly but I will say from a quick glance that <code>*if* match(*when*</code> did make me feel like &quot;well that won't work&quot;","msgtype":"m.text"},"ts":1680019449692,"senderName":"rkirsling","senderId":"@rkirsling:matrix.org","id":"$uDlsVyhOEHsPVlcoEDtGF-b05Y68OX2T-e9BPNCapJA"},
{"content":{"body":" * I've not had time to read that thread properly but I will say from a quick glance that *if* match(*when* did make me feel like \"well that won't work\"","format":"org.matrix.custom.html","formatted_body":" * I've not had time to read that thread properly but I will say from a quick glance that <em>if</em> match(<em>when</em> did make me feel like &quot;well that won't work&quot;","m.new_content":{"body":"I've not had time to read that thread properly but I will say from a quick glance that *if* match(*when* did make me feel like \"well that won't work\"","format":"org.matrix.custom.html","formatted_body":"I've not had time to read that thread properly but I will say from a quick glance that <em>if</em> match(<em>when</em> did make me feel like &quot;well that won't work&quot;","msgtype":"m.text"},"m.relates_to":{"event_id":"$uDlsVyhOEHsPVlcoEDtGF-b05Y68OX2T-e9BPNCapJA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1680019463702,"senderName":"rkirsling","senderId":"@rkirsling:matrix.org","id":"$vFdcYeYg0yI8A6f6kwA3wZ4u3j0Sk8PIFMi_17Tt-AM"},
{"content":{"body":" * I've not had time to read that thread properly but I will say from a quick glance that \"**if** match **when**\" did make me feel like \"well that won't work\"","format":"org.matrix.custom.html","formatted_body":" * I've not had time to read that thread properly but I will say from a quick glance that &quot;<strong>if</strong> match <strong>when</strong>&quot; did make me feel like &quot;well that won't work&quot;","m.new_content":{"body":"I've not had time to read that thread properly but I will say from a quick glance that \"**if** match **when**\" did make me feel like \"well that won't work\"","format":"org.matrix.custom.html","formatted_body":"I've not had time to read that thread properly but I will say from a quick glance that &quot;<strong>if</strong> match <strong>when</strong>&quot; did make me feel like &quot;well that won't work&quot;","msgtype":"m.text"},"m.relates_to":{"event_id":"$uDlsVyhOEHsPVlcoEDtGF-b05Y68OX2T-e9BPNCapJA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1680019471300,"senderName":"rkirsling","senderId":"@rkirsling:matrix.org","id":"$G-WqukqCRGFsoegVTe8IeZJap_TwSidr1kXYwy7_ec0"},
{"content":{"body":"I explored a number of novel syntax options in https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb, and the syntax that I favor matches the tenets I laid out in https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b (e.g., concise, expressive, explicit, extensible, and exhaustive).\n\nI proposed `is` expressions because they are concise and compose well with existing syntactic constructs like `if`, `do-while`, `while`, `for`, conditional expressions, `yield`, `await`, arrow functions, and logical operations.\n\nI like `match` expressions because they push developers towards exhaustive matching, and are an improvement both over `switch` (with all of its failings), and conditional expressions (as `match` removes the need to cache the head expression).\n\nI very much favor minimal, yet expressive pattern syntax, such as:\n- Literal constant patterns (i.e., `0`, `null`, `\"hello\"`, etc.)\n- Object and array patterns (i.e., `{ x: 10, y: 20 }`, `[10, 20]`, etc.)\n- Qualified name patterns for custom matchers (i.e., `String`, `Point`, `Option.Some`, etc.)\n- Extractors for nested matching in custom matchers (i.e., `Point({ x: 10, y: 20 })`, `Foo(1, 2)`, etc.)\n- Negation patterns (i.e., `not null`, `not String`, etc.)\n- Disjunction patterns (i.e., `String or Number`, etc.)\n- Conjunction patterns (i.e., `Array and { length: 10 }`, etc.)\n- `let`/`const` patterns (i.e., `Option.Some(let value)`, `{ x: 10, y: let y }`, etc.)\n\nI favor `let`/`const` patterns because they are explicit, recognizable, and familiar. They are also bound \"in place\", which avoids repetition. They also remove the need for `${}` placeholders that are necessary in the current syntax only to differentiate between _references_ to existing variables and _bindings_ produced by the pattern. I generally favor `let`/`const` over Rust's `@` syntax for bindings, as `@` is very confusing in Rust, and would overload the meaning. I find keyword-based syntax to be far easier to introduce over sigil-based syntax due to the limited budget we have remaining in the language for sigils.","format":"org.matrix.custom.html","formatted_body":"<p>I explored a number of novel syntax options in https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb, and the syntax that I favor matches the tenets I laid out in https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b (e.g., concise, expressive, explicit, extensible, and exhaustive).</p>\n<p>I proposed <code>is</code> expressions because they are concise and compose well with existing syntactic constructs like <code>if</code>, <code>do-while</code>, <code>while</code>, <code>for</code>, conditional expressions, <code>yield</code>, <code>await</code>, arrow functions, and logical operations.</p>\n<p>I like <code>match</code> expressions because they push developers towards exhaustive matching, and are an improvement both over <code>switch</code> (with all of its failings), and conditional expressions (as <code>match</code> removes the need to cache the head expression).</p>\n<p>I very much favor minimal, yet expressive pattern syntax, such as:</p>\n<ul>\n<li>Literal constant patterns (i.e., <code>0</code>, <code>null</code>, <code>&quot;hello&quot;</code>, etc.)</li>\n<li>Object and array patterns (i.e., <code>{ x: 10, y: 20 }</code>, <code>[10, 20]</code>, etc.)</li>\n<li>Qualified name patterns for custom matchers (i.e., <code>String</code>, <code>Point</code>, <code>Option.Some</code>, etc.)</li>\n<li>Extractors for nested matching in custom matchers (i.e., <code>Point({ x: 10, y: 20 })</code>, <code>Foo(1, 2)</code>, etc.)</li>\n<li>Negation patterns (i.e., <code>not null</code>, <code>not String</code>, etc.)</li>\n<li>Disjunction patterns (i.e., <code>String or Number</code>, etc.)</li>\n<li>Conjunction patterns (i.e., <code>Array and { length: 10 }</code>, etc.)</li>\n<li><code>let</code>/<code>const</code> patterns (i.e., <code>Option.Some(let value)</code>, <code>{ x: 10, y: let y }</code>, etc.)</li>\n</ul>\n<p>I favor <code>let</code>/<code>const</code> patterns because they are explicit, recognizable, and familiar. They are also bound &quot;in place&quot;, which avoids repetition. They also remove the need for <code>${}</code> placeholders that are necessary in the current syntax only to differentiate between <em>references</em> to existing variables and <em>bindings</em> produced by the pattern. I generally favor <code>let</code>/<code>const</code> over Rust's <code>@</code> syntax for bindings, as <code>@</code> is very confusing in Rust, and would overload the meaning. I find keyword-based syntax to be far easier to introduce over sigil-based syntax due to the limited budget we have remaining in the language for sigils.</p>\n","msgtype":"m.text"},"ts":1680020641029,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$U3ThT66JyjR5KprJ4PTpk2YwsGVZJ72CiIwpFeqxg8A"},
{"content":{"body":" * I explored a number of novel syntax options in https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb, and the syntax that I favor matches the tenets I laid out in https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b (e.g., concise, expressive, explicit, extensible, and exhaustive).\n\nI proposed `is` expressions because they are concise and compose well with existing syntactic constructs like `if`, `do-while`, `while`, `for`, conditional expressions, `yield`, `await`, arrow functions, and logical operations.\n\nI like `match` expressions because they push developers towards exhaustive matching, and are an improvement both over `switch` (with all of its failings), and conditional expressions (as `match` removes the need to cache the head expression).\n\nI very much favor minimal, yet expressive pattern syntax, such as:\n\n- Literal constant patterns (i.e., `0`, `null`, `\"hello\"`, etc.)\n- Object and array patterns (i.e., `{ x: 10, y: 20 }`, `[10, 20]`, etc.)\n- Qualified name patterns for custom matchers (i.e., `String`, `Point`, `Option.Some`, etc.)\n- Extractors for nested matching in custom matchers (i.e., `Point({ x: 10, y: 20 })`, `Foo(1, 2)`, etc.)\n- Negation patterns (i.e., `not null`, `not String`, etc.)\n- Disjunction patterns (i.e., `String or Number`, etc.)\n- Conjunction patterns (i.e., `Array and { length: 10 }`, etc.)\n- `let`/`const` patterns (i.e., `Option.Some(let value)`, `{ x: 10, y: let y }`, etc.)\n\nI favor `let`/`const` patterns because they are explicit, recognizable, and familiar. They are also bound \"in place\", which avoids repetition. They also remove the need for `${}` placeholders that are necessary in the current syntax only to differentiate between _references_ to existing variables and _bindings_ produced by the pattern. I generally favor `let`/`const` over Rust's `@` syntax for bindings, as `@` is very confusing in Rust, and would overload the meaning  of `@` in some contexts (i.e., decorators). I find keyword-based syntax to be far easier to introduce over sigil-based syntax due to the limited budget we have remaining in the language for sigils.","format":"org.matrix.custom.html","formatted_body":" * <p>I explored a number of novel syntax options in https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb, and the syntax that I favor matches the tenets I laid out in https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b (e.g., concise, expressive, explicit, extensible, and exhaustive).</p>\n<p>I proposed <code>is</code> expressions because they are concise and compose well with existing syntactic constructs like <code>if</code>, <code>do-while</code>, <code>while</code>, <code>for</code>, conditional expressions, <code>yield</code>, <code>await</code>, arrow functions, and logical operations.</p>\n<p>I like <code>match</code> expressions because they push developers towards exhaustive matching, and are an improvement both over <code>switch</code> (with all of its failings), and conditional expressions (as <code>match</code> removes the need to cache the head expression).</p>\n<p>I very much favor minimal, yet expressive pattern syntax, such as:</p>\n<ul>\n<li>Literal constant patterns (i.e., <code>0</code>, <code>null</code>, <code>&quot;hello&quot;</code>, etc.)</li>\n<li>Object and array patterns (i.e., <code>{ x: 10, y: 20 }</code>, <code>[10, 20]</code>, etc.)</li>\n<li>Qualified name patterns for custom matchers (i.e., <code>String</code>, <code>Point</code>, <code>Option.Some</code>, etc.)</li>\n<li>Extractors for nested matching in custom matchers (i.e., <code>Point({ x: 10, y: 20 })</code>, <code>Foo(1, 2)</code>, etc.)</li>\n<li>Negation patterns (i.e., <code>not null</code>, <code>not String</code>, etc.)</li>\n<li>Disjunction patterns (i.e., <code>String or Number</code>, etc.)</li>\n<li>Conjunction patterns (i.e., <code>Array and { length: 10 }</code>, etc.)</li>\n<li><code>let</code>/<code>const</code> patterns (i.e., <code>Option.Some(let value)</code>, <code>{ x: 10, y: let y }</code>, etc.)</li>\n</ul>\n<p>I favor <code>let</code>/<code>const</code> patterns because they are explicit, recognizable, and familiar. They are also bound &quot;in place&quot;, which avoids repetition. They also remove the need for <code>${}</code> placeholders that are necessary in the current syntax only to differentiate between <em>references</em> to existing variables and <em>bindings</em> produced by the pattern. I generally favor <code>let</code>/<code>const</code> over Rust's <code>@</code> syntax for bindings, as <code>@</code> is very confusing in Rust, and would overload the meaning  of <code>@</code> in some contexts (i.e., decorators). I find keyword-based syntax to be far easier to introduce over sigil-based syntax due to the limited budget we have remaining in the language for sigils.</p>\n","m.new_content":{"body":"I explored a number of novel syntax options in https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb, and the syntax that I favor matches the tenets I laid out in https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b (e.g., concise, expressive, explicit, extensible, and exhaustive).\n\nI proposed `is` expressions because they are concise and compose well with existing syntactic constructs like `if`, `do-while`, `while`, `for`, conditional expressions, `yield`, `await`, arrow functions, and logical operations.\n\nI like `match` expressions because they push developers towards exhaustive matching, and are an improvement both over `switch` (with all of its failings), and conditional expressions (as `match` removes the need to cache the head expression).\n\nI very much favor minimal, yet expressive pattern syntax, such as:\n\n- Literal constant patterns (i.e., `0`, `null`, `\"hello\"`, etc.)\n- Object and array patterns (i.e., `{ x: 10, y: 20 }`, `[10, 20]`, etc.)\n- Qualified name patterns for custom matchers (i.e., `String`, `Point`, `Option.Some`, etc.)\n- Extractors for nested matching in custom matchers (i.e., `Point({ x: 10, y: 20 })`, `Foo(1, 2)`, etc.)\n- Negation patterns (i.e., `not null`, `not String`, etc.)\n- Disjunction patterns (i.e., `String or Number`, etc.)\n- Conjunction patterns (i.e., `Array and { length: 10 }`, etc.)\n- `let`/`const` patterns (i.e., `Option.Some(let value)`, `{ x: 10, y: let y }`, etc.)\n\nI favor `let`/`const` patterns because they are explicit, recognizable, and familiar. They are also bound \"in place\", which avoids repetition. They also remove the need for `${}` placeholders that are necessary in the current syntax only to differentiate between _references_ to existing variables and _bindings_ produced by the pattern. I generally favor `let`/`const` over Rust's `@` syntax for bindings, as `@` is very confusing in Rust, and would overload the meaning  of `@` in some contexts (i.e., decorators). I find keyword-based syntax to be far easier to introduce over sigil-based syntax due to the limited budget we have remaining in the language for sigils.","format":"org.matrix.custom.html","formatted_body":"<p>I explored a number of novel syntax options in https://gist.github.com/rbuckton/df6ade207eecad4fc94cedc3aae79ceb, and the syntax that I favor matches the tenets I laid out in https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b (e.g., concise, expressive, explicit, extensible, and exhaustive).</p>\n<p>I proposed <code>is</code> expressions because they are concise and compose well with existing syntactic constructs like <code>if</code>, <code>do-while</code>, <code>while</code>, <code>for</code>, conditional expressions, <code>yield</code>, <code>await</code>, arrow functions, and logical operations.</p>\n<p>I like <code>match</code> expressions because they push developers towards exhaustive matching, and are an improvement both over <code>switch</code> (with all of its failings), and conditional expressions (as <code>match</code> removes the need to cache the head expression).</p>\n<p>I very much favor minimal, yet expressive pattern syntax, such as:</p>\n<ul>\n<li>Literal constant patterns (i.e., <code>0</code>, <code>null</code>, <code>&quot;hello&quot;</code>, etc.)</li>\n<li>Object and array patterns (i.e., <code>{ x: 10, y: 20 }</code>, <code>[10, 20]</code>, etc.)</li>\n<li>Qualified name patterns for custom matchers (i.e., <code>String</code>, <code>Point</code>, <code>Option.Some</code>, etc.)</li>\n<li>Extractors for nested matching in custom matchers (i.e., <code>Point({ x: 10, y: 20 })</code>, <code>Foo(1, 2)</code>, etc.)</li>\n<li>Negation patterns (i.e., <code>not null</code>, <code>not String</code>, etc.)</li>\n<li>Disjunction patterns (i.e., <code>String or Number</code>, etc.)</li>\n<li>Conjunction patterns (i.e., <code>Array and { length: 10 }</code>, etc.)</li>\n<li><code>let</code>/<code>const</code> patterns (i.e., <code>Option.Some(let value)</code>, <code>{ x: 10, y: let y }</code>, etc.)</li>\n</ul>\n<p>I favor <code>let</code>/<code>const</code> patterns because they are explicit, recognizable, and familiar. They are also bound &quot;in place&quot;, which avoids repetition. They also remove the need for <code>${}</code> placeholders that are necessary in the current syntax only to differentiate between <em>references</em> to existing variables and <em>bindings</em> produced by the pattern. I generally favor <code>let</code>/<code>const</code> over Rust's <code>@</code> syntax for bindings, as <code>@</code> is very confusing in Rust, and would overload the meaning  of <code>@</code> in some contexts (i.e., decorators). I find keyword-based syntax to be far easier to introduce over sigil-based syntax due to the limited budget we have remaining in the language for sigils.</p>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$U3ThT66JyjR5KprJ4PTpk2YwsGVZJ72CiIwpFeqxg8A","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1680020744702,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ggFjMIgd9ttl1v17N2auqeXteDUHr21ShhV54klOo9I"},
{"content":{"body":"Also, while I don't consider these to be necessary for an MVP pattern matching proposal, I think there is room to expand (in another \"layer\" or later proposal) the pattern syntax to include things like RegExp literal patterns and relational patterns.","msgtype":"m.text"},"ts":1680020847563,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0UOyXgwCKqqbXyp34Uw_gmkrzbpQF-m8auR-GzjBEnc"},
{"content":{"body":" * Also, while I don't consider these to be necessary for an MVP pattern matching proposal, I think there is room to expand the pattern syntax in another \"layer\" or later proposal to include things like RegExp literal patterns and relational patterns.","m.new_content":{"body":"Also, while I don't consider these to be necessary for an MVP pattern matching proposal, I think there is room to expand the pattern syntax in another \"layer\" or later proposal to include things like RegExp literal patterns and relational patterns.","msgtype":"m.text"},"m.relates_to":{"event_id":"$0UOyXgwCKqqbXyp34Uw_gmkrzbpQF-m8auR-GzjBEnc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1680020909637,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$63P17SJk7rx6HoYqUSBoOVMF40dkMSIygWE_rK39PYs"}
]