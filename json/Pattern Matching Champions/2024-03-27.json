[
{"content":{"body":"I've posted a PR for the initial spec text for Extractors for possible advancement to Stage 2. I'd appreciate feedback from this group, today if possible, as I plan to merge the PR later today when I post my slides to the agenda. https://github.com/tc39/proposal-extractors/pull/12","m.mentions":{},"msgtype":"m.text"},"ts":1711557628172,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$r-uv8zheM8P0LkJlNdKkYWNizWgGkruVq1QjOFG7x6E"},
{"content":{"body":"In addition, my slides are here if anyone would like to review: https://1drv.ms/p/s!AjgWTO11Fk-TkqpinLRBZZwud0rM9w?e=s7hKoI","m.mentions":{},"msgtype":"m.text"},"ts":1711558215711,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Xob8FGZV3uURBX-Ay8OG-A8SxRjcVb9O0ODepdW1PYU"},
{"content":{"body":"I have a question ","msgtype":"m.text"},"ts":1711560006758,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$746n_b0xLl_urf1gnP9xv49Ia5jBb4XsfneZCeOVrfk"},
{"content":{"body":"Does the extractor proposal encourage this? A custom matcher coerces the subject. Example: \nconst date(yyyy, mm, dd) = 123456789","msgtype":"m.text"},"ts":1711560170251,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$J-B9CtClrZ8biAhbFrr3jGD8Wfak4Tww2kThvBrZs24"},
{"content":{"body":"this is something we don't do in the built-in matchers, which means it is somehow a style we are encouraged for, only test and extract things you own, not something smart","msgtype":"m.text"},"ts":1711560231119,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$ZK1UdIqGl2ZNrX2oRdZxQFzabSzRa44b2mNilS7e-Mw"},
{"content":{"body":"if we do something smart (in the pattern matching), things might go like this:\nwhen JSON.parse({ x: 1 }) can match the corresponding JSON string and also in the extractor proposal \nconst JSON.parse({ x: 1 }) = localStorage.get(...)","msgtype":"m.text"},"ts":1711560351697,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$OjfjYuIHPDQlv8WtJe-M3_VRPkxjdIx4vuwC230bgAk"},
{"content":{"body":"* if we do something smart (in the pattern matching), things might go like this:\nwhen JSON.parse({ x: 1 }) can match the corresponding JSON string and also in the extractor proposal \nconst JSON.parse({ x }) = localStorage.get(...)","m.new_content":{"body":"if we do something smart (in the pattern matching), things might go like this:\nwhen JSON.parse({ x: 1 }) can match the corresponding JSON string and also in the extractor proposal \nconst JSON.parse({ x }) = localStorage.get(...)","msgtype":"m.text"},"m.relates_to":{"event_id":"$OjfjYuIHPDQlv8WtJe-M3_VRPkxjdIx4vuwC230bgAk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711560373300,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$flaZP7xp0g1WQBynoaTMOC2Jbs6z3JRBp4VNY7Fg9oE"},
{"content":{"body":"In general you want an extractor to be the inverse of construction, but Scala (which is the inspiration for this design) explicitly calls out use cases like that.","m.mentions":{},"msgtype":"m.text"},"ts":1711560512046,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$vmy2BscjpjEjThr30FVAE1RHMaRZeMtz4qJf1cpQ4NI"},
{"content":{"body":"I would say, it's acceptable for users to write user-defined extractors for this purpose, but built-ins generally shouldn't. With the exception being something like `RegExp` instances, since that is a convenient mechanism to explain how RegExp patterns in pattern matching work, and to allow users to decompose a regexp match pattern into a reusable regexp.","format":"org.matrix.custom.html","formatted_body":"I would say, it's acceptable for users to write user-defined extractors for this purpose, but built-ins generally shouldn't. With the exception being something like <code>RegExp</code> instances, since that is a convenient mechanism to explain how RegExp patterns in pattern matching work, and to allow users to decompose a regexp match pattern into a reusable regexp.","m.mentions":{},"msgtype":"m.text"},"ts":1711560610027,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lkcj9TrlEnFfF8OBj_xVnBiooAQ4cBgZyA8CzTLs9iU"},
{"content":{"body":"> <@jackworks:matrix.org> if we do something smart (in the pattern matching), things might go like this:\n> when JSON.parse({ x: 1 }) can match the corresponding JSON string and also in the extractor proposal \n> const JSON.parse({ x }) = localStorage.get(...)\n\nWhile this is feasible, I'd caution against doing something like this for `JSON.parse` as a string can be an arbitrarily large JSON object from which you only intend to extract a fragment, so it has a fairly sizable hidden cost.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$OjfjYuIHPDQlv8WtJe-M3_VRPkxjdIx4vuwC230bgAk?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>if we do something smart (in the pattern matching), things might go like this:<br/>when JSON.parse({ x: 1 }) can match the corresponding JSON string and also in the extractor proposal <br/>const JSON.parse({ x }) = localStorage.get(...)</blockquote></mx-reply>While this is feasible, I'd caution against doing something like this for <code>JSON.parse</code> as a string can be an arbitrarily large JSON object from which you only intend to extract a fragment, so it has a fairly sizable hidden cost.","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$OjfjYuIHPDQlv8WtJe-M3_VRPkxjdIx4vuwC230bgAk"}},"msgtype":"m.text"},"ts":1711560782695,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KJUEIf2XvuQ5SY3av86Aml7IBC0zg3wKIpnh9fnjAJE"},
{"content":{"body":"I wonder if there is any style inconsistency that lives behind, that pattern matching encourages people to write dumb matchers and extractors encourage them to write smart ones.","msgtype":"m.text"},"ts":1711560800207,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$w2n-iWmD5fRJllD-VY8GHrtnoy3jpggLPUVdHLVRraI"},
{"content":{"body":"(and they use the same symbol)","msgtype":"m.text"},"ts":1711560818244,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$gZSkoNfiP570FsXnp059YT9Oq3TeN1dVxXuKkQk5O6g"},
{"content":{"body":"If we had a SAX-like streaming parser for JSON and the matcher had full knowledge of the nested destructuring graph, maybe it would be possible to implement something efficient.","m.mentions":{},"msgtype":"m.text"},"ts":1711560889196,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$0mWBS5XU1nGkjSeDkFcUFRPmANpsF-i7bfZeYr3WePQ"},
{"content":{"body":"Considering I'm as likely to use extractors for the same reasons in both cases, I don't see a difference between the two.","m.mentions":{},"msgtype":"m.text"},"ts":1711560943476,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WSHnaAFJbdjHKpX5bkQhzhucRBF5eurlXtE0o-u2aFs"},
{"content":{"body":"wait, why would pattern matching encourage people to write dumb matchers?","m.mentions":{},"msgtype":"m.text"},"ts":1711560944680,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$rsBIVcvVVQPq2K-LZpMAcIGpoHOZqb_3vree2V_eJnQ"},
{"content":{"body":"Though I still don't find the predicate-function capability quite as important. I wonder if it would make sense to only allow predicates in `x is y`, and not `x is y(z)` ","format":"org.matrix.custom.html","formatted_body":"Though I still don't find the predicate-function capability quite as important. I wonder if it would make sense to only allow predicates in <code>x is y</code>, and not <code>x is y(z)</code>","m.mentions":{},"msgtype":"m.text"},"ts":1711561052786,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$W1J9nPXxDPf88jq075YoCxZMRUZ8jy5s-dg2671Sz8Q"},
{"content":{"body":"I don't know, maybe because how built-in acts","msgtype":"m.text"},"ts":1711561059019,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$-_TttIFfJXskoLHVEmZU29hF3Pk3qRJLTFyOCkiR0Ko"},
{"content":{"body":"just my personal feeling ","msgtype":"m.text"},"ts":1711561059616,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$2Bf6B01JT-XsykXc8DrJAbkyjbZWqz-7pV1CegmyBek"},
{"content":{"body":"If and when ADT enums become a thing, and even before that, the 95% use case will be inversion of construction, i.e. `Point(let x, let y) = new Point(x, y)`. Just like the 95% use case of `yield` and `yield*` is for iteration, not coroutine-like generators.","format":"org.matrix.custom.html","formatted_body":"If and when ADT enums become a thing, and even before that, the 95% use case will be inversion of construction, i.e. <code>Point(let x, let y) = new Point(x, y)</code>. Just like the 95% use case of <code>yield</code> and <code>yield*</code> is for iteration, not coroutine-like generators.","m.mentions":{},"msgtype":"m.text"},"ts":1711561144210,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$8-JeFRU7KzZ68UOSy1HJxFVstpaf6YEhc1oXdo44Zr0"},
{"content":{"body":"> <@jackworks:matrix.org> just my personal feeling\n\nthat's fine but i still don't understand it, can you elaborate?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$2Bf6B01JT-XsykXc8DrJAbkyjbZWqz-7pV1CegmyBek?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>just my personal feeling </blockquote></mx-reply>that's fine but i still don't understand it, can you elaborate?","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$2Bf6B01JT-XsykXc8DrJAbkyjbZWqz-7pV1CegmyBek"}},"msgtype":"m.text"},"ts":1711561161218,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$5QKm221NsBMC_9_hXARZFKqZhjTWEUBFrob8lGYUQ64"},
{"content":{"body":"> <@rbuckton:matrix.org> Though I still don't find the predicate-function capability quite as important. I wonder if it would make sense to only allow predicates in `x is y`, and not `x is y(z)`\n\nto me, the predicate function use case will be the vast majority of pattern matching's usage, even over time","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$W1J9nPXxDPf88jq075YoCxZMRUZ8jy5s-dg2671Sz8Q?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Though I still don't find the predicate-function capability quite as important. I wonder if it would make sense to only allow predicates in <code>x is y</code>, and not <code>x is y(z)</code></blockquote></mx-reply>to me, the predicate function use case will be the vast majority of pattern matching's usage, even over time","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$W1J9nPXxDPf88jq075YoCxZMRUZ8jy5s-dg2671Sz8Q"}},"msgtype":"m.text"},"ts":1711561184787,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$qdtR32Z8K2R05JR4iGNRkDb2Zz5SWT85e-C6JC3jJBU"},
{"content":{"body":"but i operate in a subset of the JS ecosystem that basically doesn't use `class` at all","format":"org.matrix.custom.html","formatted_body":"but i operate in a subset of the JS ecosystem that basically doesn't use <code>class</code> at all","m.mentions":{},"msgtype":"m.text"},"ts":1711561229335,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$e1POT57f61FvFsmvfW7LJD_Za_CTzIWzlPG0bFX3PYU"},
{"content":{"body":" * but i operate in a subset of the JS ecosystem that basically doesn't use `class` or `new` at all outside of builtins","format":"org.matrix.custom.html","formatted_body":" * but i operate in a subset of the JS ecosystem that basically doesn't use <code>class</code> or <code>new</code> at all outside of builtins","m.mentions":{},"m.new_content":{"body":"but i operate in a subset of the JS ecosystem that basically doesn't use `class` or `new` at all outside of builtins","format":"org.matrix.custom.html","formatted_body":"but i operate in a subset of the JS ecosystem that basically doesn't use <code>class</code> or <code>new</code> at all outside of builtins","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$e1POT57f61FvFsmvfW7LJD_Za_CTzIWzlPG0bFX3PYU","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711561243783,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Ml2Ueea3VWODC7vGzGa_-WGCkxCuzZhcodp2vEbJNec"},
{"content":{"body":"I just don't see it. Maybe for a while, but pattern matching leads developers towards a certain style of development that tends to favor instances (or tags) and structure.","m.mentions":{},"msgtype":"m.text"},"ts":1711561256491,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$H74x8oK0bCGYGFYmfb6T2p97IBqW-Atzi5kahZItOco"},
{"content":{"body":"structure certainly. instances, i'm skeptical.","m.mentions":{},"msgtype":"m.text"},"ts":1711561293995,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$_6WVRPJcZCE4-aUt1umfD90TJEnao6XZSbCHhda0bSA"},
{"content":{"body":"> <@ljharb:matrix.org> that's fine but i still don't understand it, can you elaborate?\n\nthink for a while, this comes from my experience of crafting smart ones as built-in being rejected by the group but smart style appears in introduction of extractors","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$5QKm221NsBMC_9_hXARZFKqZhjTWEUBFrob8lGYUQ64?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br />that's fine but i still don't understand it, can you elaborate?</blockquote></mx-reply>think for a while, this comes from my experience of crafting smart ones as built-in being rejected by the group but smart style appears in introduction of extractors","m.relates_to":{"m.in_reply_to":{"event_id":"$5QKm221NsBMC_9_hXARZFKqZhjTWEUBFrob8lGYUQ64"}},"msgtype":"m.text"},"ts":1711561389006,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$JwzHCgAtVp7PmJIA3iq6WFYPO6wdVdgzXVz-GFVlnbk"},
{"content":{"body":"hm, maybe the criteria for your \"smart\" isn't clear to me","m.mentions":{},"msgtype":"m.text"},"ts":1711561415418,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$un1_6J9UJ4RKDYkl0ivSnG0U8t_vQcuYSCtjlGAD9ZU"},
{"content":{"body":"I'm still working out a fresh design for ADT enums. I think that if I can work out the performance characteristics of ADT enums with implementations to everyone's satisfaction, there's a huge opportunity for ADT enums to gain significant traction.","m.mentions":{},"msgtype":"m.text"},"ts":1711561429797,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dzLKWQ4Hne5z44ecPgKd-xceFrEJBHZIwISSF0EZ1Go"},
{"content":{"body":"(but certainly i think matchers should avoid being overtly clever. cleverness is an antipattern)","m.mentions":{},"msgtype":"m.text"},"ts":1711561442045,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$MgIDq9X19kBE0E37tHYABjblZ7XqTcqwSAkv2m-_IZ0"},
{"content":{"body":"And ADT enums are strongly tied to both instance and structure, since instance is the part of the enum domain that I'm hoping will give it the performance characteristics necessary to be worthwhile.","m.mentions":{},"msgtype":"m.text"},"ts":1711561482487,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mSeiEuTW-rz9ZY3OU98GCsiUwDMbWksy9AVaI3GiPdk"},
{"content":{"body":"almost all of my enum use cases would not involve a class","m.mentions":{},"msgtype":"m.text"},"ts":1711561509940,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$zS1aOQXfohP-tN_Zk6Idy49vxWSKm3C4CJf7Regv5Ng"},
{"content":{"body":"if you are talking about number or symbol-valued enums, that's not the focus.","m.mentions":{},"msgtype":"m.text"},"ts":1711561550894,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mObEobBaWWYtq5D7y8NgDE9ZVHezje63Yy-7xcB2kzs"},
{"content":{"body":"yes, that's the primary use case for enums imo and ime, and i'm not yet motivated by other ones","m.mentions":{},"msgtype":"m.text"},"ts":1711561577218,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$PVs_kmIiYtwdX0ngnFNvXZq05sTG0cgX4yKLqxnwHlw"},
{"content":{"body":"Yes, they need to be supported, but the benefit of ADT enums is actually how engines can optimize for them vs. regular objects.","m.mentions":{},"msgtype":"m.text"},"ts":1711561581293,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$rS7-qLqQ8VCLL5qSkhUl-lWu0vCqEkhYqWeB6Dxo4Es"},
{"content":{"body":"> <@ljharb:matrix.org> hm, maybe the criteria for your \"smart\" isn't clear to me\n\naccepts non instances and even primitives. extract/normalize data from it. like json.parse","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$un1_6J9UJ4RKDYkl0ivSnG0U8t_vQcuYSCtjlGAD9ZU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br />hm, maybe the criteria for your &quot;smart&quot; isn't clear to me</blockquote></mx-reply>accepts non instances and even primitives. extract/normalize data from it. like json.parse","m.relates_to":{"m.in_reply_to":{"event_id":"$un1_6J9UJ4RKDYkl0ivSnG0U8t_vQcuYSCtjlGAD9ZU"}},"msgtype":"m.text"},"ts":1711561581620,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$4wN2NWjgeBn5mDcYbBBtBzYlIwyz5-G4Rner8K6t4ko"},
{"content":{"body":"something that does what your JSON.parse matcher did seems useful; using JSON.parse for it to me seems overly clever.","m.mentions":{},"msgtype":"m.text"},"ts":1711561611262,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$fBbnUSRTGx1KwDAYoxBt89J0hrpD-SftuZaHOwBS3vY"},
{"content":{"body":"By having a closed domain of type identities associated with enum values, a specific class of inline cache can be used that avoids megamorphism when branching on the type of an enum value.","m.mentions":{},"msgtype":"m.text"},"ts":1711561628649,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$pUuo1v70-BdxDWyqoR2y4lvi7K0ES7qfpNKiMrNikAU"},
{"content":{"body":"that sounds like a very niche performance need that most practitioners won","m.mentions":{},"msgtype":"m.text"},"ts":1711561650900,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$eNFj6BiGZLZfdP_SwPqZLGA8aNJD9bf_eVX4z8xSHR4"},
{"content":{"body":" * that sounds like a very niche performance need that most practitioners won't care or think about","m.mentions":{},"m.new_content":{"body":"that sounds like a very niche performance need that most practitioners won't care or think about","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$eNFj6BiGZLZfdP_SwPqZLGA8aNJD9bf_eVX4z8xSHR4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711561655387,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$0pQ1n3C1Z04eup-fc1RWvD9Sy9V9k-79xO5lwXqjKlk"},
{"content":{"body":"i.e., if you take TypeScript's AST for example, every `node.kind` is megamorphic, while individual branches are ideally monomorphic.","format":"org.matrix.custom.html","formatted_body":"i.e., if you take TypeScript's AST for example, every <code>node.kind</code> is megamorphic, while individual branches are ideally monomorphic.","m.mentions":{},"msgtype":"m.text"},"ts":1711561673210,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Hf5xWTlCp77hN3UsLTF1vuyGqrns-qzNkJmgpU-btWI"},
{"content":{"body":" * that sounds like a very niche performance need that most practitioners won't care or think about (which doesn't make it unimportant, but does mean it wouldn't achieve much dev traction)","m.mentions":{},"m.new_content":{"body":"that sounds like a very niche performance need that most practitioners won't care or think about (which doesn't make it unimportant, but does mean it wouldn't achieve much dev traction)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$eNFj6BiGZLZfdP_SwPqZLGA8aNJD9bf_eVX4z8xSHR4","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711561673347,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$BHP0jS90SAtOZfRwohqJtzsQMeVYDugO7lfCUWNU1i4"},
{"content":{"body":"> <@ljharb:matrix.org> that sounds like a very niche performance need that most practitioners won't care or think about (which doesn't make it unimportant, but does mean it wouldn't achieve much dev traction)\n\nI completely disagree. ADT enums have many of the characteristics that Shu also wants for `struct`. Fixed object layout is extremely important for engines, and you can't guarantee that with a regular Object.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$eNFj6BiGZLZfdP_SwPqZLGA8aNJD9bf_eVX4z8xSHR4?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>that sounds like a very niche performance need that most practitioners won&#39;t care or think about (which doesn&#39;t make it unimportant, but does mean it wouldn&#39;t achieve much dev traction)</blockquote></mx-reply>I completely disagree. ADT enums have many of the characteristics that Shu also wants for <code>struct</code>. Fixed object layout is extremely important for engines, and you can't guarantee that with a regular Object.","m.mentions":{"user_ids":["@ljharb:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$eNFj6BiGZLZfdP_SwPqZLGA8aNJD9bf_eVX4z8xSHR4"}},"msgtype":"m.text"},"ts":1711561725086,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$jvXtYeRDCN7qfVDILBPr7yYtTsFYQZOf8hlrf0yJuXM"},
{"content":{"body":"structs are also incredibly niche","m.mentions":{},"msgtype":"m.text"},"ts":1711561735282,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$IZ9m85Xm9e699vGLCmmXByLLAbom10bHxtgwFbP78O4"},
{"content":{"body":"the majority of devs won't ever use structs directly or think about them.","m.mentions":{},"msgtype":"m.text"},"ts":1711561748517,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$v5MGSLW3u2UrHllittB4j2uCQYLVtUp59ysOqPJ3U8A"},
{"content":{"body":"certainly the engine, and things like TS or other libraries, can benefit, which is why it's still worth spending time on it","m.mentions":{},"msgtype":"m.text"},"ts":1711561769884,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$wVyJbTHQddGPQfnRqx2ZNyJce05wAxG_FBhFNCcOMes"},
{"content":{"body":"I think the opposite would be true for ADT enums.","m.mentions":{},"msgtype":"m.text"},"ts":1711561773821,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OhAzPBcovugthZmOpC4elYlhQcVkJlhmmU0RDASj8rM"},
{"content":{"body":"> <@rbuckton:matrix.org> i.e., if you take TypeScript's AST for example, every `node.kind` is megamorphic, while individual branches are ideally monomorphic.\n\nyou should not explain from a performance perspective. even normal programming need to write adt a lot. no syntax sugar for this wastes a lot of time to define data structures ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$Hf5xWTlCp77hN3UsLTF1vuyGqrns-qzNkJmgpU-btWI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />i.e., if you take TypeScript's AST for example, every <code>node.kind</code> is megamorphic, while individual branches are ideally monomorphic.</blockquote></mx-reply>you should not explain from a performance perspective. even normal programming need to write adt a lot. no syntax sugar for this wastes a lot of time to define data structures","m.relates_to":{"m.in_reply_to":{"event_id":"$Hf5xWTlCp77hN3UsLTF1vuyGqrns-qzNkJmgpU-btWI"}},"msgtype":"m.text"},"ts":1711561797333,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$0CDktUr93vSoyRfzL6-rVC4U4Cs17lif-UPIeoljHM4"},
{"content":{"body":"i would be very surprised if non-primitive enums were ever adopted at scale.","m.mentions":{},"msgtype":"m.text"},"ts":1711561800377,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$l-Lk_Xgt2031flJw1BhgNFwC6tjQ9M02R4InCg7nns8"},
{"content":{"body":" * i would be very surprised if non-primitive enums were ever adopted at scale. (primitive enums, most certainly will be)","m.mentions":{},"m.new_content":{"body":"i would be very surprised if non-primitive enums were ever adopted at scale. (primitive enums, most certainly will be)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$l-Lk_Xgt2031flJw1BhgNFwC6tjQ9M02R4InCg7nns8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711561812265,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$MhzVsoC8mv2QMpx_xLJrHxj1RKCTd8fktn4o0EoMvec"},
{"content":{"body":"Structs are niche, but would have an outsized impact on the ecosystem as they're most likely to be used by major applications with broad reach (Google Docs, Office 365, etc.)","m.mentions":{},"msgtype":"m.text"},"ts":1711561836189,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HWQLYGfm_MVkFoeorI3o0xOUqniOLBxCvSVPW7sYQdw"},
{"content":{"body":"right - i'm not disputing that anything that makes major apps/tools faster has a large impact","m.mentions":{},"msgtype":"m.text"},"ts":1711561855809,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$u_2ao7PVxW9EbR9y6cHZudN5yJK6gFNcWaZql23iF2k"},
{"content":{"body":"ADT enums are likely to be used by everyone as a convenient way to model related information.","m.mentions":{},"msgtype":"m.text"},"ts":1711561858551,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$O-fTeO7sH8qBWwMNPTMb3fzS78dWvmPVhv3a_JZphhs"},
{"content":{"body":"but that's a different claim than \"developers will use this\"","m.mentions":{},"msgtype":"m.text"},"ts":1711561863301,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$NNmUpDKUZNw1E9RBDlpBDLvcF96c7rHYCPTbVZToZqs"},
{"content":{"body":" * but that's a different claim than \"developers will use this directly\"","m.mentions":{},"m.new_content":{"body":"but that's a different claim than \"developers will use this directly\"","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$NNmUpDKUZNw1E9RBDlpBDLvcF96c7rHYCPTbVZToZqs","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711561875165,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$NxcAyzZPay8bKyHb50WArvksLjLqm3FnQHxRmz8832o"},
{"content":{"body":"i look forward to an ADT enum presentation that helps me understand why it's a thing anyone should care about - i haven't understood that yet.","m.mentions":{},"msgtype":"m.text"},"ts":1711561904642,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$yu_Rt5CZs0mHw_YHypGMDHkAJ9CYBzyRannswP5KbcY"},
{"content":{"body":" * i look forward to an ADT enum presentation that helps me understand why it's a thing anyone should care about - i haven't understood that yet.\n\n(i've long believed primitive enums are a thing everyone wants)","m.mentions":{},"m.new_content":{"body":"i look forward to an ADT enum presentation that helps me understand why it's a thing anyone should care about - i haven't understood that yet.\n\n(i've long believed primitive enums are a thing everyone wants)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$yu_Rt5CZs0mHw_YHypGMDHkAJ9CYBzyRannswP5KbcY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711561955834,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$nNkvT3qYvgO2P94hEE485pWq6vzBdaSntBhGSIkid8Y"},
{"content":{"body":"Developers already use similar mechanisms (i.e., discriminated unions), but they constantly suffer from the performance bottleneck of megamorphic ICs. If ADT enums can avoid that bottleneck, they're very likely to gain adoption.","m.mentions":{},"msgtype":"m.text"},"ts":1711561961336,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$utuglLj_WB4yL8G0_HXaX-WLl7nbYuH-g47sIBGeCBA"},
{"content":{"body":"The pushback I usually get on primitive enums, is that the same thing can be accomplished via an object literal. My original enum proposal has long had value-adds far above the object literal case, but ADT enums are a whole world unto themselves as far as new capabilities.","m.mentions":{},"msgtype":"m.text"},"ts":1711562123125,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xyZly8IXX6KzHIMnCE6wFWHutPLaHxeCif2H_H5vM0E"},
{"content":{"body":" * The pushback I usually get on primitive enums is that the same thing can be accomplished via an object literal. My original enum proposal has long had value-adds far above the object literal case, but ADT enums are a whole world unto themselves as far as new capabilities.","m.mentions":{},"m.new_content":{"body":"The pushback I usually get on primitive enums is that the same thing can be accomplished via an object literal. My original enum proposal has long had value-adds far above the object literal case, but ADT enums are a whole world unto themselves as far as new capabilities.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$xyZly8IXX6KzHIMnCE6wFWHutPLaHxeCif2H_H5vM0E","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711562129084,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$uG2NiF8ghfJWZQdgJOD5uWNt8G-RUOSbs04LmilXVOM"},
{"content":{"body":"With an object literal, the engine has to treat every access as a property access, there's no special casing that can go on there.","m.mentions":{},"msgtype":"m.text"},"ts":1711562156050,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$G2mwDVEeWTyVnKETBcfmRQL272h3YRGqwAHcK2GO83Y"},
{"content":{"body":"right - a net new mental model is something that will be difficult to impart to devs, i think.","m.mentions":{},"msgtype":"m.text"},"ts":1711562161423,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$DKVGfZi9a6eU5XIwBhdONoHRdN18-vh4CIXj5a47lAA"},
{"content":{"body":"With an `enum` that has a well-defined, immutable domain, then engines can use that type feedback to introduce specific optimizations that aren't otherwise possible.","format":"org.matrix.custom.html","formatted_body":"With an <code>enum</code> that has a well-defined, immutable domain, then engines can use that type feedback to introduce specific optimizations that aren't otherwise possible.","m.mentions":{},"msgtype":"m.text"},"ts":1711562219484,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wP35Lc9jsV-mawWPhhJGfvjxNMHUuNDgydyB1F-v5Ew"},
{"content":{"body":" * right - a net new mental model is something that will be difficult to impart to devs, i think. (also i have zero grasp of it so far)","m.mentions":{},"m.new_content":{"body":"right - a net new mental model is something that will be difficult to impart to devs, i think. (also i have zero grasp of it so far)","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$DKVGfZi9a6eU5XIwBhdONoHRdN18-vh4CIXj5a47lAA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711562223739,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$mNVezLQzT4L15k3eAFExqwc00M3lU3BkYUVnl_KvyeE"},
{"content":{"body":" * With an `enum` that has a well-defined, immutable domain, engines can use that type feedback to introduce specific optimizations that aren't otherwise possible.","format":"org.matrix.custom.html","formatted_body":" * With an <code>enum</code> that has a well-defined, immutable domain, engines can use that type feedback to introduce specific optimizations that aren't otherwise possible.","m.mentions":{},"m.new_content":{"body":"With an `enum` that has a well-defined, immutable domain, engines can use that type feedback to introduce specific optimizations that aren't otherwise possible.","format":"org.matrix.custom.html","formatted_body":"With an <code>enum</code> that has a well-defined, immutable domain, engines can use that type feedback to introduce specific optimizations that aren't otherwise possible.","m.mentions":{},"msgtype":"m.text"},"m.relates_to":{"event_id":"$wP35Lc9jsV-mawWPhhJGfvjxNMHUuNDgydyB1F-v5Ew","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1711562273598,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$XzUHd3hL7rLutsZllPFg_-7LDhLpn0cj7HG5VDXggCI"},
{"content":{"body":"> <@ljharb:matrix.org> but that's a different claim than \"developers will use this directly\"\n\nI don't care about the performance though. ADT enum can improve many people shape their program, how they represent data structures in their code. so yes. they'll use this feature directly especially typescript users.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$NNmUpDKUZNw1E9RBDlpBDLvcF96c7rHYCPTbVZToZqs?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br />but that's a different claim than &quot;developers will use this directly&quot;</blockquote></mx-reply>I don't care about the performance though. ADT enum can improve many people shape their program, how they represent data structures in their code. so yes. they'll use this feature directly especially typescript users.","m.relates_to":{"m.in_reply_to":{"event_id":"$NNmUpDKUZNw1E9RBDlpBDLvcF96c7rHYCPTbVZToZqs"}},"msgtype":"m.text"},"ts":1711562385952,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$O0KiBnKxCc5rLsJDqhtEiCG2HMvbpvoryLful2YXZpI"},
{"content":{"body":"For instance\n```\nenum Option {\n  Some(value),\n  None\n}\n\nmatch (opt) {\n  when Option.Some(let x): ...;\n  when Option.None: ...;\n}\n```\nAn implementation could use type feedback from `opt` and `Option` to optimize away the extractor implementation and destructuring overhead to reach directly into the object, but only because `Option` has a well-defined domain that `opt` can belong to. That requires statically analyzable syntax to know how that would differ from a regular-old JS object.","format":"org.matrix.custom.html","formatted_body":"<p>For instance</p>\n<pre><code>enum Option {\n  Some(value),\n  None\n}\n\nmatch (opt) {\n  when Option.Some(let x): ...;\n  when Option.None: ...;\n}\n</code></pre>\n<p>An implementation could use type feedback from <code>opt</code> and <code>Option</code> to optimize away the extractor implementation and destructuring overhead to reach directly into the object, but only because <code>Option</code> has a well-defined domain that <code>opt</code> can belong to. That requires statically analyzable syntax to know how that would differ from a regular-old JS object.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1711562445276,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$SBSxGBNUWjoikWuxt6Y3xQbeuEUcq5hvR0gX9r0G1rE"},
{"content":{"body":"You could imagine `opt` has an _internal_ representation analogous to `map { enumType: Option, member: map { enumMember: Option.Some, instance: map { value: ... } } }`, such that each `when` clause starts with a monomorphic IC lookup against `map { enumType: Option, member: heap }`, and the first branch has another monomorphic IC lookup against `map { enumMember: Some, instance: heap }`. By the time you get to the nested pattern you're still essentially on a code path that is entirely monomorphic.","format":"org.matrix.custom.html","formatted_body":"You could imagine <code>opt</code> has an <em>internal</em> representation analogous to <code>map { enumType: Option, member: map { enumMember: Option.Some, instance: map { value: ... } } }</code>, such that each <code>when</code> clause starts with a monomorphic IC lookup against <code>map { enumType: Option, member: heap }</code>, and the first branch has another monomorphic IC lookup against <code>map { enumMember: Some, instance: heap }</code>. By the time you get to the nested pattern you're still essentially on a code path that is entirely monomorphic.","m.mentions":{},"msgtype":"m.text"},"ts":1711562779376,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5coFa5ifGXXlylbTd1g6VMsFLIYVlgND8hZDUOcDU2A"},
{"content":{"body":"vs. a flat internal representation of `map { constructor: Option.Some, value: ... }` that differs from `map { constructor: Option.#None }`, which are different maps and thus a polymorphic IC.","format":"org.matrix.custom.html","formatted_body":"vs. a flat internal representation of <code>map { constructor: Option.Some, value: ... }</code> that differs from <code>map { constructor: Option.#None }</code>, which are different maps and thus a polymorphic IC.","m.mentions":{},"msgtype":"m.text"},"ts":1711562843299,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$7paMz5cIvXstXqKn17I2-tZg0gwwvjKLokZz91uw1sk"},
{"content":{"body":"From the JS developers point of view, they just write `when Option.Some(let value)` or `opt.value` and it acts like a normal JS object. This is something that implementers strive for with `class` (and one of the reasons we had to add things like `accessor` to decorators), but it still isn't entirely reliable for `class` due to all of the shenanigans that developer's play with regular objects.","format":"org.matrix.custom.html","formatted_body":"From the JS developers point of view, they just write <code>when Option.Some(let value)</code> or <code>opt.value</code> and it acts like a normal JS object. This is something that implementers strive for with <code>class</code> (and one of the reasons we had to add things like <code>accessor</code> to decorators), but it still isn't entirely reliable for <code>class</code> due to all of the shenanigans that developer's play with regular objects.","m.mentions":{},"msgtype":"m.text"},"ts":1711563026137,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dJojmPF5dGJ0tEChAExhAheg7hLwLz1CMt_f7_U0Y1I"},
{"content":{"body":"> <@jackworks:matrix.org> I don't care about the performance though. ADT enum can improve many people shape their program, how they represent data structures in their code. so yes. they'll use this feature directly especially typescript users.\n\ni'd love to see some examples that feel javascripty","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$O0KiBnKxCc5rLsJDqhtEiCG2HMvbpvoryLful2YXZpI?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>I don't care about the performance though. ADT enum can improve many people shape their program, how they represent data structures in their code. so yes. they'll use this feature directly especially typescript users.</blockquote></mx-reply>i'd love to see some examples that feel javascripty","m.mentions":{"user_ids":["@jackworks:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$O0KiBnKxCc5rLsJDqhtEiCG2HMvbpvoryLful2YXZpI"}},"msgtype":"m.text"},"ts":1711574052504,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$ETVrdtIv_U1_u5t__vM8ACkTT9mR45KBdHZ_c4tTpqc"},
{"content":{"body":"as much as i actually do like the Option pattern from scala etc, it's not javascripty.","m.mentions":{},"msgtype":"m.text"},"ts":1711574065105,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$KWL8UBJ8dqwk-TUxrrh4ZUFdkQpGiV0jvp1laK5pBak"},
{"content":{"body":"Pattern matching isn't javascripty. Nothing is javascripty until its in the language. ADT enums *are* javascripty though, as they are readily modeled in JS as discriminated unions or even classes, but without the potential performance benefits.","format":"org.matrix.custom.html","formatted_body":"Pattern matching isn't javascripty. Nothing is javascripty until its in the language. ADT enums <em>are</em> javascripty though, as they are readily modeled in JS as discriminated unions or even classes, but without the potential performance benefits.","m.mentions":{},"msgtype":"m.text"},"ts":1711576897245,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kzIiRuF4b_eXasDHoSzvGZxlGf5O4t4_kKQNBCl3l14"},
{"content":{"body":"If we had them now, I'd model the custom matcher return value using them instead of an iterable.\n```\nenum Match {\n  No = false, // not a match\n  Yes = true, // a match, but no nested result\n  One(value), // a match with a single element, no iteration\n  List(values), // a match with multiple elements, uses iteration\n}\n```\nWe already have `No`, `Yes`, and `List` in our current design, but a fast-path for `One()` that skips iteration entirely could be beneficial. Scala has something similar as well, though you use `Option[Seq[T]]` or `unapplySeq` for the sequence case.","format":"org.matrix.custom.html","formatted_body":"<p>If we had them now, I'd model the custom matcher return value using them instead of an iterable.</p>\n<pre><code>enum Match {\n  No = false, // not a match\n  Yes = true, // a match, but no nested result\n  One(value), // a match with a single element, no iteration\n  List(values), // a match with multiple elements, uses iteration\n}\n</code></pre>\n<p>We already have <code>No</code>, <code>Yes</code>, and <code>List</code> in our current design, but a fast-path for <code>One()</code> that skips iteration entirely could be beneficial. Scala has something similar as well, though you use <code>Option[Seq[T]]</code> or <code>unapplySeq</code> for the sequence case.</p>\n","m.mentions":{},"msgtype":"m.text"},"ts":1711577228476,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$qpMWNrDg9b_ZUU0Hgq-tu7x2SMNHYnj_SZptAf2ZZRs"},
{"content":{"body":"> <@rbuckton:matrix.org> Pattern matching isn't javascripty. Nothing is javascripty until its in the language. ADT enums *are* javascripty though, as they are readily modeled in JS as discriminated unions or even classes, but without the potential performance benefits.\n\nplenty of things are javascripty even while not being in the language - idioms exist independent of the language's featureset. also tons of things IN the language are NOT javascripty, like proxy or generators.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$kzIiRuF4b_eXasDHoSzvGZxlGf5O4t4_kKQNBCl3l14?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>Pattern matching isn't javascripty. Nothing is javascripty until its in the language. ADT enums <em>are</em> javascripty though, as they are readily modeled in JS as discriminated unions or even classes, but without the potential performance benefits.</blockquote></mx-reply>plenty of things are javascripty even while not being in the language - idioms exist independent of the language's featureset. also tons of things IN the language are NOT javascripty, like proxy or generators.","m.mentions":{"user_ids":["@rbuckton:matrix.org"]},"m.relates_to":{"m.in_reply_to":{"event_id":"$kzIiRuF4b_eXasDHoSzvGZxlGf5O4t4_kKQNBCl3l14"}},"msgtype":"m.text"},"ts":1711579268132,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$79P3bFDP0I-D38wgeCBltR1LW-PetL3zkMQ0d1EusQA"}
]