[
{"content":{"body":"This is amazing. Is it possible to also cover if let (like rust)?","msgtype":"m.text"},"ts":1637108176196,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Zvg-qsNz1dM2V2ZqwDt62UEmOryRvv4gpQHpW7E1h8g"},
{"content":{"body":"And why you require a instanceof check? That's unreliable","msgtype":"m.text"},"ts":1637108205449,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$RfjVtMxd5Iigy_HEVaPq0FdfAb6qnl50YatDIIqt3R0"},
{"content":{"body":"Oops, syntax collision","msgtype":"m.text"},"ts":1637113503974,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$zzHfKpAtn3ypAfGGkwadh-j5es2LcIn-_unISA0XVb0"},
{"content":{"body":"(possibility?)","msgtype":"m.text"},"ts":1637113526929,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$imlwV3Nm-wCstaaYzvvM6gZ5PqMBLCpkSOjfqQp3wY4"},
{"content":{"body":"Its legal syntax, but always an error.","msgtype":"m.text"},"ts":1637115923371,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$B98CDAoJleqo9gvGye47_or061doHpYUvjxdX0RtDtY"},
{"content":{"body":"(a runtime error, but an error)","msgtype":"m.text"},"ts":1637115934827,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xwEkxDZiOucBgB3BeSxHY_ApsFxWaDwnUQeebq5q4fI"},
{"content":{"body":"There was some discussion about this in TDZ last meeting I think","msgtype":"m.text"},"ts":1637115952080,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QMb0JgNvzy_2fWUM84BcV9Ge7TOsKLJ6I8tBEs3yqa8"},
{"content":{"body":"The `QualifiedName{BindingPropertyList}` syntax collides with the proposed `match` syntax though, which would mean we'd need to disambiguate somehow:\n```js\n// option 1 - add => to 'when' clause:\nmatch (x) {\n  when Message.Write(message) => { ... }\n  when Message.Move{x, y} => { ... }\n}\nconst Message.Move{x, y} = z;\nconst Message.Write(message) = z;\n \n// option 2 - add disambiguator to InstanceBindingPattern:\nmatch (x) {\n  when Message.Write.(message) { ... }\n  when Message.Move.{x, y} { ... }\n}\nconst Message.Move.{x, y} = z;\nconst Message.Write.(message) = z;\n \n// option 3 - drop InstanceObjectPattern\nmatch (x) {\n  when Message.Write(message) { ... }\n  when Message.Move({x, y}) { ... }\n}\nconst Message.Move({x, y}) = z;\nconst Message.Write(message) = z;\n```\n\nOption 3 maybe isn't so bad?","format":"org.matrix.custom.html","formatted_body":"<p>The <code>QualifiedName{BindingPropertyList}</code> syntax collides with the proposed <code>match</code> syntax though, which would mean we'd need to disambiguate somehow:</p>\n<pre><code class=\"language-js\">// option 1 - add =&gt; to 'when' clause:\nmatch (x) {\n  when Message.Write(message) =&gt; { ... }\n  when Message.Move{x, y} =&gt; { ... }\n}\nconst Message.Move{x, y} = z;\nconst Message.Write(message) = z;\n \n// option 2 - add disambiguator to InstanceBindingPattern:\nmatch (x) {\n  when Message.Write.(message) { ... }\n  when Message.Move.{x, y} { ... }\n}\nconst Message.Move.{x, y} = z;\nconst Message.Write.(message) = z;\n \n// option 3 - drop InstanceObjectPattern\nmatch (x) {\n  when Message.Write(message) { ... }\n  when Message.Move({x, y}) { ... }\n}\nconst Message.Move({x, y}) = z;\nconst Message.Write(message) = z;\n</code></pre>\n<p>Option 3 maybe isn't so bad?</p>\n","msgtype":"m.text"},"ts":1637116617859,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$GHU4LKbwpvCrxQysjnELN74cSH5327DLSLnWZ5jxjxk"},
{"content":{"body":"Option 3 could work because of how I define ADT enum for a record/object here: https://gist.github.com/rbuckton/192c2922650e05a1ca9cd7c01be7fc6c\nA record/object ADT enum could have a @@destructure method that returns `[{ x, y }]`, so it would work with the nested destructuring pattern.","format":"org.matrix.custom.html","formatted_body":"Option 3 could work because of how I define ADT enum for a record/object here: https://gist.github.com/rbuckton/192c2922650e05a1ca9cd7c01be7fc6c<br>A record/object ADT enum could have a @@destructure method that returns <code>[{ x, y }]</code>, so it would work with the nested destructuring pattern.","msgtype":"m.text"},"ts":1637116765584,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DJAvRgL1qnWFhJYN2CNlC1IS1q6ocpKjFckGkpPn6VM"},
{"content":{"body":"> <@jackworks:matrix.org> And why you require a instanceof check? That's unreliable\n\nTrue, but you can hook `instanceof` using `Symbol.hasInstance` if your enum mapper wants to generate something more portable.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$RfjVtMxd5Iigy_HEVaPq0FdfAb6qnl50YatDIIqt3R0?via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>And why you require a instanceof check? That&#39;s unreliable</blockquote></mx-reply>True, but you can hook <code>instanceof</code> using <code>Symbol.hasInstance</code> if your enum mapper wants to generate something more portable.","m.relates_to":{"m.in_reply_to":{"event_id":"$RfjVtMxd5Iigy_HEVaPq0FdfAb6qnl50YatDIIqt3R0"}},"msgtype":"m.text"},"ts":1637117510315,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$p_p3WL1qYY0evHEf-OSoOKnXNo4oSa5di_IIcGBFV9w"},
{"content":{"body":"Making that a protocol sounds like a non starter","msgtype":"m.text"},"ts":1637117666910,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$poanwFFGqSX3TkgF3xfAvLUs29jccLDoQMToMxoqcEs"},
{"content":{"body":"The entire and only value of destructuring is that it’s sugar for normal property access; a protocol would shred that","msgtype":"m.text"},"ts":1637117687429,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$bMU3R7k9R_UUkxxpJmmMQaWpCDKRlefOK0Ek2YlEFzw"},
{"content":{"body":"* The entire and only value of destructuring is that it’s sugar for normal property access but without the duplicate naming; a protocol would shred that","m.new_content":{"body":"The entire and only value of destructuring is that it’s sugar for normal property access but without the duplicate naming; a protocol would shred that","msgtype":"m.text"},"m.relates_to":{"event_id":"$bMU3R7k9R_UUkxxpJmmMQaWpCDKRlefOK0Ek2YlEFzw","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1637117703274,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$WUuZoAqNDq88-fpkXlqmg3CyzEqKHW0fI3EQC_2glY0"},
{"content":{"body":"There's plenty of prior art though. C#'s `Deconstruct`, Scala's `unapply`. You can already hook array destructuring using `[Symbol.iterator]`.","format":"org.matrix.custom.html","formatted_body":"There's plenty of prior art though. C#'s <code>Deconstruct</code>, Scala's <code>unapply</code>. You can already hook array destructuring using <code>[Symbol.iterator]</code>.","msgtype":"m.text"},"ts":1637117849943,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kZyprzFpTv9Le3LQu7eyAb9oVCTYwhrVFbzB6tQj6L0"},
{"content":{"body":"And I disagree that that's the only value. Pattern matching makes it even more valuable.","msgtype":"m.text"},"ts":1637117884056,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bf3kvic5MP6q-fK7LBkv8Dmm5xMIHnz4LkkUbnxOMPU"},
{"content":{"body":"The only current value :-) pattern matching’s value is predicated on it exactly matching the simplicity that is destructuring.","msgtype":"m.text"},"ts":1637121184656,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$JYukATy3RvfQMXhGcx2lj2awUmfeBLw1YMkPR3bp_MU"},
{"content":{"body":"Prior art is useful to inspire how we might do something; it’s irrelevant tho when its unidiomatic for the language.","msgtype":"m.text"},"ts":1637121209273,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$SOb59u2-PyhIA0DWIDPzOzn_4aTxx7vf8AF46C-rqEU"},
{"content":{"body":"there’s tons of things tons of languages do that would be horrifically bad in JS; “prior art” isn’t a justification to add anything.","msgtype":"m.text"},"ts":1637121232662,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$LWibAQvIuSOuqfpPcs-aSpe1hIYB2cXqYS08lzrK2vg"}
]