[
{"content":{"body":"ljharb: Before I post in issue 216 (about caching) - our intention is that Gets are cached by path, right? So a `when({a, b}) ...; when({a}) ...;` will only result in `matchable.a` being observably retrieved a single time?","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a>: Before I post in issue 216 (about caching) - our intention is that Gets are cached by path, right? So a <code>when({a, b}) ...; when({a}) ...;</code> will only result in <code>matchable.a</code> being observably retrieved a single time?","msgtype":"m.text"},"ts":1639161370554,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$P4_GVvjpgEPGtPqaCUcHaoiES8RjmgniNn51tM_Tf5o"},
{"content":{"body":"The OP of the thread, as far as I can tell, is interpreting the caching behavior as caching by object identity (of the matchable compared to the array matcher) only, so we'll still retrieve properties multiple times, but the same iterator fetched in two different ways will cache across instances.","msgtype":"m.text"},"ts":1639161498571,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$WAx44EAKarAHjUYU7Gxb9vLm0oPKjHxv_YZ9k-AwMZA"},
{"content":{"body":"So:\n```js\nconst log = console.log;\nconst foo = {iter1: (function* () { log(\"1\"); yield 1; log(\"2\"); yield 2; log(\"3\");yield 3; })};\nfoo.iter2 = foo.iter1;\nmatch(foo) {\n when({iter1: [a]}) log(\"this fails to match, due to length check\");\n when({iter2: [a,b,c]}) log(\"matches, with 1, 2, 3\");\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>So:</p>\n<pre><code class=\"language-js\">const log = console.log;\nconst foo = {iter1: (function* () { log(&quot;1&quot;); yield 1; log(&quot;2&quot;); yield 2; log(&quot;3&quot;);yield 3; })};\nfoo.iter2 = foo.iter1;\nmatch(foo) {\n when({iter1: [a]}) log(&quot;this fails to match, due to length check&quot;);\n when({iter2: [a,b,c]}) log(&quot;matches, with 1, 2, 3&quot;);\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1639161572915,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$PY8BBiElC8gSp4wG2eZiklb54jukAhw0rRjuyBFOOUo"},
{"content":{"body":" * So:\n```js\nconst foo = {iter1: (function* () { yield 1; yield 2; yield 3; })};\nfoo.iter2 = foo.iter1;\n```","format":"org.matrix.custom.html","formatted_body":" * <p>So:</p>\n<pre><code class=\"language-js\">const foo = {iter1: (function* () { yield 1; yield 2; yield 3; })};\nfoo.iter2 = foo.iter1;\n</code></pre>\n","m.new_content":{"body":"So:\n```js\nconst foo = {iter1: (function* () { yield 1; yield 2; yield 3; })};\nfoo.iter2 = foo.iter1;\n```","format":"org.matrix.custom.html","formatted_body":"<p>So:</p>\n<pre><code class=\"language-js\">const foo = {iter1: (function* () { yield 1; yield 2; yield 3; })};\nfoo.iter2 = foo.iter1;\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$PY8BBiElC8gSp4wG2eZiklb54jukAhw0rRjuyBFOOUo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639161579443,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$dD36S1hR-Jx_PPnl-0GDrxcsPK0XiVWhjIbvUdrNcaI"},
{"content":{"body":" * So:\n```js\nconst log = console.log;\nconst foo = {iter1: (function* () { log(\"1\"); yield 1; log(\"2\"); yield 2; log(\"3\");yield 3; })};\nfoo.iter2 = foo.iter1;\nmatch(foo) {\n when({iter1: [a]}) log(\"this fails to match, due to length check\");\n when({iter2: [a,b,c]}) log(\"matches, with 1, 2, 3\");\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>So:</p>\n<pre><code class=\"language-js\">const log = console.log;\nconst foo = {iter1: (function* () { log(&quot;1&quot;); yield 1; log(&quot;2&quot;); yield 2; log(&quot;3&quot;);yield 3; })};\nfoo.iter2 = foo.iter1;\nmatch(foo) {\n when({iter1: [a]}) log(&quot;this fails to match, due to length check&quot;);\n when({iter2: [a,b,c]}) log(&quot;matches, with 1, 2, 3&quot;);\n}\n</code></pre>\n","m.new_content":{"body":"So:\n```js\nconst log = console.log;\nconst foo = {iter1: (function* () { log(\"1\"); yield 1; log(\"2\"); yield 2; log(\"3\");yield 3; })};\nfoo.iter2 = foo.iter1;\nmatch(foo) {\n when({iter1: [a]}) log(\"this fails to match, due to length check\");\n when({iter2: [a,b,c]}) log(\"matches, with 1, 2, 3\");\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>So:</p>\n<pre><code class=\"language-js\">const log = console.log;\nconst foo = {iter1: (function* () { log(&quot;1&quot;); yield 1; log(&quot;2&quot;); yield 2; log(&quot;3&quot;);yield 3; })};\nfoo.iter2 = foo.iter1;\nmatch(foo) {\n when({iter1: [a]}) log(&quot;this fails to match, due to length check&quot;);\n when({iter2: [a,b,c]}) log(&quot;matches, with 1, 2, 3&quot;);\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$PY8BBiElC8gSp4wG2eZiklb54jukAhw0rRjuyBFOOUo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639161722849,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$CHF2KmVJtocpJwAg-qazaHc8ipAyRrrUpXwA45GDXgg"},
{"content":{"body":"will result in logging \"1\", \"2\", \"3\", then the \"matches, with 1, 2, 3\" message.","msgtype":"m.text"},"ts":1639161745730,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$V-g6a_m7S4yBnlqtamXEr4_d-ekSDRvNZdgopYHqk00"},
{"content":{"body":"In what I assumed we were leaning towards (caching by path), the two would be considered separate, so we'd cache their results separately, and both would fail; the second because the iterator only has a single item left in it.","msgtype":"m.text"},"ts":1639161840070,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$TrEP4MftpDlewpAl53coVhUNzuhtCecix0VLgifV0aA"},
{"content":{"body":"oh, no it’d be both","msgtype":"m.text"},"ts":1639161843146,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$No3O6UmJYZiea0u-Hq2I7YHSsfzFFQ4gPWQ8CuY0s2g"},
{"content":{"body":"caching the object, and also the propertykey","msgtype":"m.text"},"ts":1639161852440,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$pG0qScJGtwcc3_Jk97I4IuArKK7eXCfXpRkdWf6yC1o"},
{"content":{"body":"iow you should see only one Get for any property name, ideally ","format":"org.matrix.custom.html","formatted_body":"iow you should see only one Get for any property name, ideally","msgtype":"m.text"},"ts":1639161869043,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$flhImBfxmTChs4Ux_DQrtfEV80yPNP8RLCF1IjBp73I"},
{"content":{"body":"sure. by \"both\", do you mean we *also* cache iterators themselves, so if the same iterator is accessed via multiple paths it reuses the cached results (as in the example I gave)?","format":"org.matrix.custom.html","formatted_body":"sure. by &quot;both&quot;, do you mean we <em>also</em> cache iterators themselves, so if the same iterator is accessed via multiple paths it reuses the cached results (as in the example I gave)?","msgtype":"m.text"},"ts":1639161912626,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$hz6j3iIPsomiFVfDQzKu9xUBLhR1G-EmAxMCUJNYm9g"},
{"content":{"body":"if the access is done by a pattern yes","msgtype":"m.text"},"ts":1639161955964,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$jZ8_i8unji-a-5CzA4OP5OVMtghub55J6cv5XV-VDJ0"},
{"content":{"body":"not if they it.next() themselves tho, that’s just one the match will “miss”","msgtype":"m.text"},"ts":1639162000597,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$wA9q8MGWhzJSq8zOZG39PizENSL86wl44nR_2pVcVDI"},
{"content":{"body":"yeah def, that's not in question","msgtype":"m.text"},"ts":1639162013635,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$bpkIYUjXl5FNhGtuCA0-SdNI_g5R0vzUidwu7X6pEFI"},
{"content":{"body":"I’m undecided about whether an inner match can share the cache of an outer match, but i think probably not?","msgtype":"m.text"},"ts":1639162047782,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$e2cvkfuAlX4NKEVT03YnF_VJGEpOF84IjKHkuss-gmg"},
{"content":{"body":"okay so this implies two separate caching mechanism, one that caches iterators specifically as {iterator => [items]} and another that's {(object, key) => item} for property access?","msgtype":"m.text"},"ts":1639162061924,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$ywIW6jcT7j0VWqYyqKTVFtuHDXQzKUQvamRt9q4I4Ok"},
{"content":{"body":"yes, exactly.","msgtype":"m.text"},"ts":1639162074499,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$haXU-rDz1K8ZF7DMMKKzCpdug0JM5wZop_GWuXFdHy0"},
{"content":{"body":"Okay, cool.","msgtype":"m.text"},"ts":1639162082300,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$Kc1rkwkUTsOuB0V-ocwJLaWE0zAQSKuFKSh41O60Hqk"},
{"content":{"body":"object caching is not a necessity, it’s just a nicety to increase determinism and reduce observability. But iterator caching is a necessity because otherwise matching on an iterator is useless","msgtype":"m.text"},"ts":1639162128974,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$WGnf6oO9BD3emX9KpE-74vNK-pNSCJ3v5ccy0EQWClc"},
{"content":{"body":"yeah, just wasn't sure if the iterator caching was being done *solely* thru paths, or by object identity of the thing we're matching against an array matcher","format":"org.matrix.custom.html","formatted_body":"yeah, just wasn't sure if the iterator caching was being done <em>solely</em> thru paths, or by object identity of the thing we're matching against an array matcher","msgtype":"m.text"},"ts":1639162203873,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$NWT14vuVtyVQhnc4nXebLm4NkfXZ-l3m5I1lvZteBIs"},
{"content":{"body":"if it was solely thru paths, then my code above would throw, since neither would match; it wouldn't recognize the iterator was the same both times.","msgtype":"m.text"},"ts":1639162237958,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$2qgDbY4ieo4EKgliUlQlsdo90SKijBUaTfpgoXHPoL4"},
{"content":{"body":"right, a good thing to clarify ","format":"org.matrix.custom.html","formatted_body":"right, a good thing to clarify","msgtype":"m.text"},"ts":1639162251245,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$uPPfDyhy5dvgq_WCCw8NnzsqZVj-jy7jazdCqxb-Z5s"},
{"content":{"body":"I'm writing a comment with this right now; I'll let you review it after posting before I fold it into the README","msgtype":"m.text"},"ts":1639162271725,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$Tc6KqPoVKQyqyQrtpiJBOxNSJR4lLKp24WV_u_Uk49I"},
{"content":{"body":"k, https://github.com/tc39/proposal-pattern-matching/issues/216#issuecomment-991216880","msgtype":"m.text"},"ts":1639162599632,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$22DDfMqG7DhV3-HB3H10U78nU41ED8jd_c8Vrb6T3Mk"},
{"content":{"body":"did we decide on an error to throw for lack of match?","msgtype":"m.text"},"ts":1639162862765,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$OjZJi3Tj6-UJSy0EvkHBoqKDbGLguAldSMZ-ddNzkOQ"},
{"content":{"body":"We didn’t. TypeError is the generic choice here; RangeError would be whimsically appropriate; there’s not really another builtin error type that would fit, and making a new one is probably unwarranted","msgtype":"m.text"},"ts":1639163698231,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$z_S3T5eWncfj_jjdb9WjbcDT92TVIvtk8Jk0akVUymY"},
{"content":{"body":"+1 for TypeError - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","format":"org.matrix.custom.html","formatted_body":"+1 for TypeError - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","msgtype":"m.text"},"ts":1639163787973,"senderName":"mpcsh","senderId":"@mpcsh_:matrix.org","id":"$p5On8Uu4Ge03c4etG8vOY2xHsSNAf3Ongl2pGtOyBdo"},
{"content":{"body":" * +1 for type error - in languages with ADTs, you're often concerned about covering every ~case~ variant of an enum type; that's the intuition for me here too","m.new_content":{"body":"+1 for type error - in languages with ADTs, you're often concerned about covering every ~case~ variant of an enum type; that's the intuition for me here too","msgtype":"m.text"},"m.relates_to":{"event_id":"$p5On8Uu4Ge03c4etG8vOY2xHsSNAf3Ongl2pGtOyBdo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639163799453,"senderName":"mpcsh","senderId":"@mpcsh_:matrix.org","id":"$3drlCDnuwOcd46U5MTQ8i-JFa4cPmPlH6iq46gcnhQE"},
{"content":{"body":" * +1 for type error - in languages with ADTs, you're often concerned about covering every ~~case~~ variant of an enum type; that's the intuition for me here too","m.new_content":{"body":"+1 for type error - in languages with ADTs, you're often concerned about covering every ~~case~~ variant of an enum type; that's the intuition for me here too","msgtype":"m.text"},"m.relates_to":{"event_id":"$p5On8Uu4Ge03c4etG8vOY2xHsSNAf3Ongl2pGtOyBdo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639163806696,"senderName":"mpcsh","senderId":"@mpcsh_:matrix.org","id":"$mGXethFOPaHfqlgm63f5-GREyGSQtOe6ln7Vx3FSRFg"},
{"content":{"body":" * +1 for type error - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","format":"org.matrix.custom.html","formatted_body":" * +1 for type error - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","m.new_content":{"body":"+1 for type error - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","format":"org.matrix.custom.html","formatted_body":"+1 for type error - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","msgtype":"m.text"},"m.relates_to":{"event_id":"$p5On8Uu4Ge03c4etG8vOY2xHsSNAf3Ongl2pGtOyBdo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639163817463,"senderName":"mpcsh","senderId":"@mpcsh_:matrix.org","id":"$O5Q9-UR12ZXGP2VZJJrjCipLOE-f17tHhKvJloS-DX4"},
{"content":{"body":" * +1 for TypeError - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","format":"org.matrix.custom.html","formatted_body":" * +1 for TypeError - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","m.new_content":{"body":"+1 for TypeError - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","format":"org.matrix.custom.html","formatted_body":"+1 for TypeError - in languages with ADTs, you're often concerned about covering every <del>case</del> variant of an enum type; that's the intuition for me here too","msgtype":"m.text"},"m.relates_to":{"event_id":"$p5On8Uu4Ge03c4etG8vOY2xHsSNAf3Ongl2pGtOyBdo","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1639163964372,"senderName":"mpcsh","senderId":"@mpcsh_:matrix.org","id":"$vb1wluDDyMPXcGs4RRsyygIEuBWZ2S-L3hv_g1qZnCo"},
{"content":{"body":"works for me","msgtype":"m.text"},"ts":1639164310851,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$MH9uW8GlOyKycXjcVDWoGD3vkQqtjEvQRtcZTtDmAbY"},
{"content":{"body":"Writing more examples for the README makes me really think we might want a separator between the LHS and RHS.","msgtype":"m.text"},"ts":1639169880681,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$tSwm97Q4UJsewx_qEarEnIecyLHidLPIKtOrDkTkKJ0"},
{"content":{"body":"All right, I think the README is up-to-date with our decisions, and has all the discussed future extensions catalogued as well.","msgtype":"m.text"},"ts":1639175931072,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$Bf0YnPmO6Lma0ULXMu5M6cYpKsczW2CcZhjsd00VaOU"},
{"content":{"body":"> <@tabatkins:matrix.org> Writing more examples for the README makes me really think we might want a separator between the LHS and RHS.\n\nLooking at it, I would agree. `:` or `=>` or `->` or something like it? I wasn't fond of `{}` as it was confusing when the result was an object literal, and `do {}` could give you block syntax if necessary. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$tSwm97Q4UJsewx_qEarEnIecyLHidLPIKtOrDkTkKJ0?via=matrix.org&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">@tabatkins:matrix.org</a><br />Writing more examples for the README makes me really think we might want a separator between the LHS and RHS.</blockquote></mx-reply>Looking at it, I would agree. `:` or `=>` or `->` or something like it? I wasn't fond of `{}` as it was confusing when the result was an object literal, and `do {}` could give you block syntax if necessary. ","m.relates_to":{"m.in_reply_to":{"event_id":"$tSwm97Q4UJsewx_qEarEnIecyLHidLPIKtOrDkTkKJ0"}},"msgtype":"m.text"},"ts":1639178345249,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$m-Tx-T06WonnhzIhe0_CL-w7tGWWjU0D6QavRKXr3Nc"},
{"content":{"body":"We're rejecting => immediately because it suggests arrow function semantics we absolutely do not have, but : and -> are the leading two ideas, yeah","msgtype":"m.text"},"ts":1639179157910,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$jRHuTXOSdjpYZYFJvMDiM-xcVOmaAwm_YEMWHVf2hTE"},
{"content":{"body":"Previous iterations used ->, which I rather like, but it's novel, prevents future usages (like adding type hints a la Python)","msgtype":"m.text"},"ts":1639179246795,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$1bR1ncZUnXUeW4scqlk1_Ur0tooJ1YGOdGaxBd0y4Jw"},
{"content":{"body":": is quite possible, tho","msgtype":"m.text"},"ts":1639179258550,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$G9TIuAiRzgQTE5mP0EnHm7K2T4BpP_Qmjti9sonPUm0"},
{"content":{"body":"I feel like we should also come up with a name for the `when()` part, specifically","msgtype":"m.text"},"ts":1639179379220,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$yYY5mxOTiq7LyHFrym5QSgD0ZQCqtVcM_gIUJ7owlr8"},
{"content":{"body":"\"the LHS of the matcher clause\" could be more succinct, i suppose","msgtype":"m.text"},"ts":1639179418703,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$lu2pmBNc4I2Py86Jk12I6JXoFM5NxsqCALBB1etx7Iw"},
{"content":{"body":"\"the when\" works too","msgtype":"m.text"},"ts":1639179435609,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$qCQMm68Gyh4JVBakRM5dbSzvv-i7a3ArkBP-6jU-Au8"},
{"content":{"body":"Yeah I mean specifically the when part, not guards or else","msgtype":"m.text"},"ts":1639179655388,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$ozuHNkWZL9LsrIMWG3JOBoz6uI-JvYoKeGIcXf-CLWw"},
{"content":{"body":"I have to talk about it a little in the readme, and it's awkward","msgtype":"m.text"},"ts":1639179684426,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$tWDvyIK7acOGqZUgdWkr8fno0bMxuykmVNxrA4Ks4PU"},
{"content":{"body":"Fine with clause LHS for the whole thing","msgtype":"m.text"},"ts":1639179699610,"senderName":"TabAtkins","senderId":"@tabatkins:matrix.org","id":"$9Qc1Av5qSLbqU2WqG9-j6U1h-iKAk5jrWibGuRB5rkA"}
]