[
{"content":{"body":"I hope you don't mind me butting in - just a distant observer. I quite like the presentation of the layering from yulia . However, one concern, which I think TabAtkins picked upon, with the specific content of the proposal is that the `let when` matching doesn't allow for matching on nested properties, which I think its pretty core the value of the original pattern matching proposal and is a common feature across prior art in other languages. \n\nFor some context, I originally suggested expanding the matcher proposal to include implementation for at least all scalars in the language, and I provide some example use cases in the first few comments https://github.com/tc39/proposal-pattern-matching/issues/209","format":"org.matrix.custom.html","formatted_body":"<p>I hope you don't mind me butting in - just a distant observer. I quite like the presentation of the layering from <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia</a> . However, one concern, which I think <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">TabAtkins</a> picked upon, with the specific content of the proposal is that the <code>let when</code> matching doesn't allow for matching on nested properties, which I think its pretty core the value of the original pattern matching proposal and is a common feature across prior art in other languages.</p>\n<p>For some context, I originally suggested expanding the matcher proposal to include implementation for at least all scalars in the language, and I provide some example use cases in the first few comments https://github.com/tc39/proposal-pattern-matching/issues/209</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I hope you don't mind me butting in - just a distant observer. I quite like the presentation of the layering from yulia . However, one concern, which I think TabAtkins picked upon, with the specific content of the proposal is that the `let when` matching doesn't allow for matching on nested properties, which I think its pretty core the value of the original pattern matching proposal and is a common feature across prior art in other languages. \n\nFor some context, I originally suggested expanding the matcher proposal to include implementation for at least all scalars in the language, and I provide some example use cases in the first few comments https://github.com/tc39/proposal-pattern-matching/issues/209","mimetype":"text/plain"},{"body":"<p>I hope you don't mind me butting in - just a distant observer. I quite like the presentation of the layering from <a href=\"https://matrix.to/#/@yulia:mozilla.org\">yulia</a> . However, one concern, which I think <a href=\"https://matrix.to/#/@tabatkins:matrix.org\">TabAtkins</a> picked upon, with the specific content of the proposal is that the <code>let when</code> matching doesn't allow for matching on nested properties, which I think its pretty core the value of the original pattern matching proposal and is a common feature across prior art in other languages.</p>\n<p>For some context, I originally suggested expanding the matcher proposal to include implementation for at least all scalars in the language, and I provide some example use cases in the first few comments https://github.com/tc39/proposal-pattern-matching/issues/209</p>\n","mimetype":"text/html"}]},"ts":1659002865053,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$0OGaRHnB4QvXh4BfmoGhxqMz5Sb9W-RszyuZa_vMBFU"},
{"content":{"body":"but I can definitely see the value of building up the feature from smaller parts that can be used standalone - it could make it a better integrated feature in the language if its made up of smaller parts that have value elsewhere","msgtype":"m.text","org.matrix.msc1767.text":"but I can definitely see the value of building up the feature from smaller parts that can be used standalone - it could make it a better integrated feature in the language if its made up of smaller parts that have value elsewhere"},"ts":1659002980670,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$mGXcwU1dKKHPuI0iB9JeJ65sineTO65SQ1OLuRRbzNQ"},
{"content":{"body":"easier to understand, and educate users","msgtype":"m.text","org.matrix.msc1767.text":"easier to understand, and educate users"},"ts":1659002994895,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$qghKgKoYxpAeFhIQXLTNsrci5bsT2hX2ZRmm_WyzilY"},
{"content":{"body":"let-when (in my original thinking) is intentionally restricted to make sure that it is unambiguous for users","msgtype":"m.text","org.matrix.msc1767.text":"let-when (in my original thinking) is intentionally restricted to make sure that it is unambiguous for users"},"ts":1659003039292,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$p2x4OlK7VzN6Cia8xtu18whypQZ5_mYJfqsHx1dK8To"},
{"content":{"body":"but, if you need more complex matching, you can break it into let ... when ... where the when is more powerful","msgtype":"m.text","org.matrix.msc1767.text":"but, if you need more complex matching, you can break it into let ... when ... where the when is more powerful"},"ts":1659003055055,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$fELc6nxTLeEkPXX7sRFP2YsZuuTIzgCZOkstSiYurGw"},
{"content":{"body":"its an idea -- largely coming from a difficulty that you also noted in your examples that it is a little difficult to tell how destructuring works exactly. That problem will be compounded if we are not careful. Especially if we allow patterns in other contexts (which i believe will be very powerful and we should try)","msgtype":"m.text","org.matrix.msc1767.text":"its an idea -- largely coming from a difficulty that you also noted in your examples that it is a little difficult to tell how destructuring works exactly. That problem will be compounded if we are not careful. Especially if we allow patterns in other contexts (which i believe will be very powerful and we should try)"},"ts":1659003109319,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$rFzPhJygIygxTqU9MskY3_a-AgKjR9mDtyXJJ4epYM8"},
{"content":{"body":"can you point me to a more specific example? I am (as always) low on time, so i can only take a glance at the very detailed comments you have. You can take one specific one and ill take a look","msgtype":"m.text","org.matrix.msc1767.text":"can you point me to a more specific example? I am (as always) low on time, so i can only take a glance at the very detailed comments you have. You can take one specific one and ill take a look"},"ts":1659003155309,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$55zHvkV2Yf71-XaiJPLto2pptDEdD0RFbe8qC-3-71A"},
{"content":{"body":"yeah, but in prior art I wouldn't need to say use a `where` clause for matching against a nested `Some` for example","format":"org.matrix.custom.html","formatted_body":"yeah, but in prior art I wouldn't need to say use a <code>where</code> clause for matching against a nested <code>Some</code> for example","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"yeah, but in prior art I wouldn't need to say use a `where` clause for matching against a nested `Some` for example","mimetype":"text/plain"},{"body":"yeah, but in prior art I wouldn't need to say use a <code>where</code> clause for matching against a nested <code>Some</code> for example","mimetype":"text/html"}]},"ts":1659003161808,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$WhLkXDjaTf9NFV7ksrv3bleP4g-x6kdnI14xuGN6yds"},
{"content":{"body":"A `Some` containing a `Some`","format":"org.matrix.custom.html","formatted_body":"A <code>Some</code> containing a <code>Some</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"A `Some` containing a `Some`","mimetype":"text/plain"},{"body":"A <code>Some</code> containing a <code>Some</code>","mimetype":"text/html"}]},"ts":1659003178842,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$BxIf6N8FlrlDxNrrQEvqETV1xHSiMFwpVaqIL4_-DBo"},
{"content":{"body":"can you write out what you have in mind?","msgtype":"m.text","org.matrix.msc1767.text":"can you write out what you have in mind?"},"ts":1659003205257,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$UOmFTqdsoDg_hPkyTFK_j8w31LGcdCBeYT5_PnuuPbw"},
{"content":{"body":"forgive the made up syntax, just copying it from the issue I linked\n\n```ts\ntype User = \n  | { id: string, name: string} \n  | { id: string, name: { name: string } } \n  | string \n  | number \n  | null\n\ndeclare function getNameFromId(id: number): string;\n\ndeclare const user: User;\n\n// again I'm not sure about how binding works in this proposals, so taking a haphazard guess\nconst str = match( user ) {\n  when ( { name: _string } ) { name }\n  when ( { name: { name } ) { name }\n  when _string { user }\n  when _number { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n\n```","format":"org.matrix.custom.html","formatted_body":"<p>forgive the made up syntax, just copying it from the issue I linked</p>\n<pre><code class=\"language-ts\">type User = \n  | { id: string, name: string} \n  | { id: string, name: { name: string } } \n  | string \n  | number \n  | null\n\ndeclare function getNameFromId(id: number): string;\n\ndeclare const user: User;\n\n// again I'm not sure about how binding works in this proposals, so taking a haphazard guess\nconst str = match( user ) {\n  when ( { name: _string } ) { name }\n  when ( { name: { name } ) { name }\n  when _string { user }\n  when _number { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"forgive the made up syntax, just copying it from the issue I linked\n\n```ts\ntype User = \n  | { id: string, name: string} \n  | { id: string, name: { name: string } } \n  | string \n  | number \n  | null\n\ndeclare function getNameFromId(id: number): string;\n\ndeclare const user: User;\n\n// again I'm not sure about how binding works in this proposals, so taking a haphazard guess\nconst str = match( user ) {\n  when ( { name: _string } ) { name }\n  when ( { name: { name } ) { name }\n  when _string { user }\n  when _number { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n\n```","mimetype":"text/plain"},{"body":"<p>forgive the made up syntax, just copying it from the issue I linked</p>\n<pre><code class=\"language-ts\">type User = \n  | { id: string, name: string} \n  | { id: string, name: { name: string } } \n  | string \n  | number \n  | null\n\ndeclare function getNameFromId(id: number): string;\n\ndeclare const user: User;\n\n// again I'm not sure about how binding works in this proposals, so taking a haphazard guess\nconst str = match( user ) {\n  when ( { name: _string } ) { name }\n  when ( { name: { name } ) { name }\n  when _string { user }\n  when _number { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659003228322,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$0TccI9WGi58jpI2P_OI5DJEfK2I8_ryFpTjwNXWQcpo"},
{"content":{"body":"its kinda arbitrary and refers back to when `do` was part of the proposal","format":"org.matrix.custom.html","formatted_body":"its kinda arbitrary and refers back to when <code>do</code> was part of the proposal","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"its kinda arbitrary and refers back to when `do` was part of the proposal","mimetype":"text/plain"},{"body":"its kinda arbitrary and refers back to when <code>do</code> was part of the proposal","mimetype":"text/html"}]},"ts":1659003275120,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$yUdCqgaPM3S7QoMOvXZVCisu78uzi6neyD9h4XDODfg"},
{"content":{"body":" * its kinda arbitrary and refers back to when `do` was part of the proposal","format":"org.matrix.custom.html","formatted_body":" * its kinda arbitrary and refers back to when <code>do</code> was part of the proposal","m.new_content":{"body":"its kinda arbitrary and refers back to when `do` was part of the proposal","format":"org.matrix.custom.html","formatted_body":"its kinda arbitrary and refers back to when <code>do</code> was part of the proposal","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"its kinda arbitrary and refers back to when `do` was part of the proposal","mimetype":"text/plain"},{"body":"its kinda arbitrary and refers back to when <code>do</code> was part of the proposal","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$yUdCqgaPM3S7QoMOvXZVCisu78uzi6neyD9h4XDODfg","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * its kinda arbitrary and refers back to when `do` was part of the proposal","mimetype":"text/plain"},{"body":" * its kinda arbitrary and refers back to when <code>do</code> was part of the proposal","mimetype":"text/html"}]},"ts":1659003281947,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$g3e-0BoQECVXul-aoi4vJh0E-aERAH9F9448eFEoGSY"},
{"content":{"body":"the proposal hasnt' changed at the moment","msgtype":"m.text","org.matrix.msc1767.text":"the proposal hasnt' changed at the moment"},"ts":1659003296642,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$WuqZ1o2vJfaZGjnV6zzoi3gM9nzARBBMd8Ohyr0bnHI"},
{"content":{"body":"so you mean this kind of match","msgtype":"m.text","org.matrix.msc1767.text":"so you mean this kind of match"},"ts":1659003306904,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$6VtVkWX9Hsemzr9ZASTbhvYHwcKmT1G7FMdI7NiqSmg"},
{"content":{"body":"```js\nconst str = match( user ) {\n  when ( { name: _string } ) { name }\n  when ( { name: { name } ) { name }\n  when _string { user }\n  when _number { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">const str = match( user ) {\n  when ( { name: _string } ) { name }\n  when ( { name: { name } ) { name }\n  when _string { user }\n  when _number { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"```js\nconst str = match( user ) {\n  when ( { name: _string } ) { name }\n  when ( { name: { name } ) { name }\n  when _string { user }\n  when _number { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```","mimetype":"text/plain"},{"body":"<pre><code class=\"language-js\">const str = match( user ) {\n  when ( { name: _string } ) { name }\n  when ( { name: { name } ) { name }\n  when _string { user }\n  when _number { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659003310071,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$TWI6FgYp4VCCEohKLPCu44z4o5IT3MjxKb0qFpFH8ME"},
{"content":{"body":"haha, yes","msgtype":"m.text","org.matrix.msc1767.text":"haha, yes"},"ts":1659003330306,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$geZPdrwMp1pZMd920nd3HizrcqZO2i67qiPrzokfFPE"},
{"content":{"body":"I'm guessing you read the issue","msgtype":"m.text","org.matrix.msc1767.text":"I'm guessing you read the issue"},"ts":1659003337802,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$t0rot2KzcmNP1hTaQLNmQnIjb_GAOPRRbfxfFenwFF8"},
{"content":{"body":"and i guess with the current proposal it would look like this","msgtype":"m.text","org.matrix.msc1767.text":"and i guess with the current proposal it would look like this"},"ts":1659003341119,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$iOplpecMLnQA80M8hoqicaCmHXt6ysq5GS0G0geY7Zw"},
{"content":{"body":"`_string` is kinda like `${String}` or in a previous iteration `^String`","format":"org.matrix.custom.html","formatted_body":"<code>_string</code> is kinda like <code>${String}</code> or in a previous iteration <code>^String</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`_string` is kinda like `${String}` or in a previous iteration `^String`","mimetype":"text/plain"},{"body":"<code>_string</code> is kinda like <code>${String}</code> or in a previous iteration <code>^String</code>","mimetype":"text/html"}]},"ts":1659003357669,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$u01LAq53JAM4M-W-R528wgUCAO9zRsRhpCgulAw3QXs"},
{"content":{"body":"```js\nconst str = match( user ) {\n  when ( { name: ${String} } ) { name }\n  when ( { name: { name } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code class=\"language-js\">const str = match( user ) {\n  when ( { name: ${String} } ) { name }\n  when ( { name: { name } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"```js\nconst str = match( user ) {\n  when ( { name: ${String} } ) { name }\n  when ( { name: { name } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```","mimetype":"text/plain"},{"body":"<pre><code class=\"language-js\">const str = match( user ) {\n  when ( { name: ${String} } ) { name }\n  when ( { name: { name } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659003398065,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$rjElnaRgdtoT671DOwCDGMwLiV4sVpf7xo6vxv7o2vo"},
{"content":{"body":"yep, that is how it would roughly look I think in the current proposal ","msgtype":"m.text","org.matrix.msc1767.text":"yep, that is how it would roughly look I think in the current proposal "},"ts":1659003424729,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$SwxmcUjYmQsoCPMCCPiN641b73Ltop1oE-_oUl2vvX4"},
{"content":{"body":"I'm matching potentially on a union of possible values, and some of those values have nested properties that I want to match against","msgtype":"m.text","org.matrix.msc1767.text":"I'm matching potentially on a union of possible values, and some of those values have nested properties that I want to match against"},"ts":1659003590377,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$300OEY53aIzpaotG3Zhwkrp7U6JRz2WNTJ87IbygVlY"},
{"content":{"body":"in the fully layered version, we could have:\n\n\n```js\nfunction hasName(user) {\n  if (user.name) {\n    if (user.name.name) {\n       return MatchPattern({ result: true, value: user.name.name})\n    }\n    return MatchPattern({ result: true, value: user.name})\n  }\n  return MatchPattern({ result: false} )\n}\nconst str = match( user ) {\n  let { name } when hasName { name }\n  when String { user }\n  when Number { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>in the fully layered version, we could have:</p>\n<pre><code class=\"language-js\">function hasName(user) {\n  if (user.name) {\n    if (user.name.name) {\n       return MatchPattern({ result: true, value: user.name.name})\n    }\n    return MatchPattern({ result: true, value: user.name})\n  }\n  return MatchPattern({ result: false} )\n}\nconst str = match( user ) {\n  let { name } when hasName { name }\n  when String { user }\n  when Number { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"in the fully layered version, we could have:\n\n\n```js\nfunction hasName(user) {\n  if (user.name) {\n    if (user.name.name) {\n       return MatchPattern({ result: true, value: user.name.name})\n    }\n    return MatchPattern({ result: true, value: user.name})\n  }\n  return MatchPattern({ result: false} )\n}\nconst str = match( user ) {\n  let { name } when hasName { name }\n  when String { user }\n  when Number { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```","mimetype":"text/plain"},{"body":"<p>in the fully layered version, we could have:</p>\n<pre><code class=\"language-js\">function hasName(user) {\n  if (user.name) {\n    if (user.name.name) {\n       return MatchPattern({ result: true, value: user.name.name})\n    }\n    return MatchPattern({ result: true, value: user.name})\n  }\n  return MatchPattern({ result: false} )\n}\nconst str = match( user ) {\n  let { name } when hasName { name }\n  when String { user }\n  when Number { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659003630944,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$n4n1hlppqkv1MI41kX-0i0a1TanpRYM2GsBgKUzP0-o"},
{"content":{"body":"I suppose the issue is then that I have to now create a dedicated function for matching against this - I suppose this could be solved in userland ","msgtype":"m.text","org.matrix.msc1767.text":"I suppose the issue is then that I have to now create a dedicated function for matching against this - I suppose this could be solved in userland "},"ts":1659003668821,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$kIQtS_acRC0CrQE9tf372HheDzM64hSwlYkHXO2wFe0"},
{"content":{"body":"I can imagine that userland libraries will emerge that would allow you to construct that function ","msgtype":"m.text","org.matrix.msc1767.text":"I can imagine that userland libraries will emerge that would allow you to construct that function "},"ts":1659003686070,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$_iYhrd36sMXt5sRvjzcS4T-EjiXkIHIDAut0xSNw1Pw"},
{"content":{"body":"but you could arguably do \n```js\nconst str = match( user ) {\n  let when ( { name: { name } ) { name }\n  let when ( { name } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```\n\nthis misses the string because i haven't thought that through","format":"org.matrix.custom.html","formatted_body":"<p>but you could arguably do</p>\n<pre><code class=\"language-js\">const str = match( user ) {\n  let when ( { name: { name } ) { name }\n  let when ( { name } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n<p>this misses the string because i haven't thought that through</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"but you could arguably do \n```js\nconst str = match( user ) {\n  let when ( { name: { name } ) { name }\n  let when ( { name } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```\n\nthis misses the string because i haven't thought that through","mimetype":"text/plain"},{"body":"<p>but you could arguably do</p>\n<pre><code class=\"language-js\">const str = match( user ) {\n  let when ( { name: { name } ) { name }\n  let when ( { name } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n<p>this misses the string because i haven't thought that through</p>\n","mimetype":"text/html"}]},"ts":1659003703444,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$W2I8ueOvRQ_28pvG09ZLHVJLmdvaKu3UQC_xzNvRY7E"},
{"content":{"body":"> <@yulia:mozilla.org> in the fully layered version, we could have:\n> \n> \n> ```js\n> function hasName(user) {\n>   if (user.name) {\n>     if (user.name.name) {\n>        return MatchPattern({ result: true, value: user.name.name})\n>     }\n>     return MatchPattern({ result: true, value: user.name})\n>   }\n>   return MatchPattern({ result: false} )\n> }\n> const str = match( user ) {\n>   let { name } when hasName { name }\n>   when String { user }\n>   when Number { getNameFromId(user) }\n>   otherwise { \"unknown user\" }\n> }\n> ```\n\nI think a consequence of this is that we will likely have a proliferation of user lands libraries that give you builders for these functions to build up complex patterns with nested values ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$n4n1hlppqkv1MI41kX-0i0a1TanpRYM2GsBgKUzP0-o?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@yulia:mozilla.org\">@yulia:mozilla.org</a><br><p>in the fully layered version, we could have:</p>\n<pre><code class=\"language-js\">function hasName(user) {\n  if (user.name) {\n    if (user.name.name) {\n       return MatchPattern({ result: true, value: user.name.name})\n    }\n    return MatchPattern({ result: true, value: user.name})\n  }\n  return MatchPattern({ result: false} )\n}\nconst str = match( user ) {\n  let { name } when hasName { name }\n  when String { user }\n  when Number { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n</code></pre>\n</blockquote></mx-reply>I think a consequence of this is that we will likely have a proliferation of user lands libraries that give you builders for these functions to build up complex patterns with nested values","m.relates_to":{"m.in_reply_to":{"event_id":"$n4n1hlppqkv1MI41kX-0i0a1TanpRYM2GsBgKUzP0-o"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@yulia:mozilla.org> in the fully layered version, we could have:\n> \n> \n> ```js\n> function hasName(user) {\n>   if (user.name) {\n>     if (user.name.name) {\n>        return MatchPattern({ result: true, value: user.name.name})\n>     }\n>     return MatchPattern({ result: true, value: user.name})\n>   }\n>   return MatchPattern({ result: false} )\n> }\n> const str = match( user ) {\n>   let { name } when hasName { name }\n>   when String { user }\n>   when Number { getNameFromId(user) }\n>   otherwise { \"unknown user\" }\n> }\n> ```\n\nI think a consequence of this is that we will likely have a proliferation of user lands libraries that give you builders for these functions to build up complex patterns with nested values ","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$n4n1hlppqkv1MI41kX-0i0a1TanpRYM2GsBgKUzP0-o?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@yulia:mozilla.org\">@yulia:mozilla.org</a><br><p>in the fully layered version, we could have:</p>\n<pre><code class=\"language-js\">function hasName(user) {\n  if (user.name) {\n    if (user.name.name) {\n       return MatchPattern({ result: true, value: user.name.name})\n    }\n    return MatchPattern({ result: true, value: user.name})\n  }\n  return MatchPattern({ result: false} )\n}\nconst str = match( user ) {\n  let { name } when hasName { name }\n  when String { user }\n  when Number { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n</code></pre>\n</blockquote></mx-reply>I think a consequence of this is that we will likely have a proliferation of user lands libraries that give you builders for these functions to build up complex patterns with nested values","mimetype":"text/html"}]},"ts":1659003783296,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$_636xhdu5byK8Y9KiBDRsXIwcq1gdJLlzJevNhfQ8hY"},
{"content":{"body":"though this is also possible: \n```js\nconst str = match( user ) {\n  let { name: name } when ( { name: { name: ${String} } ) { name }\n  let { name }  when ( { name: ${String} } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>though this is also possible:</p>\n<pre><code class=\"language-js\">const str = match( user ) {\n  let { name: name } when ( { name: { name: ${String} } ) { name }\n  let { name }  when ( { name: ${String} } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"though this is also possible: \n```js\nconst str = match( user ) {\n  let { name: name } when ( { name: { name: ${String} } ) { name }\n  let { name }  when ( { name: ${String} } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { \"unknown user\" }\n}\n```","mimetype":"text/plain"},{"body":"<p>though this is also possible:</p>\n<pre><code class=\"language-js\">const str = match( user ) {\n  let { name: name } when ( { name: { name: ${String} } ) { name }\n  let { name }  when ( { name: ${String} } ) { name }\n  when (${String}) { user }\n  when ($number}) { getNameFromId(user) }\n  otherwise { &quot;unknown user&quot; }\n}\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659003784633,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$hHMpIyWdpEsrCdV6AJD00Lb_bRptwyQ_qYfFb5lA3Dg"},
{"content":{"body":"which might not be a bad thing","msgtype":"m.text","org.matrix.msc1767.text":"which might not be a bad thing"},"ts":1659003791208,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$p89Qui73zWS02prxi6Q9gkL4aFBstvsF33990ZQjxf4"},
{"content":{"body":"it might give us more type safety in a dynamic language, which i guess is also an interest of mine","msgtype":"m.text","org.matrix.msc1767.text":"it might give us more type safety in a dynamic language, which i guess is also an interest of mine"},"ts":1659003816402,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$lTT9udPwI2ofVB8EG7ttYv4FRS6xF1Y9mCZa6V8Xnw8"},
{"content":{"body":"oh that is interesting ","msgtype":"m.text","org.matrix.msc1767.text":"oh that is interesting "},"ts":1659003817914,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$qpkyQiwaR7kmnteuLoB-KBXiuToK_DB_2xwRPi0NGS8"},
{"content":{"body":"effectively matching on structures, and making that something that can be used almost anywhere","msgtype":"m.text","org.matrix.msc1767.text":"effectively matching on structures, and making that something that can be used almost anywhere"},"ts":1659003830255,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$lOF5RRff5gRcY9JwxxGA1eFTtaMFxQVjeF9om9dUnj0"},
{"content":{"body":"but with the way the syntax is right now, it shadows and overlaps with destructuring in a way that may be ambiguous","msgtype":"m.text","org.matrix.msc1767.text":"but with the way the syntax is right now, it shadows and overlaps with destructuring in a way that may be ambiguous"},"ts":1659003852014,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$aTUhWKdigAtDyw5syVQulOEOF5QFfEqs9DtkNl5Vzz8"},
{"content":{"body":"so in a way we are moving the pattern matching syntax slightly over to the right?","msgtype":"m.text","org.matrix.msc1767.text":"so in a way we are moving the pattern matching syntax slightly over to the right?"},"ts":1659003867243,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$02pU7PI3zSTDgifpfdELfmStH9EBcXErdZEQax2unWc"},
{"content":{"body":"or the left, it can be `when { ... } as { ... } `","format":"org.matrix.custom.html","formatted_body":"or the left, it can be <code>when { ... } as { ... } </code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"or the left, it can be `when { ... } as { ... } `","mimetype":"text/plain"},{"body":"or the left, it can be <code>when { ... } as { ... } </code>","mimetype":"text/html"}]},"ts":1659003879215,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$xuxosMZezzB1Q2_A3Rl0FRn_gI4BJSZh2b7d6sWtn3o"},
{"content":{"body":"`( { name: { name: ${String} } )` is going to create a funciton?","format":"org.matrix.custom.html","formatted_body":"<code>( { name: { name: ${String} } )</code> is going to create a funciton?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"`( { name: { name: ${String} } )` is going to create a funciton?","mimetype":"text/plain"},{"body":"<code>( { name: { name: ${String} } )</code> is going to create a funciton?","mimetype":"text/html"}]},"ts":1659003880388,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$-HO1z50_xmN_SYymioQ_bUuwLVxskobjUGM3EzAvCoU"},
{"content":{"body":"equivalent to `hasName`","format":"org.matrix.custom.html","formatted_body":"equivalent to <code>hasName</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"equivalent to `hasName`","mimetype":"text/plain"},{"body":"equivalent to <code>hasName</code>","mimetype":"text/html"}]},"ts":1659003897437,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$egAiV5myGxCRYQP7pbEn45Hc-GDqO4aE6SKH9sWhmy0"},
{"content":{"body":"> <@m-rutter:matrix.org> `( { name: { name: ${String} } )` is going to create a funciton?\n\na matcher rather, but same idea","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$-HO1z50_xmN_SYymioQ_bUuwLVxskobjUGM3EzAvCoU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@m-rutter:matrix.org\">@m-rutter:matrix.org</a><br><code>( { name: { name: ${String} } )</code> is going to create a funciton?</blockquote></mx-reply>a matcher rather, but same idea","m.relates_to":{"m.in_reply_to":{"event_id":"$-HO1z50_xmN_SYymioQ_bUuwLVxskobjUGM3EzAvCoU"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@m-rutter:matrix.org> `( { name: { name: ${String} } )` is going to create a funciton?\n\na matcher rather, but same idea","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$-HO1z50_xmN_SYymioQ_bUuwLVxskobjUGM3EzAvCoU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@m-rutter:matrix.org\">@m-rutter:matrix.org</a><br><code>( { name: { name: ${String} } )</code> is going to create a funciton?</blockquote></mx-reply>a matcher rather, but same idea","mimetype":"text/html"}]},"ts":1659003899641,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$2EIVeUzZMUHjkVee7DPKALhoi7PBTXwfpBxEROPfQNM"},
{"content":{"body":"matcher as defined in the current proposal","msgtype":"m.text","org.matrix.msc1767.text":"matcher as defined in the current proposal"},"ts":1659003908751,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$2e18dP87JE82FzwhGhhLtVO4714JWoRgPbg10SU9iYA"},
{"content":{"body":"ok, that sound fairly reasonable to me ","msgtype":"m.text","org.matrix.msc1767.text":"ok, that sound fairly reasonable to me "},"ts":1659003921122,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$bw-ktvzba4YRRJE-aP-E3tz93_moj5wzaomUXl_bCgA"},
{"content":{"body":"that could be a way of addressing my concern ","msgtype":"m.text","org.matrix.msc1767.text":"that could be a way of addressing my concern "},"ts":1659003935801,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$H38Xkc2UT2FYcGkLMoMvNYGJHjRZH_mPkkqR6b9kTxk"},
{"content":{"body":"binding happens on the left, matcher is constructed in the middle, expression on the right ","msgtype":"m.text","org.matrix.msc1767.text":"binding happens on the left, matcher is constructed in the middle, expression on the right "},"ts":1659003976459,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$MRbzNfy9C_qh1EpddnvudB8oUyjrN36riMLasdoGjX4"},
{"content":{"body":"i have a crazy idea (please no one shoot me for this, this is a thought experiment)\n\n```js\nfunction handle(res when { status: 200 }) {...} // matched when no \"body\" present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when \"body\" is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when \"body\" is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n```","format":"org.matrix.custom.html","formatted_body":"<p>i have a crazy idea (please no one shoot me for this, this is a thought experiment)</p>\n<pre><code class=\"language-js\">function handle(res when { status: 200 }) {...} // matched when no &quot;body&quot; present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when &quot;body&quot; is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when &quot;body&quot; is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"i have a crazy idea (please no one shoot me for this, this is a thought experiment)\n\n```js\nfunction handle(res when { status: 200 }) {...} // matched when no \"body\" present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when \"body\" is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when \"body\" is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n```","mimetype":"text/plain"},{"body":"<p>i have a crazy idea (please no one shoot me for this, this is a thought experiment)</p>\n<pre><code class=\"language-js\">function handle(res when { status: 200 }) {...} // matched when no &quot;body&quot; present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when &quot;body&quot; is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when &quot;body&quot; is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659004014366,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$NGKz5TzormTacNMyzsg5My2-1w7pwRbECZiBoJN-RkU"},
{"content":{"body":"you might recognize this as pattern matching of a different sort -- specifically haskell-likes","msgtype":"m.text","org.matrix.msc1767.text":"you might recognize this as pattern matching of a different sort -- specifically haskell-likes"},"ts":1659004029133,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$OAitRqzptLrHhO1ZCyXZsv3VZoJAbQzxIjdpJ36dgh0"},
{"content":{"body":" * i have a crazy idea (please no one shoot me for this, this is a thought experiment)\n\n```js\nfunction handle(res when { status: 200 }) {...} // matched when no \"body\" present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when \"body\" is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when \"body\" is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n```","format":"org.matrix.custom.html","formatted_body":" * <p>i have a crazy idea (please no one shoot me for this, this is a thought experiment)</p>\n<pre><code class=\"language-js\">function handle(res when { status: 200 }) {...} // matched when no &quot;body&quot; present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when &quot;body&quot; is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when &quot;body&quot; is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n</code></pre>\n","m.new_content":{"body":"i have a crazy idea (please no one shoot me for this, this is a thought experiment)\n\n```js\nfunction handle(res when { status: 200 }) {...} // matched when no \"body\" present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when \"body\" is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when \"body\" is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n```","format":"org.matrix.custom.html","formatted_body":"<p>i have a crazy idea (please no one shoot me for this, this is a thought experiment)</p>\n<pre><code class=\"language-js\">function handle(res when { status: 200 }) {...} // matched when no &quot;body&quot; present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when &quot;body&quot; is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when &quot;body&quot; is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n</code></pre>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"i have a crazy idea (please no one shoot me for this, this is a thought experiment)\n\n```js\nfunction handle(res when { status: 200 }) {...} // matched when no \"body\" present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when \"body\" is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when \"body\" is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n```","mimetype":"text/plain"},{"body":"<p>i have a crazy idea (please no one shoot me for this, this is a thought experiment)</p>\n<pre><code class=\"language-js\">function handle(res when { status: 200 }) {...} // matched when no &quot;body&quot; present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when &quot;body&quot; is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when &quot;body&quot; is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n</code></pre>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$NGKz5TzormTacNMyzsg5My2-1w7pwRbECZiBoJN-RkU","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * i have a crazy idea (please no one shoot me for this, this is a thought experiment)\n\n```js\nfunction handle(res when { status: 200 }) {...} // matched when no \"body\" present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when \"body\" is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when \"body\" is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n```","mimetype":"text/plain"},{"body":" * <p>i have a crazy idea (please no one shoot me for this, this is a thought experiment)</p>\n<pre><code class=\"language-js\">function handle(res when { status: 200 }) {...} // matched when no &quot;body&quot; present\n\nfunction handle(res when { status: 200, body: $validBody }) {...} // the match when &quot;body&quot; is present and valid\n\nfunction handle(res when { status: 200, body }) {...} // the match when &quot;body&quot; is present\n\nfunction handle(res when { status: 200 }) {...} // this overwrites the first function\n\nfunction handle(res) { ...} // fall through case\n</code></pre>\n","mimetype":"text/html"}]},"ts":1659004049982,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$Gj9v9wXEBEjumUxNNUB4fM-3aMMB0cjVBlLIDqM1R8A"},
{"content":{"body":"typescript would like to have a word, you just broke overloads :P","msgtype":"m.text","org.matrix.msc1767.text":"typescript would like to have a word, you just broke overloads :P"},"ts":1659004052237,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$V4xg8j6h9L4BO1ad4l0G6uOTRqKrieRFWUob0WQEHgc"},
{"content":{"body":"i already spoke with them a bit about this ;) they don't hate it","msgtype":"m.text","org.matrix.msc1767.text":"i already spoke with them a bit about this ;) they don't hate it"},"ts":1659004067377,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$imaD655b4ViswQFTIN0fbmAA8ahw8vNTN59O9ZvKRYQ"},
{"content":{"body":"yet","msgtype":"m.text","org.matrix.msc1767.text":"yet"},"ts":1659004068907,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$Bm3k89VFmPK7DhpdyM416UOD8EY6_S4AM5dIiYuYIGQ"},
{"content":{"body":"oh, they all have bodies","msgtype":"m.text","org.matrix.msc1767.text":"oh, they all have bodies"},"ts":1659004092169,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$JlQoNshoKfmC4ul8Uwjkp73CTDEPWDQrYzrILqdj_Ak"},
{"content":{"body":"typescript probably doesn't mind so much then","msgtype":"m.text","org.matrix.msc1767.text":"typescript probably doesn't mind so much then"},"ts":1659004102017,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$H6vFs4zDukHFiCazqwPtTKe8gRcCaENZxn45r6UW3Vo"},
{"content":{"body":"but effectively, if you leave out the default case -- the engine would treat values passed to `handle` that don't match, as a call to an undefined function","format":"org.matrix.custom.html","formatted_body":"but effectively, if you leave out the default case -- the engine would treat values passed to <code>handle</code> that don't match, as a call to an undefined function","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"but effectively, if you leave out the default case -- the engine would treat values passed to `handle` that don't match, as a call to an undefined function","mimetype":"text/plain"},{"body":"but effectively, if you leave out the default case -- the engine would treat values passed to <code>handle</code> that don't match, as a call to an undefined function","mimetype":"text/html"}]},"ts":1659004111244,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$_iiJ1dx6Py3bH-2WgGSrS1gTx-F5DGfdUMMgBxQssJA"},
{"content":{"body":"this reminds me of axum in rust","msgtype":"m.text","org.matrix.msc1767.text":"this reminds me of axum in rust"},"ts":1659004116392,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$jmJjd5xZXb8qPV8DBKrgSxS7ShcCt8hxlSTPFNHtJ20"},
{"content":{"body":"with their extractor functions ","msgtype":"m.text","org.matrix.msc1767.text":"with their extractor functions "},"ts":1659004123264,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$nyoGT47j4WqGoJkujk1g5j1UOP25GwvSqG9YSseBQ6Y"},
{"content":{"body":"meaning that you could be restrictive in what kind of shapes can be passed to functions. i think this might be interesting.","msgtype":"m.text","org.matrix.msc1767.text":"meaning that you could be restrictive in what kind of shapes can be passed to functions. i think this might be interesting."},"ts":1659004135320,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$ERs8THdnfgRwxS4jXkFcfM3YVbIbx4hbW2USJqv5cl8"},
{"content":{"body":"what i find additionally interesting is that WASM has roughly settled on a structural typing approach (with some nominal typing). This would give us a way to talk about what structures are permitted, and that would mean that we take a somewhat unified approach across the platform","msgtype":"m.text","org.matrix.msc1767.text":"what i find additionally interesting is that WASM has roughly settled on a structural typing approach (with some nominal typing). This would give us a way to talk about what structures are permitted, and that would mean that we take a somewhat unified approach across the platform"},"ts":1659004180955,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$QUO3XkMQD72wxyhRrlvW5yUYLHlLlCETinWBIGMh6DY"},
{"content":{"body":"that said, its very fuzzy","msgtype":"m.text","org.matrix.msc1767.text":"that said, its very fuzzy"},"ts":1659004187230,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$OsffbNzaoDikaxaajto-bxPySUsBQV49VahxJw2vcKU"},
{"content":{"body":"just, you know, interesting","msgtype":"m.text","org.matrix.msc1767.text":"just, you know, interesting"},"ts":1659004194949,"senderName":"yulia","senderId":"@yulia:mozilla.org","id":"$eosFZQPYyvT_zgTxYQDp_10fRp6P85n0tbvfL7cQjAM"},
{"content":{"body":"its an interesting idea","msgtype":"m.text","org.matrix.msc1767.text":"its an interesting idea"},"ts":1659004201827,"senderName":"michael","senderId":"@m-rutter:matrix.org","id":"$LyP50Fzzgq4IRKUFBGv-kQOWRpLte0IbdxpZqXVLro0"}
]