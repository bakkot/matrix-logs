[
{"content":{"body":"I started to edit spec and found there is something we need to figure out before we continue","msgtype":"m.text"},"ts":1693913957965,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$nbNJslEkdQsPygjT34k021UB7SCs2kIV24a7yxQYUbc"},
{"content":{"body":"the current spec create a new DeclarativeEnvironment for each binding (https://tc39.es/proposal-pattern-matching/#sec-add-match-binding)","msgtype":"m.text"},"ts":1693914006621,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$-7ymo5OkvsVuB2xkeTh9ISKNezC3qhZ9WJGa25fhD34"},
{"content":{"body":"to support `for` head, https://tc39.es/ecma262/#sec-createperiterationenvironment, we need to pre-determinate what binding it contains","format":"org.matrix.custom.html","formatted_body":"to support <code>for</code> head, https://tc39.es/ecma262/#sec-createperiterationenvironment, we need to pre-determinate what binding it contains","msgtype":"m.text"},"ts":1693914079914,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$6yxWICLC_PF-mdKEHL7it1wE3hove-qfpnGCh4ANAj4"},
{"content":{"body":"this brings the question: how is the `let` `const` binding work inside a pattern.","format":"org.matrix.custom.html","formatted_body":"this brings the question: how is the <code>let</code> <code>const</code> binding work inside a pattern.","msgtype":"m.text"},"ts":1693914153805,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$-nUKVnQIhFc9P6K70EQFosur8pQh-1IkaEaWkW2TckM"},
{"content":{"body":"for example, is `[1, let a] or [2, let a]` valid? or is it an early error?","format":"org.matrix.custom.html","formatted_body":"for example, is <code>[1, let a] or [2, let a]</code> valid? or is it an early error?","msgtype":"m.text"},"ts":1693914217502,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$csJ5ELeTHbwTjT5PTDn4DSoRectZXWh-NKnshKOe4T0"},
{"content":{"body":"is every level of MatchPattern creates a DeclarationEnvironment?\n\n```\n{ // level 1 DeclEnv\n    let x,\n    y: [ // level 2 DeclEnv\n        let x, x\n    ]\n} // matches { x: 1, y: [2, 3] } and creates binding of x that is value ...?\n```","format":"org.matrix.custom.html","formatted_body":"<p>is every level of MatchPattern creates a DeclarationEnvironment?</p>\n<pre><code>{ // level 1 DeclEnv\n    let x,\n    y: [ // level 2 DeclEnv\n        let x, x\n    ]\n} // matches { x: 1, y: [2, 3] } and creates binding of x that is value ...?\n</code></pre>\n","msgtype":"m.text"},"ts":1693914543500,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$rEsA0k7R3YUX_9N9hsQR0NZrZpXbWh1ZpDH4H2zIsoU"},
{"content":{"body":"or only the top level MatchPattern creates a DeclarationEnvironment (in this case the previous example gives an early error)?","msgtype":"m.text"},"ts":1693914651644,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$wAS_f38bmv1n7Pd4aNBI-baLHmBdA15WmLDwJ6B5e7Q"},
{"content":{"body":"what's the syntax when it is used in `for...of`?\n\n`for (const x is pattern of expr)`? `for (match pattern of expr)`?","format":"org.matrix.custom.html","formatted_body":"<p>what's the syntax when it is used in <code>for...of</code>?</p>\n<p><code>for (const x is pattern of expr)</code>? <code>for (match pattern of expr)</code>?</p>\n","msgtype":"m.text"},"ts":1693914797404,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$kg4dr9lKWEDxBfl8J1ShDwZIn_6qFxprKGmrb618cMs"},
{"content":{"body":"> <@ljharb:matrix.org> eg, does pascal have the ability to produce bindings in expressions? what else does?\n\nPascal does not, to my knowledge, but there are many languages that support bindings in expressions: C#, F#, LCF, Haskell (LCF derivative), Scheme (LCF derivative), ML (LCF derivative), Python, Clojure, Racket (Scheme derivative), OCaml (ML derivative), Perl, Raku (Perl derivative) PHP, M (aka PowerQuery), and that is not an exhaustive list.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$fu1woDOGkxFGDFIe9uof9M3Z9lzpExcZmLJrgZNK3_I?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>eg, does pascal have the ability to produce bindings in expressions? what else does?</blockquote></mx-reply>Pascal does not, to my knowledge, but there are many languages that support bindings in expressions: C#, F#, LCF, Haskell (LCF derivative), Scheme (LCF derivative), ML (LCF derivative), Python, Clojure, Racket (Scheme derivative), OCaml (ML derivative), Perl, Raku (Perl derivative) PHP, M (aka PowerQuery), and that is not an exhaustive list.","m.relates_to":{"m.in_reply_to":{"event_id":"$fu1woDOGkxFGDFIe9uof9M3Z9lzpExcZmLJrgZNK3_I"}},"msgtype":"m.text"},"ts":1693922467907,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UnTqAKTNYHGBD_XebKiS9mXfOj3AAoMIevEGMliirDQ"},
{"content":{"body":"> <@ljharb:matrix.org> and yes, i do feel that an expression producing a binding would be a wildly surprising, brand new capability in the language, and i can't conceive of what would convince me that that capability is anything short of catastrophic\n\nI have a very difficult time believing that something like this would be catastrophic. ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$YzE7TuDZQRCK7xHlO-9MGtmB9K5d4pN6CbSi_0sslrc?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>and yes, i do feel that an expression producing a binding would be a wildly surprising, brand new capability in the language, and i can&#39;t conceive of what would convince me that that capability is anything short of catastrophic</blockquote></mx-reply>I have a very difficult time believing that something like this would be catastrophic.","m.relates_to":{"m.in_reply_to":{"event_id":"$YzE7TuDZQRCK7xHlO-9MGtmB9K5d4pN6CbSi_0sslrc"}},"msgtype":"m.text"},"ts":1693922519089,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NjO_AApQepzuPYvgQEVdLfXOd2oDc2iB4mhmsCWXRaQ"},
{"content":{"body":"> <@jackworks:matrix.org> for example, is `[1, let a] or [2, let a]` valid? or is it an early error?\n\nIn earlier discussions, a pattern could allow multiple declarations of the same binding, such as in different branches of a disjunction. Variables that are not initialized would remain in TDZ. We did not fully describe what would happen in the case where the same declaration was initialized twice. For `let` we could either error or possibly just reassign. For `const` we would probably error (unless maybe we tried to initialize it to the same value).","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$csJ5ELeTHbwTjT5PTDn4DSoRectZXWh-NKnshKOe4T0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>for example, is <code>[1, let a] or [2, let a]</code> valid? or is it an early error?</blockquote></mx-reply>In earlier discussions, a pattern could allow multiple declarations of the same binding, such as in different branches of a disjunction. Variables that are not initialized would remain in TDZ. We did not fully describe what would happen in the case where the same declaration was initialized twice. For <code>let</code> we could either error or possibly just reassign. For <code>const</code> we would probably error (unless maybe we tried to initialize it to the same value).","m.relates_to":{"m.in_reply_to":{"event_id":"$csJ5ELeTHbwTjT5PTDn4DSoRectZXWh-NKnshKOe4T0"}},"msgtype":"m.text"},"ts":1693922782659,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OrfJfNfXs2nUD_f6rBsxj2L8an0hdoxkeO3JUUGxVhI"},
{"content":{"body":"> <@jackworks:matrix.org> for example, is `[1, let a] or [2, let a]` valid? or is it an early error?\n\nPersonally, I would like this to not be an error for the sake of developer convenience, but could see an argument for it not being so. Simple disjunctions like this could be rewritten to `[1 or 2, let a]`, but more complex disjunctions that don't share much of the same shape couldn't be simplified.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$csJ5ELeTHbwTjT5PTDn4DSoRectZXWh-NKnshKOe4T0?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>for example, is <code>[1, let a] or [2, let a]</code> valid? or is it an early error?</blockquote></mx-reply>Personally, I would like this to not be an error for the sake of developer convenience, but could see an argument for it not being so. Simple disjunctions like this could be rewritten to <code>[1 or 2, let a]</code>, but more complex disjunctions that don't share much of the same shape couldn't be simplified.","m.relates_to":{"m.in_reply_to":{"event_id":"$csJ5ELeTHbwTjT5PTDn4DSoRectZXWh-NKnshKOe4T0"}},"msgtype":"m.text"},"ts":1693922967359,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IB5OCUrCrhYKfZ_rzrKXXRxI4dGdbOnkX8KYwRoMfXc"},
{"content":{"body":"> <@jackworks:matrix.org> is every level of MatchPattern creates a DeclarationEnvironment?\n> \n> ```\n> { // level 1 DeclEnv\n>     let x,\n>     y: [ // level 2 DeclEnv\n>         let x, x\n>     ]\n> } // matches { x: 1, y: [2, 3] } and creates binding of x that is value ...?\n> ```\n\nWhy would you create new declarative environments? My assumption was that you would descend into expressions and patterns to look for `let` and `const` bindings in `BoundNames`, and only need to create a single declarative environment for each `when` clause of `match`, or use the current declarative environment for `is`.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$rEsA0k7R3YUX_9N9hsQR0NZrZpXbWh1ZpDH4H2zIsoU?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br><p>is every level of MatchPattern creates a DeclarationEnvironment?</p>\n<pre><code>{ // level 1 DeclEnv\n    let x,\n    y: [ // level 2 DeclEnv\n        let x, x\n    ]\n} // matches { x: 1, y: [2, 3] } and creates binding of x that is value ...?\n</code></pre>\n</blockquote></mx-reply>Why would you create new declarative environments? My assumption was that you would descend into expressions and patterns to look for <code>let</code> and <code>const</code> bindings in <code>BoundNames</code>, and only need to create a single declarative environment for each <code>when</code> clause of <code>match</code>, or use the current declarative environment for <code>is</code>.","m.relates_to":{"m.in_reply_to":{"event_id":"$rEsA0k7R3YUX_9N9hsQR0NZrZpXbWh1ZpDH4H2zIsoU"}},"msgtype":"m.text"},"ts":1693923166864,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-jQruB6_XUabEBW2eAHd645fSj3qxO2YeuHKcMlOpAQ"},
{"content":{"body":"> <@rbuckton:matrix.org> I have a very difficult time believing that something like this would be catastrophic. \n\nwe can certainly see what the committee thinks, but i’m surprised that you have such different expectations tbh","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD%3Amatrix.org/%24NjO_AApQepzuPYvgQEVdLfXOd2oDc2iB4mhmsCWXRaQ\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>I have a very difficult time believing that something like this would be catastrophic.</blockquote></mx-reply>we can certainly see what the committee thinks, but i’m surprised that you have such different expectations tbh","m.relates_to":{"m.in_reply_to":{"event_id":"$NjO_AApQepzuPYvgQEVdLfXOd2oDc2iB4mhmsCWXRaQ"}},"msgtype":"m.text"},"ts":1693926087941,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$ZcOsEy-btFlt7kO5xoSs8YtYANzbVWk7Id7PCRR-WIo"},
{"content":{"body":"> <@rbuckton:matrix.org> Why would you create new declarative environments? My assumption was that you would descend into expressions and patterns to look for `let` and `const` bindings in `BoundNames`, and only need to create a single declarative environment for each `when` clause of `match`, or use the current declarative environment for `is`.\n\nwe need to decide if `is` can leak variable bindings. it will be a breaking change adding it in the future ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$-jQruB6_XUabEBW2eAHd645fSj3qxO2YeuHKcMlOpAQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br />Why would you create new declarative environments? My assumption was that you would descend into expressions and patterns to look for <code>let</code> and <code>const</code> bindings in <code>BoundNames</code>, and only need to create a single declarative environment for each <code>when</code> clause of <code>match</code>, or use the current declarative environment for <code>is</code>.</blockquote></mx-reply>we need to decide if <code>is</code> can leak variable bindings. it will be a breaking change adding it in the future","m.relates_to":{"m.in_reply_to":{"event_id":"$-jQruB6_XUabEBW2eAHd645fSj3qxO2YeuHKcMlOpAQ"}},"msgtype":"m.text"},"ts":1693926282951,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$cSRwTMlhHkL34qYNyKub5_-6YbZ8LKdpmCua9rxwXSQ"},
{"content":{"body":"> <@jackworks:matrix.org> we need to decide if `is` can leak variable bindings. it will be a breaking change adding it in the future\n\nMy intent with `is` is that the bindings are declared in the nearest block scope, otherwise we would not be able to emulate `if let`/`while let` with `is`, which is one of the key capabilities:\n\n```\nif (x is Option.Some(let value)) {\n  value;\n}\n\nconst y = x is Option.Some(let value) ? value + 1 : 0;\n```\nIf the `let` is only visible within the pattern itself, it makes it useless as a destructuring mechanism.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$cSRwTMlhHkL34qYNyKub5_-6YbZ8LKdpmCua9rxwXSQ?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>we need to decide if <code>is</code> can leak variable bindings. it will be a breaking change adding it in the future</blockquote></mx-reply><p>My intent with <code>is</code> is that the bindings are declared in the nearest block scope, otherwise we would not be able to emulate <code>if let</code>/<code>while let</code> with <code>is</code>, which is one of the key capabilities:</p>\n<pre><code>if (x is Option.Some(let value)) {\n  value;\n}\n\nconst y = x is Option.Some(let value) ? value + 1 : 0;\n</code></pre>\n<p>If the <code>let</code> is only visible within the pattern itself, it makes it useless as a destructuring mechanism.</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$cSRwTMlhHkL34qYNyKub5_-6YbZ8LKdpmCua9rxwXSQ"}},"msgtype":"m.text"},"ts":1693928516115,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3J_AhzD4HFgkWmU2-omFMKQOXuKtvAKDMK2n1umS_ZQ"},
{"content":{"body":"i think there's specific places it makes sense. an if conditional making bindings available in the block is good. a ternary conditional making bindings available in the positive branch is good too","msgtype":"m.text"},"ts":1693932033205,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$QBat0UJ9ZTvbbBUlSaSiRRkCar2nvDDCpMJHrAbQrcs"},
{"content":{"body":"but `;x is Option.some(let value);` making bindings available outside the pattern seems very very bad to me.","format":"org.matrix.custom.html","formatted_body":"but <code>;x is Option.some(let value);</code> making bindings available outside the pattern seems very very bad to me.","msgtype":"m.text"},"ts":1693932058143,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$xMliTViMUkG6RxH7gg5NWZIECDJipgm6VxPukwEzL0E"},
{"content":{"body":"You can't have one without the other without introducing some new even more complex binding mechanism.","msgtype":"m.text"},"ts":1693932066593,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$btF_X6w9XKjMplnEkdvLTnIhXhRVdvQgrsnNeILDNvk"},
{"content":{"body":"i don't think that's true","msgtype":"m.text"},"ts":1693932074208,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$yeQkx4IA3Vg9E9FknQ5nK4q0XBtdT83nSWTaZgwtmQ4"},
{"content":{"body":"certainly it will make the spec trickier to write, but that's not important","msgtype":"m.text"},"ts":1693932091362,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Cve3ajqyJ7EDwJae0FtYR8Uxwyv-zX_bX73wZkP382g"},
{"content":{"body":"Bad maybe, but it will rarely be used in that way as its not the most convenient mechanism.","msgtype":"m.text"},"ts":1693932119714,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$DXDcrUI2iBr5sZKmM-VM4piTGi-PdzKyRXVxWkUJDkM"},
{"content":{"body":" * certainly it will make the spec trickier to write, but that's not important (in terms of priority of constituencies)","m.new_content":{"body":"certainly it will make the spec trickier to write, but that's not important (in terms of priority of constituencies)","msgtype":"m.text"},"m.relates_to":{"event_id":"$Cve3ajqyJ7EDwJae0FtYR8Uxwyv-zX_bX73wZkP382g","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693932123341,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$6mbgDjxrW9SIcdBX5CuuWM2uWBqTnsxgJdP0Tuy8ZQg"},
{"content":{"body":"i think it would also be bad if the ternary made the bindings available in the negative branch, to be clear","msgtype":"m.text"},"ts":1693932148854,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$50Xa4ZTRcgM7JL756XQ6Asf-CQl-rN-jNxFgIxLAvaA"},
{"content":{"body":"I'd very much like to be able to have this capability.","msgtype":"m.text"},"ts":1693932157592,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$UJvc3BmT-GuhFf5djKvDyiEOxjQS320eiKmr3MGe9-U"},
{"content":{"body":"i'd prefer bindings never be visible outside the pattern, over leaking bindings willy nilly","msgtype":"m.text"},"ts":1693932164548,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$J3X1MvMyqkL-ILOoHmiTdfJQIG7yA2kQsdhUsz16sSI"},
{"content":{"body":"The bindings in the negative branch would be uninitialized and thus in TDZ","msgtype":"m.text"},"ts":1693932176925,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Qiaura6z0TBoZVq1kYslhXcQFkX69TUy3ICK-sBs6HU"},
{"content":{"body":"not if they use `var`","format":"org.matrix.custom.html","formatted_body":"not if they use <code>var</code>","msgtype":"m.text"},"ts":1693932192899,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$wKeoXh6CA5YIO8ROeEAp2c7N6JI_W7x2BtCQ5wyu4Sc"},
{"content":{"body":"Then don't support `var` for this feature. I think that's far more reasonable.","format":"org.matrix.custom.html","formatted_body":"Then don't support <code>var</code> for this feature. I think that's far more reasonable.","msgtype":"m.text"},"ts":1693932222892,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$NBoTS0Px5eshrytG52g2cjT4wgJKYrgNGszhtSJULJg"},
{"content":{"body":"And restricting this to only the true branch would break negation for cases like early exit:\n\n```\nif (!(x is Option.some(let value)) {\n  return; // nothing to do, exit early\n}\nvalue; // use 'value'\n```","format":"org.matrix.custom.html","formatted_body":"<p>And restricting this to only the true branch would break negation for cases like early exit:</p>\n<pre><code>if (!(x is Option.some(let value)) {\n  return; // nothing to do, exit early\n}\nvalue; // use 'value'\n</code></pre>\n","msgtype":"m.text"},"ts":1693932475337,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$n1QeyfGIWVkuWQQMANjDh9-rkG0MxGTdIYLayy--E6k"},
{"content":{"body":"(or possibly even `if (x is not Option.some(let value)) { ... }` should we decide to make that work as well.","format":"org.matrix.custom.html","formatted_body":"(or possibly even <code>if (x is not Option.some(let value)) { ... }</code> should we decide to make that work as well.","msgtype":"m.text"},"ts":1693932514882,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ucrsv-P8dqXZpMKjvm3GugI381h9V0Tku3e6uqmX41M"},
{"content":{"body":" * (or possibly even `if (x is not Option.some(let value)) { ... }` should we decide to make that work as well)","format":"org.matrix.custom.html","formatted_body":" * (or possibly even <code>if (x is not Option.some(let value)) { ... }</code> should we decide to make that work as well)","m.new_content":{"body":"(or possibly even `if (x is not Option.some(let value)) { ... }` should we decide to make that work as well)","format":"org.matrix.custom.html","formatted_body":"(or possibly even <code>if (x is not Option.some(let value)) { ... }</code> should we decide to make that work as well)","msgtype":"m.text"},"m.relates_to":{"event_id":"$ucrsv-P8dqXZpMKjvm3GugI381h9V0Tku3e6uqmX41M","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693932519723,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$RVg7lUOavlDX4oT7y77mcUn_W38bsCRxFuV5bMMgm5A"},
{"content":{"body":"that only affects ternaries, not if's","msgtype":"m.text"},"ts":1693932933436,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$8eXi29PdIC7BvoHEYbN_PGf-2mQ69ltGSBYcsD0ogq8"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1693932938761,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$st1HKMnFnsy8OxBuo69OpLaRNt-c-cFVdKmxOXgbSPI"},
{"content":{"body":"well yeah, don't do that","msgtype":"m.text"},"ts":1693932942727,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$fj11spWquCS5zX7TGGuKmUl8QP7DR6U1LkCfLz9gJvA"},
{"content":{"body":"you'd do `if (x not is Option.Some(let value)) { }`","format":"org.matrix.custom.html","formatted_body":"you'd do <code>if (x not is Option.Some(let value)) { }</code>","msgtype":"m.text"},"ts":1693932960491,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$looPQp4XF6ElGdjRSbTeyLLtFUOVYDUnj4b_NFnqJ2c"},
{"content":{"body":"What is `not is`? That's not proposed and doesn't read well, IMO.","format":"org.matrix.custom.html","formatted_body":"What is <code>not is</code>? That's not proposed and doesn't read well, IMO.","msgtype":"m.text"},"ts":1693932991046,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1tmBsivoZwbyha8UASoQlEwaek4aOAQcZliIUyYlZSM"},
{"content":{"body":"it's definitely supposed to be in the PR","msgtype":"m.text"},"ts":1693933007975,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$7kGTNv84QmRdEigxcsSx5eXd1jS1R4cEEAvwCSBrptE"},
{"content":{"body":"Ternary and `if` shouldn't be treated differently.","format":"org.matrix.custom.html","formatted_body":"Ternary and <code>if</code> shouldn't be treated differently.","msgtype":"m.text"},"ts":1693933013467,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3u2ZEwjP5YvjxB2gYxwmy3Sst15C0Y4kil4QmxVqfYw"},
{"content":{"body":"in this case they're the same.","msgtype":"m.text"},"ts":1693933023280,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$9yxDtbsuVSkUGLRQ3R28O9Lb74zSWqjoelQGjyKTKVI"},
{"content":{"body":"`is not` I would expect, since `not` is part of the pattern grammar. `not is` is not a part of the proposal, IIRC.","format":"org.matrix.custom.html","formatted_body":"<code>is not</code> I would expect, since <code>not</code> is part of the pattern grammar. <code>not is</code> is not a part of the proposal, IIRC.","msgtype":"m.text"},"ts":1693933034471,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$-gyZ44DqKPZzAbql_0eOP571VWzrKBNATLey7kTd95Y"},
{"content":{"body":"oh ok, fair","msgtype":"m.text"},"ts":1693933040992,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$W2tI3TUwssWO0EbgHqmoJAVCiZjA0gAyja_8GR-J_oA"},
{"content":{"body":"`is not`, sure","format":"org.matrix.custom.html","formatted_body":"<code>is not</code>, sure","msgtype":"m.text"},"ts":1693933043399,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$PzkRwlxLq-vG2vISuwJLSMh0WCzeuO4O_hsWlBCC0V8"},
{"content":{"body":"either way you'd still only get the bindings in the positive branch","msgtype":"m.text"},"ts":1693933052117,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$QRqOU3cHtlE_IG7bZFmFoldUDJAX1ik7MQzbsc14V_Y"},
{"content":{"body":"I think that's far too confusing.","msgtype":"m.text"},"ts":1693933070603,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QIyqIEnJ_GxxMxWPEI_PNtECIhsxK7Ab363P7cdisKw"},
{"content":{"body":"i think anything else would be confusing.","msgtype":"m.text"},"ts":1693933090223,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$FOz7bLsHU0WawTykedMHcCPAyct1Wxl9bgaxmbXfH4M"},
{"content":{"body":"fwiw the committee already discussed this with https://github.com/tc39/proposal-Declarations-in-Conditionals and i recall the majority thinking that it should only be visible in the `if`, but i might be remembering wrong","format":"org.matrix.custom.html","formatted_body":"fwiw the committee already discussed this with https://github.com/tc39/proposal-Declarations-in-Conditionals and i recall the majority thinking that it should only be visible in the <code>if</code>, but i might be remembering wrong","msgtype":"m.text"},"ts":1693933142512,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$hyCd_sb2IRpQT6lf4ECWjYirvIKw3lT3FrOBv54pYrU"},
{"content":{"body":"Short-circuiting to avoid complex middle branches is a common practice, and you're proposing a mechanism that would force a specific style of coding. I'd like to be able to do this:\n\n```\nreturn x is not Option.Some(let value) ? \"no-value\" :\n  value === 1 ? \"single-value\" :\n  \"multiple-values\";\n```\n\nvs this:\n\n```\nreturn x is Option.Some(let value) ? \n    value === 1 ? \"single-value\" :\n    \"multiple-values\" :\n  \"no-value\";\n```\n\nAs the latter requires additional nesting that hampers readability, especially in more complex cases than is shown. Yes, `match` is an option, but this could be existing code that you're refactoring to use patterns.","format":"org.matrix.custom.html","formatted_body":"<p>Short-circuiting to avoid complex middle branches is a common practice, and you're proposing a mechanism that would force a specific style of coding. I'd like to be able to do this:</p>\n<pre><code>return x is not Option.Some(let value) ? \"no-value\" :\n  value === 1 ? \"single-value\" :\n  \"multiple-values\";\n</code></pre>\n<p>vs this:</p>\n<pre><code>return x is Option.Some(let value) ? \n    value === 1 ? \"single-value\" :\n    \"multiple-values\" :\n  \"no-value\";\n</code></pre>\n<p>As the latter requires additional nesting that hampers readability, especially in more complex cases than is shown. Yes, <code>match</code> is an option, but this could be existing code that you're refactoring to use patterns.</p>\n","msgtype":"m.text"},"ts":1693933280418,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$6UB1DMsC0BhvmTDc_F-0YRvmxlgPStLxqkrPHvKAZYs"},
{"content":{"body":"we often have mechanisms that somewhat force specific styles of coding.","msgtype":"m.text"},"ts":1693933315497,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$CSjjg_pFKsOcTitqdyxIU5qVmh03F86Bf2MTEN7YPeI"},
{"content":{"body":"and nested ternaries are pretty widely considered horrifically unreadable.","msgtype":"m.text"},"ts":1693933329161,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$hnO96wQrPOIlt4H9zSPouPnW7tftuEAwEm_s52WU_Ig"},
{"content":{"body":"I would very much like for this not to be one of them.","msgtype":"m.text"},"ts":1693933332982,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$akJvUdojLkVlMsqRaPjJO7VGBnsUCSa_Ok9lkoNmoKc"},
{"content":{"body":"do you have any compelling examples that don't use the comma operator or nested ternaries?","msgtype":"m.text"},"ts":1693933350084,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$BXIf0St093_tp2PpqTtjuj0Z_nyO8JPVAb2tcNKHJjw"},
{"content":{"body":"Ternaries nested in the second example, yes. ternaries in the first example are far more readable.","msgtype":"m.text"},"ts":1693933354275,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wuV6qcG9TYn5PE5SVOK0TebTMg4bEozkyKOA2S3t5CA"},
{"content":{"body":"that's subjective, i don't find either of those readable.","msgtype":"m.text"},"ts":1693933365849,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$E9vNhbM_dtcOAT9zbzZ8spZnwsMgcNXDOGZ_nIVRY6w"},
{"content":{"body":"not everything needs to be, or should be, a single expression","msgtype":"m.text"},"ts":1693933373922,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$eSqHFo46Ppk7eael-TCxPvkbi2lyJvYaCCTHx8Z8yvk"},
{"content":{"body":" * not everything needs to be, or should be, a single expression/line","m.new_content":{"body":"not everything needs to be, or should be, a single expression/line","msgtype":"m.text"},"m.relates_to":{"event_id":"$eSqHFo46Ppk7eael-TCxPvkbi2lyJvYaCCTHx8Z8yvk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693933377280,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Cu_iWE6Z1nIfFmv364hYKBKo1_nZxeixspxumk5lid4"},
{"content":{"body":"Given that it is subjective, mandating a coding style that fits your perspective essentially invalidates everyone else's style. That's what linters are for.","msgtype":"m.text"},"ts":1693933429316,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bTrAmKl3KVozJPm8hhn9QmAhOv5ZcB6M4D_JAQhA3j0"},
{"content":{"body":" * Given that it is subjective, mandating a coding style that fits a single perspective essentially invalidates everyone else's style. That's what linters are for.","m.new_content":{"body":"Given that it is subjective, mandating a coding style that fits a single perspective essentially invalidates everyone else's style. That's what linters are for.","msgtype":"m.text"},"m.relates_to":{"event_id":"$bTrAmKl3KVozJPm8hhn9QmAhOv5ZcB6M4D_JAQhA3j0","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693933448789,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Aqo30xziPEc8SKqFnEfmokOI8leFFm3u2LZCbYz4uQw"},
{"content":{"body":"it's not to mandate a coding style","msgtype":"m.text"},"ts":1693933520179,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$yUS6d0KtACkgSliOBaRy8UvzME--sKOvijH0LFyQr80"},
{"content":{"body":"it's to ensure explicit and clear variable scopes","msgtype":"m.text"},"ts":1693933527876,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$nvdiFLVg5kUEipJ84EWXuM0RIX3nBaq2Y1OOQFqOgyw"},
{"content":{"body":"if some coding styles don't work with that, that's fine, they just don't work with that","msgtype":"m.text"},"ts":1693933540093,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$wy6bQPNzGrt717UXF-L59NZbI4rkbKH6N8s3I8OgnKQ"},
{"content":{"body":"There are plenty of examples that wouldn't use ternaries. I showed one earlier:\n\n```\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```\n\n\n","format":"org.matrix.custom.html","formatted_body":"<p>There are plenty of examples that wouldn't use ternaries. I showed one earlier:</p>\n<pre><code>function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    return getTypeOfPropertyOfType(type, name) ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1693933547335,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$WjIXE-mmvwxoPy9YHfbfn_d5_yzSjZDCl9IoiZdZKPw"},
{"content":{"body":"and personally i find that very unreadable and would not try to do that in a single return statement","msgtype":"m.text"},"ts":1693933566632,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Stkdz1AuDnD4f8xXPSGEBsE427KAU7zezeRShYaHdXQ"},
{"content":{"body":"This proposal still maintains explicit variable scopes, and it is the same scoping mechanism we already have: block scoping. Introducing a _new_ scoping mechanism would be confusing.","format":"org.matrix.custom.html","formatted_body":"This proposal still maintains explicit variable scopes, and it is the same scoping mechanism we already have: block scoping. Introducing a <em>new</em> scoping mechanism would be confusing.","msgtype":"m.text"},"ts":1693933593165,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$uePoR_oTVg7EZmhOjYhf2tjZIQWJxv6ftrJoRi3GDbY"},
{"content":{"body":"but please remember that both the vscode and typescript codebases are not in any way common or idiomatic for the JS ecosystem, so style arguments coming from them aren't very compelling to me.","msgtype":"m.text"},"ts":1693933596977,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$ZcukSZdFND5OO_sclNpCFdFSj9pl4usL_2ZzsSKFufo"},
{"content":{"body":"This is a style preference that many projects have made, especially FP-style projects.","msgtype":"m.text"},"ts":1693933633621,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$9R4gVfKcida56fZYjg2FG4HJ2SbF6rveUSu3Dct9RoI"},
{"content":{"body":"an expression can't produce bindings, and adding that capability is something that would need to be its own proposal. trying to do that here would tank both efforts.","msgtype":"m.text"},"ts":1693933639087,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$SLf_wnrJA16YslyVV0jJuLV-T8dKCI04_g8mpeF_Q4E"},
{"content":{"body":"i realize that we wouldn't necessarily be able to add it later to `is`, which makes it tricky, but that doesn't mean we can add it now either","format":"org.matrix.custom.html","formatted_body":"i realize that we wouldn't necessarily be able to add it later to <code>is</code>, which makes it tricky, but that doesn't mean we can add it now either","msgtype":"m.text"},"ts":1693933672615,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$RuOB8tqTKbhqs4NCM95QRAlSxpQ0_5nVD3KlcoLWVSs"},
{"content":{"body":"I don't believe that it would, and I think this is the correct proposal to discuss this.","msgtype":"m.text"},"ts":1693933711430,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$L3eTOb9T61GemKBKrOkZlpB2-8AWLJ-W24ghP3i_Tsk"},
{"content":{"body":"i think you are severely underestimating the reaction to this aspect of the proposal.","msgtype":"m.text"},"ts":1693933763158,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$d4xJxzQC9xIllTJFP5zcQdZioTotPDlNyj9ugJ891ZE"},
{"content":{"body":"I'd be happier if we _also_ had a specific expression form similar to `let..in`, which is more explicitly tailored to that case, but that wouldn't mean that `let` patterns in `is` aren't valid.","format":"org.matrix.custom.html","formatted_body":"I'd be happier if we <em>also</em> had a specific expression form similar to <code>let..in</code>, which is more explicitly tailored to that case, but that wouldn't mean that <code>let</code> patterns in <code>is</code> aren't valid.","msgtype":"m.text"},"ts":1693933784181,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$HhWf41eKdvKXSKeV1D-aWkgtokKZIO2CoxyU8y47eZw"},
{"content":{"body":"i can tell you if i weren't a champion of pattern matching i'd die on the hill of not allowing it. as it is, i won't block on that but i would bet money others will.","msgtype":"m.text"},"ts":1693933789189,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$m3T2RBDusEEPnDRgFUm4WvF2AC_FKdMQFfNEqhZK8vo"},
{"content":{"body":"it's fine for declaration patterns to work in `is`, so they can be used later in the pattern. the question here is how much *beyond* the pattern should they be usable","format":"org.matrix.custom.html","formatted_body":"it's fine for declaration patterns to work in <code>is</code>, so they can be used later in the pattern. the question here is how much <em>beyond</em> the pattern should they be usable","msgtype":"m.text"},"ts":1693933820304,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$UMUiQYX068Cru08xj3Slz7KvVHQ4p7ypZu_U_5Dw410"},
{"content":{"body":"Having been down the road of \"what other statements could be made into expressions\" discussion back when I first proposed `throw` expressions, I'm not sure the sentiment is that much against it.","format":"org.matrix.custom.html","formatted_body":"Having been down the road of \"what other statements could be made into expressions\" discussion back when I first proposed <code>throw</code> expressions, I'm not sure the sentiment is that much against it.","msgtype":"m.text"},"ts":1693933847224,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$v7VmB7bb9coq0esOr4raeZor816gh_XYZ_gQAfQ86rY"},
{"content":{"body":" * it's fine for declaration patterns to work in `is`, so they can be used later in the pattern. the question here is how much _beyond_ the pattern should they be usable (for when clauses, it's available in the RHS)","format":"org.matrix.custom.html","formatted_body":" * it's fine for declaration patterns to work in <code>is</code>, so they can be used later in the pattern. the question here is how much <em>beyond</em> the pattern should they be usable (for when clauses, it's available in the RHS)","m.new_content":{"body":"it's fine for declaration patterns to work in `is`, so they can be used later in the pattern. the question here is how much _beyond_ the pattern should they be usable (for when clauses, it's available in the RHS)","format":"org.matrix.custom.html","formatted_body":"it's fine for declaration patterns to work in <code>is</code>, so they can be used later in the pattern. the question here is how much <em>beyond</em> the pattern should they be usable (for when clauses, it's available in the RHS)","msgtype":"m.text"},"m.relates_to":{"event_id":"$UMUiQYX068Cru08xj3Slz7KvVHQ4p7ypZu_U_5Dw410","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693933859930,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$f2dgYaKiIMWQ5SW5KpUvDnYpCjqfdp7eoUKy_9GmYeI"},
{"content":{"body":"you have a very different takeaway than i do from that discussion","msgtype":"m.text"},"ts":1693933872333,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$xFKbL6C04Lc3es_k9w5HC1A5I0Ja0mb4qbSnTByjI2Q"},
{"content":{"body":" * Having been down the road of the \"what other statements could be made into expressions\" discussion back when I first proposed `throw` expressions, I'm not sure the sentiment is that much against it.","format":"org.matrix.custom.html","formatted_body":" * Having been down the road of the \"what other statements could be made into expressions\" discussion back when I first proposed <code>throw</code> expressions, I'm not sure the sentiment is that much against it.","m.new_content":{"body":"Having been down the road of the \"what other statements could be made into expressions\" discussion back when I first proposed `throw` expressions, I'm not sure the sentiment is that much against it.","format":"org.matrix.custom.html","formatted_body":"Having been down the road of the \"what other statements could be made into expressions\" discussion back when I first proposed <code>throw</code> expressions, I'm not sure the sentiment is that much against it.","msgtype":"m.text"},"m.relates_to":{"event_id":"$v7VmB7bb9coq0esOr4raeZor816gh_XYZ_gQAfQ86rY","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693933872686,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ONJGCyXouas9KSF8pdZK-PcEMJaqPDuLk6UocUu8zuo"},
{"content":{"body":"my takeaway was that throw expressions were basically the only thing consensus would even come close to tolerating","msgtype":"m.text"},"ts":1693933888229,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$LJxBSxcakWtqnyCGANAx7HYCbB6dFmfetQgbgh7zU10"},
{"content":{"body":" * my takeaway was that throw expressions were basically the only statement-as-expression that consensus would even come close to tolerating","m.new_content":{"body":"my takeaway was that throw expressions were basically the only statement-as-expression that consensus would even come close to tolerating","msgtype":"m.text"},"m.relates_to":{"event_id":"$LJxBSxcakWtqnyCGANAx7HYCbB6dFmfetQgbgh7zU10","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693933896593,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$fZnXpbgwej2Baqqvvov-oj0K2rYP4X4uSa6iMdU4NaE"},
{"content":{"body":"I pushed back against most statements-as-expressions at the time. The only ones I thought that were possibly worth pursuing aside from `throw` were `debugger` and `let`/`const`.","format":"org.matrix.custom.html","formatted_body":"I pushed back against most statements-as-expressions at the time. The only ones I thought that were possibly worth pursuing aside from <code>throw</code> were <code>debugger</code> and <code>let</code>/<code>const</code>.","msgtype":"m.text"},"ts":1693933945650,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$OYaJ61hbU2kHQEZnuBLF6dPoah1ve-g-HYgjyo8R5YI"},
{"content":{"body":"debugger seems doable, but i'm convinced let/const isn't for the same reasons as here","msgtype":"m.text"},"ts":1693934131170,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$AYfhIRdTlidUwRaQfupLmqSEKnRHu4mqP2kiXzmehQA"},
{"content":{"body":"I'm not necessarily opposed to restricting the scope of `let` patterns, I just fine that there are too many basic cases that will not work or be confusing if we enforce a specific scope. Negation/short-circuiting/early return are the most obvious examples. Introducing a `let` whose scope isn't block-scoped is another. However, I find `let` patterns to be the _best_ way out of the \"what is a reference vs. what is a binding\" problem from the original proposal, and that Rust also has.","format":"org.matrix.custom.html","formatted_body":"I'm not necessarily opposed to restricting the scope of <code>let</code> patterns, I just fine that there are too many basic cases that will not work or be confusing if we enforce a specific scope. Negation/short-circuiting/early return are the most obvious examples. Introducing a <code>let</code> whose scope isn't block-scoped is another. However, I find <code>let</code> patterns to be the <em>best</em> way out of the \"what is a reference vs. what is a binding\" problem from the original proposal, and that Rust also has.","msgtype":"m.text"},"ts":1693934425419,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PIPGJqfVgWaSUc0T-s494aLWtXhtbM_gC83NZFrBGIg"},
{"content":{"body":" * I'm not necessarily opposed to restricting the scope of `let` patterns, I just find that there are too many basic cases that will not work or be confusing if we enforce a specific scope. Negation/short-circuiting/early return are the most obvious examples. Introducing a `let` whose scope isn't block-scoped is another. However, I find `let` patterns to be the _best_ way out of the \"what is a reference vs. what is a binding\" problem from the original proposal, and that Rust also has.","format":"org.matrix.custom.html","formatted_body":" * I'm not necessarily opposed to restricting the scope of <code>let</code> patterns, I just find that there are too many basic cases that will not work or be confusing if we enforce a specific scope. Negation/short-circuiting/early return are the most obvious examples. Introducing a <code>let</code> whose scope isn't block-scoped is another. However, I find <code>let</code> patterns to be the <em>best</em> way out of the \"what is a reference vs. what is a binding\" problem from the original proposal, and that Rust also has.","m.new_content":{"body":"I'm not necessarily opposed to restricting the scope of `let` patterns, I just find that there are too many basic cases that will not work or be confusing if we enforce a specific scope. Negation/short-circuiting/early return are the most obvious examples. Introducing a `let` whose scope isn't block-scoped is another. However, I find `let` patterns to be the _best_ way out of the \"what is a reference vs. what is a binding\" problem from the original proposal, and that Rust also has.","format":"org.matrix.custom.html","formatted_body":"I'm not necessarily opposed to restricting the scope of <code>let</code> patterns, I just find that there are too many basic cases that will not work or be confusing if we enforce a specific scope. Negation/short-circuiting/early return are the most obvious examples. Introducing a <code>let</code> whose scope isn't block-scoped is another. However, I find <code>let</code> patterns to be the <em>best</em> way out of the \"what is a reference vs. what is a binding\" problem from the original proposal, and that Rust also has.","msgtype":"m.text"},"m.relates_to":{"event_id":"$PIPGJqfVgWaSUc0T-s494aLWtXhtbM_gC83NZFrBGIg","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693934433378,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$YD1E8ikar2izO2wGxoBZ56eg13I0HlGUzROe45Utb-A"},
{"content":{"body":"i agree with that part","msgtype":"m.text"},"ts":1693935340247,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$OJ3tdPcKfHzsZUGHt4AByoZXH8Kzit8ttA8Ck3ZtSYQ"},
{"content":{"body":"but we can satisfy that by just always restricting bindings to the pattern, or to the RHS of the containing when clause.\n\nbut, i think we can do better than that - as long as we don't open the floodgates by just naively expanding it to the containing block","msgtype":"m.text"},"ts":1693935372375,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$cMA6Ypmtu2447zP5SFmQ3eMBscUkZea-5FTzusz9x4w"},
{"content":{"body":"> <@rbuckton:matrix.org> And restricting this to only the true branch would break negation for cases like early exit:\n> \n> ```\n> if (!(x is Option.some(let value)) {\n>   return; // nothing to do, exit early\n> }\n> value; // use 'value'\n> ```\n\nlooks like we have very different mental morals on this. I won't expect any binding created in the if header is available outside of the if statement ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$n1QeyfGIWVkuWQQMANjDh9-rkG0MxGTdIYLayy--E6k?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br /><p>And restricting this to only the true branch would break negation for cases like early exit:</p>\n<pre><code>if (!(x is Option.some(let value)) {\n  return; // nothing to do, exit early\n}\nvalue; // use 'value'\n</code></pre>\n</blockquote></mx-reply>looks like we have very different mental morals on this. I won't expect any binding created in the if header is available outside of the if statement","m.relates_to":{"m.in_reply_to":{"event_id":"$n1QeyfGIWVkuWQQMANjDh9-rkG0MxGTdIYLayy--E6k"}},"msgtype":"m.text"},"ts":1693935475486,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$hGcby3t8UaIW3GGhOFnKwVyDQBVc1HB61GiaIB7miIc"},
{"content":{"body":"* In reply to @rbuckton:matrix.org\nAnd restricting this to only the true branch would break negation for cases like early exit:\n\nif (!(x is Option.some(let value)) {\n  return; // nothing to do, exit early\n}\nvalue; // use 'value'\n\n\nlooks like we have very different mental modal on this. I won't expect any binding created in the if header is available outside of the if statement","m.new_content":{"body":"> <@rbuckton:matrix.org> And restricting this to only the true branch would break negation for cases like early exit:\n> \n> ```\n> if (!(x is Option.some(let value)) {\n>   return; // nothing to do, exit early\n> }\n> value; // use 'value'\n> ```\n\nIn reply to @rbuckton:matrix.org\nAnd restricting this to only the true branch would break negation for cases like early exit:\n\nif (!(x is Option.some(let value)) {\n  return; // nothing to do, exit early\n}\nvalue; // use 'value'\n\n\nlooks like we have very different mental modal on this. I won't expect any binding created in the if header is available outside of the if statement","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$n1QeyfGIWVkuWQQMANjDh9-rkG0MxGTdIYLayy--E6k?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a><br /><p>And restricting this to only the true branch would break negation for cases like early exit:</p>\n<pre><code>if (!(x is Option.some(let value)) {\n  return; // nothing to do, exit early\n}\nvalue; // use 'value'\n</code></pre>\n</blockquote></mx-reply><p>In reply to @rbuckton:matrix.org<br />And restricting this to only the true branch would break negation for cases like early exit:</p>\n<p>if (!(x is Option.some(let value)) {<br />return; // nothing to do, exit early<br />}<br />value; // use 'value'</p>\n<p>looks like we have very different mental modal on this. I won't expect any binding created in the if header is available outside of the if statement</p>","msgtype":"m.text"},"m.relates_to":{"event_id":"$hGcby3t8UaIW3GGhOFnKwVyDQBVc1HB61GiaIB7miIc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693935488075,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$_KmAOXVmp3FpCkwJkNvMnXEA_pmIq-QzKSB_rs2upIg"},
{"content":{"body":"* looks like we have very different mental modal on this. I won't expect any binding created in the if header is available outside of the if statement\n","m.new_content":{"body":"> <@rbuckton:matrix.org> And restricting this to only the true branch would break negation for cases like early exit:\n> \n> ```\n> if (!(x is Option.some(let value)) {\n>   return; // nothing to do, exit early\n> }\n> value; // use 'value'\n> ```\n\nlooks like we have very different mental modal on this. I won't expect any binding created in the if header is available outside of the if statement\n","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$n1QeyfGIWVkuWQQMANjDh9-rkG0MxGTdIYLayy--E6k?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">rbuckton</a><br /><p>And restricting this to only the true branch would break negation for cases like early exit:</p>\n<pre><code>if (!(x is Option.some(let value)) {\n  return; // nothing to do, exit early\n}\nvalue; // use 'value'\n</code></pre>\n</blockquote></mx-reply>looks like we have very different mental modal on this. I won't expect any binding created in the if header is available outside of the if statement","msgtype":"m.text"},"m.relates_to":{"event_id":"$hGcby3t8UaIW3GGhOFnKwVyDQBVc1HB61GiaIB7miIc","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693935505526,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$dFbXBg1Q-imJdSZv5c5cRu4qWK4ueo7-Gx4gUiNKst0"},
{"content":{"body":"How would you propose such code be written then?","msgtype":"m.text"},"ts":1693935756753,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Mc96uCVABsfnLo9PbXeAgmy8KgodP78fwNFnZB1awJ8"},
{"content":{"body":"If anything, that convinces me that we *shouldn't* introduce a new block scope in an `if` head.","format":"org.matrix.custom.html","formatted_body":"If anything, that convinces me that we <em>shouldn't</em> introduce a new block scope in an <code>if</code> head.","msgtype":"m.text"},"ts":1693936319531,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$c17VeEE6p6tKQpy1ca-C_X3ugD5aNPMiABLX4QsHuq4"},
{"content":{"body":"which examples do you want me to alter?","msgtype":"m.text"},"ts":1693937658888,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$mcMskA179HK2KJCrxGG_u-k_IqrMyiXytql02ffB6q8"},
{"content":{"body":"The kind of complexity you are signing up for to make `let` patterns usable in such a narrow way is full-on control flow analysis. If they are just declared in the outer block scope, TDZ does all of that work for you. ","format":"org.matrix.custom.html","formatted_body":"The kind of complexity you are signing up for to make <code>let</code> patterns usable in such a narrow way is full-on control flow analysis. If they are just declared in the outer block scope, TDZ does all of that work for you.","msgtype":"m.text"},"ts":1693937669575,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$3XNrf8hkXqd4trDc3grzIx1_npaODGIFs3HReL_4OAI"},
{"content":{"body":"eg\n```\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    return  ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>eg</p>\n<pre><code>function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    return  ||\n        (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"ts":1693937681627,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$im_yiNYOYMP4iUElmJAwj8IhWMiCmeKl9hg5aeIrkZA"},
{"content":{"body":"The early return example. ","format":"org.matrix.custom.html","formatted_body":"The early return example.","msgtype":"m.text"},"ts":1693937684843,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$babckeF84EkEn-T26lAFMTC6SxzT_fX7g0GKc2nLj8M"},
{"content":{"body":" * eg\n\n```\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    if (topot) { return topot; }\n    return  (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>eg</p>\n<pre><code>function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    if (topot) { return topot; }\n    return  (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","m.new_content":{"body":"eg\n\n```\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    if (topot) { return topot; }\n    return  (getApplicableIndexInfoForName(type, name) is { type: const propType } &&\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>eg</p>\n<pre><code>function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    if (topot) { return topot; }\n    return  (getApplicableIndexInfoForName(type, name) is { type: const propType } &amp;&amp;\n            addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$im_yiNYOYMP4iUElmJAwj8IhWMiCmeKl9hg5aeIrkZA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693937694656,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Y1vvHzcN1yS7WVabBbkqybpFfwbsBT0ngYvalq0Csg8"},
{"content":{"body":"That isn't an applicable refactoring, that is a complete change to code style. ","format":"org.matrix.custom.html","formatted_body":"That isn't an applicable refactoring, that is a complete change to code style.","msgtype":"m.text"},"ts":1693937714261,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$sbjbD-IDJ2i8bhOZZ08dCXzVJjPtY5zR9M1xPHkbb18"},
{"content":{"body":" * eg\n\n```\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    if (topot) { return topot; }\n\n    if (getApplicableIndexInfoForName(type, name) is { type: const propType }) {\n            return addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n    }\n\n    return false;\n}\n```","format":"org.matrix.custom.html","formatted_body":" * <p>eg</p>\n<pre><code>function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    if (topot) { return topot; }\n\n    if (getApplicableIndexInfoForName(type, name) is { type: const propType }) {\n            return addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n    }\n\n    return false;\n}\n</code></pre>\n","m.new_content":{"body":"eg\n\n```\nfunction getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    if (topot) { return topot; }\n\n    if (getApplicableIndexInfoForName(type, name) is { type: const propType }) {\n            return addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n    }\n\n    return false;\n}\n```","format":"org.matrix.custom.html","formatted_body":"<p>eg</p>\n<pre><code>function getTypeOfPropertyOrIndexSignatureOfType(type: Type, name: __String): Type | undefined {\n    const topot = getTypeOfPropertyOfType(type, name);\n    if (topot) { return topot; }\n\n    if (getApplicableIndexInfoForName(type, name) is { type: const propType }) {\n            return addOptionality(propType, /*isProperty*/ true, /*isOptional*/ true));\n    }\n\n    return false;\n}\n</code></pre>\n","msgtype":"m.text"},"m.relates_to":{"event_id":"$im_yiNYOYMP4iUElmJAwj8IhWMiCmeKl9hg5aeIrkZA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693937726529,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$wc-n47OfiKBuyxou4Ayyk3LmBbkUa8jSBRjEhl_HtDM"},
{"content":{"body":"i dunno, something like that (sorry for the edits)","msgtype":"m.text"},"ts":1693937734587,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$q5XnhRhWc3RWmOQdimgvawK7QFNJHJYVEYAR8uVwno0"},
{"content":{"body":"I'd argue we'd keep it as is rather than use pattern matching in that case","msgtype":"m.text"},"ts":1693937737367,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$cw2sybAG0gGkrxGkpwt80hpIHVGbDT8oGnPC6Vdx3U4"},
{"content":{"body":"\"change to code style\" is what refactoring *is*","format":"org.matrix.custom.html","formatted_body":"\"change to code style\" is what refactoring <em>is</em>","msgtype":"m.text"},"ts":1693937742285,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$722KOrpZZzySUk2KniGnVDryqvh2uPd90WlyyOZtMg8"},
{"content":{"body":"early returns tend to make code more readable; i (and most of the js ecosystem) used to force everything to have one return at the bottom, per jslint, but everyone's largely shifted away from that.","msgtype":"m.text"},"ts":1693937773817,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Y5dEG09BxzEiGzUpfnlfpun6kBz_zOXdVJalnHxjWho"},
{"content":{"body":" * early returns tend to make code more readable; i (and most of the js ecosystem) used to force everything to have one return at the bottom, per jslint, but everyone's largely shifted away from that since the late 2000's.","m.new_content":{"body":"early returns tend to make code more readable; i (and most of the js ecosystem) used to force everything to have one return at the bottom, per jslint, but everyone's largely shifted away from that since the late 2000's.","msgtype":"m.text"},"m.relates_to":{"event_id":"$Y5dEG09BxzEiGzUpfnlfpun6kBz_zOXdVJalnHxjWho","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693937788417,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$uiExanC9wW0Eu7juI9RQObpK71GsHcnjYbW9krl6mIc"},
{"content":{"body":"but yeah \"don't use pattern matching\" is obv a fine choice there if it doesn't mesh well with the style you prefer","msgtype":"m.text"},"ts":1693937836803,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$icfUZt01ypxlAY0LsjVCB-Kcl90a19u0SZw0wSW-sd4"},
{"content":{"body":"Yes. I would like to be able to use early return in my last example, but can't if the condition including the pattern is the negative case. ","format":"org.matrix.custom.html","formatted_body":"Yes. I would like to be able to use early return in my last example, but can't if the condition including the pattern is the negative case.","msgtype":"m.text"},"ts":1693937837389,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tEt5f0TQdEADxPQsP6_99-bLeea5yHMTuYPjvKWpfsM"},
{"content":{"body":"i'm pretty sure that example works; is there something i missed, or another one with the negative caes?","msgtype":"m.text"},"ts":1693937866790,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$d3aiGZ_9rtHjc5iZM0HEO1qdlWHiJc98THhBC2U5WL8"},
{"content":{"body":" * i'm pretty sure that example works; is there something i missed, or another one with the negative case?","m.new_content":{"body":"i'm pretty sure that example works; is there something i missed, or another one with the negative case?","msgtype":"m.text"},"m.relates_to":{"event_id":"$d3aiGZ_9rtHjc5iZM0HEO1qdlWHiJc98THhBC2U5WL8","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693937868629,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$a1KkxeyGhm2LYNlra1T_2gQeJB19McPK5uXyNmKrTLs"},
{"content":{"body":"Sorry, I was away from my PC and on my phone. I meant this example:\n\n```\nif (!(x is Option.some(let value)) {\n  return; // nothing to do, exit early\n}\nvalue; // use 'value'\n```","format":"org.matrix.custom.html","formatted_body":"<p>Sorry, I was away from my PC and on my phone. I meant this example:</p>\n<pre><code>if (!(x is Option.some(let value)) {\n  return; // nothing to do, exit early\n}\nvalue; // use 'value'\n</code></pre>\n","msgtype":"m.text"},"ts":1693937928605,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$EF0tR3_3jzOI-oiMAE0frNpp8UE5F3LIZ9aYJqC13D4"},
{"content":{"body":"Specifically, the negative case in the `if`. This is an example of something I've seen in C#, which has the same \"declaration pattern\" concept that I'm proposing with `let` patterns.","format":"org.matrix.custom.html","formatted_body":"Specifically, the negative case in the <code>if</code>. This is an example of something I've seen in C#, which has the same \"declaration pattern\" concept that I'm proposing with <code>let</code> patterns.","msgtype":"m.text"},"ts":1693938002650,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$5I0oFNEOTxbcBZHBwrCnwl1LB4EzTqVVetOgUieQTFY"},
{"content":{"body":"```\nif (x is not Option.Some(let value)) {\n   // use `value`\n}\nreturn;\n```\nis fine imo","format":"org.matrix.custom.html","formatted_body":"<pre><code>if (x is not Option.Some(let value)) {\n   // use `value`\n}\nreturn;\n</code></pre>\n<p>is fine imo</p>\n","msgtype":"m.text"},"ts":1693938135113,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$SK4QQLVLv72UYhkKPZs4osRuVtHcIaQcnJoZXEmGJ24"},
{"content":{"body":"That isn't an early return though.","msgtype":"m.text"},"ts":1693938159100,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$tpKWeAEKHEyToQRlfhbsHLV2jVSGBuMh95Z9yb2da9g"},
{"content":{"body":"true. but not everything has to be","msgtype":"m.text"},"ts":1693938166092,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$rP1JwM-YI6sizGxGpf-Be_RjHNxitWY4G1RdypmgWoM"},
{"content":{"body":"You also are incorrect in the use of `not`.","format":"org.matrix.custom.html","formatted_body":"You also are incorrect in the use of <code>not</code>.","msgtype":"m.text"},"ts":1693938182512,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_b4xSDEiYqmKYj1oyukhtdDlaj083Lv_3Q5g6WbSAu4"},
{"content":{"body":"how so?","msgtype":"m.text"},"ts":1693938187831,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$-mxzcv30_oNditIRqP9adpuH22dBzQjKDWF-EKX8Mug"},
{"content":{"body":"The early return is if its not a match. You swapped the branches but not the condition.","msgtype":"m.text"},"ts":1693938205361,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$fxFUrINqUJOvOF-VyNxpKXbMdnRVEeWDhfAf-fr1W4g"},
{"content":{"body":"or this:\n```\nif (x is Option.Some(value)) {\n  return;\n}\nconst Option.Some(value) = x;\n```\nusing extractors","format":"org.matrix.custom.html","formatted_body":"<p>or this:</p>\n<pre><code>if (x is Option.Some(value)) {\n  return;\n}\nconst Option.Some(value) = x;\n</code></pre>\n<p>using extractors</p>\n","msgtype":"m.text"},"ts":1693938214091,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$d0_ABwZ4xjtMXsi5ItXASg2_nJKF51UbJXOrLjXbNFA"},
{"content":{"body":"ok so yes, i see what you mean","msgtype":"m.text"},"ts":1693938240653,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$BWHmhhCg6E2pJtIhA28er82vfnW3DggQQdgLndMui4g"},
{"content":{"body":"I'm saying that we *could* have this work in a way that is intuitive, but these restrictions make it hard to reason over.","format":"org.matrix.custom.html","formatted_body":"I'm saying that we <em>could</em> have this work in a way that is intuitive, but these restrictions make it hard to reason over.","msgtype":"m.text"},"ts":1693938245073,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$IaLVFhAmqZeVZUlLWXER-omhC6zjC0WXxx0pFOF1q_g"},
{"content":{"body":"Also, you're re-evaluating the match now which is completely inefficient.","msgtype":"m.text"},"ts":1693938262722,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$KrE4tbJ4-Nk7SkRkZHDhVK-7A3ibmqzvN8VqEPPpYhY"},
{"content":{"body":"true. i don't think this kind of situation is common enough or important enough tho to warrant shredding the mental model of what can produce bindings in a block.","msgtype":"m.text"},"ts":1693938281357,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$GxaD8UtFlt9PoWFVCrM4BIajaPFe16YJjWQL6fnQzPc"},
{"content":{"body":"what happens if you do `const Option.Some(value) = x` when it doesn't match, btw?","format":"org.matrix.custom.html","formatted_body":"what happens if you do <code>const Option.Some(value) = x</code> when it doesn't match, btw?","msgtype":"m.text"},"ts":1693938300923,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$o_zv5PNCHnkXJNrOln4EdfPiNkoRX6rw-kn2W2RywaI"},
{"content":{"body":"It doesn't need to be that complex. `if` doesn't make its own block, so the bindings are declared in the containing scope. TDZ handles cases where conditions failed to match or bindings weren't initialized. Scoping works as you'd expect and existing code can be refactored to patterns without completely rewriting the entire function.","format":"org.matrix.custom.html","formatted_body":"It doesn't need to be that complex. <code>if</code> doesn't make its own block, so the bindings are declared in the containing scope. TDZ handles cases where conditions failed to match or bindings weren't initialized. Scoping works as you'd expect and existing code can be refactored to patterns without completely rewriting the entire function.","msgtype":"m.text"},"ts":1693938375661,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$b0S-cn9HdzhIsmVR9EU8Zr6bt_Z4vQApPAAwfJlFRms"},
{"content":{"body":"the if parens are attached to the block","msgtype":"m.text"},"ts":1693938464661,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$xbg-6-zvlt2TA6dqp4QPv8Nffw4HX-Y6SRBOgGCJfRE"},
{"content":{"body":"just like `for (let x in y) {}` is","format":"org.matrix.custom.html","formatted_body":"just like <code>for (let x in y) {}</code> is","msgtype":"m.text"},"ts":1693938472281,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$sobMz6koYYflCGTSoSYX2CYYG1iFwN6aF-UVZzCbKqk"},
{"content":{"body":"By narrowing the scoping to inside of the `if`, or to only `true` branches in ternaries/short-circuiting, you're making things far more complicated and harder to reason over and use.","format":"org.matrix.custom.html","formatted_body":"By narrowing the scoping to inside of the <code>if</code>, or to only <code>true</code> branches in ternaries/short-circuiting, you're making things far more complicated and harder to reason over and use.","msgtype":"m.text"},"ts":1693938474510,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xOyMeQ-OXbbyNLiYLxaoNjytquvqxA-4KzBsvbdXhhs"},
{"content":{"body":" * just like `for (let x in y) {}` is - so there's already precedent for that mental model.","format":"org.matrix.custom.html","formatted_body":" * just like <code>for (let x in y) {}</code> is - so there's already precedent for that mental model.","m.new_content":{"body":"just like `for (let x in y) {}` is - so there's already precedent for that mental model.","format":"org.matrix.custom.html","formatted_body":"just like <code>for (let x in y) {}</code> is - so there's already precedent for that mental model.","msgtype":"m.text"},"m.relates_to":{"event_id":"$sobMz6koYYflCGTSoSYX2CYYG1iFwN6aF-UVZzCbKqk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693938479780,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$MWfeF9Q8mqmfeYdvXXZz9d_pEUHp1OLFEVUibZOlOxI"},
{"content":{"body":" * just like `for (let x of y) {}` is - so there's already precedent for that mental model.","format":"org.matrix.custom.html","formatted_body":" * just like <code>for (let x of y) {}</code> is - so there's already precedent for that mental model.","m.new_content":{"body":"just like `for (let x of y) {}` is - so there's already precedent for that mental model.","format":"org.matrix.custom.html","formatted_body":"just like <code>for (let x of y) {}</code> is - so there's already precedent for that mental model.","msgtype":"m.text"},"m.relates_to":{"event_id":"$sobMz6koYYflCGTSoSYX2CYYG1iFwN6aF-UVZzCbKqk","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693938485357,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$wJQbaTd9YLJKxDnQRbTCqtE-4plTknHgEwNGa81CxXU"},
{"content":{"body":"That doesn't need to be the case, since `if` isn't `for`.","format":"org.matrix.custom.html","formatted_body":"That doesn't need to be the case, since <code>if</code> isn't <code>for</code>.","msgtype":"m.text"},"ts":1693938496754,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$eulXr1xpvC39he3cSsSdvHaq_P1mb1XfSCmzgXM7AJE"},
{"content":{"body":"yes but that's what users already expect","msgtype":"m.text"},"ts":1693938504533,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$BCbjibLEiVbvSILLgGgZb9UVvM10wfqGU6TcxbNYXXg"},
{"content":{"body":"that's what will be easy to reason about","msgtype":"m.text"},"ts":1693938508139,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$_ycXHcTKWLlMBdMSZjQzQjL3yd2HiNjGMIYIklO5iz0"},
{"content":{"body":"doing anything *different* is what will be complicated and confusing","format":"org.matrix.custom.html","formatted_body":"doing anything <em>different</em> is what will be complicated and confusing","msgtype":"m.text"},"ts":1693938516372,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$RFf72W-pYYIfwGmDf6jYhJVV-xeGQq6yftISO8Q6hHY"},
{"content":{"body":"Users expect `for` declarations to be scoped, but that doesn't apply to _Expression_.","format":"org.matrix.custom.html","formatted_body":"Users expect <code>for</code> declarations to be scoped, but that doesn't apply to <em>Expression</em>.","msgtype":"m.text"},"ts":1693938540059,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$_Lim4bgNnCxp1qDUsjlh9g0ytogWesdoA1lsrowfYhk"},
{"content":{"body":"users don't think about grammar at all","msgtype":"m.text"},"ts":1693938554256,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$xTz_TSFUYIYU2hlAaJLGeWj0vB4SvJ6nPaYk9_ei6PI"},
{"content":{"body":"for example, there's no reason that a `let` pattern in the Expression of a `for` statement head should be scoped to the `for`.","format":"org.matrix.custom.html","formatted_body":"for example, there's no reason that a <code>let</code> pattern in the Expression of a <code>for</code> statement head should be scoped to the <code>for</code>.","msgtype":"m.text"},"ts":1693938565192,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$p5nLZIQdIUyP_VCY5lXDDTNlWKQGgN1RnltxcPndIGQ"},
{"content":{"body":"`for (let i = 0; i < 3; ++i) { } i;` will error because i is not defined","format":"org.matrix.custom.html","formatted_body":"<code>for (let i = 0; i &lt; 3; ++i) { } i;</code> will error because i is not defined","msgtype":"m.text"},"ts":1693938601502,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$DBn-SDuU_MolqKfziix4ZI-0zMRI-Pu_lC3ZbfDrJGE"},
{"content":{"body":"so there is a reason, because *that's already how it works* since 2015","format":"org.matrix.custom.html","formatted_body":"so there is a reason, because <em>that's already how it works</em> since 2015","msgtype":"m.text"},"ts":1693938609764,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$-HpwWblVcqGPQM8-aW5GZIuQMP34jjn6qcYp3htyWeE"},
{"content":{"body":"we can't change that, period","msgtype":"m.text"},"ts":1693938613621,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$tZVBR2M0CYX8r8S3HV4CfhR6J8-_Hq_Ax4YFxix8QOU"},
{"content":{"body":"```\nfor (let x of y is Option.some(let value) ? value : []) {\n}\nvalue; // could be legal here\n```","format":"org.matrix.custom.html","formatted_body":"<pre><code>for (let x of y is Option.some(let value) ? value : []) {\n}\nvalue; // could be legal here\n</code></pre>\n","msgtype":"m.text"},"ts":1693938617947,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$ENIEypjBHbR9OAuyoMcdsWTNaOQ6By25wQrpdhMnDuU"},
{"content":{"body":"could be. but that would be different and surprising.","msgtype":"m.text"},"ts":1693938629100,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$qNkO7CEPOJkz-ESU04jQtHsX_2FZMDYm2SwFjp8Tozc"},
{"content":{"body":"and thus, shouldn't be.","msgtype":"m.text"},"ts":1693938631530,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$xVXvYdFK2iHrDuRsD77qb8KctEsSPZyvOxinnayKDQA"},
{"content":{"body":"Yes, that's the `for` declaration. That's separate from the `expression` part.","format":"org.matrix.custom.html","formatted_body":"Yes, that's the <code>for</code> declaration. That's separate from the <code>expression</code> part.","msgtype":"m.text"},"ts":1693938636791,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$QCo7HObzfPGQp8hWMrWVRbbYkobFyzRZpi6gn7l_BDc"},
{"content":{"body":" * and thus, shouldn't be, even if some people would find it useful.","m.new_content":{"body":"and thus, shouldn't be, even if some people would find it useful.","msgtype":"m.text"},"m.relates_to":{"event_id":"$xVXvYdFK2iHrDuRsD77qb8KctEsSPZyvOxinnayKDQA","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693938638419,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$X1OSAHiEOZ8LQwEJvLJpJbav3bu9O9oMfyVOuqU2jNA"},
{"content":{"body":"users don't think about it that way","msgtype":"m.text"},"ts":1693938648861,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$9kZHoGZfW_WrHpNnc9vTxD1RhHVaBBVlg0ArFwiuEBY"},
{"content":{"body":"it's \"things bound inside the for (…) are only in scope in the `{ … }`\"","format":"org.matrix.custom.html","formatted_body":"it's \"things bound inside the for (…) are only in scope in the <code>{ … }</code>\"","msgtype":"m.text"},"ts":1693938664036,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$8iFKd6ZApVH0I7i4BAN0NNvYu9GQM5ZCSoCNGPwxRcc"},
{"content":{"body":"obviously we *could* do it. but nobody will expect that.","format":"org.matrix.custom.html","formatted_body":"obviously we <em>could</em> do it. but nobody will expect that.","msgtype":"m.text"},"ts":1693938672475,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$OPPFFyD7kPwNkBulh26rs-QetD1kozUhKyTun7qxRzI"},
{"content":{"body":"And maybe it makes sense to have `for` and `while` scope their expressions to the per-iteration block, but `if` is not per-iteration, so it doesn't need to obey those rules.","format":"org.matrix.custom.html","formatted_body":"And maybe it makes sense to have <code>for</code> and <code>while</code> scope their expressions to the per-iteration block, but <code>if</code> is not per-iteration, so it doesn't need to obey those rules.","msgtype":"m.text"},"ts":1693938687527,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$dVQtNrE7kBWzQUrlIWJ-PCdDhX78nY40CTIeRqgc_Jo"},
{"content":{"body":"arguably if is an iteration of one :-p but sure","msgtype":"m.text"},"ts":1693938701561,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$VRIGyLFdrOj484xvuypMrQpKRFEYHnfiKANw_p5ci1s"},
{"content":{"body":"it doesn't *need* to. but it *should* because that's what users will expect. and that always trumps \"what we could get away with\"","format":"org.matrix.custom.html","formatted_body":"it doesn't <em>need</em> to. but it <em>should</em> because that's what users will expect. and that always trumps \"what we could get away with\"","msgtype":"m.text"},"ts":1693938713855,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$4pLAwuXVBWFO5PJ2cBQJGyvnZnHa2Ip9mOUSWN16dfI"},
{"content":{"body":"But I could definitely see this being useful:\n\n```\nwhile (x is not Option.Some(let value)) {\n  x = nextX();\n}\nvalue;\n```","format":"org.matrix.custom.html","formatted_body":"<p>But I could definitely see this being useful:</p>\n<pre><code>while (x is not Option.Some(let value)) {\n  x = nextX();\n}\nvalue;\n</code></pre>\n","msgtype":"m.text"},"ts":1693938731830,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$iP4ABg30xLijNZtvgxlHAuvyVqKL1YE-Ppp89MG5cao"},
{"content":{"body":"\"it could be useful\" is never sufficient to override \"it will probably be surprising\"","msgtype":"m.text"},"ts":1693938751327,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$o7M5SDOiYqZ8cekzEkGaFNEtmmvRNJKTKeHuoirmpwU"},
{"content":{"body":"I don't find it surprising, and I'm not convinced the general developer population would either.","msgtype":"m.text"},"ts":1693938775789,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$Qb7EYAOqaR_FXQMFExe82w11GPJ_oW8AKafJPcLXtHQ"},
{"content":{"body":"What I would find surprising is if this:\n\n```\nif (x is Option.Some(let value)) {\n  value;\n}\nreturn;\n```\n\ncan't be refactored to the negative case like it can for every other expression:\n\n```\nif (!(x is Option.Some(let value))) {\n  return;\n}\nvalue;\n```\n","format":"org.matrix.custom.html","formatted_body":"<p>What I would find surprising is if this:</p>\n<pre><code>if (x is Option.Some(let value)) {\n  value;\n}\nreturn;\n</code></pre>\n<p>can't be refactored to the negative case like it can for every other expression:</p>\n<pre><code>if (!(x is Option.Some(let value))) {\n  return;\n}\nvalue;\n</code></pre>\n","msgtype":"m.text"},"ts":1693938853141,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$k5qHZ8LB5joq-PgDOO4ur2kU5Bx-7HJR3a2P06EN99g"},
{"content":{"body":"then the solution to that surprise is no bindings at all, really.","msgtype":"m.text"},"ts":1693938875972,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$2v6gyslTnWRo6qa3t8zbXNVgWkc5ZUzeXccHwysd8jk"},
{"content":{"body":"which i don't think any of us want","msgtype":"m.text"},"ts":1693938885548,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$N624rGmeUshZPshZLfP1tBCRFNekLiZapzEylkxXaQU"},
{"content":{"body":"because no expression can create bindings yet, so that would be a much larger surprise.","msgtype":"m.text"},"ts":1693938913916,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$Qts-dMGxzfRbF1U0630o_G17E3VGbDqDMeIISiFwDP4"},
{"content":{"body":"If we can't introduce bindings in patterns to capture matched values, pattern matching has almost no value.","msgtype":"m.text"},"ts":1693938921026,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$1nPs_9gmE3XM7U8KLtoSImuHIxvtfcyyWKKwBeDqK3g"},
{"content":{"body":"to use your \"but this is different so its ok\" argument, then \"an expression with let/const/var inside\" is different, and it's fine if it follows different rules","msgtype":"m.text"},"ts":1693938939746,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$cX0QRgjyq_jhTSqXTeT1TtxYdW8FbQiGGxBWhl34t5s"},
{"content":{"body":" * to use your \"but this is different so its ok\" argument, then \"an expression with let/const/var inside\" is different, and it's fine if it follows different rules, including that you can't naively refactor it like you can normal expressions.","m.new_content":{"body":"to use your \"but this is different so its ok\" argument, then \"an expression with let/const/var inside\" is different, and it's fine if it follows different rules, including that you can't naively refactor it like you can normal expressions.","msgtype":"m.text"},"m.relates_to":{"event_id":"$cX0QRgjyq_jhTSqXTeT1TtxYdW8FbQiGGxBWhl34t5s","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693938950228,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$tGdjeGiCkWTY62miE2THAWIOHGeP3XbV6NE7EnJsZ6A"},
{"content":{"body":"Pattern matching itself is a very complex feature. You're not going to get away with just assuming how things work without reading some kind of documentation, so I'm not sure its going to be that surprising.","msgtype":"m.text"},"ts":1693938966604,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$xXV7AjNVrtoyHedw-ZdQoT_cyuzxqAKXPTaZ0t32bXw"},
{"content":{"body":"sure. but that argument works for all of our positions in varying degrees.","msgtype":"m.text"},"ts":1693939011179,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$l36ZT8f_hc8uV1qfQ3pKPZV4fT0uagJ6QvONzQ33wPI"},
{"content":{"body":"including refactorability","msgtype":"m.text"},"ts":1693939018774,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$GnqOM2GZn3VxElKugLC8UNeQoNEs-3wp5qDIHOhtbe8"},
{"content":{"body":"Principle of least surprise. Which is more surprising?\n1. A `let` pattern introduces a binding that is scoped to the nearest outer block.\n2. I can't swap an `if` condition to its inverse without a complete rewrite of the surrounding code.","format":"org.matrix.custom.html","formatted_body":"<p>Principle of least surprise. Which is more surprising?</p>\n<ol>\n<li>A <code>let</code> pattern introduces a binding that is scoped to the nearest outer block.</li>\n<li>I can't swap an <code>if</code> condition to its inverse without a complete rewrite of the surrounding code.</li>\n</ol>\n","msgtype":"m.text"},"ts":1693939079257,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$4YPxqkUODwVxHeTDkyKM6yhrgX5niPX-ZOm2ee_j0Es"},
{"content":{"body":"personally, the former.","msgtype":"m.text"},"ts":1693939099869,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$qYY-vf3oIqnZ_gcYBVOHJCpssTPiZmnx-0x9AUffPSY"},
{"content":{"body":"All `let` declarations are currently scoped to the nearest outer block.","format":"org.matrix.custom.html","formatted_body":"All <code>let</code> declarations are currently scoped to the nearest outer block.","msgtype":"m.text"},"ts":1693939109786,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$mVOyzn4SH1URL86fk70CrnRMKtAfkKEywwDXqwvN-gw"},
{"content":{"body":"because i just don't hold that second assumption at all","msgtype":"m.text"},"ts":1693939111308,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$hrP9VkHNq0ECcDahKSmJCbIkoC8Mtky9UnFXyQmWLXU"},
{"content":{"body":"for example, if you return inside the block, or throw, or do something async, etc, you can't swap it without larger rewrites","msgtype":"m.text"},"ts":1693939127470,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$h1eDIhyRiip7kMdptnaYAeFZYBGD4nXcWZ3tOndqFBg"},
{"content":{"body":"> <@rbuckton:matrix.org> All `let` declarations are currently scoped to the nearest outer block.\n\nsure, and no expressions can create bindings. both current scenarios aren't super relevant here?","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!XyZDxqjPFLRXDgUzhD:matrix.org/$mVOyzn4SH1URL86fk70CrnRMKtAfkKEywwDXqwvN-gw?via=matrix.org&via=mozilla.org&via=igalia.com\">In reply to</a> <a href=\"https://matrix.to/#/@rbuckton:matrix.org\">@rbuckton:matrix.org</a><br>All <code>let</code> declarations are currently scoped to the nearest outer block.</blockquote></mx-reply>sure, and no expressions can create bindings. both current scenarios aren't super relevant here?","m.relates_to":{"m.in_reply_to":{"event_id":"$mVOyzn4SH1URL86fk70CrnRMKtAfkKEywwDXqwvN-gw"}},"msgtype":"m.text"},"ts":1693939148749,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$hc3ibFuwnIY_73koPnRraF8snzehhhf9Kb5Sh8Ro6EQ"},
{"content":{"body":"I've already imagined a number of cases for (2) in multiple codebases where I wouldn't be able to employ pattern matching in cases where it would be extremely useful, without having to even further complicate my code.","msgtype":"m.text"},"ts":1693939170063,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$VT4YlLKuwAgJXephrUzWDJ63h8rdsdMl75QjwDL8dZ8"},
{"content":{"body":"Both (1) and (2) are assuming expressions can create bindings, they're just talking about scoping. We've already spent the cost of that surprise for these cases.","msgtype":"m.text"},"ts":1693939214267,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$lhvjmucIzJbHPGv2g6ZGqbNGVIAFVNT55MkMQeVex5s"},
{"content":{"body":"ok, but as i said, 2 is just not a valid assumption without a bunch of caveats","msgtype":"m.text"},"ts":1693939241618,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$W8AuECwQmTaF-rwzd8-SBEI6bXsTwXwHgNlSTMOudCM"},
{"content":{"body":"and pattern matching doesn't have to be useful everywhere. there's still a vast number of places it will be useful.","msgtype":"m.text"},"ts":1693939260371,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$ZT_6pD9M2Bnv6bqsitfFtGWEYCrbS9fbbe5HyH5IcGo"},
{"content":{"body":"If it helps, I can reach out to Anders and the C# team to get additional context as to why they chose the variable scope they did for `is`.","format":"org.matrix.custom.html","formatted_body":"If it helps, I can reach out to Anders and the C# team to get additional context as to why they chose the variable scope they did for <code>is</code>.","msgtype":"m.text"},"ts":1693939267333,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$heoBr3IRfDvYaJyfdn_WsWGsor-EX4rIQqW2yOxSJp4"},
{"content":{"body":"it can't hurt, but i'm not sure it'll make much difference. JS isn't C#.","msgtype":"m.text"},"ts":1693939290820,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$7USJembjMOFUkMXkYqHWueWNdpvTqc9VKp-Dte4dlRU"},
{"content":{"body":"What caveats? I showed a very basic case that shows the discrepancy already.","msgtype":"m.text"},"ts":1693939301334,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$kk9gob4WFaWP5mcBK_kDOZo24a3pnyoQlivRzWa-XVQ"},
{"content":{"body":"there exist less basic cases where you can't just swap the condition without a larger code change.","msgtype":"m.text"},"ts":1693939331254,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$9T-Gh1EIZNFyic0XBz3SnMcXVWUhM4xELRq0WRKVbhE"},
{"content":{"body":"I find (1) the least surprising because it matches what `let` already does. It declares the variable in the containing block scope. ","format":"org.matrix.custom.html","formatted_body":"I find (1) the least surprising because it matches what <code>let</code> already does. It declares the variable in the containing block scope.","msgtype":"m.text"},"ts":1693939335110,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$wmtS1dm5Fk74f-QGPOw1Yv3TaETBfpbaVIDy3S5Q3Dg"},
{"content":{"body":" * there exist less-basic cases where you can't just swap the condition without a larger code change.","m.new_content":{"body":"there exist less-basic cases where you can't just swap the condition without a larger code change.","msgtype":"m.text"},"m.relates_to":{"event_id":"$9T-Gh1EIZNFyic0XBz3SnMcXVWUhM4xELRq0WRKVbhE","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693939352811,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$pStokd_HzOS37UOMQ-ZnGzWysJqTFWcxsWg8JFMgNiM"},
{"content":{"body":"Yes, but those cases are going to be complicated regardless as to how pattern matching works.","msgtype":"m.text"},"ts":1693939359424,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$bEbtJpkaKYRaDdxUYSp1D_EEOZn1KqpLSsSawr_Mp_M"},
{"content":{"body":"right but it illustrates why it's an invalid assumption that you can just inverse an `if`","format":"org.matrix.custom.html","formatted_body":"right but it illustrates why it's an invalid assumption that you can just inverse an <code>if</code>","msgtype":"m.text"},"ts":1693939374239,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$7fNZD2IbUA5qrtpbBGu1GPI-_l4HtCajLvp39DpOd50"},
{"content":{"body":" * right but it illustrates why it's an invalid assumption that you can just easily inverse an `if`","format":"org.matrix.custom.html","formatted_body":" * right but it illustrates why it's an invalid assumption that you can just easily inverse an <code>if</code>","m.new_content":{"body":"right but it illustrates why it's an invalid assumption that you can just easily inverse an `if`","format":"org.matrix.custom.html","formatted_body":"right but it illustrates why it's an invalid assumption that you can just easily inverse an <code>if</code>","msgtype":"m.text"},"m.relates_to":{"event_id":"$7fNZD2IbUA5qrtpbBGu1GPI-_l4HtCajLvp39DpOd50","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1693939377340,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$EA8iPHMeM7SB06bEqjAEtG71aCFgf2sIkiKZDmkPQRg"},
{"content":{"body":"Its not more or less complex with pattern matching.","msgtype":"m.text"},"ts":1693939377959,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PyPeL65jDFVAMcIjTHB4sOEAsE72R3nA4H6DaRPPpvk"},
{"content":{"body":"that's not generally true, so it's false","msgtype":"m.text"},"ts":1693939382839,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$On4BQ8uZE-5gIyqONmnh6_YFJtLGEDNoGqOeBjuY9Ic"},
{"content":{"body":"If you can't inverse an `if` in the simple case, the more complex cases aren't relevant.","format":"org.matrix.custom.html","formatted_body":"If you can't inverse an <code>if</code> in the simple case, the more complex cases aren't relevant.","msgtype":"m.text"},"ts":1693939393218,"senderName":"rbuckton","senderId":"@rbuckton:matrix.org","id":"$PRT_jYycmxeJcwQpZutRKsCb49rjX1FzX_PmTPXbQ2Y"},
{"content":{"body":"i hear you that some very basic if's would be inversable, and pattern matching with contained bindings would make that not the case","msgtype":"m.text"},"ts":1693939422692,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$HvDQ5JK5AQFfmGHoclJxwIIQCzc29f_uV_U2wnQS6dI"},
{"content":{"body":"but to me that makes things *more* consistent - that you can count on inverting the if even *less*.","format":"org.matrix.custom.html","formatted_body":"but to me that makes things <em>more</em> consistent - that you can count on inverting the if even <em>less</em>.","msgtype":"m.text"},"ts":1693939434837,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$qC2QC5VzV_r74SgWlGd3RE-EET6_SlA9aS2Eh39ZPTU"},
{"content":{"body":"because that's just not something you should ever rely on.","msgtype":"m.text"},"ts":1693939440583,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$kArSZS_8Q_ILv_xeshQd_9PX_gLPVqam8miWYJepZCM"}
]