[
{"content":{"body":"Good morning, all. I wanted to reiterate a bit on what I said in plenary and also afterwards direct to Kris last week.\n\nThe layered modules APIs that Kris presented are great at permitting a bunch of use-cases. In particular I like the idea of using them for achieving mocking in a test runner (avoiding the need for code to use DI patterns or custom host hooks).\n\nThe bigger win (value proposition) is if we can identify features that will allow the wider ecosystem to adopt ES modules. npm & Node mostly ship and execute CommonJS. No one has provided a compelling or easy migration story. So we have a situation that may even be worse than the Python 2/3 switchover.\n\nA key specific use-case that CJS still beats ESM on is the ability to ergonomically/quickly achieve fast load times via lazy loading. Meaning the Babel option \"lazy\" on the ESM->CJS transform that injects conditional synchronous requires to defer loading static imports to instead be just-in-time.\n\nESM has no ergonomic way to achieve this. Instead users are forced to rewrite their app to become async and use dynamic `import() `. Because switching sync->async functions have ripple effects back to the caller.\n\nOriginally Yulia's defer-eval proposal looked like it might solve this problem. But I understand the sync part of that proposal is now under debate.\n\nMy purpose in conveying this is not to demand sync loading. It is to highlight that, if you can make migration from CJS to ESM easier, then (1) the community/ecosystem will love you and see the value of your work, and (2) it will be easier to fund this work stream.","msgtype":"m.text"},"ts":1658736102114,"senderName":"Rob Palmer","senderId":"@robpalme:matrix.org","id":"$sM11Q66L1nUqqKOCMic6H6r_A7Q3v3SRmoI5Ej3yznw"},
{"content":{"body":"I really like Rob's idea in the abstract, but I'm having trouble understanding what it means concretely. Would we ask people to write app-specific compartment adapters? Or would there be one in the ecosystem that catches on?","msgtype":"m.text","org.matrix.msc1767.text":"I really like Rob's idea in the abstract, but I'm having trouble understanding what it means concretely. Would we ask people to write app-specific compartment adapters? Or would there be one in the ecosystem that catches on?"},"ts":1658753806979,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$8SB6K4KH5r8BpAzPVAl0CvTauYsF0geXWE86jVnc4UY"},
{"content":{"body":"I read the request as one to find a solution to the problem that named imports can’t trigger an export accessor, the way destructuring a module.exports can.","msgtype":"m.text","org.matrix.msc1767.text":"I read the request as one to find a solution to the problem that named imports can’t trigger an export accessor, the way destructuring a module.exports can."},"ts":1658777377825,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$UPAxcKmQA7hj1C_hJg57iKs6thRO0JiK6yACVF6C07E"},
{"content":{"body":"Or to find a different way to solve the problem that export accessors currently do, in a way that helps existing CommonJS code lift into ESM.","msgtype":"m.text","org.matrix.msc1767.text":"Or to find a different way to solve the problem that export accessors currently do, in a way that helps existing CommonJS code lift into ESM."},"ts":1658777430417,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$kmW6PEbBXwswo3FWI4pEWaXAwDlJoJXMD79TCG1k4ro"},
{"content":{"body":"Which will be hard and I imagine most solutions to be worse than the problem, but it’s very fair to ask us to think about it.","msgtype":"m.text","org.matrix.msc1767.text":"Which will be hard and I imagine most solutions to be worse than the problem, but it’s very fair to ask us to think about it."},"ts":1658777468703,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$e3FMwELU9U0rvm4DR9XN93PEQudWOJ7_OFP4gEdittM"},
{"content":{"body":"I personally find it appetizing to force that particular kind of CommonJS to be rewritten into patterns more amenable to tree shaking in ESM, but that’s contrary to the goal of easing adoption.","msgtype":"m.text","org.matrix.msc1767.text":"I personally find it appetizing to force that particular kind of CommonJS to be rewritten into patterns more amenable to tree shaking in ESM, but that’s contrary to the goal of easing adoption."},"ts":1658777554697,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$gPYdBX1X_epM-EIQ-LGqMz5VlbCuNaJSYp8TMNi0JIU"},
{"content":{"body":"I'm not sure if accessors are the goal here, though they would actually help us with something else! namely the goal of deferred module evaluation, where the module body is only run on the first access of one of the exports","msgtype":"m.text","org.matrix.msc1767.text":"I'm not sure if accessors are the goal here, though they would actually help us with something else! namely the goal of deferred module evaluation, where the module body is only run on the first access of one of the exports"},"ts":1658778252168,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$4J6hSgFYY7RrjRGZVwG21DqxUl_HJqW9UTUr4l3AqjY"},
{"content":{"body":"(TLA would be handled by running the async subgraph eagerly, and only being lazy about the stuff on top of that)","msgtype":"m.text","org.matrix.msc1767.text":"(TLA would be handled by running the async subgraph eagerly, and only being lazy about the stuff on top of that)"},"ts":1658778283900,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$HwjrFzkhXbmBdoIskrdOTUWHUaTgJtJCOnF4RzpzyCc"},
{"content":{"body":"Sure, that sounds like a similar solution to the same problem.","msgtype":"m.text","org.matrix.msc1767.text":"Sure, that sounds like a similar solution to the same problem."},"ts":1658778332598,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Y2jltQV1j9nxoo6nSrMeSKiHFXFJXxVMnuC7paVHis8"},
{"content":{"body":"Wasn't there a proposal for export accessors a few years ago?","msgtype":"m.text"},"ts":1658780636096,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$kn_mJQn7ygxL-XmzmA_pRG_ZVvR6mCwurP0D2XfWSRE"},
{"content":{"body":"Thanks Rob Palmer for the input, very good points raised. My personal take on this perspective would be to ensure we have lazy execution and sync execution as a possibility of the \"epiche\" (in the spirit of continued mutation of the word). I completely get that these CJS -> ESM scenarios are causing friction for adoption, although a concern here is that this is a Node.js-specific issue that even with a spec unlock won't guarantee progress. Unfortunately Node.js is now caught up in a bind with its own loader system causing asynchronous loading requirements, although there are people actively working on making hooks sync by moving them off thread. Funding on the Node.js side may well speed things up there as well. On the ECMA-262 side, I could imagine a follow-up or new iteration of Yulia's proposal that tackles lazy execution and sync execution to fit into this story and I'd be more than happy to be involved in discussions here. From my perspective I don't see any frictions or concerns regarding the overall picture, short of more features just being more complexity, but I don't personally see an issue with adding complexity to the module system since it also means more control over performance and loading in the hands of users.","format":"org.matrix.custom.html","formatted_body":"Thanks <a href=\"https://matrix.to/#/@robpalme:matrix.org\">Rob Palmer</a> for the input, very good points raised. My personal take on this perspective would be to ensure we have lazy execution and sync execution as a possibility of the &quot;epiche&quot; (in the spirit of continued mutation of the word). I completely get that these CJS -&gt; ESM scenarios are causing friction for adoption, although a concern here is that this is a Node.js-specific issue that even with a spec unlock won't guarantee progress. Unfortunately Node.js is now caught up in a bind with its own loader system causing asynchronous loading requirements, although there are people actively working on making hooks sync by moving them off thread. Funding on the Node.js side may well speed things up there as well. On the ECMA-262 side, I could imagine a follow-up or new iteration of Yulia's proposal that tackles lazy execution and sync execution to fit into this story and I'd be more than happy to be involved in discussions here. From my perspective I don't see any frictions or concerns regarding the overall picture, short of more features just being more complexity, but I don't personally see an issue with adding complexity to the module system since it also means more control over performance and loading in the hands of users.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Thanks Rob Palmer for the input, very good points raised. My personal take on this perspective would be to ensure we have lazy execution and sync execution as a possibility of the \"epiche\" (in the spirit of continued mutation of the word). I completely get that these CJS -> ESM scenarios are causing friction for adoption, although a concern here is that this is a Node.js-specific issue that even with a spec unlock won't guarantee progress. Unfortunately Node.js is now caught up in a bind with its own loader system causing asynchronous loading requirements, although there are people actively working on making hooks sync by moving them off thread. Funding on the Node.js side may well speed things up there as well. On the ECMA-262 side, I could imagine a follow-up or new iteration of Yulia's proposal that tackles lazy execution and sync execution to fit into this story and I'd be more than happy to be involved in discussions here. From my perspective I don't see any frictions or concerns regarding the overall picture, short of more features just being more complexity, but I don't personally see an issue with adding complexity to the module system since it also means more control over performance and loading in the hands of users.","mimetype":"text/plain"},{"body":"Thanks <a href=\"https://matrix.to/#/@robpalme:matrix.org\">Rob Palmer</a> for the input, very good points raised. My personal take on this perspective would be to ensure we have lazy execution and sync execution as a possibility of the &quot;epiche&quot; (in the spirit of continued mutation of the word). I completely get that these CJS -&gt; ESM scenarios are causing friction for adoption, although a concern here is that this is a Node.js-specific issue that even with a spec unlock won't guarantee progress. Unfortunately Node.js is now caught up in a bind with its own loader system causing asynchronous loading requirements, although there are people actively working on making hooks sync by moving them off thread. Funding on the Node.js side may well speed things up there as well. On the ECMA-262 side, I could imagine a follow-up or new iteration of Yulia's proposal that tackles lazy execution and sync execution to fit into this story and I'd be more than happy to be involved in discussions here. From my perspective I don't see any frictions or concerns regarding the overall picture, short of more features just being more complexity, but I don't personally see an issue with adding complexity to the module system since it also means more control over performance and loading in the hands of users.","mimetype":"text/html"}]},"ts":1658780877987,"senderName":"guybedford","senderId":"@guybedford:matrix.org","id":"$40BYk6zAnh3rVda-AfTXACvjcDuvayaM-XDJB_FpCmc"}
]