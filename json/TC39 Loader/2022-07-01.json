[
{"content":{"body":"Caridy (and by association Daniel) have convinced me that we can use `importMeta` as in `new Module(source, importHook, importMeta)` and in `importHook(importSpecifier, importMeta)` to stand in for a “referrer” and that every host environment would still be able to emulate every other host environment. The key is that `importMeta` is object identical in these cases so can be used to carry a gensym or as a key in a WeakMap, even though it’s not identical to the `import.meta` that the evaluated module sees (unless we change that in ecma262 too!).","format":"org.matrix.custom.html","formatted_body":"Caridy (and by association Daniel) have convinced me that we can use <code>importMeta</code> as in <code>new Module(source, importHook, importMeta)</code> and in <code>importHook(importSpecifier, importMeta)</code> to stand in for a “referrer” and that every host environment would still be able to emulate every other host environment. The key is that <code>importMeta</code> is object identical in these cases so can be used to carry a gensym or as a key in a WeakMap, even though it’s not identical to the <code>import.meta</code> that the evaluated module sees (unless we change that in ecma262 too!).","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Caridy (and by association Daniel) have convinced me that we can use `importMeta` as in `new Module(source, importHook, importMeta)` and in `importHook(importSpecifier, importMeta)` to stand in for a “referrer” and that every host environment would still be able to emulate every other host environment. The key is that `importMeta` is object identical in these cases so can be used to carry a gensym or as a key in a WeakMap, even though it’s not identical to the `import.meta` that the evaluated module sees (unless we change that in ecma262 too!).","mimetype":"text/plain"},{"body":"Caridy (and by association Daniel) have convinced me that we can use <code>importMeta</code> as in <code>new Module(source, importHook, importMeta)</code> and in <code>importHook(importSpecifier, importMeta)</code> to stand in for a “referrer” and that every host environment would still be able to emulate every other host environment. The key is that <code>importMeta</code> is object identical in these cases so can be used to carry a gensym or as a key in a WeakMap, even though it’s not identical to the <code>import.meta</code> that the evaluated module sees (unless we change that in ecma262 too!).","mimetype":"text/html"}]},"ts":1656708610331,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$7KrAhrmNcmSzmEINvrXEnna_m3DDrpeVlZ8eqsstkgk"},
{"content":{"body":"Caridy and I have also come to an agreement that the next revision of the compartments proposal will reify the constructor named `Module` since we believe module harmony will likely mean `module {} instanceof Module`, where `Module(source, importHook, importMeta)` generates unlinked, linkable, initializable instances of modules.","format":"org.matrix.custom.html","formatted_body":"Caridy and I have also come to an agreement that the next revision of the compartments proposal will reify the constructor named <code>Module</code> since we believe module harmony will likely mean <code>module {} instanceof Module</code>, where <code>Module(source, importHook, importMeta)</code> generates unlinked, linkable, initializable instances of modules.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Caridy and I have also come to an agreement that the next revision of the compartments proposal will reify the constructor named `Module` since we believe module harmony will likely mean `module {} instanceof Module`, where `Module(source, importHook, importMeta)` generates unlinked, linkable, initializable instances of modules.","mimetype":"text/plain"},{"body":"Caridy and I have also come to an agreement that the next revision of the compartments proposal will reify the constructor named <code>Module</code> since we believe module harmony will likely mean <code>module {} instanceof Module</code>, where <code>Module(source, importHook, importMeta)</code> generates unlinked, linkable, initializable instances of modules.","mimetype":"text/html"}]},"ts":1656708769047,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Tb35WG2GEkccl8BpudUaP5tIRHmrGnMzc38yVt3JAfk"},
{"content":{"body":"I’ve also agreed that there’s no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \\[\\[Realm\\]\\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","format":"org.matrix.custom.html","formatted_body":"I’ve also agreed that there’s no need for the module constructor to <em>ever</em> have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified <code>new ExecutionContext()</code> that would carry new evaluators <code>eval</code>, <code>Function</code>, and <code>Module</code> bound to the same [[Realm]]. Between <code>Module</code>, <code>ModuleSource</code>, and <code>ExecutionContext</code>, we would have everything we need to build compartments in user code. We could still go on to provide a <code>Compartment</code> constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I’ve also agreed that there’s no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \\[\\[Realm\\]\\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","mimetype":"text/plain"},{"body":"I’ve also agreed that there’s no need for the module constructor to <em>ever</em> have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified <code>new ExecutionContext()</code> that would carry new evaluators <code>eval</code>, <code>Function</code>, and <code>Module</code> bound to the same [[Realm]]. Between <code>Module</code>, <code>ModuleSource</code>, and <code>ExecutionContext</code>, we would have everything we need to build compartments in user code. We could still go on to provide a <code>Compartment</code> constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","mimetype":"text/html"}]},"ts":1656708997723,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$EWYpKmkb8UT-5FeovA7RbUAkH9CZtFv-HMRv4Ge_tx4"},
{"content":{"body":" * I’ve also agreed that there’s no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \\[\\[Realm\\]\\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","format":"org.matrix.custom.html","formatted_body":" * I’ve also agreed that there’s no need for the module constructor to <em>ever</em> have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified <code>new ExecutionContext()</code> that would carry new evaluators <code>eval</code>, <code>Function</code>, and <code>Module</code> bound to the same [[Realm]]. Between <code>Module</code>, <code>ModuleSource</code>, and <code>ExecutionContext</code>, we would have everything we need to build compartments in user code. We could still go on to provide a <code>Compartment</code> constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","m.new_content":{"body":"I’ve also agreed that there’s no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \\[\\[Realm\\]\\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","format":"org.matrix.custom.html","formatted_body":"I’ve also agreed that there’s no need for the module constructor to <em>ever</em> have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified <code>new ExecutionContext()</code> that would carry new evaluators <code>eval</code>, <code>Function</code>, and <code>Module</code> bound to the same [[Realm]]. Between <code>Module</code>, <code>ModuleSource</code>, and <code>ExecutionContext</code>, we would have everything we need to build compartments in user code. We could still go on to provide a <code>Compartment</code> constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I’ve also agreed that there’s no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \\[\\[Realm\\]\\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","mimetype":"text/plain"},{"body":"I’ve also agreed that there’s no need for the module constructor to <em>ever</em> have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified <code>new ExecutionContext()</code> that would carry new evaluators <code>eval</code>, <code>Function</code>, and <code>Module</code> bound to the same [[Realm]]. Between <code>Module</code>, <code>ModuleSource</code>, and <code>ExecutionContext</code>, we would have everything we need to build compartments in user code. We could still go on to provide a <code>Compartment</code> constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$EWYpKmkb8UT-5FeovA7RbUAkH9CZtFv-HMRv4Ge_tx4","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I’ve also agreed that there’s no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \\[\\[Realm\\]\\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","mimetype":"text/plain"},{"body":" * I’ve also agreed that there’s no need for the module constructor to <em>ever</em> have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified <code>new ExecutionContext()</code> that would carry new evaluators <code>eval</code>, <code>Function</code>, and <code>Module</code> bound to the same [[Realm]]. Between <code>Module</code>, <code>ModuleSource</code>, and <code>ExecutionContext</code>, we would have everything we need to build compartments in user code. We could still go on to provide a <code>Compartment</code> constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.","mimetype":"text/html"}]},"ts":1656709081090,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$vnbj2w8w1mXD-POvCB1GZDGI5ElL0oNABLFmyXGheL0"},
{"content":{"body":"I’ve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the `Module` and `ModuleSource` primitives.","format":"org.matrix.custom.html","formatted_body":"I’ve also convinced myself that, if module instances locally memoize the results of their <code>importHook</code> for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the <code>Module</code> and <code>ModuleSource</code> primitives.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I’ve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the `Module` and `ModuleSource` primitives.","mimetype":"text/plain"},{"body":"I’ve also convinced myself that, if module instances locally memoize the results of their <code>importHook</code> for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the <code>Module</code> and <code>ModuleSource</code> primitives.","mimetype":"text/html"}]},"ts":1656709833757,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$OT-NSjlDSmwtYppSVEOQihPxMlPcHNLi2MIYV6iQ8U4"},
{"content":{"body":" * I’ve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the `Module` and `ModuleSource` primitives.","format":"org.matrix.custom.html","formatted_body":" * I’ve also convinced myself that, if module instances locally memoize the results of their <code>importHook</code> for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the <code>Module</code> and <code>ModuleSource</code> primitives.","m.new_content":{"body":"I’ve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the `Module` and `ModuleSource` primitives.","format":"org.matrix.custom.html","formatted_body":"I’ve also convinced myself that, if module instances locally memoize the results of their <code>importHook</code> for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the <code>Module</code> and <code>ModuleSource</code> primitives.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I’ve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the `Module` and `ModuleSource` primitives.","mimetype":"text/plain"},{"body":"I’ve also convinced myself that, if module instances locally memoize the results of their <code>importHook</code> for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the <code>Module</code> and <code>ModuleSource</code> primitives.","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$OT-NSjlDSmwtYppSVEOQihPxMlPcHNLi2MIYV6iQ8U4","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * I’ve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the `Module` and `ModuleSource` primitives.","mimetype":"text/plain"},{"body":" * I’ve also convinced myself that, if module instances locally memoize the results of their <code>importHook</code> for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn’t have both in the fullness of time, but I’m convinced we should focus on the <code>Module</code> and <code>ModuleSource</code> primitives.","mimetype":"text/html"}]},"ts":1656709923687,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$arghRC0b81E8_cI8UFwYAly1zC9iN3FWShLc8twAuEs"},
{"content":{"body":"I also believe that there is no better contender for the enormously self-assured name `Module`. My expectation is that `Module` will be backed by the Last Module Record type we ever need and that all meaningful extensions to the module system are different kinds of module source, not new kinds of module instance.","format":"org.matrix.custom.html","formatted_body":"I also believe that there is no better contender for the enormously self-assured name <code>Module</code>. My expectation is that <code>Module</code> will be backed by the Last Module Record type we ever need and that all meaningful extensions to the module system are different kinds of module source, not new kinds of module instance.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I also believe that there is no better contender for the enormously self-assured name `Module`. My expectation is that `Module` will be backed by the Last Module Record type we ever need and that all meaningful extensions to the module system are different kinds of module source, not new kinds of module instance.","mimetype":"text/plain"},{"body":"I also believe that there is no better contender for the enormously self-assured name <code>Module</code>. My expectation is that <code>Module</code> will be backed by the Last Module Record type we ever need and that all meaningful extensions to the module system are different kinds of module source, not new kinds of module instance.","mimetype":"text/html"}]},"ts":1656710024585,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$EAASO0PFgyKFFDe5ZNTUJzWCUIpscCGirOAHr06PmQ4"},
{"content":{"body":"Caridy is focusing on a minimal layer that achieves parity with the current behaviors of ecma262, just reifying these two functions. I propose, in addition, that the `Module` constructor receives a ***Module Source Protocol*** implementation object, like `{bindings?, initialize?, needsDynamicImport?, needsImportMeta?}` which instances of `ModuleSource` happen to provide. This would be sufficient to define JSON, CommonJS, WASM, &c module sources in user code. However, that protocol would not be adequate to carry CSP information for vetted module sources and would not preclude the introduction of other host-defined module source classes. I expect only host-defined module source classes would be transmissible via structured clone and cary host-vetted origin metadata.","format":"org.matrix.custom.html","formatted_body":"Caridy is focusing on a minimal layer that achieves parity with the current behaviors of ecma262, just reifying these two functions. I propose, in addition, that the <code>Module</code> constructor receives a <em><strong>Module Source Protocol</strong></em> implementation object, like <code>{bindings?, initialize?, needsDynamicImport?, needsImportMeta?}</code> which instances of <code>ModuleSource</code> happen to provide. This would be sufficient to define JSON, CommonJS, WASM, &amp;c module sources in user code. However, that protocol would not be adequate to carry CSP information for vetted module sources and would not preclude the introduction of other host-defined module source classes. I expect only host-defined module source classes would be transmissible via structured clone and cary host-vetted origin metadata.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Caridy is focusing on a minimal layer that achieves parity with the current behaviors of ecma262, just reifying these two functions. I propose, in addition, that the `Module` constructor receives a ***Module Source Protocol*** implementation object, like `{bindings?, initialize?, needsDynamicImport?, needsImportMeta?}` which instances of `ModuleSource` happen to provide. This would be sufficient to define JSON, CommonJS, WASM, &c module sources in user code. However, that protocol would not be adequate to carry CSP information for vetted module sources and would not preclude the introduction of other host-defined module source classes. I expect only host-defined module source classes would be transmissible via structured clone and cary host-vetted origin metadata.","mimetype":"text/plain"},{"body":"Caridy is focusing on a minimal layer that achieves parity with the current behaviors of ecma262, just reifying these two functions. I propose, in addition, that the <code>Module</code> constructor receives a <em><strong>Module Source Protocol</strong></em> implementation object, like <code>{bindings?, initialize?, needsDynamicImport?, needsImportMeta?}</code> which instances of <code>ModuleSource</code> happen to provide. This would be sufficient to define JSON, CommonJS, WASM, &amp;c module sources in user code. However, that protocol would not be adequate to carry CSP information for vetted module sources and would not preclude the introduction of other host-defined module source classes. I expect only host-defined module source classes would be transmissible via structured clone and cary host-vetted origin metadata.","mimetype":"text/html"}]},"ts":1656710343641,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$GpJPbyDaYRXWNFOaJSM8JBVzQArOd-UIWq_itVcYTRo"},
{"content":{"body":"I’ve also been convinced that the first argument to `initialize` should be called a ***Module Imports Namespace Exotic Object*** (not a reification of the entire definition of ***Module Environment Record***, just an exotic object that can be used to get and set the import and export bindings of the module, in its internal namespace.","format":"org.matrix.custom.html","formatted_body":"I’ve also been convinced that the first argument to <code>initialize</code> should be called a <em><strong>Module Imports Namespace Exotic Object</strong></em> (not a reification of the entire definition of <em><strong>Module Environment Record</strong></em>, just an exotic object that can be used to get and set the import and export bindings of the module, in its internal namespace.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I’ve also been convinced that the first argument to `initialize` should be called a ***Module Imports Namespace Exotic Object*** (not a reification of the entire definition of ***Module Environment Record***, just an exotic object that can be used to get and set the import and export bindings of the module, in its internal namespace.","mimetype":"text/plain"},{"body":"I’ve also been convinced that the first argument to <code>initialize</code> should be called a <em><strong>Module Imports Namespace Exotic Object</strong></em> (not a reification of the entire definition of <em><strong>Module Environment Record</strong></em>, just an exotic object that can be used to get and set the import and export bindings of the module, in its internal namespace.","mimetype":"text/html"}]},"ts":1656710484122,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$ftHF5AaXhHpYgCAvbrw39-DdN2WaI8yMgjiDesQooKM"}
]