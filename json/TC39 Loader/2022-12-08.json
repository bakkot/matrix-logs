[
{"content":{"body":"👋 just discussed module reflection, lazy, and import assertions with my team","msgtype":"m.text","org.matrix.msc1767.text":"👋 just discussed module reflection, lazy, and import assertions with my team"},"ts":1670521236256,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$I5EqHRdkEl0Vj3boWgrqhoiloy205STQcsl98iq4J-Y"},
{"content":{"body":"A few notes we have:\n- the `import module` syntax is acceptable if we can't move this into the assertions\n- If we do move into assertions, we really should rename `assert` (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)\n- If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of `import(\"\", { assert: { key: value } })`, just make it `import(\"\", { key: value })`\n- The `module` in `import module` is confusingly named, I'm already importing from ES modules","format":"org.matrix.custom.html","formatted_body":"<p>A few notes we have:</p>\n<ul>\n<li>the <code>import module</code> syntax is acceptable if we can't move this into the assertions</li>\n<li>If we do move into assertions, we really should rename <code>assert</code> (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)</li>\n<li>If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of <code>import(&quot;&quot;, { assert: { key: value } })</code>, just make it <code>import(&quot;&quot;, { key: value })</code></li>\n<li>The <code>module</code> in <code>import module</code> is confusingly named, I'm already importing from ES modules</li>\n</ul>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"A few notes we have:\n- the `import module` syntax is acceptable if we can't move this into the assertions\n- If we do move into assertions, we really should rename `assert` (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)\n- If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of `import(\"\", { assert: { key: value } })`, just make it `import(\"\", { key: value })`\n- The `module` in `import module` is confusingly named, I'm already importing from ES modules","mimetype":"text/plain"},{"body":"<p>A few notes we have:</p>\n<ul>\n<li>the <code>import module</code> syntax is acceptable if we can't move this into the assertions</li>\n<li>If we do move into assertions, we really should rename <code>assert</code> (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)</li>\n<li>If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of <code>import(&quot;&quot;, { assert: { key: value } })</code>, just make it <code>import(&quot;&quot;, { key: value })</code></li>\n<li>The <code>module</code> in <code>import module</code> is confusingly named, I'm already importing from ES modules</li>\n</ul>\n","mimetype":"text/html"}]},"ts":1670521399609,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$rIN_CHIIyfFeET-WgtRZzjEweGN-2K0nLRzSxpYsoas"},
{"content":{"body":"So I'm not blocking import reflection anymore, but would still very much like to move it into assertions","msgtype":"m.text","org.matrix.msc1767.text":"So I'm not blocking import reflection anymore, but would still very much like to move it into assertions"},"ts":1670521434882,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$XK6VqDYE84b8kIO_hWp3Lb4ebSep6Sh-09Kv84ME_uk"},
{"content":{"body":" * So I'm not going to lone block import reflection anymore, but would still very much like to move it into assertions","m.new_content":{"body":"So I'm not going to lone block import reflection anymore, but would still very much like to move it into assertions","msgtype":"m.text","org.matrix.msc1767.text":"So I'm not going to lone block import reflection anymore, but would still very much like to move it into assertions"},"m.relates_to":{"event_id":"$XK6VqDYE84b8kIO_hWp3Lb4ebSep6Sh-09Kv84ME_uk","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * So I'm not going to lone block import reflection anymore, but would still very much like to move it into assertions"},"ts":1670522074826,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$qp2ivFNukXxsj0USSWumHbhg1yC1SO0dwmy3Kv-qfrc"},
{"content":{"body":"At this point, I’m in favor of changing the shape of import reflection to `import example from 'example.com' with { type: 'e.g.,destination' }` and `import('example.com', { type: 'e.g.,destination' })`.\n\nIf our constituents demand that the `type` string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the `type` must be threaded thru `importHook`. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the `type` can be ignored and the response content-type dictates what kind of module source it will produce.\n\nI will be difficult to convince that the `with` parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like `reflect`, `lazy`, `phase` or so on, with behaviors that can’t be emulated by an `importHook`.","format":"org.matrix.custom.html","formatted_body":"<p>At this point, I’m in favor of changing the shape of import reflection to <code>import example from 'example.com' with { type: 'e.g.,destination' }</code> and <code>import('example.com', { type: 'e.g.,destination' })</code>.</p>\n<p>If our constituents demand that the <code>type</code> string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the <code>type</code> must be threaded thru <code>importHook</code>. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the <code>type</code> can be ignored and the response content-type dictates what kind of module source it will produce.</p>\n<p>I will be difficult to convince that the <code>with</code> parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like <code>reflect</code>, <code>lazy</code>, <code>phase</code> or so on, with behaviors that can’t be emulated by an <code>importHook</code>.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"At this point, I’m in favor of changing the shape of import reflection to `import example from 'example.com' with { type: 'e.g.,destination' }` and `import('example.com', { type: 'e.g.,destination' })`.\n\nIf our constituents demand that the `type` string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the `type` must be threaded thru `importHook`. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the `type` can be ignored and the response content-type dictates what kind of module source it will produce.\n\nI will be difficult to convince that the `with` parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like `reflect`, `lazy`, `phase` or so on, with behaviors that can’t be emulated by an `importHook`.","mimetype":"text/plain"},{"body":"<p>At this point, I’m in favor of changing the shape of import reflection to <code>import example from 'example.com' with { type: 'e.g.,destination' }</code> and <code>import('example.com', { type: 'e.g.,destination' })</code>.</p>\n<p>If our constituents demand that the <code>type</code> string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the <code>type</code> must be threaded thru <code>importHook</code>. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the <code>type</code> can be ignored and the response content-type dictates what kind of module source it will produce.</p>\n<p>I will be difficult to convince that the <code>with</code> parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like <code>reflect</code>, <code>lazy</code>, <code>phase</code> or so on, with behaviors that can’t be emulated by an <code>importHook</code>.</p>\n","mimetype":"text/html"}]},"ts":1670522083815,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$fxvS0GGt33c1O7FfX2pkRqqo_cGL7fKlbD-5HuQR2CY"},
{"content":{"body":" * A few notes we have:\n\n- the `import module` syntax is acceptable if we can't move this into the assertions\n- If we do move into assertions, we really should rename `assert` (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)\n- If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of `import(\"\", { assert: { key: value } })`, just make it `import(\"\", { key: value })`)\n- The `module` in `import module` is confusingly named, I'm already importing from ES modules","format":"org.matrix.custom.html","formatted_body":" * <p>A few notes we have:</p>\n<ul>\n<li>the <code>import module</code> syntax is acceptable if we can't move this into the assertions</li>\n<li>If we do move into assertions, we really should rename <code>assert</code> (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)</li>\n<li>If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of <code>import(&quot;&quot;, { assert: { key: value } })</code>, just make it <code>import(&quot;&quot;, { key: value })</code>)</li>\n<li>The <code>module</code> in <code>import module</code> is confusingly named, I'm already importing from ES modules</li>\n</ul>\n","m.new_content":{"body":"A few notes we have:\n\n- the `import module` syntax is acceptable if we can't move this into the assertions\n- If we do move into assertions, we really should rename `assert` (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)\n- If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of `import(\"\", { assert: { key: value } })`, just make it `import(\"\", { key: value })`)\n- The `module` in `import module` is confusingly named, I'm already importing from ES modules","format":"org.matrix.custom.html","formatted_body":"<p>A few notes we have:</p>\n<ul>\n<li>the <code>import module</code> syntax is acceptable if we can't move this into the assertions</li>\n<li>If we do move into assertions, we really should rename <code>assert</code> (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)</li>\n<li>If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of <code>import(&quot;&quot;, { assert: { key: value } })</code>, just make it <code>import(&quot;&quot;, { key: value })</code>)</li>\n<li>The <code>module</code> in <code>import module</code> is confusingly named, I'm already importing from ES modules</li>\n</ul>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"A few notes we have:\n\n- the `import module` syntax is acceptable if we can't move this into the assertions\n- If we do move into assertions, we really should rename `assert` (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)\n- If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of `import(\"\", { assert: { key: value } })`, just make it `import(\"\", { key: value })`)\n- The `module` in `import module` is confusingly named, I'm already importing from ES modules","mimetype":"text/plain"},{"body":"<p>A few notes we have:</p>\n<ul>\n<li>the <code>import module</code> syntax is acceptable if we can't move this into the assertions</li>\n<li>If we do move into assertions, we really should rename <code>assert</code> (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)</li>\n<li>If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of <code>import(&quot;&quot;, { assert: { key: value } })</code>, just make it <code>import(&quot;&quot;, { key: value })</code>)</li>\n<li>The <code>module</code> in <code>import module</code> is confusingly named, I'm already importing from ES modules</li>\n</ul>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$rIN_CHIIyfFeET-WgtRZzjEweGN-2K0nLRzSxpYsoas","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * A few notes we have:\n\n- the `import module` syntax is acceptable if we can't move this into the assertions\n- If we do move into assertions, we really should rename `assert` (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)\n- If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of `import(\"\", { assert: { key: value } })`, just make it `import(\"\", { key: value })`)\n- The `module` in `import module` is confusingly named, I'm already importing from ES modules","mimetype":"text/plain"},{"body":" * <p>A few notes we have:</p>\n<ul>\n<li>the <code>import module</code> syntax is acceptable if we can't move this into the assertions</li>\n<li>If we do move into assertions, we really should rename <code>assert</code> (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)</li>\n<li>If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of <code>import(&quot;&quot;, { assert: { key: value } })</code>, just make it <code>import(&quot;&quot;, { key: value })</code>)</li>\n<li>The <code>module</code> in <code>import module</code> is confusingly named, I'm already importing from ES modules</li>\n</ul>\n","mimetype":"text/html"}]},"ts":1670522087273,"senderName":"Justin Ridgewell","senderId":"@jridgewell:matrix.org","id":"$UM2Il1p321NHMBRJt6IrGNFkCSruC5g__WU4ROE5__8"},
{"content":{"body":" * At this point, I’m in favor of changing the shape of import reflection to `import example from 'example.com' with { reflect: true }` and `import('example', { reflect: true })`, which would imply import assertions would look like `import example from 'example.com' with { type: 'e.g.,destination' }` and `import('example.com', { type: 'e.g.,destination' })`.\n\nIf our constituents demand that the `type` string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the `type` must be threaded thru `importHook`. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the `type` can be ignored and the response content-type dictates what kind of module source it will produce.\n\nI will be difficult to convince that the `with` parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like `reflect`, `lazy`, `phase` or so on, with behaviors that can’t be emulated by an `importHook`.","format":"org.matrix.custom.html","formatted_body":" * <p>At this point, I’m in favor of changing the shape of import reflection to <code>import example from 'example.com' with { reflect: true }</code> and <code>import('example', { reflect: true })</code>, which would imply import assertions would look like <code>import example from 'example.com' with { type: 'e.g.,destination' }</code> and <code>import('example.com', { type: 'e.g.,destination' })</code>.</p>\n<p>If our constituents demand that the <code>type</code> string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the <code>type</code> must be threaded thru <code>importHook</code>. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the <code>type</code> can be ignored and the response content-type dictates what kind of module source it will produce.</p>\n<p>I will be difficult to convince that the <code>with</code> parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like <code>reflect</code>, <code>lazy</code>, <code>phase</code> or so on, with behaviors that can’t be emulated by an <code>importHook</code>.</p>\n","m.new_content":{"body":"At this point, I’m in favor of changing the shape of import reflection to `import example from 'example.com' with { reflect: true }` and `import('example', { reflect: true })`, which would imply import assertions would look like `import example from 'example.com' with { type: 'e.g.,destination' }` and `import('example.com', { type: 'e.g.,destination' })`.\n\nIf our constituents demand that the `type` string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the `type` must be threaded thru `importHook`. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the `type` can be ignored and the response content-type dictates what kind of module source it will produce.\n\nI will be difficult to convince that the `with` parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like `reflect`, `lazy`, `phase` or so on, with behaviors that can’t be emulated by an `importHook`.","format":"org.matrix.custom.html","formatted_body":"<p>At this point, I’m in favor of changing the shape of import reflection to <code>import example from 'example.com' with { reflect: true }</code> and <code>import('example', { reflect: true })</code>, which would imply import assertions would look like <code>import example from 'example.com' with { type: 'e.g.,destination' }</code> and <code>import('example.com', { type: 'e.g.,destination' })</code>.</p>\n<p>If our constituents demand that the <code>type</code> string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the <code>type</code> must be threaded thru <code>importHook</code>. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the <code>type</code> can be ignored and the response content-type dictates what kind of module source it will produce.</p>\n<p>I will be difficult to convince that the <code>with</code> parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like <code>reflect</code>, <code>lazy</code>, <code>phase</code> or so on, with behaviors that can’t be emulated by an <code>importHook</code>.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"At this point, I’m in favor of changing the shape of import reflection to `import example from 'example.com' with { reflect: true }` and `import('example', { reflect: true })`, which would imply import assertions would look like `import example from 'example.com' with { type: 'e.g.,destination' }` and `import('example.com', { type: 'e.g.,destination' })`.\n\nIf our constituents demand that the `type` string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the `type` must be threaded thru `importHook`. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the `type` can be ignored and the response content-type dictates what kind of module source it will produce.\n\nI will be difficult to convince that the `with` parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like `reflect`, `lazy`, `phase` or so on, with behaviors that can’t be emulated by an `importHook`.","mimetype":"text/plain"},{"body":"<p>At this point, I’m in favor of changing the shape of import reflection to <code>import example from 'example.com' with { reflect: true }</code> and <code>import('example', { reflect: true })</code>, which would imply import assertions would look like <code>import example from 'example.com' with { type: 'e.g.,destination' }</code> and <code>import('example.com', { type: 'e.g.,destination' })</code>.</p>\n<p>If our constituents demand that the <code>type</code> string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the <code>type</code> must be threaded thru <code>importHook</code>. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the <code>type</code> can be ignored and the response content-type dictates what kind of module source it will produce.</p>\n<p>I will be difficult to convince that the <code>with</code> parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like <code>reflect</code>, <code>lazy</code>, <code>phase</code> or so on, with behaviors that can’t be emulated by an <code>importHook</code>.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$fxvS0GGt33c1O7FfX2pkRqqo_cGL7fKlbD-5HuQR2CY","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * At this point, I’m in favor of changing the shape of import reflection to `import example from 'example.com' with { reflect: true }` and `import('example', { reflect: true })`, which would imply import assertions would look like `import example from 'example.com' with { type: 'e.g.,destination' }` and `import('example.com', { type: 'e.g.,destination' })`.\n\nIf our constituents demand that the `type` string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the `type` must be threaded thru `importHook`. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the `type` can be ignored and the response content-type dictates what kind of module source it will produce.\n\nI will be difficult to convince that the `with` parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like `reflect`, `lazy`, `phase` or so on, with behaviors that can’t be emulated by an `importHook`.","mimetype":"text/plain"},{"body":" * <p>At this point, I’m in favor of changing the shape of import reflection to <code>import example from 'example.com' with { reflect: true }</code> and <code>import('example', { reflect: true })</code>, which would imply import assertions would look like <code>import example from 'example.com' with { type: 'e.g.,destination' }</code> and <code>import('example.com', { type: 'e.g.,destination' })</code>.</p>\n<p>If our constituents demand that the <code>type</code> string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the <code>type</code> must be threaded thru <code>importHook</code>. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the <code>type</code> can be ignored and the response content-type dictates what kind of module source it will produce.</p>\n<p>I will be difficult to convince that the <code>with</code> parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like <code>reflect</code>, <code>lazy</code>, <code>phase</code> or so on, with behaviors that can’t be emulated by an <code>importHook</code>.</p>\n","mimetype":"text/html"}]},"ts":1670522159634,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$IdmKzd-5JPrIum-aeG7T0bndMoJTNOZ67JUERxK4Y4c"},
{"content":{"body":"My opinion shifted in that direction because our SES shim for “hardened JavaScript” censors dynamic import to deny guest programs an escape hatch, and for that to continue being effective going forward, `import.module`, `import.reflect`, or `import.anything` would be problematic. I don’t expect that argument to convince anyone else that we should funnel reflection through dynamic import, but I also don’t expect anyone else to need to be convinced!","format":"org.matrix.custom.html","formatted_body":"My opinion shifted in that direction because our SES shim for “hardened JavaScript” censors dynamic import to deny guest programs an escape hatch, and for that to continue being effective going forward, <code>import.module</code>, <code>import.reflect</code>, or <code>import.anything</code> would be problematic. I don’t expect that argument to convince anyone else that we should funnel reflection through dynamic import, but I also don’t expect anyone else to need to be convinced!","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"My opinion shifted in that direction because our SES shim for “hardened JavaScript” censors dynamic import to deny guest programs an escape hatch, and for that to continue being effective going forward, `import.module`, `import.reflect`, or `import.anything` would be problematic. I don’t expect that argument to convince anyone else that we should funnel reflection through dynamic import, but I also don’t expect anyone else to need to be convinced!","mimetype":"text/plain"},{"body":"My opinion shifted in that direction because our SES shim for “hardened JavaScript” censors dynamic import to deny guest programs an escape hatch, and for that to continue being effective going forward, <code>import.module</code>, <code>import.reflect</code>, or <code>import.anything</code> would be problematic. I don’t expect that argument to convince anyone else that we should funnel reflection through dynamic import, but I also don’t expect anyone else to need to be convinced!","mimetype":"text/html"}]},"ts":1670522272940,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$c3n4HVTDGySz5gHOGuhgnfs1DOzG168Ubrf74m4SPBw"}
]