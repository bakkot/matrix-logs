[
{"content":{"body":"> <@kriskowal:matrix.org> nicolo-ribaudo: Caridy is working on First-class Modules spec text. It might be good for you to connect.\n\nAwesome! This week I started refactoring the `HostResolveImportedModule` and `HostImportModuleDynamically` host hooks, because I didn't want to go through host-defined behavior when importing module blocks/fragments (until they import external modules).\n\nI now have a single `HostLoadImportedModule` hook, used both for static and dynamic imports, that \"returns\" an unlinked Module Record. ECMA-262 takes care of iterating through its dependencies, and it recursively calls `HostLoadImportedModule` to visit the whole graph (cc guybedford: this matches your intuition in https://github.com/tc39/proposal-js-module-blocks/pull/65#discussion_r912412376 !).\n\nThis is my proposed refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/\nIf you are curious, this is how the module blocks spec looks like on top of that refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/proposals/module-blocks - the updates to `import()` are relevant for \"layer 0\", because they show how to import a \"module object\".\n\nI believe that the new logic closely resembles the loading logic introduced by \"layer 0\": we could probably just add a step tocheck to 2.d.ii of InnerModuleLoading that calls a `module.[[ImportHook]]` function, rather than always delegating to `HostLoadImportedModule`.\n\nIt would probably also help with module reflection: assuming that `WebAssembly.Module` will be a module source, the proposal could use `HostLoadImportedModule(...).[[ModuleSource]]` instead of introducing a new `HostResolveModuleReflection` AO. This would also guarantee that `import module x from \"x.wasm\"` and `import * as ns from \"x.wasm\"` import the same module, even if they do two different things with it (probably we could guarantee `ns === await import(x)`).\n\nI would love to hear your thoughts on this ðŸ™‚","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$LluC8fhPVyXxFx_Dzey8SuoVh5qBKmsKBVc6mqvaFjo?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br><a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a>: Caridy is working on First-class Modules spec text. It might be good for you to connect.</blockquote></mx-reply><p>Awesome! This week I started refactoring the <code>HostResolveImportedModule</code> and <code>HostImportModuleDynamically</code> host hooks, because I didn't want to go through host-defined behavior when importing module blocks/fragments (until they import external modules).</p>\n<p>I now have a single <code>HostLoadImportedModule</code> hook, used both for static and dynamic imports, that &quot;returns&quot; an unlinked Module Record. ECMA-262 takes care of iterating through its dependencies, and it recursively calls <code>HostLoadImportedModule</code> to visit the whole graph (cc <a href=\"https://matrix.to/#/@guybedford:matrix.org\">guybedford</a>: this matches your intuition in https://github.com/tc39/proposal-js-module-blocks/pull/65#discussion_r912412376 !).</p>\n<p>This is my proposed refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/<br>If you are curious, this is how the module blocks spec looks like on top of that refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/proposals/module-blocks - the updates to <code>import()</code> are relevant for &quot;layer 0&quot;, because they show how to import a &quot;module object&quot;.</p>\n<p>I believe that the new logic closely resembles the loading logic introduced by &quot;layer 0&quot;: we could probably just add a step tocheck to 2.d.ii of InnerModuleLoading that calls a <code>module.[[ImportHook]]</code> function, rather than always delegating to <code>HostLoadImportedModule</code>.</p>\n<p>It would probably also help with module reflection: assuming that <code>WebAssembly.Module</code> will be a module source, the proposal could use <code>HostLoadImportedModule(...).[[ModuleSource]]</code> instead of introducing a new <code>HostResolveModuleReflection</code> AO. This would also guarantee that <code>import module x from &quot;x.wasm&quot;</code> and <code>import * as ns from &quot;x.wasm&quot;</code> import the same module, even if they do two different things with it (probably we could guarantee <code>ns === await import(x)</code>).</p>\n<p>I would love to hear your thoughts on this ðŸ™‚</p>\n","m.relates_to":{"m.in_reply_to":{"event_id":"$LluC8fhPVyXxFx_Dzey8SuoVh5qBKmsKBVc6mqvaFjo"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@kriskowal:matrix.org> nicolo-ribaudo: Caridy is working on First-class Modules spec text. It might be good for you to connect.\n\nAwesome! This week I started refactoring the `HostResolveImportedModule` and `HostImportModuleDynamically` host hooks, because I didn't want to go through host-defined behavior when importing module blocks/fragments (until they import external modules).\n\nI now have a single `HostLoadImportedModule` hook, used both for static and dynamic imports, that \"returns\" an unlinked Module Record. ECMA-262 takes care of iterating through its dependencies, and it recursively calls `HostLoadImportedModule` to visit the whole graph (cc guybedford: this matches your intuition in https://github.com/tc39/proposal-js-module-blocks/pull/65#discussion_r912412376 !).\n\nThis is my proposed refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/\nIf you are curious, this is how the module blocks spec looks like on top of that refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/proposals/module-blocks - the updates to `import()` are relevant for \"layer 0\", because they show how to import a \"module object\".\n\nI believe that the new logic closely resembles the loading logic introduced by \"layer 0\": we could probably just add a step tocheck to 2.d.ii of InnerModuleLoading that calls a `module.[[ImportHook]]` function, rather than always delegating to `HostLoadImportedModule`.\n\nIt would probably also help with module reflection: assuming that `WebAssembly.Module` will be a module source, the proposal could use `HostLoadImportedModule(...).[[ModuleSource]]` instead of introducing a new `HostResolveModuleReflection` AO. This would also guarantee that `import module x from \"x.wasm\"` and `import * as ns from \"x.wasm\"` import the same module, even if they do two different things with it (probably we could guarantee `ns === await import(x)`).\n\nI would love to hear your thoughts on this ðŸ™‚","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$LluC8fhPVyXxFx_Dzey8SuoVh5qBKmsKBVc6mqvaFjo?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br><a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a>: Caridy is working on First-class Modules spec text. It might be good for you to connect.</blockquote></mx-reply><p>Awesome! This week I started refactoring the <code>HostResolveImportedModule</code> and <code>HostImportModuleDynamically</code> host hooks, because I didn't want to go through host-defined behavior when importing module blocks/fragments (until they import external modules).</p>\n<p>I now have a single <code>HostLoadImportedModule</code> hook, used both for static and dynamic imports, that &quot;returns&quot; an unlinked Module Record. ECMA-262 takes care of iterating through its dependencies, and it recursively calls <code>HostLoadImportedModule</code> to visit the whole graph (cc <a href=\"https://matrix.to/#/@guybedford:matrix.org\">guybedford</a>: this matches your intuition in https://github.com/tc39/proposal-js-module-blocks/pull/65#discussion_r912412376 !).</p>\n<p>This is my proposed refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/<br>If you are curious, this is how the module blocks spec looks like on top of that refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/proposals/module-blocks - the updates to <code>import()</code> are relevant for &quot;layer 0&quot;, because they show how to import a &quot;module object&quot;.</p>\n<p>I believe that the new logic closely resembles the loading logic introduced by &quot;layer 0&quot;: we could probably just add a step tocheck to 2.d.ii of InnerModuleLoading that calls a <code>module.[[ImportHook]]</code> function, rather than always delegating to <code>HostLoadImportedModule</code>.</p>\n<p>It would probably also help with module reflection: assuming that <code>WebAssembly.Module</code> will be a module source, the proposal could use <code>HostLoadImportedModule(...).[[ModuleSource]]</code> instead of introducing a new <code>HostResolveModuleReflection</code> AO. This would also guarantee that <code>import module x from &quot;x.wasm&quot;</code> and <code>import * as ns from &quot;x.wasm&quot;</code> import the same module, even if they do two different things with it (probably we could guarantee <code>ns === await import(x)</code>).</p>\n<p>I would love to hear your thoughts on this ðŸ™‚</p>\n","mimetype":"text/html"}]},"ts":1658537358726,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$mFqfqL9OKNmIH37LJ52jyAGqthTiyLB9WBkwTg7a38w"},
{"content":{"body":"Your description matches my intuition.","msgtype":"m.text","org.matrix.msc1767.text":"Your description matches my intuition."},"ts":1658537585179,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$qQvgKQ4tvY1ix6-8R7D2AiIcDdJ8_1u9PiKKDNiRMQY"},
{"content":{"body":"Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule.","msgtype":"m.text","org.matrix.msc1767.text":"Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule."},"ts":1658537660093,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$5pfABOWvzTwKw37nSA-V2fi8C7-zj9ypBD4otKlpRkk"},
{"content":{"body":"I reviewed this refactor earlier today and it looks great to me.","msgtype":"m.text"},"ts":1658537707149,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$gentvATL7hsb1WPSJcCSd2wSGnKad7pEJy0wG1zcZwI"},
{"content":{"body":"And I think this generally closes the gap with Caridyâ€™s upcoming changes, which had no reasonable default importHook.","msgtype":"m.text","org.matrix.msc1767.text":"And I think this generally closes the gap with Caridyâ€™s upcoming changes, which had no reasonable default importHook."},"ts":1658537722182,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Qu7DMTZqxEF9osf7XdAcf-wy4404ZWv2qVao1LJrIrY"},
{"content":{"body":"This refactor is great because it makes it clear exactly where importHook is called; it is not too often as currently ","format":"org.matrix.custom.html","formatted_body":"This refactor is great because it makes it clear exactly where importHook is called; it is not too often as currently","msgtype":"m.text"},"ts":1658537937680,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$kCweZQHdtFHsoXPRpgLC0rLG-67yo7hHVoM7flSwx5Y"},
{"content":{"body":"IMO it would make sense to land separately in HTML and JS already, since it is a significant cleanup, or at least put out for review as a separated item","msgtype":"m.text"},"ts":1658538004773,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$fE-j4ljflhthkUaDowdguYk5QB-mV_70AVOJiU1nIsk"}
]