[
{"content":{"body":"Caridy and I had a conversation about paring down the compartments/loader proposal to avoid having to specify any maps at all, to avoid mentioning referrer specifiers at all, to further slim its profile against the wind.","msgtype":"m.text","org.matrix.msc1767.text":"Caridy and I had a conversation about paring down the compartments/loader proposal to avoid having to specify any maps at all, to avoid mentioning referrer specifiers at all, to further slim its profile against the wind."},"ts":1656340818182,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$U0GCag7WBGMK1GlfF-nR6cqsmDbyVhYGRwgsO_6D_o8"},
{"content":{"body":"The thought experiment is to return to the proposal Guy and Luca made at plenary and ask more questions.","msgtype":"m.text","org.matrix.msc1767.text":"The thought experiment is to return to the proposal Guy and Luca made at plenary and ask more questions."},"ts":1656340855905,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$A1CqkN6sMC7bP3LWG9QtjANErThpPn_QHaxhRe9v4L8"},
{"content":{"body":"Suppose new ModuleSource(source) and new ModuleInstance(source, importHook, importMeta?)","msgtype":"m.text","org.matrix.msc1767.text":"Suppose new ModuleSource(source) and new ModuleInstance(source, importHook, importMeta?)"},"ts":1656340880515,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$zi7EKsoRORZxjDJ-d9Wm3Qcn4HcIhfHVhK9QRcG_Lx4"},
{"content":{"body":"Such that source.bindings reflects imports/exports and instance.source refers to the original source.","msgtype":"m.text","org.matrix.msc1767.text":"Such that source.bindings reflects imports/exports and instance.source refers to the original source."},"ts":1656340902859,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$bVUtxehF_AB5e_xY8nJeH_vbdxe4B0-a9vKH4HmIWE0"},
{"content":{"body":"Suppose also that import reflection gives us the means to obtain either of these through syntax. Recursively, that would mean that ModuleInstances and ModuleSources could be drawn out of ModuleInstance hooks.","msgtype":"m.text","org.matrix.msc1767.text":"Suppose also that import reflection gives us the means to obtain either of these through syntax. Recursively, that would mean that ModuleInstances and ModuleSources could be drawn out of ModuleInstance hooks."},"ts":1656341058057,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$HLGXa1mJKsVdN6KWml6wBdV4nj6r88AD_wPBEujn3xY"},
{"content":{"body":"Also, supposing that importHook’s signature is importHook(importSpecifier, moduleInstance), such that there is no referrer, but the importHook can associate instances with referrers and do whatever it must internally.","msgtype":"m.text","org.matrix.msc1767.text":"Also, supposing that importHook’s signature is importHook(importSpecifier, moduleInstance), such that there is no referrer, but the importHook can associate instances with referrers and do whatever it must internally."},"ts":1656341108029,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$oZjjQuqGjk60BoKnFAQ7SCacjaw1-SiUk9GFko8uZ0k"},
{"content":{"body":"Caridy also proposes that we use dynamic import in the same way as blocks.","msgtype":"m.text","org.matrix.msc1767.text":"Caridy also proposes that we use dynamic import in the same way as blocks."},"ts":1656341129986,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$J6gesk7hUws2DJjmLscfT1M7_osqiFlo7svtCF2KDuc"},
{"content":{"body":"Which is to say, in this thought experiment, ModuleInstance corresponds to module {}","msgtype":"m.text","org.matrix.msc1767.text":"Which is to say, in this thought experiment, ModuleInstance corresponds to module {}"},"ts":1656341144703,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$5ehEvhN7a0btHwX2JgSuvnpTkvVVuXZY8cseb05Mn5A"},
{"content":{"body":"With that in mind, it’s sufficient to have a module instance to get the underlying unhooked Module Source, like (module {}).source, but Caridy suggests that would potentially mean the creation of throw-away module instances as in new ModuleInstance((module {}.source), importHook, importMeta)","msgtype":"m.text","org.matrix.msc1767.text":"With that in mind, it’s sufficient to have a module instance to get the underlying unhooked Module Source, like (module {}).source, but Caridy suggests that would potentially mean the creation of throw-away module instances as in new ModuleInstance((module {}.source), importHook, importMeta)"},"ts":1656341216040,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$8kxuviNm9qMXzdCQZjOYFO35A_B54I_ICsnPk1D8Tgs"},
{"content":{"body":"So we go on to suggest (static module {}) instanceof ModuleSource, bypassing that step","msgtype":"m.text","org.matrix.msc1767.text":"So we go on to suggest (static module {}) instanceof ModuleSource, bypassing that step"},"ts":1656341233932,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$g2LfJmTi-41zGKd_-_TYj78H9WnvMMBEXKWoczAK1Vw"},
{"content":{"body":"That suggests that there be import syntax that gives us both of those options.","msgtype":"m.text","org.matrix.msc1767.text":"That suggests that there be import syntax that gives us both of those options."},"ts":1656341267432,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$qcl9b15Xwi_RBE9jF3LoUqkC6JGGoapQuvhP4Cr8x3A"},
{"content":{"body":"One thing I had not considered until this moment is that importHook would not be sufficient in order to support the ModuleSource import case.","msgtype":"m.text","org.matrix.msc1767.text":"One thing I had not considered until this moment is that importHook would not be sufficient in order to support the ModuleSource import case."},"ts":1656341335784,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$dsKXViOhUzV8ExWhqG4wqXy-ajwMLo8LJkNF5pJzCqM"},
{"content":{"body":"But importHook is sufficient for deferred execution. For the deferred execution case, you’re importing a fully linked ModuleInstance that inherits the surrounding ModuleInstance’s importHook. You would then have the option of using it as a handle in a more elaborate import graph or just import(moduleInstance) at whatever time you deem appropriate to experience jank.","msgtype":"m.text","org.matrix.msc1767.text":"But importHook is sufficient for deferred execution. For the deferred execution case, you’re importing a fully linked ModuleInstance that inherits the surrounding ModuleInstance’s importHook. You would then have the option of using it as a handle in a more elaborate import graph or just import(moduleInstance) at whatever time you deem appropriate to experience jank."},"ts":1656341436628,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$C9SQ3X4kexR6Tpc9X75cMyY8uKg7bfYQEzqzNiogxxg"},
{"content":{"body":"In any case, I sketched this, borrowing as much as possible from the Compartments proposal https://gist.github.com/kriskowal/288d38e62e55e09685bf62c3a3c25565","msgtype":"m.text","org.matrix.msc1767.text":"In any case, I sketched this, borrowing as much as possible from the Compartments proposal https://gist.github.com/kriskowal/288d38e62e55e09685bf62c3a3c25565"},"ts":1656341482026,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$R6vzCXVsXoaF1NO3bWx6aMHCsNf6uT-quOxlnXMEn2U"},
{"content":{"body":"And note that it varies from Guy and Luca’s proposal in only one meaningful way: there’s no link method. Linking is a side-effect of kicking off the module system with a dynamic import of some leaf instance, which draws in its transitive dependencies.","msgtype":"m.text","org.matrix.msc1767.text":"And note that it varies from Guy and Luca’s proposal in only one meaningful way: there’s no link method. Linking is a side-effect of kicking off the module system with a dynamic import of some leaf instance, which draws in its transitive dependencies."},"ts":1656341543707,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$adR2k0EelGZAgG7gugcJMTX8nNi0GpEF8XdwJMyQkWU"},
{"content":{"body":"So the difference is that the importHook gets used for both static and dynamic import.","msgtype":"m.text","org.matrix.msc1767.text":"So the difference is that the importHook gets used for both static and dynamic import."},"ts":1656341571229,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$37uN6qpv8qboRPZeWJzmFb_5PrW8C-ycIp79iy-qMIQ"},
{"content":{"body":"I need to think more about the ramifications, but you’re all welcome to join me in the thought experiment.","msgtype":"m.text","org.matrix.msc1767.text":"I need to think more about the ramifications, but you’re all welcome to join me in the thought experiment."},"ts":1656341604926,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$sVl3jKlgt3PzV1NXSSSx4_ImqyAu4nQ3yhTqn_j3PIY"},
{"content":{"body":"One question ljharb asked on Github was whether it is ever desirable for dynamic import to provide different values for the same specifier (un-idem-potent?), or results inconsistent with `import * as name`. It would be surprising, which is undesirable. I’m not sure whether it’s always undesirable. In the context of this thought experiment, it would be possible to enforce idempotence on dynamic import and consistency with static import by having a locale memo as part of the ModuleInstance state. That comes at a cost we might prefer not to bear, especially if it is adequate to suggest that the responsibility to maintain this invariant be deferred to user code.","format":"org.matrix.custom.html","formatted_body":"One question <a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a> asked on Github was whether it is ever desirable for dynamic import to provide different values for the same specifier (un-idem-potent?), or results inconsistent with <code>import * as name</code>. It would be surprising, which is undesirable. I’m not sure whether it’s always undesirable. In the context of this thought experiment, it would be possible to enforce idempotence on dynamic import and consistency with static import by having a locale memo as part of the ModuleInstance state. That comes at a cost we might prefer not to bear, especially if it is adequate to suggest that the responsibility to maintain this invariant be deferred to user code.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"One question ljharb asked on Github was whether it is ever desirable for dynamic import to provide different values for the same specifier (un-idem-potent?), or results inconsistent with `import * as name`. It would be surprising, which is undesirable. I’m not sure whether it’s always undesirable. In the context of this thought experiment, it would be possible to enforce idempotence on dynamic import and consistency with static import by having a locale memo as part of the ModuleInstance state. That comes at a cost we might prefer not to bear, especially if it is adequate to suggest that the responsibility to maintain this invariant be deferred to user code.","mimetype":"text/plain"},{"body":"One question <a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a> asked on Github was whether it is ever desirable for dynamic import to provide different values for the same specifier (un-idem-potent?), or results inconsistent with <code>import * as name</code>. It would be surprising, which is undesirable. I’m not sure whether it’s always undesirable. In the context of this thought experiment, it would be possible to enforce idempotence on dynamic import and consistency with static import by having a locale memo as part of the ModuleInstance state. That comes at a cost we might prefer not to bear, especially if it is adequate to suggest that the responsibility to maintain this invariant be deferred to user code.","mimetype":"text/html"}]},"ts":1656342932085,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$l4XdzSVxcRYvYgXVWE883DkEq228bpaccgz02aDSpr4"},
{"content":{"body":"Maintaining import consistency at any granularity broader than module instance might be futile though. Since compartments as specified do and must allow inter-compartment linkage, it is possible in the degenerate case for user code to arrange a single compartment for every module instance and do whatever they want.","msgtype":"m.text","org.matrix.msc1767.text":"Maintaining import consistency at any granularity broader than module instance might be futile though. Since compartments as specified do and must allow inter-compartment linkage, it is possible in the degenerate case for user code to arrange a single compartment for every module instance and do whatever they want."},"ts":1656343028994,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$b_QecoFVqiPsvmzQ97t-bU3EukwYxjzl_2T8_hiaeHA"},
{"content":{"body":"to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold","msgtype":"m.text"},"ts":1656343041278,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$NtOqaYakOr6IWmHmcRjoUA-DESgTz_Z7fqBNNKTcwfM"},
{"content":{"body":"Do you mean in the scope of an instance, cohort of instances, or realm?","msgtype":"m.text","org.matrix.msc1767.text":"Do you mean in the scope of an instance, cohort of instances, or realm?"},"ts":1656343107570,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$3H9rBlZZsisajhIlwa5DcAvG3W7ZLQoxUEF9SZzoDrQ"},
{"content":{"body":"> <@ljharb:matrix.org> to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold\n\nThat’s also my default assumption. I can think of no use for inconsistency in the scope of an instance.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$NtOqaYakOr6IWmHmcRjoUA-DESgTz_Z7fqBNNKTcwfM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold</blockquote></mx-reply>That’s also my default assumption. I can think of no use for inconsistency in the scope of an instance.","m.relates_to":{"m.in_reply_to":{"event_id":"$NtOqaYakOr6IWmHmcRjoUA-DESgTz_Z7fqBNNKTcwfM"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@ljharb:matrix.org> to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold\n\nThat’s also my default assumption. I can think of no use for inconsistency in the scope of an instance.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$NtOqaYakOr6IWmHmcRjoUA-DESgTz_Z7fqBNNKTcwfM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold</blockquote></mx-reply>That’s also my default assumption. I can think of no use for inconsistency in the scope of an instance.","mimetype":"text/html"}]},"ts":1656343191618,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$hcb08N185a126nLsUXpqKzDvQ0NhWMZV-zsB9Zq-oFA"}
]