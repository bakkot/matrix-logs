[
{"content":{"body":"Caridy and I had a conversation about paring down the compartments/loader proposal to avoid having to specify any maps at all, to avoid mentioning referrer specifiers at all, to further slim its profile against the wind.","msgtype":"m.text","org.matrix.msc1767.text":"Caridy and I had a conversation about paring down the compartments/loader proposal to avoid having to specify any maps at all, to avoid mentioning referrer specifiers at all, to further slim its profile against the wind."},"ts":1656340818182,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$U0GCag7WBGMK1GlfF-nR6cqsmDbyVhYGRwgsO_6D_o8"},
{"content":{"body":"The thought experiment is to return to the proposal Guy and Luca made at plenary and ask more questions.","msgtype":"m.text","org.matrix.msc1767.text":"The thought experiment is to return to the proposal Guy and Luca made at plenary and ask more questions."},"ts":1656340855905,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$A1CqkN6sMC7bP3LWG9QtjANErThpPn_QHaxhRe9v4L8"},
{"content":{"body":"Suppose new ModuleSource(source) and new ModuleInstance(source, importHook, importMeta?)","msgtype":"m.text","org.matrix.msc1767.text":"Suppose new ModuleSource(source) and new ModuleInstance(source, importHook, importMeta?)"},"ts":1656340880515,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$zi7EKsoRORZxjDJ-d9Wm3Qcn4HcIhfHVhK9QRcG_Lx4"},
{"content":{"body":"Such that source.bindings reflects imports/exports and instance.source refers to the original source.","msgtype":"m.text","org.matrix.msc1767.text":"Such that source.bindings reflects imports/exports and instance.source refers to the original source."},"ts":1656340902859,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$bVUtxehF_AB5e_xY8nJeH_vbdxe4B0-a9vKH4HmIWE0"},
{"content":{"body":"Suppose also that import reflection gives us the means to obtain either of these through syntax. Recursively, that would mean that ModuleInstances and ModuleSources could be drawn out of ModuleInstance hooks.","msgtype":"m.text","org.matrix.msc1767.text":"Suppose also that import reflection gives us the means to obtain either of these through syntax. Recursively, that would mean that ModuleInstances and ModuleSources could be drawn out of ModuleInstance hooks."},"ts":1656341058057,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$HLGXa1mJKsVdN6KWml6wBdV4nj6r88AD_wPBEujn3xY"},
{"content":{"body":"Also, supposing that importHook’s signature is importHook(importSpecifier, moduleInstance), such that there is no referrer, but the importHook can associate instances with referrers and do whatever it must internally.","msgtype":"m.text","org.matrix.msc1767.text":"Also, supposing that importHook’s signature is importHook(importSpecifier, moduleInstance), such that there is no referrer, but the importHook can associate instances with referrers and do whatever it must internally."},"ts":1656341108029,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$oZjjQuqGjk60BoKnFAQ7SCacjaw1-SiUk9GFko8uZ0k"},
{"content":{"body":"Caridy also proposes that we use dynamic import in the same way as blocks.","msgtype":"m.text","org.matrix.msc1767.text":"Caridy also proposes that we use dynamic import in the same way as blocks."},"ts":1656341129986,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$J6gesk7hUws2DJjmLscfT1M7_osqiFlo7svtCF2KDuc"},
{"content":{"body":"Which is to say, in this thought experiment, ModuleInstance corresponds to module {}","msgtype":"m.text","org.matrix.msc1767.text":"Which is to say, in this thought experiment, ModuleInstance corresponds to module {}"},"ts":1656341144703,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$5ehEvhN7a0btHwX2JgSuvnpTkvVVuXZY8cseb05Mn5A"},
{"content":{"body":"With that in mind, it’s sufficient to have a module instance to get the underlying unhooked Module Source, like (module {}).source, but Caridy suggests that would potentially mean the creation of throw-away module instances as in new ModuleInstance((module {}.source), importHook, importMeta)","msgtype":"m.text","org.matrix.msc1767.text":"With that in mind, it’s sufficient to have a module instance to get the underlying unhooked Module Source, like (module {}).source, but Caridy suggests that would potentially mean the creation of throw-away module instances as in new ModuleInstance((module {}.source), importHook, importMeta)"},"ts":1656341216040,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$8kxuviNm9qMXzdCQZjOYFO35A_B54I_ICsnPk1D8Tgs"},
{"content":{"body":"So we go on to suggest (static module {}) instanceof ModuleSource, bypassing that step","msgtype":"m.text","org.matrix.msc1767.text":"So we go on to suggest (static module {}) instanceof ModuleSource, bypassing that step"},"ts":1656341233932,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$g2LfJmTi-41zGKd_-_TYj78H9WnvMMBEXKWoczAK1Vw"},
{"content":{"body":"That suggests that there be import syntax that gives us both of those options.","msgtype":"m.text","org.matrix.msc1767.text":"That suggests that there be import syntax that gives us both of those options."},"ts":1656341267432,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$qcl9b15Xwi_RBE9jF3LoUqkC6JGGoapQuvhP4Cr8x3A"},
{"content":{"body":"One thing I had not considered until this moment is that importHook would not be sufficient in order to support the ModuleSource import case.","msgtype":"m.text","org.matrix.msc1767.text":"One thing I had not considered until this moment is that importHook would not be sufficient in order to support the ModuleSource import case."},"ts":1656341335784,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$dsKXViOhUzV8ExWhqG4wqXy-ajwMLo8LJkNF5pJzCqM"},
{"content":{"body":"But importHook is sufficient for deferred execution. For the deferred execution case, you’re importing a fully linked ModuleInstance that inherits the surrounding ModuleInstance’s importHook. You would then have the option of using it as a handle in a more elaborate import graph or just import(moduleInstance) at whatever time you deem appropriate to experience jank.","msgtype":"m.text","org.matrix.msc1767.text":"But importHook is sufficient for deferred execution. For the deferred execution case, you’re importing a fully linked ModuleInstance that inherits the surrounding ModuleInstance’s importHook. You would then have the option of using it as a handle in a more elaborate import graph or just import(moduleInstance) at whatever time you deem appropriate to experience jank."},"ts":1656341436628,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$C9SQ3X4kexR6Tpc9X75cMyY8uKg7bfYQEzqzNiogxxg"},
{"content":{"body":"In any case, I sketched this, borrowing as much as possible from the Compartments proposal https://gist.github.com/kriskowal/288d38e62e55e09685bf62c3a3c25565","msgtype":"m.text","org.matrix.msc1767.text":"In any case, I sketched this, borrowing as much as possible from the Compartments proposal https://gist.github.com/kriskowal/288d38e62e55e09685bf62c3a3c25565"},"ts":1656341482026,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$R6vzCXVsXoaF1NO3bWx6aMHCsNf6uT-quOxlnXMEn2U"},
{"content":{"body":"And note that it varies from Guy and Luca’s proposal in only one meaningful way: there’s no link method. Linking is a side-effect of kicking off the module system with a dynamic import of some leaf instance, which draws in its transitive dependencies.","msgtype":"m.text","org.matrix.msc1767.text":"And note that it varies from Guy and Luca’s proposal in only one meaningful way: there’s no link method. Linking is a side-effect of kicking off the module system with a dynamic import of some leaf instance, which draws in its transitive dependencies."},"ts":1656341543707,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$adR2k0EelGZAgG7gugcJMTX8nNi0GpEF8XdwJMyQkWU"},
{"content":{"body":"So the difference is that the importHook gets used for both static and dynamic import.","msgtype":"m.text","org.matrix.msc1767.text":"So the difference is that the importHook gets used for both static and dynamic import."},"ts":1656341571229,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$37uN6qpv8qboRPZeWJzmFb_5PrW8C-ycIp79iy-qMIQ"},
{"content":{"body":"I need to think more about the ramifications, but you’re all welcome to join me in the thought experiment.","msgtype":"m.text","org.matrix.msc1767.text":"I need to think more about the ramifications, but you’re all welcome to join me in the thought experiment."},"ts":1656341604926,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$sVl3jKlgt3PzV1NXSSSx4_ImqyAu4nQ3yhTqn_j3PIY"},
{"content":{"body":"One question ljharb asked on Github was whether it is ever desirable for dynamic import to provide different values for the same specifier (un-idem-potent?), or results inconsistent with `import * as name`. It would be surprising, which is undesirable. I’m not sure whether it’s always undesirable. In the context of this thought experiment, it would be possible to enforce idempotence on dynamic import and consistency with static import by having a locale memo as part of the ModuleInstance state. That comes at a cost we might prefer not to bear, especially if it is adequate to suggest that the responsibility to maintain this invariant be deferred to user code.","format":"org.matrix.custom.html","formatted_body":"One question <a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a> asked on Github was whether it is ever desirable for dynamic import to provide different values for the same specifier (un-idem-potent?), or results inconsistent with <code>import * as name</code>. It would be surprising, which is undesirable. I’m not sure whether it’s always undesirable. In the context of this thought experiment, it would be possible to enforce idempotence on dynamic import and consistency with static import by having a locale memo as part of the ModuleInstance state. That comes at a cost we might prefer not to bear, especially if it is adequate to suggest that the responsibility to maintain this invariant be deferred to user code.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"One question ljharb asked on Github was whether it is ever desirable for dynamic import to provide different values for the same specifier (un-idem-potent?), or results inconsistent with `import * as name`. It would be surprising, which is undesirable. I’m not sure whether it’s always undesirable. In the context of this thought experiment, it would be possible to enforce idempotence on dynamic import and consistency with static import by having a locale memo as part of the ModuleInstance state. That comes at a cost we might prefer not to bear, especially if it is adequate to suggest that the responsibility to maintain this invariant be deferred to user code.","mimetype":"text/plain"},{"body":"One question <a href=\"https://matrix.to/#/@ljharb:matrix.org\">ljharb</a> asked on Github was whether it is ever desirable for dynamic import to provide different values for the same specifier (un-idem-potent?), or results inconsistent with <code>import * as name</code>. It would be surprising, which is undesirable. I’m not sure whether it’s always undesirable. In the context of this thought experiment, it would be possible to enforce idempotence on dynamic import and consistency with static import by having a locale memo as part of the ModuleInstance state. That comes at a cost we might prefer not to bear, especially if it is adequate to suggest that the responsibility to maintain this invariant be deferred to user code.","mimetype":"text/html"}]},"ts":1656342932085,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$l4XdzSVxcRYvYgXVWE883DkEq228bpaccgz02aDSpr4"},
{"content":{"body":"Maintaining import consistency at any granularity broader than module instance might be futile though. Since compartments as specified do and must allow inter-compartment linkage, it is possible in the degenerate case for user code to arrange a single compartment for every module instance and do whatever they want.","msgtype":"m.text","org.matrix.msc1767.text":"Maintaining import consistency at any granularity broader than module instance might be futile though. Since compartments as specified do and must allow inter-compartment linkage, it is possible in the degenerate case for user code to arrange a single compartment for every module instance and do whatever they want."},"ts":1656343028994,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$b_QecoFVqiPsvmzQ97t-bU3EukwYxjzl_2T8_hiaeHA"},
{"content":{"body":"to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold","msgtype":"m.text"},"ts":1656343041278,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$NtOqaYakOr6IWmHmcRjoUA-DESgTz_Z7fqBNNKTcwfM"},
{"content":{"body":"Do you mean in the scope of an instance, cohort of instances, or realm?","msgtype":"m.text","org.matrix.msc1767.text":"Do you mean in the scope of an instance, cohort of instances, or realm?"},"ts":1656343107570,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$3H9rBlZZsisajhIlwa5DcAvG3W7ZLQoxUEF9SZzoDrQ"},
{"content":{"body":"> <@ljharb:matrix.org> to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold\n\nThat’s also my default assumption. I can think of no use for inconsistency in the scope of an instance.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$NtOqaYakOr6IWmHmcRjoUA-DESgTz_Z7fqBNNKTcwfM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold</blockquote></mx-reply>That’s also my default assumption. I can think of no use for inconsistency in the scope of an instance.","m.relates_to":{"m.in_reply_to":{"event_id":"$NtOqaYakOr6IWmHmcRjoUA-DESgTz_Z7fqBNNKTcwfM"}},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":"> <@ljharb:matrix.org> to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold\n\nThat’s also my default assumption. I can think of no use for inconsistency in the scope of an instance.","mimetype":"text/plain"},{"body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$NtOqaYakOr6IWmHmcRjoUA-DESgTz_Z7fqBNNKTcwfM?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@ljharb:matrix.org\">@ljharb:matrix.org</a><br>to be clear, my default assumption is that it should be an unbreakable axiom modulo thenable modules, that static and dynamic imports are the same. I asked when it’d be desirable to figure out if that axiom should hold</blockquote></mx-reply>That’s also my default assumption. I can think of no use for inconsistency in the scope of an instance.","mimetype":"text/html"}]},"ts":1656343191618,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$hcb08N185a126nLsUXpqKzDvQ0NhWMZV-zsB9Zq-oFA"},
{"content":{"body":"This thought experiment would allow for inconsistency, and although inconsistency is not a desired effect, it does allow us to decouple the module loader from the realm’s module map, since it becomes the responsibility of the module instance hooks to maintain consistency.","msgtype":"m.text","org.matrix.msc1767.text":"This thought experiment would allow for inconsistency, and although inconsistency is not a desired effect, it does allow us to decouple the module loader from the realm’s module map, since it becomes the responsibility of the module instance hooks to maintain consistency."},"ts":1656343412096,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$ls0Pgu7SxxhBy7TkDevti78VAZMfOAKEiu8XQg2g1Ts"},
{"content":{"body":"The compartments proposal as written today would require module maps to be factored out of Realm so each Compartment can have its own maps. We’re anticipating that will meet resistance, but I don’t know for sure.","msgtype":"m.text","org.matrix.msc1767.text":"The compartments proposal as written today would require module maps to be factored out of Realm so each Compartment can have its own maps. We’re anticipating that will meet resistance, but I don’t know for sure."},"ts":1656343490627,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$2VsY7QO4pIwVG7-UOBtCmNsjrvX07_ply6H9gSXtIqY"},
{"content":{"body":"nicolo-ribaudo can correct me if I’m wrong, but I believe that module blocks and fragments as littledan has described them to me, would enforce consistency in the same realm by incorporating every module instance into the realm’s module map, using either a gensym or the module instance’s identity as an (ephemeral?) key. That would not allow for inconsistency. But, round-tripping a module instance through an intermediate realm would.","format":"org.matrix.custom.html","formatted_body":"<a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a> can correct me if I’m wrong, but I believe that module blocks and fragments as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> has described them to me, would enforce consistency in the same realm by incorporating every module instance into the realm’s module map, using either a gensym or the module instance’s identity as an (ephemeral?) key. That would not allow for inconsistency. But, round-tripping a module instance through an intermediate realm would.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"nicolo-ribaudo can correct me if I’m wrong, but I believe that module blocks and fragments as littledan has described them to me, would enforce consistency in the same realm by incorporating every module instance into the realm’s module map, using either a gensym or the module instance’s identity as an (ephemeral?) key. That would not allow for inconsistency. But, round-tripping a module instance through an intermediate realm would.","mimetype":"text/plain"},{"body":"<a href=\"https://matrix.to/#/@nicolo-ribaudo:matrix.org\">nicolo-ribaudo</a> can correct me if I’m wrong, but I believe that module blocks and fragments as <a href=\"https://matrix.to/#/@littledan:matrix.org\">littledan</a> has described them to me, would enforce consistency in the same realm by incorporating every module instance into the realm’s module map, using either a gensym or the module instance’s identity as an (ephemeral?) key. That would not allow for inconsistency. But, round-tripping a module instance through an intermediate realm would.","mimetype":"text/html"}]},"ts":1656343688700,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$zDm9DT8q0PtLbbDTm3LCQHlCgdYlHCW4ttpm10nbfBY"},
{"content":{"body":"But I think the inconsistency would be limited to fragments themselves. Stringly-named dependencies would remain consistent.","msgtype":"m.text","org.matrix.msc1767.text":"But I think the inconsistency would be limited to fragments themselves. Stringly-named dependencies would remain consistent."},"ts":1656343766130,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$ki-BmxQ_Cto9AmQW2cBdYr6KIGMsGA6YpGntwJpQMds"},
{"content":{"body":"I for one see no reason to expect consistency of fragment identity under any circumstances, but that is a separate matter.","msgtype":"m.text","org.matrix.msc1767.text":"I for one see no reason to expect consistency of fragment identity under any circumstances, but that is a separate matter."},"ts":1656343803982,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$m-SM8bYznZ4eUVtmy4SrRdkmxuSC0TE86D91lDnBocs"},
{"content":{"body":"Compartments as proposed do attempt to maintain consistency by having per-compartment maps and consistent-linkage to other compartments. I should try harder to come up with a consistency attack. I’m not sure a meaningful one exists.","msgtype":"m.text","org.matrix.msc1767.text":"Compartments as proposed do attempt to maintain consistency by having per-compartment maps and consistent-linkage to other compartments. I should try harder to come up with a consistency attack. I’m not sure a meaningful one exists."},"ts":1656344064715,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$qVG4q9e_9vAz7pHJBLjO4SWi5WPScMGh-IxUqJcwGME"},
{"content":{"body":"> <@kriskowal:matrix.org> Do you mean in the scope of an instance, cohort of instances, or realm?\n\ni mean in a realm, but I’m not paged in on all the new terminology here","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT%3Amatrix.org/%243H9rBlZZsisajhIlwa5DcAvG3W7ZLQoxUEF9SZzoDrQ\">In reply to</a> <a href=\"https://matrix.to/#/@kriskowal:matrix.org\">@kriskowal:matrix.org</a><br>Do you mean in the scope of an instance, cohort of instances, or realm?</blockquote></mx-reply>i mean in a realm, but I’m not paged in on all the new terminology here","m.relates_to":{"m.in_reply_to":{"event_id":"$3H9rBlZZsisajhIlwa5DcAvG3W7ZLQoxUEF9SZzoDrQ"}},"msgtype":"m.text"},"ts":1656344129094,"senderName":"ljharb","senderId":"@ljharb:matrix.org","id":"$tG8a2pgVkGfzVtZ2wkf-wEHNbVCOpxCGD7oeb3Ja2Os"},
{"content":{"body":"I need some time to digest all of this, but I like this direction.\nFor module blocks, having \"module instances\" and \"module sources\" easily explains why/how passing a module to a different realm (and back) looses the `import()` caching: you now have a new module, just with the same source (like having two identical files on the file system but in two different locations)","format":"org.matrix.custom.html","formatted_body":"I need some time to digest all of this, but I like this direction.<br>For module blocks, having &quot;module instances&quot; and &quot;module sources&quot; easily explains why/how passing a module to a different realm (and back) looses the <code>import()</code> caching: you now have a new module, just with the same source (like having two identical files on the file system but in two different locations)","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I need some time to digest all of this, but I like this direction.\nFor module blocks, having \"module instances\" and \"module sources\" easily explains why/how passing a module to a different realm (and back) looses the `import()` caching: you now have a new module, just with the same source (like having two identical files on the file system but in two different locations)","mimetype":"text/plain"},{"body":"I need some time to digest all of this, but I like this direction.<br>For module blocks, having &quot;module instances&quot; and &quot;module sources&quot; easily explains why/how passing a module to a different realm (and back) looses the <code>import()</code> caching: you now have a new module, just with the same source (like having two identical files on the file system but in two different locations)","mimetype":"text/html"}]},"ts":1656346200278,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$jmZMIf6HVC8lEGwz_Hqj094mZGTcGGmN1VzHYQdt42A"},
{"content":{"body":"The \"import axioms\" I think we shuold guarantee are (modulo `export function then`):\n- `await import(\"x\")` and `import * as _ from \"x\"` in the same module must always evaluate to the same object \n- `await import(fragment)` and `import * as _ from fragment` in the same realm must always evaluate to the same object\n\nAnd, with your proposed ModuleInstance/ModuleSource,\n- `await import(fragment)` and `await import(new ModuleInstance(fragment.source))` must re-evaluate the module two times\n\nThe only thing I'm not sure about is if in module blocks the evaluation context should depend on where `import()` is called or where the module is defined. Given `realm` the `globalThis` of an `iframe`, I don't know if `await import(fragment)` and `await realm.Function(\"s\", \"import(s)\")(fragment)` should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).\nFor string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.","format":"org.matrix.custom.html","formatted_body":"<p>The &quot;import axioms&quot; I think we shuold guarantee are (modulo <code>export function then</code>):</p>\n<ul>\n<li><code>await import(&quot;x&quot;)</code> and <code>import * as _ from &quot;x&quot;</code> in the same module must always evaluate to the same object</li>\n<li><code>await import(fragment)</code> and <code>import * as _ from fragment</code> in the same realm must always evaluate to the same object</li>\n</ul>\n<p>And, with your proposed ModuleInstance/ModuleSource,</p>\n<ul>\n<li><code>await import(fragment)</code> and <code>await import(new ModuleInstance(fragment.source))</code> must re-evaluate the module two times</li>\n</ul>\n<p>The only thing I'm not sure about is if in module blocks the evaluation context should depend on where <code>import()</code> is called or where the module is defined. Given <code>realm</code> the <code>globalThis</code> of an <code>iframe</code>, I don't know if <code>await import(fragment)</code> and <code>await realm.Function(&quot;s&quot;, &quot;import(s)&quot;)(fragment)</code> should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).<br>For string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The \"import axioms\" I think we shuold guarantee are (modulo `export function then`):\n- `await import(\"x\")` and `import * as _ from \"x\"` in the same module must always evaluate to the same object \n- `await import(fragment)` and `import * as _ from fragment` in the same realm must always evaluate to the same object\n\nAnd, with your proposed ModuleInstance/ModuleSource,\n- `await import(fragment)` and `await import(new ModuleInstance(fragment.source))` must re-evaluate the module two times\n\nThe only thing I'm not sure about is if in module blocks the evaluation context should depend on where `import()` is called or where the module is defined. Given `realm` the `globalThis` of an `iframe`, I don't know if `await import(fragment)` and `await realm.Function(\"s\", \"import(s)\")(fragment)` should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).\nFor string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.","mimetype":"text/plain"},{"body":"<p>The &quot;import axioms&quot; I think we shuold guarantee are (modulo <code>export function then</code>):</p>\n<ul>\n<li><code>await import(&quot;x&quot;)</code> and <code>import * as _ from &quot;x&quot;</code> in the same module must always evaluate to the same object</li>\n<li><code>await import(fragment)</code> and <code>import * as _ from fragment</code> in the same realm must always evaluate to the same object</li>\n</ul>\n<p>And, with your proposed ModuleInstance/ModuleSource,</p>\n<ul>\n<li><code>await import(fragment)</code> and <code>await import(new ModuleInstance(fragment.source))</code> must re-evaluate the module two times</li>\n</ul>\n<p>The only thing I'm not sure about is if in module blocks the evaluation context should depend on where <code>import()</code> is called or where the module is defined. Given <code>realm</code> the <code>globalThis</code> of an <code>iframe</code>, I don't know if <code>await import(fragment)</code> and <code>await realm.Function(&quot;s&quot;, &quot;import(s)&quot;)(fragment)</code> should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).<br>For string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.</p>\n","mimetype":"text/html"}]},"ts":1656346661745,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$sGZ7vhVAksuCrFwjYkFe7GahpHnzEGMVET_FoUexoQM"},
{"content":{"body":" * The \"import axioms\" I think we shuold guarantee are (modulo `export function then`):\n\n- `await import(\"x\")` and `import * as _ from \"x\"` in the same module must always evaluate to the same object\n- `await import(fragment)` and `import * as _ from fragment` in the same realm (compartment?) must always evaluate to the same object\n\nAnd, with your proposed ModuleInstance/ModuleSource,\n\n- `await import(fragment)` and `await import(new ModuleInstance(fragment.source))` must re-evaluate the module two times\n\nThe only thing I'm not sure about is if in module blocks the evaluation context should depend on where `import()` is called or where the module is defined. Given `realm` the `globalThis` of an `iframe`, I don't know if `await import(fragment)` and `await realm.Function(\"s\", \"import(s)\")(fragment)` should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).\nFor string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.","format":"org.matrix.custom.html","formatted_body":" * <p>The &quot;import axioms&quot; I think we shuold guarantee are (modulo <code>export function then</code>):</p>\n<ul>\n<li><code>await import(&quot;x&quot;)</code> and <code>import * as _ from &quot;x&quot;</code> in the same module must always evaluate to the same object</li>\n<li><code>await import(fragment)</code> and <code>import * as _ from fragment</code> in the same realm (compartment?) must always evaluate to the same object</li>\n</ul>\n<p>And, with your proposed ModuleInstance/ModuleSource,</p>\n<ul>\n<li><code>await import(fragment)</code> and <code>await import(new ModuleInstance(fragment.source))</code> must re-evaluate the module two times</li>\n</ul>\n<p>The only thing I'm not sure about is if in module blocks the evaluation context should depend on where <code>import()</code> is called or where the module is defined. Given <code>realm</code> the <code>globalThis</code> of an <code>iframe</code>, I don't know if <code>await import(fragment)</code> and <code>await realm.Function(&quot;s&quot;, &quot;import(s)&quot;)(fragment)</code> should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).<br>For string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.</p>\n","m.new_content":{"body":"The \"import axioms\" I think we shuold guarantee are (modulo `export function then`):\n\n- `await import(\"x\")` and `import * as _ from \"x\"` in the same module must always evaluate to the same object\n- `await import(fragment)` and `import * as _ from fragment` in the same realm (compartment?) must always evaluate to the same object\n\nAnd, with your proposed ModuleInstance/ModuleSource,\n\n- `await import(fragment)` and `await import(new ModuleInstance(fragment.source))` must re-evaluate the module two times\n\nThe only thing I'm not sure about is if in module blocks the evaluation context should depend on where `import()` is called or where the module is defined. Given `realm` the `globalThis` of an `iframe`, I don't know if `await import(fragment)` and `await realm.Function(\"s\", \"import(s)\")(fragment)` should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).\nFor string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.","format":"org.matrix.custom.html","formatted_body":"<p>The &quot;import axioms&quot; I think we shuold guarantee are (modulo <code>export function then</code>):</p>\n<ul>\n<li><code>await import(&quot;x&quot;)</code> and <code>import * as _ from &quot;x&quot;</code> in the same module must always evaluate to the same object</li>\n<li><code>await import(fragment)</code> and <code>import * as _ from fragment</code> in the same realm (compartment?) must always evaluate to the same object</li>\n</ul>\n<p>And, with your proposed ModuleInstance/ModuleSource,</p>\n<ul>\n<li><code>await import(fragment)</code> and <code>await import(new ModuleInstance(fragment.source))</code> must re-evaluate the module two times</li>\n</ul>\n<p>The only thing I'm not sure about is if in module blocks the evaluation context should depend on where <code>import()</code> is called or where the module is defined. Given <code>realm</code> the <code>globalThis</code> of an <code>iframe</code>, I don't know if <code>await import(fragment)</code> and <code>await realm.Function(&quot;s&quot;, &quot;import(s)&quot;)(fragment)</code> should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).<br>For string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.</p>\n","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The \"import axioms\" I think we shuold guarantee are (modulo `export function then`):\n\n- `await import(\"x\")` and `import * as _ from \"x\"` in the same module must always evaluate to the same object\n- `await import(fragment)` and `import * as _ from fragment` in the same realm (compartment?) must always evaluate to the same object\n\nAnd, with your proposed ModuleInstance/ModuleSource,\n\n- `await import(fragment)` and `await import(new ModuleInstance(fragment.source))` must re-evaluate the module two times\n\nThe only thing I'm not sure about is if in module blocks the evaluation context should depend on where `import()` is called or where the module is defined. Given `realm` the `globalThis` of an `iframe`, I don't know if `await import(fragment)` and `await realm.Function(\"s\", \"import(s)\")(fragment)` should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).\nFor string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.","mimetype":"text/plain"},{"body":"<p>The &quot;import axioms&quot; I think we shuold guarantee are (modulo <code>export function then</code>):</p>\n<ul>\n<li><code>await import(&quot;x&quot;)</code> and <code>import * as _ from &quot;x&quot;</code> in the same module must always evaluate to the same object</li>\n<li><code>await import(fragment)</code> and <code>import * as _ from fragment</code> in the same realm (compartment?) must always evaluate to the same object</li>\n</ul>\n<p>And, with your proposed ModuleInstance/ModuleSource,</p>\n<ul>\n<li><code>await import(fragment)</code> and <code>await import(new ModuleInstance(fragment.source))</code> must re-evaluate the module two times</li>\n</ul>\n<p>The only thing I'm not sure about is if in module blocks the evaluation context should depend on where <code>import()</code> is called or where the module is defined. Given <code>realm</code> the <code>globalThis</code> of an <code>iframe</code>, I don't know if <code>await import(fragment)</code> and <code>await realm.Function(&quot;s&quot;, &quot;import(s)&quot;)(fragment)</code> should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).<br>For string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.</p>\n","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$sGZ7vhVAksuCrFwjYkFe7GahpHnzEGMVET_FoUexoQM","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * The \"import axioms\" I think we shuold guarantee are (modulo `export function then`):\n\n- `await import(\"x\")` and `import * as _ from \"x\"` in the same module must always evaluate to the same object\n- `await import(fragment)` and `import * as _ from fragment` in the same realm (compartment?) must always evaluate to the same object\n\nAnd, with your proposed ModuleInstance/ModuleSource,\n\n- `await import(fragment)` and `await import(new ModuleInstance(fragment.source))` must re-evaluate the module two times\n\nThe only thing I'm not sure about is if in module blocks the evaluation context should depend on where `import()` is called or where the module is defined. Given `realm` the `globalThis` of an `iframe`, I don't know if `await import(fragment)` and `await realm.Function(\"s\", \"import(s)\")(fragment)` should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).\nFor string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.","mimetype":"text/plain"},{"body":" * <p>The &quot;import axioms&quot; I think we shuold guarantee are (modulo <code>export function then</code>):</p>\n<ul>\n<li><code>await import(&quot;x&quot;)</code> and <code>import * as _ from &quot;x&quot;</code> in the same module must always evaluate to the same object</li>\n<li><code>await import(fragment)</code> and <code>import * as _ from fragment</code> in the same realm (compartment?) must always evaluate to the same object</li>\n</ul>\n<p>And, with your proposed ModuleInstance/ModuleSource,</p>\n<ul>\n<li><code>await import(fragment)</code> and <code>await import(new ModuleInstance(fragment.source))</code> must re-evaluate the module two times</li>\n</ul>\n<p>The only thing I'm not sure about is if in module blocks the evaluation context should depend on where <code>import()</code> is called or where the module is defined. Given <code>realm</code> the <code>globalThis</code> of an <code>iframe</code>, I don't know if <code>await import(fragment)</code> and <code>await realm.Function(&quot;s&quot;, &quot;import(s)&quot;)(fragment)</code> should return the same object (because they are importing the same ModuleInstance) or if they should evaluate the module twice (because they are in two different realms).<br>For string-based imports they would evaluate the module twice, but with this ModuleSource/ModuleInstance thing maye they should return the same object.</p>\n","mimetype":"text/html"}]},"ts":1656347203548,"senderName":"nicolo-ribaudo","senderId":"@nicolo-ribaudo:matrix.org","id":"$34gqv9kN2hd-s79FvbFIrSiyfemWd0dBAf_7VN-0cnI"}
]