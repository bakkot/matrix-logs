[
{"content":{"body":"Caridy and I had a conversation about paring down the compartments/loader proposal to avoid having to specify any maps at all, to avoid mentioning referrer specifiers at all, to further slim its profile against the wind.","msgtype":"m.text","org.matrix.msc1767.text":"Caridy and I had a conversation about paring down the compartments/loader proposal to avoid having to specify any maps at all, to avoid mentioning referrer specifiers at all, to further slim its profile against the wind."},"ts":1656340818182,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$U0GCag7WBGMK1GlfF-nR6cqsmDbyVhYGRwgsO_6D_o8"},
{"content":{"body":"The thought experiment is to return to the proposal Guy and Luca made at plenary and ask more questions.","msgtype":"m.text","org.matrix.msc1767.text":"The thought experiment is to return to the proposal Guy and Luca made at plenary and ask more questions."},"ts":1656340855905,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$A1CqkN6sMC7bP3LWG9QtjANErThpPn_QHaxhRe9v4L8"},
{"content":{"body":"Suppose new ModuleSource(source) and new ModuleInstance(source, importHook, importMeta?)","msgtype":"m.text","org.matrix.msc1767.text":"Suppose new ModuleSource(source) and new ModuleInstance(source, importHook, importMeta?)"},"ts":1656340880515,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$zi7EKsoRORZxjDJ-d9Wm3Qcn4HcIhfHVhK9QRcG_Lx4"},
{"content":{"body":"Such that source.bindings reflects imports/exports and instance.source refers to the original source.","msgtype":"m.text","org.matrix.msc1767.text":"Such that source.bindings reflects imports/exports and instance.source refers to the original source."},"ts":1656340902859,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$bVUtxehF_AB5e_xY8nJeH_vbdxe4B0-a9vKH4HmIWE0"},
{"content":{"body":"Suppose also that import reflection gives us the means to obtain either of these through syntax. Recursively, that would mean that ModuleInstances and ModuleSources could be drawn out of ModuleInstance hooks.","msgtype":"m.text","org.matrix.msc1767.text":"Suppose also that import reflection gives us the means to obtain either of these through syntax. Recursively, that would mean that ModuleInstances and ModuleSources could be drawn out of ModuleInstance hooks."},"ts":1656341058057,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$HLGXa1mJKsVdN6KWml6wBdV4nj6r88AD_wPBEujn3xY"},
{"content":{"body":"Also, supposing that importHook’s signature is importHook(importSpecifier, moduleInstance), such that there is no referrer, but the importHook can associate instances with referrers and do whatever it must internally.","msgtype":"m.text","org.matrix.msc1767.text":"Also, supposing that importHook’s signature is importHook(importSpecifier, moduleInstance), such that there is no referrer, but the importHook can associate instances with referrers and do whatever it must internally."},"ts":1656341108029,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$oZjjQuqGjk60BoKnFAQ7SCacjaw1-SiUk9GFko8uZ0k"},
{"content":{"body":"Caridy also proposes that we use dynamic import in the same way as blocks.","msgtype":"m.text","org.matrix.msc1767.text":"Caridy also proposes that we use dynamic import in the same way as blocks."},"ts":1656341129986,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$J6gesk7hUws2DJjmLscfT1M7_osqiFlo7svtCF2KDuc"},
{"content":{"body":"Which is to say, in this thought experiment, ModuleInstance corresponds to module {}","msgtype":"m.text","org.matrix.msc1767.text":"Which is to say, in this thought experiment, ModuleInstance corresponds to module {}"},"ts":1656341144703,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$5ehEvhN7a0btHwX2JgSuvnpTkvVVuXZY8cseb05Mn5A"},
{"content":{"body":"With that in mind, it’s sufficient to have a module instance to get the underlying unhooked Module Source, like (module {}).source, but Caridy suggests that would potentially mean the creation of throw-away module instances as in new ModuleInstance((module {}.source), importHook, importMeta)","msgtype":"m.text","org.matrix.msc1767.text":"With that in mind, it’s sufficient to have a module instance to get the underlying unhooked Module Source, like (module {}).source, but Caridy suggests that would potentially mean the creation of throw-away module instances as in new ModuleInstance((module {}.source), importHook, importMeta)"},"ts":1656341216040,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$8kxuviNm9qMXzdCQZjOYFO35A_B54I_ICsnPk1D8Tgs"},
{"content":{"body":"So we go on to suggest (static module {}) instanceof ModuleSource, bypassing that step","msgtype":"m.text","org.matrix.msc1767.text":"So we go on to suggest (static module {}) instanceof ModuleSource, bypassing that step"},"ts":1656341233932,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$g2LfJmTi-41zGKd_-_TYj78H9WnvMMBEXKWoczAK1Vw"},
{"content":{"body":"That suggests that there be import syntax that gives us both of those options.","msgtype":"m.text","org.matrix.msc1767.text":"That suggests that there be import syntax that gives us both of those options."},"ts":1656341267432,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$qcl9b15Xwi_RBE9jF3LoUqkC6JGGoapQuvhP4Cr8x3A"},
{"content":{"body":"One thing I had not considered until this moment is that importHook would not be sufficient in order to support the ModuleSource import case.","msgtype":"m.text","org.matrix.msc1767.text":"One thing I had not considered until this moment is that importHook would not be sufficient in order to support the ModuleSource import case."},"ts":1656341335784,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$dsKXViOhUzV8ExWhqG4wqXy-ajwMLo8LJkNF5pJzCqM"}
]