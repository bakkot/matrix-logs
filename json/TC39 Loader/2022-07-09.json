[
{"content":{"body":"I’m working on a sketch of what a user code Compartment looks like through the lens of Module, ModuleSource, and ExecutionContext https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c","msgtype":"m.text","org.matrix.msc1767.text":"I’m working on a sketch of what a user code Compartment looks like through the lens of Module, ModuleSource, and ExecutionContext https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c"},"ts":1657327522808,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$aTtgVor5Wc8wsWA8zkUQIRRmwEuXT3GFjyBIkwfHmCc"},
{"content":{"body":" * I’m working on a sketch of what a user code Compartment looks like through the lens of Module, ModuleSource, and ExecutionContext https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c","m.new_content":{"body":"I’m working on a sketch of what a user code Compartment looks like through the lens of Module, ModuleSource, and ExecutionContext https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c","msgtype":"m.text","org.matrix.msc1767.text":"I’m working on a sketch of what a user code Compartment looks like through the lens of Module, ModuleSource, and ExecutionContext https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c"},"m.relates_to":{"event_id":"$aTtgVor5Wc8wsWA8zkUQIRRmwEuXT3GFjyBIkwfHmCc","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.text":" * I’m working on a sketch of what a user code Compartment looks like through the lens of Module, ModuleSource, and ExecutionContext https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c"},"ts":1657327529908,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$AOhlC0dfIu5HQAlyMDzxRzM6Z6vY2HoD-XzIirXBeNM"},
{"content":{"body":"Have a question","msgtype":"m.text","org.matrix.msc1767.text":"Have a question"},"ts":1657336918290,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$Fs1-PIxtcsXhcaGm8Hf_uEnul3aKxrnPqdoBoVxHFss"},
{"content":{"body":"for example, I have a `const a = new Module(source, hook, meta)`","format":"org.matrix.custom.html","formatted_body":"for example, I have a <code>const a = new Module(source, hook, meta)</code>","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"for example, I have a `const a = new Module(source, hook, meta)`","mimetype":"text/plain"},{"body":"for example, I have a <code>const a = new Module(source, hook, meta)</code>","mimetype":"text/html"}]},"ts":1657336946025,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$b9rFrcLu33tAtrBiHi2wVT63OgQQncbWi3oplDFo_xE"},
{"content":{"body":"in which level it will execute twice? in different Realm? or in different `Module` constructor?","format":"org.matrix.custom.html","formatted_body":"in which level it will execute twice? in different Realm? or in different <code>Module</code> constructor?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"in which level it will execute twice? in different Realm? or in different `Module` constructor?","mimetype":"text/plain"},{"body":"in which level it will execute twice? in different Realm? or in different <code>Module</code> constructor?","mimetype":"text/html"}]},"ts":1657337000646,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$uvHQMUAbUAH12oJDeNcpP_rBnM8FVSio1lWg2aU25Jw"},
{"content":{"body":" * in which level it will execute twice? in different Realm? or in different `Module` constructor?","format":"org.matrix.custom.html","formatted_body":" * in which level it will execute twice? in different Realm? or in different <code>Module</code> constructor?","m.new_content":{"body":"in which level it will execute twice? in different Realm? or in different `Module` constructor?","format":"org.matrix.custom.html","formatted_body":"in which level it will execute twice? in different Realm? or in different <code>Module</code> constructor?","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"in which level it will execute twice? in different Realm? or in different `Module` constructor?","mimetype":"text/plain"},{"body":"in which level it will execute twice? in different Realm? or in different <code>Module</code> constructor?","mimetype":"text/html"}]},"m.relates_to":{"event_id":"$uvHQMUAbUAH12oJDeNcpP_rBnM8FVSio1lWg2aU25Jw","rel_type":"m.replace"},"msgtype":"m.text","org.matrix.msc1767.message":[{"body":" * in which level it will execute twice? in different Realm? or in different `Module` constructor?","mimetype":"text/plain"},{"body":" * in which level it will execute twice? in different Realm? or in different <code>Module</code> constructor?","mimetype":"text/html"}]},"ts":1657337007237,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$v4uGSjo3grX3j1irl6D2IDAO3JTcKc_4BRYSxnh-2TE"},
{"content":{"body":"Once per object identity.","msgtype":"m.text","org.matrix.msc1767.text":"Once per object identity."},"ts":1657337748302,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$8OuCnDOwqu19cATbojL5xuveT0xOVjI9bYPkKWDVWJk"},
{"content":{"body":"even it is used in multiple realms?","msgtype":"m.text","org.matrix.msc1767.text":"even it is used in multiple realms?"},"ts":1657339119318,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$pjOi7b5FzUneNpSFg0LOELyI_CSegRkuBZkLQLkgj8o"},
{"content":{"body":"That is my understanding.","msgtype":"m.text","org.matrix.msc1767.text":"That is my understanding."},"ts":1657339132904,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Aq4iFfrn3_SxTWiKYVYVufhfxetEhCDFurY9KxWFQAE"},
{"content":{"body":"My understanding at the moment is that a module block corresponds to a `Module` instance, so locally it will only initialize once. But, every time a `Module` gets serialized and deserialized, it emerges as a new `Module` instance on the far side. The only parts of the module instance that are serialized are the `source` and `importMeta`, to the extent that `importMeta` is serializable, and the module instance is not memoized by the receiver.","format":"org.matrix.custom.html","formatted_body":"My understanding at the moment is that a module block corresponds to a <code>Module</code> instance, so locally it will only initialize once. But, every time a <code>Module</code> gets serialized and deserialized, it emerges as a new <code>Module</code> instance on the far side. The only parts of the module instance that are serialized are the <code>source</code> and <code>importMeta</code>, to the extent that <code>importMeta</code> is serializable, and the module instance is not memoized by the receiver.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"My understanding at the moment is that a module block corresponds to a `Module` instance, so locally it will only initialize once. But, every time a `Module` gets serialized and deserialized, it emerges as a new `Module` instance on the far side. The only parts of the module instance that are serialized are the `source` and `importMeta`, to the extent that `importMeta` is serializable, and the module instance is not memoized by the receiver.","mimetype":"text/plain"},{"body":"My understanding at the moment is that a module block corresponds to a <code>Module</code> instance, so locally it will only initialize once. But, every time a <code>Module</code> gets serialized and deserialized, it emerges as a new <code>Module</code> instance on the far side. The only parts of the module instance that are serialized are the <code>source</code> and <code>importMeta</code>, to the extent that <code>importMeta</code> is serializable, and the module instance is not memoized by the receiver.","mimetype":"text/html"}]},"ts":1657339177752,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Y8y-HPCF4DrNOnk-2hu8nnTYENykJ9B9SgETGpxnCuk"},
{"content":{"body":"The new `Module` instance would inherit the receiver execution environment’s import hook.","format":"org.matrix.custom.html","formatted_body":"The new <code>Module</code> instance would inherit the receiver execution environment’s import hook.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"The new `Module` instance would inherit the receiver execution environment’s import hook.","mimetype":"text/plain"},{"body":"The new <code>Module</code> instance would inherit the receiver execution environment’s import hook.","mimetype":"text/html"}]},"ts":1657339222038,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$ZRpKtxO99itZZUtj4_wimPoG5PmuehMuoTZuYpaiWwk"},
{"content":{"body":"The module instance also has the [[Context]] internal slot that binds it to the original realm, so the namespace’s objects are guaranteed to be from the originating realm.","msgtype":"m.text","org.matrix.msc1767.text":"The module instance also has the [[Context]] internal slot that binds it to the original realm, so the namespace’s objects are guaranteed to be from the originating realm."},"ts":1657339300369,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$lB4rjlW5wd4aMOEgPu6UxZywKfE3wPBN4Bqbs_2scrU"},
{"content":{"body":"If we’re talking about same-origin `<iframe>` realms, still once because single identity.","format":"org.matrix.custom.html","formatted_body":"If we’re talking about same-origin <code>&lt;iframe&gt;</code> realms, still once because single identity.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"If we’re talking about same-origin `<iframe>` realms, still once because single identity.","mimetype":"text/plain"},{"body":"If we’re talking about same-origin <code>&lt;iframe&gt;</code> realms, still once because single identity.","mimetype":"text/html"}]},"ts":1657339351719,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$O2mEF9VOK3K3LcvnW-jIDbYzYeOqSojIugakYkRi680"},
{"content":{"body":"If we’re talking about shadow realms, once per transit.","msgtype":"m.text","org.matrix.msc1767.text":"If we’re talking about shadow realms, once per transit."},"ts":1657339369600,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$1e0gOkCqzdiM4exfJG0J0U4zOCue05EQFJkDCk0LeVA"},
{"content":{"body":"Though with shadow realms, assuming Static Module Records are treated as immutable after construction, transmitting between shadow realms or even between threads of the same process can be optimized. You still get fresh instances of the `Module` object, though.","format":"org.matrix.custom.html","formatted_body":"Though with shadow realms, assuming Static Module Records are treated as immutable after construction, transmitting between shadow realms or even between threads of the same process can be optimized. You still get fresh instances of the <code>Module</code> object, though.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"Though with shadow realms, assuming Static Module Records are treated as immutable after construction, transmitting between shadow realms or even between threads of the same process can be optimized. You still get fresh instances of the `Module` object, though.","mimetype":"text/plain"},{"body":"Though with shadow realms, assuming Static Module Records are treated as immutable after construction, transmitting between shadow realms or even between threads of the same process can be optimized. You still get fresh instances of the <code>Module</code> object, though.","mimetype":"text/html"}]},"ts":1657339461313,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$dhsX-sVZu8ZaBk_cytDTuy7cFJUsXycq4EtfcFp8xRU"},
{"content":{"body":"And the reasoning for module fragments is that every module fragment has a unique `ModuleSource` consisting of the fragment and all the fragments it transitively depends upon, so each fragment is effectively equivalent to a single module block.","format":"org.matrix.custom.html","formatted_body":"And the reasoning for module fragments is that every module fragment has a unique <code>ModuleSource</code> consisting of the fragment and all the fragments it transitively depends upon, so each fragment is effectively equivalent to a single module block.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"And the reasoning for module fragments is that every module fragment has a unique `ModuleSource` consisting of the fragment and all the fragments it transitively depends upon, so each fragment is effectively equivalent to a single module block.","mimetype":"text/plain"},{"body":"And the reasoning for module fragments is that every module fragment has a unique <code>ModuleSource</code> consisting of the fragment and all the fragments it transitively depends upon, so each fragment is effectively equivalent to a single module block.","mimetype":"text/html"}]},"ts":1657339576688,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$UkJqJPskuU3FTDwtIZncY9fz0xNAZwE466sIw_RvuJg"},
{"content":{"body":"I think there are still open questions about the local semantics, like whether each evaluation of a module fragment produces a new `Module` instance, thus a new identity, thus a new namespace instance.","format":"org.matrix.custom.html","formatted_body":"I think there are still open questions about the local semantics, like whether each evaluation of a module fragment produces a new <code>Module</code> instance, thus a new identity, thus a new namespace instance.","msgtype":"m.text","org.matrix.msc1767.message":[{"body":"I think there are still open questions about the local semantics, like whether each evaluation of a module fragment produces a new `Module` instance, thus a new identity, thus a new namespace instance.","mimetype":"text/plain"},{"body":"I think there are still open questions about the local semantics, like whether each evaluation of a module fragment produces a new <code>Module</code> instance, thus a new identity, thus a new namespace instance.","mimetype":"text/html"}]},"ts":1657339739418,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Mw6dD_15EZPJ2NHXg3egslg7vNFgVOwZIDtZXPe79nE"},
{"content":{"body":"I suspect that’s the only reasonable answer, since module instances are superficially mutable. Having a singleton would create a covert communication channel.","msgtype":"m.text","org.matrix.msc1767.text":"I suspect that’s the only reasonable answer, since module instances are superficially mutable. Having a singleton would create a covert communication channel."},"ts":1657339798745,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$a1DIbmFreKPS2mmH4Bcw5LYtFl0KHrXVU2ES8yWelm0"},
{"content":{"body":"The one hard rule is that a module block can’t write itself into the remote module map using the local key.","msgtype":"m.text","org.matrix.msc1767.text":"The one hard rule is that a module block can’t write itself into the remote module map using the local key."},"ts":1657339882226,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$dS0JmuME_FN7UJKQJZVk4sTZwKeIcdQzI9jSs8iUNvE"},
{"content":{"body":"> <@jackworks:matrix.org> even it is used in multiple realms?\n\nI can’t understand a case where multiple realms would permit importing the same Module. It seems like it should typically throw.","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT%3Amatrix.org/%24pjOi7b5FzUneNpSFg0LOELyI_CSegRkuBZkLQLkgj8o\">In reply to</a> <a href=\"https://matrix.to/#/@jackworks:matrix.org\">@jackworks:matrix.org</a><br>even it is used in multiple realms?</blockquote></mx-reply>I can’t understand a case where multiple realms would permit importing the same Module. It seems like it should typically throw.","m.relates_to":{"m.in_reply_to":{"event_id":"$pjOi7b5FzUneNpSFg0LOELyI_CSegRkuBZkLQLkgj8o"}},"msgtype":"m.text"},"ts":1657343320977,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$o_DYkWeGeOWdX60ShIEnNp332UwrnYmFAVFAgyy1Zgw"},
{"content":{"body":"> <@littledan:matrix.org> I can’t understand a case where multiple realms would permit importing the same Module. It seems like it should typically throw.\n\nCreate 2 modules in 2 realms, and the import hook returns the same module object, does that module return by the import hook evaluate twice? ","format":"org.matrix.custom.html","formatted_body":"<mx-reply><blockquote><a href=\"https://matrix.to/#/!RkpmGMjJtqLKXzByOT:matrix.org/$o_DYkWeGeOWdX60ShIEnNp332UwrnYmFAVFAgyy1Zgw?via=matrix.org&via=igalia.com&via=mozilla.org\">In reply to</a> <a href=\"https://matrix.to/#/@littledan:matrix.org\">@littledan:matrix.org</a><br />I can’t understand a case where multiple realms would permit importing the same Module. It seems like it should typically throw.</blockquote></mx-reply>Create 2 modules in 2 realms, and the import hook returns the same module object, does that module return by the import hook evaluate twice?","m.relates_to":{"m.in_reply_to":{"event_id":"$o_DYkWeGeOWdX60ShIEnNp332UwrnYmFAVFAgyy1Zgw"}},"msgtype":"m.text"},"ts":1657343623928,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$GY818Xxo5lR3nZFxoLdOJacVkXLCQxX5KEdz2y80tsI"},
{"content":{"body":"My contention is that a well-behaved importHook would not do that ","format":"org.matrix.custom.html","formatted_body":"My contention is that a well-behaved importHook would not do that","msgtype":"m.text"},"ts":1657343997822,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$eBNNrNEM51hh26ow4vJgfdsZLYfq8mf_KCgf-GUDgQs"},
{"content":{"body":"But it is possible ","msgtype":"m.text"},"ts":1657344087898,"senderName":"Jack Works","senderId":"@jackworks:matrix.org","id":"$AcDVihrXF85F6xu6J-EX7dPrbYuMGQguTyL8TtWHw68"},
{"content":{"body":"It simplifies a lot of things to have each Module run at most once","msgtype":"m.text"},"ts":1657344145490,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$MPDLr3ilM8d7wIi0FjsyXElbr5kY34YOCh1fc0moy0w"},
{"content":{"body":"It is possible to use a Proxy in a poorly behaved way. We will need to define some kind of semantics for this case, but it doesn’t need to be pretty/perfect IMO","msgtype":"m.text"},"ts":1657344202802,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$vzKPSG-M1WAIgmdo-RdOKSw4MExaUr3cU_sd_LHQKiI"},
{"content":{"body":"* It is possible to use a Proxy in a poorly behaved way. We will need to define some kind of semantics for this case, but it doesn’t need to be pretty/perfect IMO","format":"org.matrix.custom.html","formatted_body":"* (null)","m.new_content":{"body":"It is possible to use a Proxy in a poorly behaved way. We will need to define some kind of semantics for this case, but it doesn’t need to be pretty/perfect IMO","msgtype":"m.text"},"m.relates_to":{"event_id":"$vzKPSG-M1WAIgmdo-RdOKSw4MExaUr3cU_sd_LHQKiI","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1657344207089,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$hp-Q_BYtxn3OUpMN2fGb3My41a6ujcc540k93hz5zLc"},
{"content":{"body":"* It simplifies a lot of things to have each Module run at most once","format":"org.matrix.custom.html","formatted_body":"* (null)","m.new_content":{"body":"It simplifies a lot of things to have each Module run at most once","msgtype":"m.text"},"m.relates_to":{"event_id":"$MPDLr3ilM8d7wIi0FjsyXElbr5kY34YOCh1fc0moy0w","rel_type":"m.replace"},"msgtype":"m.text"},"ts":1657344225079,"senderName":"littledan","senderId":"@littledan:matrix.org","id":"$Bw1QFxwAYtxMMgYXrxRs1UIntGOXRA1F5lwTZNVBDf8"},
{"content":{"body":"You’re suggesting that the dynamic import from one realm would fail to import a module from a realm with the wrong [[Context]]? (This seems fine to me.)","msgtype":"m.text","org.matrix.msc1767.text":"You’re suggesting that the dynamic import from one realm would fail to import a module from a realm with the wrong [[Context]]? (This seems fine to me.)"},"ts":1657344274714,"senderName":"Kris Kowal","senderId":"@kriskowal:matrix.org","id":"$Gxg0s7RG6ZWAXwlhWn2qgG3ZXCNX5dbBCo6myoCLM9w"}
]