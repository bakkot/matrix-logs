[
{"content":{"body":"separately existing.","msgtype":"m.text"},"ts":1608854407000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"croraf: in the spec that is how that works, yes","msgtype":"m.text"},"ts":1608854469000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in engines they will do lots of optimizations with different string representations","msgtype":"m.text"},"ts":1608854503000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if you did \"asd\" + \"c\" you'd probably get a special placeholder value that just says \"i am the result of asd plus c\"","msgtype":"m.text"},"ts":1608854528000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"instead of a new string containing asdc","msgtype":"m.text"},"ts":1608854536000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"OK. Without optimization (or if some chars require) the string will be allocated as \"pairs of bytes filled with utf-16 encoded values for the string\"","msgtype":"m.text"},"ts":1608854610000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"i'd call it an array of u16 values","msgtype":"m.text"},"ts":1608854634000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but yeah you could say pairs of bytes","msgtype":"m.text"},"ts":1608854640000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"And here we come to these peculiarities of charAt, charCodeAt and codePointAt, and perhaps some more.","msgtype":"m.text"},"ts":1608854702000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"That is when the Unicode symbol requires 2 byte-pairs.","msgtype":"m.text"},"ts":1608854742000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"If you have for example \"abX\" where X requires 2 byte-pairs. Using \"abX\".charAt(2) and \"abX\".charAt(3) would both give something other than \"X\", right?","msgtype":"m.text"},"ts":1608854825000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"when you say \"2 byte-pairs\", are you talking about surrogate pairs?","msgtype":"m.text"},"ts":1608854951000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if so, yes","msgtype":"m.text"},"ts":1608854973000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I havent really read surrogate pairs description in the spec carefully. But I think these should be what I talk about.","msgtype":"m.text"},"ts":1608855006000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"the ES spec is not the right place to read about surrogate pairs; it is a Unicode thing, and you should read about it in that context","msgtype":"m.text"},"ts":1608855039000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"A pair of 2  16bit  allocations next to each other, that represent a utf-16 encoding of an Unicode symbol?","msgtype":"m.text"},"ts":1608855087000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"This is a surrogate pair?","msgtype":"m.text"},"ts":1608855100000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"roughly, yes","msgtype":"m.text"},"ts":1608855110000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"And every \"regular\" utf-16 symbol after this X cannot be accessed by the simple \"charAt()\" because the offset produced by X has to be accounted?","msgtype":"m.text"},"ts":1608855189000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"you have to take into account that \"abX\" in your example is four characters long, and so to access the \"y\" in \"abXy\" you would need to do `.charAt(4)` instead of (as you might expect) `.charAt(3)`, yes","msgtype":"m.text"},"ts":1608855278000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Yes, cool, thanks!!!","msgtype":"m.text"},"ts":1608855296000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"And charCodeAt is the same think, just it returns the unsigned integer from the 16bits","msgtype":"m.text"},"ts":1608855329000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1608855340000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(this is where the unsigned integer note is relevant :) )","msgtype":"m.text"},"ts":1608855350000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"OK, fromCharCode seems intuitive now, String.fromCharCode(189, 43, 190, 61).","msgtype":"m.text"},"ts":1608855397000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"Although two arguments in fromCharCode might merge to create a surrogate pair, right?","msgtype":"m.text"},"ts":1608855423000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"they wouldn't really \"merge\", since the string itself would store both parts of the pair without knowing they have anything to do with each other, but yes, you could put a lead and trail surrogate into it and browsers would render that as the single code point represented by that pair","msgtype":"m.text"},"ts":1608855601000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I see. I read MDN now, and the difference is better explained that you cannot put more than 16 bits in the one argument of fromCharCode","msgtype":"m.text"},"ts":1608855673000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1608855724000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"there is fromCodePoint if you want that","msgtype":"m.text"},"ts":1608855728000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"While in fromCodePoint() you can put a 32bit \"supplementary character\"","msgtype":"m.text"},"ts":1608855759000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1608855761000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"OMG, I thoguht there is no codePointAt :|","msgtype":"m.text"},"ts":1608855805000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"but there is","msgtype":"m.text"},"ts":1608855808000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"yes, although it is slightly awkward to use","msgtype":"m.text"},"ts":1608855830000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I see","msgtype":"m.text"},"ts":1608855857000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"It doesnt account the previous surrogate paris","msgtype":"m.text"},"ts":1608855878000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"because it still indexes the same way as charCodeAt, it's just that if you give it the index of a lead surrogate which is followed by a trail surrogate then it will give you the code point represented by the pair rather than just the value of the lead surrogate","msgtype":"m.text"},"ts":1608855878000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Yes","msgtype":"m.text"},"ts":1608855883000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"exactly!","msgtype":"m.text"},"ts":1608855896000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"if you want to actually index by code points, you can spread the string and index that: `[...string][index]` will index by code points","msgtype":"m.text"},"ts":1608855898000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"wait what :O X_X","msgtype":"m.text"},"ts":1608855928000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"this is too much for my brain","msgtype":"m.text"},"ts":1608855938000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"spreading a string with `...` splits by code points, not by code units","msgtype":"m.text"},"ts":1608855953000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Yes, thats what I wanted to ask but almost forgot, what agbout the indexing access","msgtype":"m.text"},"ts":1608855959000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"for some reason","msgtype":"m.text"},"ts":1608855962000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"\"abXy\"[3]","msgtype":"m.text"},"ts":1608855967000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"regular indexing is the same as charAt","msgtype":"m.text"},"ts":1608855971000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":":O","msgtype":"m.text"},"ts":1608855981000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"So many nice questions for a technical interview :D","msgtype":"m.text"},"ts":1608856012000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"OK, one last method \"normalize\"","msgtype":"m.text"},"ts":1608856043000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"(I would not ask someone this sorta stuff in a technical interview unless the job is actually going to involve worrying about unicode encodings, but that's beside the point)","msgtype":"m.text"},"ts":1608856076000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I know, these are kind of stupid questions.","msgtype":"m.text"},"ts":1608856104000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"normalize implements the unicode normalization algorithm: https://unicode.org/reports/tr15/","msgtype":"m.text"},"ts":1608856104000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I would say it is not a minus if the person does not know it but kind of is a big plus if a person knows.","msgtype":"m.text"},"ts":1608856171000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"At least the general idea.","msgtype":"m.text"},"ts":1608856174000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"Not all the differences and trickiness","msgtype":"m.text"},"ts":1608856188000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"I'm kind of confused about these normalization forms. Isn't a Unicode symbol uniquely represented by an integer.","msgtype":"m.text"},"ts":1608856357000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"(which can then be encoded differently)","msgtype":"m.text"},"ts":1608856377000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"but ok, if it is too complicated to explain in one sentence, we can skip.","msgtype":"m.text"},"ts":1608856419000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"yes, but not all characters are uniquely represented by a Unicode code point","msgtype":"m.text"},"ts":1608856423000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"How come? This seems silly.","msgtype":"m.text"},"ts":1608856477000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"Why not just take 1 char = 1 code point (integer)","msgtype":"m.text"},"ts":1608856488000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"the standard example is `é`: it can be written as either `\\u00e9` or `\\u0065\\u00301`","msgtype":"m.text"},"ts":1608856494000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"uhhhh a mix of historical reasons plus complexity of language, is my understanding","msgtype":"m.text"},"ts":1608856515000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Yes, I thought about these ă which are written as a combination of two.","msgtype":"m.text"},"ts":1608856537000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"(that `\\u00301` should be `\\u0301`)","msgtype":"m.text"},"ts":1608856540000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"there's also stuff like, emojis have modifiers like gender and skin tone, and you have to pick a canonical order for those things to appear in","msgtype":"m.text"},"ts":1608856577000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I mean, it kind of gives you the flexibility in writing a terminal I guess.","msgtype":"m.text"},"ts":1608856578000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"Like you can just send two symbols","msgtype":"m.text"},"ts":1608856601000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"You dont have to implement buffer in the terminal","msgtype":"m.text"},"ts":1608856608000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"which will combine two sent chunks of data into one single integer","msgtype":"m.text"},"ts":1608856641000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"I mean it still buffers, but doesnt have to combine as per some table","msgtype":"m.text"},"ts":1608856682000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"OK, thank you very much, you clarified all my doubts :)","msgtype":"m.text"},"ts":1608856734000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"You guys have been very helpful!!","msgtype":"m.text"},"ts":1608856743000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"devsnek, Bakkot :)","msgtype":"m.text"},"ts":1608856755000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"glad to help","msgtype":"m.text"},"ts":1608856943000,"senderName":"Bakkot","senderId":"Bakkot@irc"}
]