[
{"content":{"body":"if we get tuples in js, advent of code will become a lot easier, because a lot of their challenges use maps of (x, y)","msgtype":"m.text"},"ts":1576050739000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: why not use literals for those?","msgtype":"m.text"},"ts":1576077169000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"new Map([[x,y],[a,b]]) is often forgotten too :(","msgtype":"m.text"},"ts":1576077196000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"It is pretty easy to write an n-key map class","msgtype":"m.text"},"ts":1576086347000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: it could be easier","msgtype":"m.text"},"ts":1576087066000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"sure but you do it once and then it is done","msgtype":"m.text"},"ts":1576087077000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"depends on if the base class adds apis","msgtype":"m.text"},"ts":1576087133000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"if it adds apis you do it again","msgtype":"m.text"},"ts":1576087140000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"if it adds APIs your map will not automatically update to have those APIs, yes","msgtype":"m.text"},"ts":1576087170000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(depending on how they are implemented...)","msgtype":"m.text"},"ts":1576087179000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but no existing applications will break","msgtype":"m.text"},"ts":1576087180000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1576087188000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"even if they are implemented through delegating to existing interfaces it might be odd","msgtype":"m.text"},"ts":1576087225000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Potentially yes","msgtype":"m.text"},"ts":1576087237000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"like .has could be false but .get could return a value if we add default values that are not undefined","msgtype":"m.text"},"ts":1576087250000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"also when I've done this in the past I haven't actually done `extends Map`","msgtype":"m.text"},"ts":1576087250000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"interesting","msgtype":"m.text"},"ts":1576087257000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"(since it doesn't really keep the interface for map)","msgtype":"m.text"},"ts":1576087274000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"bradleymeck: you need identity of the x and y","msgtype":"m.text"},"ts":1576095721000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(x, y) === (x, y)","msgtype":"m.text"},"ts":1576095742000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Symbol.compositeKey would be nice~","msgtype":"m.text"},"ts":1576095744000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1576095749000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I guess there's also that frozen proposal","msgtype":"m.text"},"ts":1576095758000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that probably won't go anywhere fast though :(","msgtype":"m.text"},"ts":1576095761000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"mine/compositeKey","msgtype":"m.text"},"ts":1576095768000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"value types seem to have some momentum","msgtype":"m.text"},"ts":1576095779000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"I just hope they allow all types inside","msgtype":"m.text"},"ts":1576095907000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'd not be ok with that unless they change intent of the proposal a bit","msgtype":"m.text"},"ts":1576096478000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"though if they do change stated intent seems doable","msgtype":"m.text"},"ts":1576096487000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"it seems kinda useless if it can't hold objects tbh","msgtype":"m.text"},"ts":1576096642000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like private fields, I'd use them every once in a blue moon but not as a generalized pattern","msgtype":"m.text"},"ts":1576096670000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if serializable and stateless is the critical use case holding objects would be problematic. if immutable but allowing state is the critical use case holding refs seems fine.","msgtype":"m.text"},"ts":1576096748000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"you can have them without objects inside them even if objects are allowed","msgtype":"m.text"},"ts":1576096775000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and even then, think of JSON.serialize on an object with a function property","msgtype":"m.text"},"ts":1576096794000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"er","msgtype":"m.text"},"ts":1576096803000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"JSON.stringify","msgtype":"m.text"},"ts":1576096807000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"?","msgtype":"m.text"},"ts":1576096827000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"I don't get why one person wanting to restrict it means another person can't also use it more liberally","msgtype":"m.text"},"ts":1576096942000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"depends, but if the more liberal use makes it hard to assert the more constrained use holds true in various cases thats usually a reason","msgtype":"m.text"},"ts":1576096989000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"I mean it's a trade off either way","msgtype":"m.text"},"ts":1576097021000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the more constrained case literally makes it impossible for the more liberal use case","msgtype":"m.text"},"ts":1576097035000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yea, like you said its a trade off","msgtype":"m.text"},"ts":1576097049000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"I feel like the obvious balance would be choosing the difficult case over the impossible case","msgtype":"m.text"},"ts":1576097170000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but people consistently go the other way so ðŸ¤·","msgtype":"m.text"},"ts":1576097183000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"difficult enough to be impossible pretty much is just impossible","msgtype":"m.text"},"ts":1576097251000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"if it's an invariant of serialisation you can throw when you hit an object","msgtype":"m.text"},"ts":1576097426000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it doesn't seem too hard imo","msgtype":"m.text"},"ts":1576097434000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: the reason to disallow objects is that many people are going to look at these things and assume they can treat all of them as immutable and be bitten when that turns out to not be the case","msgtype":"m.text"},"ts":1576097818000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I didn't have that assumption","msgtype":"m.text"},"ts":1576097857000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"many other people will","msgtype":"m.text"},"ts":1576097879000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"a lot of people also assume const makes the object it holds immutable","msgtype":"m.text"},"ts":1576097933000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like probably at least one a week in ##javascript","msgtype":"m.text"},"ts":1576097946000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"should const have not been allowed to point to objects?","msgtype":"m.text"},"ts":1576097965000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I am not entirely clear on why const exists at all, in honesty","msgtype":"m.text"},"ts":1576098004000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"variables that can't change","msgtype":"m.text"},"ts":1576098077000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that is a description of the thing, not an explanation of why it exists","msgtype":"m.text"},"ts":1576098111000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"const is great, but it is definitely a confusing name","msgtype":"m.text"},"ts":1576098120000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I mean I use it as that enough to justify it as the sole reason for it's existence","msgtype":"m.text"},"ts":1576098135000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I dunno if others do","msgtype":"m.text"},"ts":1576098142000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(i like it because it conveys developer intent to not reassign a variable, which is not sufficiently conveyed by \"it doesn't happen to be reassigned at the moment\")","msgtype":"m.text"},"ts":1576098157000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"in any case my larger point was that no matter what, there will be people who don't understand features because they assume their behaviour instead of actually learning what they do","msgtype":"m.text"},"ts":1576098197000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"of course, and that's something we always have to weigh","msgtype":"m.text"},"ts":1576098232000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"here I think most people will assume it is deeply immutable","msgtype":"m.text"},"ts":1576098241000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"maybe we can make a poll or something","msgtype":"m.text"},"ts":1576098318000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the name itself is definitely bad, but I don't understand folks not taking the time to get used to it","msgtype":"m.text"},"ts":1576098478000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"we could just remove the immutability part from them","msgtype":"m.text"},"ts":1576098517000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":":P","msgtype":"m.text"},"ts":1576098523000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like, it seems that there are folks that advocate for using `let` and not `const` because `let` itself might've been a better name for what `const` does, but","msgtype":"m.text"},"ts":1576098600000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that's really upsetting to me since at the end of the day, `const`'s behavior is exactly the desirable thing, and the name can be gotten used to...","msgtype":"m.text"},"ts":1576098649000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"var was already taken though","msgtype":"m.text"},"ts":1576098650000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah that's the thing","msgtype":"m.text"},"ts":1576098656000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I love Scala's `val` / `var`","msgtype":"m.text"},"ts":1576098667000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah val's not bad","msgtype":"m.text"},"ts":1576098678000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"something I'm a little unclear of the timeline on is the existence of a `const` keyword in browsers","msgtype":"m.text"},"ts":1576098804000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I feel like it existed non-functionally prior to ES6?","msgtype":"m.text"},"ts":1576098825000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"but maybe that's some headcanon of mine that developed due to the long implementation window of ES6","msgtype":"m.text"},"ts":1576098849000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: old spidermonkey had its own const and let for awhile","msgtype":"m.text"},"ts":1576098864000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that had different semantics from ES2015's","msgtype":"m.text"},"ts":1576098869000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"eventually they fixed it","msgtype":"m.text"},"ts":1576098874000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that must be it","msgtype":"m.text"},"ts":1576098876000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"in their \"JavaScript 1.7\" thing, or whichever version","msgtype":"m.text"},"ts":1576098889000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ahh","msgtype":"m.text"},"ts":1576098896000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"old V8 also had it's own let and const","msgtype":"m.text"},"ts":1576098915000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"with weird semantics","msgtype":"m.text"},"ts":1576098915000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"they weren't allowed in strict mode","msgtype":"m.text"},"ts":1576098915000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah right that too","msgtype":"m.text"},"ts":1576098968000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i think v8's tho were early ES6 versions","msgtype":"m.text"},"ts":1576098981000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"altho maybe SM's were even earlier ones, i dunno","msgtype":"m.text"},"ts":1576098996000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'm glad node doesn't use harmony flags anymore","msgtype":"m.text"},"ts":1576099033000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lots of breakage","msgtype":"m.text"},"ts":1576099035000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"do we have a strong assertion about run to completion semantics in JS written out anywhere/what to do if a host implements a co-routine like Job Scheduler?","msgtype":"m.text"},"ts":1576101604000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"e.g. if a host is allowed to have `Promise.resolve().then(()=>{...;bar();...}); foo();` execute `bar()` before `foo()`","msgtype":"m.text"},"ts":1576102154000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"if that isn't explicitly forbidden than ES6 has a massive gap","msgtype":"m.text"},"ts":1576102247000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'm pretty sure it was a quite intentional part of promises that nothing that happens in a then callback can *ever* happen synchronously","msgtype":"m.text"},"ts":1576102271000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"TLA changes that slightly, in that if you `await` that promise before calling `foo()`, then bar can happen before foo","msgtype":"m.text"},"ts":1576102305000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: i'm staring at https://github.com/nodejs/node/pull/30891","msgtype":"m.text"},"ts":1576102420000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: i mean, `require()` can already \"sleep\" if the module wants it too","msgtype":"m.text"},"ts":1576102464000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"bradleymeck: via node addons","msgtype":"m.text"},"ts":1576102467000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: thats different though. that PR lets you unwind promises","msgtype":"m.text"},"ts":1576102489000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"oh right true","msgtype":"m.text"},"ts":1576102495000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"sleep/atomics is fine","msgtype":"m.text"},"ts":1576102499000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"even execSync is probably fine since it isn't using exposed machinery even though it does nest JS","msgtype":"m.text"},"ts":1576102529000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"but JS that can't share an env","msgtype":"m.text"},"ts":1576102657000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it kind of does due to the streams impl","msgtype":"m.text"},"ts":1576102969000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"but not from the process","msgtype":"m.text"},"ts":1576102976000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"it just inlines an event loop to resolve streams events","msgtype":"m.text"},"ts":1576102990000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"which aren't under the promise-like invariants","msgtype":"m.text"},"ts":1576103001000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"that isn't really exposing that stuff to userland though so ðŸ¤·","msgtype":"m.text"},"ts":1576103095000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: it could never execute the inner bit first","msgtype":"m.text"},"ts":1576104835000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the only thing possible is if foo pumped the event loop, it would happen *during*","msgtype":"m.text"},"ts":1576104854000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but never *before*","msgtype":"m.text"},"ts":1576104859000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually","msgtype":"m.text"},"ts":1576104885000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I don't know if foo pumping the event loop is allowed","msgtype":"m.text"},"ts":1576104893000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I hope it isn't","msgtype":"m.text"},"ts":1576104896000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm not clear on that, if you require out of the inner loop and grab the outer promise and await it","msgtype":"m.text"},"ts":1576104900000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"it looks like it would resolve","msgtype":"m.text"},"ts":1576104912000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"thinks this is esoteric","msgtype":"m.emote"},"ts":1576104938000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"I think it's safe to assume nothing will ever do that","msgtype":"m.text"},"ts":1576104986000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i never thought modules would delete themselves from require.cache at one point, but they do","msgtype":"m.text"},"ts":1576105064000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i can imagine finding an easier way to do this kind of forced resolve being possible but not obvious","msgtype":"m.text"},"ts":1576105091000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"}
]