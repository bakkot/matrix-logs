[
{"content":{"body":"hmm, the spec language is confusing me, but it looks like `OptionalChain [ Expression ]`, `OptionalChain . IdentifierName` and `OptionalChain Arguments` prevent short-circuiting?","msgtype":"m.text"},"ts":1569986809000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"Jessidhia: unsure how much channel history you have, but there's a big long convo between me and rkirsling about it","msgtype":"m.text"},"ts":1569987214000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hmm, nvm; for example `IdentifierName ?. IdentifierName Arguments` would parse as `OptionalExpression(MemberExpression(PrimaryExpression) OptionalChain(OptionalChain(?. IdentifierName) Arguments)`, and the OptionalExpression would short-circuit if the MemberExpression is not non-nullish","msgtype":"m.text"},"ts":1569987231000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"also.... https://github.com/engine262/engine262/blob/master/src/parse.mjs#L147-L185","msgtype":"m.text"},"ts":1569987241000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I just saw this comment on a (now-locked) issue in typescript and had to do a double take to make sure I understood things right https://github.com/microsoft/TypeScript/issues/16#issuecomment-524498719","msgtype":"m.text"},"ts":1569987395000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"unsure why they used ?. for setAttribute","msgtype":"m.text"},"ts":1569987454000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but that is the syntax","msgtype":"m.text"},"ts":1569987457000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah, that is the syntax; the double-take is that (assuming they always expected an Element there, if present) it looks as if it doesn't short-circuit","msgtype":"m.text"},"ts":1569987512000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"Jessidhia: I think that part is just the part that requires getting the word out about","msgtype":"m.text"},"ts":1569988461000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah, trying to make sense of things; it now looks to me `OptionalChain` is there more for grammar reasons to prevent `MemberExpression`/`CallExpression` from matching than to actually have any bearing on the semantics; the real \"meat\" is `OptionalExpression`","msgtype":"m.text"},"ts":1569988541000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"yeah, both of us initially found it tricky to read too ðŸ˜“","msgtype":"m.text"},"ts":1569988623000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1569988675000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"which isn't to say I had a better suggestion for an equivalent organization (my understanding is that it was originally even more complicated)","msgtype":"m.text"},"ts":1569988734000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"its basically just a copy of MemberExpression","msgtype":"m.text"},"ts":1569988742000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but it boils down to that, lexically, an OptionalChain is a *normal* access/chain starting with exactly one ?","msgtype":"m.text"},"ts":1569988779000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"and then the OptionalExpression connects that to its LHS, meaning that there's ultimately the same number of those nodes too","msgtype":"m.text"},"ts":1569988880000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Jessidhia: maybe someone on the TS team can edit that comment to remove the unnecessary `?.` on setAttribute","msgtype":"m.text"},"ts":1569988903000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but OptionalChain is what makes the whole chain evaluation (and thus short-circuiting) semantics possible","msgtype":"m.text"},"ts":1569988907000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"also wrt TS in particular, this seems to be in order: https://github.com/microsoft/TypeScript/pull/33294","msgtype":"m.text"},"ts":1569988926000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"tfw you notice a typo `OptionalExpressoin`","msgtype":"m.text"},"ts":1569988936000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: wait where lol","msgtype":"m.text"},"ts":1569988968000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"oh my code","msgtype":"m.text"},"ts":1569988975000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not ts","msgtype":"m.text"},"ts":1569988976000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ahh :P","msgtype":"m.text"},"ts":1569988980000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"anyway the \"Optional Chains\" section of that PR description is relevant","msgtype":"m.text"},"ts":1569989000000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"there is a typo though","msgtype":"m.text"},"ts":1569989004000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"`a?.b(); // call chain` should be something like `a?.().b; // call chain` instead","msgtype":"m.text"},"ts":1569989034000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(^ cc rbuckton )","msgtype":"m.text"},"ts":1569989042000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"er also \"optional expression\" in that description is not the spec OptionalExpression but that's inevitable","msgtype":"m.text"},"ts":1569989124000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the spec nodes simply don't correspond to the \"pieces\" of the expression from a user's perspective (or, hell, even from an implementer's perspective)","msgtype":"m.text"},"ts":1569989225000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"e.g. this is how I'd represent the \"a.b?.c.d?.e.f\" example in JSX, if it helps https://www.irccloud.com/pastebin/kYP9Kd4z/","msgtype":"m.text"},"ts":1569989251000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"mmm but like `?.e` isn't a node in itself","msgtype":"m.text"},"ts":1569989344000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"errrr wait","msgtype":"m.text"},"ts":1569989386000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"?.e is an OptionalChain node with nothing on the left-hand side","msgtype":"m.text"},"ts":1569989404000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"agh sorry I'd forgotten which way that recurses","msgtype":"m.text"},"ts":1569989410000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"like, I had seen OptionalChain as greedily eating anything to its left, which it does, but it \"stops\" once its left-hand-side no longer parses as an OptionalChain, at which point it matches OptionalExpression instead","msgtype":"m.text"},"ts":1569989497000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"yeah your snippet is correct, apologies","msgtype":"m.text"},"ts":1569989502000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"and then you can just jump over the entire chain","msgtype":"m.text"},"ts":1569989526000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"by not evaluating it","msgtype":"m.text"},"ts":1569989533000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1569989536000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1569989547000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"it's all for the good of the surface semantics ðŸ˜…","msgtype":"m.text"},"ts":1569989577000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"OptionalChain will greedily evaluate everything but because it lets OptionalExpression itself evaluate the LHS _first_, it's OptionalExpression that does the work of not running the OptionalChain","msgtype":"m.text"},"ts":1569989581000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"right.","msgtype":"m.text"},"ts":1569989622000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"its crazy how much simpler this all is in actual implementations","msgtype":"m.text"},"ts":1569989635000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it actually is","msgtype":"m.text"},"ts":1569989642000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the way I see it, OptionalChain pretty much could just be MemberExpression/CallExpression if not for the fact that you need it to stop matching at \"the boundary\"","msgtype":"m.text"},"ts":1569989651000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"(except for JSC's function call node menagerie)","msgtype":"m.text"},"ts":1569989656000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1569989676000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"er wait what if the `?.` token were raised to being part of each OptionalExpression production","msgtype":"m.text"},"ts":1569989806000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"uh nope that's only half of a thought and not even a whole one, never mind","msgtype":"m.text"},"ts":1569989850000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah, I just tried to see if I could make it fit but then `MemberExpression '?.' MemberExpression` would fail if the Identifier on the right side of the '?.' was a reserved name","msgtype":"m.text"},"ts":1569989942000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"hmm, probably the most obvious follow-up proposal to this would be adding a `?:` version of `PropertyName: BindingElement` ðŸ¤”","msgtype":"m.emote"},"ts":1569997200000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"`const { a: { b?: { c } } } = d` which would skip evaluating the pattern on the RHS of `b?:` if it's null/undefined, while still creating the `c` binding","msgtype":"m.text"},"ts":1569997315000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"you can currently do that by declaring a `= {}` initializer for the elements you want to be optional (`{ b: { c } = {} }`) but that creates a throwaway object for the sole purpose of avoiding a TypeError","msgtype":"m.text"},"ts":1569997363000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"hm, that has more consequences than I thought. Clearly `c` can't stay in TDZ after the `const` runs to completion so it needs to be initialized with something (well, `undefined` here). But if something in a destructuring pattern would \"receive\" an `undefined`, it can evaluate the Initializer if present. Even if there was short circuiting these initializers would still need to run. ðŸ¤”","msgtype":"m.text"},"ts":1569997589000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"I have no idea what the equivalent could be for an array pattern. A `?` suffix?","msgtype":"m.text"},"ts":1569997663000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"const [a, { b }?] = c","msgtype":"m.text"},"ts":1569998015000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"and this opens another question... throw if iterating `c` produces less than 2 elements, or treat it as the null/undefined case?","msgtype":"m.text"},"ts":1569998088000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"oh, iterator destructuring with insufficient values no longer throws? I thought it did at one point","msgtype":"m.text"},"ts":1569998502000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"afaik it only throws if you try to iterate a non iterable","msgtype":"m.text"},"ts":1570021352000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah, I vaguely remember it throwing if the iterable ended prematurely, but maybe it was a bug or I'm misremembering","msgtype":"m.text"},"ts":1570026550000,"senderName":"Jessidhia","senderId":"Jessidhia@irc"},
{"content":{"body":"bterlson i just encountered that :(","msgtype":"m.text"},"ts":1570031689000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"bterlson (I also dont have access to the delegates channel)","msgtype":"m.text"},"ts":1570031715000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"littledan: ljharb: there's an unused `status` variable from the uint32 change","msgtype":"m.text"},"ts":1570032241000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(Note to self: look for unused variables.)","msgtype":"m.text"},"ts":1570032307000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1570032328000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there's something rather poetic about eslint catching spec bugs","msgtype":"m.text"},"ts":1570032346000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: sounds like a great thing to follow up on in an editorial PR. Good catch","msgtype":"m.text"},"ts":1570032416000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"ljharb: unflagged globalThis in engine262 ðŸŽ‰","msgtype":"m.text"},"ts":1570032444000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"mind you, there'll be a lot of 'false' positives: a lot of SDO defns ignore the parameter(s)","msgtype":"m.text"},"ts":1570032462000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"devsnek: yay","msgtype":"m.text"},"ts":1570032651000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: and for the unused var, please do file a PR :-D","msgtype":"m.text"},"ts":1570032661000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"aggregate error's toString is going to kill so many error formatting things","msgtype":"m.text"},"ts":1570032926000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"things that check if o.toString === Error.prototype.toString, doing Error.prototype.toString.call(o), etc","msgtype":"m.text"},"ts":1570032950000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"mathiasbynens: is there any difference between Error.prototype.toString and AggregateError.prototype.toString?","msgtype":"m.text"},"ts":1570033241000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: the message it's supposed to produce should be different; namely that the errors should be represented somehow","msgtype":"m.text"},"ts":1570033299000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"is https://tc39.es/proposal-promise-any/ outdated?","msgtype":"m.text"},"ts":1570033316000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rn toString is the same exact steps as far as i can tell","msgtype":"m.text"},"ts":1570033326000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think it recently got changed to end up being the same","msgtype":"m.text"},"ts":1570033421000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"althooooo","msgtype":"m.text"},"ts":1570033428000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if errors moves to a slot, then Error.prototype.toString could be modified to check for that slot","msgtype":"m.text"},"ts":1570033441000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(even if it's just mentioning it in a note telling implementers to include it in the message somehow)","msgtype":"m.text"},"ts":1570033454000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that seems ideal to me","msgtype":"m.text"},"ts":1570033478000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: https://github.com/tc39/ecma262/pull/1717/files","msgtype":"m.text"},"ts":1570047120000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this is likely a hacktoberfest pr","msgtype":"m.text"},"ts":1570047126000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not spam","msgtype":"m.text"},"ts":1570047128000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"based on hacktoberfest's rules, that's still not a PR that should count","msgtype":"m.text"},"ts":1570047142000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"thats absolutely untrue","msgtype":"m.text"},"ts":1570047149000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and this is a problem every year with hacktoberfest; these PRs are spam","msgtype":"m.text"},"ts":1570047153000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"spelling/linting/etc are valuable","msgtype":"m.text"},"ts":1570047159000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: https://hacktoberfest.digitalocean.com/details#quality-standards","msgtype":"m.text"},"ts":1570047169000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"this isn't either","msgtype":"m.text"},"ts":1570047171000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it's at best, a stylistic preference that is unsolicited and not previously confirmed with maintainers","msgtype":"m.text"},"ts":1570047188000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i think you're being a bit harsh","msgtype":"m.text"},"ts":1570047196000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"my first pr to node fixed the spelling of a single word","msgtype":"m.text"},"ts":1570047205000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ugh this is the first time I'm hearing of Hacktoberfest and it sounds terrible","msgtype":"m.text"},"ts":1570047244000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"its not that terrible :(","msgtype":"m.text"},"ts":1570047333000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"plus a lot of schools and stuff are getting into it now","msgtype":"m.text"},"ts":1570047360000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like hour of code","msgtype":"m.text"},"ts":1570047363000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: nah spelling of words is fine","msgtype":"m.text"},"ts":1570047428000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"its not like we have a huge volume of active prs either","msgtype":"m.text"},"ts":1570047450000,"senderName":"devsnek","senderId":"devsnek@irc"}
]