[
{"content":{"body":":w","msgtype":"m.text"},"ts":1594599975000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oops","msgtype":"m.text"},"ts":1594599981000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: new variable declarator kind?","msgtype":"m.text"},"ts":1594665632000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: hmm?","msgtype":"m.text"},"ts":1594665645000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"def {x,y} = pt; pt.translate(1,1); def {x,y} = pt;","msgtype":"m.text"},"ts":1594665674000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"though questions of shadowing get confusing due to JS having hoisting","msgtype":"m.text"},"ts":1594665688000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"is that just a re-declareable var?","msgtype":"m.text"},"ts":1594665721000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"*let, sorry","msgtype":"m.text"},"ts":1594665724000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1594665729000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that's what i originally suggested","msgtype":"m.text"},"ts":1594665733000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i feel like there's a stage 1 proposal here","msgtype":"m.text"},"ts":1594665739000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"agree with bradleymeck on hoisting","msgtype":"m.text"},"ts":1594665934000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"seems very confusing given hoisting. which one gets closed over?","msgtype":"m.text"},"ts":1594665948000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: i mean, thats the only real complaint left with the repl goal","msgtype":"m.text"},"ts":1594665955000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"in other languages it is via source location, which honestly would be fine, but diff problem than repl has","msgtype":"m.text"},"ts":1594665991000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"the rule i'm imagining is","msgtype":"m.text"},"ts":1594666129000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if the code would cause a redeclaration error","msgtype":"m.text"},"ts":1594666139000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"make it valid","msgtype":"m.text"},"ts":1594666144000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"leave everything else untouched","msgtype":"m.text"},"ts":1594666151000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so they point to the same storage?","msgtype":"m.text"},"ts":1594666161000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"thats what v8 did for making their repl design doc","msgtype":"m.text"},"ts":1594666177000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i think either they're the same variable or you invalidate the old ones","msgtype":"m.text"},"ts":1594666212000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"invalidating seems needlessly annoying","msgtype":"m.text"},"ts":1594666219000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`sudo let x`","msgtype":"m.text"},"ts":1594666233000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: üëè","msgtype":"m.text"},"ts":1594666296000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"could also reassign consts that way","msgtype":"m.text"},"ts":1594666378000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`sudo eval = undefined`","msgtype":"m.text"},"ts":1594666402000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"proposal: make const less constant","msgtype":"m.text"},"ts":1594666406000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"free me of linter errors!","msgtype":"m.text"},"ts":1594666419000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"proposal: `let const`","msgtype":"m.text"},"ts":1594666423000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"also `const mut`","msgtype":"m.text"},"ts":1594666430000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`let let let = 1` gasp a new tier","msgtype":"m.text"},"ts":1594666441000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"why is redeclaring important in js exactly?","msgtype":"m.text"},"ts":1594666460000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i think it is just convenient in other langs","msgtype":"m.text"},"ts":1594666474000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"that was the point","msgtype":"m.text"},"ts":1594666478000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"do these other langs have types and benefit from being able to shadow a same-named declaration with a differently typed one?","msgtype":"m.text"},"ts":1594666490000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I think this is just a repl impl issue","msgtype":"m.text"},"ts":1594666496000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ah, for repls that makes sense","msgtype":"m.text"},"ts":1594666502000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"redecl in a static file is bad news","msgtype":"m.text"},"ts":1594666504000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(I'm not representing the discussion here though, that's just my view)","msgtype":"m.text"},"ts":1594666528000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"shu: i just hate putting destructuring reassignments in parens","msgtype":"m.text"},"ts":1594666563000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ts users could benefit from the type thing you mentioned though","msgtype":"m.text"},"ts":1594666576000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rust allows that too and its very nice","msgtype":"m.text"},"ts":1594666587000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ohhh that was your motivation","msgtype":"m.text"},"ts":1594666590000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the destructuring thing doesn't seem that compelling to me","msgtype":"m.text"},"ts":1594666600000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the TS one i have to think about","msgtype":"m.text"},"ts":1594666605000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah this is like","msgtype":"m.text"},"ts":1594666626000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"a nit of a feature","msgtype":"m.text"},"ts":1594666631000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I'm kind of unclear on why type-shadowing wouldn't be dangerous though","msgtype":"m.text"},"ts":1594666636000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"which is why i didn't think it warranted new syntax","msgtype":"m.text"},"ts":1594666640000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it might be dangerous in ts due to the laxness of its type system","msgtype":"m.text"},"ts":1594666667000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or maybe taken in stride","msgtype":"m.text"},"ts":1594666681000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rkirsling: the *only* case where it's kind of legit, and probably the one devsnek ran into in Torque, V8's DSL, is where you cast an argument","msgtype":"m.text"},"ts":1594666683000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ah yeah that's the same as rust","msgtype":"m.text"},"ts":1594666700000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh from something void*-esque to what it really is?","msgtype":"m.text"},"ts":1594666713000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"e.g., in pseudo-ish code `function f(xArg: Any) { let x = Cast<T>(xArg); }`","msgtype":"m.text"},"ts":1594666715000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yes exactly","msgtype":"m.text"},"ts":1594666718000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1594666720000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i don't know of other places where shadowing with different type is a good idea","msgtype":"m.text"},"ts":1594666731000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"except you can do `x: Any` and `let x = Cast<T>(x)`","msgtype":"m.text"},"ts":1594666733000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that is far from sufficient motivation for allowing redecls in general imo","msgtype":"m.text"},"ts":1594666751000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah its not like the most revolutionary deature","msgtype":"m.text"},"ts":1594666760000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that's kind of surprising even without the redecl though","msgtype":"m.text"},"ts":1594666761000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"feature*","msgtype":"m.text"},"ts":1594666763000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that `{ let x = ... x ...;} ` is allowed","msgtype":"m.text"},"ts":1594666779000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah actually with JS's parameter scope rules that isn't a redeclaration","msgtype":"m.text"},"ts":1594666798000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"its not valid due to tdz though","msgtype":"m.text"},"ts":1594666838000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually in strict mode its also invalid to declare the name","msgtype":"m.text"},"ts":1594666846000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or maybe all modes","msgtype":"m.text"},"ts":1594666876000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah all modes","msgtype":"m.text"},"ts":1594666886000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"at top-level function scope sure, but you could block it","msgtype":"m.text"},"ts":1594666890000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"can't get around the TDZ though","msgtype":"m.text"},"ts":1594666910000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"anyway yeah this is one of those features that's too small to feel justified","msgtype":"m.text"},"ts":1594666917000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1594666922000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"we could add it in variables v3","msgtype":"m.text"},"ts":1594666951000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1594666969000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(`val` and `val mut`, eta 2030)","msgtype":"m.text"},"ts":1594666974000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if this wasn't about redecl and was simply about destructuring assignment to existing bindings then maybe there's something there","msgtype":"m.text"},"ts":1594666979000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"but only if it didn't add to the syntax budget","msgtype":"m.text"},"ts":1594666994000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"which seems unlikely to achieve","msgtype":"m.text"},"ts":1594667000000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"right if you want to separate those two item","msgtype":"m.text"},"ts":1594667008000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"items","msgtype":"m.text"},"ts":1594667009000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek if you don't like parens for destructuring you can use `0,` instead","msgtype":"m.text"},"ts":1594667491000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`let x; 0,{ x } = { x: 1 };","msgtype":"m.text"},"ts":1594667505000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's almost worse","msgtype":"m.text"},"ts":1594667508000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's better 'cause it's local!","msgtype":"m.text"},"ts":1594667518000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"though it makes me wonder","msgtype":"m.text"},"ts":1594667521000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`void`?","msgtype":"m.text"},"ts":1594667523000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i.e. you don't have to put parens at the end","msgtype":"m.text"},"ts":1594667526000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"omg are you kidding me","msgtype":"m.text"},"ts":1594667536000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I am not entirely serious, no","msgtype":"m.text"},"ts":1594667554000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that really binds as `(void { a }) = 1`?","msgtype":"m.text"},"ts":1594667554000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1594667557000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sad times","msgtype":"m.text"},"ts":1594667566000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"assignment expressions are very low precedence","msgtype":"m.text"},"ts":1594667567000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh god the comma","msgtype":"m.text"},"ts":1594667577000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"what a truly horrific invention","msgtype":"m.text"},"ts":1594667612000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"you know I was pretty much joking but looking at it it's kind of growing on me","msgtype":"m.text"},"ts":1594667648000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that \"horrific invention\" is the basis of minifiers, have some RESPECT","msgtype":"m.text"},"ts":1594667654000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lolol","msgtype":"m.text"},"ts":1594667665000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ok new proposal idea","msgtype":"m.text"},"ts":1594667735000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"somehow allow `void AssignmentExpression`","msgtype":"m.text"},"ts":1594667768000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you could allow it in statement position easily enough, I think","msgtype":"m.text"},"ts":1594667933000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"tricker in expression position","msgtype":"m.text"},"ts":1594667944000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or, well, it might be easy I'm just less sure if the obvious thing would work","msgtype":"m.text"},"ts":1594667959000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and can more readily convince myself it works in statement position","msgtype":"m.text"},"ts":1594667976000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: lol I shared that with a colleague and he was like \"if only it worked for `() => 0,{ bar: 42 }`\"","msgtype":"m.text"},"ts":1594667985000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling ha","msgtype":"m.text"},"ts":1594667992000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that one I am happy to write the parens","msgtype":"m.text"},"ts":1594668016000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and also happy that comma doesn't work","msgtype":"m.text"},"ts":1594668029000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"agreed, just made me laugh","msgtype":"m.text"},"ts":1594668048000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that comma works perfectly don't @ me","msgtype":"m.text"},"ts":1594668115000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: are you worried about people setting really high maximum values on resizable buffers in order to get around the resize limit","msgtype":"m.text"},"ts":1594673275000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"s/resize limit/maximum size limit/","msgtype":"m.text"},"ts":1594673291000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"This is not slack but I basically need some @channel for the broad message:","msgtype":"m.text"},"ts":1594673362000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"i feel like the primary use case for resizing is that you don't know what the maximum will be","msgtype":"m.text"},"ts":1594673368000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if you consume Test262, please read this: https://github.com/tc39/test262/issues/2699","msgtype":"m.text"},"ts":1594673369000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"devsnek: not really, why?","msgtype":"m.text"},"ts":1594673380000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"like i said above","msgtype":"m.text"},"ts":1594673403000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't think wasm requires a maximum limit either","msgtype":"m.text"},"ts":1594673421000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it does for shared","msgtype":"m.text"},"ts":1594673452000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but that doesn't answer why i might be worried about people setting really high maximum values?","msgtype":"m.text"},"ts":1594673473000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"cuz that's how you would get around the problem","msgtype":"m.text"},"ts":1594673497000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and browsers might not want people falling into that pattern","msgtype":"m.text"},"ts":1594673520000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"idk","msgtype":"m.text"},"ts":1594673523000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't understand the full concern, that because applications do not know ahead of time what their max buffer size is, they will reserve something huge?","msgtype":"m.text"},"ts":1594673558000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and that reserving something huge is bad because... they cause their own application to run out of address space?","msgtype":"m.text"},"ts":1594673586000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"right, that seems like a bad pattern","msgtype":"m.text"},"ts":1594673592000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that seems no worse than if someone wants to do that today, they would either commit to a huge buffer today","msgtype":"m.text"},"ts":1594673621000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"or they keep making new buffers and copying","msgtype":"m.text"},"ts":1594673628000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"well the point of resizing is that you don't commit to huge","msgtype":"m.text"},"ts":1594673634000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't get this","msgtype":"m.text"},"ts":1594673637000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you commit to the address range, but you do not commit to the actual memory","msgtype":"m.text"},"ts":1594673652000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"what do you not get? did you read the motivation?","msgtype":"m.text"},"ts":1594673670000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1594673680000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is there a part of the motivation that you don't understand, or you disagree with the motivation?","msgtype":"m.text"},"ts":1594673694000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ok so for example","msgtype":"m.text"},"ts":1594673695000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i have this package called earl","msgtype":"m.text"},"ts":1594673701000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that converts js values into erlang term format buffers","msgtype":"m.text"},"ts":1594673711000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ideally you start smallish and only grow if needed","msgtype":"m.text"},"ts":1594673732000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the main performance hit rn is growing, i have to allocate a new buffer and copy everything over","msgtype":"m.text"},"ts":1594673755000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"resizing sounds great","msgtype":"m.text"},"ts":1594673762000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for that use case, is it important that you keep the identify of the ArrayBuffer the same?","msgtype":"m.text"},"ts":1594673774000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"no","msgtype":"m.text"},"ts":1594673781000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"then you should be using transfer() which i am reviving as part of this proposal","msgtype":"m.text"},"ts":1594673789000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Resizable buffers are for in-place grwoth","msgtype":"m.text"},"ts":1594673796000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"if your issue is you need zero-copy growth, realloc semantics are sufficient, and that should be used instead","msgtype":"m.text"},"ts":1594673812000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so realloc is possible?","msgtype":"m.text"},"ts":1594673839000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what do you mean by \"possible\"?","msgtype":"m.text"},"ts":1594673849000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"your explainer says that realloc is bad because xyz and so you want to avoid it","msgtype":"m.text"},"ts":1594673899000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which is fine","msgtype":"m.text"},"ts":1594673907000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but if transfer doesn't avoid it","msgtype":"m.text"},"ts":1594673950000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"then why are you avoiding it with resize","msgtype":"m.text"},"ts":1594673956000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"because there are two use cases","msgtype":"m.text"},"ts":1594674007000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"1) an in-place growable buffer like wasm has, so that an underlying buffer can grow without requiring buffers and TA views be remade. that use case requires the identities of the buffers and TAs to stay the same. related is the webgpu re-pointing use case","msgtype":"m.text"},"ts":1594674068000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"2) realloc for arbitrary growing and shrinking, avoiding copying where possible. this use case doesn't care about the identity of the buffers and TAs and can make new JS objects if needed","msgtype":"m.text"},"ts":1594674110000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i don't get why these are exclusive","msgtype":"m.text"},"ts":1594674147000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"semantically, they are not. implementation and security experience says otherwise","msgtype":"m.text"},"ts":1594674172000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"is there some inherent thing about security and the identity of the object i'm missing","msgtype":"m.text"},"ts":1594674179000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the implementation and security thing boils down to what i said in the explainer, that you want to be able to implement the first use case as not moving the underlying data pointer","msgtype":"m.text"},"ts":1594674205000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but if they *can* move","msgtype":"m.text"},"ts":1594674219000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if the underlying data pointer can move, you have perf cliffs, extra security risk to make sure you don't have stale data pointers, etc","msgtype":"m.text"},"ts":1594674222000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ah ok","msgtype":"m.text"},"ts":1594674250000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"detaching was a huge security bug farm","msgtype":"m.text"},"ts":1594674262000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so its specifically, moving with the same object identity","msgtype":"m.text"},"ts":1594674285000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if you allow general data pointer moves, which is a much larger surface than \"data pointer or null\", it puts security folks on edge","msgtype":"m.text"},"ts":1594674291000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yep","msgtype":"m.text"},"ts":1594674293000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"got it","msgtype":"m.text"},"ts":1594674300000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ok one other question","msgtype":"m.text"},"ts":1594674316000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shoot","msgtype":"m.text"},"ts":1594674326000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"you mention the wasm detach problem in the motivation section","msgtype":"m.text"},"ts":1594674338000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"about how you have to check every time you read if the buffer was detached","msgtype":"m.text"},"ts":1594674347000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is that solved with this? i didn't see anything but maybe i missed it","msgtype":"m.text"},"ts":1594674369000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"good question, i didn't outline the solution in the explainer since. it's solved with the JS integration exposing a new API that uses growable buffers","msgtype":"m.text"},"ts":1594674410000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so its still on wasm to provide some sort of hook, ok","msgtype":"m.text"},"ts":1594674426000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"no hook","msgtype":"m.text"},"ts":1594674432000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but right now, when you ask for a wasm memory, you get an AB back. i doubt that can be changed to return a ResizableAB and be web compat","msgtype":"m.text"},"ts":1594674450000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it couldn't be a resizableAB anyway","msgtype":"m.text"},"ts":1594674465000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"wasm memories don't have to have an upper limit","msgtype":"m.text"},"ts":1594674471000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there can be a new API where the wasm JS api gives you a ResizableAB, which emscripten would use","msgtype":"m.text"},"ts":1594674485000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"in practice there is, surely, set it at that","msgtype":"m.text"},"ts":1594674492000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i doubt most compilers emit an upper limit","msgtype":"m.text"},"ts":1594674515000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the emscripten team has told me this would solve their issue, at least","msgtype":"m.text"},"ts":1594674521000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i imagine not having a limit can be reported as like, 3gb when exposed to JS","msgtype":"m.text"},"ts":1594674569000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"that can a contract for emscripten output, i imagine","msgtype":"m.text"},"ts":1594674585000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but then 3gb of your heap is reserved","msgtype":"m.text"},"ts":1594674589000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if you did that more than once in node you'd get an OOM","msgtype":"m.text"},"ts":1594674606000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that is not observable? and it also is in practice","msgtype":"m.text"},"ts":1594674609000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"where possible wasm memory bounds checks are implemented with guard pages + segfault handler, and doing so reserves the virtual memory range","msgtype":"m.text"},"ts":1594674701000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"perhaps you are confusing virtual memory reservation and getting them backed by physical memory","msgtype":"m.text"},"ts":1594674737000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"if you make two reservations","msgtype":"m.text"},"ts":1594674767000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"each 3gb or so","msgtype":"m.text"},"ts":1594674776000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if you are running the engine in 32bit, you've exhausted your vm range and are shit out of luck","msgtype":"m.text"},"ts":1594674796000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"if you are running the engine in 64bit, you're probably fine","msgtype":"m.text"},"ts":1594674804000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but the v8 heap is only so large","msgtype":"m.text"},"ts":1594674823000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what do you mean by the v8 heap?","msgtype":"m.text"},"ts":1594674832000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the GC heap is not the process heap","msgtype":"m.text"},"ts":1594674839000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the place where all the stuff is stored","msgtype":"m.text"},"ts":1594674839000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there are several places :)","msgtype":"m.text"},"ts":1594674847000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the place where all the heap objects are stored","msgtype":"m.text"},"ts":1594674859000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"buffer backing stores are not allocated on the GC heap","msgtype":"m.text"},"ts":1594674859000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1594674870000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"interesting","msgtype":"m.text"},"ts":1594674873000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't think any engine does that?","msgtype":"m.text"},"ts":1594674877000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so they're just out in process memory?","msgtype":"m.text"},"ts":1594674912000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's hookable by the embedder depending on where they need the buffer to be, but yes they're externally managed","msgtype":"m.text"},"ts":1594674933000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"could be mmap'd directly","msgtype":"m.text"},"ts":1594674937000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"interesting","msgtype":"m.text"},"ts":1594674943000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's hard to get a contiguous address range otherwise","msgtype":"m.text"},"ts":1594674954000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i just figured most arraybuffers were usually small","msgtype":"m.text"},"ts":1594674970000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the GC heap can't be reserve contiguous gig+ ranges just in case an app needs it, for instance","msgtype":"m.text"},"ts":1594674976000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"nope","msgtype":"m.text"},"ts":1594674978000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i think there's probably a bimodal distribution of buffer sizes","msgtype":"m.text"},"ts":1594674989000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"given asmjs and wasm","msgtype":"m.text"},"ts":1594674994000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"well wasm in itself is probably bimodal","msgtype":"m.text"},"ts":1594675018000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"its either tiny canvas app or firefox running inside firefox","msgtype":"m.text"},"ts":1594675033000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"anyway this is starting to make more sense","msgtype":"m.text"},"ts":1594675051000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"thumbs up","msgtype":"m.text"},"ts":1594675058000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"gotta run, bbl","msgtype":"m.text"},"ts":1594675077000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"üëãüèª","msgtype":"m.text"},"ts":1594675080000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"leobalter: I consume test262 in ~half a dozen projects and they will all need to be updated to point to main instead of master unless github supports redirecting branches, but I don't expect that to be all that much work","msgtype":"m.text"},"ts":1594675335000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Thanks Bakkot! Idk how to name it in that list so I'll have your name :)","msgtype":"m.text"},"ts":1594675376000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"Bakkot: leobalter: iirc one thing you can do is point to \"HEAD\" and it'll always point to the default branch","msgtype":"m.text"},"ts":1594675379000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's not the same as github supporting redirection for web URLs (which is still critically important) but it should suffice for tooling","msgtype":"m.text"},"ts":1594675397000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: too many thinks directly pointing to master","msgtype":"m.text"},"ts":1594675414000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"in the import process","msgtype":"m.text"},"ts":1594675419000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"or linking (which is worse)","msgtype":"m.text"},"ts":1594675425000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"leobalter: what i mean is, the tools can all update from master to HEAD and they'll work moving forward, regardless of the default branch name (or the availability of an alternate name)","msgtype":"m.text"},"ts":1594675648000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"FWIW is to set a plan to completely delete the master branch, so I need people to know we are doing this change","msgtype":"m.text"},"ts":1594675845000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"I think it might be better to lean harder on GitHub for updates on how soon they plan to deploy redirection","msgtype":"m.text"},"ts":1594676593000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i agree","msgtype":"m.text"},"ts":1594676752000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so here's a question","msgtype":"m.text"},"ts":1594684100000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"if we're inclined to discouraging direct eval","msgtype":"m.text"},"ts":1594684118000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"how come we let it apply to lexical scopes too?","msgtype":"m.text"},"ts":1594684139000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"seems like some bud-nipping could've been done when introducing let/const","msgtype":"m.text"},"ts":1594684217000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"making direct eval do something more complicated than evaluate the code it's passed in the context it's in seems like it would be worse","msgtype":"m.text"},"ts":1594684250000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"at least the current state is possible to explain","msgtype":"m.text"},"ts":1594684256000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"hmm it's possible I haven't thought it through enough but","msgtype":"m.text"},"ts":1594684300000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I was just thinking in terms of like","msgtype":"m.text"},"ts":1594684315000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"if vars hoist through blocks then it would seem like direct eval's visibility could be similarly scoped to the containing function","msgtype":"m.text"},"ts":1594684374000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I mean I guess that would amount to creating a more awful thing just for the sake of discouraging its use though","msgtype":"m.text"},"ts":1594684580000,"senderName":"rkirsling","senderId":"rkirsling@irc"}
]