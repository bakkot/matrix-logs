[
{"content":{"body":"oh, well then","msgtype":"m.text"},"ts":1564486689000,"senderName":"MJCD","senderId":"MJCD@irc"},
{"content":{"body":"howdoi, ljharb, devsnek ignore that then haha","msgtype":"m.text"},"ts":1564486705000,"senderName":"MJCD","senderId":"MJCD@irc"},
{"content":{"body":"ljharb: is aware of compare and equals MJCD :-)","msgtype":"m.text"},"ts":1564487316000,"senderName":"howdoi","senderId":"howdoi@irc"},
{"content":{"body":"I am interested in their opinion","msgtype":"m.text"},"ts":1564487336000,"senderName":"MJCD","senderId":"MJCD@irc"},
{"content":{"body":"but that wasn't why I was trying to assemble","msgtype":"m.text"},"ts":1564487347000,"senderName":"MJCD","senderId":"MJCD@irc"},
{"content":{"body":"##javascript the other day was sooo clogged with proposal talk","msgtype":"m.text"},"ts":1564487370000,"senderName":"MJCD","senderId":"MJCD@irc"},
{"content":{"body":"now I can send them over here ^_^","msgtype":"m.text"},"ts":1564487381000,"senderName":"MJCD","senderId":"MJCD@irc"},
{"content":{"body":"Sigh, new Math weirdness. hypot(Infinity, NaN) returns Infinity and pow(NaN, 0) returns 1, presumably under the logic that replacing the NaN with any Number wouldn't affect the result. But max(Infinity, NaN) and min(-Infinity, NaN) both return NaN, despite the same logic applying","msgtype":"m.text"},"ts":1564496855000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(I have an issue open on CSS to see if we need to copy over the hypot/pow behavior, rather than the strict \"NaN is always infectious\" behavior that's currently specced.)","msgtype":"m.text"},"ts":1564496896000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I recall that min and max are specified in terms of a large list of mathematical operators without individual spec text","msgtype":"m.text"},"ts":1564496949000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Nah they have spec text. It just defined \"no args, return +/- Infinity; NaN args, return NaN; otherwise call the comparison algo\".","msgtype":"m.text"},"ts":1564497661000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"hypot checks for infinity before checking for NaN, who knows why.","msgtype":"m.text"},"ts":1564497720000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"pow defers to `**`, which says \"If exponent is +0, the result is 1, even if base is NaN.\"","msgtype":"m.text"},"ts":1564497850000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I wonder if that behavior is dictated by IEEE-754.","msgtype":"m.text"},"ts":1564497938000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(just fyi, i was reading the spec for all of these so I could have css copy the behavior)","msgtype":"m.text"},"ts":1564500224000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"devsnek: It finally clicked for me this morning that I think that solution for ?. would've been more obvious to me if I'd've done a bytecode impl of try-catch before","msgtype":"m.text"},"ts":1564507801000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: try/catch is what got me thinking of the solution i came up with","msgtype":"m.text"},"ts":1564507940000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Does anyone remember what the argument for including uninitialized class fields was?","msgtype":"m.text"},"ts":1564512503000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"It's causing people coming from TypeScript a fair bit of pain, and is a huge pain to implement","msgtype":"m.text"},"ts":1564512521000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(in parsers)","msgtype":"m.text"},"ts":1564512525000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and it seems like `x = undefined` isn't that bad of an alternative","msgtype":"m.text"},"ts":1564512552000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"mostly I just don't remember why we included them, and am wondering if anyone knows offhand","msgtype":"m.text"},"ts":1564512578000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: like `class X { x; }`?","msgtype":"m.text"},"ts":1564514561000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i mean they don't have TDZ or anything","msgtype":"m.text"},"ts":1564514590000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what's the issue people are having","msgtype":"m.text"},"ts":1564514596000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"looking over the acorn plugin, it seems pretty simple","msgtype":"m.text"},"ts":1564514687000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: what happens in that if you are in a sloppy context with a `undefined` var?","msgtype":"m.text"},"ts":1564515953000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"betting it was something dealing with sloppy doing bad things","msgtype":"m.text"},"ts":1564515977000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i feel like sloppy just keeps getting more strange over time","msgtype":"m.text"},"ts":1564516040000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"because divergence and different things made for strict/Module having compromises instead of initial designs for making them work in sloppy","msgtype":"m.text"},"ts":1564516081000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"devsnek: yeah, like that","msgtype":"m.text"},"ts":1564516260000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"see https://github.com/tc39/proposal-class-fields/issues/242 and https://github.com/babel/babel/issues/10282","msgtype":"m.text"},"ts":1564516271000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the issue is basically that typescript and flow treat that syntax (or roughly that syntax) as being basically a comment","msgtype":"m.text"},"ts":1564516288000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1564516300000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bradleymeck: `x = void 0` then, I guess","msgtype":"m.text"},"ts":1564516303000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this silly thing","msgtype":"m.text"},"ts":1564516308000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: can't they just pretend it was `= void 0`","msgtype":"m.text"},"ts":1564516354000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ofc if we'd chosen [[Set]] this wouldn't be a problem :-/","msgtype":"m.text"},"ts":1564516363000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: I would not guarantee acorn's plugin is correct; I spent a while getting it right in babel: https://github.com/babel/babylon/pull/351","msgtype":"m.text"},"ts":1564516373000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: yes it would?","msgtype":"m.text"},"ts":1564516376000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it has nothing to do with Define vs Set","msgtype":"m.text"},"ts":1564516382000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: you're talking entirely about runtime semantics though","msgtype":"m.text"},"ts":1564516388000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: with [[Set]], then `x;` is just `this.x = undefined`, no?","msgtype":"m.text"},"ts":1564516390000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: they could, sure, but that's not the semantics they actually want","msgtype":"m.text"},"ts":1564516392000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: right, which does not solve the issue these people are having","msgtype":"m.text"},"ts":1564516403000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: hm, what issue are they having then","msgtype":"m.text"},"ts":1564516411000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"they are not using accessors or nonwritable properties","msgtype":"m.text"},"ts":1564516414000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: see https://github.com/tc39/proposal-class-fields/issues/242","msgtype":"m.text"},"ts":1564516423000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i mean i get that they want it to be a noop, but if it used [[Set]] and `= undefined` wouldn't that just work?","msgtype":"m.text"},"ts":1564516433000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"no, it would not","msgtype":"m.text"},"ts":1564516440000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh because it would override, hm","msgtype":"m.text"},"ts":1564516449000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah, it overrides regardless of Set vs Define","msgtype":"m.text"},"ts":1564516458000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so we'd really have to spec `x;` as a noop to fix that, which indeed would be the same with either semantics","msgtype":"m.text"},"ts":1564516460000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(Set vs Define really is not something which comes up that much in most code)","msgtype":"m.text"},"ts":1564516469000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if we're gonna change class fields","msgtype":"m.text"},"ts":1564516476000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: orrrrr we could spec `x;` as being illegal","msgtype":"m.text"},"ts":1564516476000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"can we just get rid of them","msgtype":"m.text"},"ts":1564516478000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"altho maybe if we used Set, then we could justify the semantics of `x;` being `if (!(x in this)) { x = undefined; }`","msgtype":"m.text"},"ts":1564516482000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: no","msgtype":"m.text"},"ts":1564516484000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"we can't make `x;` illegal, its already in code","msgtype":"m.text"},"ts":1564516495000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"at least my code","msgtype":"m.text"},"ts":1564516500000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and i assume i'm not the only person","msgtype":"m.text"},"ts":1564516508000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"s/could/could have/, I guess","msgtype":"m.text"},"ts":1564516509000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: thoughts on my last comment?","msgtype":"m.text"},"ts":1564516676000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(not that it will change the Set vs Define outcome anyways)","msgtype":"m.text"},"ts":1564516704000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i think class fields are the only js feature i actively dislike :(","msgtype":"m.text"},"ts":1564516761000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i feel like i missed some big stuff and decorators changed a lot while i was absent","msgtype":"m.text"},"ts":1564516890000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"idk how i feel about them now","msgtype":"m.text"},"ts":1564516894000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i think a lot of people feel that way","msgtype":"m.text"},"ts":1564516944000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: that seems way too complicated","msgtype":"m.text"},"ts":1564516960000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i want decorators over \"no decorators\", but i reallllly do not like the current second-class magic Modules-only form :-/","msgtype":"m.text"},"ts":1564516963000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: the semantics for \"declare the field\" would be \"the field exists afterwards\", seems simple to me","msgtype":"m.text"},"ts":1564516980000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: except it wouldn't. imagine `Object.freeze(Object.prototype); class A { toString; constructor(callback) { this.toString = callback; } }`. with current semantics, you get the right thing; with your semantics, you would get an error.","msgtype":"m.text"},"ts":1564517042000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: and it would work if you changed the `toString;` to `toString = void 0;`, which is even more surprising.","msgtype":"m.text"},"ts":1564517063000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok that's fair","msgtype":"m.text"},"ts":1564517099000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so then short of straight making `toString;` illegal, it seems like we're in the best place already","msgtype":"m.text"},"ts":1564517116000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and doing that is probably not even web compatible at this point","msgtype":"m.text"},"ts":1564517132000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i might just make a node addon that exposes private symbols","msgtype":"m.text"},"ts":1564517172000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: yeah; I just want to know why `toString;` is legal in the first place","msgtype":"m.text"},"ts":1564517217000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sidebar: I am not convinced that \"someone somewhere has written code using this\" ought to justify \"we can't take it out of this stage 3 feature\"","msgtype":"m.text"},"ts":1564517312000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(cc devsnek)","msgtype":"m.text"},"ts":1564517316000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the whole point of having stage 3 vs 4 is to allow changes","msgtype":"m.text"},"ts":1564517338000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"fair","msgtype":"m.text"},"ts":1564517361000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if we're gonna make changes though, having to use try catch to check if an object has a private field still feels like a non-starter for the current design :(","msgtype":"m.text"},"ts":1564517396000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why?","msgtype":"m.text"},"ts":1564517436000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you have to use try catch to check if a string is valid JSON, and to check if an object is a Map, and a bunch of other places","msgtype":"m.text"},"ts":1564517452000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"doesn't seem that surprising","msgtype":"m.text"},"ts":1564517456000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"we really just need a way to test for private fields in terms of ergonomics","msgtype":"m.text"},"ts":1564517483000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"none of those are even remotely related to checking if x has a property","msgtype":"m.text"},"ts":1564517496000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I would be on board with `#x in foo` working (without going up the prototype chain, just like `foo.#x` does not go up the prototype chain)","msgtype":"m.text"},"ts":1564517498000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek: \"has a property\", in the context of private fields, is equivalent to \"is of this kind\"","msgtype":"m.text"},"ts":1564517519000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which is in fact a lot like \"is a Map\"","msgtype":"m.text"},"ts":1564517527000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah its a whole new thing","msgtype":"m.text"},"ts":1564517527000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which is why i think its a non-starter","msgtype":"m.text"},"ts":1564517532000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but oh well","msgtype":"m.text"},"ts":1564517533000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: fwiw tho that try/catch requirement is terrible","msgtype":"m.text"},"ts":1564517536000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so yeah `#x in foo` working would be *amazing*","msgtype":"m.text"},"ts":1564517547000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but really we need a \"has own\" operator, that also works with private fields","msgtype":"m.text"},"ts":1564517564000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"^","msgtype":"m.text"},"ts":1564517572000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`foo has x` or `foo has #x` or something. but we're out of keywords.","msgtype":"m.text"},"ts":1564517583000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i do like the throw though personally","msgtype":"m.text"},"ts":1564517584000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i like the throw behavior where it currently exists","msgtype":"m.text"},"ts":1564517593000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i don't like that there's no non-throwy way to check","msgtype":"m.text"},"ts":1564517598000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"hm, `has` would be kinda nice, true","msgtype":"m.text"},"ts":1564517606000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: we can still add contextual keywords *shudder*","msgtype":"m.text"},"ts":1564517607000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`K own in O`","msgtype":"m.text"},"ts":1564517620000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`in foo has x`","msgtype":"m.text"},"ts":1564517630000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1564517642000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"throwing by default feels so weirdly opinionated","msgtype":"m.text"},"ts":1564517647000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think ASI would be a problem for leading `in`?","msgtype":"m.text"},"ts":1564517648000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`foo...has...x`","msgtype":"m.text"},"ts":1564517671000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`symbol in foo` :(","msgtype":"m.text"},"ts":1564517704000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(x\\n in foo); has x","msgtype":"m.text"},"ts":1564517716000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`foo with x`","msgtype":"m.text"},"ts":1564517718000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ooo `with` returns?","msgtype":"m.text"},"ts":1564517732000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`foo super in x`","msgtype":"m.text"},"ts":1564517733000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`foo in.own x` :-p","msgtype":"m.text"},"ts":1564517753000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i've got a whole closetful of bikeshed paint here","msgtype":"m.text"},"ts":1564517761000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"seems fine","msgtype":"m.text"},"ts":1564517762000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"as long as grammar isn't terrible w/e","msgtype":"m.text"},"ts":1564517773000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":". o O ( `x of foo` )","msgtype":"m.emote"},"ts":1564517794000,"senderName":"FireFly","senderId":"FireFly@irc"},
{"content":{"body":"the saddest part of the `with` construct really is the fact that it's occupying such a useful keyword","msgtype":"m.text"},"ts":1564518297000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(although that's probably more relevant to the resource mgmt discussion but still)","msgtype":"m.text"},"ts":1564518332000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"one day ASI, one day i will be freed to use keywords not from the 90s","msgtype":"m.text"},"ts":1564519053000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yolo https://www.npmjs.com/package/@snek/private","msgtype":"m.text"},"ts":1564519196000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1564519554000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"devsnek: bug report, doesn't work in a browser","msgtype":"m.text"},"ts":1564525628000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: with the right combination of flags it might work in chrome :)","msgtype":"m.text"},"ts":1564525650000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"\"this website best used with chrome 74 and these seventeen flags\"","msgtype":"m.text"},"ts":1564525676000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"wouldn't even be the most outrageous requirement i've seen","msgtype":"m.text"},"ts":1564525701000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the projectors my school got last year require activex to send telnet commands, so you have to use internet explorer","msgtype":"m.text"},"ts":1564525764000,"senderName":"devsnek","senderId":"devsnek@irc"}
]