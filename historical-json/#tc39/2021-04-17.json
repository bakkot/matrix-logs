[
{"content":{"body":"no","msgtype":"m.text"},"ts":1618617694000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I'm also pretty sure it isn't","msgtype":"m.text"},"ts":1618617715000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but it shouldn't be, also","msgtype":"m.text"},"ts":1618617719000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Curious. The resolve function in a promise has a reference to the promise more or less right? So code like: new Promise(resolve => window.resolve = resolve) That's what causes the promise to not get GC'ed even if a direct reference to the promise doesn't exist?","msgtype":"m.text"},"ts":1618619335000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"I presume, yeah. The resolve fn has to hold a strong ref to its associated Promise.","msgtype":"m.text"},"ts":1618619389000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I guess theoretically it could hold a weak ref it was written defensively; you can't get at the promise *using* the resolve function.","msgtype":"m.text"},"ts":1618619417000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Resolver maybe not blocking it to be GCed as TabAtkins said, but reject will. Cause when the promise rejects, a host hook will be called to notify that unhandled rejection","msgtype":"m.text"},"ts":1618620638000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"akirose only if the host actually does anything with that host hook; if it doesn't it can GC the promise without that being observable","msgtype":"m.text"},"ts":1618622155000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"*jackwors, sorry aki","msgtype":"m.text"},"ts":1618622161000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"*jackworks","msgtype":"m.text"},"ts":1618622164000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ugh","msgtype":"m.text"},"ts":1618622165000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"typing","msgtype":"m.text"},"ts":1618622167000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1618622194000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"Almost ready to have another playground for Pipelines: https://media.discordapp.net/attachments/640177429775777792/832755342109573170/unknown.png","msgtype":"m.text"},"ts":1618659184000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"Very cool! (Tho I am *highly* doubtful that the gain of avoiding putting a `(#)` at the end of `Math.round` there is worth the complexity of a second pipeline operator and accordingly separate syntax model for the RHS.)","msgtype":"m.text"},"ts":1618675151000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: The *additional* complexity of second pipeline operator is elemental compared to introducing the first one, especially if topic-styles are implemented first.","msgtype":"m.text"},"ts":1618688173000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"Then we have to weigh in the people who strongly prefer one style over another, whichever way they prefer. This might be the compromise with least opposition.","msgtype":"m.text"},"ts":1618688345000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"Obviosly with so many years behind us, the issue doesn't seem to be not whether one style works better than the other, but whether someone prefers on over another. This is one way where complaints like: \"We don't need this style because I don't use it and it introduces compexity\" or \"It's ugly\" or \"The character cost is way too high!\" are seen as","msgtype":"m.text"},"ts":1618688665000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"ridicilous and ineffective.","msgtype":"m.text"},"ts":1618688666000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"Also, adding full support of these features to TypeScript, which might be one of the most complex JS-style parsers is kind of disproving that the implementation is too difficult / complex. I've done protos of partial function application, Hack pipelins and F# pipelines (without await) with no prior knowledge of TypeScript codebase or even compilers","msgtype":"m.text"},"ts":1618689157000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"really in a reasonable amount of time.","msgtype":"m.text"},"ts":1618689158000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"Pokute: remember tho, the future is longer than the past. it'd be better to wait 10 more years to get any form of pipeline than to be stuck with the wrong one for the next 1000","msgtype":"m.text"},"ts":1618690631000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"god I hope we are not writing new javascript 1000 years hence","msgtype":"m.text"},"ts":1618691364000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"fully expect some to be running somewhere, at least if there is anything left on the planet","msgtype":"m.text"},"ts":1618691396000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"our mistakes will live *forever*","msgtype":"m.text"},"ts":1618691449000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://twitter.com/ktemkin/status/1346734616749563905","msgtype":"m.text"},"ts":1618691467000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1618691490000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://twitter.com/evntdrvn/status/1346816967001444352","msgtype":"m.text"},"ts":1618691496000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Not doing anything can be a mistake too.","msgtype":"m.text"},"ts":1618692887000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"Pokute: sure. but often much less of one than doing the wrong thing.","msgtype":"m.text"},"ts":1618693221000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"And by someone's standards, there have already been mistakes in JavaScript, and the mistakes will be made in the future too. Thus mistakes by some standard are always made. What I'm aiming here is a reaching compromise where most can agree that no more universally agreaable solution is seen.","msgtype":"m.text"},"ts":1618693241000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"that we're stuck with some mistakes should encourage fewer, not excuse more","msgtype":"m.text"},"ts":1618693271000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(ftr i like pipeline and want it to advance)","msgtype":"m.text"},"ts":1618693282000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but i don't think \"it's been so long\" is a compelling argument","msgtype":"m.text"},"ts":1618693291000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I think that \"it's been so long\" is a valid argument for overcoming dislikes/distastes/preferences. More technical arguments are a different matter of course.","msgtype":"m.text"},"ts":1618693441000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"It's not always clear of course which arguments are less of personal likes and which genuinely affect most people. :-)","msgtype":"m.text"},"ts":1618693542000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"This is why I don't really mind which pipeline proposal variant ends up at the top. Both hack- and F# variant proponents favor their own, but disregarding other side's wants feel to me only slightly more justified than \"foo.#bar for private members is ugly\" -argument. A tactful person would offer to take the one character of extra syntax tax (|>>)","msgtype":"m.text"},"ts":1618694037000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"for his own variant.","msgtype":"m.text"},"ts":1618694038000,"senderName":"Pokute","senderId":"Pokute@irc"},
{"content":{"body":"just been reading the specification. we have these four lexical goals defined: InputElementDiv, InputElementRegExp, InputElementTemplateTail and InputElementRegExpOrTemplateTail... but they're not really used any where other than defining them... it implies the idea is that according to the grammar, a lexical tokenizer ought to use one of those four as its goal, but it never really tells you when those cases","msgtype":"m.text"},"ts":1618696343000,"senderName":"aradesh","senderId":"aradesh@irc"},
{"content":{"body":"are","msgtype":"m.text"},"ts":1618696344000,"senderName":"aradesh","senderId":"aradesh@irc"},
{"content":{"body":"i guess the idea maybe is to just consult the production you're parsing, and determine if eg a regexp is allowed at that point, and set the goal accordingly?","msgtype":"m.text"},"ts":1618696708000,"senderName":"aradesh","senderId":"aradesh@irc"},
{"content":{"body":"and i suppose, if regexp is allowed, /hi/ is parsed as the regexp rather than the punctuator / because it's longer?","msgtype":"m.text"},"ts":1618696764000,"senderName":"aradesh","senderId":"aradesh@irc"}
]