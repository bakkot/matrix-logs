[
{"content":{"body":"ljharb: I saw you've commentend on BigInt PR. Thx a lot! I'll be able get back to work on this tomorrow.","msgtype":"m.text"},"ts":1562590288000,"senderName":"caiolima","senderId":"caiolima@irc"},
{"content":{"body":"devsnek Domenic ljharb I don't have strong preferences how we can add a reverse iterator to the spec, as long as we get something for Array, Map, and Set. Not even worried about String. I'll follow the consent sentiment from the room","msgtype":"m.text"},"ts":1562598819000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"the way Lee Byron's proposal describes the iter.reverse() is \"safe\" but weird, I'm not sure I love it. It should definitely be coordinated with devsnek's proposal.","msgtype":"m.text"},"ts":1562598890000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"obviously we need a reverse iteration syntax /s","msgtype":"m.text"},"ts":1562598937000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"What I want is something straight to the point where in a list object I can `list.reverse()`. I have a preference (not a blocker) for a string named method, that may mirror a Symbol property. And I'm fully aware Array#reverse is taken, so I'm open to bikeshed names","msgtype":"m.text"},"ts":1562598992000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"fwiw i haven't explored optional capabilities at all yet, so iter.reverse might not be the the best way forward, it was just off the top of my head","msgtype":"m.text"},"ts":1562599017000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's very odd calling `[].values().reverse()` where you get two iterators and rely on both","msgtype":"m.text"},"ts":1562599057000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"in rust, when you use rev, what you actually start doing is consuming the same iterator from the back instead of the front","msgtype":"m.text"},"ts":1562599121000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"[].valuesRight() is ugly but follow consistency with reduceRight","msgtype":"m.text"},"ts":1562599131000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"technically you could consume it from both sides at the same time, and end up in the middle","msgtype":"m.text"},"ts":1562599141000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I'd rather not have a @@reverseIterator depending on a @@iterator","msgtype":"m.text"},"ts":1562599192000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"it needn’t have to","msgtype":"m.text"},"ts":1562599215000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it's weird in my mind to be a reverse iterator but not a regular iterator","msgtype":"m.text"},"ts":1562599230000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but that’d be a naive possible implementation","msgtype":"m.text"},"ts":1562599231000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"naive possible yes, thats why I'm not discarding","msgtype":"m.text"},"ts":1562599249000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"you could also make it required to have an iterator method, but not invoke it","msgtype":"m.text"},"ts":1562599254000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"is there an example where you would want to only be iterable with a concept of reverse","msgtype":"m.text"},"ts":1562599257000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I'm playing flexible here","msgtype":"m.text"},"ts":1562599263000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"devsnek: you could have an iterable for, say, data points over time, which is infinite - but your reverse iterator could start at a timestamp","msgtype":"m.text"},"ts":1562599315000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek if I have a Map/Set subclass instance that enforces LIFO operations","msgtype":"m.text"},"ts":1562599322000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1562599342000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if we have a concept of double-ended iterators reverse can just be a general wrapper than calls nextBack instead of next","msgtype":"m.text"},"ts":1562599415000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"also, the fact these two steps are only applied in specific cases, not applied to generators or any other custom iterator","msgtype":"m.text"},"ts":1562599417000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"same for: `[@@asyncIterator]()[@@reverseIterator]()`","msgtype":"m.text"},"ts":1562599464000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"or `[@@asyncIterator]().reverse()` where it should not even be available","msgtype":"m.text"},"ts":1562599490000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"i'm trying to think of other languages that have this","msgtype":"m.text"},"ts":1562599576000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think rust and c++ are the only languages that generalize it to a trait/template type thing","msgtype":"m.text"},"ts":1562599621000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and they both use the concept of double-ended","msgtype":"m.text"},"ts":1562599647000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i kinda like this, but perhaps its too complex? https://gc.gy/30305686.png","msgtype":"m.text"},"ts":1562600716000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think a pro/con list for various possibilities would be a good thing to put in the proposal document","msgtype":"m.text"},"ts":1562601904000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"haste","msgtype":"m.text"},"ts":1562613137000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"(inb4 jorendorff can say anything posthaste)","msgtype":"m.text"},"ts":1562613148000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"> BindingIdentifier: `yield`","msgtype":"m.text"},"ts":1562613170000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"> *   It is a Syntax Error if this production has a [Yield] parameter.","msgtype":"m.text"},"ts":1562613170000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"^ this appears in the current draft. But how is that different from","msgtype":"m.text"},"ts":1562613186000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"> BindingIdentifier: [~Yield] `yield`","msgtype":"m.text"},"ts":1562613210000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"That is, seems like an Early Error should be kind of a last resort. We could just enforce this in the grammar. Also, what does \"this production\" mean?","msgtype":"m.text"},"ts":1562613263000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"`yield` in the position of a binding identifier is \"this production\"","msgtype":"m.text"},"ts":1562613631000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ok, well, that just seems to confirm that the meaning is basically the same as making that production conditional","msgtype":"m.text"},"ts":1562614072000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"jorendorff: There is a NOTE above that early error section","msgtype":"m.text"},"ts":1562614274000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"\"yield and await are permitted as BindingIdentifier in the grammar, and prohibited with static semantics below, to prohibit automatic semicolon insertion in cases such as\"","msgtype":"m.text"},"ts":1562614284000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"WOW","msgtype":"m.text"},"ts":1562614329000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"asi strikes again","msgtype":"m.text"},"ts":1562614331000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":":-O","msgtype":"m.text"},"ts":1562614415000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"still trying to wrap my head around how that example works though","msgtype":"m.text"},"ts":1562614461000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"it's unbelievable, this is the junction of half a dozen JS quirks","msgtype":"m.text"},"ts":1562614477000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"`let` is a conditional keyword","msgtype":"m.text"},"ts":1562614483000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"`let;` is a legal JS statement in non-strict code; you can do `let = 12; eval(\"let\")` and the answer is 12","msgtype":"m.text"},"ts":1562614524000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"loganfsmyth: So if ASI did happen, you would get `let; await 0;` which would actually parse","msgtype":"m.text"},"ts":1562614650000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"ah right, so by making it a valid BindingIdentifier, it's not a syntax error and thus doesn't trigger ASI, ugh","msgtype":"m.text"},"ts":1562614771000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"well, not exactly lol","msgtype":"m.text"},"ts":1562614780000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"because `let await 0;` *is* still a syntax error","msgtype":"m.text"},"ts":1562614789000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"or at least, not a grammar error","msgtype":"m.text"},"ts":1562614792000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"yeah, poorly worded","msgtype":"m.text"},"ts":1562614797000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"so it *does* trigger ASI","msgtype":"m.text"},"ts":1562614804000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"but not until `0`","msgtype":"m.text"},"ts":1562614807000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"and ASI looks at the `0`, sees that it's not immediately after a new line, and says no way","msgtype":"m.text"},"ts":1562614830000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"so the way this prohibits ASI is by •exploiting details of how ASI case 1 works; and •arranging for a different token to be \"the offending token\"","msgtype":"m.text"},"ts":1562614951000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"yupp","msgtype":"m.text"},"ts":1562614963000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"good times :P","msgtype":"m.text"},"ts":1562614966000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"loganfsmyth: TIL the Python parser in `python` is generated by this 406-line script https://github.com/python/cpython/blob/master/Parser/pgen/pgen.py","msgtype":"m.text"},"ts":1562615226000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"oh cool","msgtype":"m.text"},"ts":1562615278000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"apparently python's no-semicolons-required syntax works a *little* differently from JS's","msgtype":"m.text"},"ts":1562615354000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"just a tad","msgtype":"m.text"},"ts":1562615464000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ok, i got another one","msgtype":"m.text"},"ts":1562615499000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"> TemplateLiteral : NoSubstitutionTemplate","msgtype":"m.text"},"ts":1562615533000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"> * It is a Syntax Error if the number of elements in the result of TemplateStrings of TemplateLiteral with argument false is greater than 2^32 - 1.","msgtype":"m.text"},"ts":1562615533000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"but TemplateStrings on this is guaranteed to return a List with exactly one element  TemplateLiteral:NoSubstitutionTemplate","msgtype":"m.text"},"ts":1562615584000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"oops, meant to paste this link https://tc39.es/ecma262/#sec-static-semantics-templatestrings","msgtype":"m.text"},"ts":1562615611000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"https://github.com/tc39/ecma262/issues/1588","msgtype":"m.text"},"ts":1562615860000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"jorendorff: ^^","msgtype":"m.text"},"ts":1562615867000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"I think?","msgtype":"m.text"},"ts":1562615872000,"senderName":"loganfsmyth","senderId":"loganfsmyth@irc"},
{"content":{"body":"yup. thanks","msgtype":"m.text"},"ts":1562615921000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"imagine a template literal with 2^32-1 substitutions","msgtype":"m.text"},"ts":1562618993000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: why just imagine? 😈","msgtype":"m.text"},"ts":1562619108000,"senderName":"rkirsling","senderId":"rkirsling@irc"}
]