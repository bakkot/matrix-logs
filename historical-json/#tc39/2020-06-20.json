[
{"content":{"body":"maybe the `of` in a for/of statemenr","msgtype":"m.text"},"ts":1592611211000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Even though Punctuator is defined in the lexical grammar, it's not used in the syntactic grammar. Instead you have things like RelationalOperator or EqualityOperator.","msgtype":"m.text"},"ts":1592611217000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"ah you mean when it does bold text","msgtype":"m.text"},"ts":1592611241000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"generally those occurances are described by the lexical grammar, even when it doesn't specifically mention the lexical production in question","msgtype":"m.text"},"ts":1592611289000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Exactly.","msgtype":"m.text"},"ts":1592611302000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"Really, they're not. Like I said, the lexical grammar includes Punctuator. Nowhere is that referred to in the syntactic grammar.","msgtype":"m.text"},"ts":1592611344000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"toddobryan: if it helps, think of them like c enums","msgtype":"m.text"},"ts":1592611393000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"everything used in the syntaric grammar should be well defined in the lexical grammar even it not directly referring to it","msgtype":"m.text"},"ts":1592611474000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"syntactic*","msgtype":"m.text"},"ts":1592611484000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"And I lied above. RelationalOperator and EqualityOperator don't exist. I created them when I was writing my grammar. In the lexical grammar, they're not distinguishable (all under Punctuator) and in the syntactic grammar, they're literals: https://www.ecma-international.org/ecma-262/#prod-RelationalExpression and https://www.ecma-international.org/ecma-262/#prod-EqualityExpression.","msgtype":"m.text"},"ts":1592611532000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"toddobryan: I'm not sure I understand what the problem is üòÖ","msgtype":"m.text"},"ts":1592611686000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: I'd be fine with that, but nowhere in the spec does it specify how/when you should choose between the goal symbols of InputElementDiv, InputElementRegExp, etc.","msgtype":"m.text"},"ts":1592611710000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"it shouldn't ever have to specify how you choose","msgtype":"m.text"},"ts":1592611740000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there are maybe two places where it does (if statements and some regex thing in annex b)","msgtype":"m.text"},"ts":1592611760000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there's a pr open to fix the if statement one","msgtype":"m.text"},"ts":1592611774000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"It does specify: \"The InputElementRegExpOrTemplateTail goal is used in syntactic grammar contexts where a RegularExpressionLiteral, a TemplateMiddle, or a TemplateTail is permitted. The InputElementRegExp goal symbol is used in all syntactic grammar contexts where a RegularExpressionLiteral is permitted but neither a TemplateMiddle, nor a TemplateTail is permitted. The InputElementTemplateTail goal is used in all syntactic grammar","msgtype":"m.text"},"ts":1592611779000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":" contexts where a TemplateMiddle or a TemplateTail is permitted but a RegularExpressionLiteral is not permitted. In all other contexts, InputElementDiv is used as the lexical goal symbol.\"","msgtype":"m.text"},"ts":1592611779000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"OK--here's the basic problem. If the left-hand side of a grammar production never appears in the right-hand sign of another rule, that production is unused and provides no information to the spec.","msgtype":"m.text"},"ts":1592611794000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"Find me a place where InputElementDiv is used in the syntactic grammar.","msgtype":"m.text"},"ts":1592611816000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"The information it provides is in how to divide up the source text.","msgtype":"m.text"},"ts":1592611942000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think it's described in section 11?","msgtype":"m.text"},"ts":1592611990000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"But it's not actually used. In the syntactic grammar, the input is referred to explicitly, not the productions that the lexical grammar provides.","msgtype":"m.text"},"ts":1592612084000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"And since the syntactic grammar does not explicitly use those rules, it's almost impossible to write a tokenizer. (Or at least it has been for me.)","msgtype":"m.text"},"ts":1592612207000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"The syntactic grammar is not defined over the source text. If it were it would have to deal with whitespace and comments.","msgtype":"m.text"},"ts":1592612237000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"The point of splitting them is so that the lexical grammar can deal with whitespace and comments, including stuff like \"is `/ a /` three tokens or one\"","msgtype":"m.text"},"ts":1592612288000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"to quote the page I linked","msgtype":"m.text"},"ts":1592612342000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"> In implementations, the syntactic grammar analyzer (‚Äúparser‚Äù) may call the lexical grammar analyzer (‚Äútokenizer‚Äù or ‚Äúlexer‚Äù), passing the goal symbol as a parameter and asking for the next input element suitable for that goal symbol.","msgtype":"m.text"},"ts":1592612343000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"OK. Fair enough. But how would I know when to use the `InputElementRegExp` production to get the next token?","msgtype":"m.text"},"ts":1592612459000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"See note 1 here: https://www.ecma-international.org/ecma-262/#prod-GeneratorMethod","msgtype":"m.text"},"ts":1592612480000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"There is no such note anywhere that references InputElementRegExp. (That I can find. I'd be happy to learn I'm missing something.)","msgtype":"m.text"},"ts":1592612516000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"in terms of concrete implementation you don't usually see any specific \"now we're lexing the input\" type stuff","msgtype":"m.text"},"ts":1592612554000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"aside from handling hashbang","msgtype":"m.text"},"ts":1592612563000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"The bit I quoted above says you'd use `InputElementRegExp` to get the next input element \"in all syntactic grammar contexts where a RegularExpressionLiteral is permitted but neither a TemplateMiddle, nor a TemplateTail is permitted\"","msgtype":"m.text"},"ts":1592612585000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"all the implementations I know of use a whitelist of allowed tokens preceding the yield","msgtype":"m.text"},"ts":1592612640000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there aren't that many","msgtype":"m.text"},"ts":1592612658000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"*following?","msgtype":"m.text"},"ts":1592612663000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"rather than preceding","msgtype":"m.text"},"ts":1592612669000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah that lol","msgtype":"m.text"},"ts":1592612672000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"So, you'd use `InputElementRegExp` when applying `PrimaryExpression`? (I did a quick search, and I think that's the only rule that `RegularExpressionLiteral` appears on the right of.)","msgtype":"m.text"},"ts":1592612777000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"mmm.... \"when applying\" doesn't exactly make sense, I think","msgtype":"m.text"},"ts":1592612828000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if you've just parsed _part_ of an expression, like `a +`, then you'd use InputElmentRegexp`","msgtype":"m.text"},"ts":1592612857000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"When trying to satisfy?","msgtype":"m.text"},"ts":1592612869000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"The spec is kind of written on the assumption that you'll be using a bottom-up parser, probably specifically a shift-reduce parser","msgtype":"m.text"},"ts":1592612923000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which doesn't really have a notion of \"trying to satisfy\"","msgtype":"m.text"},"ts":1592612932000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"trying to satisfy is more of a top-down thing","msgtype":"m.text"},"ts":1592612973000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"How can you do a bottom-up parse when what's legal as a token depends on the context you're in?","msgtype":"m.text"},"ts":1592612986000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"Because you don't have to know exactly which context you're in","msgtype":"m.text"},"ts":1592613011000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I'm writing a recursive-descent parser, so I do know which rule I'm trying to apply...","msgtype":"m.text"},"ts":1592613045000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"Like I said, if you've just parsed `a +`, you know that the following token can be a RegularExpressionLiteral but not a TemplateMiddle or a TemplateTail, so you know to use InputElementRegExp","msgtype":"m.text"},"ts":1592613050000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if you've just parsed `yield`, and you're in a template interpolation, you know that the next token could be a RegularExpressionLiteral or a TemplateTail, so you'd use InputElementRegExpOrTemplateTail","msgtype":"m.text"},"ts":1592613099000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"etc","msgtype":"m.text"},"ts":1592613101000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok, so, backing up a bit","msgtype":"m.text"},"ts":1592613105000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Are you specifically interested in having your parser cleave as close as possible to the spec, or are you just trying to write a parser?","msgtype":"m.text"},"ts":1592613135000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Is there a way to know, only from the previous tokens, which goal symbol I should be using?","msgtype":"m.text"},"ts":1592613155000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"  def importCall(_yield: Boolean, _await: Boolean) =    str(\"import\") ~ elem('(') ~ assignmentExpression(true, _yield, _await) ~ elem(')')","msgtype":"m.text"},"ts":1592613212000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"There's a sample rule in the parser I've written so far, so I'm sticking pretty close to the spec. :-)","msgtype":"m.text"},"ts":1592613236000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"what language is that","msgtype":"m.text"},"ts":1592613247000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Scala.","msgtype":"m.text"},"ts":1592613250000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"parser combinators, woo","msgtype":"m.text"},"ts":1592613264000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Anyway, the answer is to your previous question is yes","msgtype":"m.text"},"ts":1592613287000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"You know which syntactic contexts you might be in, which means you know if the next token can be a regexp, a template tail, or neither, which means you know which of the goal symbols to use","msgtype":"m.text"},"ts":1592613323000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"both? InputElementRegExpOrTemplateTail. just regexp? InputElementRegExp. just template middle/tail? InputElementTemplateTail. neither? InputElementDiv.","msgtype":"m.text"},"ts":1592613370000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you might want to take a look at  some existing parsers (acorn, babel, shiftjs) and see how they work","msgtype":"m.text"},"ts":1592613407000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"OK. I know about TemplateTail, because if I don't have a previous, unclosed TemplateHead, that's out.","msgtype":"m.text"},"ts":1592613435000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"devsnek ehh, so, the reason I was asking about if toddobryan was interested in sticking to the spec or not was, the spec is written for clarity and precision, not for ease of implementation","msgtype":"m.text"},"ts":1592613450000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so all the parser implementations don't look very much like the spec","msgtype":"m.text"},"ts":1592613463000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if you're trying to look like the spec you have to use different implementation strategies","msgtype":"m.text"},"ts":1592613486000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Is there something as easy as that for whether a Regexp is legal?","msgtype":"m.text"},"ts":1592613512000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"I'm guessing I'll need a couple of flags during tokenizing that just flip on or off `isRegexpAllowed` and `isTemplateTailAllowed`.","msgtype":"m.text"},"ts":1592613580000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"for regex literals you generally run over them with some very light rule that just basically recognizes / [ and ]","msgtype":"m.text"},"ts":1592613613000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"mm, not quite as easy as that, I don't think","msgtype":"m.text"},"ts":1592613618000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and then pass it to the separate regex parser","msgtype":"m.text"},"ts":1592613625000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek that happens later, not when trying to decide which lexical goal symbol to use","msgtype":"m.text"},"ts":1592613636000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it's a separate concern","msgtype":"m.text"},"ts":1592613638000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh they meant if a regex is allowed","msgtype":"m.text"},"ts":1592613652000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not if it's valid","msgtype":"m.text"},"ts":1592613659000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"toddobryan basically though a regexp is legal wherever an expression is legal; if the next token can't be an expression (without an intervening semicolon), then you can't have a regexp","msgtype":"m.text"},"ts":1592613684000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so, e.g., if you have just finished parsing an expression (other than `yield`), you can't have a semicolon","msgtype":"m.text"},"ts":1592613709000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"*can't have a regexp, sorry","msgtype":"m.text"},"ts":1592613713000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"btw if you haven't thought about ASI now is the time at which you'll need to think about ASI","msgtype":"m.text"},"ts":1592613736000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ASI?","msgtype":"m.text"},"ts":1592613748000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"also no line terminator here","msgtype":"m.text"},"ts":1592613753000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"automatic semicolon insertion","msgtype":"m.text"},"ts":1592613754000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-automatic-semicolon-insertion","msgtype":"m.text"},"ts":1592613763000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Yeah. That's next on the list.","msgtype":"m.text"},"ts":1592613784000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"OK. So I guess I need to figure out how to keep track of whether a RegularExpressionLiteral is allowed.","msgtype":"m.text"},"ts":1592613896000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"I think you always know at any point you'd ask the tokenizer for the next token","msgtype":"m.text"},"ts":1592613965000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"like the normal way of writing a recursive descent parser, you have, I don't know, parseConditionalExpression or whatever","msgtype":"m.text"},"ts":1592614005000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Thanks for humoring me. I now understand what I was missing.","msgtype":"m.text"},"ts":1592614008000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"and you call parseBinaryExpression and so on, and eventually end up at parsePrimaryExpression, and you're looking at the next token to determine which kind of primary expression it is","msgtype":"m.text"},"ts":1592614091000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Well, I was hoping to separate the parser and the tokenizer, but couldn't figure out how to do that without understanding which rules were applicable.","msgtype":"m.text"},"ts":1592614102000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"and at that point you know that a regexp is legal, so when you ask for the next token, you know to ask for the regexp ones","msgtype":"m.text"},"ts":1592614118000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah, yeah, you can't split them out because you don't know which goal symbol to use without knowing the syntactic context, unfortunately","msgtype":"m.text"},"ts":1592614136000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"specifically, you don't know if `/` (or `/=`) is going to be the beginning of a regexp or a division without knowing the syntactic context","msgtype":"m.text"},"ts":1592614172000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"anyway, good luck! if you make progress and are inclined to share you should post it; I would enjoy reading it","msgtype":"m.text"},"ts":1592614243000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I maintain a recursive descent JS parser written in Java, which... is a bit of a pain","msgtype":"m.text"},"ts":1592614260000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"That makes perfect sense. So if I did want to write just a tokenizer, I'd need to include enough syntactic context to disambiguate.","msgtype":"m.text"},"ts":1592614261000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"I can imagine. I tried creating a parser combinator library in Kotlin and gave up. The thing that makes them so nice in Kotlin is that you have the flexible syntax, but, and this is key, you can pass arguments by name in addition to by reference, so you don't have to deal with things like circular references and such.","msgtype":"m.text"},"ts":1592614396000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"\"so nice in Scala\" I meant.","msgtype":"m.text"},"ts":1592614412000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"Thanks for all the help!","msgtype":"m.text"},"ts":1592614425000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"Yeah, the Java one does not get to use combinators","msgtype":"m.text"},"ts":1592614480000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Well, it could I guess, but it doesn't","msgtype":"m.text"},"ts":1592614487000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(it lives in https://github.com/shapesecurity/shift-java/blob/es2018/src/main/java/com/shapesecurity/shift/es2018/parser/GenericParser.java )","msgtype":"m.text"},"ts":1592614529000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Thanks!","msgtype":"m.text"},"ts":1592614555000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"toddobryan: thinking about it more, for a recursive descent parser I don't think you'd need to actually \"keep track\" of any state, as such, to know which of the four lexical grammar goal symbols to ask for","msgtype":"m.text"},"ts":1592614820000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it's always going to be obvious every time you ask for a token","msgtype":"m.text"},"ts":1592614837000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Yeah. It seems to work for parsing without knowing--what I can't do is tokenize.","msgtype":"m.text"},"ts":1592614876000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"Can't tokenize ahead of parsing, right","msgtype":"m.text"},"ts":1592614895000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Because the syntactic grammar rules aren't written in terms of tokens--they're written in terms of input literals in lots of cases.","msgtype":"m.text"},"ts":1592614941000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"Hm. I guess the way I'd put it is, the input literals are specializations of the nonterminals of the lexical grammar","msgtype":"m.text"},"ts":1592615004000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"when the syntactic grammar says `if`, for example, that is an IdentifierName which has the contents \"if\"","msgtype":"m.text"},"ts":1592615035000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i.e. it is a particular kind of IdentifierName","msgtype":"m.text"},"ts":1592615045000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"similarly when it says `(` that is a particular kind of Punctuator, etc","msgtype":"m.text"},"ts":1592615062000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you could write your tokenizer over the specializations, rather than over the full set; that is (afaik) what everyone actually does","msgtype":"m.text"},"ts":1592615091000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Yeah, I can see interpreting it that way.","msgtype":"m.text"},"ts":1592615097000,"senderName":"toddobryan","senderId":"toddobryan@irc"},
{"content":{"body":"dang, I missed a grammar discussion","msgtype":"m.text"},"ts":1592622939000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I was looking at NamedEvaluation of anon functions within object literals","msgtype":"m.text"},"ts":1592659075000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"and I was like gotcha - what if this key is a symbol? what will be to the fn name?","msgtype":"m.text"},"ts":1592659075000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"And then found this - `set name to the string-concatenation of \"[\", description, and \"]\"`","msgtype":"m.text"},"ts":1592659075000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"Now i understand how much of effort and details goes in to the specs. Just wanted to appreciate the contributors.","msgtype":"m.text"},"ts":1592659075000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"(and i also wonder if there is a story behind this naming?)","msgtype":"m.text"},"ts":1592659226000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"bendtherules: a story behind the name \"NamedEvaluation\" you mean?","msgtype":"m.text"},"ts":1592688085000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"bradleymeck: is there a repo for string literal imports","msgtype":"m.text"},"ts":1592695689000,"senderName":"devsnek","senderId":"devsnek@irc"}
]