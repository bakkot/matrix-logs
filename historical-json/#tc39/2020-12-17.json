[
{"content":{"body":"I have a floating-point question:","msgtype":"m.text"},"ts":1608174564000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Are there any strings of digits (maybe including a decimal point) with more than 20 significant digits such that the three algorithms \"set everything after the 20th significant digit to a 0, then choose the nearest double\", \"set everything after the 20th significant digit to a 0, increment the digit in the 20th place, then choose the nearest double\", and \"choose the nearest double\" produce three distinct values, rather than just two?","msgtype":"m.text"},"ts":1608174573000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":" (You can get two from e.g. \"100000000000000008191\".) Resolving ties with roundTiestToEven, though I don't think it matters.","msgtype":"m.text"},"ts":1608174573000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I am _almost_ certain the answer is no but I would like to be more confident.","msgtype":"m.text"},"ts":1608174599000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(it's mostly subnormals and stuff that I'm worried about; I've convinced myself of it for integers.)","msgtype":"m.text"},"ts":1608174966000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"function f() { throw \"BAD\"; }  null.name = f();","msgtype":"m.text"},"ts":1608241229000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"The standard seems to say this should throw a TypeError. Is that right?","msgtype":"m.text"},"ts":1608241251000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"We end up at: https://tc39.es/ecma262/#sec-evaluate-property-access-with-identifier-key","msgtype":"m.text"},"ts":1608241266000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"from: https://tc39.es/ecma262/#sec-property-accessors-runtime-semantics-evaluation","msgtype":"m.text"},"ts":1608241289000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"from step 1.a of: https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation","msgtype":"m.text"},"ts":1608241394000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"It seems pretty clear f() should never be called. But it is called in V8 and SM","msgtype":"m.text"},"ts":1608241416000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"es6draft follows the spec. ugh","msgtype":"m.text"},"ts":1608241472000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"JSC throws \"BAD\" too","msgtype":"m.text"},"ts":1608241541000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"I'm asking because the Private Fields proposal quite naturally has the same language: https://tc39.es/proposal-class-fields/#sec-private-references-runtime-semantics-evaluation","msgtype":"m.text"},"ts":1608241627000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"and V8 has shipped a nonconforming implementation, such that `null.#f = f();` calls f","msgtype":"m.text"},"ts":1608241784000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"if all the engines don't follow the spec, then it seems plausible that the spec might need to change to match","msgtype":"m.text"},"ts":1608241823000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"will file against ecma262","msgtype":"m.text"},"ts":1608241850000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"i wonder if this is related to the thing where `(foo) = 42` doesn't throw a syntax error","msgtype":"m.text"},"ts":1608241972000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"well ... I think it's on purpose that in `f1().x = f2();`, f1 is called before f2","msgtype":"m.text"},"ts":1608242956000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"everyone gets that much right, at least","msgtype":"m.text"},"ts":1608242971000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"this was filed previously: https://github.com/tc39/ecma262/issues/1224","msgtype":"m.text"},"ts":1608243151000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"ah ok great","msgtype":"m.text"},"ts":1608243212000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"jorendorff: that reading seems right","msgtype":"m.text"},"ts":1608247031000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i'd imagine everyone gets the ordering wrong because our bytecodes are all \"fat\"","msgtype":"m.text"},"ts":1608247179000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and there's some StoreNamedProperty bytecode that encompasses the error checking","msgtype":"m.text"},"ts":1608247198000,"senderName":"shu","senderId":"shu@irc"}
]