[
{"content":{"body":"Hi all","msgtype":"m.text"},"ts":1571238979000,"senderName":"Lcfvs","senderId":"Lcfvs@irc"},
{"content":{"body":"hi","msgtype":"m.text"},"ts":1571239064000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Why, in JS, we don't have an array hybrid method like every (stopping iteration at a certain point), to filter them?","msgtype":"m.text"},"ts":1571239072000,"senderName":"Lcfvs","senderId":"Lcfvs@irc"},
{"content":{"body":"Lcfvs: how would you indicate \"stopping\"?","msgtype":"m.text"},"ts":1571240216000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb like a filter, by a falsy value","msgtype":"m.text"},"ts":1571240299000,"senderName":"Lcfvs","senderId":"Lcfvs@irc"},
{"content":{"body":"Lcfvs: so not like filter, more like \"takeUntil\"?","msgtype":"m.text"},"ts":1571240379000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah, it's the name I got in head: until","msgtype":"m.text"},"ts":1571240420000,"senderName":"Lcfvs","senderId":"Lcfvs@irc"},
{"content":{"body":"^^","msgtype":"m.text"},"ts":1571240422000,"senderName":"Lcfvs","senderId":"Lcfvs@irc"},
{"content":{"body":"Lcfvs: for that it sounds like `const i = arr.findIndex(predicate); i >= 0 ? arr.slice(0, i) : arr.slice()` or something would do it","msgtype":"m.text"},"ts":1571240523000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yep, something like that... as a native method?","msgtype":"m.text"},"ts":1571240703000,"senderName":"Lcfvs","senderId":"Lcfvs@irc"},
{"content":{"body":"i imagine just that nobody's proposed it yet","msgtype":"m.text"},"ts":1571240837000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but it'd need lots of prior art and a compelling argument why a native method was better than a two-liner, i think","msgtype":"m.text"},"ts":1571240851000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah, I'm just launching the idea :)","msgtype":"m.text"},"ts":1571240942000,"senderName":"Lcfvs","senderId":"Lcfvs@irc"},
{"content":{"body":"if an error occurs while i'm using an iterator, that iterator should be closed right?","msgtype":"m.text"},"ts":1571241605000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: i think for..of and spread are supposed to close it; i don't think there's any guarantee that it will be closed in general tho","msgtype":"m.text"},"ts":1571241670000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"in my proposal, i don't close it","msgtype":"m.text"},"ts":1571241681000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://tc39.es/proposal-iterator-helpers/#sec-iteratorprototype-map","msgtype":"m.text"},"ts":1571241685000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm trying to figure out if i need to replace all these calls with ?","msgtype":"m.text"},"ts":1571241702000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you can also make something unclosable by making .return not callable if i remember right","msgtype":"m.text"},"ts":1571241799000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"maybe i'll need an IfAbruptCloseIterator lol","msgtype":"m.text"},"ts":1571241859000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for (let x of Object.assign(iter, {return:null})) ... would be kind of funny to have that as a helper somehow","msgtype":"m.text"},"ts":1571241877000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"devsnek: it seems like it'd be a consistency issue to *not* call return if iteration errors, yeah","msgtype":"m.text"},"ts":1571241919000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: it depends on whether the error comes from the iterator protocol or not","msgtype":"m.text"},"ts":1571246904000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"e.g. if the error is that \"next\" is an accessor which throws, you don't attempt to close the iterator. but if you you're doing, say, `.map(foo)`, and `foo` throws, you need to close the iterator","msgtype":"m.text"},"ts":1571246941000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"bakkot: that you for clarifying!","msgtype":"m.text"},"ts":1571247118000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"aha, gtk","msgtype":"m.text"},"ts":1571247666000,"senderName":"ljharb","senderId":"ljharb@irc"}
]