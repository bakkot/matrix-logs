[
{"content":{"body":"DerekNonGeneric: i think itâ€™s a hard sell to add types like those to the language when they have virtually no usage in userland","msgtype":"m.text"},"ts":1621732289000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":">  they have virtually no usage in userland","msgtype":"m.text"},"ts":1621733865000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"ljharb, `AssertionError` has no usage in userland?","msgtype":"m.text"},"ts":1621733890000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"this is one of the most common (and most fundamental) error types in all of the JS ecosystem","msgtype":"m.text"},"ts":1621733940000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"the fact that it's missing seems wild to me","msgtype":"m.text"},"ts":1621734010000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"adding a new error type w/o even having `stack` (or whatever) standardized yet means that there is no foundation from which to build new standardized errors, so this would be a massive standardization undertaking afaict","msgtype":"m.text"},"ts":1621734319000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"DerekNonGeneric: nodeâ€™s assert has it but i donâ€™t know of anyone directly caring that thatâ€™s the error type","msgtype":"m.text"},"ts":1621736500000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"DerekNonGeneric: iow a standard Error with a â€œassertion: trueâ€ property on it would probably work just as well","msgtype":"m.text"},"ts":1621736525000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"> a standard Error with a â€œassertion: trueâ€ property on it would probably work just as well","msgtype":"m.text"},"ts":1621737446000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"ljharb, that is not one of the properties of an `AssertionError` according to JS ecosystem usage patterns","msgtype":"m.text"},"ts":1621737483000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"the most common are: `actual`, `expected`, and `operator` to name a few","msgtype":"m.text"},"ts":1621737523000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"DerekNonGeneric: maybe i'm missing context. is this an interoperable thing already?","msgtype":"m.text"},"ts":1621737540000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or is it just a convention that a few libraries all follow similarly?","msgtype":"m.text"},"ts":1621737557000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i've used mocha and jest and jasmine and assert for many, many years, and i've never cared that the error thrown is an \"AssertionError\" - i only care that the test runner can catch the errors that it, itself, generates from its assertion API","msgtype":"m.text"},"ts":1621737612000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah, it is a convention that several assertion libraries follow (Chai, Jest, Node Core `assert`, Mocha, etc.)","msgtype":"m.text"},"ts":1621737757000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"right but do they interoperate?","msgtype":"m.text"},"ts":1621737787000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"everybody using jest's assertion api is using jest's runner, almost everyone using chai or mocha's assertion api is using mocha, etc","msgtype":"m.text"},"ts":1621737812000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"node's assert is probably a special case but how many people using any of those runners are using an assert-based api, as opposed to the much more common BDD-style interfaces?","msgtype":"m.text"},"ts":1621737831000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so like what i mean is, there's like, 6 developers/teams that ever need AssertionError, and to everyone else, they're completely transparent, and it _seems_ to me that virtually nobody actually relies on interoperability there","msgtype":"m.text"},"ts":1621738009000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"interop btwx test frameworks is one good justification, but probably not the strongest reason to include it in the language","msgtype":"m.text"},"ts":1621738146000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"what's your strongest reason?","msgtype":"m.text"},"ts":1621738179000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"dunno, i have a few and have not really identified one of them to be the strongest reason so far","msgtype":"m.text"},"ts":1621738265000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"i'd love to hear a few","msgtype":"m.text"},"ts":1621738277000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"interop between test frameworks was the only one i can think of","msgtype":"m.text"},"ts":1621738290000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"well, there is also data validation","msgtype":"m.text"},"ts":1621738344000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"where you'd want to rely on try/catch?","msgtype":"m.text"},"ts":1621738421000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"more like you are validating some function arguments and throw this error when you get something you don't want (could be wrong type, wrong value, range, etc.)","msgtype":"m.text"},"ts":1621738520000,"senderName":"DerekNonGeneric","senderId":"DerekNonGeneric@irc"},
{"content":{"body":"until we do something interesting with errors, as far as i'm concerned, we don't even need the subclasses we currently have","msgtype":"m.text"},"ts":1621738741000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the only test suite i've worked with that cares which specific error is thrown is test262, and that's just a cycle at that point","msgtype":"m.text"},"ts":1621738801000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"DerekNonGeneric: right but that's already what TypeError is","msgtype":"m.text"},"ts":1621738902000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or RangeError","msgtype":"m.text"},"ts":1621738925000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or AggregateError, i suppose","msgtype":"m.text"},"ts":1621738935000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like what does \"assertion\" mean here","msgtype":"m.text"},"ts":1621738954000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"in the spec, an assertion is something that can't ever fail, or else the whole implementation is invalid. i feel like typically, that's what `assert()` statements are for","msgtype":"m.text"},"ts":1621738981000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so unless AssertionErrors are uncatchable (and uncatchable errors would be a huge nonstarter for a number of reasons) then i'm not sure why it'd be any different than just any kind of thrown value","msgtype":"m.text"},"ts":1621739016000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i think most engines already have uncatchable errors","msgtype":"m.text"},"ts":1621739032000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"isn't that also part of mark's proposal for gc recovery","msgtype":"m.text"},"ts":1621739045000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: that part of it got strong pushback, and i don't think is still in it","msgtype":"m.text"},"ts":1621739145000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ðŸ˜­ i like uncatchable errors","msgtype":"m.text"},"ts":1621739168000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but you like reference assignments too","msgtype":"m.text"},"ts":1621739248000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"array.at(-1) = x is a good feature","msgtype":"m.text"},"ts":1621739288000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":":^)","msgtype":"m.text"},"ts":1621739296000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"13.2.5.1 says \"When ObjectLiteral appears in a context where ObjectAssignmentPattern is required the following Early Error rules are not applied. In addition, they are not applied when initially parsing a CoverParenthesizedExpressionAndArrowParameterList or CoverCallExpressionAndAsyncArrowHead.\"","msgtype":"m.text"},"ts":1621743705000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I'm wondering about that \"In addition\". Is there a case where the first sentence applies but the second one doesn't?","msgtype":"m.text"},"ts":1621743865000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"jmdyck CoverParenthesizedExpressionAndArrowParameterList derives ObjectBindingPatternm, not ObjectAssignmentPattern","msgtype":"m.text"},"ts":1621745270000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"they're just different cases","msgtype":"m.text"},"ts":1621745286000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"CoverParenthesizedExpressionAndArrowParameterList derives ( Expression ) and Expression derives ObjectLiteral, so that's an instance of the second sentence and could also be an instance of the first sentence.","msgtype":"m.text"},"ts":1621745481000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ah, sure, I see what you're saying","msgtype":"m.text"},"ts":1621745492000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"as a concrete example, then, the inner `{}` in `({x = 0, y: {}} = z)` is a position where ObjectAssignmentPattern is required but which is not initially parsing CoverParenthesizedExpressionAndArrowParameterList or CoverCallExpressionAndAsyncArrowHead","msgtype":"m.text"},"ts":1621745511000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"thanks, I'll have a look at that tomorrow.","msgtype":"m.text"},"ts":1621745554000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"or just like any position where there's no parentheses","msgtype":"m.text"},"ts":1621745578000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the object in `x = {} = y`, for example","msgtype":"m.text"},"ts":1621745595000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`console.tap = v => ( console.log( v ), v );` hmm","msgtype":"m.text"},"ts":1621778596000,"senderName":"howdoi","senderId":"howdoi@irc"},
{"content":{"body":"urgh, i'm so confused.","msgtype":"m.text"},"ts":1621784396000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"somehow I got shut out of this room, and my irc client won't let me use my freenode account","msgtype":"m.text"},"ts":1621784485000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"and I wasn't sure if this was just part of the whole freenode thing, or is an unrelated problem.","msgtype":"m.text"},"ts":1621784539000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(I'm connecting though a web client now)","msgtype":"m.text"},"ts":1621784595000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"test on freenode","msgtype":"m.text"},"ts":1621789371000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"yo","msgtype":"m.text"},"ts":1621789393000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Well, that was a waste of about 3 hours. Not sure what caused it, or what fixed it.","msgtype":"m.text"},"ts":1621789715000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"Bakkot: re your first example:","msgtype":"m.text"},"ts":1621791978000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"[1] ({x = 0, y: {}} = z) is a CoverParenthesizedExpressionAndArrowParameterList that covers ...","msgtype":"m.text"},"ts":1621791978000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"[2] a ParenthesizedExpression, in which {x = 0, y: {}} is a LeftHandSideExpression that covers ...","msgtype":"m.text"},"ts":1621791978000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"[3] an AssignmentPattern, in which {} is a LeftHandSideExpression that covers ...","msgtype":"m.text"},"ts":1621791978000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"[4] an AssignmentPattern.","msgtype":"m.text"},"ts":1621791978000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"Presumably the second sentence (\"when initially parsing a CoverParenthesizedExpressionAndArrowParameterList\") is only talking about [1].","msgtype":"m.text"},"ts":1621791978000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"But for the first sentence (\"when ObjectLiteral appears in a context where ObjectAssignmentPattern is required\"), are you saying this only applies to [3] (and thus [1] is indeed additional)?","msgtype":"m.text"},"ts":1621791978000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"Certainly `{}` is an ObjectLiteral in each of [1-3], so I guess the question is whether an ObjectAssignmentPattern is \"required\" in [1] and [2].","msgtype":"m.text"},"ts":1621791980000,"senderName":"jmdyck1","senderId":"jmdyck1@irc"},
{"content":{"body":"every day i grow closer to proposing if-let","msgtype":"m.text"},"ts":1621798993000,"senderName":"devsnek","senderId":"devsnek@irc"}
]