[
{"content":{"body":"devsnek: you should write down the \"if .throw or .return is called on an iterator produced by one of these iterator methods, it calls that method with the same argument on the underlying iterator\" behavior somewhere that isn't the spec","msgtype":"m.text"},"ts":1549076331000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"for Object.fromEntries I had a `DETAILS.md` where I wrote down design decisions of that type, so that they'd be easier to identify and review","msgtype":"m.text"},"ts":1549076352000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1549076384000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"btw is that more of an opinionated choice than i imagined it to be?","msgtype":"m.text"},"ts":1549076404000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"No, probably not.","msgtype":"m.text"},"ts":1549076912000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"That is, it's almost certainly right, unless I'm missing something. It's just not something I'd thought about and I needed to stare at the spec for a moment to think about what was going on, and I like to have those things written down.","msgtype":"m.text"},"ts":1549076970000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"bterlson, https://github.com/bterlson/ecmarkup/issues/152 I made an issue. mmm elegant.","msgtype":"m.text"},"ts":1549077288000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Sirisian: that takes td items based on the th declared?","msgtype":"m.text"},"ts":1549077756000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes, magic","msgtype":"m.text"},"ts":1549077766000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"took me a minute to figure out","msgtype":"m.text"},"ts":1549077773000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah, I can probably add a note for that.","msgtype":"m.text"},"ts":1549077804000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"I'm adding all the Symbol.operators from my proposal into the tables. This is so verbose.","msgtype":"m.text"},"ts":1549078021000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Symbol.operators","msgtype":"m.text"},"ts":1549078041000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes, great evil. https://github.com/sirisian/ecmascript-types#classes-and-operator-overloading wcgw","msgtype":"m.text"},"ts":1549078174000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"i still don't get why this isn't better suited for build time ðŸ¤·","msgtype":"m.text"},"ts":1549078217000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you can do more powerful type checks with more time","msgtype":"m.text"},"ts":1549078234000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"build time?","msgtype":"m.text"},"ts":1549078242000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1549078296000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"types usually happen at compile time","msgtype":"m.text"},"ts":1549078303000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Sirisian: btw simd was explicitly moved to wasm land","msgtype":"m.text"},"ts":1549078375000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"As in ECMAScript can never have it?","msgtype":"m.text"},"ts":1549078395000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"I asked about that before and was told by others that wasm isn't designed to replace ECMAScript.","msgtype":"m.text"},"ts":1549078436000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Wait, can ECMAScript use wasm?","msgtype":"m.text"},"ts":1549078462000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"ecmascript has no concept of wasm","msgtype":"m.text"},"ts":1549078470000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh, I thought I missed something. Got excited.","msgtype":"m.text"},"ts":1549078482000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"but the people working on the simd api moved all their efforts to wasm","msgtype":"m.text"},"ts":1549078488000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I was hoping when that's finalized it would be more refined for an inclusion into ECMAScript. I mostly just added it to think about language features. Would be nice for math library performance though. Always found matrix operations to be disappointingly slow. Also I think my implementation with types will be cleaner. No accidental conversions to Number and other weird things.","msgtype":"m.text"},"ts":1549078778000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"There's no harm if operator overloading is added to allow static operator overloading right? class A { static operator +=(value) { this.constructor.x += value; } } A.x = 0; A += 5; Seems deceptively simple. Makes the grammar change straightforward. http://sirisian.github.io/ecmascript-types/#prod-MethodDefinition I can pitch it to a champion later as \"ECMAScript now with more powerful singleton features.\" Developers love those.","msgtype":"m.text"},"ts":1549090660000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Sirisian: operator overloading has brought up lots of concerns from implementors that it would make *every* operation in the language slower","msgtype":"m.text"},"ts":1549090775000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"plus it's not a given that everyone *wants* that feature.","msgtype":"m.text"},"ts":1549090787000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"That would be bad. I'm trying to make every operation faster. :|","msgtype":"m.text"},"ts":1549090843000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Operator overloading without a type-checked step means that every operator suddenly becomes less predictable than `==`.","msgtype":"m.text"},"ts":1549090942000,"senderName":"Havvy","senderId":"Havvy@irc"},
{"content":{"body":"The only reason I want operator overloading is for math libraries. Oddly enough that's all it's generally used for in other languages. Except C++. Those guys are insane. They were right to be wary to add it there.","msgtype":"m.text"},"ts":1549090954000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Sirisian: `a.add(b)` can already be done","msgtype":"m.text"},"ts":1549091134000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Sirisian: or `a['+'](b)`","msgtype":"m.text"},"ts":1549091141000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or ``` math`${a} + ${b}` ``` perhaps","msgtype":"m.text"},"ts":1549091164000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Meaning it's not a concern?","msgtype":"m.text"},"ts":1549091166000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"meaning that the tradeoff might not be worth it to add syntax for it","msgtype":"m.text"},"ts":1549091178000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Trust me. I have a ton of math libraries written without it and code. It's a pain.","msgtype":"m.text"},"ts":1549091211000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"fair, but if it's going to slow down all the non-math libraries, that's going to be a hard sell","msgtype":"m.text"},"ts":1549091248000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Indeed.","msgtype":"m.text"},"ts":1549091289000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"If it slows down the math libraries, it's going to be an even harder sell. ;)","msgtype":"m.text"},"ts":1549091298000,"senderName":"Havvy","senderId":"Havvy@irc"},
{"content":{"body":"ha, true","msgtype":"m.text"},"ts":1549091377000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"should apis check the arguments passed or the validity of the receiver first","msgtype":"m.text"},"ts":1549134607000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Receiver is the precedent I believe","msgtype":"m.text"},"ts":1549138016000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"+1 to that","msgtype":"m.text"},"ts":1549143050000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(i think of the receiver as an implicit first argument, so it comes before all the arguments)","msgtype":"m.text"},"ts":1549143070000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'm not sure I'd want operator overloading, and I've written some mathsy JS code that would have benefitted from it syntactically..","msgtype":"m.text"},"ts":1549148973000,"senderName":"FireFly","senderId":"FireFly@irc"}
]