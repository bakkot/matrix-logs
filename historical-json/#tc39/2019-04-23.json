[
{"content":{"body":"rwaldron: seems like there might be an issue with the jsc runner? https://gc.gy/23732912.png","msgtype":"m.text"},"ts":1556027935000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is there an annex B or web compat reason why all vms seem to ignore changes to property `enumerable`-ness during for-in loops?","msgtype":"m.text"},"ts":1556048725000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"e.g. https://jsfiddle.net/y6sdgm2b/","msgtype":"m.text"},"ts":1556049145000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I mean I know it's \"undefined\", except that afaict all the vms match, but the way they match is incongruent with the example implementation in the spec","msgtype":"m.text"},"ts":1556049614000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: I don't think that's actually true; Chakra matches the spec","msgtype":"m.text"},"ts":1556051318000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"also XS, though I dunno if we're counting it","msgtype":"m.text"},"ts":1556051329000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I have that case in https://github.com/bakkot/for-in-exploration/blob/master/made-enum.js","msgtype":"m.text"},"ts":1556051350000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I was thinking \"browsers\", and I dunno if chakra really counts there anymore","msgtype":"m.text"},"ts":1556051360000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"anyway, in reseaching this a while back I couldn't find any references to people depending on that behavior","msgtype":"m.text"},"ts":1556051400000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the behaviour of the engines I've tried (v8/jsc/sm) seem pretty consistent, so I thought it would be good if the spec actually reflected it","msgtype":"m.text"},"ts":1556051417000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"unlike some other genuinly interop semantics: https://github.com/bakkot/for-in-exploration#real-constraints","msgtype":"m.text"},"ts":1556051418000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I am intending to bring to the committee a proposed spec text for some interop semantics at the June meeting","msgtype":"m.text"},"ts":1556051459000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"though that will depend on me actually running it","msgtype":"m.text"},"ts":1556051465000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and also, since Chakra differs here (and that mattered when I was first doing this), I did not consider this particular case to be within the interop semantics","msgtype":"m.text"},"ts":1556051495000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(s/actually running/actually writing/)","msgtype":"m.text"},"ts":1556051523000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"interesting, you've done a lot more work on it than me","msgtype":"m.text"},"ts":1556051626000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I'm guessing this is coming from you following up one of my JSC bugs which came out of this process?","msgtype":"m.text"},"ts":1556051679000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if there's some other for-in stuff you're working on I'd be interested in following along","msgtype":"m.text"},"ts":1556051703000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no it is still your filed bugs --- the JSC behaviour and all the matching VMs seem to pre-filter enumerable properties at the start of the loop, and then do another [[GetOwnProperty]] for each key to see if it exists (but ignore the DontEnum-ness)","msgtype":"m.text"},"ts":1556051929000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"so it's a little awkward to get the expected semantics","msgtype":"m.text"},"ts":1556051953000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"its' weird for proxies because you observably do [[GetOwnProperty]] for each key twice, once during the pre-filtering and again during the loop, which based on what the spec illustrates as an example implementation, shouldn't happen","msgtype":"m.text"},"ts":1556052076000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"so, since you're looking at this, can I ask - my plan was to say that engines are required to implement the spec's semantics for proxies in particular","msgtype":"m.text"},"ts":1556052336000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"with the thought that they'd just have a special case for proxies","msgtype":"m.text"},"ts":1556052358000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"does that seem reasonable?","msgtype":"m.text"},"ts":1556052363000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(the other half of the plan was to somehow nail down the \"normal\" case - no proxies or other exotics, no prototype changes, no enumerability changes, no non-enumerable properties shadowing enumerable properties, etc - and then say that you can do whatever you want as long as it matches the spec algorithm in those cases, which all engines already do)","msgtype":"m.text"},"ts":1556052459000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in JSC's case it's doable, I don't know if I like them having different semantics since any difference would be observable (e.g. wrt changes to enumerability affecting keys that are handled in the loop)","msgtype":"m.text"},"ts":1556052523000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"hm, yeah. my intent was to minimize the observable differences between engines, rather than between similar-ish cases on a single engine, but I don't know how to prioritize those.","msgtype":"m.text"},"ts":1556052660000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"currently engines all behave radically differently when for-in'ing a proxy","msgtype":"m.text"},"ts":1556052674000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(the proxy-trapped test in the above repo illustrates this)","msgtype":"m.text"},"ts":1556052730000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think https://gist.github.com/caitp/db5eae82a62b27d9e8ee9f7ab6b20a01 comes pretty close to what jsc does, I dunno if that exactly matches other engines","msgtype":"m.text"},"ts":1556053348000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"in the proxy case","msgtype":"m.text"},"ts":1556053432000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"no, not quite","msgtype":"m.text"},"ts":1556053615000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"though that also doesn't match JSC, at least on my local copy","msgtype":"m.text"},"ts":1556053628000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that gist differs from other engines mainly in that no engine other than JSC will print a non-enumerable property which shadows an enumerable one","msgtype":"m.text"},"ts":1556053716000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you might not have r244330 locally","msgtype":"m.text"},"ts":1556053725000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"i.e. JSC is unique in printing `x` in https://github.com/bakkot/for-in-exploration/blob/master/enumerable-shadowed.js","msgtype":"m.text"},"ts":1556053725000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah, I haven't done a lot of testing with the prototype object","msgtype":"m.text"},"ts":1556053790000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"hm. just updated, now on v244563, but still seeing the same proxy traps hit for JSC","msgtype":"m.text"},"ts":1556054014000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right now upstream:","msgtype":"m.text"},"ts":1556054175000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"if the proxy has no ownKeys handler, we do the normal [[GetOwnPropertyNames]] for the target object, and [[GetOwnProperty]] isn't run through the proxy","msgtype":"m.text"},"ts":1556054232000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"if it does have the ownKeys trap, then...","msgtype":"m.text"},"ts":1556054247000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"ownKeys is called, the returned object is converted into a list, configurable/extensible invariants are performed etc, and at the end, the list is re-filtered, kicking out DontEnum keys, before ever reaching the loop body","msgtype":"m.text"},"ts":1556054404000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"then, in the loop, for each key returned from `ProxyObject::performGetOwnPropertyNames()`, the loop body is evaluated only if `Boolean([[GetOwnProperty]](proxy, key))` is true","msgtype":"m.text"},"ts":1556054491000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"so there should be an ownKeys trap call, and 2 gopd trap calls per key, assuming \"ownKeys\" exists","msgtype":"m.text"},"ts":1556054526000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"and no trap calls (except for the gopd done in the for-in loop) if it does not exist","msgtype":"m.text"},"ts":1556054550000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"sounds about right. gets a little weirder in the presence of prototypes.","msgtype":"m.text"},"ts":1556054704000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"other engines are consistent about only ever invoking gopd once per key, even when (as in spidermonkey) that leads to spec-prohibited behavior ( https://bugzilla.mozilla.org/show_bug.cgi?id=1486656 )","msgtype":"m.text"},"ts":1556054827000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'd prefer that, if we spec behavior for proxies, we do it in such a way that gopd is invoked only once per property","msgtype":"m.text"},"ts":1556054887000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"v8 seems to follow your suggestions (ignoring anything wrt prototype shadowing), so for proxies, filtering is deferred until each loop iteration, and enumerability is checked there, but for non-proxies it's all pre-filtered","msgtype":"m.text"},"ts":1556055499000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"it wouldn't be the worst thing if all impls matched that, but I think it's not great to have the inconsistent behaviour between proxies and non-proxies, so I'd be happier to just forbid pre-filtering when it's observable, and let turbofan/DFG/etc do it if they decide they can","msgtype":"m.text"},"ts":1556055668000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"what's the worst that could happen","msgtype":"m.text"},"ts":1556055691000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I've been trying to avoid doing anything with the case where it's observable","msgtype":"m.text"},"ts":1556055827000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"mostly because that would require engines to make changes for non-proxy cases, which historically has been... basically impossible","msgtype":"m.text"},"ts":1556055847000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sorry, for the case where it's observable without proxies; I have higher hopes for getting engines to change where proxies are involved","msgtype":"m.text"},"ts":1556055898000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"> Previous discussions (Yes, I have read every comment in every one of these threads.)","msgtype":"m.text"},"ts":1556056535000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I love it","msgtype":"m.text"},"ts":1556056538000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"`proxy-trapped.js` is pretty crazy","msgtype":"m.text"},"ts":1556056787000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"nothing except engine262 and XS agree in proxy-trapped.js","msgtype":"m.text"},"ts":1556056855000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lmao jsc has an abrupt completion in this what even","msgtype":"m.text"},"ts":1556057001000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"wait, where?","msgtype":"m.text"},"ts":1556057080000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: https://gc.gy/23762126.png","msgtype":"m.text"},"ts":1556057127000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"x apparently doesn't get bound in the loop iteration","msgtype":"m.text"},"ts":1556057150000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually wait `loop: x` is there","msgtype":"m.text"},"ts":1556057209000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i dunno","msgtype":"m.text"},"ts":1556057216000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: I think this might be an old eshost bug or something","msgtype":"m.text"},"ts":1556057456000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1556057461000,"senderName":"devsnek","senderId":"devsnek@irc"}
]