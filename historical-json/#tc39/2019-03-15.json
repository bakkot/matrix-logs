[
{"content":{"body":"littledan: I would be against that; it ruins the ability to transparently refactor your work to take on async startup costs","msgtype":"m.text"},"ts":1552613975000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"If you're willing to rewrite the calling module graph anyway then you can just refactor to put everything inside dynamic imports","msgtype":"m.text"},"ts":1552614000000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: https://github.com/tc39/proposal-uniform-interchange-date-parsing is still active, I've just been short on time lately","msgtype":"m.text"},"ts":1552614257000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"that transparent ability is the","msgtype":"m.text"},"ts":1552618718000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"â€œSpooky action at a distanceâ€ that i have major concerns with :-/","msgtype":"m.text"},"ts":1552618730000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"littledan: along the same vein as domenic, you'd have to know if what you're importing is async or not, which is an annoying experience","msgtype":"m.text"},"ts":1552618913000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: youâ€™d get an early error about that tho","msgtype":"m.text"},"ts":1552621467000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"itâ€™d even be an autofixable lint rule","msgtype":"m.text"},"ts":1552621478000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ðŸ¤·","msgtype":"m.text"},"ts":1552621528000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: I thought `import await` would fix those exact spooky action a distance issues. Ultimately, the vitality is analogous to the virality of async/await itself","msgtype":"m.text"},"ts":1552642161000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"Domenic, devsnek: I can see this point abstractly, but isn't this just like async functions, which also require the caller to be adjusted to use a Promise rather than another value? We found it worth it to add async functions even though you could just use generators and Promises.","msgtype":"m.text"},"ts":1552642313000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"What I am missing is usage scenarios where you want to change a deep dependency like that. The current TLA explainer doesn't really have one concretely, making it hard to think about","msgtype":"m.text"},"ts":1552642361000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I don't see what dynamic imports have to do with any of this, though; why would refactoring to those solve this problem?","msgtype":"m.text"},"ts":1552642423000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"s/vitality/virality/","msgtype":"m.text"},"ts":1552649462000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: consider a web component whose template you want to move to another file","msgtype":"m.text"},"ts":1552651274000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"If you are going to change all call sites anyway you can use the import() + export default async antipattern the readme calls out.","msgtype":"m.text"},"ts":1552651303000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"The whole point of top-level await is to avoid making changes to the caller. I would be opposed to the proposal if it required caller changes.","msgtype":"m.text"},"ts":1552651437000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic, I think it's still more ergonomic than nothing. I don't quite understand that other case--why would you export the element rather than defining it (in the background than blocking module loading)?","msgtype":"m.text"},"ts":1552667603000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: consider the example at https://github.com/tc39/proposal-top-level-await/issues/58#issuecomment-468749512","msgtype":"m.text"},"ts":1552667627000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Consider a \"before\" version which had `const template = .... long string here ...`","msgtype":"m.text"},"ts":1552667643000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"You're saying I cannot switch to the version in the comment which loads the template from ./template-1.html without changing all my callers","msgtype":"m.text"},"ts":1552667662000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I don't think top-level await is worth moving forward as an ergonomics feature","msgtype":"m.text"},"ts":1552667672000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It is fundamentally an abstraction boundary feature","msgtype":"m.text"},"ts":1552667678000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wycats made this point in previous meetings","msgtype":"m.text"},"ts":1552667683000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"To be clear, I still think it makes sense to have both imports run in parallel","msgtype":"m.text"},"ts":1552667993000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"`await import` does also imply some ordering","msgtype":"m.text"},"ts":1552668096000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"+1 devsnek","msgtype":"m.text"},"ts":1552668119000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"littledan: I was just using that code sample","msgtype":"m.text"},"ts":1552668123000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Let me create a separate one to be clearer","msgtype":"m.text"},"ts":1552668127000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"heh the current proposal looks a lot like my implementation of top level await in engine262","msgtype":"m.text"},"ts":1552668396000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://github.com/tc39/proposal-top-level-await/pull/60#issuecomment-473362344","msgtype":"m.text"},"ts":1552668738000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"devsnek: Maybe, but I don't think anyone is proposing that","msgtype":"m.text"},"ts":1552668919000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"i just mean from a design standpoint","msgtype":"m.text"},"ts":1552668932000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i didn't assume you were proposing such a thing","msgtype":"m.text"},"ts":1552668942000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Right, well, I was hoping that `import await` would make it feel like the whole awaiting action is hoisted to the top and done in parallel, just like the fetch for the `import`.","msgtype":"m.text"},"ts":1552669053000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"devsnek: Do you think it achieves that?","msgtype":"m.text"},"ts":1552669067000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"i am unsure","msgtype":"m.text"},"ts":1552669090000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"domenic gave me an idea though","msgtype":"m.text"},"ts":1552669134000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if all import statements are import await statements","msgtype":"m.text"},"ts":1552669149000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well, that's basically what you get from #49 or E57","msgtype":"m.text"},"ts":1552669246000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"#57","msgtype":"m.text"},"ts":1552669251000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"the idea of this PR is that import statements stay import statements","msgtype":"m.text"},"ts":1552669264000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: `import await` fixes it for the modules that add TLA; but it just moves it to the one that adds `import await`","msgtype":"m.text"},"ts":1552670174000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"to be specific, i donâ€™t think adding TLA *should* be transparent. Maybe it should be viral, maybe not, but making a sync thing async is always a breaking change so far.","msgtype":"m.text"},"ts":1552670350000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: I don't understand what you mean by moving it. In particular, if you import a module that contains an import await, it's an error (at linking time)","msgtype":"m.text"},"ts":1552671810000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"so, it remains a breaking change","msgtype":"m.text"},"ts":1552671822000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"it's just like async functions: you need an await all the way up the callstack, if you want to get the value","msgtype":"m.text"},"ts":1552671845000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"right. But if i import a module that suddenly adds import await, thatâ€™s a breaking change too","msgtype":"m.text"},"ts":1552671855000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and in the case of promises, you donâ€™t - you could mutate a binding when the promise resolves without having to export a promise","msgtype":"m.text"},"ts":1552671873000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or you could dispatch to different behavior, etc","msgtype":"m.text"},"ts":1552671880000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the actual interface doesnâ€™t have to change","msgtype":"m.text"},"ts":1552671887000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"atm thereâ€™s no way to consume a module using TLA that encapsulates that decision from *your* users.","msgtype":"m.text"},"ts":1552671911000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i've kinda imagined that TLA is more useful at the entry rather than dependencies","msgtype":"m.text"},"ts":1552671922000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hm, i guess dynamic import","msgtype":"m.text"},"ts":1552671923000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"At the moment consuming a module that uses TLA is ENTIRELY encapsulated from your users","msgtype":"m.text"},"ts":1552671933000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"The change to use `await import` would break that, which is why I'm objecting ot it","msgtype":"m.text"},"ts":1552671942000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yes, my preference would be to only ever allow it in entry points, but thereâ€™s no way to spec that","msgtype":"m.text"},"ts":1552671942000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Domenic: using TLA changes ordering and timing semantics tho","msgtype":"m.text"},"ts":1552671955000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"doesnâ€™t it?","msgtype":"m.text"},"ts":1552671958000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yes, OK, \"ENTIRELY\" was over-strong","msgtype":"m.text"},"ts":1552671963000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"\"it is an early error if module includes top level await and export\"","msgtype":"m.text"},"ts":1552671964000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"If you don't use tick-counting trickery then it's unobservable","msgtype":"m.text"},"ts":1552671972000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"thus itâ€™s still a breaking change, just a silent one","msgtype":"m.text"},"ts":1552671974000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if it is ever observable then itâ€™s observable imo","msgtype":"m.text"},"ts":1552671980000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Sure. It's an observable change","msgtype":"m.text"},"ts":1552671988000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Just one that's highly encapsulated","msgtype":"m.text"},"ts":1552671991000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so i either want it to be entirely unobservable, trickery or not, or, i want it to be explicitly and loudly a breaking change","msgtype":"m.text"},"ts":1552672005000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the middle is where confusion happens","msgtype":"m.text"},"ts":1552672013000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"OK. Then I don't think this feature will move forward.","msgtype":"m.text"},"ts":1552672013000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"what would the downstream consequences of that be?","msgtype":"m.text"},"ts":1552672035000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"in html, node, wasm, etc","msgtype":"m.text"},"ts":1552672052000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i wouldn't agree that the number of ticks something takes is grounds to call it breaking","msgtype":"m.text"},"ts":1552672056000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: when it goes from 1 to > 1, no, but when it goes from effectively 0 to > 0, yes","msgtype":"m.text"},"ts":1552672083000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and i don't think anything except js itself wants async during evaluation phase","msgtype":"m.text"},"ts":1552672096000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually scratch that i know nothing about html imports","msgtype":"m.text"},"ts":1552672112000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so thatâ€™s my question. Before declaring a feature deadlocked, Iâ€™d like to understand what bad things could happen without it","msgtype":"m.text"},"ts":1552672139000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like E.g. if weakrefs died, wasm would ship them anyways, and then js would be forced to use wasmâ€™s version","msgtype":"m.text"},"ts":1552672166000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"what happens downstream without TLA, looking far forward?","msgtype":"m.text"},"ts":1552672180000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"IIFEs continue to exist","msgtype":"m.text"},"ts":1552672190000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it looks like importing an html returns that html as an element","msgtype":"m.text"},"ts":1552672287000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"We're still working moving the web from 0 ticks to >0 ticks","msgtype":"m.text"},"ts":1552672398000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"looks like importing html isn't hurt by the lack of async either","msgtype":"m.text"},"ts":1552672459000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I mean, importing HTML will definitely be async","msgtype":"m.text"},"ts":1552672518000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So I guess people could get around lack of top-level await by wrapping their .mjs files in .html files","msgtype":"m.text"},"ts":1552672534000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i mean there's nothing imperative about html modules that require fancy async during the evaluation phase","msgtype":"m.text"},"ts":1552672624000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not that they should be loaded synchronously :P","msgtype":"m.text"},"ts":1552672637000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"whispers .mhtml*","msgtype":"m.emote"},"ts":1552672688000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Well they can include <script type=\"module\">","msgtype":"m.text"},"ts":1552672692000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Which is loaded async","msgtype":"m.text"},"ts":1552672696000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i'd assume that's like having an import()","msgtype":"m.text"},"ts":1552672712000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"new entry point","msgtype":"m.text"},"ts":1552672714000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Nah that's not the current proposal","msgtype":"m.text"},"ts":1552672724000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"They re-export any <script>s","msgtype":"m.text"},"ts":1552672728000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Or maybe just the first one","msgtype":"m.text"},"ts":1552672739000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"interesting","msgtype":"m.text"},"ts":1552672751000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that still fits within the current evaluation rules though right?","msgtype":"m.text"},"ts":1552672770000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"All of them, it looks like","msgtype":"m.text"},"ts":1552672772000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"https://github.com/w3c/webcomponents/blob/gh-pages/proposals/html-module-spec-changes.md","msgtype":"m.text"},"ts":1552672773000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I mean HTML just evaluates modules on its own","msgtype":"m.text"},"ts":1552672814000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1552672820000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"It currently follows ES's everything-is-sync all-one-graph evaluation but that's changing","msgtype":"m.text"},"ts":1552672830000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ljharb, WebAssembly modules also need to be async, as mentioned in the TLA explainer","msgtype":"m.text"},"ts":1552687629000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"Domenic: Where can I find discussion about why HTML modules are async? I missed that.","msgtype":"m.text"},"ts":1552687642000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"ljharb: I still don't understand why `import await` wouldn't meet your goals. I think it's \"explicitly and loudly a breaking change\", as you put it.","msgtype":"m.text"},"ts":1552687714000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: why does wasm need async?","msgtype":"m.text"},"ts":1552687714000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it doesn't even *do* anything unless you have a start point","msgtype":"m.text"},"ts":1552687736000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://github.com/tc39/proposal-top-level-await#webassembly-modules","msgtype":"m.text"},"ts":1552687736000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"and if you have a start point","msgtype":"m.text"},"ts":1552687755000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it might have to do compilation during the Evaluate phase, due to what the imports are","msgtype":"m.text"},"ts":1552687757000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"its not like you can await inside wasm","msgtype":"m.text"},"ts":1552687766000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"these things are hard to reason about from first principles but come from real implementations","msgtype":"m.text"},"ts":1552687772000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"how is instantiation not part of the linking phase","msgtype":"m.text"},"ts":1552687832000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"See a detailed explanation in https://github.com/WebAssembly/esm-integration/tree/master/proposals/esm-integration","msgtype":"m.text"},"ts":1552687892000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"is this because of \"From HTML, itâ€™s not observable when parse a WebAssembly module begins, so any work perfomed in compilation may be performed off-thread.\"?","msgtype":"m.text"},"ts":1552687892000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"reading a file is async too, but we can still export things from source text","msgtype":"m.text"},"ts":1552687931000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Some compilation work might happen when parsing a WebAssembly module (nothing happens in the linking phase), but some other work might be needed once the imports are known","msgtype":"m.text"},"ts":1552687935000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"this causes me immense confusion","msgtype":"m.text"},"ts":1552687952000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in particular, some implementations have multiple types of underlying memory, and need to recompile due to that","msgtype":"m.text"},"ts":1552687954000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"if you import a memory","msgtype":"m.text"},"ts":1552687964000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"that sounds like it would break the js api","msgtype":"m.text"},"ts":1552687987000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well, it doesn't, it's just that the JS API isn't very useful...","msgtype":"m.text"},"ts":1552687999000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"you should only use instantiateStreaming for this reason","msgtype":"m.text"},"ts":1552688005000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"probably the Wasm JS API should've been designed very differently, but it's a little too late","msgtype":"m.text"},"ts":1552688020000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"the API just forces compilation work to happen on the main thread when you hold it wrong. Wasm modules will not compile on the main thread.","msgtype":"m.text"},"ts":1552688055000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"the whole point of Wasm/ESM integration is to make the right way easy","msgtype":"m.text"},"ts":1552688074000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"you can use instantiateStreaming in a module loader today right now","msgtype":"m.text"},"ts":1552688076000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ype","msgtype":"m.text"},"ts":1552688081000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"yep","msgtype":"m.text"},"ts":1552688083000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"not that its possible to easily test with cuz node refuses to merge any instantiateStreaming apis","msgtype":"m.text"},"ts":1552688123000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but locally i've built all this already which is why i'm confused","msgtype":"m.text"},"ts":1552688135000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I mean, if you're testing it, the JS API \"just works\". It just might do compilation on the main thread. And these effects are engine-specific--JSC is the one which motivated this current issue.","msgtype":"m.text"},"ts":1552688187000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"are you saying that instantiation shouldn't happen during linking?","msgtype":"m.text"},"ts":1552688231000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Anyway, between HTML and WebAssembly, I think we really need modules to be able to be asynchronous. I wouldn't like to see more HTML willful violations governing things here, the way they do with the job/microtask queue; I'd like to find some sort of clean layering. But if the WebAssembly \"do it anyway\" case is motivating for you, that's sort of the risk here.","msgtype":"m.text"},"ts":1552688299000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"can you give me an example of a wasm module that demonstrates the need for async","msgtype":"m.text"},"ts":1552688404000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: No, because any of them may need to do compilation during instantiation. Please read the documents I linked which explain this in detail","msgtype":"m.text"},"ts":1552689227000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"i am seemingly missing the why from these documents","msgtype":"m.text"},"ts":1552689356000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"littledan: is this just that you want to allow recompilation to happen off thread?","msgtype":"m.text"},"ts":1552689683000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1552689692000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"Seems like you understand; I'm wondering if you have ideas for how the documents could be more clear","msgtype":"m.text"},"ts":1552689713000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"what's the difference between my code needing to wait for something because it blocks vs needing to wait for something because its async","msgtype":"m.text"},"ts":1552689799000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like within js code it makes sense to move things to the loop so you can keep going with other things, but your module graph has to wait either way","msgtype":"m.text"},"ts":1552689877000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"littledan: sorry to answer your question, i'd say the word \"depend\" is the wrong word, i was trying to figure out why it wouldn't be possible to add wasm modules without async when the actual situation was that it was just a bonus for performance","msgtype":"m.text"},"ts":1552690872000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"exactly, but this performance bonus is an architectural thing. If we make them sync now, it will be hard to move compilation into the background in the future.","msgtype":"m.text"},"ts":1552690908000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: is the overhead of wasm optimization greater than the overhead of js optimization","msgtype":"m.text"},"ts":1552691057000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"just as a curiosity","msgtype":"m.text"},"ts":1552691065000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: Well, JS parsing and bytecode generation can be done during ParseModule, which can be done in the background, since modules are defer or async","msgtype":"m.text"},"ts":1552691156000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"an engine may need to readjust the bytecode depending on the values of imports","msgtype":"m.text"},"ts":1552691191000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Often, Wasm modules are extremely large, making them take a while to load up. That's why engines have been investing in baseline compilers.","msgtype":"m.text"},"ts":1552691202000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I don't think this comes up in JS the same as it does in Wasm","msgtype":"m.text"},"ts":1552691215000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"alright","msgtype":"m.text"},"ts":1552691238000,"senderName":"devsnek","senderId":"devsnek@irc"}
]