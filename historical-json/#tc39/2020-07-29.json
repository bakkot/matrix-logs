[
{"content":{"body":"is there a sane way to get an iterator from a value with a patched @@iterator as if it did not have a monkey patched @@iterator on it (no mutation)?","msgtype":"m.text"},"ts":1596042487000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"in particular in Node we have a \"safe\" Set that won't call out to monkey patched methods if you mutate the original global, but we noticed the iterable parameter is coercing using patched globals and we don't really want that","msgtype":"m.text"},"ts":1596042566000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"we could make a huge if/else to call the primordial @@iterator for a given type","msgtype":"m.text"},"ts":1596042590000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"but that seems... bad?","msgtype":"m.text"},"ts":1596042595000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"that's the only way i know of","msgtype":"m.text"},"ts":1596044663000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"array spread syntax, Array.from, for..of, all are \"unsafe\" in that sense since they call into \"not the original\" Symbol.iterator method","msgtype":"m.text"},"ts":1596044687000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"fun fun","msgtype":"m.text"},"ts":1596045168000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck assuming the monkey-patching is sticking @@iterator on the instance, you could just walk up the prototype chain explicitly","msgtype":"m.text"},"ts":1596045666000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: not if they replace Array.prototype[@@iterator] ?","msgtype":"m.text"},"ts":1596045694000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"right, that is not sticking it on the instance","msgtype":"m.text"},"ts":1596045711000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: yea this is just random user code we run in the same realm as","msgtype":"m.text"},"ts":1596046112000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Are you just trying to do `[...x]`?","msgtype":"m.text"},"ts":1596046128000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Or for-of?","msgtype":"m.text"},"ts":1596046134000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"jridgewell: we are trying to construct a subclass of a Map and we are providing something to it's first param","msgtype":"m.text"},"ts":1596046208000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"its","msgtype":"m.text"},"ts":1596046218000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Could just use a helper function?","msgtype":"m.text"},"ts":1596046238000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Check if `iterable[@@iterator]` is patched","msgtype":"m.text"},"ts":1596046256000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"we can write one, but thats effort to maintain","msgtype":"m.text"},"ts":1596046262000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"also if we are crawling to see if something is patched we can just call the primordial value","msgtype":"m.text"},"ts":1596046280000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Yah, I guess the easiest way would just be to `super(%Array.p.@@iterator%.call(v))`","msgtype":"m.text"},"ts":1596046775000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"jridgewell: problem is it isn't always an iterator ðŸ˜‚","msgtype":"m.text"},"ts":1596046862000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"so was hoping there was some kind of method to help","msgtype":"m.text"},"ts":1596046880000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Doesn't it have to be an iterable?","msgtype":"m.text"},"ts":1596046895000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"(if given)","msgtype":"m.text"},"ts":1596046901000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"yes, but `[...Array.prototype[Symbol.iterator].call(new Map())]` is empty for example","msgtype":"m.text"},"ts":1596046931000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"well populate that map with [[1,1]]","msgtype":"m.text"},"ts":1596046953000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"still empty","msgtype":"m.text"},"ts":1596046958000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: you'd have to cache the original Map.prototype[Symbol.iterator], and then install it as a nonconfigurable own property on the subclass's prototype, i think","msgtype":"m.text"},"ts":1596048129000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"for each parameter type possible yea","msgtype":"m.text"},"ts":1596048146000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"not just since we are a subclass","msgtype":"m.text"},"ts":1596048151000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"though, we already cache almost all intrinsics so...","msgtype":"m.text"},"ts":1596048160000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"}
]