[
{"content":{"body":"can anyone make sense of this? https://github.com/Agoric/proposal-infix-bang","msgtype":"m.text"},"ts":1562979580000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"deferred operations on objects is what i'm seeing","msgtype":"m.text"},"ts":1562979603000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it looks like a really really large proposal","msgtype":"m.text"},"ts":1562993957000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like, the first one is \"promise prototype methods for deferred operations on a fulfillment value\"","msgtype":"m.text"},"ts":1562993974000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and the second piece is \"syntax for those methods\"","msgtype":"m.text"},"ts":1562993980000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: i think fluent apis can already do the deferred operations tbh","msgtype":"m.text"},"ts":1562994342000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: what do you mean","msgtype":"m.text"},"ts":1562994354000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like `target!foo` can just be `target.foo`","msgtype":"m.text"},"ts":1562994356000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: not if `target` is a promise","msgtype":"m.text"},"ts":1562994363000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"then it'd be `(await target).foo`","msgtype":"m.text"},"ts":1562994367000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or `target.then(x => x.foo)` really","msgtype":"m.text"},"ts":1562994376000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"well your weird proxy thing would be part of a larger api","msgtype":"m.text"},"ts":1562994386000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like in the readme's queue message example","msgtype":"m.text"},"ts":1562994396000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i guess i'm mostly confused why we need syntax for methods nobody's using yet","msgtype":"m.text"},"ts":1562994398000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`messageThing().foo(1, 2, 3)`","msgtype":"m.text"},"ts":1562994405000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"can use proxies","msgtype":"m.text"},"ts":1562994409000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it'll be an interesting topic","msgtype":"m.text"},"ts":1562994410000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and thenable","msgtype":"m.text"},"ts":1562994412000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah i'm interested to hear the discussion","msgtype":"m.text"},"ts":1562994472000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: yeah, the methods would need to be added and shown to be widely useful before the syntax could even be considered I’d think","msgtype":"m.text"},"ts":1563007344000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"also not sure this needs new syntax at all: I am pretty sure you could just use a proxy which has traps for invocation and property access / assignment, and then use the existing syntax. something like `let remote = makeHandledPromise(); remote.foo(); remote.bar = 42; let value = await settle(remote);`","msgtype":"m.text"},"ts":1563007683000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"anyway the point of the proposal, as I understand it, is that you want to have code which represents a sequence of operations on remote data without actually requiring the data to be passed from the remote system back to the system running the code at every step","msgtype":"m.text"},"ts":1563007786000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"aside from the new API stuff, it's cool to imagine `fetch()!.json().something`","msgtype":"m.text"},"ts":1563025569000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oops `fetch()!.json()!.something`","msgtype":"m.text"},"ts":1563025596000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"perhaps it's a bit easy to forget an exclamation mark","msgtype":"m.text"},"ts":1563025607000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Excited to see the progress on https://github.com/tc39/proposal-explicit-resource-management","msgtype":"m.text"},"ts":1563028434000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think the infix bang idea is cool but not cool enough to carry its weight in the language.","msgtype":"m.text"},"ts":1563028474000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So many new methods which are just awkward and ugly and nobody would use given that we have await","msgtype":"m.text"},"ts":1563028490000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And the actual bang syntax is pretty error-prone and hard to read","msgtype":"m.text"},"ts":1563028506000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I'd rather explore executing code remotely using something like blöcks","msgtype":"m.text"},"ts":1563028531000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i can't believe we might actually have RAII in the language","msgtype":"m.text"},"ts":1563029416000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm kinda sad it's squeezed into the top of a try block","msgtype":"m.text"},"ts":1563029478000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I don't think it counts as RAII if you have to declare a specific using statement","msgtype":"m.text"},"ts":1563030110000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It's more like RAIRA","msgtype":"m.text"},"ts":1563030114000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I.e. the point of RAII is that just intializing is equivalent to resource acquisition","msgtype":"m.text"},"ts":1563030142000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Whereas this requires a specific resource acquisition statement (try, formerly using)","msgtype":"m.text"},"ts":1563030156000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"\"resource acquisition is resource acquisition\"","msgtype":"m.text"},"ts":1563030340000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i just imagine stuff like `try (const _handleScope = v8.handleScope()) {}`","msgtype":"m.text"},"ts":1563030376000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"You don't need the extra binding actually","msgtype":"m.text"},"ts":1563030390000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But yes that's the idea","msgtype":"m.text"},"ts":1563030396000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"The difference is more in cases like the file handle ones","msgtype":"m.text"},"ts":1563030410000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Whereas in C++ you just initialize the file and poof, resources allocated and deallocated at end of block","msgtype":"m.text"},"ts":1563030428000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"In this proposal you need to remember the try() or else you don't get auto-deallocation","msgtype":"m.text"},"ts":1563030444000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(To be clear, this proposal seems to be the best you can do in a GC'ed language.)","msgtype":"m.text"},"ts":1563030470000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"could just check every lexical declaration at the end of a block :)","msgtype":"m.text"},"ts":1563030549000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I assume there's a reason that doesn't work but it's too early for me to think hard enough to figure it out","msgtype":"m.text"},"ts":1563030636000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i would assume performance","msgtype":"m.text"},"ts":1563030659000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"although i guess engines like v8 already have stuff like \"does this object have a toStringTag\"","msgtype":"m.text"},"ts":1563030674000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Nah","msgtype":"m.text"},"ts":1563030706000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Google to the rescue https://softwareengineering.stackexchange.com/a/216032/13312","msgtype":"m.text"},"ts":1563030710000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"TLDR it needs a lot more infrastructure like copy constructors, move semantics, etc.","msgtype":"m.text"},"ts":1563030725000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"oh yeah","msgtype":"m.text"},"ts":1563030780000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"In a language where everything is a reference type, attaching significance to object lifetimes and making things more stack-bound starts crossing into value type territory","msgtype":"m.text"},"ts":1563030787000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1563030790000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i could always do","msgtype":"m.text"},"ts":1563030796000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`let x; try (const y = whatever) { x = y }`","msgtype":"m.text"},"ts":1563030811000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or i guess just `x = whatever; try (x) {} `","msgtype":"m.text"},"ts":1563030840000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"seems to have the same issue","msgtype":"m.text"},"ts":1563030849000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but i guess its more explicit","msgtype":"m.text"},"ts":1563030856000,"senderName":"devsnek","senderId":"devsnek@irc"}
]