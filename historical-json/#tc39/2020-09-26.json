[
{"content":{"body":"devsnek: Thank u!","msgtype":"m.text"},"ts":1601087655000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"ðŸ‘","msgtype":"m.text"},"ts":1601087826000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: yeah, i also think rest destructuring should have optional trailing comma, and proposal deiter actually need it for consistency if `[a, ...rest, b]` is added.","msgtype":"m.text"},"ts":1601087848000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"I never know deconstructing on an iterator will close the iterator instantly until I read the spec yesterday","msgtype":"m.text"},"ts":1601091508000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"I think it is a footgun if we want to use bare iterator without iterable.","msgtype":"m.text"},"ts":1601091564000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"Even worse, people won't found this on StringIterator ArrayIterator etc. This only happens on an iterator implements return method. Only generators will be affected","msgtype":"m.text"},"ts":1601091640000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"Imo, the Array iterator having return would be a good thing. It could cleanup reference to the array.","msgtype":"m.text"},"ts":1601091709000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"jackworks: iterators are iterable","msgtype":"m.text"},"ts":1601094691000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think you have the wrong mental model of it","msgtype":"m.text"},"ts":1601094703000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"iterable means any object with Symbol.iterator","msgtype":"m.text"},"ts":1601094731000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it doesn't imply anything else","msgtype":"m.text"},"ts":1601094740000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"So what should I call a thing that return a new iterator every time when I call symbol.iterator?","msgtype":"m.text"},"ts":1601095814000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"haxjs: i agree that even if not before, deiter would need it","msgtype":"m.text"},"ts":1601096735000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"jackworks: that's what an iterable is","msgtype":"m.text"},"ts":1601096766000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"jackworks: but it's not a single thing. it's a \"trait\", an interface. everything might be iterable, there's no noun called \"iterable\" yet","msgtype":"m.text"},"ts":1601096782000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"No I'm asking for another concept, what should I call an object that implements symbol.iterator and return a new unconsumed iterator every time it's being called","msgtype":"m.text"},"ts":1601102320000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"that's \"iterable\"","msgtype":"m.text"},"ts":1601102347000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"every iterable does that","msgtype":"m.text"},"ts":1601102350000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"oh hm","msgtype":"m.text"},"ts":1601102355000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i guess iterators themselves don't","msgtype":"m.text"},"ts":1601102360000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"\"iterables that aren't iterators\" always do tho","msgtype":"m.text"},"ts":1601102367000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(by convention, ofc)","msgtype":"m.text"},"ts":1601102374000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"iow, an iterable that *doesn't* always provide a fresh one, that isn't itself an iterator, is the rarity","msgtype":"m.text"},"ts":1601102398000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the spec doesn't have a term for that","msgtype":"m.text"},"ts":1601105524000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"But we need to talk about it out of the spec that cuz all of our reusability problems are related to it","msgtype":"m.text"},"ts":1601106693000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"jackworks: reusability happens via functions","msgtype":"m.text"},"ts":1601106751000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"jackworks: the fact that \"iterable\" just isn't a noun doesn't actually create any problems. Reusability in JS for `f()` is `() => f()`. 4 characters, 6 if you want the pretty spacing.","msgtype":"m.text"},"ts":1601107027000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"iow, *everything* is reusable, you just wrap it in a function","msgtype":"m.text"},"ts":1601107041000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"consider this code","msgtype":"m.text"},"ts":1601108100000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"const r = range(0, 100) // where range is a userland generator","msgtype":"m.text"},"ts":1601108234000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"const [a, b] = r","msgtype":"m.text"},"ts":1601108250000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"I expect it to be 0 and 1,it's ok","msgtype":"m.text"},"ts":1601108262000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"const [c, d] = r","msgtype":"m.text"},"ts":1601108272000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"Ought to be 2 and 3 but now I get undefined undefined","msgtype":"m.text"},"ts":1601108290000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"ok so then your expectation is wrong","msgtype":"m.text"},"ts":1601108300000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if you wanted it to be reusable, you'd do `() => range(0, 100)` and do `const [a, b] = r(); const [c, d] = r()`","msgtype":"m.text"},"ts":1601108321000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"because almost every iterator in JS is one-use","msgtype":"m.text"},"ts":1601108328000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Then your code will get 0 1 0 1","msgtype":"m.text"},"ts":1601108343000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"Not 0 1 2 3","msgtype":"m.text"},"ts":1601108347000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1601108351000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"This is another problem","msgtype":"m.text"},"ts":1601108356000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"wait","msgtype":"m.text"},"ts":1601108366000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ok so i just tried it and indeed i got 0, 1, 2, 3","msgtype":"m.text"},"ts":1601108409000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"What did you try on?","msgtype":"m.text"},"ts":1601108424000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"`const arr = [0, 1, 2, 3]; const r = arr.values(); const [a, b] = r; const [c, d] = r;`","msgtype":"m.text"},"ts":1601108425000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"node's repl","msgtype":"m.text"},"ts":1601108427000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"No","msgtype":"m.text"},"ts":1601108431000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"how would \"range\" be implemented so that doesn't work?","msgtype":"m.text"},"ts":1601108441000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ArrayIterator is not a user land generator","msgtype":"m.text"},"ts":1601108445000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"This is a problem with userland generator(or any iterator with return method) to be used to with deconstructing","msgtype":"m.text"},"ts":1601108493000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"ok, fair, `const g = function*() { yield 0; yield 1; yield 2; yield 3; }; const r = g(); const [a, b] = r; const [c, d] = r; [a, b, c, d]` does what you say","msgtype":"m.text"},"ts":1601108499000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and yeah that seems super weird to me","msgtype":"m.text"},"ts":1601108514000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I think this is super surprised to me","msgtype":"m.text"},"ts":1601108515000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"but that's a problem with generators","msgtype":"m.text"},"ts":1601108518000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'd certainly be interested to learn why it works that way","msgtype":"m.text"},"ts":1601108551000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Cause any deconstruction will close the iterator instantly","msgtype":"m.text"},"ts":1601108596000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"I guess it's memory leaking concern","msgtype":"m.text"},"ts":1601108604000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"it's weird that it'd do that for generator iterators but not for an ArrayIterator","msgtype":"m.text"},"ts":1601108615000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Cause ArrayIterator don't have a return method on it","msgtype":"m.text"},"ts":1601108636000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"ah. Then itâ€™s a shame generators do :-/","msgtype":"m.text"},"ts":1601108792000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"It's the problem of deconstructing semantics and we're too late to change anything ðŸ˜¥","msgtype":"m.text"},"ts":1601109103000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"it's more of an ownership problem","msgtype":"m.text"},"ts":1601109134000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"everything in the spec that takes an iterable assumes it has full ownership","msgtype":"m.text"},"ts":1601109167000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"[haxjs](https://matrix.to/#/@freenode_haxjs:matrix.org) suggested add a new syntax [a, ...] to tell the language it shouldn't close the iterator, but that syntax seems like \"hey please call next until done\" to me .","msgtype":"m.text"},"ts":1601109175000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"you could add an iterator helper method which returns a wrapper that doesn't forward closing","msgtype":"m.text"},"ts":1601109261000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"That's too implicit","msgtype":"m.text"},"ts":1601109453000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"I'll never imagine this behavior until I step into a bug cause by it","msgtype":"m.text"},"ts":1601109487000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"jackworks: I suggested to add new syntax `[a, ...]` for either always close or always not close because current behavior is sometime close (generator), sometime not (ArrayIterator) which is very weird and error-prone :)","msgtype":"m.text"},"ts":1601132630000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"Personally I think ArrayIterator should also close. We should add `return` to all builtin Iterators to \"fix\" it. But maybe it's too late.","msgtype":"m.text"},"ts":1601132759000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"If we had unused param, we could use `[a, ...?]` for always close and use `[a, ...]` for always not close. Unfortunately we do not have unused param now.","msgtype":"m.text"},"ts":1601132911000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"jackworks: i mean, the range Iterator doesnâ€™t have to have return on it, right?","msgtype":"m.text"},"ts":1601136585000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yeah","msgtype":"m.text"},"ts":1601136675000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"We can do whatever we want to do on the intrinsics","msgtype":"m.text"},"ts":1601136712000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"So it's the problem of userland generator DX","msgtype":"m.text"},"ts":1601136748000,"senderName":"jackworks","senderId":"jackworks@irc"}
]