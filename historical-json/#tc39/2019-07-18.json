[
{"content":{"body":"In https://tc39.es/ecma262/#sec-createintrinsics, why is thrower created before funcProto","msgtype":"m.text"},"ts":1563466890000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if it was created after, it wouldn't need the SetPrototypeOf call","msgtype":"m.text"},"ts":1563466901000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"also test262 expects thrower to have [[Extensible]] = false","msgtype":"m.text"},"ts":1563467140000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but at no point is thrower.[[Extensible]] set to false as far as i can tell","msgtype":"m.text"},"ts":1563467153000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh the intrinsic says \"The value of the [[Extensible]] internal slot of a %ThrowTypeError% function is false.\"","msgtype":"m.text"},"ts":1563467232000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but the intrinsic is also manually created with a call to CreateBuiltinFunction","msgtype":"m.text"},"ts":1563467243000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and mutated","msgtype":"m.text"},"ts":1563467246000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: seems like a good editorial improvement :-)","msgtype":"m.text"},"ts":1563467334000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i was just making a commit now","msgtype":"m.text"},"ts":1563467344000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: I think it *used* to make sense.","msgtype":"m.text"},"ts":1563467684000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I'll see if I can find it.","msgtype":"m.text"},"ts":1563467694000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"i can probably remove the entire `AddRestrictedFunctionProperties` thing too","msgtype":"m.text"},"ts":1563467728000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"See https://github.com/tc39/ecma262/issues/877 and https://github.com/tc39/ecma262/pull/1148","msgtype":"m.text"},"ts":1563467851000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"hmmmmm","msgtype":"m.text"},"ts":1563467987000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well my thing is purely editorial","msgtype":"m.text"},"ts":1563467998000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: jmdyck: https://github.com/tc39/ecma262/pull/1635/","msgtype":"m.text"},"ts":1563468495000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I'll have a look once I'm finished with last night's merges.","msgtype":"m.text"},"ts":1563468538000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"`({a, b} = obj);` is a little awkward. I wonder whether do expression could help? Is `do {a, b} = obj;` valid?","msgtype":"m.text"},"ts":1563475805000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"Oh, I realize it's a silly question... syntax conflict with current `do {} while` X)","msgtype":"m.text"},"ts":1563476179000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"haxjs: https://github.com/tc39/proposal-do-expressions","msgtype":"m.text"},"ts":1563476224000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Thanks, devsnek. I just found my head is not clear in this moment (3AM in my timezone) and decide to go to bed now. '=D","msgtype":"m.text"},"ts":1563476367000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"üëçüèª","msgtype":"m.text"},"ts":1563476381000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Domenic: random question: in the OP of https://github.com/tc39/proposal-weakrefs/issues/17 you assert \"To correctly implement this step, you need a reference to every NodeIterator object that's ever been created, so you can update it correctly \". The way I'd expect to implement this is to have the NodeIterator objects, when queried, check the document to see which nodes are still live. is there a reason that implementation doesn't work?","msgtype":"m.text"},"ts":1563476485000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(this doesn't require WeakRefs, and so seems more reasonable)","msgtype":"m.text"},"ts":1563476564000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"What do you mean by \"when queried\"?","msgtype":"m.text"},"ts":1563476595000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"oh that reminds me https://gist.github.com/devsnek/e3ee8be1fc235e2bee43b2c1cd262adf","msgtype":"m.text"},"ts":1563476636000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`.nextNode()` etc?","msgtype":"m.text"},"ts":1563476648000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this could be changed to a weakset fairly easily and used in jsdom","msgtype":"m.text"},"ts":1563476658000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or whatever other methods exist for code to look at the contents of a NodeIterator","msgtype":"m.text"},"ts":1563476660000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you have to have a reference to the node iterator first","msgtype":"m.text"},"ts":1563476676000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: ?","msgtype":"m.text"},"ts":1563476692000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I am proposing that the implementation of the nodeIterator `nextNode` method query the document to see what nodes are still live","msgtype":"m.text"},"ts":1563476711000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if no one has a reference to the nodeIterator, no one is going to call nextNode, and the point is moot","msgtype":"m.text"},"ts":1563476723000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in js though, exists and live are the same thing","msgtype":"m.text"},"ts":1563476792000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"until you add weakrefs","msgtype":"m.text"},"ts":1563476801000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: I have no idea what you are trying to say","msgtype":"m.text"},"ts":1563476857000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"maybe i'm misunderstanding","msgtype":"m.text"},"ts":1563476864000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the issue above gives an algorithm for \"removing a node\"","msgtype":"m.text"},"ts":1563476879000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what I meant by \"live\" in my first message was \"not yet removed\"","msgtype":"m.text"},"ts":1563476888000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: I am not 100% sure if this was the reason, but I believe you cannot just figure out the next node based on the current state of the tree; you need to see all the intermediate mutations.","msgtype":"m.text"},"ts":1563477003000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So doing it lazily when queried will give wrong results.","msgtype":"m.text"},"ts":1563477018000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ah, fun","msgtype":"m.text"},"ts":1563477021000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: Domenic: in particular there‚Äôs a reference node affected by mutations","msgtype":"m.text"},"ts":1563480002000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I guess you could use mutation observers","msgtype":"m.text"},"ts":1563480065000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"would anyone happen to know of a careful derivation of the length of the longest possible string returned by NumberToString?  https://tc39.es/ecma262/#sec-tostring-applied-to-the-number-type  the algorithm was not written in a fashion that makes the maximum length clear","msgtype":"m.text"},"ts":1563484259000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"jwalden: i don't believe there is a maximum length in the spec; it'd just be memory constraints of the host","msgtype":"m.text"},"ts":1563490342000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"jwalden: same as there's no max on string length","msgtype":"m.text"},"ts":1563490347000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"tfw `delete a?.b` comes for free in the spec but not the implementation","msgtype":"m.text"},"ts":1563490386000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ljharb: oh there most certainly *is* a maximum length, 64-bit floats mean at most 2**64 possible result strings so they *have* to have an upper limit","msgtype":"m.text"},"ts":1563490387000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"jwalden: are bigints 64 bit tho? i thought they were unbounded","msgtype":"m.text"},"ts":1563490399000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"jwalden: oh this isn't bigint tho, nvm","msgtype":"m.text"},"ts":1563490413000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: NumberToString takes in numbers, not bigints","msgtype":"m.text"},"ts":1563490413000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"rkirsling: you mean babel?","msgtype":"m.text"},"ts":1563490775000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: just did a JSC impl :p","msgtype":"m.text"},"ts":1563491151000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: why doesn't delete come for free?","msgtype":"m.text"},"ts":1563491187000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"we have a hackathon going on so I was like \"hmm what do I want to spend a free day on\"","msgtype":"m.text"},"ts":1563491189000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"doesn't `a?.b` either return undefined or a member reference","msgtype":"m.text"},"ts":1563491198000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"dunno, it's possible I maybe a simple mistake, will let you know :D","msgtype":"m.text"},"ts":1563491210000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"*made","msgtype":"m.text"},"ts":1563491215000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i'm looking forward to using the impl :)","msgtype":"m.text"},"ts":1563491229000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i added optional chaining to a language i'm working on a few days ago inspired by the js proposal https://github.com/devsnek/slither/commit/09746bc21e2ba0fcb8872af63f4cc62395ba8f03","msgtype":"m.text"},"ts":1563491261000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"awesome","msgtype":"m.text"},"ts":1563491431000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah no it looks like (at least for JSC) `delete` makes assumptions about its expression so I have to update them","msgtype":"m.text"},"ts":1563491469000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah i would've assumed they have all sorts of shortcuts that make life hard","msgtype":"m.text"},"ts":1563491501000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: this should give you an idea: https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/parser/Nodes.h#L985-L1025","msgtype":"m.text"},"ts":1563491898000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"oh my","msgtype":"m.text"},"ts":1563491956000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that's rough","msgtype":"m.text"},"ts":1563491999000,"senderName":"devsnek","senderId":"devsnek@irc"}
]