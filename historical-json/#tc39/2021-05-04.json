[
{"content":{"body":"yes, that's how they all work, and yes, it's extremely gross","msgtype":"m.text"},"ts":1620087019000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the worst one is, `l\\u{65}t\\nx` is a reference to `let` followed by a reference to `x`, rather than a declaration of `x` the way that `let\\nx` would be","msgtype":"m.text"},"ts":1620087075000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(though technically that one isn't a consequence of lookahead restrictions, I guess)","msgtype":"m.text"},"ts":1620087134000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"my goodness","msgtype":"m.text"},"ts":1620087409000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: when you say \"(which is, here, the context created to evaluate the \"resolve\" handler for the promise)\", is that an 'Await fulfilled function' ?","msgtype":"m.text"},"ts":1620091388000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"that's not what I intended to refer to, though I might be mistaken about which is actually the top of the stack at that point","msgtype":"m.text"},"ts":1620092004000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I didn't trace the Await machinery all that carefully","msgtype":"m.text"},"ts":1620092021000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah, yeah, it's the one context created to run the Await fulfilled function (","msgtype":"m.text"},"ts":1620092758000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(which lives in \"onFulfilled in the Await steps)","msgtype":"m.text"},"ts":1620092774000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sorry, you *did* mention  'Await fulfilled function' at the time.","msgtype":"m.text"},"ts":1620099360000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"so when the timeout completes, does the host invoke a 'PromiseReaction' job?","msgtype":"m.text"},"ts":1620099551000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"i.e., starting at step 1.a in NewPromiseReactionJob","msgtype":"m.text"},"ts":1620099626000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"well, not immediately, but ultimately yes","msgtype":"m.text"},"ts":1620099837000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"when the timeout completes, control goes Promise Resolve Functions -> FulfillPromise -> TriggerPromiseReactions -> HostEnqueuePromiseJob, and then at some future time, as a consequence of HostEnqueuePromiseJob, the host runs the steps in 1.a of NewPromiseReactionJob","msgtype":"m.text"},"ts":1620099863000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so much machinery","msgtype":"m.text"},"ts":1620100010000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yyyyyyup","msgtype":"m.text"},"ts":1620100015000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"also, before then, I'm not clear on when/where the ConciseBody is evaluated","msgtype":"m.text"},"ts":1620100095000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"the concisebody is evaluated in step 9 of the Promise constructor","msgtype":"m.text"},"ts":1620100148000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(i.e. as part of the `new Promise` call)","msgtype":"m.text"},"ts":1620100160000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so that would be in an execution context stacked onto the genContext","msgtype":"m.text"},"ts":1620100296000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yes, though one which is pushed and popped without doing any unusual juggling","msgtype":"m.text"},"ts":1620100326000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"strictly speaking it's actually twice-nested, because there's an execution context pushed for the call to Promise as well","msgtype":"m.text"},"ts":1620100338000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which then pushes the context for the arrow","msgtype":"m.text"},"ts":1620100345000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah yup","msgtype":"m.text"},"ts":1620100360000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"so when the Await Fulfilled Function starts, the running execution context is probably nothing much?","msgtype":"m.text"},"ts":1620101081000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"no wait, you say it's \"the context created to evaluate the \"resolve\" handler for the promise\"","msgtype":"m.text"},"ts":1620101318000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"i.e., created by the host?","msgtype":"m.text"},"ts":1620101353000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"\"the context created to evaluate the \"resolve\" handler for the promise\" isn't really precise","msgtype":"m.text"},"ts":1620101391000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I just meant that the host will create an execution context to run the PromiseReactionJob","msgtype":"m.text"},"ts":1620101455000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah, okay","msgtype":"m.text"},"ts":1620101467000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Bakkot: re https://freenode.logbot.info/tc39/20210503","msgtype":"m.text"},"ts":1620136196000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"19:38: \"so AsyncGeneratorResumeNext [at 15] suspends the caller context - which, as  before, is the context created to evaluate the \"resolve\" handler for the  promise - and then [17] pushes and [18] resumes the generator context\"","msgtype":"m.text"},"ts":1620136320000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"but look more closely at 18: it says \"Resume the suspended evaluation of genContext\". But genContext's evaluation was never suspended!","msgtype":"m.text"},"ts":1620136504000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"AsyncGeneratorYield step 8 removed it from the stack, but didn't suspend it, and didn't resume the new running execution context","msgtype":"m.text"},"ts":1620136624000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"so during the execution of AsyncGeneratorResolve, [the \"resolve\" handler] is the running execution context, but it hasn't been resumed.","msgtype":"m.text"},"ts":1620136919000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Well, strictly speaking, I shouldn't say \"resumed\", because in the current spec, the generative side doesn't \"resume\" the setup side. But it \"returns to\". So AsyncGeneratorYield at the conclusion of step 9 will \"return to\" the op that most recently resumed the eval of genContext (which actually isnt an operation, but the alg for an Await fulfilled function?), but that hasn't happened yet.","msgtype":"m.text"},"ts":1620137219000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Hm.","msgtype":"m.text"},"ts":1620137722000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"re my issue #2400, I'm now thinking that the intended mental model was that the stack-manipulation step *is* an implied Resume (or however you want to refer to the generative->setup transfer of control).","msgtype":"m.text"},"ts":1620138176000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(which of course is inconsistent with the rest of the spec, where you still need an explicit Resume after a stack-push)","msgtype":"m.text"},"ts":1620138258000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"no, that's still not it, because a Resume transfers control to a suspended algorithm, and the step after the Resume step isn't executed until/if control ever returns.","msgtype":"m.text"},"ts":1620138415000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"But when AsyncGeneratorYield step 7 does the stack-pop, it doesn't transfer control to some suspended op, we're supposed to proceed to step 8 + 9, right?","msgtype":"m.text"},"ts":1620138509000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"so between the stack-pop and the eventual return, we're still in AsyncGenYield, so control hasn't transferred anywhere, and yet we're supposed to assume that genContext has been suspended (and the setup context has been [resumed])?","msgtype":"m.text"},"ts":1620138772000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"If AsyncGeneratorYield's stack-pop *did* involve a transfer of control, it would go back to the Await fulfilled function, which would accomplish close to nothing, and the genContext would never be resumed?, so that can't be it.","msgtype":"m.text"},"ts":1620144027000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"jmdyck: my reading of the current specification is that a stack-pop is implicitly a suspend, but neither this implicit suspend nor an explicit suspend entails a transfer of control. otoh, a stack-push is _not_ implicitly a resume, and an explicit resume _is_ a transfer of control.","msgtype":"m.text"},"ts":1620144739000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so after AsyncGeneratorYield step 7, _genContext_ is suspended, and the topmost execution context is the one below it (the one created by the host for the timeout promise's handler, in this example), but control remains in AsyncGeneratorYield","msgtype":"m.text"},"ts":1620144873000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: So a stack-pop is an implicit suspend, but a stack-push isn't an implicit resume; a suspend isn't a transfer of control, but a resume is. Well, that might work, but I wouldn't call it intuitively obvious.","msgtype":"m.text"},"ts":1620148563000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"agreed","msgtype":"m.text"},"ts":1620148583000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's just what I derive by working backwards from what the spec seems to be actually doing","msgtype":"m.text"},"ts":1620148599000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yup.","msgtype":"m.text"},"ts":1620148616000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I still like my \"we should conflate stack manipulation and transfer of control\" framing","msgtype":"m.text"},"ts":1620148635000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"though the above conversation made me realize we'd need to refactor the async generator plumbing to make it work","msgtype":"m.text"},"ts":1620148653000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so how would that handle AsyncGenYield?","msgtype":"m.text"},"ts":1620148656000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1620148665000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"which, I'm not sure how feasible that is; I'd need to actually try the rewrite to see.","msgtype":"m.text"},"ts":1620149009000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what if the Await fulfilled function (etc), rather than pushing asyncContext onto the stack and resuming it, instead created an intermediary context and resumed that. The intermediary context would initially just push the asynccontext and resume it, BUT it would be there waiting for an explicit resume, at which point it could do the AsyncGeneratorResolve.","msgtype":"m.text"},"ts":1620149109000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"except presumably sometimes it shouldn't do AsyncGeneratorResolve","msgtype":"m.text"},"ts":1620149218000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"or maybe i take that back.","msgtype":"m.text"},"ts":1620149382000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Await fulfilled functions are also used for regular async functions, not just async generators","msgtype":"m.text"},"ts":1620149418000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"well, there's lots of pseudocode that switches on GeneratorKind","msgtype":"m.text"},"ts":1620149476000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"true, we could switch on whether it's an async generator or async function","msgtype":"m.text"},"ts":1620149499000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i suppose you wouldn't need the extra context, you could do it in the same context as the Await fulfilled function?","msgtype":"m.text"},"ts":1620149666000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"that might be slightly less spaghetti","msgtype":"m.text"},"ts":1620149720000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"the thing I was thinking of was more along the lines of, AsyncGeneratorResumeNext is recursive so that it can drain the queue. but we could break the recursion (by having AsyncGeneratorResolve and AsyncGeneratorReject not call it), and instead an explicit loop to drain the queue","msgtype":"m.text"},"ts":1620149788000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you'd need two explicit loops, I guess, one in AsyncGeneratorEnqueue and one... somewhere else, to handle the case that something is enqueued while it is `await`ing","msgtype":"m.text"},"ts":1620149830000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that sounds like more than a refactoring","msgtype":"m.text"},"ts":1620149930000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"as in you think it would have observable implications?","msgtype":"m.text"},"ts":1620149948000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"wouldn't do it if so, but I was hoping it would not be observable","msgtype":"m.text"},"ts":1620149959000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no, i just meant it sounded like it would be difficult (for me) to verify it as preserving correctness/behavior","msgtype":"m.text"},"ts":1620150133000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"oh, sure","msgtype":"m.text"},"ts":1620150139000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess maybe a simpler option would be to have AsyncGeneratorYield not do the suspend","msgtype":"m.text"},"ts":1620150190000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"wha?","msgtype":"m.text"},"ts":1620150215000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"but you figure stack-pop is an implicit suspend, how do you not do it?","msgtype":"m.text"},"ts":1620150255000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"that logic could be moved into AsyncGeneratorResumeNext, and made conditional on the queue being empty","msgtype":"m.text"},"ts":1620150270000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so in AsyncGeneratorResumeNext, if the state is executing, it would check the queue and if it was empty then do the set-code-execution-state-and-suspend that AsyncGeneratorYield currently does, and if it is not then just execute the logic directly, instead of storing it in the code execution state","msgtype":"m.text"},"ts":1620150338000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so that we avoid the current situation where there is a suspension and then immediate resumption a few steps later","msgtype":"m.text"},"ts":1620150370000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'm not really following.","msgtype":"m.text"},"ts":1620150395000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"mm, yeah, hard to describe","msgtype":"m.text"},"ts":1620150408000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"So AGYield wouldn't have the stack-pop?","msgtype":"m.text"},"ts":1620150415000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I might make a strawman PR if I have time","msgtype":"m.text"},"ts":1620150415000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1620150418000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that would be moved into the AsyncGeneratorResumeNext call","msgtype":"m.text"},"ts":1620150423000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(or the step 8 set code eval state)","msgtype":"m.text"},"ts":1620150439000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1620150450000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it would just go straight to invoking AGResolve","msgtype":"m.text"},"ts":1620150463000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So does AGResolve","msgtype":"m.text"},"ts":1620150511000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"'s step 8 not care what the running ex context is?","msgtype":"m.text"},"ts":1620150534000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Also there are other invocations of AGResolve: are they going to be okay with this change?","msgtype":"m.text"},"ts":1620150630000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(and other invocations of AGResumeNext)","msgtype":"m.text"},"ts":1620150687000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"AGResumeNext currently has an assertion that the state is not ~executing~, so if the new logic were guarded on the state being ~executing~, it shouldn't affect the other callers","msgtype":"m.text"},"ts":1620150830000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think AGResolve does not care what the running execution context is, though I'm not 100% certain","msgtype":"m.text"},"ts":1620150873000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"anyway I haven't thought through this very far, just talking through possibilities","msgtype":"m.text"},"ts":1620150893000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sure","msgtype":"m.text"},"ts":1620150915000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"and I haven't thought about the `.return` calls at all","msgtype":"m.text"},"ts":1620150920000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"fundamentally the bit that I don't like is that AsyncGeneratorYield pops the execution context but does not immediately return control there","msgtype":"m.text"},"ts":1620151148000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's been bugging me for days","msgtype":"m.text"},"ts":1620151174000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"that's why 2400 is only an issue and not a PR","msgtype":"m.text"},"ts":1620151230000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"because my brilliant idea didn't work for AGYield","msgtype":"m.text"},"ts":1620151243000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"because of the AGResolve call between the stack-pop and the control transfer.","msgtype":"m.text"},"ts":1620151283000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Bakkot: so AGYield's step 6 \"Set generator.[[AsyncGeneratorState]] to suspendedYield.\" would instead set it to executing?","msgtype":"m.text"},"ts":1620151532000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"hm, currently it gets set to executing late in AGResumeNext","msgtype":"m.text"},"ts":1620151619000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":" it's already executing in AGYield","msgtype":"m.text"},"ts":1620152036000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"how?","msgtype":"m.text"},"ts":1620152239000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Currently the only way you can be executing the body of the async generator, and so perform AGYield, is via step 18 of AGResumeNext, which is immediately preceded by setting the state to ~executing~","msgtype":"m.text"},"ts":1620152360000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh right, there's an AGREsumeNext way back near the start if this example","msgtype":"m.text"},"ts":1620152492000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ok, so take steps 6,7,8 from AGYield, push them down into AGResolve (at which point we have to wrap them in \"If state is ~executing~\" so that other invocations aren't disturbed), past AGResolve's `Call` at step 8, and down into AGResumeNext,","msgtype":"m.text"},"ts":1620153315000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"In AGResumeNext, if the queue is not empty, I'm not sure what you mean by \"then just execute the logic directly, instead of storing it in the code execution state\"","msgtype":"m.text"},"ts":1620154948000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"...","msgtype":"m.text"},"ts":1620156038000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I've been looking at other calls to AGResolve. The one in AGStart is another case where we do a stack-pop without an immediate control-transfer.","msgtype":"m.text"},"ts":1620156124000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"It looks like currently, AGResolve is only invoked when the async context is suspended (not the running context). So that would make me worried about invoking it when the async context *is* the running context.","msgtype":"m.text"},"ts":1620156631000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"is there a way to \"break loop\" in the spec? Can someone point me to some part of the spec that does that?","msgtype":"m.text"},"ts":1620156893000,"senderName":"ryzokuken","senderId":"ryzokuken@irc"},
{"content":{"body":"I am writing a loop that I need to conditionally break out of...","msgtype":"m.text"},"ts":1620156917000,"senderName":"ryzokuken","senderId":"ryzokuken@irc"},
{"content":{"body":"ryzokuken: what's the use case?","msgtype":"m.text"},"ts":1620156923000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ryzokuken: i'd think an AO with an early return would be clearer","msgtype":"m.text"},"ts":1620156929000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: gotcha","msgtype":"m.text"},"ts":1620156942000,"senderName":"ryzokuken","senderId":"ryzokuken@irc"},
{"content":{"body":"ah okay that makes a whole lot of sense in hindsight, thanks ljharb","msgtype":"m.text"},"ts":1620157034000,"senderName":"ryzokuken","senderId":"ryzokuken@irc"},
{"content":{"body":"jmdyck: yeah, you're right: my most recent idea would end up changing the realm for the iterator result object created in AGResolve","msgtype":"m.text"},"ts":1620163064000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so it wouldn't be strictly editorial","msgtype":"m.text"},"ts":1620163070000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"however, I am certain it would be web-compat","msgtype":"m.text"},"ts":1620163078000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"cf results in https://gist.github.com/bakkot/587234af192dcb86f6a76b024a416c1c","msgtype":"m.text"},"ts":1620163084000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"also, note that the realm for the iterator result object for _regular_ generators is always that of the generator, because the result object is created before the stack-pop","msgtype":"m.text"},"ts":1620163128000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in that gist I believe FF's results are the ones which are correct per spec, but I wouldn't put money on it","msgtype":"m.text"},"ts":1620163171000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"https://github.com/tc39/ecma262/compare/master...jmdyck:AsyncGeneratorYield is what I had in mind","msgtype":"m.text"},"ts":1620163368000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"this doesn't work when there's no await","msgtype":"m.text"},"ts":1620163486000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no AwaitExpression in the AsyncGeneratorBody?","msgtype":"m.text"},"ts":1620163533000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1620163540000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"at least, I think not","msgtype":"m.text"},"ts":1620163542000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in that case it needs to do the AsyncGeneratorResolve steps, still","msgtype":"m.text"},"ts":1620163572000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it doesn't need to do the AsyncGeneratorResumeNext ones, because the steps in that case will just be to return immediately (generally speaking, since the queue would be empty)","msgtype":"m.text"},"ts":1620163645000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so if there isn't an await, then AGYield is returning to ... AGResumeNext?","msgtype":"m.text"},"ts":1620163657000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"but it needs to resolve the promise created by the first call to `.next`","msgtype":"m.text"},"ts":1620163667000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1620163670000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in your gist, why realm.eval('foo') rather than just declaring foo?","msgtype":"m.text"},"ts":1620164112000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"s/declaring/executing/","msgtype":"m.text"},"ts":1620164152000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"as in, why the `eval`? the point is to get a generator whose realm is different from the realm of the outer context","msgtype":"m.text"},"ts":1620164175000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1620164186000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I don't really follow what it's doing, but you're saying that implementations are fairly different in the behavior they exhibit, so web devs can't be relying on a particular behavior, so tc39 is free to pick one?","msgtype":"m.text"},"ts":1620164368000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(not \"pick one of the exhibited behaviors\" necessarily, but \"pick a specific behavior\")","msgtype":"m.text"},"ts":1620164490000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1620164632000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in terms of which realm the objects created by these AOs come from","msgtype":"m.text"},"ts":1620164655000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"we'd need consensus, still","msgtype":"m.text"},"ts":1620164683000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so then what about the calls to AGResolve when the async context isn't the running context? Won't they create objects in a different realm from those created when the async context *is* the running context?","msgtype":"m.text"},"ts":1620166410000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yes, unless we patched that","msgtype":"m.text"},"ts":1620167083000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"something like that already happens, though: the iterator result created during normal operation of a non-async generator comes from the generator realm, but if you call `Generator.prototype.return` on the generator after it is already completed you get an object created in the realm of your `Generator.prototype.return`","msgtype":"m.text"},"ts":1620167182000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(which is not necessarily the same realm as the generator, since you can `.call` it across realms)","msgtype":"m.text"},"ts":1620167205000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"not just `.return` but also `.next` after the generator has completed, I should say","msgtype":"m.text"},"ts":1620167237000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that is: the iterator result object created in step 2 of GeneratorResume is created in the realm of the caller (e.g. Generator.prototype.return), whereas the iterator result object created in step 3 of Yield is created in the realm of the generator itself","msgtype":"m.text"},"ts":1620167301000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"all this is just to say that we're already inconsistent here","msgtype":"m.text"},"ts":1620167315000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sorry, two lines up, for Generator.prototype.return read Generator.prototype.next","msgtype":"m.text"},"ts":1620167883000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: and your gist shows that implementations differ even on the non-async generators?","msgtype":"m.text"},"ts":1620171102000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1620171558000,"senderName":"Bakkot","senderId":"Bakkot@irc"}
]