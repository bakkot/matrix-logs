[
{"content":{"body":"surprisingly useful https://gc.gy/56273905.png","msgtype":"m.text"},"ts":1588568927000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: tbh that `.spec` thing seems like it'd be a pretty handy standalone npm package","msgtype":"m.text"},"ts":1588568993000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"well its not magic","msgtype":"m.text"},"ts":1588569003000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it uses the `// #sec-xyz` comment above every function in engine262's source","msgtype":"m.text"},"ts":1588569019000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah ok","msgtype":"m.text"},"ts":1588569024000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i agree though","msgtype":"m.text"},"ts":1588569030000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i wanted to add something similar in node's repl","msgtype":"m.text"},"ts":1588569038000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for js stuff and node stuff","msgtype":"m.text"},"ts":1588569047000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"though it would've been mdn not the spec in that case","msgtype":"m.text"},"ts":1588569058000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'd want it for the spec :-p","msgtype":"m.text"},"ts":1588569294000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"new proposal? :D","msgtype":"m.text"},"ts":1588570208000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the ultimate reflection mechanism","msgtype":"m.text"},"ts":1588570214000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"actually I guess to qualify as \"ultimate\" it would also need to include an interpreter for spec-ese","msgtype":"m.text"},"ts":1588570243000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Array.prototype.flat.__doc","msgtype":"m.text"},"ts":1588570272000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`Set.prototype.add = spec.evaluate(spec(Set.prototype.add).replace('If value is -0, set value to +0', 'If false'))`","msgtype":"m.text"},"ts":1588570381000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh gosh","msgtype":"m.text"},"ts":1588570635000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"littledan, I was looking at the operator overloading proposal. Would it be fair to say a lot of the complexity in the proposed syntax is due to a lack of function overloading? I understand it's stage 1.","msgtype":"m.text"},"ts":1588600734000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"I don't understand how function overloading would relate to it. it's true that the proposal's contents are largely about the dispatch semantics.","msgtype":"m.text"},"ts":1588600778000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I don't think you'd want function overloading to behave with the restrictions that operator overloading is defined to have","msgtype":"m.text"},"ts":1588600804000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"The static kind of design?","msgtype":"m.text"},"ts":1588600836000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"(I'm not fully clear on the implementation specifics, was just reading the issues).","msgtype":"m.text"},"ts":1588600876000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Would it be insane to use a TS-like syntax https://github.com/sirisian/ecmascript-types#classes-and-operator-overloading I'm not really clear on the big picture of what slows things down in V8 and such in regards to operator overloading. Is it being able to define new operators on individual instances that would require lookups and be unworkable? So the operators must be on global class types and all or nothing for all instances?","msgtype":"m.text"},"ts":1588601939000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"(Also I realize that Symbol doesn't work. I added that a while ago when someone suggested it. Apparently that's a bad idea).","msgtype":"m.text"},"ts":1588602015000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Bakkot: so `spec.evaluate(str)` would return a function object that, when called, performs the algorithm steps in `str`?","msgtype":"m.text"},"ts":1588606349000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"that would be the idea!","msgtype":"m.text"},"ts":1588606368000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(to be clear this is not a serious proposal)","msgtype":"m.text"},"ts":1588606375000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah, it didn't sound entirely serious. Still, I think it'd be possible.","msgtype":"m.text"},"ts":1588606659000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Bakkot: i'd feel more comfortable with a spec.evaluate if we first sat down and worked through the meta-machinery","msgtype":"m.text"},"ts":1588607497000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ecma261.5, the ecma262 metalanguage","msgtype":"m.text"},"ts":1588607569000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"working on it","msgtype":"m.text"},"ts":1588607635000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"michael ficarra and I have a preliminary linter integrated with ecmarkup","msgtype":"m.text"},"ts":1588607649000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so we can start enforcing stuff like \"variables are defined before use\" and so no","msgtype":"m.text"},"ts":1588607668000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'm interested in what the linter thinks about lets-in-branches","msgtype":"m.text"},"ts":1588607694000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"(that rule isn't implemented yet, to be clear, but should be pretty straightforward)","msgtype":"m.text"},"ts":1588607716000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'm interested in the policy question","msgtype":"m.text"},"ts":1588607730000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"for now I'd want to start with allowing them, since they're in the current spec","msgtype":"m.text"},"ts":1588607760000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and if we eliminate them we can update the linter to enforce that","msgtype":"m.text"},"ts":1588607773000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I don't actually mind them much though","msgtype":"m.text"},"ts":1588607787000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah i like them tbh","msgtype":"m.text"},"ts":1588607794000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"at least the fairly structured version where two branches both introduce the same alias","msgtype":"m.text"},"ts":1588607813000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I think there might be a place or two where there's a \"If Foo let X be *\" without a corresponding else, and later usages of X also guarded on Foo","msgtype":"m.text"},"ts":1588607865000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that also seems fine to me","msgtype":"m.text"},"ts":1588608291000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and could be checked by the linter with sufficient sophistication","msgtype":"m.text"},"ts":1588608299000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"littledan: I had an idea about operator overloaded where you try to make it as scoped as possible","msgtype":"m.text"},"ts":1588609844000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: Yes?","msgtype":"m.text"},"ts":1588609859000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"sort of like `let x = with operator xyz { a + b }`","msgtype":"m.text"},"ts":1588609873000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this lets it be fairly dynamic","msgtype":"m.text"},"ts":1588609890000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you can put as much in the block as you want but overloaded operations tend to happen in clumps so they should stay fairly small","msgtype":"m.text"},"ts":1588609925000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: Would that be a do expression?","msgtype":"m.text"},"ts":1588609983000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"it could be, yes","msgtype":"m.text"},"ts":1588609993000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(I mean, what were you picturing? what else would it be?)","msgtype":"m.text"},"ts":1588610004000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I haven't formalized this idea that much","msgtype":"m.text"},"ts":1588610008000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if we have do expressions it would make sense to (ab)use them here","msgtype":"m.text"},"ts":1588610026000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I mean, to me, curly brackets with code in them feel like they should have statements in them","msgtype":"m.text"},"ts":1588610039000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"if it's an expression, I'd imagine parentheses","msgtype":"m.text"},"ts":1588610051000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"a + b is an expression statement","msgtype":"m.text"},"ts":1588610053000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1588610056000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"so yeah it uses completion","msgtype":"m.text"},"ts":1588610069000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so, it'd work as a do expression","msgtype":"m.text"},"ts":1588610070000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"if we're OK with using completion values, that'd be fine. I guess no one has driven this to Stage 2, but it seemed like dherman made good progress last time it was discussed","msgtype":"m.text"},"ts":1588610093000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"but anyway since it encourages small scoping, you can make the protocol more dynamic","msgtype":"m.text"},"ts":1588610100000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hmm, I don't think I follow that part","msgtype":"m.text"},"ts":1588610117000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I think we need to be static just for the integrity goals anyway","msgtype":"m.text"},"ts":1588610130000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"since you're only paying for dynamic behaviour inside the block","msgtype":"m.text"},"ts":1588610138000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"\"paying for\" makes sense when thinking about performance cost, but the integrity things are sort of considered serious either way. The intention isn't that you're opting into chaos mode, but rather into something contained","msgtype":"m.text"},"ts":1588610187000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"integrity?","msgtype":"m.text"},"ts":1588610209000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"see \"predictability\" in https://github.com/tc39/proposal-operator-overloading/blob/master/README.md#design-goals","msgtype":"m.text"},"ts":1588610236000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"hm I think I feel exactly the opposite","msgtype":"m.text"},"ts":1588610260000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hmm how so?","msgtype":"m.text"},"ts":1588610267000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"they should be dynamic and changeable imo","msgtype":"m.text"},"ts":1588610270000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why?","msgtype":"m.text"},"ts":1588610276000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"more javascripty I guess","msgtype":"m.text"},"ts":1588610283000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that's why I like this language","msgtype":"m.text"},"ts":1588610288000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lots of people have told me specifically, operator overloading shouldn't happen in JS because then it'd be too dynamic and changeable","msgtype":"m.text"},"ts":1588610290000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"so, I was trying to respond to that and find something contained","msgtype":"m.text"},"ts":1588610302000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"all I've heard is that dynamic shouldn't happen because of performance","msgtype":"m.text"},"ts":1588610318000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so, I guess I've been a little sloppy about keeping quotes around, but I've personally heard more concerns than just that","msgtype":"m.text"},"ts":1588610359000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"fair enough","msgtype":"m.text"},"ts":1588610368000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"let me see what I can dig up","msgtype":"m.text"},"ts":1588610369000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I really don't like the static stuff though","msgtype":"m.text"},"ts":1588610375000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I mean, for example, ljharb at the last TC39 meeting was saying operator overloading would make JS more confusing, wasn't he?","msgtype":"m.text"},"ts":1588610394000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I think that's mostly about wide scoping of the overloads","msgtype":"m.text"},"ts":1588610417000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if you have these narrow scopes it's very obvious when it happens","msgtype":"m.text"},"ts":1588610430000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"although you still have the issue of forgetting to scope","msgtype":"m.text"},"ts":1588610440000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you could also look at the responses here: https://twitter.com/littledan/status/1024958066066898944","msgtype":"m.text"},"ts":1588610456000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"so, i was specifically trying to defend against certain \"attacks\" against integrity in this proposal. Probably I didn't do a good enough job explaining this in the repo, since people keep asking me the same questions about making more dynamic","msgtype":"m.text"},"ts":1588610502000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"so that's something for me to work on","msgtype":"m.text"},"ts":1588610509000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I think operator overloading works better when it's by intention instead of by operator","msgtype":"m.text"},"ts":1588610577000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like how in rust you implement deref, not the star operator","msgtype":"m.text"},"ts":1588610597000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think people saying \"operator overloading is bad\" tend along that pathway","msgtype":"m.text"},"ts":1588610626000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hmm, do you have ideas for what that would mean concretely, given the operators we have in JS?","msgtype":"m.text"},"ts":1588610675000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I don't know if I have a concrete answer","msgtype":"m.text"},"ts":1588610787000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it occurs to me that people use macros for this in rust, which is almost like my scoping idea","msgtype":"m.text"},"ts":1588610968000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"let x = vec_ops! { a + b }","msgtype":"m.text"},"ts":1588610987000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah, I think that's a good thing to look into, but at the same time, I feel like it's appropriate that the operator overloading proposal uses \"+\" to identify overloading things like a+b","msgtype":"m.text"},"ts":1588611128000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"and, I don't think this has to do with the responses to my tweet, which were half about operator overloading making all JS code opaque and confusing","msgtype":"m.text"},"ts":1588611155000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"so the concern was on the usage side, not the definition side","msgtype":"m.text"},"ts":1588611170000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"yeah that's what I mentioned above, with small scopes making it clearer where this happens","msgtype":"m.text"},"ts":1588611203000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Sirisian: If we can think of a more intuitive, TS-like syntax, then I'd be all for using it. I was thinking about using decorators somehow, but I was also thinking about avoiding the dependency","msgtype":"m.text"},"ts":1588611226000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"of course if scopes are involved you run into the problem of forgetting to use one","msgtype":"m.text"},"ts":1588611234000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rbuckton has some ideas about nicer syntax too, but I can't figure out how the details would fit together","msgtype":"m.text"},"ts":1588611250000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"could also use some modified operator form","msgtype":"m.text"},"ts":1588611335000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"a @X+ b to add a and b together using X's rules","msgtype":"m.text"},"ts":1588611361000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"littledan, Do you still work on V8? Was curious.","msgtype":"m.text"},"ts":1588611389000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"not really, but my coworkers in Igalia do","msgtype":"m.text"},"ts":1588611402000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"i think you've still got some TODO comments in v8","msgtype":"m.text"},"ts":1588611423000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: That wouldn't meet the goals of letting us generalize BigInt and Decimal","msgtype":"m.text"},"ts":1588611426000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"yeah, I think I left a lot there...","msgtype":"m.text"},"ts":1588611431000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I codesearched myself the other day and yeah","msgtype":"m.text"},"ts":1588611444000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"sorry","msgtype":"m.text"},"ts":1588611449000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"1n @BigInt+ 1n","msgtype":"m.text"},"ts":1588611451000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol you're definitely not the only one who leaves todos","msgtype":"m.text"},"ts":1588611461000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: By \"explain\", I mean make it as if BigInt were a feature added through operator overloading","msgtype":"m.text"},"ts":1588611485000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I'm not sure that's inherently possible","msgtype":"m.text"},"ts":1588611539000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if we require additional syntax at or around usage sites","msgtype":"m.text"},"ts":1588611549000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I'd probably explicitly mention using operator overloading for polyfilling types like you mentioned. Personally I want to polyfill all the types in my proposal. const a = new uint32(5); a /= 2; :O Once thought only possible with BigInt. Truly a paradigm switch. Complex numbers, vectors, and matrices. Should probably just make an explicit list of use cases and examples.","msgtype":"m.text"},"ts":1588612566000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Also maybe I missed something, but I didn't understand the a.contents stuff in the code sample.","msgtype":"m.text"},"ts":1588612844000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Just looked at it again. I thought it was extending the other library vector when I skimmed it. I get it now.","msgtype":"m.text"},"ts":1588615405000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"Bakkot: yes there are cases like that (\"If Foo let X be *\" without a corresponding else, and later usages of X also guarded on Foo)","msgtype":"m.text"},"ts":1588617521000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"devsnek: The idea has been that you'd imagine there would be an \"operator overloading prelude\" for the built-in types. It's an action item I have (from Mark) to actually write this prelude, to prove it's possible.","msgtype":"m.text"},"ts":1588629616000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"is that tangible to user code?","msgtype":"m.text"},"ts":1588629665000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Sirisian: Yes, i've been trying to accumulate use cases, and I'd appreciate your help in that. Feel free to make a PR to the explainer to add more use cases","msgtype":"m.text"},"ts":1588629695000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"devsnek: No, in general, you can't reflect over code in JS... how would it be tangible?","msgtype":"m.text"},"ts":1588629716000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"if its not tangible then explaining it doesn't matter","msgtype":"m.text"},"ts":1588629736000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I don't know what you mean by being tangible","msgtype":"m.text"},"ts":1588629747000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"maybe I'm not explaining the sense of \"explaining\" very well...","msgtype":"m.text"},"ts":1588629754000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"js code can observe that there is a prelude and that it contains BigInt and Number","msgtype":"m.text"},"ts":1588629766000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well, you can observe it by doing arithmetic calculations on BigInt and observing that it works rather than throwing a TypeError","msgtype":"m.text"},"ts":1588629785000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"that's the exact same way that you'd observe it for your own types","msgtype":"m.text"},"ts":1588629793000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"ok so then again","msgtype":"m.text"},"ts":1588629799000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there's no point to defining a prelude","msgtype":"m.text"},"ts":1588629803000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the goal is that you can do your own BigInt-like thing, and it'd really work","msgtype":"m.text"},"ts":1588629808000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"because we're talking about behaviour not declarations","msgtype":"m.text"},"ts":1588629810000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not sure what you mean. \"defining a prelude\" is a design-level exercise","msgtype":"m.text"},"ts":1588629831000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"(like writing spec text or explainers)","msgtype":"m.text"},"ts":1588629838000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"i'm not sure how that matches the goal of explaining how bigint works","msgtype":"m.text"},"ts":1588629864000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"let's talk about this another time. I don't really know how to get across this concept of \"explaining\". I'll think about it some more.","msgtype":"m.text"},"ts":1588629900000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"\"explaining\" is a kind of TC39 jargon that predates me in committee; maybe it's not the best word","msgtype":"m.text"},"ts":1588629932000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"i thought it meant representing some behaviour in a way that js code can also interact with","msgtype":"m.text"},"ts":1588629945000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like toStringTag","msgtype":"m.text"},"ts":1588629950000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if js code can't interact with the prelude it doesn't matter whether the prelude exists or not, its just some imaginary thing","msgtype":"m.text"},"ts":1588629986000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so, ES6 explained a bunch of things in a way that also added tons of dynamism and reflection. For reasons that I tried to explain, we don't really have the option of adding all that dynamism in this case. But the core of \"explaining\" isn't dynamism or reflection, but the idea that the thing that's built-in is also something that you could do in user code. That's something real too.","msgtype":"m.text"},"ts":1588630120000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"(you might consider things without dynamism/reflection bad, or that this feature isn't worth it, but that doesn't mean that it isn't \"explaining\")","msgtype":"m.text"},"ts":1588630146000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"to me it is like saying we're adding toStringTag but then not getting rid of [[ClassName]]","msgtype":"m.text"},"ts":1588630180000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or [[Class]] or whatever it was called","msgtype":"m.text"},"ts":1588630195000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like the magic is still there, on a separate layer from the stuff js can do","msgtype":"m.text"},"ts":1588630206000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bigint magically works in any scope and there's no js equiv","msgtype":"m.text"},"ts":1588630222000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Well, there's some things that would have to be pretty special forever, like how + works with strings and non-strings. But I think most of the arithmetic operations should be completely explainable in terms of this general mechanism","msgtype":"m.text"},"ts":1588630238000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"BigInt would work with this \"prelude\" theory. That's the one special case","msgtype":"m.text"},"ts":1588630266000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"if the prelude is invisible to js it doesn't exist","msgtype":"m.text"},"ts":1588630277000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's a concept, sure. (does anything really exist?)","msgtype":"m.text"},"ts":1588630312000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"no i mean","msgtype":"m.text"},"ts":1588630317000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bigint is still special","msgtype":"m.text"},"ts":1588630320000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in the same way","msgtype":"m.text"},"ts":1588630325000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes, but it's special in just one way; it's not *as* special. That's how I'm defining the design goal, the only way that I can see this matching up with the need to have the operator overloading declarations be scoped","msgtype":"m.text"},"ts":1588630357000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"would the small scope version allow operator stuff to be less static?","msgtype":"m.text"},"ts":1588630370000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"its like if you said \"every time a function is invoked, a parallel universe is created where the function is evaluated\"","msgtype":"m.text"},"ts":1588630382000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: In my opinion, no. Do you think it would? why?","msgtype":"m.text"},"ts":1588630384000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"personally the second-class nature of the current operator (and decorators) proposal is a big sticking point for me","msgtype":"m.text"},"ts":1588630386000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"from the perspective of js you could never observe such a thing","msgtype":"m.text"},"ts":1588630401000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so it doesn't matter","msgtype":"m.text"},"ts":1588630406000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: with a dep graph where half of the operators are transpiled and half are native, it'd be observable, no?","msgtype":"m.text"},"ts":1588630417000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you can't observe \"use strict\", but we stick it in modules implicitly... I'm not really sure what you're talking about, why this is a goal","msgtype":"m.text"},"ts":1588630438000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"which","msgtype":"m.text"},"ts":1588630446000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"what are you talking about","msgtype":"m.text"},"ts":1588630446000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you can add use strict to code","msgtype":"m.text"},"ts":1588630450000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that is an observable change to js code","msgtype":"m.text"},"ts":1588630459000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes, just like adding `with operators from` delcarations","msgtype":"m.text"},"ts":1588630467000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"i don't mean reflection","msgtype":"m.text"},"ts":1588630473000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i mean what humans using js can observe and interact with","msgtype":"m.text"},"ts":1588630482000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"from that perspective bigint is just as magical","msgtype":"m.text"},"ts":1588630493000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right now there could already be a prelude with your behaviour","msgtype":"m.text"},"ts":1588630500000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"adding or removing it doesn't change anything","msgtype":"m.text"},"ts":1588630507000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"BigInt is built-in. The idea is that it's special in a well-scoped way, limited to just what you could do with a prelude, not that it's *arbitrarily* special","msgtype":"m.text"},"ts":1588630527000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"that's the design goal I'm working towards. You can disagree about whether it's a worthwhile goal, but that's what I'm trying to communicate.","msgtype":"m.text"},"ts":1588630553000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"your goal doesn't make sense to me","msgtype":"m.text"},"ts":1588630566000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"OK","msgtype":"m.text"},"ts":1588630570000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"i can't judge whether it is worthwhile or not because it appears to me to be a non sequitur","msgtype":"m.text"},"ts":1588630611000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: my idea with the scoped version i talked about above is that it would allow more dynamicness","msgtype":"m.text"},"ts":1588630686000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"meaning like, a protocol?","msgtype":"m.text"},"ts":1588630732000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1588630738000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"no need for anything static","msgtype":"m.text"},"ts":1588630747000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but dan said the static-ness was partially because people wanted it to have integrity","msgtype":"m.text"},"ts":1588630791000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what kind of integrity","msgtype":"m.text"},"ts":1588630816000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like, how + should be commutative?","msgtype":"m.text"},"ts":1588630833000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or something else","msgtype":"m.text"},"ts":1588630835000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i assume it means you can't patch someone's overloads","msgtype":"m.text"},"ts":1588630843000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which seems rather unjavascripty to me","msgtype":"m.text"},"ts":1588630852000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"unless you've frozen it, i agree","msgtype":"m.text"},"ts":1588630862000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's an expectation i have for builtins, but not for user code","msgtype":"m.text"},"ts":1588630922000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"they have configurable: false for toStringTag","msgtype":"m.text"},"ts":1588631033000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"toStringTag is a special (bad) case that i don't see as related to operators","msgtype":"m.text"},"ts":1588631060000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: you can't patch someone's overloads today","msgtype":"m.text"},"ts":1588631285000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"like you can't redefine what \"+\" means in my code","msgtype":"m.text"},"ts":1588631310000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"there aren't overloads today","msgtype":"m.text"},"ts":1588631316000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so why would... we want to... start letting people do that?","msgtype":"m.text"},"ts":1588631320000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I don't think \"let other people change the semantics of my code\" is really a goal anyone on the committee has","msgtype":"m.text"},"ts":1588631352000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's exactly what operator overloading is trying to do","msgtype":"m.text"},"ts":1588631353000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"no it is not","msgtype":"m.text"},"ts":1588631358000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"let other people define the semantics of my code","msgtype":"m.text"},"ts":1588631362000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"no?","msgtype":"m.text"},"ts":1588631366000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"not without my explicitly opting in","msgtype":"m.text"},"ts":1588631371000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"whether people can do it once, or more than once, doesn't seem that different to me","msgtype":"m.text"},"ts":1588631374000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's the same as referencing any property on any object tho","msgtype":"m.text"},"ts":1588631394000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you opt in to using that property, and it's possible it could be changed later","msgtype":"m.text"},"ts":1588631404000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(when you don't destructure it, obv)","msgtype":"m.text"},"ts":1588631412000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and assuming it's not frozen, which in this proposal it would be","msgtype":"m.text"},"ts":1588631432000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so hey, all is well","msgtype":"m.text"},"ts":1588631434000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so you mean like, it's a symbol protocol, but the syntax for declaring it freezes it?","msgtype":"m.text"},"ts":1588631463000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if so, that does seem reasonable to me; anyone can participate but the default/ergonomic behavior makes it robust","msgtype":"m.text"},"ts":1588631530000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I think it also destructures when entering the block, so it's defensive twice","msgtype":"m.text"},"ts":1588632263000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"don't remember exactly though","msgtype":"m.text"},"ts":1588632267000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it was a very early stage design","msgtype":"m.text"},"ts":1588632272000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah, yeah, it reads the Operators property and that thing can only be made by a built-in Operator factory which produces immutable values, cool","msgtype":"m.text"},"ts":1588632340000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"anyway obviously someone can just define the overloaded functions themselves in a way which has their behavior change over time","msgtype":"m.text"},"ts":1588632366000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"point is, you have to opt in to using someone else's operators, and random third-party code can't just muck with it","msgtype":"m.text"},"ts":1588632383000,"senderName":"Bakkot","senderId":"Bakkot@irc"}
]