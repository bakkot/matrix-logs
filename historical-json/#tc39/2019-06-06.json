[
{"content":{"body":"Is anyone around who can answer some questions about the static class features proposal, WRT https://github.com/tc39/proposal-static-class-features/issues/38 ?","msgtype":"m.text"},"ts":1559841258000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I'm assuming static fields are evaluated within the class lexical environment, and don't need any extra bindings like `this`, thus it doesn't need to be implemented as a method, right?","msgtype":"m.text"},"ts":1559841427000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: i'm reasonable sure `class { static singleton = new this();  }` needs to work, if that's what you mean?","msgtype":"m.text"},"ts":1559846495000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I don't think it should work, when `class C { static singleton = new C(); }` would work and do what is expected","msgtype":"m.text"},"ts":1559846584000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"makes a lot more sense than rebinding `this`","msgtype":"m.text"},"ts":1559846604000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"the class fields proposal explicitly intended that to work","msgtype":"m.text"},"ts":1559846934000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(that `this` directly inside the class body is either the instance or the class)","msgtype":"m.text"},"ts":1559846955000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"where on earth is that stated? (that is a bad idea)","msgtype":"m.text"},"ts":1559846986000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"why is it a bad idea??","msgtype":"m.text"},"ts":1559847201000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"caitp: https://github.com/tc39/proposal-class-public-fields/issues/50","msgtype":"m.text"},"ts":1559847421000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it's a bad idea because `this` changes meaning without crossing a function boundary","msgtype":"m.text"},"ts":1559847536000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"it adds \"the class boundary\" as a place where it can change, and matches many people's intuition","msgtype":"m.text"},"ts":1559847566000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"similarly, in an instance field, `foo = this`, `this` is the instance","msgtype":"m.text"},"ts":1559847582000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"class boundary really should not be a thing","msgtype":"m.text"},"ts":1559847594000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"yet there's curly braces there :-p","msgtype":"m.text"},"ts":1559847605000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it sounds like in general you don't like the idea of fields at all tho","msgtype":"m.text"},"ts":1559847621000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the entire proposal is predicated on making \"class boundary\" a thing","msgtype":"m.text"},"ts":1559847635000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"nothing against fields, but `singleton = new this();` isn't any better than `singleton = new ClassName()`","msgtype":"m.text"},"ts":1559847663000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"which is arguably significantly easier to reason about","msgtype":"m.text"},"ts":1559847685000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"and doesn't prohbit accessing stuff from the real `this`","msgtype":"m.text"},"ts":1559847697000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"ClassName is in the lexical scope, has been since day 1, we should use that instead of doing some awkward stuff with `this`","msgtype":"m.text"},"ts":1559847796000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"it's better because you don't have to repeat the classname in code","msgtype":"m.text"},"ts":1559847816000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and because not every class has a name at all","msgtype":"m.text"},"ts":1559847824000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ie an anonymous class expression","msgtype":"m.text"},"ts":1559847835000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah so the solution there is to not use it in those cases innit","msgtype":"m.text"},"ts":1559847849000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1559847853000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's one option","msgtype":"m.text"},"ts":1559847860000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'd rather provide a new metaproperty for people who really want to do that","msgtype":"m.text"},"ts":1559847945000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"https://github.com/tc39/proposal-class-access-expressions","msgtype":"m.text"},"ts":1559847958000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"call it Self","msgtype":"m.text"},"ts":1559847960000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"make the rustaceans happy","msgtype":"m.text"},"ts":1559847964000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"either way tho, `this` needs to be the instance inside instance fields","msgtype":"m.text"},"ts":1559847974000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so disallowing `this` in static fields doesn't seem very useful","msgtype":"m.text"},"ts":1559847984000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I don't think you would disallow it, just let it evaluate to the `this` that already exists","msgtype":"m.text"},"ts":1559848029000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"that'd be very confusing","msgtype":"m.text"},"ts":1559848177000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"because tons of people expect it to be the class itself","msgtype":"m.text"},"ts":1559848189000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I wouldn't expect it to be the class itself, I don't think I've ever written in any language where `this` refers to the class currently being defined","msgtype":"m.text"},"ts":1559848239000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"does python do that? maybe python does","msgtype":"m.text"},"ts":1559848264000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"but everybody hates python","msgtype":"m.text"},"ts":1559848266000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"excluding the possible exceptions of python/ruby/perl, what else does?","msgtype":"m.text"},"ts":1559848315000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"but anyways, regardless of all of that, where in the actual proposal does it say any of this?","msgtype":"m.text"},"ts":1559848566000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I would find overriding `this` with yet another meaning in another context to be confusing...","msgtype":"m.text"},"ts":1559850125000,"senderName":"FireFly","senderId":"FireFly@irc"},
{"content":{"body":"in function expressions you have to specify a name if you want to refer to the function itself (e.g. to call it recursively) -- I would expect the same to be the case with class expressions","msgtype":"m.text"},"ts":1559850229000,"senderName":"FireFly","senderId":"FireFly@irc"},
{"content":{"body":"How does `this` behave in static methods inside a class today?","msgtype":"m.text"},"ts":1559850282000,"senderName":"FireFly","senderId":"FireFly@irc"},
{"content":{"body":"FireFly: it's the class","msgtype":"m.text"},"ts":1559850367000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Always?","msgtype":"m.text"},"ts":1559850372000,"senderName":"FireFly","senderId":"FireFly@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1559850374000,"senderName":"FireFly","senderId":"FireFly@irc"},
{"content":{"body":"alright, I guess it might make some sense (in that \"usual rules\" of method calls would make `this` be the class if you invoke it as Class.staticMethod())","msgtype":"m.text"},"ts":1559850440000,"senderName":"FireFly","senderId":"FireFly@irc"},
{"content":{"body":"But it still seems a bit of a pity to me to add another rule to remember about what value `this` resolves to..","msgtype":"m.text"},"ts":1559850477000,"senderName":"FireFly","senderId":"FireFly@irc"},
{"content":{"body":"caitp: i'm not sure where in the current proposal it says that tbh","msgtype":"m.text"},"ts":1559850722000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"\"Define an own property on the constructor which is set to the value of the initializer expression. The initializer is evaluated in a scope where the binding of the class is available--unlike in computed property names, the class can be referred to from inside initializers without leading to a ReferenceError. The this value in the initializer is the constructor.\" << that is...","msgtype":"m.text"},"ts":1559851080000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"so we can have scope swapping before and after every initializer is evaluated, for no reason","msgtype":"m.text"},"ts":1559851098000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I really don't see this as being something worth having in the spec, from a user perspective -or- implementor perspective","msgtype":"m.text"},"ts":1559851232000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I will be ok with it if computed properties see the same `this` as initializers, but it's still nutso","msgtype":"m.text"},"ts":1559851269000,"senderName":"caitp","senderId":"caitp@irc"}
]