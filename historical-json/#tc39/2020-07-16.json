[
{"content":{"body":"I wonder if there's any point to implementing atomics and sab in engine262","msgtype":"m.text"},"ts":1594866880000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"could maybe validate some of the logic","msgtype":"m.text"},"ts":1594866896000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you aren't currently using generators in engine262, right?","msgtype":"m.text"},"ts":1594867097000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if so, it is probably not that much work to add multithreading; you just add a babel transform which turns every AO into a generator, wraps every call to an AO so that it invokes and consumes the whole generator and gives you the return value, and wraps every expression with `yield`","msgtype":"m.text"},"ts":1594867261000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: I use generators to implement generators","msgtype":"m.text"},"ts":1594867972000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it doesn't bubble through AOs though","msgtype":"m.text"},"ts":1594868025000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"kind of a mess","msgtype":"m.text"},"ts":1594868030000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1594868200000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"step one implement generators from scratch","msgtype":"m.text"},"ts":1594868207000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1594868211000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"step two implement multithreading by making everything a generator","msgtype":"m.text"},"ts":1594868217000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"well I was thinking, I might not be able to test actual multithreading but I could at least test that the spec steps generally make sense","msgtype":"m.text"},"ts":1594868264000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I am also working on a bytecode evaluator (called \"boost\"), I could do more in depth validation with that if I ever finish it","msgtype":"m.text"},"ts":1594868309000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"designing a bytecode for JS is a fun exercise","msgtype":"m.text"},"ts":1594868335000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"mostly the try/finally bits","msgtype":"m.text"},"ts":1594868359000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"took me a good while to realize new expressions can be two opcodes","msgtype":"m.text"},"ts":1594868369000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I do try/catch by pushing an instruction pointer and current stack depth into an array","msgtype":"m.text"},"ts":1594868436000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"instruction pointer of the catch block anyway","msgtype":"m.text"},"ts":1594868477000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"doesn't support finally blocks yet","msgtype":"m.text"},"ts":1594868486000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"catch is pretty easy, finally is somewhat trickier","msgtype":"m.text"},"ts":1594868490000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"getting finally right was like 25% of the entire effort of building the VM when I tried this","msgtype":"m.text"},"ts":1594868503000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess it's a desugaring problem","msgtype":"m.text"},"ts":1594868508000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1594868514000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"try finally = catch that throws at the end","msgtype":"m.text"},"ts":1594868518000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"try catch finally = try catch that catches and then catch that throws","msgtype":"m.text"},"ts":1594868535000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe","msgtype":"m.text"},"ts":1594868536000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`try { } catch (e) {} finally {}` is 100% equivalent to `try { try {} catch (e) {} } finally {}`","msgtype":"m.text"},"ts":1594868568000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's fun","msgtype":"m.text"},"ts":1594868582000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually wait it has to deal with return instructions too","msgtype":"m.text"},"ts":1594868611000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah return and break are the part that make this hard","msgtype":"m.text"},"ts":1594868621000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess you have to push a fake return location","msgtype":"m.text"},"ts":1594868630000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"let me see if I can get permission to open source the fuzzer I wrote for this","msgtype":"m.text"},"ts":1594868640000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ooo","msgtype":"m.text"},"ts":1594868646000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(it's the obvious thing you'd do if you set out to write a fuzzer for this problem, nothing special)","msgtype":"m.text"},"ts":1594868662000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(just I have already written it)","msgtype":"m.text"},"ts":1594868679000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I tell myself I'll start fuzzing after I pass all of test262","msgtype":"m.text"},"ts":1594868704000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"haven't gotten that far yet","msgtype":"m.text"},"ts":1594868709000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the fun cases are stuff like `x: try { return 0; } finally { if (Math.random() < 5) break x; }`","msgtype":"m.text"},"ts":1594868725000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`< .5`, not 5","msgtype":"m.text"},"ts":1594868754000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I haven't done labels yet either","msgtype":"m.text"},"ts":1594868772000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I guess that won't be too hard to add","msgtype":"m.text"},"ts":1594868782000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rkirsling: still failing like 10k tests but looking pretty good in terms of test262 coverage https://gc.gy/62624842.png","msgtype":"m.text"},"ts":1594919853000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"er","msgtype":"m.text"},"ts":1594919867000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rwaldron: ^","msgtype":"m.text"},"ts":1594919869000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I feel like this might've been brought up before but it's weird that return is sometimes an await and sometimes not","msgtype":"m.text"},"ts":1594929961000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in async vs async generator","msgtype":"m.text"},"ts":1594929976000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hm, i would assume it never needs the await","msgtype":"m.text"},"ts":1594930040000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it's better for it to include the await","msgtype":"m.text"},"ts":1594930111000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"cuz of try/catch","msgtype":"m.text"},"ts":1594930114000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in the spec?","msgtype":"m.text"},"ts":1594930214000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I mean so you don't need to write `return await`","msgtype":"m.text"},"ts":1594930314000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right but you might not want the await","msgtype":"m.text"},"ts":1594930414000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the way it works in async function imo is the right way; i think there was discussion about this for async generators late in the process, but i don't remember the outcome","msgtype":"m.text"},"ts":1594930471000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I know we discussed it for `yield`, see https://github.com/tc39/proposal-async-iteration/issues/93","msgtype":"m.text"},"ts":1594931595000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I would guess that `return` implicitly unwraps in async generators so that it matches `yield`","msgtype":"m.text"},"ts":1594931695000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it is a bit odd though","msgtype":"m.text"},"ts":1594931698000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh, wait, that happens because the value from `return` isn't going to get wrapped in a promise","msgtype":"m.text"},"ts":1594931795000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if `return` didn't implicit await you could end up with `{ done: true, value: [a promise] }`, which would be weird","msgtype":"m.text"},"ts":1594931898000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(at least, I assume this is the reason)","msgtype":"m.text"},"ts":1594931910000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah right, yes, that was the reason","msgtype":"m.text"},"ts":1594931941000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that doesn't  have to be an await","msgtype":"m.text"},"ts":1594931957000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"iirc, i'd have preferred syntactically requiring `return await`, but instead we went with implicit await","msgtype":"m.text"},"ts":1594931961000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it could be a `.then(fulfill)`","msgtype":"m.text"},"ts":1594931971000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"pushing the error to the caller instead of the returner","msgtype":"m.text"},"ts":1594931980000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that would be weirder still","msgtype":"m.text"},"ts":1594932012000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it makes more sense to me than the await","msgtype":"m.text"},"ts":1594932029000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually wait maybe I don't understand the proposal","msgtype":"m.text"},"ts":1594932134000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what would `(async function*(){ return Promise.reject(0); })` return?","msgtype":"m.text"},"ts":1594932166000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(and the first couple of `.next`s)","msgtype":"m.text"},"ts":1594932176000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"idk off the top of my head","msgtype":"m.text"},"ts":1594932187000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i could plug my idea into engine262 in a bit","msgtype":"m.text"},"ts":1594932192000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bradleymeck: did you have a repo for the arbitrary-module-specifiers proposal?","msgtype":"m.text"},"ts":1594943781000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"could find it on tc39/proposals","msgtype":"m.text"},"ts":1594943790000,"senderName":"Bakkot","senderId":"Bakkot@irc"}
]