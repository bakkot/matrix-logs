[
{"content":{"body":"well, are there [[Construct]]-only things?","msgtype":"m.text"},"ts":1603757296000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: I believe that is prohibited","msgtype":"m.text"},"ts":1603760034000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"by one of those prose sections about functions","msgtype":"m.text"},"ts":1603760042000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"let's see...","msgtype":"m.text"},"ts":1603760061000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ah indeed, thanks, it is in prose","msgtype":"m.text"},"ts":1603760087000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"👍","msgtype":"m.text"},"ts":1603760122000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"should put that in the list of invariants","msgtype":"m.text"},"ts":1603760129000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but i guess strictly speaking that list is a list of invariants of the methods, while this invariant is an invariant of all objects","msgtype":"m.text"},"ts":1603760171000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"still seems useful","msgtype":"m.text"},"ts":1603760189000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"we should highlight the important stuff","msgtype":"m.text"},"ts":1603760371000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but then that brings the question of what isn't important :P","msgtype":"m.text"},"ts":1603760383000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"looking forward to some website breaking because we change default constructors to be spec text","msgtype":"m.text"},"ts":1603821598000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bradleymeck: would you prefer to present on https://github.com/tc39/ecma262/pull/2216?","msgtype":"m.text"},"ts":1603827496000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if not i will","msgtype":"m.text"},"ts":1603827498000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i have no desire to","msgtype":"m.text"},"ts":1603827528000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"👍🏻","msgtype":"m.text"},"ts":1603827535000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if [[SetData]] is a List and Set.prototype.add appends to it and %SetIteratorPrototype%.next traverses it in order, does that mean Set iteration has a guaranteed order?","msgtype":"m.text"},"ts":1603828022000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1603828034000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I was really expecting us not to guarantee that","msgtype":"m.text"},"ts":1603828038000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"weird","msgtype":"m.text"},"ts":1603828041000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"map iteration has a guaranteed order as well","msgtype":"m.text"},"ts":1603828041000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"they are both ordered collections","msgtype":"m.text"},"ts":1603828047000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what's the reasoning behind that decision? I wonder","msgtype":"m.text"},"ts":1603828116000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"nondeterminism is bad","msgtype":"m.text"},"ts":1603828258000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"also if it is unspecified it is likely to be implementation-dependent and then people depend on one implementation and then other implementations have to ship that","msgtype":"m.text"},"ts":1603828285000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which is also bad","msgtype":"m.text"},"ts":1603828287000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that part is fair...","msgtype":"m.text"},"ts":1603828309000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"we have been trying hard to avoid leaving things like that unspecified, with the glaring exception of weakrefs","msgtype":"m.text"},"ts":1603828314000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"basically either we risk that ^, or we risk people thinking that they should conceptually rely on the insertion order. it seems pretty clear to me at least that the former would be worse","msgtype":"m.text"},"ts":1603828326000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(and atomics I guess)","msgtype":"m.text"},"ts":1603828329000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"just thinking of std::unordered_set and std::unordered_map and how the abstract data structures have no notion of order","msgtype":"m.text"},"ts":1603828362000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i wish we had a System.hash(v) -> n","msgtype":"m.text"},"ts":1603828392000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so we could make our own collections","msgtype":"m.text"},"ts":1603828400000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right now you would have to make a WeakMap of objects to numbers or smth","msgtype":"m.text"},"ts":1603828454000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rkirsling whenever I think of those I think about how many times I've had bugs which were not reproducible because they were only triggered in a specific case of iterating over an unordered collection","msgtype":"m.text"},"ts":1603828457000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and am grateful that we did not make that mistake","msgtype":"m.text"},"ts":1603828488000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's fair","msgtype":"m.text"},"ts":1603828515000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling, https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables","msgtype":"m.text"},"ts":1603831792000,"senderName":"gsathya","senderId":"gsathya@irc"},
{"content":{"body":"oh thanks!","msgtype":"m.text"},"ts":1603831885000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"> if we don't specify an iteration order I think the web will just go and specify it for us, as it has for object property iteration order","msgtype":"m.text"},"ts":1603832058000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah that's a very good point","msgtype":"m.text"},"ts":1603832069000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":" devsnek: shift is going to have an even more different AST for optional chaining","msgtype":"m.text"},"ts":1603835961000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it's very exciting","msgtype":"m.text"},"ts":1603835970000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"we're getting rid of regular member access","msgtype":"m.text"},"ts":1603835974000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"🤔","msgtype":"m.text"},"ts":1603835999000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: YESSSSS","msgtype":"m.text"},"ts":1603836016000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"YESSSSS","msgtype":"m.text"},"ts":1603836019000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"References and Lookups?","msgtype":"m.text"},"ts":1603836050000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck https://gist.github.com/bakkot/bc3702ebf05b6960caefff8d47e2905c","msgtype":"m.text"},"ts":1603836126000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"not sure what \"references and lookups\" means","msgtype":"m.text"},"ts":1603836140000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if you have a different idea, I would love to hear it!","msgtype":"m.text"},"ts":1603836148000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"we aren't set on this design","msgtype":"m.text"},"ts":1603836151000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`delete x.y` is a nightmare right now since it isn't a lookup and you have to crawl up to `delete` to deal w/ its reference nature rather than access nature","msgtype":"m.text"},"ts":1603836184000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"ah, that would be a change to `delete` rather than a change to MemberAccess","msgtype":"m.text"},"ts":1603836237000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"call has a weirdness to it that i'm trying to figure out if it is fixed by this","msgtype":"m.text"},"ts":1603836256000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i'd have to dig this up but i remember i had to defer processing on it too somewhere","msgtype":"m.text"},"ts":1603836302000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"call is also not fixed by this probably","msgtype":"m.text"},"ts":1603836305000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"not going to do that right now","msgtype":"m.text"},"ts":1603836307000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"I really just want the locations to state if they are a reference vs an eager Get()","msgtype":"m.text"},"ts":1603836334000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yeah, this doesn't help that at all, unfortunately :(","msgtype":"m.text"},"ts":1603836384000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah that was it, i had to propagate the receiver until i knew if it was a ref vs get","msgtype":"m.text"},"ts":1603836407000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"if you have a bunch of code looking for member access, this change would require you to rewrite that code","msgtype":"m.text"},"ts":1603836492000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which is an argument against doing this change","msgtype":"m.text"},"ts":1603836496000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i don't understand Call in that gist","msgtype":"m.text"},"ts":1603836497000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i think breaking changes are fine here? this doesn't look to utterly change things like splitting Reference from Lookup","msgtype":"m.text"},"ts":1603836549000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`f()` would be represented as `{ type: 'MemberAccessOrCall', optional: false, base: Identifier('f'), first: { type: 'Call', args: [] }, rest: [] }`","msgtype":"m.text"},"ts":1603836568000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`f?.()` would be just the same except with `optional: true`","msgtype":"m.text"},"ts":1603836583000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1603836619000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`a.b()` would be `{ type: 'MemberAccessOrCall', optional: false, base: Identifier('a'), first: { type: 'StaticPropertyAccess', name: 'b' }, rest: [{ type: 'Call', args: [] }] }`","msgtype":"m.text"},"ts":1603836622000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so, yeah, this would actually make it harder to figure out if you were doing a member call, I think","msgtype":"m.text"},"ts":1603836726000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess from the `StaticPropertyAccess` it's just a matter of looking to see if the next part is a Call node","msgtype":"m.text"},"ts":1603836772000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(or a tagged template node? do tagged template calls set `this`?)","msgtype":"m.text"},"ts":1603836785000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(answer: yes)","msgtype":"m.text"},"ts":1603836812000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: seems complex","msgtype":"m.text"},"ts":1603837127000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is your AST concerned with ease of short-circuiting? or just surface appearance?","msgtype":"m.text"},"ts":1603837246000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"'cause those lead to very different ways of handling ?.","msgtype":"m.text"},"ts":1603837263000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"devsnek it's almost identical to yours, just folding in regular member access","msgtype":"m.text"},"ts":1603837290000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and using an actual list of parts instead of an ADT-list, I guess","msgtype":"m.text"},"ts":1603837323000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"rkirsling the goal for the AST is that it's relatively easy too analyze","msgtype":"m.text"},"ts":1603837367000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1603837379000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"so, yes, it needs to represent short-circuiting, not just stick an \"optional\" property on member access","msgtype":"m.text"},"ts":1603837396000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1603837445000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"not sure if I showed this before but JSC does this: https://usercontent.irccloud-cdn.com/file/L4KWhjS9/jsc-optional-chaining-ast","msgtype":"m.text"},"ts":1603837477000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"JSC also has this wild menagerie of function call nodes, which V8 does not, but","msgtype":"m.text"},"ts":1603837661000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah, for codegen I think it doesn't matter much","msgtype":"m.text"},"ts":1603837715000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this structure made it easy to generate the appropriate bytecode even in wacky nested cases","msgtype":"m.text"},"ts":1603837739000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"a thing we care about is, there should as much as possible be a 1-1 relationship between well-typed ASTs and actual programs","msgtype":"m.text"},"ts":1603837740000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what does your AST for `a?.b.c` look like?","msgtype":"m.text"},"ts":1603837800000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"same as above except for the right branch, I think","msgtype":"m.text"},"ts":1603837897000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I just added an optional field to member expressions in v8","msgtype":"m.text"},"ts":1603838135000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and a root optional chain node for the jump location","msgtype":"m.text"},"ts":1603838163000,"senderName":"devsnek","senderId":"devsnek@irc"}
]