[
{"content":{"body":"jmdyck: I'm don't understand the question I'm afraid","msgtype":"m.text"},"ts":1621814974000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"my claim is that the position following `y:` is a.) a position where ObjectAssignmentPattern and b.) not initially parsing CoverParenthesizedExpressionAndArrowParameterList or CoverCallExpressionAndAsyncArrowHead (because there's no parenthesis)","msgtype":"m.text"},"ts":1621815029000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Well, do you agree that (in the spec's processing model), `{}` is parsed 3 times as an ObjectLiteral before it's parsed as an ObjectAssignmentPattern?","msgtype":"m.text"},"ts":1621816274000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"The inner `{}`? I'm not sure if I can count to three times, but I do agree it's parsed as an ObjectLiteral first, yes","msgtype":"m.text"},"ts":1621816370000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"In the initial parse, the whole text is parsed as an instance of PrimaryExpression : CoverParenEtc, which 13.2.9.1 then requires to be covering a ParenthesizedExpression.","msgtype":"m.text"},"ts":1621816765000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So when you do that, `{x = 0, y: {}} = z` is parsed as an Expression, in particular an AssignmentExpression","msgtype":"m.text"},"ts":1621816859000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"in which `{x = 0, y: {}}` is a LHSExpression","msgtype":"m.text"},"ts":1621816911000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"and in that parse also, the inner {} is an ObjectLiteral","msgtype":"m.text"},"ts":1621817015000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"But then that instance of `AssignmentExpression : LeftHandSideExpression = AssignmentExpression` (the one that matches `{x = 0, y: {}} = z`) is subject to 13.15.1 Early Error that requires the LHSExpression `{x = 0, y: {}}` to be covering an AssignmentPattern.","msgtype":"m.text"},"ts":1621817385000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So parse #3 is of `{x = 0, y: {}}` as an AssignmentPattern. It's an ObjectAssignmentPattern with 2 AssignmentPropertys. In the second one, the PropertyName is `y` and the AssignmentElement is `{}`.","msgtype":"m.text"},"ts":1621817743000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"That AssignmentElement is an instance of `DestructuringAssignmentTarget : LeftHandSideExpression` in which the LHSExpr is (yet again) an ObjectLiteral, so the Early Error in 13.15.5.1 requires it to be covering an AssignmentPattern.","msgtype":"m.text"},"ts":1621817858000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So parse #4 is of `{}` as an AssignmentPattern, and it finally is recognized as an ObjectAssignmentPattern.","msgtype":"m.text"},"ts":1621817891000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"In parse #1, `x` matches `PropertyDefinition : CoverInitializedName`, but the 13.2.5.1 Syntax Error doesn't apply, because we're \"initially parsing a CoverParenthesizedExpressionAndArrowParameterList\", but also (I think) because the ObjectLiteral `{x = 0, y: {}}` will eventually (in parse #3) be reparsed as an ObjectAssignmentPattern.","msgtype":"m.text"},"ts":1621820090000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"In parse #2, `x` matches `PropertyDefinition : CoverInitializedName` again, and presumably the 13.2.5.1 doesn't apply again, but not because of the \"initially parsing\" sentence, rather because (again) `{x = 0, y: {}}` will soon be parsed as an ObjectAssignmentPattern.","msgtype":"m.text"},"ts":1621820325000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So now I'm wondering if the \"initially parsing\" sentence is actually needed.","msgtype":"m.text"},"ts":1621820393000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Is there a case where \"initially parsing\" sentence applies but the \"ObjectAssignmentPattern\" sentence doesn't?","msgtype":"m.text"},"ts":1621820520000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(This reverses the question I asked a few hours ago.)","msgtype":"m.text"},"ts":1621820537000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Yes, `({}) => 0` is initially parsed as CoverParenthesizedExpressionAndArrowParameterList, but never as ObjectAssignmentPattern","msgtype":"m.text"},"ts":1621822660000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that is, `({})` is initially parsed as CoverParenthesizedExpressionAndArrowParameterList, and `{}` is never parsed as ObjectAssignmentPattern","msgtype":"m.text"},"ts":1621822698000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"test","msgtype":"m.text"},"ts":1621827424000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"`({})` doesn't contain an instance of `PropertyDefinition : CoverInitializedName`, so the question of whether or not to apply the associated early error rule doesn't arise.","msgtype":"m.text"},"ts":1621827568000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"If I change it to `({x=1})` then that does contain an instance, so the question does arise, and presumably the answer is yes, apply the rule and raise a syntax error.","msgtype":"m.text"},"ts":1621827627000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"But is there a case where the question arises, and the \"initially parsing\" sentence tells us not to apply the rule, and the \"ObjectAssignmentPattern\" sentence doesn't?","msgtype":"m.text"},"ts":1621827762000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(The \"when initially parsing\" sentence first appeared in ES6.)","msgtype":"m.text"},"ts":1621828239000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"sorry, change my example to `({x=1}) => 0`","msgtype":"m.text"},"ts":1621835088000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"there's no ObjectAssignmentPattern in that case","msgtype":"m.text"},"ts":1621835095000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: Ok, interesting. So the text that is initially parsed as an ObjectLiteral containing a CoverInitializedName is re-parsed as ObjectBindingPattern containing a SingleNameBinding.","msgtype":"m.text"},"ts":1621860336000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"But it seems like that's analogous to the situation where an ObjectLiteral containing a CoverInitializedName is re-parsed as an ObjectAssignmentPattern containing an AssignmentProperty.","msgtype":"m.text"},"ts":1621865076000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So why doesn't 13.2.5.1 deal with them similarly? I.e., there's a sentence that directly handles cases where ObjectLiteral is re-parsed as an ObjectAssignmentPattern, so why not the same for cases where ObjectLiteral is re-parsed as an ObjectBindingPattern?","msgtype":"m.text"},"ts":1621865277000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(e.g., just change \"where ObjectAssignmentPattern is required\" to \"where ObjectAssignmentPattern or ObjectBindingPattern is required\")","msgtype":"m.text"},"ts":1621865350000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"would that not handle some cases that are handled by the existing wording?","msgtype":"m.text"},"ts":1621865399000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"rephrase: Does the current wording handle some cases that wouldn't be handled by an \"ObjectBindingPattern is required\" wording?","msgtype":"m.text"},"ts":1621865995000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Consider if we put your latest example in an extra pair of parens: (({x=1}) => 0)","msgtype":"m.text"},"ts":1621867211000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I'll refer to the whole expr as \"the outer\" and `({x=1})` as \"the inner\".","msgtype":"m.text"},"ts":1621867272000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"In the initial parse, both the outer and the inner are parsed as CoverParenEtc.","msgtype":"m.text"},"ts":1621867315000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"The outer is re-parsed as a ParenthesizedExpression, in which the inner is again parsed as CoverParenEtc.","msgtype":"m.text"},"ts":1621867470000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Then the inner is re-parsed as a ArrowFormalParameters.","msgtype":"m.text"},"ts":1621867530000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"In that middle stage, where the inner is again parsed as CoverParenEtc, the `{x=1}` is (again) parsed as an ObjectLiteral with a CoverInitializedName. Presumably the example is valid, so the 13.2.5.1 Early Error for CoverInitializedName shouldn't be applied; but does the existing wording accomplish that?","msgtype":"m.text"},"ts":1621868054000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Obviously, the ObjectAssignmentPattern sentence isn't relevant.","msgtype":"m.text"},"ts":1621868073000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"The other sentence says that the CoverInitalizedName rule isn't applied \"when initially parsing a CoverParenthesizedExpressionAndArrowParameterList ...\". Does that describe this middle stage?","msgtype":"m.text"},"ts":1621868704000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"On the one hand, this isn't the first time that the inner has been parsed as a CoverParenEtc. On the other, it is the first time it's been parsed as a CoverParenEtc *within* the re-parse of the outer.","msgtype":"m.text"},"ts":1621868787000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I don't think there's a definitive answer: the wording of \"initially parsing a CoverParenEtc\" isn't precise enough.","msgtype":"m.text"},"ts":1621868904000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(For one thing, you don't parse a <nonterminal>, you parse a text.)","msgtype":"m.text"},"ts":1621868964000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Curious. Has anyone brought up renaming the object during parameter destructuring? function f({ a = 1, b = 2 }:options = {}) {} I might be missing something obvious here.","msgtype":"m.text"},"ts":1621877148000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"Sirisian|Work yes, people have asked, see e.g. https://github.com/zkat/proposal-as-patterns","msgtype":"m.text"},"ts":1621877301000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"most people seem to get by fine with just doing it in two steps, though","msgtype":"m.text"},"ts":1621877327000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"jmdyck, re \"why doesn't 13.2.5.1 deal with them similarly\", that I could not tell you","msgtype":"m.text"},"ts":1621877372000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"You mean like: function f({ a = 1, b = 2 }) { const options = { a, b }; } ?","msgtype":"m.text"},"ts":1621879081000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"Also it looks like that \"as\" proposal doesn't do exactly what I'd want. function({ a = 1, b = 2 } as x) { console.log(x); } with f({ c: 1 }); outputs \"{ a = 1, b = 2, c = 3 }\" which is consistent with that proposal.","msgtype":"m.text"},"ts":1621879763000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"Looks like what I want is the pick proposal.","msgtype":"m.text"},"ts":1621879772000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"function f(options.{ a = 1, b = 2 }) {}","msgtype":"m.text"},"ts":1621879798000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"hmm, no.","msgtype":"m.text"},"ts":1621879809000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"Sirisian|Work: so you want the equivalent of `do { const { a, b } = options; ({ a, b }) }`?","msgtype":"m.text"},"ts":1621879858000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Sirisian|Work: can you elaborate on the use case of accepting an options bag, but actively needing to omit un-named properties?","msgtype":"m.text"},"ts":1621879895000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"function options(options) { Object.assign(this, { option1: 1, option2: 2 }, options); } Kind of like this, but where options is listed so the IDE can see the object in the parameters and sets defaults. I then assign all the options to this.","msgtype":"m.text"},"ts":1621880189000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"function options({ option1 = 1, option2 = 2 }) { Object.assign(this, { option1, option2 }); }","msgtype":"m.text"},"ts":1621880359000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"Not a huge deal really using that which is what I have now.","msgtype":"m.text"},"ts":1621880377000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"> You mean like","msgtype":"m.text"},"ts":1621885449000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"No, I meant like `function f(options = {}) { const {a = 1, b = 2} = options; ...}`","msgtype":"m.text"},"ts":1621885467000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot, ah. options wouldn't have the defaults set then.","msgtype":"m.text"},"ts":1621885613000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"Which I might not have been clear about. I didn't explain myself well.","msgtype":"m.text"},"ts":1621885636000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"}
]