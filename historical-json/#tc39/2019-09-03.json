[
{"content":{"body":"I'm trying to use switches, but I find that having a variable within the scope of it is rather difficult. Here is a gist (https://gist.github.com/puppy0cam/b319f59831d2da18043278e466a4f01c) for what I want to do, as well as a workaround for how you could do to somewhat achieve this. The problem with this workaround is that it exposes a variable tha","msgtype":"m.text"},"ts":1567473135000,"senderName":"puppy0cam","senderId":"puppy0cam@irc"},
{"content":{"body":"t is only relevant to the body of the switch and is accessible from outside the switch body","msgtype":"m.text"},"ts":1567473135000,"senderName":"puppy0cam","senderId":"puppy0cam@irc"},
{"content":{"body":"puppy0cam: right, you should declare it outside the switch. there's no way to have a variable in the entry to a block (like the parens of a switch, or if, or while, etc) that's only scoped to that block.","msgtype":"m.text"},"ts":1567480211000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: there's something to be said for `if (const x = ...) {}` too","msgtype":"m.text"},"ts":1567480488000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: that has the same issue","msgtype":"m.text"},"ts":1567480510000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"what issue","msgtype":"m.text"},"ts":1567480517000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"iow, while it might be intuitive for that to declare a var just for the block, it creates it for the outer block.","msgtype":"m.text"},"ts":1567480524000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"eg `if (const x = 3) {} console.log(x)`","msgtype":"m.text"},"ts":1567480536000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"It does seem strange that the block receives it's own scope since if you have a let in there, you could end up with errors from accessing the value before initialization as the switch skipped the initialization and went directly to the part where it is being accessed.","msgtype":"m.text"},"ts":1567480549000,"senderName":"puppy0cam","senderId":"puppy0cam@irc"},
{"content":{"body":"oh wait","msgtype":"m.text"},"ts":1567480555000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ok nvm in `if` you can't declare a var in the parens","msgtype":"m.text"},"ts":1567480567000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"either way there's no \"make a var for just this block as i enter the block\" syntax ¯\\_(ツ)_/¯","msgtype":"m.text"},"ts":1567480605000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah i was just saying","msgtype":"m.text"},"ts":1567480637000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if someone were to propose such a thing","msgtype":"m.text"},"ts":1567480642000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for if/while/etc","msgtype":"m.text"},"ts":1567480645000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i would support it","msgtype":"m.text"},"ts":1567480648000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i use it a lot in rust","msgtype":"m.text"},"ts":1567480656000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in js you just end up wrapping the entire thing in a block so you feel clean","msgtype":"m.text"},"ts":1567480672000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"imagine `while (let x = regex.match()) {}`","msgtype":"m.text"},"ts":1567480706000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or exec","msgtype":"m.text"},"ts":1567480733000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"whichever one makes you loop","msgtype":"m.text"},"ts":1567480740000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"with matchAll you don't need an exec loop anymore :-p","msgtype":"m.text"},"ts":1567480820000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"fancy","msgtype":"m.text"},"ts":1567480858000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"And there is a case of a variable being declared in the parameters to a block, for loops","msgtype":"m.text"},"ts":1567482082000,"senderName":"puppy0cam","senderId":"puppy0cam@irc"},
{"content":{"body":"interestingly, the current way that async functions evaluate means that the stack may have two almost identical execution contexts on it before the first await","msgtype":"m.text"},"ts":1567483117000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"because the context is cloned","msgtype":"m.text"},"ts":1567483122000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in theory the context doesn't need to be cloned until an await is hit, but would such a change be safe to make?","msgtype":"m.text"},"ts":1567483137000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it depends on whether anything will be able to access the old context","msgtype":"m.text"},"ts":1567483184000,"senderName":"puppy0cam","senderId":"puppy0cam@irc"},
{"content":{"body":"engines have really odd stacks","msgtype":"m.text"},"ts":1567483243000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but engine262 is the only one that reveals this duplicate context","msgtype":"m.text"},"ts":1567483255000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://gc.gy/35188265.png","msgtype":"m.text"},"ts":1567483270000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"production engines probably have a way of eliding the duplicate one or mark them as hidden","msgtype":"m.text"},"ts":1567483282000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"well my current assumption is that they just don't have cloned contexts at all","msgtype":"m.text"},"ts":1567483297000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol ChakraCore with that generator shim","msgtype":"m.text"},"ts":1567483310000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"as far as i can tell the context cloning is only done to fulfill a contract with Function's [[Call]]","msgtype":"m.text"},"ts":1567483325000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which pops the context when it finishes","msgtype":"m.text"},"ts":1567483329000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually that might not be the case","msgtype":"m.text"},"ts":1567483350000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I mean in one sense this is equivalent to the .next() function for generators","msgtype":"m.text"},"ts":1567483357000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1567483369000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually i can't figure this out","msgtype":"m.text"},"ts":1567483397000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://www.irccloud.com/pastebin/rQGjAe6K/","msgtype":"m.text"},"ts":1567483397000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"time to remove the clone and see what happens","msgtype":"m.text"},"ts":1567483402000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right?","msgtype":"m.text"},"ts":1567483414000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"something bad will probably happen","msgtype":"m.text"},"ts":1567483433000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"indeed","msgtype":"m.text"},"ts":1567483447000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"also I made https://docs.google.com/document/d/1BRg0EvYIqKYqZ79ssgSLpRFr60sFjeX_-Ijw9VzsYvA/edit for fun","msgtype":"m.text"},"ts":1567483455000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"fun = LinkedIn fun","msgtype":"m.text"},"ts":1567483468000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"this is #tc39","msgtype":"m.text"},"ts":1567483473000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oops","msgtype":"m.text"},"ts":1567483477000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"ll","msgtype":"m.text"},"ts":1567483479000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol*","msgtype":"m.text"},"ts":1567483481000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"fine I don't mind","msgtype":"m.text"},"ts":1567483487000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"@ljharb when I have to make a copy of a fn, such as saving \"original\" forms of intrinsics, other are using it to add statics via prototype chain (non-proto based can use .assign)","msgtype":"m.text"},"ts":1567520628000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: not clear on the second half; for the first half, `.bind()`, if you don't need a receiver?","msgtype":"m.text"},"ts":1567526697000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: doesn't work for constructors/things using `this`","msgtype":"m.text"},"ts":1567526721000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`new C.bind()` works","msgtype":"m.text"},"ts":1567526740000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but other things using `this`, true","msgtype":"m.text"},"ts":1567526746000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"new C.bind() can't be called later to generate new C objects","msgtype":"m.text"},"ts":1567526775000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"? sure it can","msgtype":"m.text"},"ts":1567526789000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`const D = C.bind(); new D() instanceof D && new D() instanceof C`, i believe","msgtype":"m.text"},"ts":1567526807000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but essentially you want something like `.clone()`, ie, `.bind` but not touching the receiver or taking any arguments?","msgtype":"m.text"},"ts":1567526828000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"thats what people were talking about at least","msgtype":"m.text"},"ts":1567526939000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i misunderstood your suggestion, saving it to a variable would mostly work, but it is terribly hard to read","msgtype":"m.text"},"ts":1567526969000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"}
]