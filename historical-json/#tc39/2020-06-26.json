[
{"content":{"body":"> rlwarp","msgtype":"m.text"},"ts":1593138884000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"WHY HAVE I NEVER HEARD OF THIS?","msgtype":"m.text"},"ts":1593138884000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Hello. Is there any reliable mechanism to identify a type of a given function object? I want to know whether this function is normal, generator, async, and so on.","msgtype":"m.text"},"ts":1593158546000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"Oh. *mechanism* seems misleading. I want to find a reliable way to identify a type of a function.","msgtype":"m.text"},"ts":1593160003000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"Yoonseok: they do have different prototypes, but in general they could always return stuff and act as other things, e.g. it is common for a normal function to return the promise of an async function","msgtype":"m.text"},"ts":1593179998000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Yoonseok: so, even if you know the type, it generally isn't useful","msgtype":"m.text"},"ts":1593180012000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"fun stuff also happens when sometimes we have seen functions passed into node's builtins with null prototypes via Object.setPrototypeOf(()=>{}, null)","msgtype":"m.text"},"ts":1593180076000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"so even prototypes aren't necessarily a good route","msgtype":"m.text"},"ts":1593180086000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yes. Indeed, prototypes is mutable. So, it is not reliable.","msgtype":"m.text"},"ts":1593180129000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"hm. i'm thinking about \"it generally isn't useful\".","msgtype":"m.text"},"ts":1593180159000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"for a given function, i want to provide a kind of secure layer that filter out leaking a secret by return value.","msgtype":"m.text"},"ts":1593180200000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"but, without knowing the type of a given function, it is not possible to provide a secure layer for the function. (mostly, this layer is a wrapper function).","msgtype":"m.text"},"ts":1593180268000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"in the case of generator, it returns a generator object, and you can call the it by generator.next(), which is out of my scope.","msgtype":"m.text"},"ts":1593180327000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"indeed, it is not surprising even though js does not support a feature to identify a type of object.","msgtype":"m.text"},"ts":1593180403000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"but, in other cases, such as Date, RegExp, we can observe the type by applying the object to \"Date.prototype.getTime\" or \"RegExp.prototype.test\".","msgtype":"m.text"},"ts":1593180463000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"but, I really cannot find it for generator or async functions.","msgtype":"m.text"},"ts":1593180519000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"in practice, we can apply `Function.prototype.toString`, but it is not standard (so, XS or JerryScript does not return its content),","msgtype":"m.text"},"ts":1593180655000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"moreover, Function.prototype.bind removes it.","msgtype":"m.text"},"ts":1593180672000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"bradleymeck anyway. thank you for the response. :)","msgtype":"m.text"},"ts":1593180828000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"Yoonseok: I mean, Function.prototype.bind.call(fn) will give you a *new* function with the proper prototype","msgtype":"m.text"},"ts":1593180947000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"ah.","msgtype":"m.text"},"ts":1593180959000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"but it won't be useful for determining how the return value works","msgtype":"m.text"},"ts":1593180961000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"normal functions can return iterators/promises/etc.","msgtype":"m.text"},"ts":1593180973000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"or wait, not it won't it just inherits","msgtype":"m.text"},"ts":1593181011000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"my brain is waking up still","msgtype":"m.text"},"ts":1593181016000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"it is correct. okay. i had some assumption.","msgtype":"m.text"},"ts":1593181016000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"okay. i will check it first. I'm thinking about whether I can implement a membrane that allows me to pass a generator.","msgtype":"m.text"},"ts":1593181285000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"bradleymeck thank you. i think that you're right. such type information is not useful. they are all just a function that returns a different type of values.","msgtype":"m.text"},"ts":1593183403000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"Yoonseok: in general what Membranes if they are crossing a barrier do for such things is to wrap all the return values if they are objects if you look at lightning web components, es-membrane, or SES","msgtype":"m.text"},"ts":1593183546000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i'm looking at the current limitation of membranes. since membrane relies on proxy feature and proxy feature does not allow to access internal slots, membrane does not guarantee the identity of objects (here, identity means internal slots). for example, if a regular expression object o is passed via membrane, you cannot use \"abc\".test(o) because o","msgtype":"m.text"},"ts":1593183824000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"is not a regular expression object anymore.","msgtype":"m.text"},"ts":1593183824000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"I think it is the same for the generator function.","msgtype":"m.text"},"ts":1593183830000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"generator function returns a generator object, and (of course, no one really want to use this) if anyone want to call the generator object gfn by `(function*(){}).constructor.prototype.prototype.next.apply(gfn)`, it will fail. because gfn is not a generator object (it is a proxy).","msgtype":"m.text"},"ts":1593183892000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"ah. when gfn is obtained by a generator function passed via the membrane (the barrier).","msgtype":"m.text"},"ts":1593183957000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"I thought that there is a way to improve it if we know the type of a function. but, you're right. we can't even if we know the type.","msgtype":"m.text"},"ts":1593183999000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"uh. i really want to rewrite whole sentences. sorry for the mess sentences. :/","msgtype":"m.text"},"ts":1593184358000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"ljharb: i can't tell what your suggested change does","msgtype":"m.text"},"ts":1593188857000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i hate that github won't highlight it","msgtype":"m.text"},"ts":1593188867000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"spells additionally properly","msgtype":"m.text"},"ts":1593188885000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"oh cool","msgtype":"m.text"},"ts":1593188929000,"senderName":"devsnek","senderId":"devsnek@irc"}
]