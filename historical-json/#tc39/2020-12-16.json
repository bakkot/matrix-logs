[
{"content":{"body":"I am not sure I could have told you what `[,0].reduce(() => console.log('called'))` does without looking it up or reading the algorithm","msgtype":"m.text"},"ts":1608098040000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"off the top of my head, i'd assume either it was called once (with undefined and 0), or that it throws lacking an initial value","msgtype":"m.text"},"ts":1608098075000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"knowing that it's ES5 would more strongly imply the latter, i guess","msgtype":"m.text"},"ts":1608098117000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"lol seems like it does neither, fun","msgtype":"m.text"},"ts":1608098150000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`[undefined,0].reduce(() => console.log('called'))` seems to do the first thing tho","msgtype":"m.text"},"ts":1608098173000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"a fun consequence of `reduce` ignoring holes is that, unlike all the other functional array processing methods (map, filter, every, indexOf, find, etc) it is impossible to write `.join` in terms of `.reduce`","msgtype":"m.text"},"ts":1608098546000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"though I guess that would be better phrased as being a consequence of `join` _not_ ignoring holes, it being the odd one out","msgtype":"m.text"},"ts":1608098568000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"all the ES6+ ones don't ignore holes tho, right?","msgtype":"m.text"},"ts":1608098578000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"find, findIndex","msgtype":"m.text"},"ts":1608098582000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'm pretty sure the ES6+ pattern is \"pretend sparse arrays don't exist\"","msgtype":"m.text"},"ts":1608098602000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"oh, yeah, `find` does get called for holes","msgtype":"m.text"},"ts":1608098639000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`.includes` too","msgtype":"m.text"},"ts":1608098651000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I forgot we did that","msgtype":"m.text"},"ts":1608098654000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`flatMap` does its own thing","msgtype":"m.text"},"ts":1608098659000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"does flatMap not call holes??","msgtype":"m.text"},"ts":1608098686000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"what would it call them with?","msgtype":"m.text"},"ts":1608098710000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"undefined","msgtype":"m.text"},"ts":1608098718000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"anyway no, it does not","msgtype":"m.text"},"ts":1608098727000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ouch, that seems like an oversight","msgtype":"m.text"},"ts":1608098733000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"not worth fixing ofc, but a pretty big mistake considering the post-ES6 pattern","msgtype":"m.text"},"ts":1608098743000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it was intentional","msgtype":"m.text"},"ts":1608098756000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"https://github.com/tc39/proposal-flatMap/issues/29","msgtype":"m.text"},"ts":1608098760000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that issue doesn't imply it was intentional, it implies it should treat holes as undefineds :-/","msgtype":"m.text"},"ts":1608098806000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"oh i guess your last comment does","msgtype":"m.text"},"ts":1608098818000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ok, symmetry with `map` does seem reasonable","msgtype":"m.text"},"ts":1608098832000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"fair enough","msgtype":"m.text"},"ts":1608098838000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"seems like a decent precedent then - new stuff treats holes as undefineds, but symmetry with old stuff wins","msgtype":"m.text"},"ts":1608098910000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1608099011000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"dunno how many new array methods like this there will be to add","msgtype":"m.text"},"ts":1608099093000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`findLast` will get the new-semantics, fortunately, since `find` has them","msgtype":"m.text"},"ts":1608099114000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess if we add a non-mutating `.reversed` it will probably have to preserve holes","msgtype":"m.text"},"ts":1608099154000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"indeed","msgtype":"m.text"},"ts":1608099161000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"holes sure are weird","msgtype":"m.text"},"ts":1608102297000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ystartsev: have y'all shipped .at() yet and seen anything?","msgtype":"m.text"},"ts":1608137592000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ystartsev: i flipped the flag a little under 2 weeks ago and haven't seen any bug reports yet for Canary","msgtype":"m.text"},"ts":1608137612000,"senderName":"shu","senderId":"shu@irc"}
]