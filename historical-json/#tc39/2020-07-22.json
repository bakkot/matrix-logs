[
{"content":{"body":"engine262 rewrite now failing fewer than 10,000 tests ðŸŽ‰","msgtype":"m.text"},"ts":1595387054000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Nice one!","msgtype":"m.text"},"ts":1595387070000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"its mostly early errors at this point :(","msgtype":"m.text"},"ts":1595387086000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"still don't have a great way to do early errors","msgtype":"m.text"},"ts":1595387096000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"might rip out all the early error stuff i currently have and make it a second pass","msgtype":"m.text"},"ts":1595387145000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"traditionally early errors are part of the parser","msgtype":"m.text"},"ts":1595387242000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah still part of the parser api","msgtype":"m.text"},"ts":1595387290000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i mean like, `parseScriptBody` wouldn't be what checks for duplicate lexical bindings","msgtype":"m.text"},"ts":1595387309000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I mean it could be","msgtype":"m.text"},"ts":1595387325000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"everything is a mess","msgtype":"m.text"},"ts":1595387331000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`a.await` is a parse error rn","msgtype":"m.text"},"ts":1595387336000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm liking the idea of shift's reduce thing","msgtype":"m.text"},"ts":1595387356000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i wonder if it would be web compatible to make evaluators able to throw AggregateErrors instead of SyntaxError","msgtype":"m.text"},"ts":1595389613000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"10,000 tests! wow! ","msgtype":"m.emote"},"ts":1595391440000,"senderName":"howdoi","senderId":"howdoi@irc"},
{"content":{"body":"the link for Decorators slides at https://github.com/tc39/agendas/blob/master/2020/07.md and in the notes doc doesn't work, can someone involved with the proposal fix it?","msgtype":"m.text"},"ts":1595424371000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"what if function parameters had elisions","msgtype":"m.text"},"ts":1595430677000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`Object.defineProperty(new Proxy({}, {getOwnProperty(o, k) {return {value:1}}}), 'why', {value:2})` is... strange","msgtype":"m.text"},"ts":1595430771000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`{ let o = new Proxy({}, {getOwnPropertyDescriptor(o, k) {return {value:1}}}); Object.defineProperty(o, 'why', {value:2}).why; }` => 2","msgtype":"m.text"},"ts":1595430876000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`{ let o = new Proxy({}, {getOwnPropertyDescriptor(o, k) {return {value:1}}}); o.why; Object.defineProperty(o, 'why', {value:2}).why; }` => 2","msgtype":"m.text"},"ts":1595430896000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"{ let o = new Proxy({}, {getOwnPropertyDescriptor(o, k) {return {value:1}}}); Object.getOwnPropertyDescriptor(o, 'why'); Object.defineProperty(o, 'why', {value:2}); } => error","msgtype":"m.text"},"ts":1595430917000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"you can read the non-configurable value","msgtype":"m.text"},"ts":1595430946000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"and you can replace it, as long as you don't check if it is configurable","msgtype":"m.text"},"ts":1595430961000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"the `get` trap being distinct from the `getOwnPropertyDescriptor` trap is a bit weird, yeah","msgtype":"m.text"},"ts":1595430989000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"bradleymeck in your last example it's the `Object.getOwnPropertyDescriptor` which  throws, not the `Object.defineProperty`","msgtype":"m.text"},"ts":1595431061000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"also confusing","msgtype":"m.text"},"ts":1595431133000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"you can read it, but not see its descriptor?","msgtype":"m.text"},"ts":1595431168000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"what is this hell","msgtype":"m.text"},"ts":1595431177000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"> the `get` trap being distinct from the `getOwnPropertyDescriptor` trap is a bit weird, yeah","msgtype":"m.text"},"ts":1595431337000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'm learning yea","msgtype":"m.text"},"ts":1595431361000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"proxies are strange","msgtype":"m.text"},"ts":1595431655000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"reflection always gets strange eventually","msgtype":"m.text"},"ts":1595431782000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"what is a JS builtin that takes an options bag ?","msgtype":"m.text"},"ts":1595442131000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: 262 doesn't really have any, unless you count a Proxy handler, or Object.defineProperties/Object.create's second argument","msgtype":"m.text"},"ts":1595442177000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"no, per the discussion we just had","msgtype":"m.text"},"ts":1595442189000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"handler is thing which gets \"this\" value apparently","msgtype":"m.text"},"ts":1595442210000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"options bag, doesn't","msgtype":"m.text"},"ts":1595442217000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"defineProperties kind of?","msgtype":"m.text"},"ts":1595442226000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"there's nothing in 262 that takes a function off an object and calls it directly","msgtype":"m.text"},"ts":1595442233000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"in 402, there's tons of examples tho","msgtype":"m.text"},"ts":1595442239000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it doesn't really configure the algorithm","msgtype":"m.text"},"ts":1595442243000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"should we cross ref 402 in the how-we-work term list?","msgtype":"m.text"},"ts":1595442254000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"how about requisition() instead of upsert()/emplace()","msgtype":"m.text"},"ts":1595442921000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"this proposal would be great if we had Decorators","msgtype":"m.text"},"ts":1595442971000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"ensure()?","msgtype":"m.text"},"ts":1595443004000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"what if we made a new kind of function declaration","msgtype":"m.text"},"ts":1595443011000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that wasn't hoisted","msgtype":"m.text"},"ts":1595443018000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"then we could just do normal style generators","msgtype":"m.text"},"ts":1595443024000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"decorators*","msgtype":"m.text"},"ts":1595443027000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`await @all x`","msgtype":"m.text"},"ts":1595443314000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"for me this looks better than `await.all x`, not going through stacking trace issues","msgtype":"m.text"},"ts":1595443346000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"I'd be pretty satisfied with `await * x`, only giving sugar for Promise.all","msgtype":"m.text"},"ts":1595443381000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"what about","msgtype":"m.text"},"ts":1595443387000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`for await concurrent (const x of y) {}`","msgtype":"m.text"},"ts":1595443392000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"~= `await Promise.all(y.map((x) => {}))`","msgtype":"m.text"},"ts":1595443418000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: probably a separate discussion but I'd be up to discuss it as well","msgtype":"m.text"},"ts":1595443491000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"devsnek that interacts weirdly with abrupt completions","msgtype":"m.text"},"ts":1595443494000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it seems like it would lead to a lot more concurrency bugs than the current patterns","msgtype":"m.text"},"ts":1595443543000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i guess the hard part would be deciding what `break` does","msgtype":"m.text"},"ts":1595443576000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"everything else seems well defined","msgtype":"m.text"},"ts":1595443581000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"presumably `return` exits the function as soon as any iteration hits it, and it's just a race?","msgtype":"m.text"},"ts":1595443677000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that is the \"a lot more concurrency bugs\" thing","msgtype":"m.text"},"ts":1595443687000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh yeah return","msgtype":"m.text"},"ts":1595443717000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rkirsling: kind of, but idk how that implies potential update","msgtype":"m.text"},"ts":1595443725000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Bakkot: the map is more about mapping to async functions, not the result of those async functions","msgtype":"m.text"},"ts":1595443743000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek I am not sure what that means","msgtype":"m.text"},"ts":1595443782000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or, like, why it matters","msgtype":"m.text"},"ts":1595443785000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I know how Promise.all works I just don't know why you are mentioning this","msgtype":"m.text"},"ts":1595443797000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"bradleymeck: true. was all I could think of at that moment though","msgtype":"m.text"},"ts":1595443806000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"this is interesting https://es.discourse.group/t/nan-trapping-operators/402","msgtype":"m.text"},"ts":1595444077000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rkirsling: .summon()?","msgtype":"m.text"},"ts":1595444102000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"jackworks: the proposal I was referring to was https://es.discourse.group/t/array-prototype-uniqby/138","msgtype":"m.text"},"ts":1595444107000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"nice","msgtype":"m.text"},"ts":1595444109000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":".claim is pretty good","msgtype":"m.text"},"ts":1595444148000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"do we have any knowledge of static JS tools that assume after a map.has(k) === true that map.get(k) should get a value that does exist","msgtype":"m.text"},"ts":1595444495000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"also how do people feel about .get(k) firing a user code trap?","msgtype":"m.text"},"ts":1595444509000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"devsnek: I think this is at the wrong poit","msgtype":"m.text"},"ts":1595445315000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"point**","msgtype":"m.text"},"ts":1595445319000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"You'd want to throw when you generate the NaN, not when you compare with it.","msgtype":"m.text"},"ts":1595445329000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"bradleymeck: Typescript doesn't, last I checked","msgtype":"m.text"},"ts":1595445355000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"jridgewell: `nonanscope {}`","msgtype":"m.text"},"ts":1595445358000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: \"`for await concurrent (const x of y) {}`\" yeah, I always want to have some kind of concurrent control over `for await` loops. maybe even further, with args `for await concurrent 4` means max 4 running or `for await concurrent _identifier_` to refer a custom task dispatcher","msgtype":"m.text"},"ts":1595445358000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"Bakkot: yeah, maybe we ban the \"break\" or \"return\" only leave \"continue\" in `for await concurrent` like the do expression did","msgtype":"m.text"},"ts":1595445463000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"jackworks yeah, though I would still worry about closed-over values","msgtype":"m.text"},"ts":1595445661000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I remember there was a \"use strong\" in v8 that will throw immediately when a math operation yielding NaN, I like that idea, not in the language, but as a debugger tool.","msgtype":"m.text"},"ts":1595445679000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"for loops it is very common to have, like, `let x; for (...) { if (test) x = whatever }`","msgtype":"m.text"},"ts":1595445681000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which, if the loop is concurrent, is probably a bug","msgtype":"m.text"},"ts":1595445691000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you can have the same thing with Promise.all, of course, but it is much harder to run into","msgtype":"m.text"},"ts":1595445716000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Oh maybe we can suggest v8 to add a \"Pause on NaN calculation\"","msgtype":"m.text"},"ts":1595445716000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"\"if the loop is concurrent, is probably a bug\" yeah but since it is opt-in, developer should learn about what is race condition","msgtype":"m.text"},"ts":1595445826000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"ehhhhhhhhhhhhhhhh","msgtype":"m.text"},"ts":1595445841000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"concurrency bugs are notoriously one of the Hard Problems","msgtype":"m.text"},"ts":1595445854000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I would be very, very reluctant to introduce an affordance which makes them easier to run into","msgtype":"m.text"},"ts":1595445866000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I do not find \"developers should be careful\" a compelling argument in this case, especially given how hard concurrency bugs are to avoid in codebases that don't have Rust-style ownership or similar guarantees","msgtype":"m.text"},"ts":1595445913000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"\"Promise.all, of course, but it is much harder to run into\" agree, but the problem is today, async concurrent calculation is pain to write `await Promise.all(arr.map(async x=> ...))` too tedious","msgtype":"m.text"},"ts":1595445926000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"\"very reluctant to introduce an affordance which makes them easier to run into\" reasonable... so we just let async concurrent pain to write, to let devs write serial async code? at least for me, sometimes it's really safe to do the async concurrent calculation but I don't want to write `await Promise.all(arr.map(async x=> ...)) ` these bunch of code so I let it run in serial","msgtype":"m.text"},"ts":1595446175000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"I am happy to explore affordances which make it easier to write concurrent code; I don't think `await.all` would have the same problem as `for await concurrent`, for example","msgtype":"m.text"},"ts":1595446296000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think WeakRef and FinalizationRegistry are applicable to the same argument. they're easy to misuse but they're still added to the 262 and mdn.io gives warnings on it \"Avoid where possible\"","msgtype":"m.text"},"ts":1595446299000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"We would never have added WeakRefs if they hadn't been necessitated by wasm","msgtype":"m.text"},"ts":1595446323000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1595446350000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"but they're a fundamental capability, whereas `for await concurrent` is not a fundamental capability","msgtype":"m.text"},"ts":1595446356000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"my friend was working on the membrane, he also needs WeakRef; my RPC library provides iterating on remote async generators so I need WeakRef too","msgtype":"m.text"},"ts":1595446445000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"`for await concurrent` is about making certain kinds of code easier to write, which means we need to think hard about whether we in fact want those kinds of code to be easier to write, and my answer is no because that _particular_ syntax makes it much easier to have concurrency bugs, more than other possible affordances for writing concurrent code","msgtype":"m.text"},"ts":1595446445000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah they're useful in other cases, it's just that they have way too many problems to justify for those cases alone","msgtype":"m.text"},"ts":1595446469000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"hmm, so people will re-inventing it again and again and it's more easily to have bugs in their own impl","msgtype":"m.text"},"ts":1595446637000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"is it possible to design a syntax to make it easy to write, meanwhile reduce the possible race condition bugs?","msgtype":"m.text"},"ts":1595446671000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"Phew, I haven't had to write it yet myself, but `await Promise.all(arr.map(async x=>...))` is *awful* to write.","msgtype":"m.text"},"ts":1595446688000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"`for await.all(const x of arr){...}` plz","msgtype":"m.text"},"ts":1595446704000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(WebCrypto API on mdn even gives a big strong red warning box writes \"If you're not sure you know what you are doing, you probably shouldn't be using this API.\")","msgtype":"m.text"},"ts":1595446719000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"maybe the `for await.all` sugar is too sweet and people will start to abuse it everywhere leads tons of race conditions, then the eslint decides it's a super foot gun and ban it ðŸ¤£","msgtype":"m.text"},"ts":1595446840000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"oh I recall a joke, when `async await` steps into our life, I saw an article says `await` is easy to get abused and new comer to JS will try to write `await` before any expression.","msgtype":"m.text"},"ts":1595447000000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"tbf people do that!","msgtype":"m.text"},"ts":1595447025000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it just doesn't lead to bugs","msgtype":"m.text"},"ts":1595447028000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so it's not a big problem","msgtype":"m.text"},"ts":1595447038000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"name for a .get that defaults a value if no such key is present but does not insert it? (getDefault was seen as having either semantics)","msgtype":"m.text"},"ts":1595450526000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"why not `.get(key[, default])`","msgtype":"m.text"},"ts":1595450572000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"matches the current default of undefined","msgtype":"m.text"},"ts":1595450582000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"getOrDefault","msgtype":"m.text"},"ts":1595450603000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or jordan's thing","msgtype":"m.text"},"ts":1595450620000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`default` would need to be a function, there","msgtype":"m.text"},"ts":1595450645000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"ah, true. can default to `() => {}`","msgtype":"m.text"},"ts":1595450677000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"getOrCompute","msgtype":"m.text"},"ts":1595450708000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"getpute","msgtype":"m.text"},"ts":1595450718000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"jridgewell why \"need\"?","msgtype":"m.text"},"ts":1595450722000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"winner","msgtype":"m.text"},"ts":1595450722000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I see the use for it, just not the necessity","msgtype":"m.text"},"ts":1595450728000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Because the default value can be very expensive to create","msgtype":"m.text"},"ts":1595450807000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"can be, but is that frequent enough that it is necessarily something which has to be met by this method?","msgtype":"m.text"},"ts":1595450834000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"for those cases, you can still do `if (!x.has()) x.put()` or whatever","msgtype":"m.text"},"ts":1595450861000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yes, in my experience","msgtype":"m.text"},"ts":1595450864000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it's often constructing an object or transforming data","msgtype":"m.text"},"ts":1595450891000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"To counter, you could just do `x.has(key) ? x.get(key) : default` for your case","msgtype":"m.text"},"ts":1595450905000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"right, of course","msgtype":"m.text"},"ts":1595450915000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this is a question about frequency","msgtype":"m.text"},"ts":1595450920000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in my experience, the cheap key is much more common","msgtype":"m.text"},"ts":1595450928000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I am curious if your experience differs","msgtype":"m.text"},"ts":1595450933000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"cheap key?","msgtype":"m.text"},"ts":1595450941000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"*cheap default","msgtype":"m.text"},"ts":1595450942000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Ah,","msgtype":"m.text"},"ts":1595450947000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"My use is templateing libraries","msgtype":"m.text"},"ts":1595450960000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Particularly lit-html, which creates a whole `<template>` and children and walks the entire tree.","msgtype":"m.text"},"ts":1595451004000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"java has getOrDefault, which takes a value, and computeIfAbsent, which takes a lambda (and updates the map(","msgtype":"m.text"},"ts":1595451063000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think a default-value factory is a requirement, yeah. Arrow functions make it cheap to define one for constant values, and they're necessary for expensive defaults.","msgtype":"m.text"},"ts":1595459197000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And I think the functionality should indeed just be added as a second parameter on .get().","msgtype":"m.text"},"ts":1595459229000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(Python separates default-value from default-value-factory, but Python also has annoying inline functions.)","msgtype":"m.text"},"ts":1595459312000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"what if we allowed elisions in function parameters","msgtype":"m.text"},"ts":1595460780000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Elaborate?","msgtype":"m.text"},"ts":1595461559000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"}
]