[
{"content":{"body":"was it ever suggested that return with an operand could be disallowed in generators","msgtype":"m.text"},"ts":1557850328000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"vaguely idle question, given a variable |code| that is a string, is there any shorter/clearer way to count the number of code points in it than |[...code[Symbol.iterator]()].length|?","msgtype":"m.text"},"ts":1557853560000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"I guess the iterator-call already happens for a spread, so |[...code].length| would work too","msgtype":"m.text"},"ts":1557853636000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"jwalden: the latter is shortest I suspect","msgtype":"m.text"},"ts":1557855944000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"jwalden: i'd love to see an accessor that returned that length without the intermediate array","msgtype":"m.text"},"ts":1557857563000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"static function to do the same seems maybe preferable to me, if I were concerned about API and not just writing some goofball test code right now","msgtype":"m.text"},"ts":1557857609000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"sure, i suppose that's fine, but it seems weird since `.length` is an instance property","msgtype":"m.text"},"ts":1557857629000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"given code point length is O(n), an accessor that hides the perf issue seems unideal","msgtype":"m.text"},"ts":1557857659000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"or at least O(n) without a bunch of work to maintain a value that is currently never accessed","msgtype":"m.text"},"ts":1557857678000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"why would it need to be O(n) inside the engine","msgtype":"m.text"},"ts":1557857686000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and would presumably be relatively rarely accessed were one introduced","msgtype":"m.text"},"ts":1557857689000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"gotta run through all the code units to count the number of code points in them, no?","msgtype":"m.text"},"ts":1557857712000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"or rather, how is `.length` not O(n) too?","msgtype":"m.text"},"ts":1557857717000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":".length is a count of code units, and that is maintained in the string to know how much memory the characters use","msgtype":"m.text"},"ts":1557857744000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"or if the string is begin/end pointer denominated, you just subtract and divide by character size","msgtype":"m.text"},"ts":1557857767000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"sure, but that's determined at string creation time by counting the code units","msgtype":"m.text"},"ts":1557857963000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"while doing that count, couldn't the number of code points be counted at the same time, and stored alongside it?","msgtype":"m.text"},"ts":1557857978000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it /could/, but it's not accessed enough to justify four bytes' storage per string","msgtype":"m.text"},"ts":1557858054000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"i'd be interested to know how often people do count code points, but also i suspect it's not accessed that much *because* it's not easy","msgtype":"m.text"},"ts":1557858100000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I suppose you can imagine custom-arena tricks or so to encode \"this has multiple-unit code points in it\" to avoid the cost for most things, but we're building up a lot of complexity for a thing that is not often used now","msgtype":"m.text"},"ts":1557858101000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"it's usually the thing people actually want instead of length anyways","msgtype":"m.text"},"ts":1557858116000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(actually grapheme count is what people want, but that's a separate discussion)","msgtype":"m.text"},"ts":1557858124000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"a number that's usable as an index is most often what people really want, if they're manipulating strings, and a count of code units plays much better with indexes as counts of code units","msgtype":"m.text"},"ts":1557858170000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"hm, i'm not sure that's true","msgtype":"m.text"},"ts":1557858186000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"manipulating strings by code units is often inherently broken, since code points exist","msgtype":"m.text"},"ts":1557858203000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but yeah a way to index by code point, like the `.at()` proposal, would make sense in concert","msgtype":"m.text"},"ts":1557858220000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"well, if you have an index as a count of code points, of what use is it?  you have to iterate from start to find out the meaning of that index","msgtype":"m.text"},"ts":1557858221000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"it's the number of things i will see on screen","msgtype":"m.text"},"ts":1557858231000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i don't care about the index","msgtype":"m.text"},"ts":1557858241000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"No, that's grapheme clusters","msgtype":"m.text"},"ts":1557858629000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Code points are a not-so-useful in between, IME","msgtype":"m.text"},"ts":1557858641000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Or font stuff, with ligatures","msgtype":"m.text"},"ts":1557858661000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: yeah that's fair that graphemes are what i really want","msgtype":"m.text"},"ts":1557858966000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"https://paste.rs/GNo.js is roughly what I'm working on/doing right now","msgtype":"m.text"},"ts":1557859529000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"basically I'm changing a bunch of coordinate stuff inside SpiderMonkey from code units to code points -- a necessary change to be able to tokenize/parse UTF-8 without inflating to UTF-16 -- and I get to think in both coordinate spaces to some degree right now","msgtype":"m.text"},"ts":1557859577000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"that's quite a gasp matrix","msgtype":"m.text"},"ts":1557859605000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it seemed appropriate for the subject matter","msgtype":"m.text"},"ts":1557859768000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"TIL (as a demonstration of the definition of grapheme cluster not being dependent on glyph rendering) ·ÑÄ·ÑÄ·ÑÄÍ∞Å·Ü®·Ü® is a single grapheme cluster üëÄ","msgtype":"m.text"},"ts":1557859787000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I'm doing work on computing column numbers in code, and so I need some code with a bunch of non-BMP stuff in it, at intervals such that dicing up a line by code unit will end up splitting some code points in half","msgtype":"m.text"},"ts":1557859816000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"the dicing interval I'm using is 128, but in principle it could be any number that's at least 2 for UTF-16, or 4 for UTF-8","msgtype":"m.text"},"ts":1557859854000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"rkirsling: lol so i guess what i really want is a way to iterate on glyphs, and get glyph count","msgtype":"m.text"},"ts":1557859873000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and I expect to run with 128 at the end of the day, so something that hits a couple few chunks of that size is desirable","msgtype":"m.text"},"ts":1557859892000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"ljharb: do you want ff or ffi as a single unit depending on the font though?","msgtype":"m.text"},"ts":1557860878000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: lol i just want to know if i squint, how many chunks of ink will i see","msgtype":"m.text"},"ts":1557860911000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but yeah i'd expect a ligature to be counted as 1","msgtype":"m.text"},"ts":1557860933000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"bringing font metrics into core JS sounds good","msgtype":"m.text"},"ts":1557862099000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"my working assumption is code editors generally are going to denominate column numbers as counts of code points, so I'm trying to make things consistent with that","msgtype":"m.text"},"ts":1557862127000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"but given UTF-8 making a major hash of code unit counts, there is zero chance counts of code units are what editors will typically display","msgtype":"m.text"},"ts":1557862154000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"jwalden There's a proposal for that: https://github.com/tc39/proposal-intl-segmenter includes `new Intl.Segmenter(locale, {granularity: \"grapheme\"})`","msgtype":"m.text"},"ts":1557870725000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"gibson042: I could be wrong, but I don't think grapheme is the same as code point","msgtype":"m.text"},"ts":1557870820000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"and a count of code points is definitely not a locale-sensitive thing","msgtype":"m.text"},"ts":1557870847000,"senderName":"jwalden","senderId":"jwalden@irc"},
{"content":{"body":"(on a given string, that is)","msgtype":"m.text"},"ts":1557870856000,"senderName":"jwalden","senderId":"jwalden@irc"}
]