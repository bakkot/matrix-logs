[
{"content":{"body":"Bakkot: https://github.com/tc39/ecma262/pull/2275","msgtype":"m.text"},"ts":1610587826000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"jmdyck jmdyck thanks! though it'll conflict with 2271, which I think I'm going to land first, so it'll need a trivial rebase","msgtype":"m.text"},"ts":1610587917000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"np","msgtype":"m.text"},"ts":1610587936000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"jmdyck are there other multi-clause SDOs left other than Early Errors and Evaluation?","msgtype":"m.text"},"ts":1610592118000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"MV, TV and TRV, regexp-evaluate","msgtype":"m.text"},"ts":1610592149000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"regexp-evaluate I'm considering to be evaluate, basically","msgtype":"m.text"},"ts":1610592177000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"not convinced the others are SDOs","msgtype":"m.text"},"ts":1610592197000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"\"A syntax-directed operation is a named operation whose definition consists of algorithms, each of which is associated with one or more productions from one of the ECMAScript grammars.\" - MV, TV, and TRV are defined declaratively, not as algorithms","msgtype":"m.text"},"ts":1610592260000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"It's true they're not defined via emu-alg, but that doesn't mean they're not defined via algorithms. (I'm doubtful the distinction \"declaratively\" vs \"as algorithms\" means much in this context.)","msgtype":"m.text"},"ts":1610592372000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"anyway the practical answer to your question is, I didn't put \"type='sdo'\" on those because its purpose is as a marker for ecmarkup to generate reference lists, and it only knows how to do that for SDOs which follow the `emu-grammar emu-alg` pattern","msgtype":"m.text"},"ts":1610592434000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(in ecmaspeak-py, I call them \"inline SDOs\" to capture the differences in format.)","msgtype":"m.text"},"ts":1610592463000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"practical reason is okay for now.","msgtype":"m.text"},"ts":1610592549000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"is ExtendedAtom :: \\ [lookahead = c] one of the weird ambiguous parts of the annex b grammar","msgtype":"m.text"},"ts":1610593529000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"probably","msgtype":"m.text"},"ts":1610593579000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1610593611000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ExtendedAtom :: `\\` AtomEscape matches (among other things) `\\` `c` ControlLetter, so  \\ [lookahead = c] only matches when the c isn't followed by a ControlLetter.","msgtype":"m.text"},"ts":1610594324000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"jmdyck: isn't that ambiguous because at the point where you have `\\cf`it could either be `\\` `c` `f` or whatever codepoint `\\cf` expands to","msgtype":"m.text"},"ts":1610594451000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Are you thinking of \\xcf ?","msgtype":"m.text"},"ts":1610594624000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"no i was just curious about \\c","msgtype":"m.text"},"ts":1610594641000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I don't understand what you mean by  \"whatever codepoint `\\cf` expands to\"","msgtype":"m.text"},"ts":1610594659000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"this https://gc.gy/78299721.png","msgtype":"m.text"},"ts":1610594721000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you could either interpret `\\cf` as `\\` `c` `f` or CharacterEscape :: c f","msgtype":"m.text"},"ts":1610594744000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i should've said that more clearly","msgtype":"m.text"},"ts":1610594755000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"three ExtendedAtoms or one CharacterEscape","msgtype":"m.text"},"ts":1610594813000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ok, I'm not sure what you mean by the first then","msgtype":"m.text"},"ts":1610594813000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1610594816000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yes, the grammar allows either parse, but the ordering rule only allows the one where `cf` is a CharacterEscape. I think.","msgtype":"m.text"},"ts":1610594983000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ordering rule?","msgtype":"m.text"},"ts":1610594989000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"\"When parsing using the following grammar, each alternative is considered only if previous production alternatives do not match.\"","msgtype":"m.text"},"ts":1610595001000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1610595011000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is that a sentence somewhere in annex b","msgtype":"m.text"},"ts":1610595018000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-regular-expressions-patterns","msgtype":"m.text"},"ts":1610595028000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"oh i see","msgtype":"m.text"},"ts":1610595039000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1610595041000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I believe that's the main thing that's preventing B.1.* merging into main spec","msgtype":"m.text"},"ts":1610595098000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yeah...","msgtype":"m.text"},"ts":1610595107000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"jmdyck: you had some comments about adding blank lines before `<emu-clause>`, but even upstream there are a number of places we don't do that","msgtype":"m.text"},"ts":1610595868000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Yup. I only commented on places that were in the diff.","msgtype":"m.text"},"ts":1610595900000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I didn't limit it to places where the status quo has a blank line currently, but I think there was at least one such.","msgtype":"m.text"},"ts":1610595951000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ah, ok. I think I'm not going to bother fixing them in this PR, since we're not currently consistent, but I'll make a note to add a lint rule for it ecmarkup and fix all of them when I land that.","msgtype":"m.text"},"ts":1610595966000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"fine with me.","msgtype":"m.text"},"ts":1610595988000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"There were 2 cases where the status quo has a blank line.","msgtype":"m.text"},"ts":1610596086000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Well, maybe it depends on how the diff chunks things.","msgtype":"m.text"},"ts":1610596155000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"The one before \"Runtime Semantics: PropertyDefinitionEvaluation\" is for sure.","msgtype":"m.text"},"ts":1610596218000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Bakkot: re \"regexp-evaluate I'm considering to be evaluate, basically\" I think there are problems with that, but not at the level that the spec currently deals with.","msgtype":"m.text"},"ts":1610596691000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"E.g., if we ever get to the point where we're declaring the \"signature\" of SDOs, it'll be confusing to treat Evaluation and regexp-evaluate as the same SDO, because it'll have a weird signature.","msgtype":"m.text"},"ts":1610596812000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I guess by \"basically\" I meant \"for the purposes of this reorganization, I've made the decision to leave Evaluation semantics next to the productions rather than consolidated those into a single section, and I think that decision extends to the pattern evaluation semantics as well\"","msgtype":"m.text"},"ts":1610597165000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1610597210000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"last call for feedback on https://github.com/tc39/ecma262/pull/2271 before I rebase it and ask ljharb to land","msgtype":"m.text"},"ts":1610644618000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"will do those things this afternoon if there's nothing further","msgtype":"m.text"},"ts":1610644644000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: there was something else i thought of, but haven't written the code to do the analysis yet","msgtype":"m.text"},"ts":1610646164000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"jmdyck happy to wait if you'd like me to","msgtype":"m.text"},"ts":1610646185000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or if you describe what it is I might be able to do by hand","msgtype":"m.text"},"ts":1610646198000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(though I think it's probably also fine to land it now and fix it later if/when you do the analysis)","msgtype":"m.text"},"ts":1610646255000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the idea is that, within an SDO clause, it might be good to order the emu-grammar + emu-alg groups so that productions in the emu-grammars appear in the same order as in the defining grammar.","msgtype":"m.text"},"ts":1610646383000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ahh, yeah","msgtype":"m.text"},"ts":1610646406000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I'd originally planned to do that actually, but ended up going the other way","msgtype":"m.text"},"ts":1610646420000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which other way?","msgtype":"m.text"},"ts":1610646433000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"that is, I explicitly reordered them in some cases","msgtype":"m.text"},"ts":1610646443000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in particular, class declarations are defined between functions and async functions","msgtype":"m.text"},"ts":1610646469000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"was a method on String.prototype ever suggested for the dedent proposal? I don't see any discussion about it but it seems unlikely to have not been mentioned at some point...","msgtype":"m.text"},"ts":1610646492000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but in the SDOs like \"IsFunctionDefinition\" I thought it more natural to have the function ones all together, followed by the class one","msgtype":"m.text"},"ts":1610646529000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"now, probably the defining grammar should be reordered in that particular case, but I didn't want to do so in this PR","msgtype":"m.text"},"ts":1610646550000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(Indeed, having class stuff in the middle of function stuff is annoying)","msgtype":"m.text"},"ts":1610646558000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"hmm i guess that would have the wrong precedence with tagged templates","msgtype":"m.text"},"ts":1610646562000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"sigh","msgtype":"m.text"},"ts":1610646563000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think there may have been other cases I reordered too","msgtype":"m.text"},"ts":1610646582000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in the cases which I didn't manually reorder, the order in the consolidated SDO is exactly the same as the order in which the SDOs appeared in the original, which I think is almost equivalent to the order you suggest","msgtype":"m.text"},"ts":1610646635000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok, i won't bother suggesting that then","msgtype":"m.text"},"ts":1610646651000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"there's a related one, which is that within a single `<emu-alg>` for an SDO, each production for a given LHS should be in the same order as in the defining grammar","msgtype":"m.text"},"ts":1610646819000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but I'm pretty sure that property is currently met","msgtype":"m.text"},"ts":1610646838000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"guess I could write a lint rule for it reasonably quickly","msgtype":"m.text"},"ts":1610646853000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you mean <emu-grammar>","msgtype":"m.text"},"ts":1610646943000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I do mean that yes","msgtype":"m.text"},"ts":1610646950000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I have code that checks the ordering of the RHSs within each production (and the spec satisfies that), but not within each <emu-grammar> or within an sdo clause.","msgtype":"m.text"},"ts":1610647057000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"\"checks the ordering of the RHSs within each production\" - checks against what?","msgtype":"m.text"},"ts":1610647130000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"checks that they are in the same order as the corresponding RHSs of the defining production","msgtype":"m.text"},"ts":1610647210000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ok I think that's the thing I was wanting to check","msgtype":"m.text"},"ts":1610647254000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so what do you mean by \"but not within each <emu-grammar>\"? as in, if an LHS appears twice in the emu-grammar, you don't check that the productions are ordered across the two occurrences?","msgtype":"m.text"},"ts":1610647282000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I probably should ensure that a given LHS never appears twice in a single emu-grammar, but haven't done so yet","msgtype":"m.text"},"ts":1610647316000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(when you re-split that production for AsyncFunctionExpression, you got the RHSs in the 'wrong' order, but I didn't bother bringing it up because that'll evaporate if my AFE PR lands.)","msgtype":"m.text"},"ts":1610647324000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"oh, whoops","msgtype":"m.text"},"ts":1610647333000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"re \"but not within each <emu-grammar>\": I wasn't thinking of a LHS appearing twice. (I don't think I check if it does.) I just meant that all the RHSs (from all the productions) in an emu-grammar 'should' appear in the same order as the corresponding defining RHSs.","msgtype":"m.text"},"ts":1610647545000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Bakkot: another thing I was going to ask: is there an order for the clauses under Scope Analysis? They aren't alphabetical, and they aren't in dependency order. The TopLevelFoo ones aren't even in the same order as the corresponding Foo ones.","msgtype":"m.text"},"ts":1610651371000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Bakkot: checking \"LHS occurs more than once in an <emu-grammar>\": it does happen a few times.","msgtype":"m.text"},"ts":1610653528000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-static-semantics-hascallintailposition , 2nd group from bottom has two TryStatement","msgtype":"m.text"},"ts":1610653581000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-patterns-static-semantics-is-character-class has 3 ClassEscape","msgtype":"m.text"},"ts":1610653639000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-classescape also has 3 ClassEscape","msgtype":"m.text"},"ts":1610653666000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"there is not really an order, no","msgtype":"m.text"},"ts":1610654395000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I should at least make the toplevel ones match the non-toplevel ones","msgtype":"m.text"},"ts":1610654411000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Generally, in the absence of a more semantic ordering criterion, I'd say make them alphabetical.","msgtype":"m.text"},"ts":1610655277000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(A more semantic ordering might arise if, e.g., the clauses got some explanatory commentary and there was an order in which the commentary made most sense.)","msgtype":"m.text"},"ts":1610655419000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"For the scope analysis ones in particular, I think the non-toplevel ones should be grouped, which means not alphabetic","msgtype":"m.text"},"ts":1610655772000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but I can make them be alphabetic otherwise","msgtype":"m.text"},"ts":1610655791000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(I'm intending to add explanatory comments at some point, incidentally, now that there's a single place to put them)","msgtype":"m.text"},"ts":1610655833000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(yeah, but unless you already know roughly how those comments will 'flow', you can't really use that for ordering purposes)","msgtype":"m.text"},"ts":1610657261000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yup, was just an aside","msgtype":"m.text"},"ts":1610657281000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1610657286000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ok, re check RHS order over a whole SDO clause, I've got something running. It's flagging a lot, so maybe isn't working correctly...","msgtype":"m.text"},"ts":1610658471000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"No, I think it's working okay.","msgtype":"m.text"},"ts":1610659368000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"E.g., first hit is in DeclarationPart, where HoistableDeclaration is handled before Declaration, but in the grammar Declaration precedes Hostable.","msgtype":"m.text"},"ts":1610659448000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Next is in BoundNames, which handles `SingleNameBinding : BindingIdentifier Initializer?` then `BindingElement : BindingPattern Initializer?`, but the grammar has them in the opp order.","msgtype":"m.text"},"ts":1610659568000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"And handles `FunctionDeclaration` before `FormalParameters`, but those are (in this PR) in the other order.","msgtype":"m.text"},"ts":1610659669000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I count 145 out-of-order warnings: 119 where LHS are out-of-order, 26 where RHS are out-of-order for same LHS.","msgtype":"m.text"},"ts":1610659849000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"That's in 2271.  Probably a lot less in master.","msgtype":"m.text"},"ts":1610659901000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"huh","msgtype":"m.text"},"ts":1610660642000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"send me the list?","msgtype":"m.text"},"ts":1610660657000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"just checking: do those first 3 sound legit?","msgtype":"m.text"},"ts":1610661204000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"master has less, but not a lot less: 100 where LHS are out-of-order, 24 where RHS etc.","msgtype":"m.text"},"ts":1610661410000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yeah, those three at least seem legit","msgtype":"m.text"},"ts":1610661506000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so 2271 is maybe only responsible for ~20 new ones","msgtype":"m.text"},"ts":1610661728000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"send to email for you in spec?","msgtype":"m.text"},"ts":1610661798000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yup, that works","msgtype":"m.text"},"ts":1610661821000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"let me make sure i've got the latest","msgtype":"m.text"},"ts":1610661922000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"sent, with a little explanation","msgtype":"m.text"},"ts":1610662683000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"hm, i maybe should have zipped it.","msgtype":"m.text"},"ts":1610662696000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"got it, thanks","msgtype":"m.text"},"ts":1610663148000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"So there are enough out-of-orders in master that you probably shouldn't feel obliged to fix the ones that 2271 has added.","msgtype":"m.text"},"ts":1610663423000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"oh, i see one bug, but it probably isn't triggered much.","msgtype":"m.text"},"ts":1610663600000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yeah, I think I see the same one","msgtype":"m.text"},"ts":1610663626000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"emu-grammars inside of emu-algs are considered, but they shouldn't be","msgtype":"m.text"},"ts":1610663641000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1610663658000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"hmm, think there's another","msgtype":"m.text"},"ts":1610663678000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"        PrimaryExpression :","msgtype":"m.text"},"ts":1610663692000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"---------------------------^","msgtype":"m.text"},"ts":1610663692000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"-- ORDER: This is PrimaryExpression's RHS #0, but we just handled RHS #12","msgtype":"m.text"},"ts":1610663692000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"          `this`","msgtype":"m.text"},"ts":1610663692000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think it's treating the newline as an empty RHS","msgtype":"m.text"},"ts":1610663706000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no, that's just an unfortunate side-effect of the meta-grammar: the preceding newline is the start of a RHS","msgtype":"m.text"},"ts":1610663773000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"so `this` *is* PrimaryExpr's RHS #0, and that's what it's pointing at.","msgtype":"m.text"},"ts":1610663837000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"whereas IdentifierReference is RHS #1, which has already been handled. Of course, the opposite order would raise a complaint too.","msgtype":"m.text"},"ts":1610663931000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(This is #1, but we've just handled #12.)","msgtype":"m.text"},"ts":1610663972000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ah, got it","msgtype":"m.text"},"ts":1610664058000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"for cases like that one, in IsIdentifierRef, I think I prefer grouping things with identical algorithms over treating things in order","msgtype":"m.text"},"ts":1610664127000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(we also don't do that consistently, of course.)","msgtype":"m.text"},"ts":1610664136000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"definitely some cleanup to do at some point though","msgtype":"m.text"},"ts":1610664180000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Right, only way to make the complaint go away would be to split off the `this` case and handle it first.","msgtype":"m.text"},"ts":1610664187000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(It occurs to me that, despite what I said, the 'order' linting isn't happening for inline SDOs.)","msgtype":"m.text"},"ts":1610664398000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(not that that matters for 2271)","msgtype":"m.text"},"ts":1610664414000,"senderName":"jmdyck","senderId":"jmdyck@irc"}
]