[
{"content":{"body":"In conjunction with the proposal for a partial application syntax, has a related variation of the `switch` block been proposed?","msgtype":"m.text"},"ts":1576888928000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"metanomial: do you mean https://github.com/tc39/proposal-pattern-matching ?","msgtype":"m.text"},"ts":1576888973000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"metanomial: the two proposals aren't related tho","msgtype":"m.text"},"ts":1576888978000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Similar, but I was thinking for currying functions","msgtype":"m.text"},"ts":1576889093000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"using switch?","msgtype":"m.text"},"ts":1576889183000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yeah, I was thinking something like https://gist.github.com/metanomial/53873157ab73efa7bd8ffeb070c1ab54?ts=4","msgtype":"m.text"},"ts":1576889976000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"you can switch on true","msgtype":"m.text"},"ts":1576889999000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"switch (true) { case name.match(/^d/): ... }","msgtype":"m.text"},"ts":1576890014000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I use this all the time, but it's verbose in a lot of situations","msgtype":"m.text"},"ts":1576890068000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"Consider situations with `switch(true) { case value instanceof X: }` or `switch(true) { case Object.hasOwnProperty(target, 'foo') }`, where there is a long list of conditions.","msgtype":"m.text"},"ts":1576891151000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"It would be very clean to just do `switch apply(value instanceof ?) { case X: }` and `switch apply(Object.hasOwnProperty(target, ?)) { case 'foo': }`","msgtype":"m.text"},"ts":1576891197000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"I don't know if a switch block makes semantic sense here, though","msgtype":"m.text"},"ts":1576891225000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"Also I don't know if the partial application syntax would extend to the `instanceof` operator","msgtype":"m.text"},"ts":1576891306000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"*edit: `target.hasOwnProperty(?)`","msgtype":"m.text"},"ts":1576891599000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"it’s a bit fuzzy what it would mean, given `instanceof` is an observable operation that can have side effects. do you imagine a special path where the prototype chain is only unfurled once, then membership is tested against what has been reported? or is each case a distinct application of instanceof?","msgtype":"m.text"},"ts":1576894764000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"(not to mention @@hasInstance ... I’m guessing it would have to be the latter on account of that)","msgtype":"m.text"},"ts":1576894877000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"given each expression would be ‘doing work’, to me it seems `if`/`else` tells a clearer story about what’s happening than switch would.","msgtype":"m.text"},"ts":1576894946000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"I meant each case being a distinct evaluation of an expression, sequentially. Using the `switch` keyword would definitely lead to confusion, but I think the base pattern is still useful","msgtype":"m.text"},"ts":1576900792000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"`let command; apply(command.match(?)) { case /^help\\s+(\\w+)/: sendHelpMessage(command[1]); }`","msgtype":"m.text"},"ts":1576901114000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"I messed that up. Meant:","msgtype":"m.text"},"ts":1576901145000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"`let command; apply(command = input.match(?)) { case /^help\\s+(\\w+)/: sendHelpMessage(command[1]); }`","msgtype":"m.text"},"ts":1576901164000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"If the hashbang proposal, (private) instance fields proposal, and the smart pipeline proposal all ended up reaching stage four, would this imply ... nine different lexical goal symbols?","msgtype":"m.text"},"ts":1576970783000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"InputElementDiv, InputElementHashbangOrRegExp, InputElementRegExp, InputElementRegExpOrTemplateTail, InputElementRegExpOrTemplateTailOrTopic, InputElementRegExpOrTopic, InputElementTemplateTail, InputElementTemplateTailOrTopic, InputElementTopic","msgtype":"m.text"},"ts":1576970789000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"Maybe it wouldn’t. Consume-longest-possible would be enough for private ident vs topic and for hashbang vs topic I guess.","msgtype":"m.text"},"ts":1576971025000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"We could somewhat reduce the complexity by having one InputElement nonterminal with parameters.","msgtype":"m.text"},"ts":1576971070000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"tangential but even as it stands it's a bit odd that the paragraph says `a TemplateMiddle or a TemplateTail` three times when there's a single TemplateSubstitutionTail to subsume them","msgtype":"m.text"},"ts":1576971239000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(makes me wonder if TemplateSubstitutionTail was added later)","msgtype":"m.text"},"ts":1576971255000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"My understanding was that TemplateMiddle and TemplateTail are tokens, and that TemplateSubstitutionTail isn’t, so the syntactic grammar can’t refer to it.","msgtype":"m.text"},"ts":1576971440000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"(I’m not sure if this is made entirely explicit but it’s at least implied pretty strongly.)","msgtype":"m.text"},"ts":1576971498000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"hmm, that would be surprising because it's only the paragraph text that's doing this","msgtype":"m.text"},"ts":1576971524000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Ah. Yeah, I don’t know for sure. But in https://tc39.es/ecma262/#sec-tokens it does say “[...] TemplateSubstitutionTail [derives] additional tokens”","msgtype":"m.text"},"ts":1576971606000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"OTOH, it makes it sound like Template (NoSubstitutionTemplate and TemplateHead) is a token, and it’s really NoSubstitutionTemplate and TemplateHead which are.","msgtype":"m.text"},"ts":1576971657000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"that's fair, but the other ones listed in that note are behaving as expected in https://tc39.es/ecma262/#sec-ecmascript-language-lexical-grammar","msgtype":"m.text"},"ts":1576971665000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"'cause we have InputElementTemplateTail :: TemplateSubstitutionTail, and even TemplateMiddle and TemplateTail are ultimately multitoken lexical \"components\" so I don't think there's any intentionality","msgtype":"m.text"},"ts":1576971771000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"hm, not sure I follow. TemplateMiddle and TemplateTail are atomic from the syntactic grammar’s POV.","msgtype":"m.text"},"ts":1576971820000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"The derivation of the tv and trv is part of the lexical grammar.","msgtype":"m.text"},"ts":1576971845000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"(This would be more clear if references to terminals by name in the syntactic grammar weren’t styled the same as references to nonterminals.)","msgtype":"m.text"},"ts":1576971938000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"it's quite possible that I'm misunderstanding that notion of atomicity but in the sentence `The InputElementRegExpOrTemplateTail goal is used in syntactic grammar contexts where a RegularExpressionLiteral, a TemplateMiddle, or a TemplateTail is permitted.` I'm not following why there'd be any issue to s/TemplateMiddle, or a TemplateTail/TemplateSubstitutionTail/ to match what the productions actually say","msgtype":"m.text"},"ts":1576972122000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"by atomicity I meant they’re terminals; they are single symbols, not compused by multiple tokens/terminals.","msgtype":"m.text"},"ts":1576972198000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"composed*","msgtype":"m.text"},"ts":1576972205000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"but TemplateTail itself refers to TemplateCharacters which is recursive and refers to TemplateCharacter","msgtype":"m.text"},"ts":1576972270000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yes — that’s a lexical production","msgtype":"m.text"},"ts":1576972287000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"the terminals of the lexical grammar are SourceCharacters","msgtype":"m.text"},"ts":1576972301000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1576972313000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the terminals of the syntactic grammar are tokens, a subset of input elements that the lexical grammar produces","msgtype":"m.text"},"ts":1576972322000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"but looking at https://tc39.es/ecma262/#sec-template-literal-lexical-components it seems impossible that TemplateSubstitutionTail can have a different status than TemplateMiddle","msgtype":"m.text"},"ts":1576972359000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"The input element that the lexical grammar can produce are WhiteSpace, LineTerminator, Comment, IdentifierName, Punctuator, NumericLiteral, StringLiteral, NoSubstitutionTemplate, TemplateHead, TemplateMiddle, TemplateTail, RegularExpressionLiteral, RightBracePunctuator, and DivPunctuator. But that is largely left implicit.","msgtype":"m.text"},"ts":1576972370000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"elements*","msgtype":"m.text"},"ts":1576972376000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"of those, all but the first three are tokens","msgtype":"m.text"},"ts":1576972386000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"but then you'd be saying that https://tc39.es/ecma262/#prod-InputElementTemplateTail is a typo for not listing TemplateMiddle and TemplateTail separately, right?","msgtype":"m.text"},"ts":1576972446000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I just want the description and the implementation to line up...","msgtype":"m.text"},"ts":1576972465000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"No","msgtype":"m.text"},"ts":1576972472000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"because that’s a lexical production","msgtype":"m.text"},"ts":1576972478000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"two colons","msgtype":"m.text"},"ts":1576972483000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"The sentence you’re looking at (‘is used in contexts where...’) is listing tokens, not lexical productions.","msgtype":"m.text"},"ts":1576972494000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"It just happens that it’s never made fully explicit which lexical productions are tokens — it’s implicit in that those are the ones referenced as terminals in the syntactic grammar.","msgtype":"m.text"},"ts":1576972556000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"but then RegularExpressionLiteral in the same sentence isn't a token either, right...? it's in the very same note you called out about \"deriv[ing] additional tokens that are not included in the CommonToken production\"","msgtype":"m.text"},"ts":1576972588000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"There’s no requirement that the lexical grammar’s topmost symbol’s alternatives produce specifically a token of one type.","msgtype":"m.text"},"ts":1576972596000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"Why would RegularExpressionLiteral not be a token?","msgtype":"m.text"},"ts":1576972628000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"because of the note","msgtype":"m.text"},"ts":1576972672000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the token it derives which is not in CommonToken is RegularExpressionLiteral","msgtype":"m.text"},"ts":1576972677000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1576972683000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"but","msgtype":"m.text"},"ts":1576972684000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-primary-expression","msgtype":"m.text"},"ts":1576972778000,"senderName":"bathos","senderId":"bathos@irc"},
{"content":{"body":"RegularExpressionLiteral is referenced here, in the syntactic grammar. That makes it a terminal.","msgtype":"m.text"},"ts":1576972793000,"senderName":"bathos","senderId":"bathos@irc"}
]