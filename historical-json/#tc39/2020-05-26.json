[
{"content":{"body":"Bakkot: In https://github.com/tc39/ecma262/pull/2013, the Travis build is failing because ecmarkup is complaining about the lines","msgtype":"m.text"},"ts":1590503534000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"<pre><code class=\"javascript\">constructor(...args) { super(...args); }</code></pre>","msgtype":"m.text"},"ts":1590503537000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"and","msgtype":"m.text"},"ts":1590503538000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"<pre><code class=\"javascript\">constructor() {}</code></pre>","msgtype":"m.text"},"ts":1590503545000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"But those lines exist in current master. (I've just changed lines around them.)","msgtype":"m.text"},"ts":1590503606000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I've looked at the ecmarkup code, and I can't figure out why it complains for my PR but not for master.","msgtype":"m.text"},"ts":1590503648000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"jmdyck: i like your proposal","msgtype":"m.text"},"ts":1590503720000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"pr","msgtype":"m.text"},"ts":1590503722000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"tx","msgtype":"m.text"},"ts":1590503742000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"ok real question time, should we use AggregateError for handling the array of errors from parsing :P","msgtype":"m.text"},"ts":1590503780000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"from the Promise.any proposal","msgtype":"m.text"},"ts":1590503893000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"sort of joking, but it might encourage implementations to actually support reporting multiple early errors","msgtype":"m.text"},"ts":1590504465000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why aren't 'true' and 'false' strings truthy/falsy?","msgtype":"m.text"},"ts":1590514932000,"senderName":"alystair","senderId":"alystair@irc"},
{"content":{"body":"alystair: history, can't change now","msgtype":"m.text"},"ts":1590515055000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"That's a super footgun","msgtype":"m.text"},"ts":1590515107000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"it'd be super weird that `str + 'e'` might suddenly make it falsy","msgtype":"m.text"},"ts":1590515410000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i don't think it's a footgun in the language; i think it's perhaps one in HTML, and server frameworks like express, and CLI arg parsers","msgtype":"m.text"},"ts":1590515431000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I suspect jackworks is saying that \"false\" being falsey would be a footgun, not the *lack* of said feature. ^_^","msgtype":"m.text"},"ts":1590516687000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And yeah, YAML shows pretty clearly the problem with implicitly mixing the string value space with other types","msgtype":"m.text"},"ts":1590516717000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ohhh right, in that case sorry jackworks, i agree :-)","msgtype":"m.text"},"ts":1590517050000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"booleans should have been symbols. in this essay I will anger everyone for no reason","msgtype":"m.text"},"ts":1590517565000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hehe","msgtype":"m.text"},"ts":1590522009000,"senderName":"alystair","senderId":"alystair@irc"},
{"content":{"body":"thanks all","msgtype":"m.text"},"ts":1590522022000,"senderName":"alystair","senderId":"alystair@irc"},
{"content":{"body":"`Symbol.t` and `Symbol.nil`, ship it","msgtype":"m.text"},"ts":1590527717000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"littledan, In the operator overloading spec why is there a RightOperatorDefinitions? I haven't thought too hard about this, but JS has no binary operators in the form \"a operator b\" that can't be written a.operator(b) right?","msgtype":"m.text"},"ts":1590528907000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"sorry, I don't understand the question","msgtype":"m.text"},"ts":1590528934000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"the idea is that you could overload stuff like number * vector, if you define a vector class","msgtype":"m.text"},"ts":1590528949000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"(which is one of the motivating examples in the post)","msgtype":"m.text"},"ts":1590528958000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"can you just use methods instead? sure, if you don't care about that particular ergonomics thing","msgtype":"m.text"},"ts":1590528977000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"Wouldn't Number have an operator set and then just have the Vector operator in it's LeftOperatorDefinitions?","msgtype":"m.text"},"ts":1590528997000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"Just so I understand things. Every class type (and Number, BigInt, etc) would have an Operator Set with a unique OperatorCounter identifier. So if you define N classes (counting Number, BigInt, etc) in theory you'd have a NxN matrix. (Probably stored in a different data structure in practice). What I'm wondering is based on JS's current types couldn't this just store the lower or upper triangle of the matrix and thus just","msgtype":"m.text"},"ts":1590529708000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"LeftOperatorDefinitions.","msgtype":"m.text"},"ts":1590529708000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"er JS's current operators*","msgtype":"m.text"},"ts":1590529738000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"},
{"content":{"body":"Sirisian|Work: An important bit is that the set of operations is not meant to be adjustable after-the-fact, I think. So the Vector author can't modify Number's overrides.","msgtype":"m.text"},"ts":1590531086000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"That makes sense if it's to control the not editing aspect. I'll read the spec closer.","msgtype":"m.text"},"ts":1590532892000,"senderName":"Sirisian|Work","senderId":"Sirisian|Work@irc"}
]