[
{"content":{"body":"What needs to happen to merge https://github.com/rwaldron/tc39-notes/pull/123 that fixes a missing slides link in the previous meeting's notes?","msgtype":"m.text"},"ts":1568908021000,"senderName":"jgi","senderId":"jgi@irc"},
{"content":{"body":"littledan: i forgot to ask since you were gone when it came up, wasn't there a decorators README for something that had decorators over **MANY** syntactic constructs?","msgtype":"m.text"},"ts":1568912510000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i don't think it was in the main proposal","msgtype":"m.text"},"ts":1568912518000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: https://github.com/tc39/proposal-decorators/blob/master/NEXTBUILTINS.md#applying-built-in-decorators-to-other-syntactic-forms","msgtype":"m.text"},"ts":1568914542000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"tyty","msgtype":"m.text"},"ts":1568914556000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"but why do they have to be a new dsl :(","msgtype":"m.text"},"ts":1568915781000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"we have this whole expressive language","msgtype":"m.text"},"ts":1568915787000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is there anything in js that can't be a reified value besides lexical scopes","msgtype":"m.text"},"ts":1568917528000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i mean... lexical scopes could be reimplemented using values","msgtype":"m.text"},"ts":1568917609000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"sure, but i mean in live js code","msgtype":"m.text"},"ts":1568917627000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"turing completeness kind of makes the question of if something can/cannot be done lean towards it can","msgtype":"m.text"},"ts":1568917630000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"like you can capture a variable scope with with(new Proxy())","msgtype":"m.text"},"ts":1568917637000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe private fields depending on what you think `#x` is","msgtype":"m.text"},"ts":1568917706000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"takes a long drag off his bubble pipe pondering `#x`","msgtype":"m.emote"},"ts":1568917767000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"if you view #x as a fancy identifier that jumps the usual MOP stuff, then it doesn't have to be a value in its own right","msgtype":"m.text"},"ts":1568917832000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but its still not reflectable because you can't proxy it so ðŸ¤·ðŸ»","msgtype":"m.text"},"ts":1568917848000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think it goes with lexical scopes","msgtype":"m.text"},"ts":1568917857000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I dislike viewing `#x` as its own identifier personally `x` under `#` makes my brain less angry","msgtype":"m.text"},"ts":1568917887000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"its cool how much of js is values you can play with","msgtype":"m.text"},"ts":1568917923000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`#x` can still be a value just not in the same space as other ones","msgtype":"m.text"},"ts":1568918175000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"well if you consider it a value","msgtype":"m.text"},"ts":1568918186000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in particular it having a value is useful for sharing (which isn't a thing right now)","msgtype":"m.text"},"ts":1568918190000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"some sort of fancy symbol or something","msgtype":"m.text"},"ts":1568918191000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"its still not reflectable","msgtype":"m.text"},"ts":1568918207000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"doesn't matter what it is, just not in the same value space so it cannot interact with things like strings","msgtype":"m.text"},"ts":1568918223000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"littledan: aren't almost all of these builtins possible to define in terms of @wrap?","msgtype":"m.text"},"ts":1568919901000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: ...no?","msgtype":"m.text"},"ts":1568919916000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"devsnek: I mean, tell me how and I'll be interested in simplifying the proposal","msgtype":"m.text"},"ts":1568919940000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"how is @register different from @wrap except for timing","msgtype":"m.text"},"ts":1568919955000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"@expose and @initialize could be @wrap too if there were better reflective properties for class fields","msgtype":"m.text"},"ts":1568920104000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"as a super contrived example, something like could exist and be modified by an @wrap `someClass[Symbol.fields]`","msgtype":"m.text"},"ts":1568920392000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(that codeblock was supposed to be after \"something like\")","msgtype":"m.text"},"ts":1568920420000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(not that i'm advocating for Symbol.fields, just pointing out that there are other ways to approach this)","msgtype":"m.text"},"ts":1568920445000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: tbh the main thing to resolve at this point is whether we do static decorators at all, see #277","msgtype":"m.text"},"ts":1568926815000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"devsnek: I encourage you to file an issue about these ideas for adjusting the details","msgtype":"m.text"},"ts":1568926830000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"We can probably get more engagement that way than we can in this channel","msgtype":"m.text"},"ts":1568926848000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"nice to hear alternatives to static are being discussed","msgtype":"m.text"},"ts":1568926905000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rbuckton seems to have captured pretty well what i was saying above","msgtype":"m.text"},"ts":1568926995000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: i wonder if you might feel differently if static decorators were named \"limited macros\"?","msgtype":"m.text"},"ts":1568927351000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: perhaps","msgtype":"m.text"},"ts":1568927392000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"when i think about these as fixed-form macros it is not an odd thing that they aren't arbitrary JS functions","msgtype":"m.text"},"ts":1568927411000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"indeed","msgtype":"m.text"},"ts":1568927417000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but then i have a bunch of other questions","msgtype":"m.text"},"ts":1568927422000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like why they have an understanding of runtime semantics","msgtype":"m.text"},"ts":1568927434000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"they're sort of in limbo at the moment","msgtype":"m.text"},"ts":1568927444000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what is their understanding of runtime semantics?","msgtype":"m.text"},"ts":1568927446000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"hooking structures at certain times, etc","msgtype":"m.text"},"ts":1568927463000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i guess you could say `@initialize` is a macro that explicitly looks for the syntax `a = b`","msgtype":"m.text"},"ts":1568927511000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like @initialize doing something per instance?","msgtype":"m.text"},"ts":1568927521000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but then what code does it return","msgtype":"m.text"},"ts":1568927525000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"generally \"macros\" operate on code, not runtime structures","msgtype":"m.text"},"ts":1568927541000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well, for @initialize, there is a code transform that accomplishes the same task","msgtype":"m.text"},"ts":1568927637000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1568927642000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"are you saying that that transform is non-local, so it's kinda weird?","msgtype":"m.text"},"ts":1568927649000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"like it somehow reaches into the constructor and insert some code","msgtype":"m.text"},"ts":1568927658000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1568927663000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"instead of doing it at the site where the \"macro\" is applied","msgtype":"m.text"},"ts":1568927664000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i see, that's fair","msgtype":"m.text"},"ts":1568927672000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i mean i guess you could turn `a = b` into `a = (() => { return modified_b })()`","msgtype":"m.text"},"ts":1568927684000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"entirely at the syntax level","msgtype":"m.text"},"ts":1568927699000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but then i'd ask where the ability to arbitrarily map other types of syntax is","msgtype":"m.text"},"ts":1568927787000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not just `a = b` or `class X {}`","msgtype":"m.text"},"ts":1568927799000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"perhaps the non-locality is a real impediment to the macro mental model but i need to think on it some more","msgtype":"m.text"},"ts":1568927802000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"right, that's why it's limited","msgtype":"m.text"},"ts":1568927823000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i've never expected decorators to be completely no-overhead","msgtype":"m.text"},"ts":1568927840000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"with the foundations in place more expressive macros could be built on top","msgtype":"m.text"},"ts":1568927850000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i always expected them to be some form of running code, and running code always has overhead","msgtype":"m.text"},"ts":1568927857000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: well i'd disagree that its foundations, the syntax would be all wrong","msgtype":"m.text"},"ts":1568927892000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"macros need to define their bounds, like how c uses line endings or rust uses () and {}","msgtype":"m.text"},"ts":1568927915000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's beyond running vs not running code","msgtype":"m.text"},"ts":1568927919000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the feedback has been it disables optimizations, not just that it might run some code","msgtype":"m.text"},"ts":1568927955000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"indeed","msgtype":"m.text"},"ts":1568927966000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"on a very different note: https://tc39.es/ecma262/#sec-arraysetlength","msgtype":"m.text"},"ts":1568928272000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this iterates from current length to new length and deletes everything","msgtype":"m.text"},"ts":1568928298000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"would it be an observable change to iterate over the actual keys of the object instead?","msgtype":"m.text"},"ts":1568928331000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i thought it was doing it the current way because [[Delete]] would bubble up to the prototype or something","msgtype":"m.text"},"ts":1568928355000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but it isn't","msgtype":"m.text"},"ts":1568928357000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"iterate over the actual keys?","msgtype":"m.text"},"ts":1568928439000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"most likely EnumerateObjectProperties","msgtype":"m.text"},"ts":1568928479000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the reason i bring this up is that something like `new Array(2 ** 32).length = 0` can be debilitating to engines without a lot of fancy optimizations","msgtype":"m.text"},"ts":1568928562000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm confused","msgtype":"m.text"},"ts":1568928636000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ArraySetLength is only on array exotic objects right","msgtype":"m.text"},"ts":1568928649000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1568928652000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so if it's not observable what is the debilitating thing to engines","msgtype":"m.text"},"ts":1568928657000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it has to iterate over 2 ** 32 elements","msgtype":"m.text"},"ts":1568928667000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but it can simply not do that because the delete isn't observable?","msgtype":"m.text"},"ts":1568928682000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"in fact if i plug that code into eshost it just freezes","msgtype":"m.text"},"ts":1568928713000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think because of xs and engine262","msgtype":"m.text"},"ts":1568928718000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: i'm not entirely sure what's observable at the moment","msgtype":"m.text"},"ts":1568928754000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"at first i thought it was for something like `Array.prototype[0] = 5; new Array(1).length = 0; Array.prototype[0] === undefined`","msgtype":"m.text"},"ts":1568928777000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but it doesn't do that","msgtype":"m.text"},"ts":1568928781000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"wow changing ArraySetLength to only delete defined properties doesn't cause any test262 failures","msgtype":"m.text"},"ts":1568930049000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"wow this isn't even observable if you use a proxy around an array","msgtype":"m.text"},"ts":1568930456000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: does that mean steps can be removed from it?","msgtype":"m.text"},"ts":1568934536000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: https://github.com/tc39/ecma262/pull/1702","msgtype":"m.text"},"ts":1568934558000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"well alrighty","msgtype":"m.text"},"ts":1568934579000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if it's not observable i don't understand the impetus","msgtype":"m.text"},"ts":1568934934000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"deleting all properties between newLen and oldLen is pretty clear, why spec an optimization into it?","msgtype":"m.text"},"ts":1568934981000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: i think its clearer, and it stops implementers from doing a silly algorithm by accident","msgtype":"m.text"},"ts":1568935143000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: the former is opinion i'll defer to the editor group, but the latter isn't a thing that ecma262 does","msgtype":"m.text"},"ts":1568935491000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the algorithms in the spec generally adhere to the spec's guarantees for their time complexities","msgtype":"m.text"},"ts":1568935556000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"e.g. all objects are eternal in the spec, but it'd be very silly to implement this","msgtype":"m.text"},"ts":1568935562000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"at the very least, it doesn't match reality","msgtype":"m.text"},"ts":1568935565000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if you don't think it makes it clearer, that would be a valid reason not to merge it","msgtype":"m.text"},"ts":1568935624000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i agree that the spec shouldn't be hyper optimized","msgtype":"m.text"},"ts":1568935635000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: \"algorithms in the spec generally adhere to the spec's guarantees for their time complexities\" is not the case; e.g. Maps are spec'd to iterate over lists","msgtype":"m.text"},"ts":1568937137000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"also those the algorithm in the spec has the same time complexity as the algorithm in your PR","msgtype":"m.text"},"ts":1568937160000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: that matches the spec's guarantee, but not implementations","msgtype":"m.text"},"ts":1568937170000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"fair enough for my pr, although i'm thinking mostly about arrays with holes","msgtype":"m.text"},"ts":1568937239000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"its very difficult to verify the spec when one of the tests tries to iterate over four million elements","msgtype":"m.text"},"ts":1568937257000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"billion*","msgtype":"m.text"},"ts":1568937296000,"senderName":"devsnek","senderId":"devsnek@irc"}
]