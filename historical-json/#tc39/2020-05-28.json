[
{"content":{"body":"jmdyck: you had a comment on https://github.com/tc39/ecma262/issues/828 today which disappeared","msgtype":"m.text"},"ts":1590638862000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"did you delete it on purpose, or is github broken?","msgtype":"m.text"},"ts":1590638870000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"on purpose.","msgtype":"m.text"},"ts":1590638892000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"meant to cancel, but comment-and-close button is in the same place","msgtype":"m.text"},"ts":1590638916000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yeah, that UI is not great","msgtype":"m.text"},"ts":1590638935000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek: hey, i don't know if you saw, but yulia and I asked for a slot on the agenda for iterator helpers next week","msgtype":"m.text"},"ts":1590681317000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"jorendorff: yeah yulia told me 👍🏻","msgtype":"m.text"},"ts":1590681335000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: ok, cool, I want to make sure there are no surprises for you in this presentation","msgtype":"m.text"},"ts":1590681351000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"the goal is to get committee approval for a specific specification approach","msgtype":"m.text"},"ts":1590681372000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"how did you end up feeling about","msgtype":"m.text"},"ts":1590681382000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://github.com/tc39/proposal-iterator-helpers/issues/86#issuecomment-632768983","msgtype":"m.text"},"ts":1590681383000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: I like it. I think the specification ends up shorter and cleaner that way","msgtype":"m.text"},"ts":1590681523000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"🎉","msgtype":"m.text"},"ts":1590681537000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"than if we make every one of these its own iterator \"class\" with three methods","msgtype":"m.text"},"ts":1590681538000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"it's not drastically shorter and cleaner but the difference is real, fewer steps, fewer spec sections","msgtype":"m.text"},"ts":1590681557000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"and it handles state cleanly","msgtype":"m.text"},"ts":1590681587000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: is it OK to say in a slide that the idea is to pick an approach now, and try for Stage 3 next time?","msgtype":"m.text"},"ts":1590681605000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"yeah definitely not time for stage 3 yet","msgtype":"m.text"},"ts":1590681627000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"👍 ok","msgtype":"m.text"},"ts":1590681685000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"devsnek: the champions will be ok with this?","msgtype":"m.text"},"ts":1590681770000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"they were fine with generators at least","msgtype":"m.text"},"ts":1590682180000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'll ping them","msgtype":"m.text"},"ts":1590682250000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"has anyone attempted to propose a non-propagating promise handler method? e.g. `Promise.prototype.handle(fn, errfn): void`","msgtype":"m.text"},"ts":1590693339000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i don't see any refs on a quick glance","msgtype":"m.text"},"ts":1590693348000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: What's the difference between `.handle()` and a `.then()` that you just ignore the return value of?","msgtype":"m.text"},"ts":1590693410000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"no return value, can't do the evil unhandledRejection dance that .then has, likely wouldn't swallow the error","msgtype":"m.text"},"ts":1590693450000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Ah, hm, kk.","msgtype":"m.text"},"ts":1590693479000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"https://twitter.com/bradleymeck/status/1266060854111408129","msgtype":"m.text"},"ts":1590693483000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"see thread leading up to that","msgtype":"m.text"},"ts":1590693497000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"basically unused return position of .then is a propagation point for unhandledRejection","msgtype":"m.text"},"ts":1590693525000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yup, got it.","msgtype":"m.text"},"ts":1590693575000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"bradleymeck: where do errors thrown in `fn` go","msgtype":"m.text"},"ts":1590693807000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i presume it just lets it propagate through, since it is on a new tick that would be to w/e the global exception handler is","msgtype":"m.text"},"ts":1590693903000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i certainly have written `p.catch(e => setTimeout(() => {throw e;}))` before and it would go through same path","msgtype":"m.text"},"ts":1590693943000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"right now i don't think there is a way to escape the promise swallowing state in raw JS itself?","msgtype":"m.text"},"ts":1590693960000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"so host hook","msgtype":"m.text"},"ts":1590693960000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not a new one","msgtype":"m.text"},"ts":1590693969000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: what would happen if the handle function threw","msgtype":"m.text"},"ts":1590693980000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"HostHandleErrors or whatever its called","msgtype":"m.text"},"ts":1590693982000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that'd still be an unhandled rejection","msgtype":"m.text"},"ts":1590693984000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: it isn't rejecting a promise, it is just throwing","msgtype":"m.text"},"ts":1590693998000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: right but sync or async","msgtype":"m.text"},"ts":1590694009000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"idk what you mean","msgtype":"m.text"},"ts":1590694015000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"oh the report errors hook was removed","msgtype":"m.text"},"ts":1590694019000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like how would it throw an exception","msgtype":"m.text"},"ts":1590694024000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it'd just be uncatchable until a global uncaught exception hook?","msgtype":"m.text"},"ts":1590694034000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"one that no JS env is required to provide?","msgtype":"m.text"},"ts":1590694045000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"sure","msgtype":"m.text"},"ts":1590694058000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that sounds pretty bad to me","msgtype":"m.text"},"ts":1590694126000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: i mean, you can always wrap stuff in try/catch","msgtype":"m.text"},"ts":1590694131000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"this is the same behavior as... many things","msgtype":"m.text"},"ts":1590694138000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: thinking a bit more, maybe something like `.then().catch().join()`","msgtype":"m.text"},"ts":1590694139000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not if it's not synchronous","msgtype":"m.text"},"ts":1590694141000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or `.end()` as a less biased name","msgtype":"m.text"},"ts":1590694145000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: it shouldn't be sync","msgtype":"m.text"},"ts":1590694152000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"(`.done` is the one with precedent, iirc)","msgtype":"m.text"},"ts":1590694154000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"promise state cannot be inspected sync","msgtype":"m.text"},"ts":1590694159000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: right but you can't wrap everything inside a function that can throw in try/catch","msgtype":"m.text"},"ts":1590694171000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: ?","msgtype":"m.text"},"ts":1590694185000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"and that boilerplate is not better than \"remembering to chain promises\"","msgtype":"m.text"},"ts":1590694186000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"what do you mean you can't put try/catch around a function","msgtype":"m.text"},"ts":1590694203000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"the `handleFn`, it could throw in default args, or inside a `catch` block","msgtype":"m.text"},"ts":1590694206000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you can put it around a sync function call","msgtype":"m.text"},"ts":1590694210000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you can't put it around `p.handle(handleFn)`","msgtype":"m.text"},"ts":1590694215000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that isn't any different from other promise handlers","msgtype":"m.text"},"ts":1590694234000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i think ljharb is saying","msgtype":"m.text"},"ts":1590694251000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the problem is missing exceptions","msgtype":"m.text"},"ts":1590694257000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the other promise handlers always produce a new promise, and thus an opportunity to handle the error","msgtype":"m.text"},"ts":1590694257000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so adding something that still misses exceptions","msgtype":"m.text"},"ts":1590694262000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and thus a possible unhandled rejection","msgtype":"m.text"},"ts":1590694262000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"doesn't fix the problem","msgtype":"m.text"},"ts":1590694265000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"adding a promise method that doesn't produce a new promise just solves one problem by creating a larger one","msgtype":"m.text"},"ts":1590694280000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: the person attaching the handler is responsible for the errors in their handler. I don't understand.","msgtype":"m.text"},"ts":1590694359000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"isn't that true at any level","msgtype":"m.text"},"ts":1590694375000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"thats the whole reason you end up with process.nextTick style rethrows in node","msgtype":"m.text"},"ts":1590694377000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"the person calling `.then` is responsible for handling the new promise that's produced. how is that different","msgtype":"m.text"},"ts":1590694407000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it isn't which is why I'm very confused","msgtype":"m.text"},"ts":1590694427000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"the behavior delegation is still on the person calling the method to handle","msgtype":"m.text"},"ts":1590694443000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"one you have to wrap the returned promise is you want to do things, the other you wrap the handler","msgtype":"m.text"},"ts":1590694459000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"oh sure. if a method returns a promise. then the caller is responsible for handling that promise's possible rejection","msgtype":"m.text"},"ts":1590694471000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if you wrap the handler you can 100% guarantee in both cases no \"unhandled\" events occur","msgtype":"m.text"},"ts":1590694476000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"the handler might produce a rejected promise tho","msgtype":"m.text"},"ts":1590694495000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"not if you wrap that handler","msgtype":"m.text"},"ts":1590694504000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"how do you \"wrap\" that in a way that's not the same problem you're trying to avoid?","msgtype":"m.text"},"ts":1590694512000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`new Promise((resolve) => handler())` wraps it, sure, but then you have another potential rejection to handle","msgtype":"m.text"},"ts":1590694538000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"p.then(v=> {try { return f(v) } catch (e) {} }, () => {})","msgtype":"m.text"},"ts":1590694543000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i mean... you *could* write that","msgtype":"m.text"},"ts":1590694559000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"how is that better than `p.then(f).catch()`?","msgtype":"m.text"},"ts":1590694564000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`.catch(() => {})`*","msgtype":"m.text"},"ts":1590694587000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"no need","msgtype":"m.text"},"ts":1590694591000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you can even do that as the async function, and prevent your consumer from having possible unhandled rejections","msgtype":"m.text"},"ts":1590694597000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: p sure `.then()` and `.catch()` work with no args","msgtype":"m.text"},"ts":1590694618000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i mean that snippet above wouldn't be, but a .handle or something seems to have less need for all of this wrangling of promise propagation of errors","msgtype":"m.text"},"ts":1590694622000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"you just asked how you could do it and i gave a way","msgtype":"m.text"},"ts":1590694636000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"right, i'm saying that it seems like it moves the need around at best","msgtype":"m.text"},"ts":1590694637000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like you had your `p.handle(handler)` above. how do you deal with the asynchronous rejection if `handler` produces a rejection?","msgtype":"m.text"},"ts":1590694686000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: if you leave out the argument to catch it defaults to `(v) => throw v`","msgtype":"m.text"},"ts":1590694688000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it creates fewer promises and doesn't have the error swallowing behavior since global hooks for errors do exist without the tick heuristic involved either. it is just a way of expressing intent","msgtype":"m.text"},"ts":1590694695000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"devsnek: oops, you're right","msgtype":"m.text"},"ts":1590694703000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: handler cannot produce a rejection, the function can throw","msgtype":"m.text"},"ts":1590694717000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"there is no place for the rejection to reject","msgtype":"m.text"},"ts":1590694727000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"ps, rofl, i typed `Promise.reject(3).` in the chrome console and immediately got an unhandled rejection warning","msgtype":"m.text"},"ts":1590694727000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"its not wrong","msgtype":"m.text"},"ts":1590694742000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"sure it is, those warnings aren't supposed to appear synchronously, nor before i hit enter","msgtype":"m.text"},"ts":1590694765000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if it's eagerly evaluating as i type for UX reasons it should be suppressing the warnings until i hit enter","msgtype":"m.text"},"ts":1590694780000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"bradleymeck: handler will be invoked asynchronously","msgtype":"m.text"},"ts":1590694792000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"unhandledRejection is a heuristic thing","msgtype":"m.text"},"ts":1590694794000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"right but until i hit enter in the repl the JS engine has no way to know what i'm typing","msgtype":"m.text"},"ts":1590694813000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: yes? like nextTick, setImmediate, setTimeout, a lot of events, etc.","msgtype":"m.text"},"ts":1590694825000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: if handler throws asynchronously, there is no way to catch that","msgtype":"m.text"},"ts":1590694829000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"bradleymeck: none of those are in JS.","msgtype":"m.text"},"ts":1590694836000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: correct? but you can't handle a dropped promise ref either","msgtype":"m.text"},"ts":1590694850000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"wait i'm confused now, which thread is that part of","msgtype":"m.text"},"ts":1590694862000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"indeed, i can't handle a rejected promise when the promise is no longer reachable","msgtype":"m.text"},"ts":1590694878000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'm only talking about a .handle","msgtype":"m.text"},"ts":1590694883000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"my argument is unhandled rejection is a different thing than unhandled exception","msgtype":"m.text"},"ts":1590694910000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"and you currently only have a way to propagate unhandled rejection in JS","msgtype":"m.text"},"ts":1590694925000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i agree with that, notably in node where i don't think an unhandled rejection should crash the process :-)","msgtype":"m.text"},"ts":1590694929000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"bradleymeck: in any case, i think anything that requires a change in behaviour","msgtype":"m.text"},"ts":1590695040000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is not great","msgtype":"m.text"},"ts":1590695046000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: change in behavior?","msgtype":"m.text"},"ts":1590695056000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"since the problem is forgetting to do exception handling","msgtype":"m.text"},"ts":1590695057000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the solution can't involve assuming people don't forget to do something","msgtype":"m.text"},"ts":1590695074000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't think we can state we can prevent forgetting exception handling","msgtype":"m.text"},"ts":1590695081000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i'm more interested in the fact that only providing a fulfillment handler even if the promise rejects is stuck in an odd place","msgtype":"m.text"},"ts":1590695145000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"honestly i think the solution will be","msgtype":"m.text"},"ts":1590695148000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"some form of async context thing","msgtype":"m.text"},"ts":1590695153000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"just wrap your app in an async context","msgtype":"m.text"},"ts":1590695160000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so async context is a bit different","msgtype":"m.text"},"ts":1590695194000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"one of the things it can do is tell where a rejected promise came from","msgtype":"m.text"},"ts":1590695215000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there is a different between unhandled rejection which by language default is a noop even if pretty much all hosts have moved it to an event","msgtype":"m.text"},"ts":1590695218000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"and unhandled exception which is the form that propagates as some form of error in all the environments","msgtype":"m.text"},"ts":1590695249000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1590695280000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so, even if you wrap things in some kind of context, you still want to disambiguate that","msgtype":"m.text"},"ts":1590695383000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"uncaught exceptions rip through async context","msgtype":"m.text"},"ts":1590695510000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well you can't make an uncaught exception once you are in promise hell","msgtype":"m.text"},"ts":1590695749000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"at least not in pure js","msgtype":"m.text"},"ts":1590695754000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i'm not sure what we're talking about anymore lol","msgtype":"m.text"},"ts":1590695789000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i was just saying you could do","msgtype":"m.text"},"ts":1590695793000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`new AsyncContext().onError(error handler)`","msgtype":"m.text"},"ts":1590695808000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm stating that if your async context is started up, ala something like otherPromise.then(doThingInAContext) doThingInAContext can never create a unhandled exception in JS","msgtype":"m.text"},"ts":1590695860000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"well the error gets handled in the async context's error handler","msgtype":"m.text"},"ts":1590695896000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which isn't a promise reaction","msgtype":"m.text"},"ts":1590695901000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so if that throws its not a rejection","msgtype":"m.text"},"ts":1590695912000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what do you mean","msgtype":"m.text"},"ts":1590695969000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"how does it get out of being in the promise handler position and thus a rejection position","msgtype":"m.text"},"ts":1590695981000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: the async context's error handler isn't a promise reaction","msgtype":"m.text"},"ts":1590696206000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"idk how else to say that","msgtype":"m.text"},"ts":1590696209000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"gut checkL can step 3.e.ii ever fail to define the property? https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor","msgtype":"m.text"},"ts":1590701412000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah, if the object is frozen","msgtype":"m.text"},"ts":1590702903000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or prevent-extension'd","msgtype":"m.text"},"ts":1590702921000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or sealed","msgtype":"m.text"},"ts":1590702935000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok, and in those cases would you expect the current behavior where it silently avoids the issue?","msgtype":"m.text"},"ts":1590702940000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"what  do you mean by silently avoids?","msgtype":"m.text"},"ts":1590702960000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i mean that `DefineOwnProperty` returns false when it fails","msgtype":"m.text"},"ts":1590702974000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so there's no abrupt completion for the ? to unwrap","msgtype":"m.text"},"ts":1590702981000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so, nothing happens","msgtype":"m.text"},"ts":1590702984000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ie the note on https://tc39.es/ecma262/#sec-createdataproperty","msgtype":"m.text"},"ts":1590703001000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(that's why CreateDataPropertyOrThrow exists)","msgtype":"m.text"},"ts":1590703008000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: it can still throw","msgtype":"m.text"},"ts":1590703366000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for example with proxies","msgtype":"m.text"},"ts":1590703409000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"people even use `Object.defineProperty(); return true;` instead of  `return Reflect.defineProperty()` because the former gives better error messages","msgtype":"m.text"},"ts":1590703483000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: sure but would OrdinarySetWithOwnDescriptor be called with a proxy?","msgtype":"m.text"},"ts":1590703591000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"not sure about proxies","msgtype":"m.text"},"ts":1590703652000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but its used on lots of exotic objects","msgtype":"m.text"},"ts":1590703657000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right but the spec for OrdinarySetWithOwnDescriptor right now says that trying to add a property to a frozen/sealed/non-extensible object won't throw, if i'm reading it right","msgtype":"m.text"},"ts":1590703699000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"for the objects defined in the spec i think that's true","msgtype":"m.text"},"ts":1590703745000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right but like, `Object.freeze(Array.prototype).foo = 3` throws in strict mode","msgtype":"m.text"},"ts":1590703812000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if you have a proxy which doesn't handle some trap, it just uses the underlying object's trap","msgtype":"m.text"},"ts":1590703871000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`(new Proxy({}, { get defineProperty(){ throw 'no'; } })).a = 0` throws `'no'` via OrdinarySetWithOwnDescriptor 3.d.iv","msgtype":"m.text"},"ts":1590703893000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sorry, v3.e.ii","msgtype":"m.text"},"ts":1590703914000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"*via 3.e.ii","msgtype":"m.text"},"ts":1590703924000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I am having difficulty with the typing today","msgtype":"m.text"},"ts":1590703929000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it throws in practice","msgtype":"m.text"},"ts":1590703929000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but in the spec text it does not throw","msgtype":"m.text"},"ts":1590703933000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the thing I wrote throws in the spec","msgtype":"m.text"},"ts":1590703942000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh wait","msgtype":"m.text"},"ts":1590703943000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"right, because `O.[[DefineOwnProperty]]` throws","msgtype":"m.text"},"ts":1590703950000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ohhh i see","msgtype":"m.text"},"ts":1590703954000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so even on an ordinary object, it'd throw in the frozen etc case","msgtype":"m.text"},"ts":1590703962000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but the note on https://tc39.es/ecma262/#sec-createdataproperty says \"If it does exist and is not configurable or if O is not extensible, [[DefineOwnProperty]] will return false.\"","msgtype":"m.text"},"ts":1590703976000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"which isn't an exception","msgtype":"m.text"},"ts":1590703982000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so how does my above example throw in strict mode?","msgtype":"m.text"},"ts":1590704000000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-putvalue","msgtype":"m.text"},"ts":1590704040000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"putvalue step 6.c","msgtype":"m.text"},"ts":1590704047000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"speaking of strict references","msgtype":"m.text"},"ts":1590704133000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ok, so does that mean that `O.[[DefineOwnProperty]]`` won't ever return false in the normal object case (because it won't get there if it would otherwise have), but if a proxy returns false, it'd be silently ignored?","msgtype":"m.text"},"ts":1590704135000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(in the line i'm talking about in OrdinarySetWithOwnDescriptor, i mean)","msgtype":"m.text"},"ts":1590704148000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it does get there?","msgtype":"m.text"},"ts":1590704165000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: what invokes PutValue in the normal frozen object case?","msgtype":"m.text"},"ts":1590704186000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"assignmentexpression evaluation","msgtype":"m.text"},"ts":1590704203000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation","msgtype":"m.text"},"ts":1590704207000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok, and PutValue invokes [[Set]]","msgtype":"m.text"},"ts":1590704238000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"did the [[Set]] op used to be called [[Put]]","msgtype":"m.text"},"ts":1590704269000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: but then how does assignment end up invoking OrdinarySetWithOwnDescriptor ?","msgtype":"m.text"},"ts":1590704292000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ah i see, nvm","msgtype":"m.text"},"ts":1590704314000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek yup","msgtype":"m.text"},"ts":1590704331000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"http://es5.github.io/#x8.12.5","msgtype":"m.text"},"ts":1590704340000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok so then the \"return `false`\" is intentional there, because other code checks it and throws everywhere it happens to be used","msgtype":"m.text"},"ts":1590704341000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"thanks for talking me through that","msgtype":"m.text"},"ts":1590704346000,"senderName":"ljharb","senderId":"ljharb@irc"}
]