[
{"content":{"body":"Is it okay to add additional internal slots after the object created?","msgtype":"m.text"},"ts":1594259388000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"no, don't do that","msgtype":"m.text"},"ts":1594259926000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"unless you really can't express it any other way, then maybe we can see if an exception makes sense, but per https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots:","msgtype":"m.text"},"ts":1594259973000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":" Unless explicitly specified otherwise, internal slots are allocated as part of the process of creating an object and may not be dynamically added to an object.","msgtype":"m.text"},"ts":1594259980000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: isn't this jobcallback stuff all happening inside of the steps for running a job","msgtype":"m.text"},"ts":1594315093000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why can't this be part of a host's implementation defined preparation/cleanup steps","msgtype":"m.text"},"ts":1594315111000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: it probably should be happening in the steps for running a job, per my last comment, but there still needs to be an extra hook to capture the incumbent to pass back","msgtype":"m.text"},"ts":1594315197000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ah i didn't see that, glad we came up with similar conclusions :D","msgtype":"m.text"},"ts":1594315237000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: i was trying to mirror the webidl semantics, but i don't think webidl conflates job and a callback function","msgtype":"m.text"},"ts":1594315240000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"err, i do think, rather","msgtype":"m.text"},"ts":1594315249000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so webidl always associates the incumbent per function object, which is what my current PR does. but that seems to be extra expressivity that's not needed","msgtype":"m.text"},"ts":1594315309000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"since we don't have any API that for example takes multiple callbacks at different points in time, possibly with different incumbents, then posts a single job that calls them","msgtype":"m.text"},"ts":1594315349000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"makes sense","msgtype":"m.text"},"ts":1594315382000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this reminds me that i need to review your other job pr","msgtype":"m.text"},"ts":1594315387000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: interestingly, domenic's batching case suggests a per-function approach is perhaps desirable","msgtype":"m.text"},"ts":1594320760000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"what uses batching","msgtype":"m.text"},"ts":1594320777000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: since you were thinking per-job, do you have concerns with the extra expressivity?","msgtype":"m.text"},"ts":1594320792000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i don't think anything does currently","msgtype":"m.text"},"ts":1594320797000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"though, if the extra machinery isn't too much complexity, i don't see why we wouldn't want the extra expressivity","msgtype":"m.text"},"ts":1594320863000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"this whole thing feels weird","msgtype":"m.text"},"ts":1594320876000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"sort of like an implementation detail leak about the job","msgtype":"m.text"},"ts":1594320882000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't share that view, JS is embedded","msgtype":"m.text"},"ts":1594320954000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i guess the generalization is \"whenever a job calls a function\"?","msgtype":"m.text"},"ts":1594320959000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"stuff in jobs already cross that boundary","msgtype":"m.text"},"ts":1594320960000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1594320962000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the generalization is \"job callbacks\"","msgtype":"m.text"},"ts":1594320969000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"those need additional state in some embedders","msgtype":"m.text"},"ts":1594320994000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"`HostCall(job record, f, thisvalue, args)`","msgtype":"m.text"},"ts":1594321021000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and put some HostDefined on job records","msgtype":"m.text"},"ts":1594321030000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes, something like that","msgtype":"m.text"},"ts":1594321050000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"though not sure if it needs the job record passed back in","msgtype":"m.text"},"ts":1594321056000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"sure, jobrecord.[[HostDefined]] or whatever","msgtype":"m.text"},"ts":1594321070000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: if you have better names than emplace I really have no strong desires as a base except that the name shouldn't reflect an operation it might not do","msgtype":"m.text"},"ts":1594322578000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i'll definitely think about an alternative","msgtype":"m.text"},"ts":1594322631000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i realize it's not quite as reasonable to object to a name without providing at least one alternative :-)","msgtype":"m.text"},"ts":1594322649000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"bradleymeck: was \"one callback, but with arguments that tells you if it's an update or an insert\" also blocked?","msgtype":"m.text"},"ts":1594322682000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1594322692000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"what was the reasoning?","msgtype":"m.text"},"ts":1594322697000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it devolves to just being a ternary with and update and insert function generally","msgtype":"m.text"},"ts":1594322706000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"no real reason to force it to be a single function at that point","msgtype":"m.text"},"ts":1594322718000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i'd say the reason is \"because some folks objected to passing two callbacks\"","msgtype":"m.text"},"ts":1594322743000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"function handler(isUpdate, existingIfIsAnUpdate) { return isUpdate ? update(existingIfIsAnUpdate) : defaultValue() }","msgtype":"m.text"},"ts":1594322778000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"ljharb: i don't see any major problem with an options bag","msgtype":"m.text"},"ts":1594322801000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"in a comment we even had someone show an example of a reciever storing data","msgtype":"m.text"},"ts":1594322827000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"handler receiver","msgtype":"m.text"},"ts":1594322836000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"oof","msgtype":"m.text"},"ts":1594322856000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i can understand the complaint about not including naming in the function params, and that double purposing the handler is weird","msgtype":"m.text"},"ts":1594322876000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"fwiw, the mess that is \"a proxy handler\" would make me fight pretty hard to eagerly extract the functions from the object","msgtype":"m.text"},"ts":1594322877000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: implementations strongly disagree XD","msgtype":"m.text"},"ts":1594322894000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"on which part","msgtype":"m.text"},"ts":1594322903000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(also i don't think the callbacks should be called with a receiver at all)","msgtype":"m.text"},"ts":1594322917000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: collection normalization wanted to do that, but impl feedback was that it *must* match proxy handler behavior to ease impl and be more consistent","msgtype":"m.text"},"ts":1594322926000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"it's conceptually an options bag, not a handler object","msgtype":"m.text"},"ts":1594322928000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"um","msgtype":"m.text"},"ts":1594322934000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: regardless impls do not agree and I had to change a previous proposal because of it","msgtype":"m.text"},"ts":1594322950000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"that would be inconsistent with the way options bags are used everywhere else in the ecosystem","msgtype":"m.text"},"ts":1594322953000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"can you remind me who had that objection?","msgtype":"m.text"},"ts":1594322960000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"digs about","msgtype":"m.emote"},"ts":1594322969000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"because the way proxy handlers work is bizarre and confusing and unique","msgtype":"m.text"},"ts":1594322970000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you could dig through the notes too :P","msgtype":"m.text"},"ts":1594322997000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"https://github.com/tc39/proposal-collection-normalization/issues/15#issuecomment-515337415 is in there","msgtype":"m.text"},"ts":1594323002000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"notes would be around that timeframe","msgtype":"m.text"},"ts":1594323015000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"totally fair, if it's in the notes i'll look","msgtype":"m.text"},"ts":1594323033000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if it's just that one github comment tho i'd want to explore it more. in the case of collection normalization, that involves the internal hooks of maps and sets; for upsert i just don't buy a perf argument","msgtype":"m.text"},"ts":1594323119000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"also, the precedent we now have is that `resolve` is looked up on `Promise` eagerly","msgtype":"m.text"},"ts":1594323128000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: it was in committee don't remember if it was in the presentation or hallway","msgtype":"m.text"},"ts":1594323167000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"ljharb: upsert is not just perf","msgtype":"m.text"},"ts":1594323179000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yeah i'm not finding anything in the notes","msgtype":"m.text"},"ts":1594323190000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"upsert is mostly about fixing the (now fixed) bugs we had to deal with when making a complex multi-level cache for work","msgtype":"m.text"},"ts":1594323201000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"it took years to completely find them all","msgtype":"m.text"},"ts":1594323212000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"and most had to deal w/ all the variation of .has/.get/.set workflows to try to insert or update a value","msgtype":"m.text"},"ts":1594323231000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"what i mean is, i don't understand how the \"similarity to proxy handlers\" argument applies when that's the only place in the language we dynamically look up values on an object later, and when in all the Promise combinators, we look up the functions eagerly, on purpose","msgtype":"m.text"},"ts":1594323232000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and that Promise change was made *because* of implementor perf arguments","msgtype":"m.text"},"ts":1594323245000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: talk to implementors?","msgtype":"m.text"},"ts":1594323250000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"happy to but it's not in the notes, so that one github comment's all i've got","msgtype":"m.text"},"ts":1594323259000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(or rather i can't find it in the notes)","msgtype":"m.text"},"ts":1594323300000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: just ping rbuckton and maya directly?","msgtype":"m.text"},"ts":1594323331000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"they would know the source of the underlying reasoning perhaps more than I","msgtype":"m.text"},"ts":1594323353000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i'm just reacting","msgtype":"m.text"},"ts":1594323360000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"ping rbuckton :-) any context here? i'll ping maya later","msgtype":"m.text"},"ts":1594323387000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: since these are not persistent and are always looked up since the handler is immediately called does it even have meaning to eagerly read the values?","msgtype":"m.text"},"ts":1594324964000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"we don't keep a ref to the options bag after the return value","msgtype":"m.text"},"ts":1594324982000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"it determines observability","msgtype":"m.text"},"ts":1594325025000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ie if it’s a getter, then i could determine if the map’s `has` had been checked first or not","msgtype":"m.text"},"ts":1594325045000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"oh also that raises another question; are these looking up `.has` and `.get` and `.set`, or are they using the internal operations?","msgtype":"m.text"},"ts":1594325062000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: no .has delegation","msgtype":"m.text"},"ts":1594325815000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"absolutely not","msgtype":"m.text"},"ts":1594325818000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"great","msgtype":"m.text"},"ts":1594325824000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"no get or set either, i hope?","msgtype":"m.text"},"ts":1594325835000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"correct","msgtype":"m.text"},"ts":1594325838000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"reentrancy concern nailed that","msgtype":"m.text"},"ts":1594325844000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yay ty","msgtype":"m.text"},"ts":1594325844000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"otherwise we did have subclassing concerns if we didn't delegate","msgtype":"m.text"},"ts":1594325858000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"but with reentrancy delegating would be really awkward","msgtype":"m.text"},"ts":1594325870000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"also other langs don't do that","msgtype":"m.text"},"ts":1594325878000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"right; i’m personally already convinced that the normalization approach is the only viable path for JS to making subclassing easier without polluting methods with reentrancy and observable lookups","msgtype":"m.text"},"ts":1594325905000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"how long until we define that ~empty~ can coerce into a list","msgtype":"m.text"},"ts":1594326807000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"never 😠","msgtype":"m.text"},"ts":1594326882000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"it should coerce into a singleton list with `\"Empty\"`","msgtype":"m.text"},"ts":1594327014000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: which is == 0 I presume","msgtype":"m.text"},"ts":1594327677000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i like that, yes","msgtype":"m.text"},"ts":1594327695000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"😂","msgtype":"m.text"},"ts":1594327762000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"presumably also, ~empty~ is neither truthy nor falsy","msgtype":"m.text"},"ts":1594327769000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`!~empty~` produces `document.all`","msgtype":"m.text"},"ts":1594327788000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and `+~empty~` ofc produces `NaN`","msgtype":"m.text"},"ts":1594327806000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"no, those are terrible ideas","msgtype":"m.text"},"ts":1594327825000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"maybe we need a new... `void` value to represent a reified empty","msgtype":"m.text"},"ts":1594327906000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"and `anything in void` would ofc be false","msgtype":"m.text"},"ts":1594328019000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"void in void","msgtype":"m.text"},"ts":1594329658000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"touché","msgtype":"m.text"},"ts":1594329965000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"v8 has exactly what we need \"the hole\"","msgtype":"m.text"},"ts":1594330345000,"senderName":"devsnek","senderId":"devsnek@irc"}
]