[
{"content":{"body":"https://tc39.es/ecma262/#sec-numberbitwiseop seems a bit circular","msgtype":"m.text"},"ts":1576262438000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"step 3, i mean","msgtype":"m.text"},"ts":1576262442000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"& is specified in terms of Number::bitwiseAND which is specified in terms of &","msgtype":"m.text"},"ts":1576262536000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"\"applying the bitwise operator op\" tho isn't the same as how `&` is specified, is it?","msgtype":"m.text"},"ts":1576262579000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"What does that phrase mean?","msgtype":"m.text"},"ts":1576262596000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"perhaps we're missing an explicit definition for it - but the intention i think is to do math","msgtype":"m.text"},"ts":1576262629000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah, i think that has to be the intention,","msgtype":"m.text"},"ts":1576262657000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"ie if the op is &, it should do what previous editions did here: http://www.ecma-international.org/ecma-262/#sec-unsigned-right-shift-operator","msgtype":"m.text"},"ts":1576262702000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"where it just says \"compute rnum & 0x1F\"","msgtype":"m.text"},"ts":1576262713000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so maybe that detailed info for each op that's in steps 7 and 8 of the last edition needs to be restored somehow?","msgtype":"m.text"},"ts":1576262744000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"wow, here's what the previous edition says about bitwise AND: http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation","msgtype":"m.text"},"ts":1576262791000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"right, that's probably where the bigint proposal got the prose from","msgtype":"m.text"},"ts":1576262831000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"basically the same thing only instead of \"op\" it's called \"@\"","msgtype":"m.text"},"ts":1576262833000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"love it","msgtype":"m.text"},"ts":1576262835000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"sounds to me like not a new bug, if it's a bug :-)","msgtype":"m.text"},"ts":1576262853000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"no indeed :)","msgtype":"m.text"},"ts":1576262866000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"but if you want to make a PR that makes that clearer that'd be fine with me","msgtype":"m.text"},"ts":1576262874000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"right shift has a clearer definition in old editions than && does","msgtype":"m.text"},"ts":1576262901000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"* &","msgtype":"m.text"},"ts":1576262903000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"hmm. BigInt::bitwiseAND is specified in more detail. Although ... too much detail for my brain","msgtype":"m.text"},"ts":1576262944000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"I don't think I should work on this, it probably isn't bothering anyone else","msgtype":"m.text"},"ts":1576262965000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"lol k","msgtype":"m.text"},"ts":1576262980000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"thanks for bringing it up!","msgtype":"m.text"},"ts":1576262985000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-jobs-and-job-queues states that Jobs can be interleaved, but it does not clarify if that also includes preemption","msgtype":"m.text"},"ts":1576272072000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"mmmm","msgtype":"m.text"},"ts":1576272075000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"jobs must be dispatched in the correct order","msgtype":"m.text"},"ts":1576272139000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i guess it depends on your definition of \"dispatched\"","msgtype":"m.text"},"ts":1576272157000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yea, but in RunJobs the host can determine the order","msgtype":"m.text"},"ts":1576272178000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i don't see anything that implies a job can be paused entirely","msgtype":"m.text"},"ts":1576272188000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"but that word is \"interleaved\"... oddly placed","msgtype":"m.text"},"ts":1576272201000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1576272232000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`No other Job may be initiated until the currently running Job completes`","msgtype":"m.text"},"ts":1576272233000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that answers my question at least","msgtype":"m.text"},"ts":1576272275000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes, \"completes\" i assume means all the spec work / eval runs to completion as in end of source text","msgtype":"m.text"},"ts":1576272279000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"at the very least, this means the require(esm) thing is against the rules","msgtype":"m.text"},"ts":1576272350000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yea, reading the other things like await they never affect jobs, only the execution context stack","msgtype":"m.text"},"ts":1576272377000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"maybe we should explicitly state preemption of the entire job is not allowed","msgtype":"m.text"},"ts":1576272415000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"interleaved makes it a bit confusing","msgtype":"m.text"},"ts":1576272426000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"PerformEval is a trip","msgtype":"m.text"},"ts":1576272659000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"step 18 of PerformEval annoys me","msgtype":"m.text"},"ts":1576272749000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i should open a pr","msgtype":"m.text"},"ts":1576272751000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why does RunJobs offset execution cleanup","msgtype":"m.text"},"ts":1576273125000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"execution contexts are cleaned up in the next iteration","msgtype":"m.text"},"ts":1576273138000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is this just for compat with InitializeHostDefinedRealm","msgtype":"m.text"},"ts":1576273165000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: isn't the Function null for `var`?","msgtype":"m.text"},"ts":1576273209000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"hmm?","msgtype":"m.text"},"ts":1576273221000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"> step 18 of PerformEval annoys me","msgtype":"m.text"},"ts":1576273230000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1576273240000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"18. Set evalContext's Function to null.","msgtype":"m.text"},"ts":1576273253000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"uhhh","msgtype":"m.text"},"ts":1576273256000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for one of the two eval call types, eval's frame is missing that eval was called","msgtype":"m.text"},"ts":1576273268000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it doesn't matter that much except for when building up stack traces","msgtype":"m.text"},"ts":1576273284000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think its for direct calls","msgtype":"m.text"},"ts":1576273359000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah it is","msgtype":"m.text"},"ts":1576273411000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"In my limited use of `BigInt` in Chrome and Firefox, I've found myself repeatedly writing Math.abs, Math.min, and Math.max equivalents. Is there any proposal to add something like BigInt.abs, BigInt.max, etc?","msgtype":"m.text"},"ts":1576274702000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"one of the things on my todo list is changing those math methods to accept bigints","msgtype":"m.text"},"ts":1576274730000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"If, say, Math.max were changed to accept BigInt values, what happens if you mix Number and BigInt arguments?","msgtype":"m.text"},"ts":1576274866000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"it would throw","msgtype":"m.text"},"ts":1576274875000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually","msgtype":"m.text"},"ts":1576274888000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"relational comparison works on numbers and bigints","msgtype":"m.text"},"ts":1576274898000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"But what should the return type be then?","msgtype":"m.text"},"ts":1576274916000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"Math.max and Math.min could work on inputs containing both","msgtype":"m.text"},"ts":1576274916000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Number|BigInt","msgtype":"m.text"},"ts":1576274924000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well really","msgtype":"m.text"},"ts":1576274942000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"a union based on the types you pass in","msgtype":"m.text"},"ts":1576274949000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"So `Math.max(3, 5n)` would return `5n`, but `Math.max(5, 3n)` would return `5`?","msgtype":"m.text"},"ts":1576274968000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"That seems like it could cause problems","msgtype":"m.text"},"ts":1576274973000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"🤷🏻","msgtype":"m.text"},"ts":1576274975000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it doesn't exist yet","msgtype":"m.text"},"ts":1576274982000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lots of discussions to be had","msgtype":"m.text"},"ts":1576274985000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"making math methods work with bigint is something on my list","msgtype":"m.text"},"ts":1576274991000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i might actually draw something up for february","msgtype":"m.text"},"ts":1576274991000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'd be happy to work with you on that","msgtype":"m.text"},"ts":1576275012000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"cool, i'll ping you in the next few weeks","msgtype":"m.text"},"ts":1576275022000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"🎉","msgtype":"m.text"},"ts":1576275025000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think they should throw if types are mixed; yes, relational ops work on mixed inputs, but their return type isn't numeric; all the ops with numeric return types throw on mixing partially to avoid answering this question.","msgtype":"m.text"},"ts":1576275076000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"^ that does seem to be the precedent, I agree","msgtype":"m.text"},"ts":1576275096000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i think there's a few cases where we can hit a more useful bar than that - but yes, that is the precedent","msgtype":"m.text"},"ts":1576275140000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"in general, anything where you'd lose information when using a Number above MAX_SAFE_INT is something that throws - not just mixing types","msgtype":"m.text"},"ts":1576275162000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"relational comparison isn't a place like that, so it doesn't throw","msgtype":"m.text"},"ts":1576275177000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Wouldn't it be less error-prone and more readable to just add `BigInt.abs`, `BigInt.max`, etc. static methods?","msgtype":"m.text"},"ts":1576275237000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"maybe(tm)","msgtype":"m.text"},"ts":1576275256000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'd rather use the existing methods","msgtype":"m.text"},"ts":1576275262000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's cleaner imo","msgtype":"m.text"},"ts":1576275265000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there's a lot of bikeshedding to be done though","msgtype":"m.text"},"ts":1576275270000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Moving away from the static methods entirely, here is an alternative idea for BigInt absolute value: https://gist.github.com/metanomial/18695b95517d0b78bb882ffe78ce16dd?ts=4","msgtype":"m.text"},"ts":1576275293000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"if math didn't already exist i'd be all over that","msgtype":"m.text"},"ts":1576275337000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Why not just leave Math to Number types?","msgtype":"m.text"},"ts":1576275390000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"metanomial: that's something we'll have to consider, but it's much nicer to have \"math\" methods be able to do *math* with all the number types :-)","msgtype":"m.text"},"ts":1576275411000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"because math isn't about number, math is a pure thing","msgtype":"m.text"},"ts":1576275419000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"well it was pure until -0 came around","msgtype":"m.text"},"ts":1576275446000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"A bunch of the math stuff doesn't make sense for bigints","msgtype":"m.text"},"ts":1576275476000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"cos, etc","msgtype":"m.text"},"ts":1576275479000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"also true","msgtype":"m.text"},"ts":1576275512000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(or at least acos)","msgtype":"m.text"},"ts":1576275513000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Math as a general purpose set of methods would probably be more useful if there were well known symbols for describing \"number\" types and operator overloading","msgtype":"m.text"},"ts":1576275514000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"and those would continue to throw","msgtype":"m.text"},"ts":1576275517000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the entire definition of math rn is pretty scary","msgtype":"m.text"},"ts":1576275566000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but yeah basically the options are something like 1) make some of the math methods support bigints where it's intuitive, 2) keep Math for Number, and add BigInt static methods, setting a precedent for BigDecimal as well, 3) add bigint and number prototype methods and effectively deprecate the math methods (seems weird to me), 4) do nothing","msgtype":"m.text"},"ts":1576275572000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`Each of the following Math object functions applies the ToNumber abstract operation to each of its arguments (in left-to-right order if there is more than one). If ToNumber returns an abrupt completion, that Completion Record is immediately returned.`","msgtype":"m.text"},"ts":1576275591000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"fun prose","msgtype":"m.text"},"ts":1576275598000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Opt 4 is a terrible option. I'm going to be writing BigInt utilities to the end of time","msgtype":"m.text"},"ts":1576275615000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1576275627000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"metanomial: i agree","msgtype":"m.text"},"ts":1576275633000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"whatever the case","msgtype":"m.text"},"ts":1576275637000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"we should definitely support clz32","msgtype":"m.text"},"ts":1576275651000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":":D","msgtype":"m.text"},"ts":1576275653000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think 2 may be the most reasonable given the lack of \"integer math\" ops to this point (like Bakkot was saying)","msgtype":"m.text"},"ts":1576275865000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"1 would probably be fine with ample throw cases though.","msgtype":"m.text"},"ts":1576275880000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: right, i think 1 or 2 are the two options to suggest, once the committee agrees on the problem :-)","msgtype":"m.text"},"ts":1576275913000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rkirsling: i have a preference for 1, because it just doesn't make any sense to me that \"Math\" doesn't work on bigints","msgtype":"m.text"},"ts":1576275913000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rkirsling: but maybe after i audit all the math methods and come up with a table, i'll change my mind, i dunno","msgtype":"m.text"},"ts":1576275929000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'm also a fan of 1","msgtype":"m.text"},"ts":1576275941000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah I'm not opposed","msgtype":"m.text"},"ts":1576275948000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"we definitely need some solution","msgtype":"m.text"},"ts":1576275969000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"and something that allows a path for bigdec would be good (whatever that means)","msgtype":"m.text"},"ts":1576276000000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Math.clz32(1f)","msgtype":"m.text"},"ts":1576276011000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or is that 1d","msgtype":"m.text"},"ts":1576276019000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"wow I did not realize that already existed","msgtype":"m.text"},"ts":1576276072000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: right, potential conflicts with BigDecimal would be unacceptable","msgtype":"m.text"},"ts":1576276085000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I feel like opt 1 could lead to obscure bugs. You could have an instance where a collection of `{Number|BigInt}` has been getting passed to Math.xyz successfully for a while, because the collection by serendipity was all of one type. But then after an unrelated code change, the collection suddenly starts holding mixed types and `Math.xyz` throws","msgtype":"m.text"},"ts":1576276354000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"errors about it.","msgtype":"m.text"},"ts":1576276355000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"metanomial: the collection changing type unexpectedly would break every option","msgtype":"m.text"},"ts":1576276414000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"But it wouldn't *change* type. The developer could have documented that the collection was `{Number|BigInt}`, and have been unsafely passing the collection through `Math.xyz`. Then at a later time, a distance change in code causes the bug to come to a head.","msgtype":"m.text"},"ts":1576276544000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"metanomial: right but that's just a bug","msgtype":"m.text"},"ts":1576276567000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"metanomial: it could be documented as just Number and still suddenly start receiving a bigint","msgtype":"m.text"},"ts":1576276583000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"My point is that it could become difficult to debug. `Math.xyz` would accept `{Number|BigInt}`, and the collection would be of type `{Number|BigInt}`, and yet it would be throwing an error.","msgtype":"m.text"},"ts":1576276661000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"i'm confused about what this bug is","msgtype":"m.text"},"ts":1576276700000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but this doesn't sound like the fault of Math.xyz's accepted types","msgtype":"m.text"},"ts":1576276710000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"given the precedent for mixing to throw, I don't think it'd be very easy to have such a collection without a lot of conscious guarding","msgtype":"m.text"},"ts":1576276712000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i'm not clear on why it's difficult to debug","msgtype":"m.text"},"ts":1576276728000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'll write up a quick example","msgtype":"m.text"},"ts":1576276764000,"senderName":"metanomial","senderId":"metanomial@irc"},
{"content":{"body":"you'd get an exception that you mixed a bigint and a number, and you'd trace it back to where some caller was assuming it wouldn't be mixed","msgtype":"m.text"},"ts":1576276766000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"thanks!","msgtype":"m.text"},"ts":1576276854000,"senderName":"ljharb","senderId":"ljharb@irc"}
]