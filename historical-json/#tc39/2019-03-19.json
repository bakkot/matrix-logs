[
{"content":{"body":"ljharb: https://docs.google.com/document/d/101VnCaQaheEwSXQ_-eSAKpkutnAbDjS9T5TS2gF5zLQ/edit","msgtype":"m.text"},"ts":1553010573000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"mathiasbynens: guess you shared that with wycats already?","msgtype":"m.text"},"ts":1553010730000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: i believe gsathya did, yeah","msgtype":"m.text"},"ts":1553010792000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"mathiasbynens: that just talks about conceptually; is it quantified anywhere?","msgtype":"m.text"},"ts":1553011075000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like let’s say my many-10Ks class-based react component codebase has a decorator on every one. How much startup cost increase are we talking? 1ms, 1s, 1m?","msgtype":"m.text"},"ts":1553011139000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"mathiasbynens: my question is, at the cost of adding all that weird syntax/behaviour in the new proposal, is the entire feature worth it","msgtype":"m.text"},"ts":1553011216000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"its basically adding a new DSL to the language","msgtype":"m.text"},"ts":1553011231000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: the whole point of the doc is that you can't answer this question, even when given code which you can statically analyze","msgtype":"m.text"},"ts":1553013783000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"devsnek: that's a good question, and one we should be asking ourselves more often","msgtype":"m.text"},"ts":1553013826000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"any solution that has to work with function hoisting is probably going to be meh","msgtype":"m.text"},"ts":1553013860000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'd assume \"make decorated functions unhoisted\" has been proposed at some point","msgtype":"m.text"},"ts":1553013873000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"mathiasbynens: ok so it could be negligible and this could all be fud?","msgtype":"m.text"},"ts":1553014097000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"while it could also be the worst case, but nobody knows how bad that might be","msgtype":"m.text"},"ts":1553014130000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if the only way to answer it is an implementation, isn't that the purpose of stage 3?","msgtype":"m.text"},"ts":1553014213000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: i'm saying it depends on what the decorator does exactly, which you cannot statically figure oout","msgtype":"m.text"},"ts":1553014321000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"imho it's not our job as implementers to do busywork for TC39. multiple implementers voiced concerns re: start-up performance AND implementation complexity, so the suggestion to \"try and implement it to see how bad it really is\" feels a little detached from reality","msgtype":"m.text"},"ts":1553014438000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"that's fair.","msgtype":"m.text"},"ts":1553014534000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"altho the complexity grows directly out of all the use cases, so i'm not sure that's avoidable, altho the performance part may be.","msgtype":"m.text"},"ts":1553014562000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yep, it's a trade-off for sure","msgtype":"m.text"},"ts":1553014801000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"we are not required to support all use cases; as such it's totally avoidable by saying \"that use case requires too much implementation complexity and we aren't going to support it\"","msgtype":"m.text"},"ts":1553016104000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"+1 Bakkot","msgtype":"m.text"},"ts":1553016227000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: that is true; i should have said, not sure that's avoidable without cutting off a bunch of use cases","msgtype":"m.text"},"ts":1553017088000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but also, many of the use cases not being met may cause objections to advancement.","msgtype":"m.text"},"ts":1553017107000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"What if top-level await were synchronous if an entire module subgraph is deterministically synchronous (does not contain any syntactic top-level await)? https://github.com/tc39/proposal-top-level-await/pull/61","msgtype":"m.text"},"ts":1553020165000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"so it's not \"Zalgo\" (like #49) but it's also not creating lots of trivial Promises and depending on queue flushes to work through them in time (like #51)","msgtype":"m.text"},"ts":1553020204000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: as you know I think we'll want to do queue flushes on the web anyway, so as long as that's preserved I guess whatever is fine for the top-level await spec.","msgtype":"m.text"},"ts":1553020350000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: is that a cross-browser pos? It makes sense to me btw, but wonder how many folks considered the tradeoffs","msgtype":"m.text"},"ts":1553022333000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: Yeah, this would be fine in conjunction with that","msgtype":"m.text"},"ts":1553023848000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"Domenic: I don't think the difference between #61 and #51 would be observable in this case","msgtype":"m.text"},"ts":1553023877000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I think it'd be pretty weird to have the Promises set up in one layer (JS), and synchronization guarantees made in another layer (HTML for its microtask checkpoint), unless we have a very explicit contract that it's going to do exactly that. In this case, such a construction feels like overkill. What we want is for synchronous subgraphs to run in order--microtask checkpoints are one way of doing that, and just not adding in all","msgtype":"m.text"},"ts":1553024508000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"these promises on synchronous subgraphs is another way (and perfectly compatible with adding other, independently motivated microtask checkpoints)","msgtype":"m.text"},"ts":1553024509000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"anyway, you could think of it as an editorial change, if the web will end up doing these microtask checkpoints.","msgtype":"m.text"},"ts":1553024537000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: so an argument for interleaving tasks as well is that module loading should still give opportunities for hitting 60fps","msgtype":"m.text"},"ts":1553024880000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Unfortunately, we heard from nyaxt on html#4400 that it'd be hard to yield to the event loop after each module load","msgtype":"m.text"},"ts":1553024918000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"This does seem like it’d benefit from involving more people","msgtype":"m.text"},"ts":1553024934000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think yielding optionally, driven by the UA, seems like a good proposal. However, it wouldn't address the specific synchronization need we have here. I think it'd be best to decouple these","msgtype":"m.text"},"ts":1553024982000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"annevk: Is there someone from Mozilla who works on event loop kind of things who we could bring in?","msgtype":"m.text"},"ts":1553025006000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: smaug and dbaron I suppose","msgtype":"m.text"},"ts":1553025073000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"littledan: rniwa from Apple too?","msgtype":"m.text"},"ts":1553025106000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"cc'd on html#4400","msgtype":"m.text"},"ts":1553025292000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I've been wondering about something crazier as far as being incremental: Should we let code start executing when the module graph is not all fetched and parsed?","msgtype":"m.text"},"ts":1553025326000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"It would complicate things, but it could improve parallelism. On the other hand, you could accomplish the same though manual code splitting instead and give stronger priority hints to the browser that way","msgtype":"m.text"},"ts":1553025405000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"grammar question: is `({ ...{a} } = {})` legal?","msgtype":"m.text"},"ts":1553025970000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"note that this is assignment, not declaration","msgtype":"m.text"},"ts":1553025977000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh wait no","msgtype":"m.text"},"ts":1553025996000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"there's an early error for it, ok","msgtype":"m.text"},"ts":1553026007000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: i wouldn't expect spread without an identifier to be legal there","msgtype":"m.text"},"ts":1553026011000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or rest, rather","msgtype":"m.text"},"ts":1553026018000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yeah, it has to be an identifier, not an object or array. Did not know that.","msgtype":"m.text"},"ts":1553026055000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lol, but `({ ...(a) } = {})` is legal; that's fun","msgtype":"m.text"},"ts":1553026162000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that must bind to `a`?","msgtype":"m.text"},"ts":1553026196000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"interesting, seems like a weird omission to allow parens there","msgtype":"m.text"},"ts":1553026212000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"since `var (a) = 3` doesn't work","msgtype":"m.text"},"ts":1553026220000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`(a) = 3` does","msgtype":"m.text"},"ts":1553026234000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh right","msgtype":"m.text"},"ts":1553026239000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ok well then it's horrifically consistent","msgtype":"m.text"},"ts":1553026246000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yay","msgtype":"m.text"},"ts":1553026251000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"littledan: that sounds like defer or async","msgtype":"m.text"},"ts":1553026414000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Modules are always defer or async, but as a group. All of them are fetched and parsed before any of them run, and that fetching and parsing happens as defer or async","msgtype":"m.text"},"ts":1553026503000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"As we think about HTML or CSS modules, I guess these problems become more acute. Suddenly more and more stuff is all at once","msgtype":"m.text"},"ts":1553026534000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"Or, maybe it's not. Maybe those do their loading in the Evaluate phase, unlike JS. I'm not sure","msgtype":"m.text"},"ts":1553026558000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: you mean that they would export a promise? I don’t think that’s how folks are thinking about them","msgtype":"m.text"},"ts":1553028415000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"No, I mean they might run via top-level await basically","msgtype":"m.text"},"ts":1553030197000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"But if they pull in their dependencies this way, it would differ from JS. So I am wondering if JS should actually do this too","msgtype":"m.text"},"ts":1553030233000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"annevk: What I'd heard is that HTML modules might be asynchronous (as if they used top-level await), which could make sense as the HTML processing module is async. So would it make sense to extend that further, if JavaScript is what's making startup slow on lots of pages?","msgtype":"m.text"},"ts":1553032131000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"JS often needs to block startup tho, to set up the environment or the DOM or whatnot","msgtype":"m.text"},"ts":1553032366000,"senderName":"ljharb","senderId":"ljharb@irc"}
]