[
{"content":{"body":"That seems like a bug, honestly.","msgtype":"m.text"},"ts":1589248866000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"i remember a bit of discussion on it as an intentional decision","msgtype":"m.text"},"ts":1589248933000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Seems its https://github.com/tc39/proposal-async-iteration/pull/102","msgtype":"m.text"},"ts":1589251281000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"With relevant slides at https://docs.google.com/presentation/d/1U6PivKbFO0YgoFlrYB82MtXf1ofCp1xSVOODOvranBM/edit#slide=id.p","msgtype":"m.text"},"ts":1589251296000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"This should be changeable","msgtype":"m.text"},"ts":1589254350000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Justification slides at 8 and 9: https://docs.google.com/presentation/d/1U6PivKbFO0YgoFlrYB82MtXf1ofCp1xSVOODOvranBM/edit#slide=id.g223fba4116_0_207","msgtype":"m.text"},"ts":1589254389000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"These don't apply to `return Promise.reject()`, since any finalization would be able to run.","msgtype":"m.text"},"ts":1589254425000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"So it'd be a normal completion","msgtype":"m.text"},"ts":1589254443000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"We only need to ensure that the rejection is unwrapped before the iterator object settles","msgtype":"m.text"},"ts":1589254466000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"are there any plans for named parameters in JS, handled like python would? I really dislike passing objects around when I don't have to, and when some parameters have no defaults","msgtype":"m.text"},"ts":1589263619000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"unlikely. why do you dislike it?","msgtype":"m.text"},"ts":1589263645000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"e.g.: `const add = (a, b, nanAsZero = false, undefinedAsZero = false) => ...; add(1, 2); add(1, 2, undefinedAsZero: true); add(1, 2, nanAsZero: true);`","msgtype":"m.text"},"ts":1589263736000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"if I wanted optional named arguments, I'd have to do something like this: `const add = (opts = {}) => { const {a, b, nanAsZero = false, undefinedAsZero = false} = opts; ... }; add({a: 1, b: 2}); add({a: 1, b: 2, undefinedAsZero: true}); ...`","msgtype":"m.text"},"ts":1589263835000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"i mean, you'd do `({ a, b, etc } = {})` but sure","msgtype":"m.text"},"ts":1589263852000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ie, you'd destructure inline","msgtype":"m.text"},"ts":1589263856000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"also generally i'd say you want the required params to be positional","msgtype":"m.text"},"ts":1589263873000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or this, which I think is worse: `const add = (a, b, opts = {}) => ...; add(1, 2); add(1, 2, {undefinedAsZero: true}); ...`","msgtype":"m.text"},"ts":1589263899000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"why is that worse?","msgtype":"m.text"},"ts":1589263925000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the signature is unnecessarily complicated","msgtype":"m.text"},"ts":1589263939000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"it's extra curly braces","msgtype":"m.text"},"ts":1589263959000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"how is that more complicated than adding an entirely new syntax","msgtype":"m.text"},"ts":1589263978000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'm not sure, it feels like extra cognitive load, and acts as an obstacle to writing clean functions","msgtype":"m.text"},"ts":1589264089000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"\"clean\" is very subjective","msgtype":"m.text"},"ts":1589264100000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"from my perspective, kwargs would be less clean, and is extra cognitive load. object destructuring and defaults are cognitive load i already have to bear, since it's part of the language","msgtype":"m.text"},"ts":1589264129000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'd like to write functions with object-named parameters, but then I'm worried the code users will be discouraged from writing the extra `{}` on the function call, and I start (unnecessarily) worrying about object memoization","msgtype":"m.text"},"ts":1589264225000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"towc: generally there's a pretty high bar for new syntax. it needs to make something very common significantly easier, or something which is effectively impossible possible. adding additional syntax for named parameters is just syntax sugar, so it would have to meet the \"something very common significantly easier\" bar, and my feeling is that it does not. using object destructuring is not significantly harder than named parameters","msgtype":"m.text"},"ts":1589264257000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":" would be.","msgtype":"m.text"},"ts":1589264258000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"considering that's how a very large amount of the js ecosystem already does it, i don't think it will discourage anybody","msgtype":"m.text"},"ts":1589264260000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(also, yeah, agreed with ljharb: destructuring-as-named-params is common practice in JS these days, so I don't think you should worry about users not being comfortable with the `{}`.)","msgtype":"m.text"},"ts":1589264342000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"an interesting application would be to add names of the positional paremeters you're targeting, in function calls, which python allows. This would make dealing with older APIs much easier, without needing to modernize those APIs, and keeping everything backwards-compatible","msgtype":"m.text"},"ts":1589264441000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"in python, you can do `def fn(a, b): ...; fn(b=1, a=2)`","msgtype":"m.text"},"ts":1589264463000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"naming positional parameters, even if keeping the same order, could add a lot of optional clarity to user code","msgtype":"m.text"},"ts":1589264513000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"that example is already valid syntax (it creates a global variable)","msgtype":"m.text"},"ts":1589264528000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i think it would work with the colons, but then it falls to the \"high bar\" Bakkot referenced","msgtype":"m.text"},"ts":1589264561000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"well, in js using `=`, sure, but we could have `const fn = (a, b) => ...; fn(b: 1, a: 2)`","msgtype":"m.text"},"ts":1589264570000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"sometimes i do wish we could name parameters like that","msgtype":"m.text"},"ts":1589264602000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think it's worth thinking about, but thank you for your time :)","msgtype":"m.text"},"ts":1589264606000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"apart from everything else, it is common practice for build tools in javascript to change variable names, which means if we added this to existing functions in a non-opt-in manner it would mean substantially every build process would be breaking its input, which seems... bad","msgtype":"m.text"},"ts":1589264606000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but i don't think overall it is worth it","msgtype":"m.text"},"ts":1589264607000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh, good point","msgtype":"m.text"},"ts":1589264642000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"seems more like a feature for typescript than js","msgtype":"m.text"},"ts":1589264662000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"TS does not intend to add non-type features, so they're probably not interested","msgtype":"m.text"},"ts":1589264688000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"p sure TS won't add any new non-type-related features","msgtype":"m.text"},"ts":1589264690000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you could write a babel plugin for it though!","msgtype":"m.text"},"ts":1589264699000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"wouldn't be too tricky I expect","msgtype":"m.text"},"ts":1589264708000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"heh, when writing my type proposal I had a few people ask me about named parameters. Haven't thought about them in a while. I even added an example to show I wasn't conflicting with desired syntax.","msgtype":"m.text"},"ts":1589264730000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"(I don't really recommend it, since it would make other people picking up your codebases harder, but it's a possibility depending on your priorities)","msgtype":"m.text"},"ts":1589264736000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"well they say that","msgtype":"m.text"},"ts":1589264762000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh i got scroll'd","msgtype":"m.text"},"ts":1589264770000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah, I think I'll just need to stick to obscure positional parameter names, because that's what the teams I've worked on have been doing, forever","msgtype":"m.text"},"ts":1589264782000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"now if we had monads","msgtype":"m.text"},"ts":1589264817000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you could just safely and functionally get the arguments","msgtype":"m.text"},"ts":1589264843000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"s/positional parameter names/positional parameters/","msgtype":"m.text"},"ts":1589264844000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"alright, thanks all, I'll be back with another failed idea in a few months, I'm sure :)","msgtype":"m.text"},"ts":1589264906000,"senderName":"towc","senderId":"towc@irc"},
{"content":{"body":"keep 'em coming","msgtype":"m.text"},"ts":1589264936000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh they quit","msgtype":"m.text"},"ts":1589264938000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://github.com/sirisian/ecmascript-types#named-arguments I think this is the example I saw a few times. Functions with lots of defaults.","msgtype":"m.text"},"ts":1589265099000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"I don't think you should really worry about it","msgtype":"m.text"},"ts":1589265158000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah, I told other people it's so low priority it's not worth it.","msgtype":"m.text"},"ts":1589265179000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"destructuring is in all likelihood the only thing we will have for named parameters forever","msgtype":"m.text"},"ts":1589265200000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Indeed","msgtype":"m.text"},"ts":1589265213000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"you could also just use global variables","msgtype":"m.text"},"ts":1589265312000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`f(a=1)` and check the value of `globalThis.a` in `f`","msgtype":"m.text"},"ts":1589265329000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1589265348000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Creative.","msgtype":"m.text"},"ts":1589265405000,"senderName":"Sirisian","senderId":"Sirisian@irc"},
{"content":{"body":"or just introduce a new calling convention: `with (f.args) f(a = 1, b = 2)`, where `f.args` is a proxy which emulates f's parameters","msgtype":"m.text"},"ts":1589265499000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(don't even need a proxy I guess, come to think)","msgtype":"m.text"},"ts":1589265513000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i love it","msgtype":"m.text"},"ts":1589265564000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bring back zones, but one per fn call","msgtype":"m.text"},"ts":1589302781000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"}
]