[
{"content":{"body":"btw, I am planning on fixing completion records: https://github.com/tc39/ecma262/issues/1796","msgtype":"m.text"},"ts":1574902788000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"(in the spec)","msgtype":"m.text"},"ts":1574902794000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"would welcome input on this plan","msgtype":"m.text"},"ts":1574902799000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"bakkot: any chance of removing normal completions? :P","msgtype":"m.text"},"ts":1574916589000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: no","msgtype":"m.text"},"ts":1574919347000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"tagged unions are clearer than untagged unions, as a rule","msgtype":"m.text"},"ts":1574919360000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"ü§∑üèª","msgtype":"m.text"},"ts":1574919403000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"from my perspective normal completions make everything more complex","msgtype":"m.text"},"ts":1574919413000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there's no reason you can't consider language values to be a tagged union.","msgtype":"m.text"},"ts":1574919459000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"jmdyck: sure there is; there's no tag","msgtype":"m.text"},"ts":1574919477000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"How does an algorithm evaluate a condition like \"If x is an Object\" then?","msgtype":"m.text"},"ts":1574919528000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"you could just as easily say that there's no \"tag\" that allows algorithms to distinguish language values of different types. And yet they certainly do.","msgtype":"m.text"},"ts":1574919618000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"you can discriminate on types, and obviously you could do that for completion records if we decided to mix abrupt completions with other values. but here they are different kinds of things in a way that a string vs an object is not.","msgtype":"m.text"},"ts":1574919722000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"and explicitly tagging which is which makes it easier to avoid a confusion of types.","msgtype":"m.text"},"ts":1574919760000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"jmdyck: is Type(completion record) valid?","msgtype":"m.text"},"ts":1574919838000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: strictly speaking yes, but in practice we just say \"is an abrupt completion\" or \"is a normal completion\", and we could still say \"is an abrupt completion\" even if we decided to do mix abrupt completions with values other than completion records","msgtype":"m.text"},"ts":1574919941000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"\"they are different kinds of things in a way that a string vs an object is not\". Sure, but a string vs an object are different kinds of things in a way that an array vs a proxy are not. It's just different branches of a type hierarchy.","msgtype":"m.text"},"ts":1574919971000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"if that weren't valid i would understand","msgtype":"m.text"},"ts":1574919982000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but since it is...","msgtype":"m.text"},"ts":1574919986000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: I don't know what comes after your ellipses","msgtype":"m.text"},"ts":1574920034000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"jmdyck: technically true, yes, but I think the overwhelming majority of branches in the spec are on abrupt vs normal completion","msgtype":"m.text"},"ts":1574920088000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"if it can be discriminated by Type() it seems like a valid method of discrimination to me","msgtype":"m.text"},"ts":1574920099000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: yes, the two choices are semantically equivalent","msgtype":"m.text"},"ts":1574920109000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"the spec is usually if x is abrupt do y else set x to x.Value","msgtype":"m.text"},"ts":1574920128000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"basically you'd just remove a bunch of set x to x.Value","msgtype":"m.text"},"ts":1574920140000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"\"the overwhelming majority of branches in the spec are on abrupt vs normal completion\": do you mean branching on conditions in algorithms?","msgtype":"m.text"},"ts":1574920186000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"i guess we have stuff like \"Assert: completion is a normal completion and completion.[[Value]] is undefined.\"","msgtype":"m.text"},"ts":1574920199000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"probably refactor to \"assert: result is undefined\"","msgtype":"m.text"},"ts":1574920212000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"jmdyck: I mean that most \"if\"s in the spec are of the form \"If argument is an abrupt completion, return argument\"","msgtype":"m.text"},"ts":1574920245000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"(albeit somewhat obscured behind a macro)","msgtype":"m.text"},"ts":1574920260000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"else set argument to argument.Value","msgtype":"m.text"},"ts":1574920266000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: yes, I know what the other branch is","msgtype":"m.text"},"ts":1574920276000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"my point is that it's redundant","msgtype":"m.text"},"ts":1574920287000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: we are not optimizing for the shortest possible specification","msgtype":"m.text"},"ts":1574920305000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"less stuff is usually more understandable","msgtype":"m.text"},"ts":1574920321000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not when it involves mixing exceptions with values without explicit tagging","msgtype":"m.text"},"ts":1574920347000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"barring stuff like code golf","msgtype":"m.text"},"ts":1574920347000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe to put it another way","msgtype":"m.text"},"ts":1574920419000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i can point to parts of the specification where normal completions are confusing","msgtype":"m.text"},"ts":1574920429000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"usually around evaluation boundaries","msgtype":"m.text"},"ts":1574920438000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i can't imagine confusion from the lack of normal completions","msgtype":"m.text"},"ts":1574920460000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe if you had an example of a part of the spec that became less understandable","msgtype":"m.text"},"ts":1574920470000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: if there's any cases you expect will still be confusing after https://github.com/tc39/ecma262/issues/1796, I would be interested to know which and why","msgtype":"m.text"},"ts":1574920483000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"devsnek: literally any places that an algorithm returns sometimes-an-abrupt-completion, sometimes-a-js-value","msgtype":"m.text"},"ts":1574920504000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"I would find to be less undertandable","msgtype":"m.text"},"ts":1574920511000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"because I would be confused by what type the algorithm returns","msgtype":"m.text"},"ts":1574920548000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"does it return a JS value? sometimes?","msgtype":"m.text"},"ts":1574920554000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"how is \"sometimes\" an acceptable type signature?","msgtype":"m.text"},"ts":1574920560000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"\"completion record\" is a natural type","msgtype":"m.text"},"ts":1574920582000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"\"untagged union of completion records and js values\" is not a natural type","msgtype":"m.text"},"ts":1574920599000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"I will literally never expect that to be the return type of an algorithm","msgtype":"m.text"},"ts":1574920611000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"and it will be less clear to readers and authors which abstract operations can return abruptly and which cannot","msgtype":"m.text"},"ts":1574920632000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"is natural type a defined term","msgtype":"m.text"},"ts":1574920647000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm confused","msgtype":"m.text"},"ts":1574920658000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"no, not especially","msgtype":"m.text"},"ts":1574920679000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"like `Value | Error<Value>` would be a valid signature","msgtype":"m.text"},"ts":1574920682000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"re: ``I mean that most \"if\"s in the spec are of the form \"If argument is an abrupt completion, return argument\"``: I make it about 45%. But either way, I'm not sure how it's relevant.","msgtype":"m.text"},"ts":1574920689000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"i don't really understand why tagged unions are inherently simpler","msgtype":"m.text"},"ts":1574920736000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"jmdyck: it means that understanding which values are normal and which are abrupt is a much more important operation to understanding the specification than understanding whch JS values are Objects and which are Strings","msgtype":"m.text"},"ts":1574920739000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"devsnek: clearer, not simpler. and they are clearer because, among other reasons, it means that if an algorithm can possibly throw, you cannot fail to handle the throwing behavior without having the types be obviously wrong","msgtype":"m.text"},"ts":1574920818000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"whereas if \"can possibly throw\" is represented by \"returns either a JS value or a completion record\", and the caller treats the return value as a JS value, that is not obviously wrong - maybe it just doesn't throw in their particular circumstances","msgtype":"m.text"},"ts":1574920862000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"in good static languages you can't coalesce a T|U to a T","msgtype":"m.text"},"ts":1574920869000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this is a specification","msgtype":"m.text"},"ts":1574920879000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"yeah but you're talking about static types","msgtype":"m.text"},"ts":1574920887000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it does not currently have a type checker","msgtype":"m.text"},"ts":1574920892000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1574920896000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which is why i asked what tagged unions has to do with it","msgtype":"m.text"},"ts":1574920902000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if we expect random rules of tagged unions to apply why cant we expect other rules to apply as well","msgtype":"m.text"},"ts":1574920929000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like rules of how things can be coalesced","msgtype":"m.text"},"ts":1574920938000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"[understanding abrupt vs normal is more important than understanding object vs string]: possibly, but I'm not convinced that \"understanding which values are normal and which are abrupt\" is aided by the existence or normal completions.","msgtype":"m.text"},"ts":1574920944000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"^","msgtype":"m.text"},"ts":1574920966000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: it is much more obvious that you have failed to consider a case when your usage of a value cannot ever be right, rather than when it is only wrong some of the time","msgtype":"m.text"},"ts":1574921014000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"i'm not entirely sure what that means","msgtype":"m.text"},"ts":1574921039000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"when can you handle T|U wrong more than you can handle enum { T, U } wrong","msgtype":"m.text"},"ts":1574921068000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: if I write an something which treats the return value of Foo as being never-abrupt, and it turns out that Foo could sometimes be aburpt, it will not be obvious just from looking at Foo and the algorithm I'm writing","msgtype":"m.text"},"ts":1574921094000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"whereas if I write something which treats the return value of Foo as a JS value, and Foo can only return completion records, it is obvious from looking at Foo and the algorithm I'm writing that I have done that wrong","msgtype":"m.text"},"ts":1574921135000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"if foo only returns completion records you can still accidentally assume that it only returns normal ones","msgtype":"m.text"},"ts":1574921179000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but you have to do so explicitly","msgtype":"m.text"},"ts":1574921188000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"i don't understand how that's any more or less explicit than deciding that, given a signature of T|U, only T will ever exist","msgtype":"m.text"},"ts":1574921212000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(and algorithms which can never throw won't return completion records anymore, so that assumption will be much less warranted)","msgtype":"m.text"},"ts":1574921219000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"devsnek: by \"explicitly\" I mean you have to explicitly unwrap the completion record","msgtype":"m.text"},"ts":1574921231000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"in prose","msgtype":"m.text"},"ts":1574921238000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"same with T|U","msgtype":"m.text"},"ts":1574921242000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if it's U do x","msgtype":"m.text"},"ts":1574921250000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"otherwise it must be T","msgtype":"m.text"},"ts":1574921254000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you can take completion.Value without checking whether its normal or not","msgtype":"m.text"},"ts":1574921292000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"without violating any rules","msgtype":"m.text"},"ts":1574921295000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: you can, but it is obvious that you are doing something weird in that case","msgtype":"m.text"},"ts":1574921308000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"it is explicit","msgtype":"m.text"},"ts":1574921311000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"treating a T|U as a T is not explicit","msgtype":"m.text"},"ts":1574921320000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"i don't understand how it's any more obvious","msgtype":"m.text"},"ts":1574921320000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what is going on","msgtype":"m.text"},"ts":1574921357000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"if I say \"If SameValue(Foo(bar), 0)...\", but Foo can throw, it is not obvious that I have done something wrong","msgtype":"m.text"},"ts":1574921361000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"if Foo does not return completion records","msgtype":"m.text"},"ts":1574921370000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"it is if it does","msgtype":"m.text"},"ts":1574921372000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"shu: discussion about whether removing normal completions is good or not","msgtype":"m.text"},"ts":1574921375000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bakkot: why not?","msgtype":"m.text"},"ts":1574921387000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"we're not removing normal completions, we're removing implicit coercions to normal completions?","msgtype":"m.text"},"ts":1574921390000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"devsnek: at this point I am going to have to appeal to personal experience","msgtype":"m.text"},"ts":1574921415000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"replace my previous \"it is not obvious\" with \"it is not obvious to me, bakkot\"","msgtype":"m.text"},"ts":1574921430000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"i mean in the two languages i've used with an Option<T> type","msgtype":"m.text"},"ts":1574921436000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"people do unsafe unwrapping all the time","msgtype":"m.text"},"ts":1574921442000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't understand how this is any different","msgtype":"m.text"},"ts":1574921466000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(shu: one way to eliminate implicit coercions to/from normal completions is for them not to exist.)","msgtype":"m.text"},"ts":1574921476000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"so that whenever you return a JS value, it is to be interpreted as \"lifted into normal Completion of value\"?","msgtype":"m.text"},"ts":1574921501000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"at the moment, yes","msgtype":"m.text"},"ts":1574921521000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: no, so that you don't have normal completions at all, and we just have things which return \"either a JS value or a completion record\"","msgtype":"m.text"},"ts":1574921525000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"oh what, no","msgtype":"m.text"},"ts":1574921535000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"that is not a good idea","msgtype":"m.text"},"ts":1574921538000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah that is my reaction","msgtype":"m.text"},"ts":1574921543000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"maybe shu has a different perspective","msgtype":"m.text"},"ts":1574921556000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: why not?","msgtype":"m.text"},"ts":1574921564000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"devsnek: the unsafe unwrapping is explicit, not implicit","msgtype":"m.text"},"ts":1574921614000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"that is the point","msgtype":"m.text"},"ts":1574921620000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"jmdyck: because Completion records as a structure that encodes the pair of \"how to continue evaluation\" and \"the payload needed to continue evaluation in that way\" is explicit and desirable","msgtype":"m.text"},"ts":1574921627000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"you have to write down that you are doing it","msgtype":"m.text"},"ts":1574921629000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"bakkot: it's the same as doing completion.Value without checking the type of the completion","msgtype":"m.text"},"ts":1574921631000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: explicitly doing an unsafe unwrap is the same as explicitly doing completion.value without checking the type of the completion, yes","msgtype":"m.text"},"ts":1574921657000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"in that both are explicit","msgtype":"m.text"},"ts":1574921661000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"jmdyck: there will be AOs which *should not* have a say in \"how to continue evaluation\", but might return JS values","msgtype":"m.text"},"ts":1574921662000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"by contrast to the _implicit_ unwrapping which happens if I say \"If SameValue(Foo(bar), 0)...\", but Foo can throw","msgtype":"m.text"},"ts":1574921686000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1574921690000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"bakkot: in my mind that isn't valid spec text","msgtype":"m.text"},"ts":1574921723000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there's no unwrapping there","msgtype":"m.text"},"ts":1574921726000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it is detrimental to how i understand language evaluation to have to think through, in an ad hoc way, whether an AO returns a JS value to mean \"continue evaluating, with this JS value\", or \"here's a spec-internal thing i checked, and here is a JS value\"","msgtype":"m.text"},"ts":1574921734000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"devsnek: but people will write it anyway","msgtype":"m.text"},"ts":1574921734000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"i mean this isn't about reduction to some form that is equally expressive","msgtype":"m.text"},"ts":1574921795000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"this is about editorial clarity","msgtype":"m.text"},"ts":1574921797000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"in a spec that is full of prose","msgtype":"m.text"},"ts":1574921805000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"indeed","msgtype":"m.text"},"ts":1574921809000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which was my point up above","msgtype":"m.text"},"ts":1574921816000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm not as concerned about the strict typing of all our algorithms","msgtype":"m.text"},"ts":1574921827000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"sorry, what was your point because i think we're on different sides of the question here","msgtype":"m.text"},"ts":1574921842000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"my point was that i've gotten confused dealing with normal completions before","msgtype":"m.text"},"ts":1574921860000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in... what way?","msgtype":"m.text"},"ts":1574921894000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"(while working on engine262, v8 doesn't have completions)","msgtype":"m.text"},"ts":1574921898000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"because the implicit coercions?","msgtype":"m.text"},"ts":1574921904000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1574921911000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm missing some intermediate steps","msgtype":"m.text"},"ts":1574921920000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and there was something else too","msgtype":"m.text"},"ts":1574921923000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"great, we are all on board, we will get rid of implicit coercions","msgtype":"m.text"},"ts":1574921928000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"i think it was in ScriptEvaluation","msgtype":"m.text"},"ts":1574921929000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why does confusion arising from implicit coercions imply we should remove normal completions...","msgtype":"m.text"},"ts":1574921931000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i'd ahave to double check","msgtype":"m.text"},"ts":1574921933000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: that wasn't the only thing, just the main one","msgtype":"m.text"},"ts":1574921956000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"as bakkot said, i think we all agree about removing the implicit stuff","msgtype":"m.text"},"ts":1574921963000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"correct, and bakkot and i have both said we find value in keeping normal completions, but explicit","msgtype":"m.text"},"ts":1574921980000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"vs return of bare JS values","msgtype":"m.text"},"ts":1574921990000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so i'd like to understand what the lack of clarity is for having explicit normal completions","msgtype":"m.text"},"ts":1574922004000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"in terms of clarity, normal completion to me is a weird duplicate identity of just a plain js value","msgtype":"m.text"},"ts":1574922065000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like the same way jmdyck has that pr to get rid of lexical environment records or whatever","msgtype":"m.text"},"ts":1574922103000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's very explicit","msgtype":"m.text"},"ts":1574922105000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but seemingly unneeded","msgtype":"m.text"},"ts":1574922112000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"same amount of clarity either way, but one way has less stuff","msgtype":"m.text"},"ts":1574922153000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so, for me, i think it's very important to distinguish AOs that are meant to be used as part of observable evaluation, and AOs that are spec-internal, like predicates","msgtype":"m.text"},"ts":1574922174000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"for the former, it makes sense to return a completion value, whether normal or abrupt","msgtype":"m.text"},"ts":1574922185000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"for the latter, it make sense to return bare JS values","msgtype":"m.text"},"ts":1574922203000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"using completions even where it can never be non-normal?","msgtype":"m.text"},"ts":1574922206000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what?","msgtype":"m.text"},"ts":1574922215000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"AOs that are part of observable evaluation don't inherently have the ability to return abrupt completions","msgtype":"m.text"},"ts":1574922236000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"to me there would be no reason to use a completion if there's no possibility of it being anything except normal","msgtype":"m.text"},"ts":1574922256000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think that kind of mental model minimizes for the wrong thing, i don't think it should be about minimizing what can't be abrupt right now","msgtype":"m.text"},"ts":1574922339000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"devsnek: if you're talking about evaluating ES code, then (except for literals, say) wouldn't there always be the possibility of an abrupt completion?","msgtype":"m.text"},"ts":1574922383000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"jmdyck: i dunno, maybe shu and i have different definitions of \"part of observable evaluation\"","msgtype":"m.text"},"ts":1574922409000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"anything that evaluates js could throw","msgtype":"m.text"},"ts":1574922436000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: I don't find them equally clear; see above re: not finding it obvious that \"If SameValue(Foo(bar), 0)...\" is wrong","msgtype":"m.text"},"ts":1574922436000,"senderName":"bakkot","senderId":"bakkot@irc"},
{"content":{"body":"in all formal PL semantics i've worked on, \"semantics\" are captured two ways","msgtype":"m.text"},"ts":1574922453000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"1) something operational, like a step-by-step thing that describes what an evaluation machine does","msgtype":"m.text"},"ts":1574922477000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"2) something mathematical that declares a property","msgtype":"m.text"},"ts":1574922490000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it so happens that in ecma262, we conflate both with operational step-by-step algorithms","msgtype":"m.text"},"ts":1574922501000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but, some AOs are intended for the first category and some are intended for the second","msgtype":"m.text"},"ts":1574922520000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"for the first category, those are the AOs that return completion values","msgtype":"m.text"},"ts":1574922530000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i guess you mean the difference between AOs and runtime semantics?","msgtype":"m.text"},"ts":1574922537000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"no, i wish that was the line of distinction but it isn't","msgtype":"m.text"},"ts":1574922551000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"we refactor runtime semantics into AOs all the time and then call them","msgtype":"m.text"},"ts":1574922560000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i mean we don't have any distinction between them atm","msgtype":"m.text"},"ts":1574922562000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if we did though","msgtype":"m.text"},"ts":1574922569000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right, it is confusing at the moment","msgtype":"m.text"},"ts":1574922570000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and this completion value realignment thing *is* the split","msgtype":"m.text"},"ts":1574922581000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so you meant if we recategorized our runtime semantics and AOs","msgtype":"m.text"},"ts":1574922598000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that makes sense","msgtype":"m.text"},"ts":1574922600000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i took what you said to mean our current definitions","msgtype":"m.text"},"ts":1574922611000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what we call runtime semantics is just the purely syntax direct part","msgtype":"m.text"},"ts":1574922616000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but that isn't even true because we pass parse nodes to AOs too","msgtype":"m.text"},"ts":1574922625000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"directed*","msgtype":"m.text"},"ts":1574922635000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i would be a fan of fixing what we call AO and what we call RS","msgtype":"m.text"},"ts":1574922676000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":" there are lots of SDOs labelled \"Static Semantics\"","msgtype":"m.text"},"ts":1574922694000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"i don't think the labels of our metafunctions here matter as much as their signatures","msgtype":"m.text"},"ts":1574922732000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"we can relabel after we got the signatures sussed out better","msgtype":"m.text"},"ts":1574922745000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah, i was just confused about what you meant","msgtype":"m.text"},"ts":1574922755000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'll agree that \"Runtime\" vs \"Static\" is not very important.","msgtype":"m.text"},"ts":1574922795000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"i though you were suggesting something like OrdinaryOwnPropertyKeys would need to return a completion","msgtype":"m.text"},"ts":1574922817000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think if we deleted all mention of \"Runtime Semantics\" and \"Static Semantics\", it wouldn't make a bit of difference normatively.","msgtype":"m.text"},"ts":1574922840000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"devsnek: that AO reads to me as squarely in 2) from my categorization","msgtype":"m.text"},"ts":1574922868000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ya","msgtype":"m.text"},"ts":1574922880000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's declaratively describing a strict order","msgtype":"m.text"},"ts":1574922906000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: are you saying that the 1 vs 2 distinction can be made on the basis of signatures?","msgtype":"m.text"},"ts":1574922917000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"but is describing it with the algorithmic language because it's the only thing we have","msgtype":"m.text"},"ts":1574922919000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"jmdyck: that is my hope, yes","msgtype":"m.text"},"ts":1574922923000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"signatures of returning completions or not","msgtype":"m.text"},"ts":1574922934000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i imagine there are snags, but that is my rough mental model","msgtype":"m.text"},"ts":1574922953000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"whether they take productions, runtime values, etc, as arguments, what they return, etc","msgtype":"m.text"},"ts":1574922957000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or rather what they do with those arguments :P","msgtype":"m.text"},"ts":1574923025000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"anyway happy thanksgiving!","msgtype":"m.text"},"ts":1574923027000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ü¶É","msgtype":"m.text"},"ts":1574923038000,"senderName":"devsnek","senderId":"devsnek@irc"}
]