[
{"content":{"body":"like thenability is forgeable, instanceof is forgeable, brand checks are not","msgtype":"m.text"},"ts":1591747285000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"iow identity is indeed unforgeable for objects and symbols, but forgeability goes way beyond just identity to me","msgtype":"m.text"},"ts":1591747457000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"webidl has a definition of \"unforgeable\", which applies to attributes: https://heycam.github.io/webidl/#dfn-unforgeable-on-an-interface","msgtype":"m.text"},"ts":1591747493000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: hm I guess it applies in a lot of situations","msgtype":"m.text"},"ts":1591748089000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in regard to values, it means you can't create a value with the same identity, you have to have the actual value to have the same identity","msgtype":"m.text"},"ts":1591748211000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which is the distinction we're using for weak collection keys","msgtype":"m.text"},"ts":1591748229000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek except the current proposal allows `Symbol.for` symbols, I think","msgtype":"m.text"},"ts":1591748480000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"those are still unforgeable","msgtype":"m.text"},"ts":1591748510000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not any more unforgeable than string literals, surely?","msgtype":"m.text"},"ts":1591748521000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"symbol.for doesn't create new values, there's a cache","msgtype":"m.text"},"ts":1591748521000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I don't understand the distinction between Symbol.for symbols and strings","msgtype":"m.text"},"ts":1591748537000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what is the relevant distinction here?","msgtype":"m.text"},"ts":1591748546000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you can create caches of objects too","msgtype":"m.text"},"ts":1591748561000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"... so?","msgtype":"m.text"},"ts":1591748581000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I mean from some level of abstraction nothing is unforgeable because you can store it in something keyed by strings","msgtype":"m.text"},"ts":1591748594000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"neither Symbol.for symbols nor strings are objects","msgtype":"m.text"},"ts":1591748602000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I don't see what the distinction between those two things is","msgtype":"m.text"},"ts":1591748618000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I get splitting out objects from non-Symbol.for symbols: there if you don't already have access to the thing, possibly transitively (via a cache or whatever), you cannot get it","msgtype":"m.text"},"ts":1591748652000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but this is not true for Symbol.for symbols or for strings","msgtype":"m.text"},"ts":1591748672000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"those you can synthesize in a new realm without access to anything outside of the realm","msgtype":"m.text"},"ts":1591748688000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but the symbols in the agent cache aren't being forged, they're just normal symbols","msgtype":"m.text"},"ts":1591748733000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I don't know what you mean by forged","msgtype":"m.text"},"ts":1591748746000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the point of this conversation is to try to get at what you mean by forged","msgtype":"m.text"},"ts":1591748755000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"a new value is created with the identity of some other value","msgtype":"m.text"},"ts":1591748770000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I don't know what it means to be a \"new value\" but have the identity of another value","msgtype":"m.text"},"ts":1591748796000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that seems like it is tautologically impossible","msgtype":"m.text"},"ts":1591748810000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"like two strings both containing the same characters in the same order","msgtype":"m.text"},"ts":1591748813000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"how is that any more of a new value than a Symbol.for symbol is?","msgtype":"m.text"},"ts":1591748875000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"because symbol.for doesn't always return a new symbol","msgtype":"m.text"},"ts":1591748898000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"neither does writing a string literal","msgtype":"m.text"},"ts":1591748913000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it definitely does","msgtype":"m.text"},"ts":1591748930000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe in your implementation, not in mine","msgtype":"m.text"},"ts":1591748940000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the difference is not observable to user code","msgtype":"m.text"},"ts":1591748946000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I'm not sure what optimization has to do with this","msgtype":"m.text"},"ts":1591748984000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you're the one who brought it up?","msgtype":"m.text"},"ts":1591748999000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no I didn't","msgtype":"m.text"},"ts":1591749010000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you said \"symbol.for doesn't always return a new symbol\". this is exactly as true as \"writing a string literal doesn't always return a new string\".","msgtype":"m.text"},"ts":1591749052000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no symbol.for is specified to not always return a new symbol","msgtype":"m.text"},"ts":1591749068000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"string literals are not specified to return new values either","msgtype":"m.text"},"ts":1591749079000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the spec in fact speaks of \"the\" empty string","msgtype":"m.text"},"ts":1591749088000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I'm not sure what we're talking about anymore","msgtype":"m.text"},"ts":1591749144000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"my point was being able to cache a type doesn't make it a forgeable type","msgtype":"m.text"},"ts":1591749179000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I'm trying to understand what distinction you see between Symbol.for symbols and string literals, from the perspective of, only the former is \"forgeable\"","msgtype":"m.text"},"ts":1591749193000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"symbol.for symbols are symbols","msgtype":"m.text"},"ts":1591749205000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"we only have one kind of symbol in js","msgtype":"m.text"},"ts":1591749213000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"depending on what you mean by \"kind\", sure","msgtype":"m.text"},"ts":1591749244000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but this does not help me understand what you mean by \"forgeable\"","msgtype":"m.text"},"ts":1591749253000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"all objects, and symbols not created by Symbol.for, have the property that code running in a fresh realm cannot get access to them. but this is not true of symbols created by Symbol.for, just as it is not true of string literals. so clearly this cannot be the definition of \"forgeable\".","msgtype":"m.text"},"ts":1591749340000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"forgeable = you can create a value that has the identity of another value without having access to the original value","msgtype":"m.text"},"ts":1591749345000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ok, so, in what way are Symbol.for symbols not forgeable?","msgtype":"m.text"},"ts":1591749403000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you have to look up the original value using Symbol.for","msgtype":"m.text"},"ts":1591749418000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you can't produce it out of thin air","msgtype":"m.text"},"ts":1591749422000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Symbol.for is thin air","msgtype":"m.text"},"ts":1591749453000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it exists in fresh realms; it does not need to be passed in","msgtype":"m.text"},"ts":1591749470000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's what i meant above","msgtype":"m.text"},"ts":1591749477000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"\"I mean from some level of abstraction nothing is unforgeable because you can store it in something keyed by strings\"","msgtype":"m.text"},"ts":1591749479000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you can't store it in a way which will be available to code with which you share no communication channel","msgtype":"m.text"},"ts":1591749552000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i.e. you have to actually pass the value, or a thing which has access to the value, to the new code","msgtype":"m.text"},"ts":1591749577000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i.e. it can't make it itself","msgtype":"m.text"},"ts":1591749581000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":" this is not true of Symbol.for symbols","msgtype":"m.text"},"ts":1591749585000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"for mark's definition of communication channel sure","msgtype":"m.text"},"ts":1591749589000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for any definition of communication channel","msgtype":"m.text"},"ts":1591749719000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sure","msgtype":"m.text"},"ts":1591749769000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i would just say the globals are passed to the realm and therefore the symbol is passed to the realm","msgtype":"m.text"},"ts":1591749813000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: i think the crux of this is just that you cannot recreate the value with undeniable computation / primitive computation","msgtype":"m.text"},"ts":1591750050000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"basically the idea is since you can censor `.for` using APIs but cannot censor things like 'it'+'erator'","msgtype":"m.text"},"ts":1591750186000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Hi all!","msgtype":"m.text"},"ts":1591772543000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"I am having a little problem understanding why - AssignmentRestProperty doesn't allow Array or Object Literal inside it, but AssignmentRestElement allows them","msgtype":"m.text"},"ts":1591772551000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"So, I can write `[a,  ...{0: b, length: c}] = [1,2,3,4,5]` but not `({a, ...{b}} = {a: 1, b: 2})`","msgtype":"m.text"},"ts":1591772564000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"What is the reason for allowing destructuring after ... in array destructuring, but not in object dest.?","msgtype":"m.text"},"ts":1591772574000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"This is the relevant spec link - https://tc39.es/ecma262/#sec-destructuring-assignment-static-semantics-early-errors","msgtype":"m.text"},"ts":1591772648000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"bendtherules: the former is gathering the first item in `a` and the rest in an array, that you're destructuring","msgtype":"m.text"},"ts":1591772654000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"bendtherules: i can see why you'd think the latter is allowed, but it seems nonsensical to me since you can just remove the `...{ }`","msgtype":"m.text"},"ts":1591772681000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"True, but then what is the rational behind allowing `[a, ...[b, c]] = []`?","msgtype":"m.text"},"ts":1591772730000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"Array literals seem to allow both obj. and array dest, after ...","msgtype":"m.text"},"ts":1591772773000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"i'm not really sure","msgtype":"m.text"},"ts":1591772786000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but `...{b}` is 100% redundant for `b`","msgtype":"m.text"},"ts":1591772797000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"further destructuring the rest array in an array destructuring isn't always 1:1","msgtype":"m.text"},"ts":1591772816000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"not 1:1 as in?","msgtype":"m.text"},"ts":1591772862000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"It will still take values out of the iterator in the same way, right?","msgtype":"m.text"},"ts":1591772894000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"yeah, i suppose the nested array destructuring inside rest doesn't make much sense","msgtype":"m.text"},"ts":1591772927000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ie `[a, ...[b, ...c]] =` is the same as `[a, b, ...c]`","msgtype":"m.text"},"ts":1591772942000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I can only think of one thing. correct me if i am wrong","msgtype":"m.text"},"ts":1591772948000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"the second one will still take out all values of all the iterator","msgtype":"m.text"},"ts":1591772967000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"*value out of the iterator","msgtype":"m.text"},"ts":1591772976000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"so will the first one","msgtype":"m.text"},"ts":1591772982000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i mean `[a, b]` vs `[a, ...[b]]`","msgtype":"m.text"},"ts":1591773018000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"Yes, in your example it will be the same thing","msgtype":"m.text"},"ts":1591773044000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"About `...{b}` being same as `b` - Is it exactly the same thing (if it was allowed)?","msgtype":"m.text"},"ts":1591773295000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"`...{b}` would still GET all the remaining enumerable properties, right?","msgtype":"m.text"},"ts":1591773331000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"Can that have a side effect?","msgtype":"m.text"},"ts":1591773342000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"yes, i suppose that could","msgtype":"m.text"},"ts":1591773514000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Was this willingly left out for some reason?","msgtype":"m.text"},"ts":1591773702000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"Looking through the early errors, i see that AssignmentRestProperty is restricted, but AssignmentRestElement is not","msgtype":"m.text"},"ts":1591773702000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"Also about the `[a, ...{length: b}]` case - what are the usecases?","msgtype":"m.text"},"ts":1591773984000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"Because the ... part is always a new array, it will have just numeric indexes and length property. What i can think of - get a random index value, or get length of remaining elements.","msgtype":"m.text"},"ts":1591774024000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"i don't honestly know the history","msgtype":"m.text"},"ts":1591774040000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"your thinking seems reasonable to me tho","msgtype":"m.text"},"ts":1591774049000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"got it. Last question - can i somehow track the discussions of this proposal (because it is already merged, i suppose)?","msgtype":"m.text"},"ts":1591774107000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"destructuring was in ES2015, so it's long since shipped, and never went through the current proposal process.","msgtype":"m.text"},"ts":1591774190000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"any discussions would be in the notes, not likely on github","msgtype":"m.text"},"ts":1591774200000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"👍 Makes sense. Thanks for the help @ljharb.","msgtype":"m.text"},"ts":1591774455000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"ljharb / bendtherules: object rest/spread was not in ES2015 and was a \"modern\" proposal","msgtype":"m.text"},"ts":1591804194000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"its repo is at https://github.com/tc39/proposal-object-rest-spread","msgtype":"m.text"},"ts":1591804200000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right sorry, object destructuring was but not rest, that was later","msgtype":"m.text"},"ts":1591805731000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I actually recall talking about this specific question at the time but I can't find it in the notes","msgtype":"m.text"},"ts":1591805819000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I just found this - https://github.com/tc39/notes/blob/015f9392787bd9cb86f172af3d55d0475e87db26/meetings/2017-05/may-23.md","msgtype":"m.text"},"ts":1591807734000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"Which seems like when rest in obj dest. was decided to be not allowed","msgtype":"m.text"},"ts":1591807762000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"aha, yes, that's the conversation I was thinking of","msgtype":"m.text"},"ts":1591807782000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"@Bakkot: do you remember if there was similar discussion within array dest.?","msgtype":"m.text"},"ts":1591807821000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"bendtherules: that's before my time, alas","msgtype":"m.text"},"ts":1591807831000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"array rest/spread was in ES2015, so it was discussed earlier","msgtype":"m.text"},"ts":1591807849000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Ok, I'll try to search later","msgtype":"m.text"},"ts":1591807873000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"https://github.com/tc39/notes/blob/8e8bfcbddcb29c09a10b0845a55af2e0d31b6f49/meetings/2015-07/july-28.md#66-bindingrestelement-should-allow-a-bindingpattern-ala-assignmentrestelement","msgtype":"m.text"},"ts":1591807893000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"And @ljharb - seems like there is a diff between `{a, ...{b} } ` and the basic form - because it only takes from own props","msgtype":"m.text"},"ts":1591807947000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"@Bakkot: hmm, so binding was made similar to assignment in array rest case. Wondering if the assignment case was decided on purpose or discussed earlier.","msgtype":"m.text"},"ts":1591809872000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"Ok, so some more discussions are here -   https://github.com/tc39/proposal-object-rest-spread/issues/43#issuecomment-307957597","msgtype":"m.text"},"ts":1591810648000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"In conclusion, it feels like there wasn't a strong case for obj destructuring within obj, but the array stuff was already there by that time. That wasn't removed as such.","msgtype":"m.text"},"ts":1591810775000,"senderName":"bendtherules","senderId":"bendtherules@irc"},
{"content":{"body":"bendtherules: ah true","msgtype":"m.text"},"ts":1591813993000,"senderName":"ljharb","senderId":"ljharb@irc"}
]