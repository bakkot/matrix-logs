[
{"content":{"body":"jmdyck: re the weird Return in GeneratorYield (and etc), what's the basic idea of the PR you have in mind?","msgtype":"m.text"},"ts":1620057375000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"restructure them to use a Resume step","msgtype":"m.text"},"ts":1620057417000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"as in \"resume the context which is now the top of the stack providing X as the value\"?","msgtype":"m.text"},"ts":1620057483000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(or some better phrasing than that)","msgtype":"m.text"},"ts":1620057491000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1620057534000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"cool, sounds good","msgtype":"m.text"},"ts":1620057544000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"currently, we only use \"Resume\" steps on the one 'side'. Seems like it would be useful to use them on the other side too.","msgtype":"m.text"},"ts":1620057582000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Don't have good names for the 'sides' though.","msgtype":"m.text"},"ts":1620057599000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(just for the discussion, I don't think it'll come up in spec-text)","msgtype":"m.text"},"ts":1620057665000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I would say \"we only use Resume when pushing a context, not when popping a context\", probably","msgtype":"m.text"},"ts":1620057865000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: In AsyncGeneratorYield, the call to AsyncGeneratorResolve is causing me headaches. It's just so weird.","msgtype":"m.text"},"ts":1620063768000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(I'm using 'setup' and 'generative' to name the two sides.) AsyncGeneratorResolve executes *after* the stack-pop, so the 'setup' EC is the running EC, but it executes *before* the Return that will transfer control back to the setup side.","msgtype":"m.text"},"ts":1620064620000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So I thought, just move it from pre-transfer to post-transfer (i.e., call it after the Resume step in AsyncGeneratorResumeNext). But then the other transfers to that point aren't going to be happy.","msgtype":"m.text"},"ts":1620064739000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So then I thought, well, in the \"use Resume\" world, you can still execute AsyncGeneratorResumeNext between the pop and the resume, so do that. But in the \"use Resume\" world, the steps in the \"set the code evaluation state\" become post-Resume steps (at AsyncGeneratorYield's top level) (so that they Return to the natural place).","msgtype":"m.text"},"ts":1620065038000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Which means they'd happen *after* the call to AsyncGeneratorResolve, but in the status quo they're set up *before* the call to AsyncGeneratorResolve. Which *does* make a difference, it seems.","msgtype":"m.text"},"ts":1620065136000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"hmmmmm","msgtype":"m.text"},"ts":1620065203000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"AsyncGeneratorYield calls AsyncGeneratorResolve calls Â AsyncGeneratorResumeNext which Resumes _genContext_","msgtype":"m.text"},"ts":1620065313000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"if I'm reading these algorithms correctly, `AsyncGeneratorYield` suspends the generator context, and then does AsyncGeneratorResolve, which does AsyncGeneratorResumeNext, which... un-resumes gencontext?","msgtype":"m.text"},"ts":1620065319000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah, that","msgtype":"m.text"},"ts":1620065321000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"er, *un-suspends","msgtype":"m.text"},"ts":1620065326000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I will need to read up on this part of the spec in more detail","msgtype":"m.text"},"ts":1620065365000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"haven't dug into async generators in the spec before","msgtype":"m.text"},"ts":1620065372000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so there can be two executions of AsyncGenYield for the same context that are 'live' at the same time?","msgtype":"m.text"},"ts":1620065441000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"well, not 'live', but... i don't know.","msgtype":"m.text"},"ts":1620065478000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I don't think they're both live","msgtype":"m.text"},"ts":1620065525000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it suspends, and then resumes, but it's the same context","msgtype":"m.text"},"ts":1620065534000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess the immediate-resumption behavior makes sense if you have multiple calls to `.next` which happen while it's busy `await`ing something","msgtype":"m.text"},"ts":1620065574000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but I will need to trace through more carefully","msgtype":"m.text"},"ts":1620065587000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"does control ever get back to the first one?","msgtype":"m.text"},"ts":1620065591000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I think yes - step 9 of the second AsyncGeneratorYield returns to the first one","msgtype":"m.text"},"ts":1620065896000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if I'm following it correctly","msgtype":"m.text"},"ts":1620065908000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"But AsyncGeneratorResumeNext would be the op that most recently resumed genContext.","msgtype":"m.text"},"ts":1620066196000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(when the second AGY executes step 9 Return)","msgtype":"m.text"},"ts":1620066248000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"right, so, to be precise control moves to step 19 of the first AsyncGeneratorResumeNext call, and then at step 21 it returns to the end of step 9 of the first AsyncGeneratorResolve call, and then in step 10 of that AO returns to the end of step 9 of the first AsyncGeneratorYield call","msgtype":"m.text"},"ts":1620066362000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(previous messages should begin with \"upon executing step 9 of the second AsyncGeneratorYield call\")","msgtype":"m.text"},"ts":1620066415000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"*message","msgtype":"m.text"},"ts":1620066419000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but before step 19 of AGRN, there was a transfer to and a transfer back from genContext","msgtype":"m.text"},"ts":1620066632000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"agreed, but why is that a problem?","msgtype":"m.text"},"ts":1620066685000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess because it makes the \"had most previously resumed evaluation\" part inaccurate?","msgtype":"m.text"},"ts":1620066734000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"well, that's one thing.","msgtype":"m.text"},"ts":1620066772000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"it's weird to me that AsyncGeneratorYield can invoke AsyncGeneratorResolve without transferring control to the setup side.","msgtype":"m.text"},"ts":1620066833000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So the whole AGR -> AGRN -> Resume step is happening on the generative side?","msgtype":"m.text"},"ts":1620066960000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1620066968000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"consider `g = (async function*f(){ await new Promise(res => setTimeout(res, 10)); console.log('a'); yield 0; console.log('b'); yield 1; console.log('c'); })(); g.next(); g.next(); console.log('start');`","msgtype":"m.text"},"ts":1620066973000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this example prints `start`, and then `a, b`","msgtype":"m.text"},"ts":1620066992000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"because the generator had a queued `next` after the `await` completed","msgtype":"m.text"},"ts":1620067018000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so it does both at the same time, without transferring control back","msgtype":"m.text"},"ts":1620067035000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that is, it does both the initialization and the first `yield` without transferring control back","msgtype":"m.text"},"ts":1620067103000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"g.next resolve to AsyncGenerator.prototype.next, right?","msgtype":"m.text"},"ts":1620067850000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1620067863000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"each calls AsyncGenEnqueue, which appends a request to generator.[[AsyncGeneratorQueue]].","msgtype":"m.text"},"ts":1620068188000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"The first time, generator.[[AsyncGeneratorState]] is suspendedStart, so it calls AsyncGeneratorResumeNext","msgtype":"m.text"},"ts":1620068216000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"which pops a request of the queue","msgtype":"m.text"},"ts":1620068267000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"off","msgtype":"m.text"},"ts":1620068272000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"and then pushes genContext onto the stack and resumes it","msgtype":"m.text"},"ts":1620068420000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"so it starts to execute at step 5.a in AsyncGeneratorStart","msgtype":"m.text"},"ts":1620068482000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"which goes straight into 5.a.i, evaluating the function-body","msgtype":"m.text"},"ts":1620068588000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"the firs thing is to evaluate the AwaitExpression","msgtype":"m.text"},"ts":1620068686000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"this matches my interpretation so far; do you want me to jump in with (what I understand to be) the next few steps or would you prefer to walk through it yourself?","msgtype":"m.text"},"ts":1620068825000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i think i need to take a break.","msgtype":"m.text"},"ts":1620068890000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"so yeah, jump in with the next few steps, and I'll get back to it later","msgtype":"m.text"},"ts":1620068933000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"so, the AwaitExpression evaluates, which invokes the Await macro, which suspends the generator's execution context, transferring control back to AsyncGenerator.prototype.next","msgtype":"m.text"},"ts":1620069174000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"control proceeds in evaluating the script itself, meaning it then does `g.next()` again, which calls AsyncGeneratorEnqueue","msgtype":"m.text"},"ts":1620069219000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this appends a request to the AsyncGeneratorQueue, but this time state is ~executing~, so it does not call AsyncGeneratorResumeNext, and just finishes the call without doing any execution context stack juggling","msgtype":"m.text"},"ts":1620069365000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"then we do the `console.log('start')`","msgtype":"m.text"},"ts":1620069380000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"at some later point, the timeout completes, and the `new Promise` resolves","msgtype":"m.text"},"ts":1620069405000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"eliding a bit of tracing through the promise machinery, this leads to the algorithm steps in `Await Fulfilled Functions` being executed","msgtype":"m.text"},"ts":1620069459000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this suspends the running execution context (which is, here, the context created to evaluate the \"resolve\" handler for the promise), and pushes and resumes the generator's context","msgtype":"m.text"},"ts":1620069605000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"control proceeds in the evaluation of the generator body until the `yield 0`, which does our first call to AsyncGeneratorYield","msgtype":"m.text"},"ts":1620069647000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"actually I get lost here I think","msgtype":"m.text"},"ts":1620070368000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the first AsyncGeneratorYield suspends the generator context and sets up its evaluation state, then does AsyncGeneratorResolve, which pops the `AsyncGeneratorQueue` (so it is now empty) then does AsyncGeneratorResumeNext, which, since the queue is empty, immediately returns, which seems wrong","msgtype":"m.text"},"ts":1620070448000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh, the queue is not empty, nvm","msgtype":"m.text"},"ts":1620070546000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the first call to `.next` added to the queue and did not remove it","msgtype":"m.text"},"ts":1620070576000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the first AsyncGeneratorYield suspends the generator context and sets up its evaluation state, then does AsyncGeneratorResolve, which pops the `AsyncGeneratorQueue` (so it now has *one item*) then does AsyncGeneratorResumeNext","msgtype":"m.text"},"ts":1620070601000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"at this point, the queue is not empty, and the completion from the record in the queue queue is not abrupt, and the state is ~ suspendedYield~","msgtype":"m.text"},"ts":1620070650000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so AsyncGeneratorResumeNext suspends the caller context - which, as before, is the context created to evaluate the \"resolve\" handler for the promise - and then pushes and resumes the generator context","msgtype":"m.text"},"ts":1620070712000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this moves control to step 8.a of AsyncGeneratorYield","msgtype":"m.text"},"ts":1620070792000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"now we do another Await, where we are awaiting `undefined` (which was the argument to the second call to `.next`), which I'm going to skip over because it's tedious and is not the interesting part","msgtype":"m.text"},"ts":1620070893000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and we get to 8.e of AsyncGeneratorYield, which returns control to the evaluation of the generator body","msgtype":"m.text"},"ts":1620070920000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so we console.log('b') and proceed to the second `yield`, which does our second AsyncGeneratorYield","msgtype":"m.text"},"ts":1620070935000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this, again, suspends the execution context stack and sets up its evaluation state, then does AsyncGeneratorResolve","msgtype":"m.text"},"ts":1620070964000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which pops the queue - so *now* it is empty - then does AsyncGeneratorResumeNext","msgtype":"m.text"},"ts":1620070981000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but here the queue is empty, so AsyncGeneratorResumeNext returns without touching the execution context stack","msgtype":"m.text"},"ts":1620071001000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so we go back to the AsyncGeneratorResumeNext call we were just doing, which then goes back to the AsyncGeneratorYield call we were just doing","msgtype":"m.text"},"ts":1620071037000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and then, in step 9 of this second AsyncGeneratorYield call, we finally go back to the last step of the _first_ call to AsyncGeneratorYield,","msgtype":"m.text"},"ts":1620071103000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which finishes, and finally returns control to the context created to evaluate the \"resolve\" handler for the promise, which goes about doing whatever it was doing","msgtype":"m.text"},"ts":1620071158000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the end","msgtype":"m.text"},"ts":1620071180000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"to be precise, I should say: \"in step 9 of this second AsyncGeneratorYield call, we finally go back to step 19 of the first call to AsyncGeneratorResumeNext, which returns to AsyncGeneratorResolve, which returns to the first AsyncGeneratorYield, which finishes and returns to the resolve handler","msgtype":"m.text"},"ts":1620071301000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"\"","msgtype":"m.text"},"ts":1620071302000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Hi, I have an idea for a proposal for ES. Is there anyone here I could bounce it off of?","msgtype":"m.text"},"ts":1620081499000,"senderName":"aebabis","senderId":"aebabis@irc"},
{"content":{"body":"aebabis https://es.discourse.group/c/ideas/7 is probably the ideal place","msgtype":"m.text"},"ts":1620081584000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Thank you","msgtype":"m.text"},"ts":1620081596000,"senderName":"aebabis","senderId":"aebabis@irc"},
{"content":{"body":"Bakkot: so i have a contributor patch for v8 that allows escape async in for-of, e.g. `for (\\u{61}sync of`. this seems... super gross to me?","msgtype":"m.text"},"ts":1620083477000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: is this how all lookaheads restrictions work, since the tokens are pre-StringValue?","msgtype":"m.text"},"ts":1620083501000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i guess we already allow `for (l\\u{65}t() of ...)`","msgtype":"m.text"},"ts":1620085172000,"senderName":"shu","senderId":"shu@irc"}
]