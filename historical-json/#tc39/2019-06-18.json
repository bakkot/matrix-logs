[
{"content":{"body":"https://github.com/tc39/test262/blob/master/test/built-ins/Promise/all/invoke-resolve-get-error-close.js","msgtype":"m.text"},"ts":1560824967000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shouldn't returnCount be 1 here","msgtype":"m.text"},"ts":1560824972000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"iteratorRecord.Done is false","msgtype":"m.text"},"ts":1560824986000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so IteratorClose is called","msgtype":"m.text"},"ts":1560824989000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which calls the iterator's return","msgtype":"m.text"},"ts":1560824996000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"leobalter: cc","msgtype":"m.text"},"ts":1560825001000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"seems like everything is failing it now https://test262.report/browse/built-ins/Promise/all/invoke-resolve-get-error-close.js","msgtype":"m.text"},"ts":1560825099000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(whoa unrelated but big woot that XS is on there now too!)","msgtype":"m.text"},"ts":1560825182000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah that's pretty cool","msgtype":"m.text"},"ts":1560825191000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe one day engine262 will be on there too ðŸ¤ž","msgtype":"m.text"},"ts":1560825227000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":":D","msgtype":"m.text"},"ts":1560825236000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i've implemented all the recent changes except dynamic import","msgtype":"m.text"},"ts":1560825255000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Who might understand the history behind the requirement for dynamic import \"Every call to HostImportModuleDynamically with the sameÂ referencingScriptOrModuleÂ andÂ specifierÂ arguments must conform to theÂ sameÂ set of requirements above as previous calls do.\"","msgtype":"m.text"},"ts":1560876354000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"Is that meant to allow devs to reason about the cost of dynamic import with a constant value in a loop?","msgtype":"m.text"},"ts":1560876474000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"Or does this allow some engine implementors to do some extra caching?","msgtype":"m.text"},"ts":1560876558000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"ErrorIsNullError: is there something you want to do that requirement prevents?","msgtype":"m.text"},"ts":1560876680000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"On the trusted types front.","msgtype":"m.text"},"ts":1560876712000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"we'd like to treat import() as a sink and guard it.","msgtype":"m.text"},"ts":1560876732000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"import('data:text/javascript,â€¦') has been a CSP bypass.","msgtype":"m.text"},"ts":1560876764000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"So I have an agenda, but I'm mostly trying to understand how the pieces fit together right now.","msgtype":"m.text"},"ts":1560876790000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"I'm trying to understand the need for that in light of the later requirement in HostResolveImportModule: \"This operation must be idempotent if it completes normally. Each time it is called with a specificÂ referencingScriptOrModule,Â specifierÂ pair as arguments it must return the sameÂ https://tc39.github.io/ecma262/#sec-abstract-module-recordsÂ instance.\"","msgtype":"m.text"},"ts":1560876836000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"to me that just means it can't change over the life of the program","msgtype":"m.text"},"ts":1560876849000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you could block it during linking, or you could allow it, but once it fails or succeeds, it can't change out from under you","msgtype":"m.text"},"ts":1560876875000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"My question is more about the intent.","msgtype":"m.text"},"ts":1560876890000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"Domenic and littledan can probably speak to that best - the above is just my interpretation of the intent","msgtype":"m.text"},"ts":1560876911000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"It seems like an implemenation that did not have the problem would cause confusion.","msgtype":"m.text"},"ts":1560876911000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"Thanks","msgtype":"m.text"},"ts":1560876920000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"I'll reach out to them.","msgtype":"m.text"},"ts":1560876987000,"senderName":"ErrorIsNullError","senderId":"ErrorIsNullError@irc"},
{"content":{"body":"ErrorIsNullError: as in `import(x)` in one area could work while `import(x)` in another area fails?","msgtype":"m.text"},"ts":1560880813000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think the intention is that when it succeeds it must always be the same result, not that once it succeeds it must always succeed","msgtype":"m.text"},"ts":1560880864000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Domenic: ^","msgtype":"m.text"},"ts":1560881160000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: \"That is, if the host environment takes the success path once for a given referencingScriptOrModule, specifier pair, it must always do so, and the same for the failure path.\" https://tc39.es/ecma262/#sec-hostimportmoduledynamically","msgtype":"m.text"},"ts":1560881512000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah in a given module","msgtype":"m.text"},"ts":1560881569000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for csp wouldn't it be different sources","msgtype":"m.text"},"ts":1560881604000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah right, true","msgtype":"m.text"},"ts":1560881711000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"actually for different sources","msgtype":"m.text"},"ts":1560881768000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the rule is always for (referrer, specifier)","msgtype":"m.text"},"ts":1560881800000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not the resulting module","msgtype":"m.text"},"ts":1560881804000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Right, in different modules the resolution can be different, e.g., due to a different base URL (and with import maps, due to scoped maps)","msgtype":"m.text"},"ts":1560889139000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"So this is what \"with the same referencingScriptOrModule and specifier arguments \" is getting at","msgtype":"m.text"},"ts":1560889158000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"and i guess import maps can already remap the specifier for a given module to be \"nothing\" as well?","msgtype":"m.text"},"ts":1560890857000,"senderName":"ljharb","senderId":"ljharb@irc"}
]