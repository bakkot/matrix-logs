[
{"content":{"body":"do expressions would not need to specify this case as currently proposed because I would make it an early error because no human is capable of reasoning about it","msgtype":"m.text"},"ts":1600395325000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"specifically I would make it an early error for the last statement executed in your `do` to be a `break`","msgtype":"m.text"},"ts":1600395372000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"jmdyck: just pushed changes to 2007","msgtype":"m.text"},"ts":1600395442000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I _think_ it's all coherent now","msgtype":"m.text"},"ts":1600395448000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"including Date","msgtype":"m.text"},"ts":1600395451000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"there might be some stray \"integer\"/\"integral Number\" issues in some prose","msgtype":"m.text"},"ts":1600395559000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"okay, I'll try to look at it","msgtype":"m.text"},"ts":1600395636000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Bakkot: what about `do { if (true) { break } }`","msgtype":"m.text"},"ts":1600398851000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek no changes on that front; I continue to think breaking through a `do` is a bad idea","msgtype":"m.text"},"ts":1600398942000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what does \"no changes\" mean","msgtype":"m.text"},"ts":1600398969000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's not the last statement","msgtype":"m.text"},"ts":1600398974000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"no changes since the last several times we discussed it, I mean","msgtype":"m.text"},"ts":1600398987000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah ok","msgtype":"m.text"},"ts":1600398993000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"was slightly hopeful you had warmed up to it in certain positions :(","msgtype":"m.text"},"ts":1600399046000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i am quite bose-einstein condensate on flow control in do expressions","msgtype":"m.text"},"ts":1600405158000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot ljharb: so would this be sufficient for a possible do expression? a `AssignmentExpression: do Block` with Early errors preventing any directly nested `return`, `break`, or `continue`?","msgtype":"m.text"},"ts":1600450819000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"would that interact unfortunately with any annex b sloppy mode things?","msgtype":"m.text"},"ts":1600452564000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"don't need early errors","msgtype":"m.text"},"ts":1600452745000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"just `Block[~Yield, ~Return, ~Await]`","msgtype":"m.text"},"ts":1600452757000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh we don't have params for break/continue","msgtype":"m.text"},"ts":1600452788000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I'm not trying to define how we do define this yet, but conceptually, if we can move the proposal ahead this way I'd love to invest more time.","msgtype":"m.text"},"ts":1600452955000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"ljharb: I believe devsnek's suggestion is in the direction of what I'd do. TBH, I'd try the minimum limiting rules just to make it go ahead. Ideally, do expression would need to work seamlessly with anywhere you have a block","msgtype":"m.text"},"ts":1600453045000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"it should really just be `Block[~Return]`","msgtype":"m.text"},"ts":1600453070000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"dunno why i put ~Yield and ~Await","msgtype":"m.text"},"ts":1600453077000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ideally it would be `Block` though :(","msgtype":"m.text"},"ts":1600453091000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: I agree. The idea on blocking completions not Normal or Abrupt is just a helpless try to make the proposal advance","msgtype":"m.text"},"ts":1600453225000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"leobalter: I’m talking about the sloppy mode function declaration in block hoisting stuff","msgtype":"m.text"},"ts":1600453537000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the annex b thing","msgtype":"m.text"},"ts":1600453549000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I’m relatively sure we wouldn’t want to propagate that to do expressions","msgtype":"m.text"},"ts":1600453561000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"does it apply in classes","msgtype":"m.text"},"ts":1600453628000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"seems like a lint concern. like, anyone writing script today in sloppy mode, using a new feature  (do expr) and declaring functions inside","msgtype":"m.text"},"ts":1600453654000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"they can pick their own poison by themselves","msgtype":"m.text"},"ts":1600453666000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"honestly like","msgtype":"m.text"},"ts":1600453691000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"whatever wrapping a statement in a block does","msgtype":"m.text"},"ts":1600453698000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ideally `do expr` is just a way to capture the completion value of a block","msgtype":"m.text"},"ts":1600453699000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"adding a `do` to the front of it should not change that","msgtype":"m.text"},"ts":1600453719000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it should just change where the block can be","msgtype":"m.text"},"ts":1600453726000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek it seems we are pretty much in sync here","msgtype":"m.text"},"ts":1600453745000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"leobalter: I’m saying it’s complexity impls probably don’t want in more places","msgtype":"m.text"},"ts":1600453837000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"isn't it more complex to add more rules","msgtype":"m.text"},"ts":1600453851000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I read do expr: let's capture the completion of this block.","msgtype":"m.text"},"ts":1600453889000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"It sounds fair enough to disallow return because default parameters","msgtype":"m.text"},"ts":1600453909000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"but otherwise the extra limits sound like too complex to resolve a problem I believe it's up to the user choice","msgtype":"m.text"},"ts":1600453956000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"ljharb: please help me out on this: is there anything else in the Annex B concerns other than the function declaration?","msgtype":"m.text"},"ts":1600454036000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"you can disallow return in default params without disallowing it everywhere","msgtype":"m.text"},"ts":1600454047000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but people just really dislike the idea of it for some reason","msgtype":"m.text"},"ts":1600454056000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which is to say, i would expect `FormalParameters` to carry the `~Return`, i wouldn't expect do expressions to know anything about it","msgtype":"m.text"},"ts":1600454130000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"let's say do expr ships with `[~Return, ~Break, ~Continue]` + the Annex B for function declarations is not applied here. Is there anything else? I could do that","msgtype":"m.text"},"ts":1600454140000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"It's a fair trade in for me. I'd love to discuss this format, possibly championing the proposal this way","msgtype":"m.text"},"ts":1600454202000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"those might comprehend the corner cases shu mentioned before, hopefully","msgtype":"m.text"},"ts":1600454250000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"Bakkot: any thoughts?","msgtype":"m.text"},"ts":1600454445000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"leobalter I feel pretty strongly that we should forbid other sharp edges, like ending your `do` in a loop","msgtype":"m.text"},"ts":1600454911000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lint rule tho","msgtype":"m.text"},"ts":1600454966000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's not just that users will get cut on those edges; it's also that implementations are not currently consistent because these cases are super weird and so we'd be exposing users to a host of compatibility bugs","msgtype":"m.text"},"ts":1600454970000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek we should default to leaving things out. if we are adding a syntactic form which we think everyone should forbid in their programs, instead of doing that we should leave the thing out.","msgtype":"m.text"},"ts":1600455022000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i don't think people should forbid it","msgtype":"m.text"},"ts":1600455148000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"because you think it has a reasonable semantics which future readers of the code will understand, or because you don't think anyone will ever try to write this?","msgtype":"m.text"},"ts":1600455206000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the former, given what the spec says at least","msgtype":"m.text"},"ts":1600455242000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"on that point I disagree quite strongly","msgtype":"m.text"},"ts":1600455257000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"would definitely need to make sure implementations are correct first","msgtype":"m.text"},"ts":1600455263000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: because there are different opinions it seems better to enforce it in a way where you don't clobber the others","msgtype":"m.text"},"ts":1600455867000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"even if all the impls and spec did the same thing, i agree strongly with Bakkot that users won't have a reasonable intuition about them","msgtype":"m.text"},"ts":1600455873000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek when the different opinions are \"this wouldn't be harmful\" and \"this would definitely be harmful\", the correct path is to not add the thing","msgtype":"m.text"},"ts":1600456248000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ConciseBody is AssignmentExpression","msgtype":"m.text"},"ts":1600456255000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so why is this `async () => ({}) = 1`","msgtype":"m.text"},"ts":1600456263000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"equiv to `(async () => ({})) = 1`","msgtype":"m.text"},"ts":1600456271000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and not `async () => (({}) = 1)`","msgtype":"m.text"},"ts":1600456282000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: for security i agree","msgtype":"m.text"},"ts":1600456387000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for everything","msgtype":"m.text"},"ts":1600456403000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"loops in do expressions considered harmful","msgtype":"m.text"},"ts":1600456416000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if I'm wrong, there's just a minor inconsistency where you reach for a thing and it's not there, which we could maybe repair later","msgtype":"m.text"},"ts":1600456420000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if you're wrong, there's a sharp edge people will need to lint against or cut themselves on for decades","msgtype":"m.text"},"ts":1600456444000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i mean that's true of basically everything that causes any disagreement","msgtype":"m.text"},"ts":1600456489000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lots of things have disagreement on aesthetic grounds, not \"people will expect this to do something very different from what it actually does\" grounds","msgtype":"m.text"},"ts":1600456789000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"re the parsing question, I don't think you're correct about how it's interpreted; why do you think that's the interpretation?","msgtype":"m.text"},"ts":1600456801000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"cuz engines throw a syntax error?","msgtype":"m.text"},"ts":1600456836000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the syntax error is because `({})` isn't a valid LHS","msgtype":"m.text"},"ts":1600456861000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"try it with `a = 1` instead of `({}) = 1`","msgtype":"m.text"},"ts":1600456869000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"isn't that an assignment pattern?","msgtype":"m.text"},"ts":1600456876000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there's an early error for parenthesized nontrivial LHSes","msgtype":"m.text"},"ts":1600456897000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"hmmmm","msgtype":"m.text"},"ts":1600456997000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is that just ObjectLiteral and ArrayLiteral?","msgtype":"m.text"},"ts":1600457010000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1600457017000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"weird","msgtype":"m.text"},"ts":1600457019000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"parenthesizing an LHS is weird","msgtype":"m.text"},"ts":1600457031000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it's allowed for `a` and `a.b` because that was shipped and then people depended on it","msgtype":"m.text"},"ts":1600457048000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but that wasn't extended to the new forms","msgtype":"m.text"},"ts":1600457060000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"going back to yesterday's \"`break` in a `finally` block\" discussion, does anybody know the rationale for the \"If F.[[Type]] is normal\" guard?","msgtype":"m.text"},"ts":1600462105000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"like, this behavior doesn't really affect anybody right now but thinking it though, it seems like it would be terrible to have exposed","msgtype":"m.text"},"ts":1600462153000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"seems like if the `finally` block's completion value *can* be propagated then it should *always* be propagated","msgtype":"m.text"},"ts":1600462208000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(by that I mean, the question is whether `finally` exists and not whether it completed normally)","msgtype":"m.text"},"ts":1600462233000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that guard is necessary so that `try { throw 0; } finally { console.log('cleanup') }` throws","msgtype":"m.text"},"ts":1600463252000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which is what I'd want to happen, and also the precedent from Java and friends","msgtype":"m.text"},"ts":1600463289000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh wow I see","msgtype":"m.text"},"ts":1600463730000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: there's similar semantics in promise `.finally` as well, for the same reason","msgtype":"m.text"},"ts":1600464850000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ie that `rejected.finally(() => { console.log('cleanup'); })` should still be rejected","msgtype":"m.text"},"ts":1600464868000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah I see that. this was predicated on my thinking that they were different but it seems that they aren't...","msgtype":"m.text"},"ts":1600464882000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"there is one difference between syntactic finally and promise finally, tho - namely that `return x` in syntactic finally overrides the return value for the function, but is a noop in a promise finally","msgtype":"m.text"},"ts":1600465051000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"which is kind of necessary since in a promise finally you can't actually tell if a `return` happened","msgtype":"m.text"},"ts":1600465288000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`try { throw 0; } finally { return console.log('cleanup') }` will not throw","msgtype":"m.text"},"ts":1600465429000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"yikes","msgtype":"m.text"},"ts":1600465481000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"right, that was the piece of finally syntax that can't be replicated non-syntactically","msgtype":"m.text"},"ts":1600465519000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I mean Promise#finally is different in general in that abrupt completions other than `throw` can't make sense from within a lambda","msgtype":"m.text"},"ts":1600465610000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"but \"we're throwing! no wait sorry we're returning!\" is...really something","msgtype":"m.text"},"ts":1600465628000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"works the other way around too, perhaps more naturally","msgtype":"m.text"},"ts":1600465668000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`try { return 0; } finally { throw 'oops!' }`","msgtype":"m.text"},"ts":1600465684000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but my favorite is still break: `label: try { throw 0; } finally { console.log('no.'); break label; } console.log('this is reached');`","msgtype":"m.text"},"ts":1600465735000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1600466005000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":":thanks_i_hate_it:","msgtype":"m.text"},"ts":1600466025000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"those are... awful","msgtype":"m.text"},"ts":1600466203000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"`break me;`","msgtype":"m.text"},"ts":1600466243000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek what bug does https://github.com/engine262/engine262/blob/2b21fb9d9aa991d66417e714b581e4c14774c8c2/test/test262/skiplist#L9 refer to?","msgtype":"m.text"},"ts":1600472111000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: the nan one","msgtype":"m.text"},"ts":1600472136000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah, sure","msgtype":"m.text"},"ts":1600472143000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"nan is out of range and crashes","msgtype":"m.text"},"ts":1600472145000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"fun fun","msgtype":"m.text"},"ts":1600472149000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"btw I found a bunch of other cases of that","msgtype":"m.text"},"ts":1600472155000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"do you mind if I take over your PR?","msgtype":"m.text"},"ts":1600472158000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh i had a pr","msgtype":"m.text"},"ts":1600472166000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i completely forgot","msgtype":"m.text"},"ts":1600472168000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah feel free","msgtype":"m.text"},"ts":1600472183000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hmm i guess rick just updated those assignment expression tests","msgtype":"m.text"},"ts":1600472199000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"gonna become normative because I found cases where engines diverged, so there's not a single obvious interpretation","msgtype":"m.text"},"ts":1600472200000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"was it not just jsc being weird","msgtype":"m.text"},"ts":1600472212000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"also, unrelated: is this an actual skiplist, or is it xfails?","msgtype":"m.text"},"ts":1600472222000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"just skips them","msgtype":"m.text"},"ts":1600472244000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":":(","msgtype":"m.text"},"ts":1600472246000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i've been meaning to add xfail but","msgtype":"m.text"},"ts":1600472248000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i keep forgetting","msgtype":"m.text"},"ts":1600472252000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1600472256000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"everything there is expected to fail","msgtype":"m.text"},"ts":1600472267000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"open a good-first-issue, someone might take care of it","msgtype":"m.text"},"ts":1600472271000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh i remember the problem","msgtype":"m.text"},"ts":1600472317000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"some assertion failures can leave the engine in a bad state","msgtype":"m.text"},"ts":1600472343000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and i don't spin up a new node process for each test","msgtype":"m.text"},"ts":1600472357000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i suppose it could spin up a worker for each xfail test","msgtype":"m.text"},"ts":1600472389000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well, or just leave those as skipped","msgtype":"m.text"},"ts":1600472505000,"senderName":"Bakkot","senderId":"Bakkot@irc"}
]