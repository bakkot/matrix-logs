[
{"content":{"body":"devsnek https://github.com/bakkot/transcribe-to-gdocs","msgtype":"m.text"},"ts":1616544723000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"thx!","msgtype":"m.text"},"ts":1616544737000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"gonna make a version of that for discord voice calls","msgtype":"m.text"},"ts":1616544748000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this will work for that without modification","msgtype":"m.text"},"ts":1616545001000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it transcribes your computer's audio out directly","msgtype":"m.text"},"ts":1616545015000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"doesn't hook into zoom or whatever","msgtype":"m.text"},"ts":1616545021000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(that said, the way I've been doing it requires a second computer, so that I can also hear and participate in the call myself)","msgtype":"m.text"},"ts":1616545054000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(or rather it transcribes audio _in_, and I have my computer route audio out to audio in)","msgtype":"m.text"},"ts":1616545075000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: you get a separate audio stream for each person on discord","msgtype":"m.text"},"ts":1616545162000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so if i hook it up directly","msgtype":"m.text"},"ts":1616545165000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i can label them by username automatically","msgtype":"m.text"},"ts":1616545172000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh, nice","msgtype":"m.text"},"ts":1616545181000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"well technically this is all undocumented","msgtype":"m.text"},"ts":1616545201000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but hey if it works it works","msgtype":"m.text"},"ts":1616545210000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you'll probably have to muck around with the internals of https://github.com/gillesdemey/node-record-lpcm16 a bit","msgtype":"m.text"},"ts":1616545562000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(or replace it outright; it's just a very simple wrapper around `sox --default-device --type wav -`, so if you already have access to the audio streams you need, as streams, you don't need it at all)","msgtype":"m.text"},"ts":1616545783000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: apparently you can pass words that are likely to be spoken to make it more accurate (might help reduce the string replacement)","msgtype":"m.text"},"ts":1616549283000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://cloud.google.com/speech-to-text/docs/reference/rest/v1/RecognitionConfig#SpeechContext","msgtype":"m.text"},"ts":1616549289000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i tried it and didn't have much luck, so went back to my regexes","msgtype":"m.text"},"ts":1616549305000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"f","msgtype":"m.text"},"ts":1616549356000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"did you try diarization","msgtype":"m.text"},"ts":1616549371000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"uhhhhh can't remember","msgtype":"m.text"},"ts":1616549650000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if I did I didn't get very far","msgtype":"m.text"},"ts":1616549667000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"possibly it only works with certain models?","msgtype":"m.text"},"ts":1616549672000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: i found you can get rid of the custom writable stream by using stream pipe/unpipe instead, since that automatically handles backpressure","msgtype":"m.text"},"ts":1616596346000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Hi. Had a feature idea and TC39 website led me here.","msgtype":"m.text"},"ts":1616601326000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"The feature is to add well-known symbols Object.{keys,values,entries} to Object.prototype.","msgtype":"m.text"},"ts":1616601345000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"The rationale is that I want to be able to keep chaining through arrays even with an object in the middle.","msgtype":"m.text"},"ts":1616601427000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"An example would be: const x = (array.filter(x=>x).map(x=>f(x)).reduce(intoObjectSomehow)[Object.values]().map(y=>g(y)));","msgtype":"m.text"},"ts":1616601434000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"Since it would be a well-known symbol on Object, it would avoid the for-in and in-keyword and similar things picking up on it, but would otherwise be a safe and encapsulated way of adding .toKeys(), .toValues(), and .toEntries() to every object.","msgtype":"m.text"},"ts":1616601507000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"sdegutis: that's not a viable approach for a number of reasons. one is that many things inherit from Object.prototype for which these instance methods would be nonsensical, like `true[Symbol.values]()`. one is that it's not ergonomic to access symbol methods, which is why they're typically used for protocols and not accessed directly. another is that not all objects inherit from Object.prototype (`Object.create(null)`, or the `ns` in `import *","msgtype":"m.text"},"ts":1616601669000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"as ns`)","msgtype":"m.text"},"ts":1616601669000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Ah good points.","msgtype":"m.text"},"ts":1616601724000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"If your goal is chaining with functions that aren't prototype methods, you may be interested in the pipeline operator proposal https://github.com/tc39/proposal-pipeline-operator","msgtype":"m.text"},"ts":1616601730000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I suppose the |> thing solves it also, maybe.","msgtype":"m.text"},"ts":1616601731000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"Yeah that.","msgtype":"m.text"},"ts":1616601739000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"it does indeed","msgtype":"m.text"},"ts":1616601740000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Well I hope it gets here soon. Lodash and ramda do not play very well with TypeScript.","msgtype":"m.text"},"ts":1616601757000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"Or maybe I'm just using it wrong.","msgtype":"m.text"},"ts":1616601766000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"Anyway thanks ljharb for your feedback.","msgtype":"m.text"},"ts":1616601773000,"senderName":"sdegutis","senderId":"sdegutis@irc"},
{"content":{"body":"np","msgtype":"m.text"},"ts":1616601778000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`const x = array.filter(x=>x).map(x=>f(x)).reduce(intoObjectSomehow) |> Object.values(#).map(y=>g(y))` hell yeah pipeline letting every call pattern integrate into method chains","msgtype":"m.text"},"ts":1616602301000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"We should capture this as a real-world use-case in the slides.","msgtype":"m.text"},"ts":1616602485000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And by \"we\" I suppose I mean \"me\".","msgtype":"m.text"},"ts":1616602490000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: my biggest one is `Object.fromEntries(Object.entries(obj).filter(…).map(…))` etc","msgtype":"m.text"},"ts":1616602565000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"TabAtkins: will be super nice to do `obj |> Object.entries(?) |> ?.filter(…).map(…) |> Object.fromEntries(?)` or similar","msgtype":"m.text"},"ts":1616602603000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: i think you broke the grouping of the legacy box around the __define/lookup__ methods","msgtype":"m.text"},"ts":1616610763000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"they each have a separate one now","msgtype":"m.text"},"ts":1616610771000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"whoops, it was a tricky rebase. Can you fix it? :-) if not, I’ll try to fix it later today","msgtype":"m.text"},"ts":1616610803000,"senderName":"ljharb","senderId":"ljharb@irc"}
]