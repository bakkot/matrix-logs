[
{"content":{"body":"devsnek: what does .enumerate() do","msgtype":"m.text"},"ts":1557245409000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: goes from an iterator of [V1, V2, V3] to [[0, V1], [1, V2], [2, V3]]","msgtype":"m.text"},"ts":1557245441000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"from my experience with iteration in rust and python its a very useful function","msgtype":"m.text"},"ts":1557245458000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Huh. Maybe not the best name.","msgtype":"m.text"},"ts":1557245475000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I can see it though","msgtype":"m.text"},"ts":1557245481000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I've often had to keep a counter when iterating maps/sets","msgtype":"m.text"},"ts":1557245493000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"there's an argument that map can replace enumerate","msgtype":"m.text"},"ts":1557245516000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but i think having both is okay","msgtype":"m.text"},"ts":1557245522000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you'd have to add an index to map","msgtype":"m.text"},"ts":1557245573000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and i'm not a fan of map on iterators having an index","msgtype":"m.text"},"ts":1557245581000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Yeah, I tend to agree","msgtype":"m.text"},"ts":1557245591000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i really need to write all these methods for the async prototype","msgtype":"m.text"},"ts":1557245631000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe we can just bring up \"specifying async generators\" at the june meeting","msgtype":"m.text"},"ts":1557245702000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if map shouldn’t have an index then why have enumerate? map having an index seems appropriate, even if we don’t call it index","msgtype":"m.text"},"ts":1557245767000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"iterators don't have well defined starts and ends","msgtype":"m.text"},"ts":1557245797000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in a generic sense","msgtype":"m.text"},"ts":1557245801000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"enumerate explicitly adds a counter","msgtype":"m.text"},"ts":1557245808000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but map is just going from value to value, there's no explicit sense of counting there","msgtype":"m.text"},"ts":1557245822000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right but i can use enumerate and ignore the counter, so why would i need map","msgtype":"m.text"},"ts":1557245853000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"enumerate and ignore the counter?","msgtype":"m.text"},"ts":1557245868000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"enumerate doesn't take a mapfn","msgtype":"m.text"},"ts":1557245878000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it just introduces a counter into your iterator chain","msgtype":"m.text"},"ts":1557245906000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh, hm","msgtype":"m.text"},"ts":1557245924000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I’d rename it then but i think i get what it’d be for","msgtype":"m.text"},"ts":1557245946000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"well its called enum or enumerate in other langs","msgtype":"m.text"},"ts":1557245985000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't want js to be the special kid","msgtype":"m.text"},"ts":1557245994000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"enumerate in ruby is what it makes me think of","msgtype":"m.text"},"ts":1557246173000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"other langs have a method called “enumerate” that inject an index into a new lazy iterator?","msgtype":"m.text"},"ts":1557246206000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"at least python, c#, and rust","msgtype":"m.text"},"ts":1557246221000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"actually c# has it twice, because such is the way with c#","msgtype":"m.text"},"ts":1557246254000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Select and Enumerate","msgtype":"m.text"},"ts":1557246259000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ruby apparently calls this `each_with_index`","msgtype":"m.text"},"ts":1557246294000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that sounds like a clearer name to me, modulo snake case","msgtype":"m.text"},"ts":1557246311000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or just “withIndex()” taking no arguments","msgtype":"m.text"},"ts":1557246331000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"perhaps","msgtype":"m.text"},"ts":1557246359000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Ruby's probably not the best go-to for standard namings of things, hehe","msgtype":"m.text"},"ts":1557247327000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"perhaps, but “enumerate” already has a meaning in js and “add an index” isn’t it","msgtype":"m.text"},"ts":1557247740000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"everything has seven meanings","msgtype":"m.text"},"ts":1557247769000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb: yeah I suppose that's fair","msgtype":"m.text"},"ts":1557247800000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"devsnek: xkcd standards dot jpg","msgtype":"m.text"},"ts":1557247819000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I think the conception is less about \"adding an index\" and more about \"counting off the list items\" (i.e. enumerating them), but it's tricky when you've got an `enumerable` property so fundamental to the language that indicates not ability to *be* an enumeration but rather ability to be *included* in an enumeration","msgtype":"m.text"},"ts":1557248286000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"oh yeah that thing","msgtype":"m.text"},"ts":1557248352000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"never thought about how unfortunate that name choice is until now","msgtype":"m.text"},"ts":1557248554000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"but also, \"enumerate\" is a verb that describes what `.forEach` and friends does.","msgtype":"m.text"},"ts":1557248677000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the index is already there, it's not added by the verb","msgtype":"m.text"},"ts":1557248693000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah but that's not in conflict","msgtype":"m.text"},"ts":1557248761000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"if your collection has a `.forEach` method then there's nothing further to do, right?","msgtype":"m.text"},"ts":1557248784000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"though that is admittedly different from the other languages mentioned given the dynamicness of \"hey there's a second param here if you want it\"","msgtype":"m.text"},"ts":1557249032000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"in the others, iterating over a list would just give you the items and you'd need to explicit request to get tuples instead","msgtype":"m.text"},"ts":1557249107000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"what would happen with `['a', 'b', 'c'].entries().withIndex().withIndex()`? would it just keep nesting deeper entries each time?","msgtype":"m.text"},"ts":1557249243000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ha, hadn't thought to try that before, but yeah, Python and Rust give `[(0, (0, 'a')), (1, (1, 'b')), (2, (2, 'c'))]`","msgtype":"m.text"},"ts":1557249548000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(if you make a list out of it again that is)","msgtype":"m.text"},"ts":1557249570000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"is the idea here something like `%IteratorPrototype%.withIndex = function*(){ let i=0; for(let v of this) yield [i++, v] }`?","msgtype":"m.text"},"ts":1557251905000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"or maybe `%IteratorPrototype%.map = (call => function*(callbackfn, thisarg){ let i=0; for(let v of this) yield call(callbackfn, thisarg, v, i++, this) })(Function.prototype.call.bind(Function.prototype.call))`?","msgtype":"m.text"},"ts":1557251906000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"gibson042: for withIndex, yes","msgtype":"m.text"},"ts":1557251974000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"harder for me to parse that latter one","msgtype":"m.text"},"ts":1557251985000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the latter is analogous to Array.prototype.map; it would be used like e.g. `str[Symbol.iterator]().map((codePoint, cpIndex) => …)`","msgtype":"m.text"},"ts":1557252220000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"or perhaps more appropriately, `.map((element, index) => [index, element])` (which is identical to withIndex)","msgtype":"m.text"},"ts":1557252333000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"gotcha","msgtype":"m.text"},"ts":1557252339000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I think there's a larger discussion as to whether we think generic iterators have indices or not","msgtype":"m.text"},"ts":1557252862000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"If we said they have indices then lots of operations become more applicable, e.g. findIndex, indexOf, ...","msgtype":"m.text"},"ts":1557252907000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I really think \"index\" might be the wrong word in that case (Rust and Python docs just say \"(iteration) count\", say) -- 'cause the output from a generator, say, can be counted but that doesn't mean it's an indexed collection","msgtype":"m.text"},"ts":1557253814000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i mean sure, but it's basically just a zero-based counter","msgtype":"m.text"},"ts":1557255191000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`.withEventualIndexWhenSpreadIntoAnArray`","msgtype":"m.text"},"ts":1557255207000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I don't think making a distinction between indices and iteration count is useful","msgtype":"m.text"},"ts":1557255245000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i agree, but i don't think `.withIndex` would need to imply that generic iterators have indices either","msgtype":"m.text"},"ts":1557255340000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Domenic: +1 to larger discussion about whether iterators have indices","msgtype":"m.text"},"ts":1557255348000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"+1 ljharb. But if we changed iterator.map(el => ...) to iterator.map((el, index) => ...) then I think we're in the larger-discussion territory.","msgtype":"m.text"},"ts":1557255387000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"fair point, agreed!","msgtype":"m.text"},"ts":1557255412000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`.withIndex().map` is simple enough, assuming the methods are lazy","msgtype":"m.text"},"ts":1557255431000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I tend to think iterators do have indices, but that is maybe my math background leaking in (\"has an iterator\" means \"enumerable\" means \"has a bijection with N\" means \"has indices\")","msgtype":"m.text"},"ts":1557255439000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I tend to think so too, but people get really upset when I suggest sets have indices","msgtype":"m.text"},"ts":1557255462000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"bah","msgtype":"m.text"},"ts":1557255473000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"some people get upset when i remind them that JS Sets have an explicit ordering too","msgtype":"m.text"},"ts":1557255479000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"abstract sets don't, but JS's Sets do","msgtype":"m.text"},"ts":1557255485000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1557255488000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(aside: that reminds me I gotta get on specing for-in order for this meeting)","msgtype":"m.text"},"ts":1557255505000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"While we're all here, anyone have any suggested fun examples for JSON modules? Along the lines of https://html.spec.whatwg.org/multipage/scripting.html#script-type-module-example-2","msgtype":"m.text"},"ts":1557255567000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Otherwise I'm just gonna import a config file","msgtype":"m.text"},"ts":1557255579000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: we use a JSON file for translation phrases in airbnb, so we effectively have `import Polyglot from 'node-polyglot'; import phrases from './phrases.json'; const p = new Polyglot(); p.extend(phrases);` altho i suppose that's also a config file","msgtype":"m.text"},"ts":1557255661000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Domenic: https://catalog.data.gov/dataset?res_format=JSON","msgtype":"m.text"},"ts":1557255669000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Oooh these are both nice.","msgtype":"m.text"},"ts":1557255682000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"What is a fun open data set... i.e. not vehicle crash deaths...","msgtype":"m.text"},"ts":1557255732000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"https://github.com/jdorfman/awesome-json-datasets","msgtype":"m.text"},"ts":1557255777000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think I'll go with people in space right now http://api.open-notify.org/astros.json","msgtype":"m.text"},"ts":1557255806000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"spaaaace","msgtype":"m.text"},"ts":1557255833000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if you want to be meta, https://github.com/mdn/browser-compat-data/tree/master/javascript","msgtype":"m.text"},"ts":1557255836000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Oh wow that's tempting hrm","msgtype":"m.text"},"ts":1557255848000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But without rawgit there are no headers","msgtype":"m.text"},"ts":1557255857000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i found raw.githack.com that can replace it","msgtype":"m.text"},"ts":1557255884000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Nice find. Probably not good to put in the HTML spec, but I'll still use it.","msgtype":"m.text"},"ts":1557255916000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: JSON translations are also used at GoDaddy similarly","msgtype":"m.text"},"ts":1557255960000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"we do have configs per env as well but that would combine import() as well which idk if is desired","msgtype":"m.text"},"ts":1557256009000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Bakkot: your math explanation makes a lot of sense -- I think for me it's that the act of iteration is imperative / temporal and so such an \"index\" would have to be a time, whereas an index in a collection is a location. it's convenient that math and FP can just step outside of time and view those as the same, but yeah 😅","msgtype":"m.text"},"ts":1557258391000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(anyway I'm not really objecting to `withIndex`, it's just the implication that `indexOf` would follow that felt like \"whoa hang on a sec\")","msgtype":"m.text"},"ts":1557258520000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"`indexOf` is super weird for iterators, because they represented ephemeral streams","msgtype":"m.text"},"ts":1557261537000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"getting an index into an ephemeral stream is not generally a useful thing to do","msgtype":"m.text"},"ts":1557261549000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right! ephemeral is the perfect word","msgtype":"m.text"},"ts":1557261837000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i'm not a fan of map having an index","msgtype":"m.text"},"ts":1557263064000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think you should be explicit to introduce a counter","msgtype":"m.text"},"ts":1557263079000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: i agree that an iterator over X where X has indices would mean that the items of that iterator also technically have indices","msgtype":"m.text"},"ts":1557263186000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: that's not really the case I was talking about","msgtype":"m.text"},"ts":1557263210000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"was talking about arbitrary iterators","msgtype":"m.text"},"ts":1557263216000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you could also say \"this is the fifth item this map iterator has seen\"","msgtype":"m.text"},"ts":1557263249000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but it seems rather arbitrary to me","msgtype":"m.text"},"ts":1557263253000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and other languages seem to agree","msgtype":"m.text"},"ts":1557263259000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"map iterator being iterator.map() not Map.p.values()","msgtype":"m.text"},"ts":1557263279000,"senderName":"devsnek","senderId":"devsnek@irc"}
]