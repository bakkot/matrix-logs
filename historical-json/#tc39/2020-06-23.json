[
{"content":{"body":"Hello, I have a question about the Proxy object. As far as I understand, the goal of the proxy object was to provide security in JavaScript program communications.","msgtype":"m.text"},"ts":1592928499000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"But, in the current specification, a proxy does not support to handle its internal slots such as [[RegExpMatcher]], [[DateValue]], and so on. Thus, once we wrap an object by a proxy, we lose a part of its identity. And, there are many cases to confirm an identity of a given object by checking the existence of such an internal slot (one of the","msgtype":"m.text"},"ts":1592928509000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"examples is the use of the internal function \"RequireInternalSlot\").","msgtype":"m.text"},"ts":1592928509000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"I believe that everyone who is working on the specification aware of this issue. In the case of \"Array.isArray\", it checks its [[ProxyTarget]] when the given object is a proxy.","msgtype":"m.text"},"ts":1592928520000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":" But, I'm just wondering why they provide only a limited feature by a proxy. Is there any other solution to restrict the capability of such objects? Or, is there any reason not to handle the internal slots by a proxy object?","msgtype":"m.text"},"ts":1592928528000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"proxies alone don’t provide the security guarantees you’re referencing; you also need a membrane implementation.","msgtype":"m.text"},"ts":1592928630000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Ah. Of course. I'm implementing membrane.","msgtype":"m.text"},"ts":1592928649000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"But, once you pass an object via membrane, on the other-side, you lose the identity of a special object such as Date.","msgtype":"m.text"},"ts":1592928679000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"because the proxy does not allow to bypass the internal slots of Date object.","msgtype":"m.text"},"ts":1592928704000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"Simple example.","msgtype":"m.text"},"ts":1592928756000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"```var a = /abc/```","msgtype":"m.text"},"ts":1592928767000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"`var b = new Proxy(a, {})`","msgtype":"m.text"},"ts":1592928775000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"`\"abc\".match(a) === true`","msgtype":"m.text"},"ts":1592928787000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"`\"abc\".match(b)` throws an exception.","msgtype":"m.text"},"ts":1592928797000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"Ah. I was disconnected. Is there anyone answered my question? sorry.","msgtype":"m.text"},"ts":1592929177000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"Yoonseok: by \"identity\" you mean the internal slots that the builtins use; that means you have to replace all those builtins too","msgtype":"m.text"},"ts":1592930782000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yoonseok: the design of Proxies is such that if you need to call a built-in method on the object, you have to wrap the method as well, so that e.g. `.match` does not call the original `RegExp.prototype.match`, but instead calls a wrapped version which can invoke the original one on the original target","msgtype":"m.text"},"ts":1592930842000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"it's not just  internal slots which behave this way: if you do `let created = new WeakSet; let factory = () => { let r = { m(){ console.log(created.has(this)); } }; created.add(r); return r; }; let a = factory(); let b = new Proxy(a, {}); a.m(); b.m();` you get `true` for the `a.m()` and `false` for the `b.m()`","msgtype":"m.text"},"ts":1592930990000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"or, rather, I should say that internal slots - with the exception of Array, for some reason - behave the same way WeakMaps do (except for some cross-realm stuff which isn't usually relevant)","msgtype":"m.text"},"ts":1592931034000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"where access to the internal slot requires having the object itself, not just a proxy for the object","msgtype":"m.text"},"ts":1592931050000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"as to why things are the way they are, I'm not 100% sure. I think the idea was that internal slots should be like WeakMaps, and WeakMaps should work this way because they should be based on object identity, and a Proxy for an object should not have the same identity as the object because that would be confusing.","msgtype":"m.text"},"ts":1592931147000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"by the way, take a look at https://github.com/ajvincent/es-membrane if you haven't yet; it's the most complete membrane implementation I know of","msgtype":"m.text"},"ts":1592931181000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"p sure internal slots predate weakmaps, but i also don't know why things are the way they are","msgtype":"m.text"},"ts":1592931190000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and talks about some rationales","msgtype":"m.text"},"ts":1592931191000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"ljharb yes but they also predate Proxies; the decision to make Proxies not access internal slots of theirr targets was not made until WeakMaps were being introduced","msgtype":"m.text"},"ts":1592931249000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"true true, you are quite correct","msgtype":"m.text"},"ts":1592931306000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"bakkot_ Thank you for the answer. I agree that we can provide a wrapped version of 'match' when the receiver is a proxy object. It might be one of practical solution.","msgtype":"m.text"},"ts":1592931359000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"But, in my example, the receiver is the string. So, I called \"String.prototype.match\".","msgtype":"m.text"},"ts":1592931376000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"In this case, we cannot simply provide a wrapped version because the receiver is not a proxy object.","msgtype":"m.text"},"ts":1592931400000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"ah, yes.","msgtype":"m.text"},"ts":1592931421000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"(well, technically you can I think, but it relies on a feature we are discussing removing, so I don't want to encourage you to take that route)","msgtype":"m.text"},"ts":1592931474000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"ok. thank you for the responses. I would check the membrane implementation also.","msgtype":"m.text"},"ts":1592931577000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"Yoonseok: the string, or the regex, is the proxy?","msgtype":"m.text"},"ts":1592931587000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I think it's only RegExps which have this problem (and maybe TypedArrays); it is unusual for internal slots to be accessed by code outside of the prototype","msgtype":"m.text"},"ts":1592931590000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"ljharb the regex; see the code snippet above","msgtype":"m.text"},"ts":1592931597000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"the regex is the proxy.","msgtype":"m.text"},"ts":1592931598000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"Yoonseok: then you can define Symbol.match on the proxy","msgtype":"m.text"},"ts":1592931607000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ah.","msgtype":"m.text"},"ts":1592931627000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"and that can define whatever semantics you want","msgtype":"m.text"},"ts":1592931658000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb that was the bit I was alluding to re: features we want to remove","msgtype":"m.text"},"ts":1592931666000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"actually though I am mistaken, we don't want to remove Symbol.match","msgtype":"m.text"},"ts":1592931675000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"the part we're removing is in IsRegExp; String.prototype.match wouldn't change","msgtype":"m.text"},"ts":1592931679000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the proxy definitely still wouldn't pass IsRegExp with the change we want to make","msgtype":"m.text"},"ts":1592931692000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the proposed change is to RRegExp.prototype[@@match], I believe","msgtype":"m.text"},"ts":1592931721000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"i was under the impression it was removing steps 2 and 3 in https://tc39.es/ecma262/#sec-isregexp","msgtype":"m.text"},"ts":1592931752000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"hmm, can you use the subclass trick to make the proxy have a regex slot?","msgtype":"m.text"},"ts":1592931776000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I prefer not to think about that question :P","msgtype":"m.text"},"ts":1592931795000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"haha fair","msgtype":"m.text"},"ts":1592931871000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1592931878000,"senderName":"Yoonseok","senderId":"Yoonseok@irc"},
{"content":{"body":"we should add a binary not assignment operator :P","msgtype":"m.text"},"ts":1592944990000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh that is kind of a weird gap","msgtype":"m.text"},"ts":1592945056000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"just gotta add ≠ first","msgtype":"m.text"},"ts":1592945150000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"≠ is actually fewer keystrokes than != for me","msgtype":"m.text"},"ts":1592945164000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"what unicode is that","msgtype":"m.text"},"ts":1592945176000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"option-equals","msgtype":"m.text"},"ts":1592945190000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(on a mac)","msgtype":"m.text"},"ts":1592945196000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1592945198000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"neat","msgtype":"m.text"},"ts":1592945200000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"alt-8800 on a windows numeric keypad","msgtype":"m.text"},"ts":1592945211000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i could probably coerce my linux into doing that","msgtype":"m.text"},"ts":1592945217000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that... is more keystrokes","msgtype":"m.text"},"ts":1592945220000,"senderName":"bakkot_","senderId":"bakkot_@irc"},
{"content":{"body":"very true. but it looks nicer","msgtype":"m.text"},"ts":1592945227000,"senderName":"ljharb","senderId":"ljharb@irc"}
]