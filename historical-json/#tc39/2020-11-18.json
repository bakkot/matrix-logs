[
{"content":{"body":"Consider the regex /x*/u. According to clause 21.2, the parse involves `Term :: Atom Quantifier`, where `Atom` matches `x` and `Quantifier` matches `*`. All that's fine. Now look at the corresponding production in Annex B <https://tc39.es/ecma262/#prod-annexB-Term>. The rules say I should consider the `Atom Quantifier` alternative only if the previous alternatives don't match. But the previous alternative (Term :: Atom)","msgtype":"m.text"},"ts":1605666807000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"m presumably forced to use that (which then leads to Syntax Error, because the remaining `*` can't be parsed as another Term).","msgtype":"m.text"},"ts":1605666807000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"So I'm thinking either the alternatives should be in the opposite order (as with ExtendedAtom below), or there's something weird in the interpretation of the ordering rule.","msgtype":"m.text"},"ts":1605666872000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(since Annex  B claims to not change the syntax of unicode patterns under [+U])","msgtype":"m.text"},"ts":1605667163000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"eshost -s -x \"let a = {then(resolve){print('then called'); resolve(42)}}; let f = async () => { return a }; f()\"","msgtype":"m.text"},"ts":1605673114000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"I'm wondering why all engines report \"then called\"","msgtype":"m.text"},"ts":1605673127000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"jackworks https://masteringjs.io/tutorials/fundamentals/thenable","msgtype":"m.text"},"ts":1605673150000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I know it's thenable","msgtype":"m.text"},"ts":1605673161000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-return-statement-runtime-semantics-evaluation","msgtype":"m.text"},"ts":1605673168000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"But return Expression didn't mention \"Await(expr)\" to a non-generator.","msgtype":"m.text"},"ts":1605673188000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"And I have searched for \"Await(\" or \"PerformPromiseThen\" in the document, not finding the result","msgtype":"m.text"},"ts":1605673221000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"Oh maybe it is done in PromiseCapability.[[Resolve]] let me check","msgtype":"m.text"},"ts":1605673356000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"yeah, promises auto-flatten","msgtype":"m.text"},"ts":1605673424000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it is the same reason that `let a = {then(resolve){print('then called'); resolve(42)}}; new Promise(res => res(a))` hits the 'then called'","msgtype":"m.text"},"ts":1605673545000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I found it https://tc39.es/ecma262/#sec-async-functions-abstract-operations-async-function-start","msgtype":"m.text"},"ts":1605673552000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"AsyncFunctionStart step 4.d (arrow async function) or 4.e","msgtype":"m.text"},"ts":1605673607000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"I have a problem now with auto-unwraping behavior, https://tc39.es/ecma262/#sec-promise-resolve-functions (26.6.1.3.2 Promise Resolve Functions) step 9 \"Let then be Get(resolution, \"then\").\"","msgtype":"m.text"},"ts":1605674050000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"what's the issue?","msgtype":"m.text"},"ts":1605674180000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I have an RPC library and I use proxy to return a function for any methods on it. Now I have a problem with \"then\". If it checks HasProperty(resolution, \"then\") before \"Get\", I still have a chance to fix that in hasProperty trap, but unfortunately it doesn't","msgtype":"m.text"},"ts":1605674203000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"is the problem that you want to have a promise for the proxy, rather than auto-unwrapping? if so, I don't think you can fix it; this is a fundamental and irreparable defect in the design of promises","msgtype":"m.text"},"ts":1605674408000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if the problem is something else, can you post a code snippet to make it clearer?","msgtype":"m.text"},"ts":1605674430000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(the \"solution\" to the problem is to just never name a method \"then\" on any object anywhere.)","msgtype":"m.text"},"ts":1605674487000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ðŸ¤· very unlucky but yes","msgtype":"m.text"},"ts":1605674586000,"senderName":"jackworks","senderId":"jackworks@irc"},
{"content":{"body":"Hm. In the log for this channel, my earlier comment got borked. The sentence with the missing bit is: But the previous alternative (Term :: Atom) *does* match, so I'm presumably forced to use that (which then leads to Syntax Error, because the remaining `*` can't be parsed as another Term).","msgtype":"m.text"},"ts":1605675156000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"hmmm, yeah","msgtype":"m.text"},"ts":1605675494000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think the intent is probably more like \"only if the previous alternatives do not lead to a valid parse\", but that's pretty ugly","msgtype":"m.text"},"ts":1605675524000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think probably just switching those two works, given that the \"each alternative is considered only if...\" rule doesn't apply to the rest of the Pattern grammar, just the parts ini B.1.4","msgtype":"m.text"},"ts":1605675576000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(otherwise the same issue would arise with e.g. Disjunction)","msgtype":"m.text"},"ts":1605675597000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I wonder why this isn't just `Atom Quantifier_opt`, though","msgtype":"m.text"},"ts":1605675631000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess that wouldn't really help given that `_opt` is basically a macro which expands into two RHSes, which need to be ordered when in the annex B pattern grammar because of this rule","msgtype":"m.text"},"ts":1605675705000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"And it would be unclear what the \"order\" is.","msgtype":"m.text"},"ts":1605675728000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Right.","msgtype":"m.text"},"ts":1605675746000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Though it could presumably have been Quantifier_opt in the main body.","msgtype":"m.text"},"ts":1605675799000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"(when it was introduced)","msgtype":"m.text"},"ts":1605675824000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I'd approve a PR switching those two alternatives if you care to make one; I'll get to it myself at some point otherwise","msgtype":"m.text"},"ts":1605675958000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the fact that the `ExtendedAtom` variants have the `Quantifier` one first makes me pretty sure this was just an oversight","msgtype":"m.text"},"ts":1605676000000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Yeah, I'll probably make a PR.","msgtype":"m.text"},"ts":1605676015000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Patterns were introduced in 3rd edition. The \"opt\" subscript was in use, so Term could have said `Atom Quantitifer_opt`. Maybe whoever wrote that up didn't like \"opt\".","msgtype":"m.text"},"ts":1605676300000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"I'm also concerned about your suggested intent behind the \"only if previous production alternatives do not match\" wording, as that would be normatively different from my reading.","msgtype":"m.text"},"ts":1605676459000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Yeah, I thought about it more and realized that was wrong","msgtype":"m.text"},"ts":1605677421000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1605677442000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"Bakkot: https://github.com/tc39/ecma262/pull/2228","msgtype":"m.text"},"ts":1605713274000,"senderName":"jmdyck","senderId":"jmdyck@irc"},
{"content":{"body":"leobalter: ack, sorry to have you clean up after me :(","msgtype":"m.text"},"ts":1605730473000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: that's not an easy renaming","msgtype":"m.text"},"ts":1605730499000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"item and at are too common words","msgtype":"m.text"},"ts":1605730511000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"hehehe it's true","msgtype":"m.text"},"ts":1605730530000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the tests would be easily spotted in eventual test runs as well, they wouldn't lead anyone to wrong implementations, I believe so :)","msgtype":"m.text"},"ts":1605730621000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"true","msgtype":"m.text"},"ts":1605730663000,"senderName":"rkirsling","senderId":"rkirsling@irc"}
]