[
{"content":{"body":"Bakkot: you can mechanically convert an N-token lookahead to a 1-token lookahead by threading it through all intervening non-terminals","msgtype":"m.text"},"ts":1589242693000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"which is a giant PITA","msgtype":"m.text"},"ts":1589242704000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but yes... what does it mean for the dangling else PR","msgtype":"m.text"},"ts":1589242719000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i think the if-else lookahead might be okay in that we don't need an oracle to determine if we parsed something that shouldn't have been accepted","msgtype":"m.text"},"ts":1589242811000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"maybe i'm just wrong and you can't actually mechanically convert an N-token lookahead to a 1-token lookahead by threading it through all productions...","msgtype":"m.text"},"ts":1589242860000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it has been too long since I thought about formal properties of grammars rather than just how humans would actually implement them","msgtype":"m.text"},"ts":1589242908000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'm pretty sure you can though, say, once you see a `(`, you'd pass through some parameter that's basically like \"you can't see a => after a )\"","msgtype":"m.text"},"ts":1589242926000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the problem is that that blows up your grammar","msgtype":"m.text"},"ts":1589242939000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"for the grouping case, you'd pass \"you can't see a => after a )\", the opposite for arrows","msgtype":"m.text"},"ts":1589242956000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ok but how do you know which branch you're in when you start parsing?","msgtype":"m.text"},"ts":1589242982000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right, good question","msgtype":"m.text"},"ts":1589243002000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"that's a question the actual parser has to answer, but from the formal grammar's point of view as describing all strings that can be accepted","msgtype":"m.text"},"ts":1589243027000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"can't there just be an oracle?","msgtype":"m.text"},"ts":1589243032000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"an actual parser would need to back track or do arbitrary lookahead or something","msgtype":"m.text"},"ts":1589243057000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I think if there is an oracle you stop being LR(k)","msgtype":"m.text"},"ts":1589243087000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh hmm","msgtype":"m.text"},"ts":1589243095000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"maybe not though","msgtype":"m.text"},"ts":1589243112000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"like I said, it's been too long since I thought about the theory","msgtype":"m.text"},"ts":1589243124000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"should go find some undergrads and ask them","msgtype":"m.text"},"ts":1589243135000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah i think you're right, at least according to wikipedia","msgtype":"m.text"},"ts":1589243141000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"LR(k) is literally left-to-right with k-token lookahead to disambiguate the non-terminals","msgtype":"m.text"},"ts":1589243166000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so... yeah I think we might have broken that with the lookahead â‰  else PR","msgtype":"m.text"},"ts":1589243286000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ugh","msgtype":"m.text"},"ts":1589243287000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so... covers actually have extra expressivity","msgtype":"m.text"},"ts":1589243312000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"https://esdiscuss.org/topic/lr-1-grammar-parser-and-lookahead-restrictions is a pretty good read","msgtype":"m.text"},"ts":1589243866000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it had a very similar confusion to my own","msgtype":"m.text"},"ts":1589243877000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I wish we could get Waldemar to share his automated tool he talks about here","msgtype":"m.text"},"ts":1589243949000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that or give up the LR(1) ghost","msgtype":"m.text"},"ts":1589244024000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"hard to make us beholden to something we can't easily verify ourselves","msgtype":"m.text"},"ts":1589244038000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"commented on https://github.com/tc39/ecma262/pull/1966","msgtype":"m.text"},"ts":1589244177000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: as for \"extra expressivity\", i think my conclusion after reading all of that is that cover grammars don't give us extra expressivity in specifying what token streams would be accepted and what would not be","msgtype":"m.text"},"ts":1589244227000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"oh we didn't merge yet, phew","msgtype":"m.text"},"ts":1589244249000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"hmmm","msgtype":"m.text"},"ts":1589244270000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but it does affect how we write the rest of the spec and the static/evaluation semantics, since without reinterpretation of cover grammars, you'd end up with one production that the semantics would end up being responsible for disambiguating","msgtype":"m.text"},"ts":1589244282000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so the evaluator would need to keep some kind of state","msgtype":"m.text"},"ts":1589244287000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"which is terrible","msgtype":"m.text"},"ts":1589244289000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"well, cover grammars absent early errors certainly do not give extra expressivity","msgtype":"m.text"},"ts":1589244330000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"since the 1-1ness of a parse tree being interpreted a single way is really just a convention we hold","msgtype":"m.text"},"ts":1589244338000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"because the \"this must cover\" restrictions are enforced at early error time, not in the grammar itself","msgtype":"m.text"},"ts":1589244358000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I don't know that it is possible to write an LR(k) grammar that has the same set of accepted token streams as the current grammar + the early error rules for \"this must cover\"","msgtype":"m.text"},"ts":1589244392000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i feel like it is but really verbose and impossible to understand","msgtype":"m.text"},"ts":1589244452000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"e.g., for grouping vs arrow param list, something like (42) isn't a legal param list","msgtype":"m.text"},"ts":1589244473000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"you can imagine that to start, '(' can have single-token lookahead restrictions for digits","msgtype":"m.text"},"ts":1589244496000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the problem is that  it might be arbitrarily far away, yeah? `( a1, a2, ..., an, 42)`","msgtype":"m.text"},"ts":1589244538000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah, right...","msgtype":"m.text"},"ts":1589244565000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but i think it'd be like, in the context of '(', you can have a bunch of parameters that do your branching","msgtype":"m.text"},"ts":1589244619000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"accepting a 42 numeric literal means the following non-terminal doesn't accept a ') =>'","msgtype":"m.text"},"ts":1589244662000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"accepting a x means both options are still open","msgtype":"m.text"},"ts":1589244690000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"how do you know which branch to take, after encountering `(`?","msgtype":"m.text"},"ts":1589244736000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you don't, you decide the branch the first time you see an illegal token in the other branch","msgtype":"m.text"},"ts":1589245015000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the first time you see 42, you decide you have to be a grouping","msgtype":"m.text"},"ts":1589245024000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"if you don't see anything that would be an error in the other branch, you end up with a non-terminal that can be interpreted multiple ways depending on the parent non-terminal","msgtype":"m.text"},"ts":1589245048000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"that's how actual parsers are implemented, certainly","msgtype":"m.text"},"ts":1589245053000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(this might all be completely wrong, i haven't tried writing this out)","msgtype":"m.text"},"ts":1589245055000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"you can also write the grammar that way","msgtype":"m.text"},"ts":1589245063000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"no?","msgtype":"m.text"},"ts":1589245066000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"anyways the formal property of covers isn't really worth either of our time","msgtype":"m.text"},"ts":1589245199000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"mmmmmaybe","msgtype":"m.text"},"ts":1589245206000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah I would not want to try to make any definitive claims about this without writing things down","msgtype":"m.text"},"ts":1589245247000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and ideally having tools to verify them","msgtype":"m.text"},"ts":1589245253000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"('grammar is unambiguous' is actually one of my TODOs in the 'things to lint for' issue, though I doubt I personally will get to that one)","msgtype":"m.text"},"ts":1589245311000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"btw https://github.com/tc39/ecmarkup/pull/199 exists if you haven't seen it","msgtype":"m.text"},"ts":1589245323000,"senderName":"Bakkot","senderId":"Bakkot@irc"}
]