[
{"content":{"body":"so what's wrong with \"untagged unions\"? i get why if the key is the same, pivoting on the type of the key would suck, but what's wrong with `{ a: A } | { b: B }`?","msgtype":"m.text"},"ts":1585589902000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"general answer: idk, feels gross","msgtype":"m.text"},"ts":1585590356000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no concrete reasons, just feels gross?","msgtype":"m.text"},"ts":1585590369000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"in this specific case there is advantage to the field being of the same name for both cases, which is that if you don't care about the extra microtask tick you can just `await waitAsync().value`","msgtype":"m.text"},"ts":1585590396000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: untagged unions are hard to justify design wise imo, given the general design principle of \"always a promise or never a promise\"","msgtype":"m.text"},"ts":1585590491000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the upshot of that design principle means to me, instanceof checks on return to deal with promises is in general not okay","msgtype":"m.text"},"ts":1585590525000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and if it that's not okay, i don't understand why an untagged union _is_ okay","msgtype":"m.text"},"ts":1585590541000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"because in practice you're asking users to write instanceof checks","msgtype":"m.text"},"ts":1585590552000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"whereas a tagged union is you're asking users to check a flag, which is morally kinda the same but practically okay, because we switch on properties sometimes?","msgtype":"m.text"},"ts":1585590587000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: in this example you'd be asking users to write a hasOwnProperty check, not an instanceof check","msgtype":"m.text"},"ts":1585590621000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"wait, did i misunderstand","msgtype":"m.text"},"ts":1585590633000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"`{ a: A } | { b: B }`","msgtype":"m.text"},"ts":1585590642000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"{ promise } | { value } or something?","msgtype":"m.text"},"ts":1585590645000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"oh no that's... yeah no that's a 3rd option that's worse","msgtype":"m.text"},"ts":1585590659000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: yes, instanceof isn't ok, but typeof on a primitive is ok","msgtype":"m.text"},"ts":1585590691000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's also not what committee decided last time as recorded in SYNC-RESOLVE","msgtype":"m.text"},"ts":1585590712000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ok so you want the key to always be `value`","msgtype":"m.text"},"ts":1585590715000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the old design was Promise | string, but i guess that also ran up against the always-or-never-a-promise problem","msgtype":"m.text"},"ts":1585590729000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and you're saying that if it's `{ value: string | Promise }`, then they have to introspect the value in order to know which it is","msgtype":"m.text"},"ts":1585590731000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I guess it just kind of feels weird to make users compute which branch they're in instead of just telling them which branch they're in","msgtype":"m.text"},"ts":1585590744000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"whereas if it's a flag, that's somehow better/different","msgtype":"m.text"},"ts":1585590745000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"?","msgtype":"m.text"},"ts":1585590746000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: right, i thought that's what you were saying","msgtype":"m.text"},"ts":1585590746000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ljharb: yeah what bakkot said","msgtype":"m.text"},"ts":1585590758000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i guess it just feels redundant to me","msgtype":"m.text"},"ts":1585590772000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"why is it redundant?","msgtype":"m.text"},"ts":1585590821000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"like a lot of things are computable from other things, i think the high-order bit here isn't redundancy but the code you're asking people to write for the 80% use case","msgtype":"m.text"},"ts":1585590861000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"also i kind of resist the framing that it's typeof instead of instanceof","msgtype":"m.text"},"ts":1585590982000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"for this API i can't imagine a division other than primitive-object","msgtype":"m.text"},"ts":1585591003000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"right that's what i mean tho","msgtype":"m.text"},"ts":1585591041000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but in general i don't see the pattern of \"inferring what branch you're based on a typeof check\" having the primitive-object divide","msgtype":"m.text"},"ts":1585591045000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"you'd check `typeof result.value`","msgtype":"m.text"},"ts":1585591046000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"hm","msgtype":"m.text"},"ts":1585591052000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like really the important thing here that it's a Promise","msgtype":"m.text"},"ts":1585591056000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i guess i'm not thinking primitive-object","msgtype":"m.text"},"ts":1585591059000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"not that it's an object","msgtype":"m.text"},"ts":1585591062000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i'm thinking string-promise","msgtype":"m.text"},"ts":1585591063000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah but that's not a typeof check","msgtype":"m.text"},"ts":1585591072000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and that no other type would ever be possible here","msgtype":"m.text"},"ts":1585591072000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you *can* use a typeof check as a standin","msgtype":"m.text"},"ts":1585591081000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"typeof is how you'd robustly determine if it's a string, or the other thing","msgtype":"m.text"},"ts":1585591084000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ah, so you're thinking string or not string?","msgtype":"m.text"},"ts":1585591096000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i'm thinking of it more like Promise, or not promise","msgtype":"m.text"},"ts":1585591102000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"(thus why i named the property async)","msgtype":"m.text"},"ts":1585591109000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"right, string or not string","msgtype":"m.text"},"ts":1585591122000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or rather, string, or promise for string","msgtype":"m.text"},"ts":1585591130000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i don't assume anyone would use this api expecting a third kind of thing","msgtype":"m.text"},"ts":1585591143000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"right, for this api i wouldn't either","msgtype":"m.text"},"ts":1585591152000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ftr i do sort of see the logic in giving an explicit boolean rather than making them do the actual check, even tho it's an easy one","msgtype":"m.text"},"ts":1585591169000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"mainly just wondering if there's a super strong push in that direction","msgtype":"m.text"},"ts":1585591181000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or rather, why","msgtype":"m.text"},"ts":1585591186000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"anyway i still prefer a flag, if we get to it this meeting we can discuss it then","msgtype":"m.text"},"ts":1585591189000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"honestly","msgtype":"m.text"},"ts":1585591221000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it's probably because untagged unions are rare in most of PL","msgtype":"m.text"},"ts":1585591255000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"same in compilers, harder to compile, harder to get guarantees for, etc","msgtype":"m.text"},"ts":1585591288000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"in JS that's not strictly true because things are boxed and have tags anyway","msgtype":"m.text"},"ts":1585591305000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"maybe that's why it feels fine to me","msgtype":"m.text"},"ts":1585591331000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but there are many \"tags\" and it's a confused mental model: there's the typeof tag, the instanceof tag, which is mutable","msgtype":"m.text"},"ts":1585591332000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"rare except C/C++ code written more than ten years ago (before this particular discipline became pervasive), which has burned everyone who has ever gotten near it","msgtype":"m.text"},"ts":1585591335000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1585591341000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"right, only typeof and internal slot checks are reliable","msgtype":"m.text"},"ts":1585591383000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(and truthiness, modulo document.all)","msgtype":"m.text"},"ts":1585591399000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"hasownproperty is reliable just awkward","msgtype":"m.text"},"ts":1585591407000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"reliably if you `Object.prototype.hasOwnProperty.call`, and you've cached a copy of the function, but true","msgtype":"m.text"},"ts":1585591428000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the main advantage i think is a clear mental model with an easy to type check","msgtype":"m.text"},"ts":1585591435000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"hm, ok","msgtype":"m.text"},"ts":1585591437000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's the same conditions as for the internal property checks though","msgtype":"m.text"},"ts":1585591441000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"very true","msgtype":"m.text"},"ts":1585591488000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"as a reader of code, if I saw `let val = ret.async ? await ret.val : ret.val` I would know what was going on, whereas if I saw `let val = typeof ret.val === 'string '? ret.val : await ret.val` I would have to go look up the API to know what was going on","msgtype":"m.text"},"ts":1585592368000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this I think is the main reason I feel better about tagged unions, in general","msgtype":"m.text"},"ts":1585592382000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's a decently persuasive argument","msgtype":"m.text"},"ts":1585592431000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1585592440000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: so I guess if we're cutting the spec now we should remove from the editors update the bit about deciding to hold the spec until we resolved my normative PR","msgtype":"m.text"},"ts":1585610409000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"actually i was holding off anyways","msgtype":"m.text"},"ts":1585610430000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"what does a day or two matter","msgtype":"m.text"},"ts":1585610434000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"oh, cool","msgtype":"m.text"},"ts":1585610436000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sgtm","msgtype":"m.text"},"ts":1585610439000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if this was an issue, istvan should have raised it much sooner","msgtype":"m.text"},"ts":1585610446000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and he claims an \"important\" tc39 member has an issue with wanting the full 3 weeks, but plenary is where they should be raising that objection","msgtype":"m.text"},"ts":1585610463000,"senderName":"ljharb","senderId":"ljharb@irc"}
]