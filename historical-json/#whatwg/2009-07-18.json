[
{"content":{"body":"Hixie: amusing","msgtype":"m.text"},"ts":1247875440000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"is tempted to do more work on HTTP parsing","msgtype":"m.emote"},"ts":1247916180000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Is it sensible to use ABNF but state that alternations must be matched from left to right?","msgtype":"m.text"},"ts":1247916660000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: yeah, I think it would be. as long as you made that clear in the spec","msgtype":"m.text"},"ts":1247916720000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"It means I don't end up with things like: ( [ \":\" *LWS ] 1*header-content-nc [ *LWS \":\" ] / 1*\":\" / 1*header-content-nc 1*LWS \":\" *LWS header-content [ *( header-content / LWS ) header-content ] ) *LWS","msgtype":"m.text"},"ts":1247916780000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"That was an attempt to give everything that doesn't match another rule :)","msgtype":"m.text"},"ts":1247916781000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"If the order of matching is important, that sounds like a fundamental shift from the usual notion of a language grammar","msgtype":"m.text"},"ts":1247916840000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"*( %x00-09 / %x0B-FF ) LF is a lot simpler :)","msgtype":"m.text"},"ts":1247916900000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"(since normally grammars just define a set of matching strings, and it's irrelevant how you matched it)","msgtype":"m.text"},"ts":1247916901000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"The URI spec relies upon such a restraint though","msgtype":"m.text"},"ts":1247916960000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"It sort of sounds like you want to define a new type of alternative, such that \"Rule1 / Rule2\" matches if Rule1 matches or else if Rule1 doesn't match and Rule2 does match","msgtype":"m.text"},"ts":1247917020000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"but that matches exactly the same as the normal type of alternative","msgtype":"m.text"},"ts":1247917080000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"so I may be misunderstanding what you want","msgtype":"m.text"},"ts":1247917081000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Peh. If anyone complains I'll just say that RFC 3986 and 3987 (URI and IRI respectively) do this too.","msgtype":"m.text"},"ts":1247917082000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"s/exactly the same/exactly the same set of strings/","msgtype":"m.text"},"ts":1247917083000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"I suppose it makes more sense if you have an unambiguous grammar and you're interested in which rules match","msgtype":"m.text"},"ts":1247917140000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Is there any way to easily work out a rule that represents everything that doesn't match another rule?","msgtype":"m.text"},"ts":1247917200000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"in which case it seems like the 'correct' thing to do would be to define an AABNF which adds a new unambiguating-alternative rule","msgtype":"m.text"},"ts":1247917201000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"because then it would be well defined and unambiguous and everything","msgtype":"m.text"},"ts":1247917260000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"dammit","msgtype":"m.text"},"ts":1247917320000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Philip`: help me out please","msgtype":"m.text"},"ts":1247917321000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"  File \"tools/spec-splitter.py\", line 64, in ?","msgtype":"m.text"},"ts":1247917322000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"    parser = etree.HTMLParser(encoding='utf-8', recover=False)","msgtype":"m.text"},"ts":1247917323000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"TypeError: 'encoding' is an invalid keyword argument for this function","msgtype":"m.text"},"ts":1247917324000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"gsnedders: I don't think it is","msgtype":"m.text"},"ts":1247917325000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: missing python module?","msgtype":"m.text"},"ts":1247917380000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Philip`: ?","msgtype":"m.text"},"ts":1247917381000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"or a not-up-to-date one?","msgtype":"m.text"},"ts":1247917382000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"gsnedders: ...but I could be wrong","msgtype":"m.text"},"ts":1247917500000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"s/it is/there is/","msgtype":"m.text"},"ts":1247917501000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Oh, there is.","msgtype":"m.text"},"ts":1247917502000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"That makes a lot more sense.","msgtype":"m.text"},"ts":1247917560000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Philip`: my lxml too old, maybe?","msgtype":"m.text"},"ts":1247917860000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"nm","msgtype":"m.text"},"ts":1247918100000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"I'll run it from another host where I can actually make the sure packages are up to date","msgtype":"m.text"},"ts":1247918101000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"gsnedders: Hmm, I'm probably wrong, but I don't know why","msgtype":"m.text"},"ts":1247918400000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"MikeSmith: I think it requires lxml 2.0","msgtype":"m.text"},"ts":1247918460000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"but that's the only version issue I know of","msgtype":"m.text"},"ts":1247918461000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: yep, I think so. and I updating to 2.0 on the host I was trying this on would be too much of a PITA, so I'll just run it from my own server","msgtype":"m.text"},"ts":1247918462000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"gsnedders: what you describe is basically a PEG","msgtype":"m.text"},"ts":1247934480000,"senderName":"inimino","senderId":"inimino@irc"},
{"content":{"body":"a PEG?","msgtype":"m.text"},"ts":1247934540000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"rather than BNF","msgtype":"m.text"},"ts":1247934541000,"senderName":"inimino","senderId":"inimino@irc"},
{"content":{"body":"points out he isn't a compsci guy","msgtype":"m.emote"},"ts":1247934600000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: http://en.wikipedia.org/wiki/Parsing_expression_grammar","msgtype":"m.text"},"ts":1247934601000,"senderName":"takkaria","senderId":"takkaria@irc"},
{"content":{"body":"inimino: I do, however, need something formally defined to enough of an extent to use in a spec.","msgtype":"m.text"},"ts":1247935380000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"PEGs are quite formally defined, but if the protocol is byte-oriented you might want to use the ABNF notation for terminals anyway","msgtype":"m.text"},"ts":1247935500000,"senderName":"inimino","senderId":"inimino@irc"},
{"content":{"body":"it's fairly common to treat ABNF this way and there are even some parser generators that treat ABNF like something it's not","msgtype":"m.text"},"ts":1247935501000,"senderName":"inimino","senderId":"inimino@irc"},
{"content":{"body":"technically it's impossible to generate an efficient parser from an ABNF since they can be ambiguous","msgtype":"m.text"},"ts":1247935560000,"senderName":"inimino","senderId":"inimino@irc"},
{"content":{"body":"inimino: Yeah, right, I know.","msgtype":"m.text"},"ts":1247935920000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"hi","msgtype":"m.text"},"ts":1247947620000,"senderName":"guyzmo","senderId":"guyzmo@irc"},
{"content":{"body":"I'm parsing an html page with html5lib, and I get troubles when I want to get contents","msgtype":"m.text"},"ts":1247947680000,"senderName":"guyzmo","senderId":"guyzmo@irc"},
{"content":{"body":"like when I'm in an anchor element, shall I use toxml() to get the XXX part of : \"<a>XXX</a>\" ?","msgtype":"m.text"},"ts":1247947681000,"senderName":"guyzmo","senderId":"guyzmo@irc"},
{"content":{"body":"(haven't found any other way)","msgtype":"m.text"},"ts":1247947682000,"senderName":"guyzmo","senderId":"guyzmo@irc"},
{"content":{"body":"Hixie: Why does section 11 of the HTML5 spec use the XHTML namespace while defining style for HTML5-only elements?","msgtype":"m.text"},"ts":1247951400000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"GPHemsley: All HTML5 elements are parsed into the XHTML namespace","msgtype":"m.text"},"ts":1247951880000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: Oh. Is that implicit?","msgtype":"m.text"},"ts":1247952960000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"GPHemsley: It's explicit in the spec that that happens, but the markup doesn't have to have any xmlns attributes or anything","msgtype":"m.text"},"ts":1247953020000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"k","msgtype":"m.text"},"ts":1247953021000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"What's the difference between <embed> and <object>? Is one favored over the other?","msgtype":"m.text"},"ts":1247955300000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"<embed> is specifically plugin related, IIRC","msgtype":"m.text"},"ts":1247955600000,"senderName":"jcranmer","senderId":"jcranmer@irc"},
{"content":{"body":"that is, I'm pretty sure an image/*-in-embed wouldn't work","msgtype":"m.text"},"ts":1247955601000,"senderName":"jcranmer","senderId":"jcranmer@irc"},
{"content":{"body":"jcranmer: What about Flash?","msgtype":"m.text"},"ts":1247957760000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"doesn't know anything","msgtype":"m.emote"},"ts":1247957761000,"senderName":"jcranmer","senderId":"jcranmer@irc"},
{"content":{"body":"k","msgtype":"m.text"},"ts":1247957762000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"Strangely, you also cannot style <object>, it seems. It styles the fall-back underneath. :/","msgtype":"m.text"},"ts":1247957820000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"}
]