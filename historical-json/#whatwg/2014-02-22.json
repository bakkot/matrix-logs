[
{"content":{"body":"heycam: See, for example, CSS Syntax, which declares the meaning of each token.","msgtype":"m.text"},"ts":1393027515000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins, CSS Syntax also defines parsing algorithms in terms of token consumption, which is something that I'd like to avoid if possible","msgtype":"m.text"},"ts":1393027577000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"TabAtkins, I think for CSS it's fine, since you can't neatly describe it with \"parse with this grammar or fail\"","msgtype":"m.text"},"ts":1393027598000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"You're doing that anyway, if you say things like \"the digit-sequence construction represents the result of evaluating the matched characters as a base-10 number\", or whatever.","msgtype":"m.text"},"ts":1393027655000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"heycam: Also, only the *parser* has error-recovery of that sort.  Virtually all individual constructs in CSS are described in \"parse correctly or fail\" terms.","msgtype":"m.text"},"ts":1393027685000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins, ok","msgtype":"m.text"},"ts":1393027699000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"TabAtkins, well I'll see what happens when I eventually rewrite that section :)","msgtype":"m.text"},"ts":1393027708000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"The three-level parsing we have is just a convenience, allowing us to do the various definition work in one place for each thing.","msgtype":"m.text"},"ts":1393027716000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Tokenizing -> Generic Parsing -> Feature Grammars","msgtype":"m.text"},"ts":1393027734000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"othermaciej: i gotta say, \"this.elements.a.value\" seems vastly preferable to \"this.querySelector(\"#a\").value\"","msgtype":"m.text"},"ts":1393029858000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"othermaciej: maybe i've just got odd engineering aesthetic taste :-)","msgtype":"m.text"},"ts":1393029876000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: if it's based on aesthetics and not terseness, I could go either way","msgtype":"m.text"},"ts":1393029932000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"(a) magic namespaces can be convenient but on the other hand they can be conceptually confusing","msgtype":"m.text"},"ts":1393029976000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"(b) using a very context-specific way to access an element is in some ways less elegant than using a fully general way","msgtype":"m.text"},"ts":1393030003000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"(c) What happens with <div id=\"toString\">???","msgtype":"m.text"},"ts":1393030027000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"if it were not for the issues with form.elements that Jonas raised, I would be all for extending it (after all, what's the downside)","msgtype":"m.text"},"ts":1393030035000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"<div id=\"__proto__\">","msgtype":"m.text"},"ts":1393030043000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"but the fact that it misses some kinds of form elements and is a live collection - ick","msgtype":"m.text"},"ts":1393030068000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"Jonas's getParticipants() could provide a symbolic magic namespace if desired, though at some cost of terseness relative to elements","msgtype":"m.text"},"ts":1393030093000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"Also, we're gaining just a plain .query() (iirc the name it's ending up with?), so \"this.query('#a')\" versus \"this.elements.a\" becomes more evenly matched in terseness.","msgtype":"m.text"},"ts":1393030097000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"this.query('#a') is some sweet syntax IMO","msgtype":"m.text"},"ts":1393030135000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"in general, proxy like APIs do not seem that great to me. Especially when they have built-in properties like .length, .item, .namedItem and .__proto__","msgtype":"m.text"},"ts":1393030219000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"I tend to prefer things that are more overtly a dictionary instead of relying on the poor-man's-dictionariness of JS objects","msgtype":"m.text"},"ts":1393030267000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"I think form.control(\"name\") is just as good as form.elements.name","msgtype":"m.text"},"ts":1393030272000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"oh, right, form.elements does the crazy thing of \"return a node or a nodelist\" thing","msgtype":"m.text"},"ts":1393030318000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Yes, objects as pretend dictionaries is terrible.","msgtype":"m.text"},"ts":1393030328000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"that adds another level of crazyness","msgtype":"m.text"},"ts":1393030329000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"especially considering the liveness. It means that a property can morph from being a Node to a NodeList","msgtype":"m.text"},"ts":1393030369000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"a live NodeList to make things worse","msgtype":"m.text"},"ts":1393030382000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"I'll also note that ES6's map class is based on .get() and .set() functions, rather than .foo.","msgtype":"m.text"},"ts":1393030552000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"I generally prefer to defer to the API design patterns from TC39 than the ones from the DOM","msgtype":"m.text"},"ts":1393030578000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"And I've been pushing hard in the same direction, encouraging use of Map/Set methods rather than homebrew collections.","msgtype":"m.text"},"ts":1393030654000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I'll add Array to that list","msgtype":"m.text"},"ts":1393030696000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Map, Set and Array are good primitives and good ways of managing collections","msgtype":"m.text"},"ts":1393031053000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"TabAtkins: that said, the way you are inheriting Map in the fontloader looks iffy to me. I sent feedback to jdaggett (since he reached out for review). Not sure if he forwarded it to you?","msgtype":"m.text"},"ts":1393031357000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"I didn't get that feedback, I don't think.","msgtype":"m.text"},"ts":1393031373000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"What's iffy about it?","msgtype":"m.text"},"ts":1393031376000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(heycam also said he might have problems with how I asked for [MapClass] to work, but he hasn't worked out how to fix yet.)","msgtype":"m.text"},"ts":1393031401000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: for example, what happens if a font is removed from the Set (I forget if you inherit Map or Set?)","msgtype":"m.text"},"ts":1393031402000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"It's a Map.","msgtype":"m.text"},"ts":1393031412000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: key'ed on?","msgtype":"m.text"},"ts":1393031424000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Blarg, sorry.  It's a set.","msgtype":"m.text"},"ts":1393031435000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Anyway, this <http://dev.w3.org/csswg/css-font-loading/#font-face-set-css> defines what happens if you mutate the set yourself.","msgtype":"m.text"},"ts":1393031464000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins, if we make plain Array objects the values of choice for IDL attributes that reflect list-ish things, we might be able to do the same with Map for associated array stuff. but while the browser can Object.watch the Array to watch for changes to it from script, you can't do that with Maps","msgtype":"m.text"},"ts":1393031506000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"TabAtkins: what's the purpose of keying it on FontFace objects? When would you ever want to do a lookup based on a FontFace object?","msgtype":"m.text"},"ts":1393031515000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"since the data is stored in internal properties, and there aren't real property changes that would trigger the Object.watch observer","msgtype":"m.text"},"ts":1393031526000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"heycam: I know. :/  That lack of ability to hook maps/sets is super frustrating.","msgtype":"m.text"},"ts":1393031530000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"sicking: I don't understand your question, since it's not keyed on anything.","msgtype":"m.text"},"ts":1393031541000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: sets are keyed on their values, no?","msgtype":"m.text"},"ts":1393031555000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: They're not really \"keyed\" on anything?","msgtype":"m.text"},"ts":1393031567000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: i disagree","msgtype":"m.text"},"ts":1393031573000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"I mean, technically, sets can be implemented as maps with a dummy value.","msgtype":"m.text"},"ts":1393031577000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: sets are maps with no value","msgtype":"m.text"},"ts":1393031595000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"but they still have keys","msgtype":"m.text"},"ts":1393031598000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"But they're just an Array with a less visible ordering, and no duplicates.","msgtype":"m.text"},"ts":1393031600000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"hence they are keyed","msgtype":"m.text"},"ts":1393031603000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"I don't see how they have keys.","msgtype":"m.text"},"ts":1393031621000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"There's no .get() method.","msgtype":"m.text"},"ts":1393031625000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Just .add()","msgtype":"m.text"},"ts":1393031634000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And .has()","msgtype":"m.text"},"ts":1393031637000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: there's a .has() method","msgtype":"m.text"},"ts":1393031640000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"And?","msgtype":"m.text"},"ts":1393031655000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"the has method does a lookup based on the value you pass in. I.e. it uses the value as a key","msgtype":"m.text"},"ts":1393031667000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Sure.","msgtype":"m.text"},"ts":1393031676000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"expectation is that .has() runs in constant time, no?","msgtype":"m.text"},"ts":1393031694000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"ish","msgtype":"m.text"},"ts":1393031701000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Yes.","msgtype":"m.text"},"ts":1393031703000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"that means that there's a hash table","msgtype":"m.text"},"ts":1393031717000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Yes.","msgtype":"m.text"},"ts":1393031720000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"hash tables have keys","msgtype":"m.text"},"ts":1393031727000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"We can keep doing this all day, or you can tell me what your point is. ^_^","msgtype":"m.text"},"ts":1393031754000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"talking about keys in the context of a non-associative data structure is not the clearest terminology","msgtype":"m.text"},"ts":1393031757000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"TabAtkins: why would you ever want to do .has(FontFace)? Or .add(FontFace)?","msgtype":"m.text"},"ts":1393031787000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"TabAtkins: or .delete(FontFace)","msgtype":"m.text"},"ts":1393031800000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"You probably don't want to do .has().","msgtype":"m.text"},"ts":1393031802000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":".add() is useful if you construct your own.","msgtype":"m.text"},"ts":1393031807000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":".delete() isn't useful most of the time, but if you can add, there might be use-cases for deleting.","msgtype":"m.text"},"ts":1393031822000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And it comes for free with the \"act like a Set\", so we keep it.","msgtype":"m.text"},"ts":1393031840000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: what's the use case for de-duping FontFace objects?","msgtype":"m.text"},"ts":1393031847000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"TabAtkins: i.e. what's the use case for making the .add function not add if the FontFace instance already exists?","msgtype":"m.text"},"ts":1393031866000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"guesses is that sicking's point is that an array would be better","msgtype":"m.emote"},"ts":1393031867000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"the fact that dupes are meaningless?","msgtype":"m.text"},"ts":1393031875000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"is the sequence relevant?","msgtype":"m.text"},"ts":1393031894000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"othermaciej: right. The current API doesn't seem to take advantage of the hash at all","msgtype":"m.text"},"ts":1393031899000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Using an array means that I expose an index as well.  This index isn't stable (it changes if you add/remove @font-face rules from the document's stylesheets).","msgtype":"m.text"},"ts":1393031912000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i think having a myFontLoader.loadedFonts Array would be much more intuitive","msgtype":"m.text"},"ts":1393031927000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"The only thing I really want to expose is .add() and [iterator]()","msgtype":"m.text"},"ts":1393031956000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Set is the best match for that.","msgtype":"m.text"},"ts":1393031968000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: as soon as you have an iterator you have indexes","msgtype":"m.text"},"ts":1393031990000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"so you'll have to deal with that problem no matter what","msgtype":"m.text"},"ts":1393032005000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"index being unstable is not really a good reason to specifically not use an Array","msgtype":"m.text"},"ts":1393032006000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"isn't sure if Sets have stable indexes","msgtype":"m.emote"},"ts":1393032012000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"as long as there's still an order","msgtype":"m.text"},"ts":1393032017000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"Only ad-hoc ones you invent yourself.  You can't use those indexes later to directly access something (and be fooled by the value at that index being swapped out).","msgtype":"m.text"},"ts":1393032018000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"The worst you could do is associate it with an index in a side data structure, and assume that'll be stable across invocations.","msgtype":"m.text"},"ts":1393032045000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"document.queryAll() gives you an array, because element order in the document is still an order, even though indices can change if you add or remove elements","msgtype":"m.text"},"ts":1393032056000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"well, an array-ish thing","msgtype":"m.text"},"ts":1393032063000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"But if you have modern JS, you can just use a Map (or a WeakMap) instead and key it to the FontFace directly.","msgtype":"m.text"},"ts":1393032066000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"rather than a set-ish one","msgtype":"m.text"},"ts":1393032067000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"Array doesn't really promise a stable order, but it does vaguely imply that order is in some what meaningful","msgtype":"m.text"},"ts":1393032109000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"TabAtkins: is synchronously adding fonts even a good idea. It forces parsing on the main thread, no?","msgtype":"m.text"},"ts":1393032121000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Everything has an order in JS, because we're not comfortable with enforcing randomized iteration orders, and anything less creates a compat hazard.","msgtype":"m.text"},"ts":1393032123000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"sicking: Nope, read the spec.  ^_^","msgtype":"m.text"},"ts":1393032135000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It doesn't force any more synchrony than adding a new @font-face to the document via script does.","msgtype":"m.text"},"ts":1393032155000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: sorry, if you want me to read the full spec in full detail you won't get my review","msgtype":"m.text"},"ts":1393032157000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"I wasn't aware we were doing an ad hoc review right now.  ^_^","msgtype":"m.text"},"ts":1393032180000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Normally, questions that can be answered by the spec can be adequately answered by \"read the spec\". ^_^","msgtype":"m.text"},"ts":1393032197000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Actually parsing the font face data is done asynchronously.  We expose a promise for when the font is fully loaded and ready.","msgtype":"m.text"},"ts":1393032232000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1393032254000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"any reason you're not accepting URLs or Blobs in the ctor then","msgtype":"m.text"},"ts":1393032279000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"?","msgtype":"m.text"},"ts":1393032280000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"I am.","msgtype":"m.text"},"ts":1393032286000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"holds off saying \"read the spec\" again...","msgtype":"m.emote"},"ts":1393032293000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"http://dev.w3.org/csswg/css-font-loading/#font-face-constructor step 3","msgtype":"m.text"},"ts":1393032311000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Right now I only accept TypedArrays as direct data, but I could accept a Blob as well I suppose.","msgtype":"m.text"},"ts":1393032363000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ah, URLs are indeed accepted, but not Blobs afaict","msgtype":"m.text"},"ts":1393032370000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"not a big deal as long as URLs are there","msgtype":"m.text"},"ts":1393032386000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"though less leak prone","msgtype":"m.text"},"ts":1393032393000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Well...  Do blobs have serializable URLs?","msgtype":"m.text"},"ts":1393032405000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yes, if you use URL.createObjectURL","msgtype":"m.text"},"ts":1393032429000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Okay.","msgtype":"m.text"},"ts":1393032436000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"but it's leak prone","msgtype":"m.text"},"ts":1393032437000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"It's not a problem to take a Blob directly.","msgtype":"m.text"},"ts":1393032443000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Hm, is there anything weird I need to know about Blobs?  Or does http://dev.w3.org/csswg/css-font-loading/#font-face-constructor step 4 handle Blobs sufficiently?","msgtype":"m.text"},"ts":1393032495000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(Being somewhat generic about \"the data in it\".)","msgtype":"m.text"},"ts":1393032508000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i think that's pretty much good enough","msgtype":"m.text"},"ts":1393032555000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"kk","msgtype":"m.text"},"ts":1393032566000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I'll just add Blob to the BinaryData typedef, then.","msgtype":"m.text"},"ts":1393032576000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(We don't implement the BinaryData side of the constructor quite yet.)","msgtype":"m.text"},"ts":1393032586000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"At some point blobs will have a way to read their data, not in the blob spec yet","msgtype":"m.text"},"ts":1393032590000,"senderName":"annevk-cloud","senderId":"annevk-cloud@irc"},
{"content":{"body":"TabAtkins: i'm still not sure I see the value in the current use of a Set though","msgtype":"m.text"},"ts":1393032606000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"You need that to better deal with failure or the blob being closed and such","msgtype":"m.text"},"ts":1393032625000,"senderName":"annevk-cloud","senderId":"annevk-cloud@irc"},
{"content":{"body":"TabAtkins: Adding a property with an Array seems better","msgtype":"m.text"},"ts":1393032650000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Shrug.  Array has more stuff in it than I needed - all I need is something that'll hold some objects.","msgtype":"m.text"},"ts":1393032654000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(I'm seeing Set as being simpler than an Array.)","msgtype":"m.text"},"ts":1393032665000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: you could make the Array be frozen to avoid worrying about mutations","msgtype":"m.text"},"ts":1393032667000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Nah, we want to allow mutations.","msgtype":"m.text"},"ts":1393032676000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: and add a .add(FontFace) function on the loader","msgtype":"m.text"},"ts":1393032676000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"TabAtkins: including removals?","msgtype":"m.text"},"ts":1393032688000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Why not?","msgtype":"m.text"},"ts":1393032692000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"more code in implementations","msgtype":"m.text"},"ts":1393032701000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"(Note that you can't remove CSS-connected ones, only manually-added ones.)","msgtype":"m.text"},"ts":1393032704000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Why not just say that .delete() and .clear() don't do anything?","msgtype":"m.text"},"ts":1393032759000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I gotta head home - we can pick this up tomorrow.","msgtype":"m.text"},"ts":1393032800000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: how would we implement .delete() not doing anything?","msgtype":"m.text"},"ts":1393032821000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"since we'll likely reuse the actual JS Set implementation","msgtype":"m.text"},"ts":1393032836000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Exactly that way.","msgtype":"m.text"},"ts":1393032838000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"You can override the methods.","msgtype":"m.text"},"ts":1393032842000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i'm not entirely sure how we would implement subclassing Set, so i'm not sure","msgtype":"m.text"},"ts":1393032885000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"but having a .delete() function that didn't delete seems pretty poor","msgtype":"m.text"},"ts":1393032905000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"I mean, it would probably throw instead.","msgtype":"m.text"},"ts":1393033097000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(Subclassing Set/Map is pretty piss-poor right now, I think.)","msgtype":"m.text"},"ts":1393033117000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"agreed. Array too","msgtype":"m.text"},"ts":1393033145000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"(I think the only way to reliably do it is to put Set/Map on your proto chain, for detection purposes, but then implement reimplement all the methods yourself and forward to a contained Set/Map holding the real data.)","msgtype":"m.text"},"ts":1393033170000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i'm kind'a worried that subclassing in JS is entirely broken","msgtype":"m.text"},"ts":1393033170000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"apparently one of the design patterns is to allow base classes to instantiate subclasses","msgtype":"m.text"},"ts":1393033179000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Subclassing works fine in user-land. :/","msgtype":"m.text"},"ts":1393033180000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yeah, i think in user-land they use different rules","msgtype":"m.text"},"ts":1393033222000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"than what tc39 is trying to implement","msgtype":"m.text"},"ts":1393033233000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"at least that's my perception","msgtype":"m.text"},"ts":1393033243000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"heycam: All I really want WebIDL to do is let me define a handful of core methods for my thing, have it act like a Map/Set, and then I never have to worry about it again.","msgtype":"m.text"},"ts":1393033601000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"In particular, \"not worry about it\" means that if new Map/Set methods get added, it can be handled directly in WebIDL, not in every single spec that uses a Map/Set-like interface.","msgtype":"m.text"},"ts":1393033643000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: I don't think we should make WebIDL go beyond what ES6 provides","msgtype":"m.text"},"ts":1393033667000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Also, for friendliness, basic typechecking should work (instanceof), and userland methods added to Map/Set.prototype should work.","msgtype":"m.text"},"ts":1393033673000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"sicking: It's possible that this should be better handled in ES6.  I proposed this a year or so ago, didn't get anywhere with it.","msgtype":"m.text"},"ts":1393033707000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins, those latter points paint us into this awkward corner of subclassing Map where it's not really designed to be subclassed","msgtype":"m.text"},"ts":1393033710000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"TabAtkins: i hear you :(","msgtype":"m.text"},"ts":1393033733000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"(Specifically, I suggested defining a MapCore or whatever class that had just get/set/has/delete, and similar for Set.)","msgtype":"m.text"},"ts":1393033738000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And Map is defined to store its data in an internal MapCore, and other methods are defined on top of that.","msgtype":"m.text"},"ts":1393033769000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Maybe MapCore#clear too, just to let that one be efficient.  Oh, and [iterator], obviously.","msgtype":"m.text"},"ts":1393033793000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"So 5 or 6 core methods, and everything else forever defined on top of just those.","msgtype":"m.text"},"ts":1393033807000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Then WebIDL could specify that when you subclass you can swap out the core for something else that implements the same methods.","msgtype":"m.text"},"ts":1393033875000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And we can expose that to userland via a [core] symbol or something.","msgtype":"m.text"},"ts":1393033888000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"that sounds more much reasonable than the current [MapClass] setup","msgtype":"m.text"},"ts":1393033914000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"plug a map behaviour into a Map object","msgtype":"m.text"},"ts":1393033949000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"Tell that to AWB.","msgtype":"m.text"},"ts":1393033949000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"the alternative is to do something like we want to do with Arrays, where at defined times the browser can update/replace an IDL attribute's Array object, and uses Object.watch on it","msgtype":"m.text"},"ts":1393034111000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"you'd need to forgo exceptions being thrown with bad values inserted into the Map though","msgtype":"m.text"},"ts":1393034120000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"and you'd need a Map.watch mechanism","msgtype":"m.text"},"ts":1393034130000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"A watch mechanism that lets me filter out the bad things before they get used is sufficient.","msgtype":"m.text"},"ts":1393034192000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins, yeah you can always in prose skip over items of bad types","msgtype":"m.text"},"ts":1393034215000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"Since you'd only be able to insert bad things by doing silly monkeypatching, like \"Map.prototype.set.call(mapSubclass, badVal)\"","msgtype":"m.text"},"ts":1393034222000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins, doesn't need to be integrated with the watching mechanism","msgtype":"m.text"},"ts":1393034224000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"yeah, synchronously calling into a validate-value hook would help hugely with DOM APIs","msgtype":"m.text"},"ts":1393034228000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"for all container types","msgtype":"m.text"},"ts":1393034236000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking, I think that argues for the map core kind of pattern","msgtype":"m.text"},"ts":1393034251000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"I wonder if you could retrofit something like that onto Arrays as well","msgtype":"m.text"},"ts":1393034275000,"senderName":"heycam","senderId":"heycam@irc"},
{"content":{"body":"wonders if he is the only one who gets oddly-aligned checkboxes on http://naesten.mooo.com:8080/checkbox-off-kilter.html ...","msgtype":"m.emote"},"ts":1393039099000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: Off kilter for me too, in Chrome stable channel.","msgtype":"m.text"},"ts":1393039129000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"wonders if it's been like this forever and he only just noticed","msgtype":"m.emote"},"ts":1393039227000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"it should be off in any browser due to the table's cellspacing and cellpadding","msgtype":"m.text"},"ts":1393039674000,"senderName":"Goplat","senderId":"Goplat@irc"},
{"content":{"body":"Goplat: does only the one in the table look bad to you?","msgtype":"m.text"},"ts":1393043674000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"They both look fine on their own, they're just not aligned with each other","msgtype":"m.text"},"ts":1393043731000,"senderName":"Goplat","senderId":"Goplat@irc"},
{"content":{"body":"oh, that's really two examples that happen to be in one file","msgtype":"m.text"},"ts":1393043772000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"my problem is that the text seems to be a few pixels below where it ought to be","msgtype":"m.text"},"ts":1393043808000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"foolip is on a roll","msgtype":"m.text"},"ts":1393060999000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Does anything define the initial networkState?","msgtype":"m.text"},"ts":1393061945000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"}
]