[
{"content":{"body":"JakeA: is it not inconvenient that the Cache API does not allow things like .match(url, {headers:{x:\"y\"}})?","msgtype":"m.text"},"ts":1428302679000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: wanderview: was it considered to allow more than http/https URLs in caches?","msgtype":"m.text"},"ts":1428305346000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: that stuff can be added. What use cases are you thinking? Are those matching request or response headers?","msgtype":"m.text"},"ts":1428305812000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I mean constructing Request objects in the same way that fetch() allows for","msgtype":"m.text"},"ts":1428305859000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: nah, it follows http caching rules so it's pretty restricted to http","msgtype":"m.text"},"ts":1428305865000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it doesn't really follow HTTP cache rules","msgtype":"m.text"},"ts":1428305906000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: perhaps HTTP cache matching rules","msgtype":"m.text"},"ts":1428305913000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: but we use HTTP headers and such for other schemes too, and if we allowed other schemes you could more easily abuse it as a key/value store","msgtype":"m.text"},"ts":1428305957000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Ohh, so the API would be .match(url, requestOpt, queryOpts)?","msgtype":"m.text"},"ts":1428305958000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah, I was wondering why that wasn't done","msgtype":"m.text"},"ts":1428305977000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Having to include an empty object just to get at the query options sounds bad","msgtype":"m.text"},"ts":1428306005000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I guess it doesn't matter so much here to have an easy way to construct a Request object","msgtype":"m.text"},"ts":1428306080000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: if there's a way to add non-http in there, I'm cool with it. The way caching is designed is to ensure every item in the cache is matchable","msgtype":"m.text"},"ts":1428306118000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Other than http/https, what were you thinking?","msgtype":"m.text"},"ts":1428306193000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I was initially thinking everything, but that doesn't work well. So maybe something like cachekey URLs (cachekey:item1)... Anyway, later seems fine","msgtype":"m.text"},"ts":1428306275000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"What might also be cool is having a way to refer to Cache API objects from content without having to go through a service worker, but that might be harder for objects that require more than a URL to match on","msgtype":"m.text"},"ts":1428306372000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Or maybe it could be something like <script src=url from=cache>","msgtype":"m.text"},"ts":1428306422000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But that's also awfully similar to the static routes stuff so I'll stop brainstorming now :-)","msgtype":"m.text"},"ts":1428306487000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: what about allowing URL.createObjectURL to take a response object? It'd need to consume the stream potentially into memory through","msgtype":"m.text"},"ts":1428309312000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Hmm, going off that idea already","msgtype":"m.text"},"ts":1428309375000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Maybe createCallbackURL(func), which returns a url, and when that url is loaded it calls the callback which returns a promise for a response","msgtype":"m.text"},"ts":1428309452000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"That callback could be _=> caches.match(\"/whatever\")","msgtype":"m.text"},"ts":1428309501000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"But you could also create your own stream","msgtype":"m.text"},"ts":1428309583000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: either a one-time Response -> URL mapping or supporting Response objects for all possible networking features makes a lot of sense to me","msgtype":"m.text"},"ts":1428312297000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: from past experience I'd prefer starting out with <img>.objectSrc = response over <img>.src = createURLFrom(response) given that the latter has all kinds of warts","msgtype":"m.text"},"ts":1428312372000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: but the latter is more portable...","msgtype":"m.text"},"ts":1428312382000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: and the latter could probably work fine since you just acquire a lock on the stream meaning subsequent use would fail anyway","msgtype":"m.text"},"ts":1428312526000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I wonder what zewt thinks about introducing URLs for Response objects with the same guarantees as blob URLs (except reuse not being possible at all). I'm kind of warming up to the idea since it would be much simpler to roll out across existing features...","msgtype":"m.text"},"ts":1428312841000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ooh exciting, it seems we can let sites control User-Agent soonish :-)","msgtype":"m.text"},"ts":1428314905000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: JakeA: Krinkle|detached: I came up with some better terminology for this whole storage thing: https://etherpad.mozilla.org/storage","msgtype":"m.text"},"ts":1428316681000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: JakeA: Krinkle|detached: will likely update the wiki later","msgtype":"m.text"},"ts":1428316696000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: the benefit of a callback is it'd vend a new response each time, so it can be used more than once. But if that's not useful, it isn't needed","msgtype":"m.text"},"ts":1428317123000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it does seem like it might be more convenient not to have to .then() to get hold of the Response...","msgtype":"m.text"},"ts":1428317373000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So you get code akin to <img>.src = toURL(fetch(...))","msgtype":"m.text"},"ts":1428317436000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"The only weird thing with that is that you invoke all of Fetch twice, once for the URL inside fetch(), and once for the URL returned by toURL()...","msgtype":"m.text"},"ts":1428318191000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"would be great if somebody could post a status report of some kind for the Service Workers specーwhere things are at, what the major remaining issues are","msgtype":"m.text"},"ts":1428320291000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"the traffic on the SW issues tracker is a lot to try to keep up with, and the volume of open issues is pretty high","msgtype":"m.text"},"ts":1428320343000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: I think it's mostly just cleaning up","msgtype":"m.text"},"ts":1428320758000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: we don't have specification blockers for implementing anyway","msgtype":"m.text"},"ts":1428320784000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ok","msgtype":"m.text"},"ts":1428320883000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"I'd volunteer to try to write something up myself based on what I've managed to keep up with from the discussions but I don't reckon I'd do a great job of it","msgtype":"m.text"},"ts":1428320949000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"in other news https://github.com/whatwg/fetch/issues/27 is epic","msgtype":"m.text"},"ts":1428320994000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"and I wonder how long that guy will keep on at https://github.com/whatwg/fetch/issues/28","msgtype":"m.text"},"ts":1428321063000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: so yeah, if you count fetch() as part of service workers I'd mention that as something we need to address","msgtype":"m.text"},"ts":1428321085000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: but I still think that can be additive, and JakeA and Domenic seem to agree","msgtype":"m.text"},"ts":1428321135000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well it seems like the dependency should count","msgtype":"m.text"},"ts":1428321136000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1428321141000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"on another meta-note I wonder how many people are paying attention to the discussions","msgtype":"m.text"},"ts":1428321269000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"looking at https://github.com/whatwg/fetch/issues/27 I see in all that traffic over the last week or whatever it's been, there's just 14 people who have commented","msgtype":"m.text"},"ts":1428321320000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"or maybe that's relatively a lot of commentors, I dunno","msgtype":"m.text"},"ts":1428321333000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"but even then there's only 32 people watching the fetch repo and reckon quite a few of the people watching don't actually read a lot of the messages","msgtype":"m.text"},"ts":1428321408000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"anyway, that's sorta why I suggested some occasional summaries would be nice to haveーto give others a heads-up about what's being discussed and why they should care","msgtype":"m.text"},"ts":1428321551000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: there's not a lot of signal in that thread","msgtype":"m.text"},"ts":1428323720000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: the gist is still that we don't really know how we want to do cancelation","msgtype":"m.text"},"ts":1428323745000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: OK, it's good to know that at least","msgtype":"m.text"},"ts":1428323755000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"I thought I must be missing something","msgtype":"m.text"},"ts":1428323767000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: I'm happy to help btw if anything is unclear","msgtype":"m.text"},"ts":1428325138000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: but afaict some v1 of all these features is being shipped by vendors","msgtype":"m.text"},"ts":1428325151000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: just a bit unclear how to summarize all the minutiae","msgtype":"m.text"},"ts":1428325200000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: MikeSmith: there's been some progress at https://gist.github.com/jakearchibald/9a24f3c06f06b9c06a1e","msgtype":"m.text"},"ts":1428325309000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: occasional stuff like https://annevankesteren.nl/2015/02/cancelable-promises is nice","msgtype":"m.text"},"ts":1428325364000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"looks at https://gist.github.com/jakearchibald/9a24f3c06f06b9c06a1e","msgtype":"m.emote"},"ts":1428325379000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"serendipity :-)","msgtype":"m.text"},"ts":1428325401000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: that's effectively still where we are at :-)","msgtype":"m.text"},"ts":1428325479000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: nice","msgtype":"m.text"},"ts":1428325483000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"(at a summary level, anyway, JakeA is making progress)","msgtype":"m.text"},"ts":1428325503000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: the bit I'm most worried about is the \"gotcha\" bit, but maybe Domenic can find something under the hood that makes it not a problem (I couldn't quite get my head around the spec)","msgtype":"m.text"},"ts":1428325541000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Next step is to build a prototype","msgtype":"m.text"},"ts":1428325549000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: yeah https://gist.github.com/jakearchibald/9a24f3c06f06b9c06a1e seems somewhere beyond where it was at at the time you wrote that blog post","msgtype":"m.text"},"ts":1428325554000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"JakeA: you mean the resolved-but-unsettled promises part?","msgtype":"m.text"},"ts":1428325584000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1428325591000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I see Domenic didn't respond about that part yet","msgtype":"m.text"},"ts":1428325742000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"man this stuff is hairy","msgtype":"m.text"},"ts":1428325759000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: I only made those edits a couple of days ago","msgtype":"m.text"},"ts":1428325759000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"ah ok","msgtype":"m.text"},"ts":1428325763000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"annevk: JakeA: we would have some implementation headaches if we allow \"non-standard\" schemes in Cache...  gecko's requirement to do full url parsing on the main thread is a major pain","msgtype":"m.text"},"ts":1428328951000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I get around that by leaning on the http/https only requirement","msgtype":"m.text"},"ts":1428328959000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"we only check the request url, though... so a SW could always load from some other URL scheme and then manually cache.put() it in with an http request","msgtype":"m.text"},"ts":1428329018000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: JakeA: it seems referring to resources in a Cache directly from static content would need something extra logic to try to fetch if not present in cache...  basically what http cache does today, but it ends up in a named Cache object","msgtype":"m.text"},"ts":1428329551000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah, I think that's why I prefer URLs from Response objects and leave that use case to \"static routing\"","msgtype":"m.text"},"ts":1428330079000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: as for non-standard schemes, we could just allow for one to keep things straightforward","msgtype":"m.text"},"ts":1428330099000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I guess I didn't understand the Response URL thing","msgtype":"m.text"},"ts":1428330102000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"oh, you mean like a URL that says \"load this from a Cache\"?","msgtype":"m.text"},"ts":1428330116000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: a URL that says read this from this Response","msgtype":"m.text"},"ts":1428330246000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: oh, so I still have to have js in the loop... I thought you were trying to allow the page to load from Cache without js","msgtype":"m.text"},"ts":1428330275000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: but yea, the Response URL could be nice for non-SW stuff... I could see things like firefoxos photo gallery using that, etc","msgtype":"m.text"},"ts":1428330340000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"although they've implemented it all as blobs in IDB right now","msgtype":"m.text"},"ts":1428330350000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Fun","msgtype":"m.text"},"ts":1428330365000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"importScripts says \"Resolve<#resolve-a-url> each argument.\"","msgtype":"m.text"},"ts":1428330390000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"#resolve-a-url says \"let base be the element's base URL.\"","msgtype":"m.text"},"ts":1428330402000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"wanderview: yeah the without JavaScript use case is probably best done using static routes for service workers, something we never ended up specifying since we didn't know what the perf hit of service workers was going to be in the first place","msgtype":"m.text"},"ts":1428330426000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it seems now that Cache is on window we don't really need the SW to run in the non-js world...  maybe I don't understand what you mean by \"static routes for service workers\"","msgtype":"m.text"},"ts":1428330559000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: well unless you want to change how you load images (and you might, and for that we have the URL for Response object idea), I'm not sure that Cache available from window will help","msgtype":"m.text"},"ts":1428330691000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"well... images are a special case it seems","msgtype":"m.text"},"ts":1428330719000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Ms2ger: file a bug?","msgtype":"m.text"},"ts":1428331593000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"https://www.w3.org/Bugs/Public/show_bug.cgi?id=28411","msgtype":"m.text"},"ts":1428331604000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"annevk: gotta appreciate the humor of http://www.w3.org/mid/4q03ia5cpqt5m0q867fffniqd6ma20f7qs⊙hbhd","msgtype":"m.text"},"ts":1428331814000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"or at least I assume he was sorta trying to be humorous there (by not directly pointing out that you were the one he was quoting)","msgtype":"m.text"},"ts":1428331888000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: I was about to own up to my past mistake for not addressing the problem until I found sicking's reply and remembered that being the reason","msgtype":"m.text"},"ts":1428331903000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: it was kind of funny I guess, but not super helpful","msgtype":"m.text"},"ts":1428331931000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah saw your reply after that","msgtype":"m.text"},"ts":1428331941000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"yeah, not helpful and not sure he actually meant it to be good-naturedly funny instead of just obnoxious","msgtype":"m.text"},"ts":1428332044000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"anyway, I think I'll take a break for now from pushing my e-mail inbox boulder up the hill, and go to the sento","msgtype":"m.text"},"ts":1428332120000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"nice","msgtype":"m.text"},"ts":1428332679000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: I thought you didn't like magic in your APIs :-)","msgtype":"m.text"},"ts":1428339390000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: not sure what's magical here... a Request/Response can do exactly three things: be written to disk (cache), be written socket (upload), or be read from by script.","msgtype":"m.text"},"ts":1428341217000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I guess now we need to figure out what the APIs are for writing to cache and uploading","msgtype":"m.text"},"ts":1428341244000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I want to understand more why we need to expose the underlying writer for fetch and cache... I mean, are there reasons beyond progress?","msgtype":"m.text"},"ts":1428341322000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: did you see my reply?","msgtype":"m.text"},"ts":1428341339000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I'm also curious if browsers today report progress for \"bytes actually written on tcp connection\"...","msgtype":"m.text"},"ts":1428341361000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: implementing that requires a lot more IPC traffic vs just \"progress based on stuff read from the buffer\"","msgtype":"m.text"},"ts":1428341464000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: maybe I'm too Node-influenced... but there, write(chunk, cb) will only call cb when the OS has accepted the chunk","msgtype":"m.text"},"ts":1428341501000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"that's important for program guarantees","msgtype":"m.text"},"ts":1428341511000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"E.g. where you need to re-try from if there's a failure","msgtype":"m.text"},"ts":1428341528000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think that is harder to guarantee in multi-process architectures where networking is actually done in a separate process... it also doesn't really make any guarantee about it reaching the server","msgtype":"m.text"},"ts":1428341559000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or if you're sending important messages to a server, it helps you maintain invariants","msgtype":"m.text"},"ts":1428341561000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: well, that still doesn't give complete guarantees that the receiving end got it","msgtype":"m.text"},"ts":1428341568000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"sure","msgtype":"m.text"},"ts":1428341572000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"just helps","msgtype":"m.text"},"ts":1428341574000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"e.g. you would base your UI off of it, but you would still validate on the server","msgtype":"m.text"},"ts":1428341597000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess I'm curious what we do today... I would be surprised if gecko provided this kind of progress now... no idea what chrome does","msgtype":"m.text"},"ts":1428341615000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah, maybe we just say that this is not information we think is important to expose to web platform authors?","msgtype":"m.text"},"ts":1428341639000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i mean, not doing it today isn't necessarily an argument against it. but on the other hand i haven't heard people agitating for it.","msgtype":"m.text"},"ts":1428341661000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I've asked in our network channel... no responses yet","msgtype":"m.text"},"ts":1428341710000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Fetch/XHR spec is a bit ambiguous... it says \"Whenever one or more bytes are transmitted\" ... do a bunch of steps then eventually fire a progress event","msgtype":"m.text"},"ts":1428341790000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Not sure if \"transmitted\" here means \"transmitted to the OS\" or...","msgtype":"m.text"},"ts":1428341823000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"probably read from socket or sent to socket","msgtype":"m.text"},"ts":1428341846000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"no, sent to socket wouldn't make sense for upload progress","msgtype":"m.text"},"ts":1428341868000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"is annoyed we have two XHR classes.","msgtype":"m.emote"},"ts":1428341925000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Gecko does?","msgtype":"m.text"},"ts":1428341932000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: yea, one for main thread and one for workers","msgtype":"m.text"},"ts":1428341966000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Good times.","msgtype":"m.text"},"ts":1428341986000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: does XHR provide upload progress?  the code I am looking at mainly seems to do download progress","msgtype":"m.text"},"ts":1428342039000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"oh, nm","msgtype":"m.text"},"ts":1428342053000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"sorry","msgtype":"m.text"},"ts":1428342057000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: Fetch accepts patches","msgtype":"m.text"},"ts":1428342191000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: I stand correct, gecko's XHR reports progress on bytes pushed to the kernel","msgtype":"m.text"},"ts":1428342219000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"corrected","msgtype":"m.text"},"ts":1428342223000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"it's hard to tell what blink's does without opening an actual text editor, too hard to follow the didSendData() / dataSent() code paths through mxr --- but it's probably sent to kernel","msgtype":"m.text"},"ts":1428342299000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"its still a bit lame, though, since the kernel is going to buffer all but the largest uploads anyway","msgtype":"m.text"},"ts":1428342367000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah, but it at least gives you a guarantee the socket is still alive, I assume","msgtype":"m.text"},"ts":1428342421000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but it's not really \"upload progress\"","msgtype":"m.text"},"ts":1428342447000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"its admittedly better than \"bytes read in a child process in the browser\", though","msgtype":"m.text"},"ts":1428342479000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"well I mean, from a developer pov, you probably expect upload progress to indicate the amount of data the recipient has received so far","msgtype":"m.text"},"ts":1428342538000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"which is harder","msgtype":"m.text"},"ts":1428342554000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"i dunno, maybe at first, but if you thought about that for a few seconds you'd realize it makes no real sense","msgtype":"m.text"},"ts":1428342580000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"or does it ... TCP has ACKs...","msgtype":"m.text"},"ts":1428342593000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it doesn't make any sense","msgtype":"m.text"},"ts":1428342595000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"plans more blog posts, this time on \"byte sinks\"","msgtype":"m.emote"},"ts":1428342626000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tangent: do TCP ACKs get exposed in syscalls at all?","msgtype":"m.text"},"ts":1428342690000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"not that we should try to expose those (at least not in a HTTP API), but now I'm curious","msgtype":"m.text"},"ts":1428342714000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think trying to return a promise for every chunk written in a stream is going to be pretty heavyweight from an impl point of view... thinking about what that would mean for my Cache implementation... its not just the cost of a promise... its the promise plus IPC traffic for each chunk... and a lot of added code complexity","msgtype":"m.text"},"ts":1428342730000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"well like","msgtype":"m.text"},"ts":1428342736000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"*looks at libc code :>*","msgtype":"m.text"},"ts":1428342755000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"Domenic: I think you have to look at the window on the TCP stream","msgtype":"m.text"},"ts":1428342776000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: that's good implementer feedback I guess... although you're already doing that for XHR?","msgtype":"m.text"},"ts":1428342810000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: yes, for XHR... but not for Cache","msgtype":"m.text"},"ts":1428342833000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: i see... so you wouldn't be able to signal completion of a write to the filesystem? I mean libuv definitely does this, although they do use threads instead of processes, it's true.","msgtype":"m.text"},"ts":1428342879000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: on the flip side... being able to see stream progress would help let us resolve a cache.put() when headers are available, but then stream to disk in the background... stream progress could be observed to detect errors in body streaming","msgtype":"m.text"},"ts":1428342885000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: today cache.put() is spec'd not to resolve its Promise until all the bytes are on disk","msgtype":"m.text"},"ts":1428342909000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: honestly as a developer i'd be surprised if cache.put() fulfilled earlier","msgtype":"m.text"},"ts":1428342924000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"which is a bit of a wart","msgtype":"m.text"},"ts":1428342926000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I'd definitely want a promise that gets fulfilled only when hte cache successfully has had my thing put in it","msgtype":"m.text"},"ts":1428342938000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: so if you think there's some value in streaming in the background, I'd do something like cache.put() -> { headersDone, allDone } (two promises)","msgtype":"m.text"},"ts":1428342969000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think the spec is a bit confusing on this point now... it currently says you can commit to the Cache before the body is complete... but resolves when the body is complete... so some other cache.match() can get the thing you just put in before your first promise resolves... I haven't implemented any of that because it seems not quite right to me","msgtype":"m.text"},"ts":1428343005000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"(\"there is no mechanism in Linux to wait for a TCP ACK to be received\" http://stackoverflow.com/a/12528808/31910","msgtype":"m.text"},"ts":1428343025000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: I see, yeah...","msgtype":"m.text"},"ts":1428343038000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"that'd be weird...","msgtype":"m.text"},"ts":1428343050000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so if we expose some other WritableStream interface on fetch... what does that mean for Request objects with a body buffer?","msgtype":"m.text"},"ts":1428343074000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"imagine writing half a stream to disk, calling cache.match to get it, then ... reading half the stream? you're now talking to yourself?","msgtype":"m.text"},"ts":1428343076000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: an optimized implementation would stream it off disk as its written to disk... but thats a bit hard I think","msgtype":"m.text"},"ts":1428343113000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: not sure at all... I guess we'd build those on top? So fetch(req) does `req.body.pipeTo(getMeAWritableStreamFor(req.url))`?","msgtype":"m.text"},"ts":1428343117000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Even TCP ack tells you only that a data has successfully delivered to the destination kernel. It's unknown whether the data has been successfully accepted by the application layer or not without involving app layer ack.","msgtype":"m.text"},"ts":1428343144000,"senderName":"tyoshino________","senderId":"tyoshino________@irc"},
{"content":{"body":"wanderview: wait I think what I just wrote is wrong","msgtype":"m.text"},"ts":1428343151000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tyoshino________, that's fine I think --- but it's a moot point if you have to write your own tcp stack to figure out when you get an ACK","msgtype":"m.text"},"ts":1428343174000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"ok so the primitive is ... some kind of httpConnection object per request, with httpConnection.ws being something you can call .write() on.","msgtype":"m.text"},"ts":1428343194000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so fetch(req) creates a httpConnection for req.url, and does req.body.pipeTo(httpConnection.writable) [changing name to avoid auto-linking in IRCcloud]","msgtype":"m.text"},"ts":1428343230000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: what about a compromise where you can pass a ReadableStream to Request() as the body or provide a bodyFactory function that operates on a WritableStream... by default the WritableStream goes to a pipe... but there is a SetWriterableStream() that can be called to override this... must be set before the body is ever read","msgtype":"m.text"},"ts":1428343245000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"whereas cache.add(req) creates a fsWriteStream for a \"file\" whose name is determined by req.url etc., and calls req.body.pipeTo(fsWriteStream)","msgtype":"m.text"},"ts":1428343261000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: that sounds intriguing; what is SetWritableStream? Spec-only operation, or user-exposed?","msgtype":"m.text"},"ts":1428343293000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"right. posix socket API doesnt'","msgtype":"m.text"},"ts":1428343293000,"senderName":"tyoshino________","senderId":"tyoshino________@irc"},
{"content":{"body":"tyoshino________: out of curiousity what APIs do we use in Chrome/Blink? POSIX socket ones, or something more sophisticated?","msgtype":"m.text"},"ts":1428343329000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: user exposed so js library consumers can call it... if its never updated then the bodyFactory is triggered on first body access","msgtype":"m.text"},"ts":1428343336000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: would be nice to provide a progress thing for fixed bodies like ArrayBuffers, though","msgtype":"m.text"},"ts":1428343369000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: hmmmmm this might be something we can work out ... we say that fetch(req) calls req.setWritableStream(httpConnection.writable) or something...","msgtype":"m.text"},"ts":1428343374000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: exactly, yes","msgtype":"m.text"},"ts":1428343386000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: sure, can definitely do once we figure out streams","msgtype":"m.text"},"ts":1428343390000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: For Linux, yes, read(2)","msgtype":"m.text"},"ts":1428343410000,"senderName":"tyoshino________","senderId":"tyoshino________@irc"},
{"content":{"body":"wanderview: I guess the question is then whether we want to spec out httpConnection.writable as something people can access somehow","msgtype":"m.text"},"ts":1428343411000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: i would think that's something for the implementors, not something defined in the spec.","msgtype":"m.text"},"ts":1428343431000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"boogyman: why?","msgtype":"m.text"},"ts":1428343440000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ah, sorry. write()","msgtype":"m.text"},"ts":1428343446000,"senderName":"tyoshino________","senderId":"tyoshino________@irc"},
{"content":{"body":"Domenic: I don't see how we can do that without tackling the promise extension for fetch or a controller object for fetch... leads us to the abortable fetch thing","msgtype":"m.text"},"ts":1428343461000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I mean write(2)","msgtype":"m.text"},"ts":1428343464000,"senderName":"tyoshino________","senderId":"tyoshino________@irc"},
{"content":{"body":"tyoshino________: any ideas on windows or mac? :P","msgtype":"m.text"},"ts":1428343478000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it may be a suggestion, but why should a spec dictate how something is implemented at that level?","msgtype":"m.text"},"ts":1428343486000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"s/?/.","msgtype":"m.text"},"ts":1428343495000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"wanderview: hmm don't see how they're related... I mean in theory it could be like a new fetchUpload API.","msgtype":"m.text"},"ts":1428343497000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"boogyman: sorry, maybe I missed what you were referring to? Are you saying we shouldn't expose a writable stream for HTTP connections?","msgtype":"m.text"},"ts":1428343518000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: oh... i thought we wanted to maintain fetch() as a function... I guess we need to talk to annevk","msgtype":"m.text"},"ts":1428343526000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: well I'm just going crazy here in this channel, who knows","msgtype":"m.text"},"ts":1428343537000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I can try to sketch out the setWritableStream thing in the issue... I have to head to the airport in a little bit, though","msgtype":"m.text"},"ts":1428343553000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: no problem, I can do it","msgtype":"m.text"},"ts":1428343560000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Not familiar but quick codesearch tells me that WSASend for Win, and POSIX for Mac","msgtype":"m.text"},"ts":1428343562000,"senderName":"tyoshino________","senderId":"tyoshino________@irc"},
{"content":{"body":"wanderview: but the question is where do these writable streams come from, that people (who are not UAs) pass to setWritableStream()","msgtype":"m.text"},"ts":1428343582000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tyoshino________: cool, thanks ^_^","msgtype":"m.text"},"ts":1428343591000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: WritableStream has a constructor, no?","msgtype":"m.text"},"ts":1428343601000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: sure. But why can't you get a writable stream for HTTP uploads?","msgtype":"m.text"},"ts":1428343615000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: I mean a direct one, not a pipe","msgtype":"m.text"},"ts":1428343624000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I still think we want some pipe construct as well that people could use for this","msgtype":"m.text"},"ts":1428343626000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: no, i'm saying that the spec should not dictate how that stream is exposed, just that one is exposed","msgtype":"m.text"},"ts":1428343633000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"boogyman: oh, sure. not sure what i said that contradicts that.","msgtype":"m.text"},"ts":1428343652000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I don't understand what a \"HTTP uploads\" stream would do without the rest of the network stack behind it","msgtype":"m.text"},"ts":1428343666000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: why wouldn't it have the rest of the network stack behind it?","msgtype":"m.text"},"ts":1428343681000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic\twanderview: hmmmmm this might be something we can work out ... we say that fetch(req) calls req.setWritableStream(httpConnection.writable) or something...","msgtype":"m.text"},"ts":1428343689000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"unless i misread","msgtype":"m.text"},"ts":1428343696000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"Domenic: how do you get a TCP connection without doing a fetch()?","msgtype":"m.text"},"ts":1428343712000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"boogyman: maybe, don't take the code too literally  I guess","msgtype":"m.text"},"ts":1428343715000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: ah, you wouldn't, you definitely would need some new API that gets a TCP connection","msgtype":"m.text"},"ts":1428343729000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: the trick is this API can't involve Request since Request is too generic","msgtype":"m.text"},"ts":1428343736000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"okay, that was intended as pseudo-code. carry on.","msgtype":"m.text"},"ts":1428343758000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"wanderview: strawperson: fetch.upload(url, method, headers) -> Promise<WritableStream>?","msgtype":"m.text"},"ts":1428343773000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"does webrtc use tcp for networking?","msgtype":"m.text"},"ts":1428343780000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"(off-topic, just wondering)","msgtype":"m.text"},"ts":1428343786000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"caitp-: probably UDP? video/audio is generally cited as something that doesn't need reliabiity and hates latency","msgtype":"m.text"},"ts":1428343810000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"stackoverflow says it can be but doesn't need to be","msgtype":"m.text"},"ts":1428343812000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"yeah, that's why I was wondering","msgtype":"m.text"},"ts":1428343821000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"Domenic: but not a Request object?","msgtype":"m.text"},"ts":1428343844000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: well Request has the problem that people could put it in a cache or something instead of just writing to it, right? that's how we got started here...","msgtype":"m.text"},"ts":1428343885000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I thought one of the goals was to provide primitives like Request which could be used throughout many APIs","msgtype":"m.text"},"ts":1428343931000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"routing around the primitive seems a step backwards","msgtype":"m.text"},"ts":1428343941000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: me too, but it sounds like Request was not primitive enough :(","msgtype":"m.text"},"ts":1428343946000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"a queue with readable side and writable side?","msgtype":"m.text"},"ts":1428343991000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"if it can be read by anyone (cache, author code, etc.), it can't represent the primitive operation of an actual ongoing HTTP request (whose body can only be read by the UA/OS)","msgtype":"m.text"},"ts":1428343995000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tyoshino: that doesn't really solve things though. Authors write into the writable side, the UA reads from the readable side, and does ... what? Magic that writes to the TCP socket?","msgtype":"m.text"},"ts":1428344041000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tyoshino: I'm trying to say there should be a writable stream authors can get to that represents that TCP socket","msgtype":"m.text"},"ts":1428344053000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so, fetch() is being used primarily for pretty high-level operations, this isn't something that emscripten would want to use for a pretend posix socket api","msgtype":"m.text"},"ts":1428344100000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"why does it need to be so primitive?","msgtype":"m.text"},"ts":1428344106000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"authors aren't going to want to be writing libc code in js","msgtype":"m.text"},"ts":1428344113000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"BTW just as a general sentiment check: I am feeling positive and the last 30 minutes have gotten ideas flowing :). If I seem like I'm pushing against things I'm really just trying to explore the spaces and make sure we're doing the right thing.","msgtype":"m.text"},"ts":1428344122000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"caitp-: fetch was/is supposed to be a low-level primitive","msgtype":"m.text"},"ts":1428344145000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"caitp-: library authors will in general want control","msgtype":"m.text"},"ts":1428344154000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i think library authors are generally pretty happy with what XHR gives them","msgtype":"m.text"},"ts":1428344177000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"O_O","msgtype":"m.text"},"ts":1428344183000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think there is an inherent mismatch with your writer-per-active-operation goal and the operation-as-object-concept of Request... let me gist something...","msgtype":"m.text"},"ts":1428344195000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: agree.","msgtype":"m.text"},"ts":1428344223000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"hmm, the key point of the discussion is the meaning of write() completion?","msgtype":"m.text"},"ts":1428344434000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"sorry. i haven't caught up with the log. I was watching only the issue.","msgtype":"m.text"},"ts":1428344477000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Domenic: something like this? https://gist.github.com/wanderview/ac6052184c62d2f165ee","msgtype":"m.text"},"ts":1428344606000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"maybe lose the bodyAsWriter","msgtype":"m.text"},"ts":1428344617000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"not sure if consumers of Request should be required to call setWriter or not","msgtype":"m.text"},"ts":1428344669000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"is req.body.closed  a promise?","msgtype":"m.text"},"ts":1428344714000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"boogyman: I was thinking it was something that existed as a promise... but I could be wrong","msgtype":"m.text"},"ts":1428344736000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yes, it's a promise","msgtype":"m.text"},"ts":1428344746000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"a getter of a promise","msgtype":"m.text"},"ts":1428344760000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"new Request(url, { body (String | Stream | ArrayBuffer | ...) }) --- different behaviour depending on what type Body is","msgtype":"m.text"},"ts":1428344811000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"would make more sense to most people, tbh","msgtype":"m.text"},"ts":1428344825000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"though it's gone from body now and lives only on reader","msgtype":"m.text"},"ts":1428344833000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"caitp-: is that \"Stream\" a ReadableStream or a WritableStream?","msgtype":"m.text"},"ts":1428344877000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"well it has to be readable","msgtype":"m.text"},"ts":1428344885000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"wanderview: that looks more or less good, I have some cosmetic comments. But my question is, when fetch calls setWriter, what argument does it use?","msgtype":"m.text"},"ts":1428344888000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but you probably want it to be writable too","msgtype":"m.text"},"ts":1428344893000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"caitp-: thats what I want... pass ReadableStream to constructor... but to get the progress semantics Domenic wants and XHR currently provides, we need to allow access to a consumer-specific WritableStream","msgtype":"m.text"},"ts":1428344927000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I don't think that's really true","msgtype":"m.text"},"ts":1428344952000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"Domenic: a private implementation of WritableStream","msgtype":"m.text"},"ts":1428344953000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: OK. Why is it private?","msgtype":"m.text"},"ts":1428344960000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: why does only the UA get to create WritableStreams representing sockets?","msgtype":"m.text"},"ts":1428344982000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"you don't really get progress semantics from the number of bytes you've pushed to a writable stream","msgtype":"m.text"},"ts":1428344986000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"Domenic: because it could be c++ and it will depend on internal implementation details that can't be spec'd?","msgtype":"m.text"},"ts":1428344997000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"caitp-: Domenic wants the consumer stream to not resolve the write() promises until its pushed to the kernel","msgtype":"m.text"},"ts":1428345016000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"caitp-: which is why a pipe primitive is not adequate here","msgtype":"m.text"},"ts":1428345029000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: nah :P. its observable behavior should be interoperable. it could be C++ sure, but it could be exposed to JS if we wanted it to.","msgtype":"m.text"},"ts":1428345047000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: because its not safe to expose sockets on the web?  or are we doing the TCP spec now? :-)","msgtype":"m.text"},"ts":1428345054000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"s/should be/could be specced to be/","msgtype":"m.text"},"ts":1428345057000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"what if --- and hear me out here --- what if pushing to a writable stream was not related to progress at all","msgtype":"m.text"},"ts":1428345066000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"wanderview: haha, well, http://www.w3.org/2012/sysapps/tcp-udp-sockets/, but leaving that aside","msgtype":"m.text"},"ts":1428345069000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: we have one for firefoxos, too","msgtype":"m.text"},"ts":1428345081000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: it's not a socket though, it's just a writable stream with HTTP semantics","msgtype":"m.text"},"ts":1428345083000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"what if you had some kind of, I don't know, upload event tied to actually pushing the data to the kernel","msgtype":"m.text"},"ts":1428345085000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"sort of like what already exists","msgtype":"m.text"},"ts":1428345091000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"caitp-: I would be quite happy with a progress notifier separate from the stream","msgtype":"m.text"},"ts":1428345094000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: maybe the API is something like new HttpUploadStream(url, method, headers)","msgtype":"m.text"},"ts":1428345107000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"caitp-: we probably want that too. but it should be explicable in terms of the stream primitive. i.e., when you drop down to the stream level, you shouldn't lose power. we should layer things appropriately.","msgtype":"m.text"},"ts":1428345146000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: what does it do if you don't attach it to a fetch() call?","msgtype":"m.text"},"ts":1428345147000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"what is the thing gained from explaining it in terms of the stream, other than making the stream interface more complicated?","msgtype":"m.text"},"ts":1428345171000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"wanderview: just waving my hands here, but you don't need to fetch() a HttpUploadStream. fetch() is explained in terms of HttpUploadStream, not the other way around.","msgtype":"m.text"},"ts":1428345182000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: similar to how, say, cache.add could be explained in terms of a WritableFileStream or maybe WritableDatabaseEntryStream","msgtype":"m.text"},"ts":1428345251000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so you are talking about blowing up all the stuff coming from ServiceWorker effort and replacing it with a streams foundation, no?  this seems like a huge undertaking","msgtype":"m.text"},"ts":1428345346000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: it's fine if HttpUploadStream is private for now. Maybe it stays private forever. But I want us to kind of acknowledge that our mental model includes more capabilities for the UA than the script, and then question whether we expose them","msgtype":"m.text"},"ts":1428345366000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"and in theory these specs tried to accomodate streams being added","msgtype":"m.text"},"ts":1428345371000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"operation stream is one possible solution. it can propagate written-to-kernel event.","msgtype":"m.text"},"ts":1428345380000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"wanderview: no, not at all! I'm saying that we're continuing to do archeology, and we have to ask at each layer whether we've gotten to the bedrock or not","msgtype":"m.text"},"ts":1428345397000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I have to admit I actually said \"dear god no\" when I read \"WritableDatabaseEntryStream\" :-)","msgtype":"m.text"},"ts":1428345428000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: what we're discovering is that the SW APIs are not bedrockey---Request/Response especially, since they abstract multiple things: writing to a cache, uploading, and being able to be read from user code","msgtype":"m.text"},"ts":1428345436000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: doing this kind of thing adds a lot of complexity and constrain on the implementation... I would want to see huge benefits before agreeing to that","msgtype":"m.text"},"ts":1428345453000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: hmmmm but don't you want the ability to do streaming writes to IndexedDB at some point in the future?","msgtype":"m.text"},"ts":1428345455000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"> IndexedDB","msgtype":"m.text"},"ts":1428345473000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"wanderview: that makes sense, it's a reasonable argument for keeping HttpUploadStream private for now until someone clamors for it.","msgtype":"m.text"},"ts":1428345491000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: although I'd be curious how much extra work/constraints it adds to wrap up the code you were going to use anyway into a writable stream.","msgtype":"m.text"},"ts":1428345511000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: solve abortable fetch and promise extension first?  because what you really are asking for is rich promises of future behavior... say activities or maybes tasks...","msgtype":"m.text"},"ts":1428345517000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ducks","msgtype":"m.emote"},"ts":1428345520000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: totally fair to solve those first :)","msgtype":"m.text"},"ts":1428345534000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: I am reasonably happy with this mental model at least","msgtype":"m.text"},"ts":1428345547000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the problem is when the spec assumes a particular implementation that cannot be easily mapped to all vendors","msgtype":"m.text"},"ts":1428345564000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: as long as we are OK with authors not getting good progress event semantics out of the pipe model that we'd start with","msgtype":"m.text"},"ts":1428345567000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"going to low risks making things \"assuming its implemented like chrome, then its easy...\", etc","msgtype":"m.text"},"ts":1428345584000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: well it probably helps that I don't know too much about Chrome's implementation and make unreasonable demands of everyone :)","msgtype":"m.text"},"ts":1428345602000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: and I do think we want streams to IDB... but I don't know we need an abstract \"DatabaseEntry\" interface to do that","msgtype":"m.text"},"ts":1428345640000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"what are the use cases that Fetch (the api, not the XHR backend) has to accomodate?","msgtype":"m.text"},"ts":1428345652000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"is there like an explicit set of requirements that have been figured out?","msgtype":"m.text"},"ts":1428345664000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"wanderview: haha OK (re IDB)","msgtype":"m.text"},"ts":1428345673000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"caitp-: probably a question for annevk","msgtype":"m.text"},"ts":1428345676000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"i'm curious where streams need to fit into it at all, since the only thing I can think of would be uploading something that was already cached, or downloading something and using the body stream as an upload to something else","msgtype":"m.text"},"ts":1428345741000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"tunes into the IDB discussion...","msgtype":"m.emote"},"ts":1428345764000,"senderName":"jsbell_gardener","senderId":"jsbell_gardener@irc"},
{"content":{"body":"caitp-: did you see https://github.com/domenic/streams-demo ? that's another use case that was impossible with XHR/non-streaming approaches","msgtype":"m.text"},"ts":1428345826000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"caitp-: https://domenic.github.io/streams-demo/ is nicer","msgtype":"m.text"},"ts":1428345838000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: do you anticipate adding a pipe construct to the streams spec?  by which I mean an object type that provides ReadableStream, WritableStream, and a (possibly fixed) buffer","msgtype":"m.text"},"ts":1428345913000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"caitp-: do you agree that we need to expose streams?","msgtype":"m.text"},"ts":1428345918000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: I'd like to avoid fetchUpload(), that sounds rather terrible","msgtype":"m.text"},"ts":1428345934000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think it would be nice to have, buuuut","msgtype":"m.text"},"ts":1428345940000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"wanderview: yes, definitely. Although I'd probably call it \"Identity Transform Stream\"","msgtype":"m.text"},"ts":1428345942000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i'm not totally convinced by the use cases","msgtype":"m.text"},"ts":1428345949000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"Domenic: I can't tell if you are just messing with me now :-)","msgtype":"m.text"},"ts":1428345962000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but I shall not object over names :-)","msgtype":"m.text"},"ts":1428345987000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: no, I'm not, I promise! We even have a prototype (which suffers from a number of issues related to nobody giving it any love in a while): https://github.com/whatwg/streams/blob/master/reference-implementation/lib/transform-stream.js","msgtype":"m.text"},"ts":1428345993000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"if it's not something that authors are asking for, why make an api complicated just to accomodate it?","msgtype":"m.text"},"ts":1428345996000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"simpler is better :>","msgtype":"m.text"},"ts":1428346005000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"caitp-: developers have been asking for streams for ages","msgtype":"m.text"},"ts":1428346012000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"to accomodate what, though","msgtype":"m.text"},"ts":1428346020000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"caitp-: did you not see the huge twitter blow-up about devs asking for streams just two weeks ago?","msgtype":"m.text"},"ts":1428346022000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"caitp-: we've wanted to add this to XMLHttpRequest since 2008 or so","msgtype":"m.text"},"ts":1428346034000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"what I'm asking is, what problem is it actually solving for them, and could that problem be solved in a nicer way","msgtype":"m.text"},"ts":1428346079000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"Domenic: ok... so like node's Transform","msgtype":"m.text"},"ts":1428346095000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"caitp-: the ability to process data in chunks rather than having it all buffered or written to disk","msgtype":"m.text"},"ts":1428346113000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: yes, but without the silly squash-everything-into-one-object issue","msgtype":"m.text"},"ts":1428346119000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"shudders ... node transform streams prototypally inherit from readable stream, then copy over all the writable stream methods and private state, and then they get confused because e.g. an \"error\" event can come from either side...","msgtype":"m.emote"},"ts":1428346164000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk I'm primarily talking about the upload stream though","msgtype":"m.text"},"ts":1428346269000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"Domenic: I guess I worry that progress via WritableStream makes it kind of hard for people to get progress... I mean... it seems like there should be an easier way if you wouldn't have been going the WritableStream route to begin with","msgtype":"m.text"},"ts":1428346317000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"caitp-: if you want a simple one-way channel that seems ideal","msgtype":"m.text"},"ts":1428346422000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: maybe there could be a request.bodyWritten promise which is the value returned from ws.write(body).... or could we set it as the value of body.pipeTo(ws)? does that promise reflect actual written status?","msgtype":"m.text"},"ts":1428346433000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I agree we should add an easy progress API on top. Is that related to the request.bodyWritten promise?","msgtype":"m.text"},"ts":1428346478000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"starts packing up to go to the airport.","msgtype":"m.emote"},"ts":1428346478000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: yea... I meant a simple promise they could resolve when the bytes from a fixed or ReadableStream body have been written to the consumer-specific WritableStream","msgtype":"m.text"},"ts":1428346508000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or that WritableStream resolves and says the bytes are at the kernel, I mean","msgtype":"m.text"},"ts":1428346526000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"body.pipeTo(ws) ... currently that will fulfill early if ws buffers some writes ... that seems wrong though, we should fix that to fulfill only after all writes and the close complete. Or maybe it already does and I'm confused.","msgtype":"m.text"},"ts":1428346527000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: it seems the WritableStream implementation could make that determination by setting its internal buffer to \"zero\" effectively?","msgtype":"m.text"},"ts":1428346554000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I don't know if that's as useful as just progress events or similar on the Request object...","msgtype":"m.text"},"ts":1428346557000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"or just lying","msgtype":"m.text"},"ts":1428346561000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: ok","msgtype":"m.text"},"ts":1428346567000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah I think so.","msgtype":"m.text"},"ts":1428346568000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: ok, I'll stop pestering you with this stuff now :-) later","msgtype":"m.text"},"ts":1428346596000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: not sure how much wiggle room there still is, but if we need to redesign certain pieces it'd be good to raise an issue on them","msgtype":"m.text"},"ts":1428346635000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: no problem! this was pretty great I think. Have a good flight!","msgtype":"m.text"},"ts":1428346837000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: yeah... I think the setWritable idea is pretty reasonable now that I keep turning it over in my head. I tried to outline it more in the issue.","msgtype":"m.text"},"ts":1428346859000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: pipeTo() promise fulfills once the source is done and dest.ready fulfills","msgtype":"m.text"},"ts":1428346893000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"currently.","msgtype":"m.text"},"ts":1428346902000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"tyoshino: that seems bad, hmm, we should wait for dest.closed I think","msgtype":"m.text"},"ts":1428346911000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"on the other hand it has the flavor of something i already thought about and put the current behavior in for a good reason... darn past-Domenic.","msgtype":"m.text"},"ts":1428346951000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: looks reasonable","msgtype":"m.text"},"ts":1428346954000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: \\o/","msgtype":"m.text"},"ts":1428346962000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: though I also got excited by the redesign everything ideas :p","msgtype":"m.text"},"ts":1428346979000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hahaha","msgtype":"m.text"},"ts":1428347028000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: I'm leaving... but it occurs to me... will the fetch() sanitize step play havoc with this setWriter() plan?  since fetch is operating on a copy of the request?","msgtype":"m.text"},"ts":1428347175000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: Yes. It was discussed in past at https://github.com/whatwg/streams/issues/236#issue-46428456","msgtype":"m.text"},"ts":1428347269000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"wanderview: no, the stream is carefully moved","msgtype":"m.text"},"ts":1428347291000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"cool","msgtype":"m.text"},"ts":1428347300000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ok, nye","msgtype":"m.text"},"ts":1428347302000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"bye","msgtype":"m.text"},"ts":1428347303000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: sort of akin to Domenic's design","msgtype":"m.text"},"ts":1428347305000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: safe travels","msgtype":"m.text"},"ts":1428347310000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: wanderview should get most of the credit for that design (if you're referring to the one I just left a comment about on GitHub)","msgtype":"m.text"},"ts":1428347337000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tyoshino: it seems like where we ended up in that thread was that it should wait for the write (and close?) to complete, but we forgot to implement that","msgtype":"m.text"},"ts":1428347505000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tyoshino: no, wait, we did implement it. dest.close().then(resolvePipeToPromise, rejectPipeToPromise)","msgtype":"m.text"},"ts":1428347539000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ah. preventClose == false","msgtype":"m.text"},"ts":1428347576000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"right, I see. In the preventClose === true case our semantics are perhaps unexpected","msgtype":"m.text"},"ts":1428347612000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I will open an issue","msgtype":"m.text"},"ts":1428347619000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: BTW, I'd like to get your comment on what I was suggesting.","msgtype":"m.text"},"ts":1428347737000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"tyoshino: operationstream as a solution, you mean?","msgtype":"m.text"},"ts":1428347753000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yes","msgtype":"m.text"},"ts":1428347757000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"It was basically","msgtype":"m.text"},"ts":1428347775000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"sorry I was unclear","msgtype":"m.text"},"ts":1428347780000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"but it's","msgtype":"m.text"},"ts":1428347783000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Request/Response has an extended ReadableStream side (possible hidden)","msgtype":"m.text"},"ts":1428347808000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"fetch(), cache.put(), etc. pipes the extended ReadableStream and WritableStream (CacheWritableStream, etc.)","msgtype":"m.text"},"ts":1428347835000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"CacheWritableStream (possibly hidden or public)","msgtype":"m.text"},"ts":1428347857000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"The extended ReadableStream can propagate completion of consumption to the Readable side of Request/Response","msgtype":"m.text"},"ts":1428347902000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"e.g. written to the kernel, that is represented by write() completion of CacheWritableStream, HttpUploadWritableStream","msgtype":"m.text"},"ts":1428347928000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"right ... I guess I am still cautious about conflating enqueuing into a readable stream's with writing to a writable stream, and thus indirectly to an underlying sink.","msgtype":"m.text"},"ts":1428347986000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"also, i can't imagine a non-awkward API for acknowledging reads","msgtype":"m.text"},"ts":1428347998000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I'm concerned, if","msgtype":"m.text"},"ts":1428348025000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"We want to build longer chain","msgtype":"m.text"},"ts":1428348033000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"if the idea of setWriter that is kinda propagating the sink itself to left","msgtype":"m.text"},"ts":1428348103000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"is better or not","msgtype":"m.text"},"ts":1428348112000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"\"propagating the sink itself to left\"?","msgtype":"m.text"},"ts":1428348156000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hmm. I don't know if we really want to create such a longer chain","msgtype":"m.text"},"ts":1428348164000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"left of the chain","msgtype":"m.text"},"ts":1428348190000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"a -> b -> c","msgtype":"m.text"},"ts":1428348192000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"still a bit confused ... let's say I have res1.body -> transform1 -> transform2 -> res2.bodyWriter (a HttpUploadStream). What are you worried about?","msgtype":"m.text"},"ts":1428348247000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"setWriter is kinda collapsing Request and fetch(). right?","msgtype":"m.text"},"ts":1428348257000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"It's saying \"this Request now represents a fetch, not a cache write or anything else\", is how I think of it.","msgtype":"m.text"},"ts":1428348291000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"In that chain, can res1.body know when a chunk it generated has been successfully uploaded?","msgtype":"m.text"},"ts":1428348414000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Does it need to be this Request or can it be that the stream is now associated with a fetch?","msgtype":"m.text"},"ts":1428348423000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Because it's more like we discard the Request and use its stream...","msgtype":"m.text"},"ts":1428348449000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well wanderview's gist makes it so you keep using the Request object ... do you think that's unworkable?","msgtype":"m.text"},"ts":1428348489000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: currently no ... pipe discards write() return values and only reacts to errors and backpressure","msgtype":"m.text"},"ts":1428348513000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"sorry, s/wanderview/tyoshino/","msgtype":"m.text"},"ts":1428348522000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Right. And my understanding is the goal of that is making the promise returned by write() to represent commit to file, DB, network, etc.?","msgtype":"m.text"},"ts":1428348568000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"tyoshino: yeah","msgtype":"m.text"},"ts":1428348574000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: not sure","msgtype":"m.text"},"ts":1428348581000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: see step 2 of https://fetch.spec.whatwg.org/#dom-global-fetch","msgtype":"m.text"},"ts":1428348597000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: hmm I see","msgtype":"m.text"},"ts":1428348626000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: I would imagine it could be made to work. But the question is, what do we want developers to be doing. We could also do const upload = fetch(request); upload.bodyWriter.write() with a promise subclass, I guess.","msgtype":"m.text"},"ts":1428348674000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"OK. So, we can know at each point of the chain that the right half of the chain has finished consumption via write() promise","msgtype":"m.text"},"ts":1428348695000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"tyoshino: we could, yeah, although we currently don't, hmm.","msgtype":"m.text"},"ts":1428348737000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tyoshino: the complicating factor here is that we generally anticipate some queues being introduced in each intermediate step","msgtype":"m.text"},"ts":1428348754000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i'm basically trying investigate if this appraoch works well with BYOB streaming","msgtype":"m.text"},"ts":1428348771000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Ah, good question","msgtype":"m.text"},"ts":1428348779000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think for developers the easiest would be to pass a writable to Request or fetch() and have that just work","msgtype":"m.text"},"ts":1428348806000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"maybe i'm too pessimistic","msgtype":"m.text"},"ts":1428348818000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Domenic: regardless of who reads","msgtype":"m.text"},"ts":1428348820000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"but to make sure...","msgtype":"m.text"},"ts":1428348822000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"annevk: how do they create the writable? they can't create HttpUploadStreams...","msgtype":"m.text"},"ts":1428348843000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"maybe in general transformation consumes data and generate something new to the left","msgtype":"m.text"},"ts":1428348853000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"s/left/right/","msgtype":"m.text"},"ts":1428348857000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Domenic: body: ws => ... or some such?","msgtype":"m.text"},"ts":1428348897000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: the moment you start the operation the callback gets invoked and hands you a writeable","msgtype":"m.text"},"ts":1428348924000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: right, that was where we started, but wanderview didn't like it :)","msgtype":"m.text"},"ts":1428348944000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so, for most of transform, whether transformX has consumed the ArrayBufferView passed to transformX is meaningful","msgtype":"m.text"},"ts":1428348960000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Domenic: this would either be for req = new Req(..., body ...); req.body.getReader(); or when you pass to fetch(), or when you pass to cache","msgtype":"m.text"},"ts":1428348965000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"transformX -> transformY","msgtype":"m.text"},"ts":1428348965000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Domenic: I see","msgtype":"m.text"},"ts":1428348971000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"tyoshino: that sounds right to me.","msgtype":"m.text"},"ts":1428348974000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: well the alternative is to pipe it to HttpUploadStream","msgtype":"m.text"},"ts":1428349004000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ok. then, I think the concern I had only applies to a simple queue.","msgtype":"m.text"},"ts":1428349007000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Domenic: and maybe the UA can do magic to make the piping disappear","msgtype":"m.text"},"ts":1428349020000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: the main arguments against it were in response to https://github.com/yutakahirano/fetch-with-streams/issues/30#issuecomment-90151618 but yeah agreed on pipe to HttpUploadStream","msgtype":"m.text"},"ts":1428349062000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: thanks for the pointer, I guess I should talk to wanderview about my concerns","msgtype":"m.text"},"ts":1428349129000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: and maybe he can do something even cleverer","msgtype":"m.text"},"ts":1428349139000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"You said we may add an identity transform to address wanderview's needs. We might need to give the identity transform ability to propagate consumption completion signal when we designing BYOB ecosystem.","msgtype":"m.text"},"ts":1428349162000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"Not sure now...","msgtype":"m.text"},"ts":1428349169000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"tyoshino: that's a good test case, very interesting. Existing transform has I believe (enqueue, done, close, error) or something, although that could become promise-returning (enqueue, close, error). Maybe the done() signal is enough to say it's consumed? But, would be worth exploring more.","msgtype":"m.text"},"ts":1428349232000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tyoshino: are trailers high-priority? I guess we want to do them after streams?","msgtype":"m.text"},"ts":1428349256000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah. let's at least investigate","msgtype":"m.text"},"ts":1428349263000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"annevk: yeah","msgtype":"m.text"},"ts":1428349272000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"annevk: i was requested to bring it up to the standardization body","msgtype":"m.text"},"ts":1428349302000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"louiscryan who's on the issue is actual gRPC developer","msgtype":"m.text"},"ts":1428349345000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"I don't know exact timeframe yet. But I just thought it's better to think of interference with streams, etc. earlier.","msgtype":"m.text"},"ts":1428349427000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"tyoshino: sgtm","msgtype":"m.text"},"ts":1428349440000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Actual spec-cing may be not so urgent","msgtype":"m.text"},"ts":1428349442000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"tyoshino: also, any thoughts on the HTTP proxy authentication thing from https://github.com/slightlyoff/ServiceWorker/issues/533 ?","msgtype":"m.text"},"ts":1428349454000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"tyoshino: there's a feature to prevent redirects, but HTTP proxy authentication could still require the entire upload stream to be teed","msgtype":"m.text"},"ts":1428349491000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"tyoshino: and while we could indeed invent another server protocol to do some damage control, that hardly seems elegant","msgtype":"m.text"},"ts":1428349526000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"nothing new than what i said in the comment so far. i need to learn more about difficulties you described in your comment","msgtype":"m.text"},"ts":1428349571000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1428349594000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"so basically before Fetch hits the network the request body is teed","msgtype":"m.text"},"ts":1428349623000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"i'd basically like to avoid involvement by protocol layer","msgtype":"m.text"},"ts":1428349630000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"this is done for 1) redirects 2) HTTP auth 3) HTTP proxy auth","msgtype":"m.text"},"ts":1428349634000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"automatic HTTP auth is disabled by fetch() so 2 is not relevant, 1 can be disabled using { redirect: \"error\" }","msgtype":"m.text"},"ts":1428349674000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"leaves 3 :-(","msgtype":"m.text"},"ts":1428349679000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ya...","msgtype":"m.text"},"ts":1428349743000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"if you find anyone within Chrome happy to discuss HTTP proxy auth please send them my way :-)","msgtype":"m.text"},"ts":1428349788000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ok. i'll chime someone","msgtype":"m.text"},"ts":1428349851000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"going to bed. ttyl :)","msgtype":"m.text"},"ts":1428349925000,"senderName":"tyoshino","senderId":"tyoshino@irc"},
{"content":{"body":"same here, hope you're not in Tokyo atm :p","msgtype":"m.text"},"ts":1428349962000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"@Domenic - fyi, you may have rushed your description for https://github.com/whatwg/streams/issues/314.  check preventClose: false vs preventClose: true","msgtype":"m.text"},"ts":1428350239000,"senderName":"neonstalwart","senderId":"neonstalwart@irc"},
{"content":{"body":"neonstalwart: thanks, fixed!","msgtype":"m.text"},"ts":1428350547000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: yes, the fact that fetch throws away the Request was what concerned me...  I think its somewhat mitigated in that you cannot reuse a drained Request","msgtype":"m.text"},"ts":1428351847000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but we've been trying to avoid consumer state on the Request","msgtype":"m.text"},"ts":1428351860000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: Domenic: I'm ok with new Request(url, { body: ws => blah }) if there is still an option to pass a ReadableStream in the constructor... it would just have to get progress through an alternate path, which I think Domenic said he was ok with...  The WritableStream approach is really only necessary if you need to know when the bytes are written to the","msgtype":"m.text"},"ts":1428351951000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"kernel","msgtype":"m.text"},"ts":1428351951000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"(or when you're working with an abstraction or library that expects data sinks to be represented as writable streams!)","msgtype":"m.text"},"ts":1428352001000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1428352009000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"And yeah, I think response.addEventListener(\"progress\", ...), if nothing else, is totally fine to build on top of streams once we know those semantics.","msgtype":"m.text"},"ts":1428352048000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"oh in this case it would be request though, which brings us back to the is-request-heavy-or-light question","msgtype":"m.text"},"ts":1428352076000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think you would have to do fetch(request, {progress: handler});  not sure what annevk feels about that","msgtype":"m.text"},"ts":1428352109000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"which I like... because I don't want to bite off providing progress from Cache right now","msgtype":"m.text"},"ts":1428352251000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: what happens if someone does var r = new Request(url, { body: ws => blah); r.body.getReader().read()?","msgtype":"m.text"},"ts":1428352309000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"does it invoke the body function with a pipe just in time?","msgtype":"m.text"},"ts":1428352323000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"on first getReader()","msgtype":"m.text"},"ts":1428352328000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: my thought was the body() function is always immediately called. Then ws routes to several different possible destinations: r.body, upload, cache, ... per my code sample, which you (rightly) pointed out was not extensible.","msgtype":"m.text"},"ts":1428352445000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think you have to wait until a consumer sets the stream... possibly stealing the body at the same time","msgtype":"m.text"},"ts":1428352491000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: maybe setting the stream should be definition mark the bodyUsed flag on the Request","msgtype":"m.text"},"ts":1428352508000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"actually, it definitely should","msgtype":"m.text"},"ts":1428352515000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"sets the stream, as in, setWriter? So we are doing a synthesis of setWriter and body: ws => blah?","msgtype":"m.text"},"ts":1428352555000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think you can't set the writer until the Request is passed to a consumer... so I don't know how to do it immediately at construction time","msgtype":"m.text"},"ts":1428352585000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: agreed, i was confused and thought going back to body: ws => blah meant going back to my code sketch","msgtype":"m.text"},"ts":1428352619000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: body: ws => blah is essentially a \"start pushing the body\" function... we don't want to push the body until it has somewhere to go","msgtype":"m.text"},"ts":1428352623000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"going to have to think about how to implement that then if we want getReader() to be the trigger...","msgtype":"m.text"},"ts":1428352662000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: well... set the writer stream could also trigger the push immediately at that point without getReader()... the .body stream should probably be considered locked at that point","msgtype":"m.text"},"ts":1428352712000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"because you don't really have a ReadableStream at all","msgtype":"m.text"},"ts":1428352739000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I only want to auto-create a pipe if someone is using the body: ws => blah form... but then someone tries to use getReader() instead of setting a writer","msgtype":"m.text"},"ts":1428352769000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"thinks we need a better name than body: ws => blah","msgtype":"m.emote"},"ts":1428352791000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"right, I agree setWriter is a good trigger, but unsure about how to trigger given r.body.getReader()","msgtype":"m.text"},"ts":1428352794000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1428352796000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ws-revealer?","msgtype":"m.text"},"ts":1428352804000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: body getter?","msgtype":"m.text"},"ts":1428352809000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"trigger on body getter","msgtype":"m.text"},"ts":1428352815000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah maybe","msgtype":"m.text"},"ts":1428352822000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"could play havoc with dev tools, though","msgtype":"m.text"},"ts":1428352833000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah getters with side effects seems like it would be nice to avoid if possible","msgtype":"m.text"},"ts":1428352849000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"getReader() seems like the right place for this, just need to make it work in the spec, but that's on me","msgtype":"m.text"},"ts":1428352863000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"will accept ws-revealer although he was angling for the \"the blah function\".","msgtype":"m.emote"},"ts":1428352903000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"the revealer function?","msgtype":"m.emote"},"ts":1428352932000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ws-revealer works for me","msgtype":"m.text"},"ts":1428352956000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Pretty clear instance of http://domenic.me/2014/02/13/the-revealing-constructor-pattern/ is the only reason I keep saying \"revealer\"","msgtype":"m.text"},"ts":1428352966000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hmm I dislike how Firefox awesomebar keeps old URLs around even though they have redirects that I've visited","msgtype":"m.text"},"ts":1428352992000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(should be https://blog.domenic.me/the-revealing-constructor-pattern/ )","msgtype":"m.text"},"ts":1428352997000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: https://bugzilla.mozilla.org/show_bug.cgi?id=922514","msgtype":"m.text"},"ts":1428353096000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: but this unfortunately was marked WONTFIX https://bugzilla.mozilla.org/show_bug.cgi?id=426142","msgtype":"m.text"},"ts":1428353108000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wowww it's funny to be reminded that bugzilla has bugs about the actual browser i use not just the web platform :P","msgtype":"m.text"},"ts":1428353122000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"oooh yeah that latter also sucks","msgtype":"m.text"},"ts":1428353156000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess they don't want to break muscle memory because the site moved the page","msgtype":"m.text"},"ts":1428353201000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"right. i guess what i find annoying is when both the old and new URLs show up in the search","msgtype":"m.text"},"ts":1428353234000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"boggles as the boarding line form 15 minutes before boarding.","msgtype":"m.emote"},"ts":1428353256000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: mostly i just want it to read my mind","msgtype":"m.text"},"ts":1428353282000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: it basically does. it's mind-boggling how often one character is enough for it to go on. soooo much better than chrome.","msgtype":"m.text"},"ts":1428353314000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I can't type \"streams-demo\" into my chrome location bar and get anything, despite visiting that page all the time. \"streams d\" gets it in Firefox.","msgtype":"m.text"},"ts":1428353345000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: in the Identity Transform stream... can we make a null transform function mean \"make a buffered pipe\"?","msgtype":"m.text"},"ts":1428353359000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I think that's the idea, yeah.","msgtype":"m.text"},"ts":1428353383000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I'm glad I finally have it trained so \"streams\" goes to the spec","msgtype":"m.text"},"ts":1428353387000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: in the thing you linked it throws in that case right now","msgtype":"m.text"},"ts":1428353398000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah, as i said, suffering from a lack of love. (Although I do always fix its tests when they break!) Also unsure whether `new TransformStream()` is good or we should do `TransformStream.identity()` or something","msgtype":"m.text"},"ts":1428353425000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I commented in #20","msgtype":"m.text"},"ts":1428353489000,"senderName":"wanderview","senderId":"wanderview@irc"}
]