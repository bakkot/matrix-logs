[
{"content":{"body":"MikeSmith: will do...","msgtype":"m.text"},"ts":1507161884000,"senderName":"jsbell","senderId":"jsbell@irc"},
{"content":{"body":"MikeSmith: done","msgtype":"m.text"},"ts":1507161915000,"senderName":"jsbell","senderId":"jsbell@irc"},
{"content":{"body":"Yeah, I think it predates some (all?) lint checks","msgtype":"m.text"},"ts":1507161932000,"senderName":"jsbell","senderId":"jsbell@irc"},
{"content":{"body":"MikeSmith: dropping off now, so followups -> email/github. Thank you VERY much for your help!","msgtype":"m.text"},"ts":1507162009000,"senderName":"jsbell","senderId":"jsbell@irc"},
{"content":{"body":"annevk: jochen__ just closed https://bugs.chromium.org/p/chromium/issues/detail?id=760096#c6 as WontFix, which reminded me how much I hate that `file:` URLs can have hostnames.","msgtype":"m.text"},"ts":1507192925000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"Before I go through the trouble of adding metrics, would you fundamentally object to not allowing hostnames? :)(","msgtype":"m.text"},"ts":1507192948000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"mkwst: probably not, file URLs already have a lot of special cases in the parser","msgtype":"m.text"},"ts":1507192987000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"mkwst: it's probably worth raising an issue at the same time though since Node.js uses file URLs a fair bit too","msgtype":"m.text"},"ts":1507193006000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"mkwst: the other thing you could do of course is block them at the resolve layer","msgtype":"m.text"},"ts":1507193035000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'd add metrics before raising an issue. No point in poking if there's no way to follow through.","msgtype":"m.text"},"ts":1507193037000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"mkwst: maybe that's cleaner","msgtype":"m.text"},"ts":1507193041000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Sure. Chrome could decide that it doesn't like the behavior. But I'd like other folks on board.","msgtype":"m.text"},"ts":1507193059000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"Eh. I guess? I'm not sure what's simpler to implement, really, since I think we delegate to the OS for filesystem access.","msgtype":"m.text"},"ts":1507193082000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"We haven't really defined how file URLs resolve since it's platform dependent","msgtype":"m.text"},"ts":1507193084000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"You'd have to gate those calls somehow if you block at the resolve layer","msgtype":"m.text"},"ts":1507193115000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I haven't looked at any of the code. Maybe it's trivial.","msgtype":"m.text"},"ts":1507193159000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"But I know it's trivial to remove the URL-parsing special case in Chrome's URL library, so. :)","msgtype":"m.text"},"ts":1507193191000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"annevk: Hey, more file things! https://bugs.chromium.org/p/chromium/issues/detail?id=756416#c3","msgtype":"m.text"},"ts":1507194024000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"I'll file something against... HTML, I guess?","msgtype":"m.text"},"ts":1507194033000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"Or maybe URL, which already hand-waves in the direction of opaqueness for `file:`?","msgtype":"m.text"},"ts":1507194067000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"mkwst: the main problem is getting user agents to agree","msgtype":"m.text"},"ts":1507194097000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"mkwst: is it consistently cross-origin in Chrome or can you still do XHR?","msgtype":"m.text"},"ts":1507194107000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah. Which is why I'd file a bug for discussion.","msgtype":"m.text"},"ts":1507194115000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"I'm just looking now, actually. I remember that we had some strange carveouts where we called the origin `file:` for all file URLs,  but I don't recall the details.","msgtype":"m.text"},"ts":1507194149000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"mkwst: I guess it would be HTML, since URL gives an opaque origin for data URLs too, but that's not always what we do because of overrides","msgtype":"m.text"},"ts":1507194190000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Got it.","msgtype":"m.text"},"ts":1507194211000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"mkwst: Firefox has some kind of same-or-deeper directory thing going on","msgtype":"m.text"},"ts":1507194224000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah. We considered that, but intentionally chose not to because of the downloads directory.","msgtype":"m.text"},"ts":1507194243000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"mkwst: it doesn't really seem worth it and will probably all go away the more we force HTTPS","msgtype":"m.text"},"ts":1507194246000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"mkwst: that's a compelling argument","msgtype":"m.text"},"ts":1507194270000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"On the HTTPS note, I saw that you poked at dev-platform@ regarding pushing for secure contexts.","msgtype":"m.text"},"ts":1507194281000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"Is there anything I can do there to help out? Other than poking at folks on Chrome's end in the same way?","msgtype":"m.text"},"ts":1507194300000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"mkwst: I need to talk to some more folks and at some point I mean to investigate what Chrome has disabled and Firefox has not","msgtype":"m.text"},"ts":1507194369000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"mkwst: if the latter is available somewhere that'd be swell, but I don't see anything else right now (other than pushing the worklets folks up the hill and getting a story for CSS and such)","msgtype":"m.text"},"ts":1507194413000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"mkwst: agreed with your review on the TAG PR too, FWIW","msgtype":"m.text"},"ts":1507194448000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"There's an internal thread among API owners that wasn't actually meant to be internal. Will try to externalize that when folks wake up.","msgtype":"m.text"},"ts":1507194472000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"I saw the public thread, but there weren't many convincing arguments there","msgtype":"m.text"},"ts":1507194498000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But it's more or less the same story. slightlyoff, jochen__, and I are the bad cops.","msgtype":"m.text"},"ts":1507194507000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"The resistance mostly seems to be that transition is hard","msgtype":"m.text"},"ts":1507194563000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But the argument also changes, since first the resistance was that it would be too expansive or too slow","msgtype":"m.text"},"ts":1507194601000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I need a poster image for a <video> in wpt,","msgtype":"m.text"},"ts":1507195405000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"annevk: what image should I use?","msgtype":"m.text"},"ts":1507195410000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"Oh, media/poster.png","msgtype":"m.text"},"ts":1507195436000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"Glad you found something ðŸ˜Š","msgtype":"m.text"},"ts":1507195535000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hah. :)","msgtype":"m.text"},"ts":1507195644000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"annevk: Almost done with them tests,","msgtype":"m.text"},"ts":1507195655000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"annevk: and I have a question: there is nothing that lets me know whether a poster frame loaded, apart from making sure the poster frame starts loading before the document's load event, so that I can do stuff in the onload handler?","msgtype":"m.text"},"ts":1507195718000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"nox: I don't know about that either","msgtype":"m.text"},"ts":1507195810000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"nox: I was really only closely involved with <video> before it became all complicated","msgtype":"m.text"},"ts":1507195829000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Hah!","msgtype":"m.text"},"ts":1507195953000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"annevk: tfw local clone is thousands of commits in the past and you need to push all of them to make a PR with a single test","msgtype":"m.text"},"ts":1507195988000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"And as we get closer to requiring UTF-8 all over, XMLHttpRequest and Firefox have to regress on that point: https://github.com/whatwg/xhr/issues/159","msgtype":"m.text"},"ts":1507208963000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It even had a test, but I suspect no bugs were filed back then","msgtype":"m.text"},"ts":1507208998000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Makes me wonder whether we test fetch() for this","msgtype":"m.text"},"ts":1507209043000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: do you know who knows about chrome performance timeline stuff with service workers involved?","msgtype":"m.text"},"ts":1507217414000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"just trying to figure out: https://github.com/w3c/resource-timing/issues/119","msgtype":"m.text"},"ts":1507217747000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: falken maybe?","msgtype":"m.text"},"ts":1507217960000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: ok... I pinged him in the github issue... thanks","msgtype":"m.text"},"ts":1507218001000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"these values are pretty confusing right now","msgtype":"m.text"},"ts":1507218009000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"damn, apparently font-size:calc(1vw*1vh) is not possible :/","msgtype":"m.text"},"ts":1507224797000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"why not? sounds like a useful idea.","msgtype":"m.text"},"ts":1507224806000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"annevk: mkwst: according to https://quuz.org/url/liveview.html#file://x.jd.com/mkt/pcwap?&callback=dsp_1504020242543&r=1504020242544 in Firefox there is no hostname there, at least. So that's a point in its favor.","msgtype":"m.text"},"ts":1507225080000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Great! Go file a bug against every other browser to align with Firefox!","msgtype":"m.text"},"ts":1507226410000,"senderName":"mkwst","senderId":"mkwst@irc"},
{"content":{"body":"JakeA: I'm curious about your thoughts on Wikimedia's approach to the client-side caching of javascript/css module bundles. As you might know, we currently do it as follows (in a nut shell): JS has a module manifest (dependency tree and version hashes), and an array of modules names to load on this page. For each module+version key it checks localStorage, and if present, evals it. Any remaining modules are fetched from the server in 1 batch","msgtype":"m.text"},"ts":1507228026000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"request. On response, after normal execution, we also stash each module's response closure from the batch request into localStorage.","msgtype":"m.text"},"ts":1507228026000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"I've considered using ServiceWorkers and/or its Cache API in various ways over the past 2 years but always came back to the current solution.","msgtype":"m.text"},"ts":1507228046000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"ondras: Because it's multiplying a length by a length, so the unit ends up being length^2.  (V&U 4 will allow unit algebra, so you can divide that expression by 1px and get back to a plain length, and that's already specified in the TypedOM spec.)","msgtype":"m.text"},"ts":1507228170000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"@TabAtkins: yeah, I would happily divide that by Npx to get to a reasonable unit","msgtype":"m.text"},"ts":1507228199000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"TabAtkins: ^ (sorry for bad highlight)","msgtype":"m.text"},"ts":1507228216000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"The main reason I want to get out of localStorage is because it's synchronous and because it's limited and is sometimes breaking user features when its full (e.g. 99% full with js/css, no space for \"normal\" usage like small key/value pairs for things like hiding notices or keeping track of collapsed/expanded state of something).","msgtype":"m.text"},"ts":1507228226000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"ideally, I would like to take a square root tho","msgtype":"m.text"},"ts":1507228226000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"replacing localstorage usage with cache API usage or something definitely sounds like a sensible thing to do","msgtype":"m.text"},"ts":1507228332000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"At first I tried the \"obvious\" way with proper ServiceWorker intercepting network requests, and disabling the main thread logic of using localStorage.","msgtype":"m.text"},"ts":1507228736000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"That means the SW thread needs to unpack the request url to find the raw list of module names again, then it needs access to the module manifest (postMessage, or separate request), and then for each moduleName/moduleVersion, construct a non-batch fake url and do cache lookups, then the logic is essentially the same as before: Make a batch request for the cache misses, and then mimick the server-side's logic of concatenating the hits from Cache","msgtype":"m.text"},"ts":1507228829000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"and cache-miss-batch responses.","msgtype":"m.text"},"ts":1507228829000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"The downside is that now the whole thing is a lot slower. we used to eval modules right away from those that are in the cache. I don't wanna block those on 1 cache  miss.","msgtype":"m.text"},"ts":1507228851000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"And JS responses don't stream execution.","msgtype":"m.text"},"ts":1507228857000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"So it seems more natural to ditch the SW part of it, and do the cache lookups in the main thread instead, but that means resorting to eval again, which is fine I suppose, (as long as V8's parse cache still works, which seems to be fine for us at the moment).","msgtype":"m.text"},"ts":1507228925000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Krinkle: what do you mean by \"And JS responses don't stream execution.\"","msgtype":"m.text"},"ts":1507229046000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: Given 10 keys, where 8 are going to hit cache. We currently read from localStorage, eval, and then request 2 from network. At this point, the first 8 modules are not waiting or blocked, they're executed and are done.","msgtype":"m.text"},"ts":1507230043000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"If I'd do the same in SW, I'd have to wait for the batch request for the remaining 2 modules in order to concat the response and send it back to the client.","msgtype":"m.text"},"ts":1507230066000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"E.g. given the client making a request for 10, SW.js unpacking it and composing it of 8 cache entries and the real request for 2 more.","msgtype":"m.text"},"ts":1507230087000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Krinkle: even with ReadableStream in the service worker script?","msgtype":"m.text"},"ts":1507230093000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I can stream alright, but JS doesn't execute in a streaming way.","msgtype":"m.text"},"ts":1507230104000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Even if Chrome/V8 does streamed parsing (does it?), it certainly won't execute any JS code until the last byte arrives afaik.","msgtype":"m.text"},"ts":1507230125000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Krinkle: ah, ok","msgtype":"m.text"},"ts":1507230172000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"well you can't given JS semantics","msgtype":"m.text"},"ts":1507230189000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"oh wait that was literally your previous line","msgtype":"m.text"},"ts":1507230201000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Yeah, I get it. I'm not blaming the browser here. Just looking for a suitable way to get this stash out of localStorage without making things worse :)","msgtype":"m.text"},"ts":1507230245000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Krinkle: I wonder if streaming html with <script> tags would let them evaluate incrementally","msgtype":"m.text"},"ts":1507230317000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yes","msgtype":"m.text"},"ts":1507230363000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"wanderview: Yeah, I suppose it would. but is there a way to stream HTML into an existing browsing context? Maybe with an iframe, that then accesses the parent.","msgtype":"m.text"},"ts":1507230365000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"but I don't expect code to then work as-is.","msgtype":"m.text"},"ts":1507230380000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Any use of 'window' or 'document' would be broken.","msgtype":"m.text"},"ts":1507230395000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"For a single script that would work, but not with e.g. existing code base or something like jquery.js or any standard lib.","msgtype":"m.text"},"ts":1507230421000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"dependency injection is nice, but use of browser APIs directly is quite common, DI in JS hasn't gotten much traction yet.","msgtype":"m.text"},"ts":1507230458000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"gsnedders: wanderview: JakeA: Thanks for your input :-) I summarised it again at https://github.com/w3c/ServiceWorker/issues/1203","msgtype":"m.text"},"ts":1507231008000,"senderName":"Krinkle","senderId":"Krinkle@irc"}
]