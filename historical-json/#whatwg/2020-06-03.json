[
{"content":{"body":"annevk: would you be able to find someone from Mozilla to comment on https://github.com/whatwg/streams/pull/1035 for implementer interest?","msgtype":"m.text"},"ts":1591154546000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I pinged some people from the WebVM team","msgtype":"m.text"},"ts":1591161064000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"> * ignores issue for four years","msgtype":"m.text"},"ts":1591171340000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"> it's unfortunate [browser] implemented this change without noticing that this open issue existed","msgtype":"m.text"},"ts":1591171348000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: that's a very selective quote given what follows, please do better 😉","msgtype":"m.text"},"ts":1591171623000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Well, the ignoring bothers me more than the comment anyway","msgtype":"m.text"},"ts":1591171674000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"There's not many specifications without that problem unfortunately","msgtype":"m.text"},"ts":1591171782000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Although usually the problems are a bit more involved if they are older","msgtype":"m.text"},"ts":1591171809000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: hi, I have some questions about cachestorage (realted to https://github.com/w3c/ServiceWorker/pull/1516).","msgtype":"m.text"},"ts":1591176665000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: sure","msgtype":"m.text"},"ts":1591176686000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Is https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list the persisted requests and responses?","msgtype":"m.text"},"ts":1591176717000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: my knowledge about the Cache API is a bit limited unfortunately; maybe JakeA can help","msgtype":"m.text"},"ts":1591177106000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yhirano: on the face of it that definition doesn't make any sense to me","msgtype":"m.text"},"ts":1591177135000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yhirano: I guess I can sorta see what it's getting it and I think you're right about the intent, but this isn't how this ought to be worded","msgtype":"m.text"},"ts":1591177230000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I see. After thinking about this a bit more I come to think we should rely on response, not the request, because web authors can select arbitrary request and response for cache.put arguments.","msgtype":"m.text"},"ts":1591177276000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"annevk: web deves can call cache.put(cors-request, opaque-response) so we shouldn't trust the mode on request for the CORP check.","msgtype":"m.text"},"ts":1591177334000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: I tend to agree","msgtype":"m.text"},"ts":1591177412000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yhirano: the CORP algorithm I looked it was mostly looking at the request though","msgtype":"m.text"},"ts":1591177428000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I suspect in part because the response's URL list wouldn't have been updated yet, but maybe there's a better way to do this","msgtype":"m.text"},"ts":1591177481000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: that's why I'm resetting mode at https://pr-preview.s3.amazonaws.com/w3c/ServiceWorker/1516/0aceaac...yutakahirano:23a4317.html#cross-origin-resource-policy-check-for-cached-resource-algorithm","msgtype":"m.text"},"ts":1591177496000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"annevk: For origin request.origin can be \"client\" and we don't want to use the string.","msgtype":"m.text"},"ts":1591177526000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: I don't see how resetting mode helps with the CORP algorithm not looking at the response","msgtype":"m.text"},"ts":1591177563000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: https://github.com/whatwg/fetch/pull/1030 adds  'Assert: request.mode either \"no-cors\" or \"navigate\"'.","msgtype":"m.text"},"ts":1591177721000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: sure, but there's a larger issue","msgtype":"m.text"},"ts":1591177743000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: The CORP check looks at url, mode, origin and coep (via client) on request.","msgtype":"m.text"},"ts":1591177787000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"Yes","msgtype":"m.text"},"ts":1591177832000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: For origin and client I thin the relevant settings object works.","msgtype":"m.text"},"ts":1591177865000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"annevk: For mode we cannot trust request and I'm using response.type instead.","msgtype":"m.text"},"ts":1591177884000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: I mean, URL is the problem, right?","msgtype":"m.text"},"ts":1591177971000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yhirano: but also, I'm wondering if we can restructure the CORP check somehow to make it easier for the Cache API to use, rather than having to more or less abuse a request","msgtype":"m.text"},"ts":1591178028000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: in the fetch spec?","msgtype":"m.text"},"ts":1591178044000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: yes","msgtype":"m.text"},"ts":1591178049000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: i see","msgtype":"m.text"},"ts":1591178084000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"annevk: For url I think we can use https://fetch.spec.whatwg.org/#concept-response-url","msgtype":"m.text"},"ts":1591178099000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: yeah, though at that point you shouldn't really clone the bogus request, you should just construct your own, but it ends up looking really weird","msgtype":"m.text"},"ts":1591178127000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ok I'll modify https://github.com/w3c/ServiceWorker/pull/1516 again. We may want to move the CORP-for-cache algorithm to the fetch spec (https://github.com/whatwg/fetch/pull/1030/). Does that sound OK?","msgtype":"m.text"},"ts":1591178298000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: I think we should take a closer look at what algorithm Fetch should define here","msgtype":"m.text"},"ts":1591178611000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm thinking about having CORP-check-for-cached-response which takes a response and and environment settings object and returns allowed/blocked.","msgtype":"m.text"},"ts":1591178677000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"annevk: a response and an environment settings object","msgtype":"m.text"},"ts":1591178696000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"annevk: (url, mode, origin, client) is calculated as (response's url, \"no-cors\", settings object's origin, settings object)","msgtype":"m.text"},"ts":1591178962000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: basically, I think the CORP check is also bogus for responses coming from a service worker","msgtype":"m.text"},"ts":1591179324000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yhirano: since you can fake the request there as well","msgtype":"m.text"},"ts":1591179338000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ah you're right.","msgtype":"m.text"},"ts":1591179581000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"annevk: what do you think about giving (url, origin, mode, coep, response) instead of (request, response) to the CORP check?","msgtype":"m.text"},"ts":1591179689000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"annevk: ah we need two urls, current url and original url for reporting.","msgtype":"m.text"},"ts":1591179742000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: I would prefer looking into whether response should get a URL sooner","msgtype":"m.text"},"ts":1591180193000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yhirano: or URL list, for that matter","msgtype":"m.text"},"ts":1591180209000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: sorry I don't understand your last comment. Can you rephrase it?","msgtype":"m.text"},"ts":1591180255000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: in main fetch step 9 we set a response's URL list, if we do that before we do the CORP check, we don't need to pass it so many things and can instead rely on the response for most of it","msgtype":"m.text"},"ts":1591180293000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: i see thanks","msgtype":"m.text"},"ts":1591180350000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: another I thing that seems weird is that we check response tainting before invoking the CORP check, but how would we ever invoke it with mode being navigate then? Does HTML invoke it directly?","msgtype":"m.text"},"ts":1591180393000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yes","msgtype":"m.text"},"ts":1591180408000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"annevk: please see the 6th step of https://whatpr.org/html/5454/browsing-the-web.html#process-a-navigate-fetch.","msgtype":"m.text"},"ts":1591180521000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: that doesn't check it for redirects","msgtype":"m.text"},"ts":1591180604000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yhirano: that also seems to have the problem of the request URL not being the correct source of authority","msgtype":"m.text"},"ts":1591180683000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Redirects are handled in the above while loop, right?","msgtype":"m.text"},"ts":1591180842000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: if a redirect response lacks CORP, it would still continue, afaict","msgtype":"m.text"},"ts":1591180871000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah so we need to move the block to somewhere in the step 5.","msgtype":"m.text"},"ts":1591180968000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"I'll comment on the PR","msgtype":"m.text"},"ts":1591180982000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: regarding the request url vs response url the navigation case is more difficult than cachestorage","msgtype":"m.text"},"ts":1591181076000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: I think we could use the response URL list as well, but I forgot what document URL a request for /foo that gets a response for /bar ends up with, so I'm not entirely sure","msgtype":"m.text"},"ts":1591181207000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: i'll work on the PRs tomorrow. Thank you very much for your thoughtful comments!","msgtype":"m.text"},"ts":1591181458000,"senderName":"yhirano","senderId":"yhirano@irc"},
{"content":{"body":"yhirano: sounds good, take care","msgtype":"m.text"},"ts":1591181555000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: can you help me understand your iframe lazyload comment about nondeterminism and the sandbox attr? Do you mean the value of the sandbox attribute could change after load deferral, therefore it’s “snapshot” is taking arbitrarily later?","msgtype":"m.text"},"ts":1591187294000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: yes","msgtype":"m.text"},"ts":1591187511000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: see also https://github.com/whatwg/html/issues/4926","msgtype":"m.text"},"ts":1591187564000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: (it seems that for referrer policy the right thing would happen in your PR)","msgtype":"m.text"},"ts":1591187586000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: that and the URL, since it is parsed relative to the node doc before navigating","msgtype":"m.text"},"ts":1591187668000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: right, that helps with blobs","msgtype":"m.text"},"ts":1591187690000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: hmm ok interesting. Do you have an idea on what other state could be problematic?","msgtype":"m.text"},"ts":1591187700000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: any kind of policy that is mutable","msgtype":"m.text"},"ts":1591187733000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(this is one of the reasons to oppose <meta http-equiv> policies)","msgtype":"m.text"},"ts":1591187756000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I guess a solution could be to defer the load much later (in the navigation algorithm) but I’m not sure how clean that’d be","msgtype":"m.text"},"ts":1591187812000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: so CSP, base URL","msgtype":"m.text"},"ts":1591187823000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: yeah, we discussed that last time, that might work, but would also trigger some new issues","msgtype":"m.text"},"ts":1591187868000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: oh, though I guess we have those here too","msgtype":"m.text"},"ts":1591187873000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: what if someone navigates the frame while there's a navigation queued in this manner?","msgtype":"m.text"},"ts":1591187890000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think that’s not too problematic. The navigation algorithm would be invoked again, the decision to lazy load, if still true, would just re-observe the element (which is no-op), and when the resumption steps are invoked the navigation continues","msgtype":"m.text"},"ts":1591188008000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"annevk: “so CSP, base URL”. Hmm didn’t we say base URL is fine?","msgtype":"m.text"},"ts":1591188055000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: we did for images, because we already parsed, but frames can inherit things","msgtype":"m.text"},"ts":1591188134000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: at least, I think a blob URL frame might do something with the base URL and srcdoc certainly will","msgtype":"m.text"},"ts":1591188174000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: now for blobs I guess you could make the argument that it should be copied when you create the blob URL","msgtype":"m.text"},"ts":1591188193000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"so maybe blob URLs don't count as much","msgtype":"m.text"},"ts":1591188206000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"or at all","msgtype":"m.text"},"ts":1591188210000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I don’t think I follow. Independently, I don’t actually know anything about blob URLs, which probably isn’t helping. But I was referring to your comment above “right, that helps with blobs” in response to mine about snapshotting the resolved URL before the navigation algorithm","msgtype":"m.text"},"ts":1591188338000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: I'm not sure what you mean","msgtype":"m.text"},"ts":1591188664000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: if an element’s loading gets deferred before its src is parsed relative to the node document’s base URL, and the base URL changes, then the load is subject to those base URL changes which is not good. We solve that with images by first parsing the src relative to the document, then deferring after. I think we do the same for iframes, since we parse the url and set up the request before deferring","msgtype":"m.text"},"ts":1591189051000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"So therefore the resolved URL is known before load deferral, which I think is what we want","msgtype":"m.text"},"ts":1591189089000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: correct","msgtype":"m.text"},"ts":1591189652000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: the tricky aspect is that a base URL can also been as a policy as it \"inherits\" into the framed document in certain cases; that's unique to the iframe scenario","msgtype":"m.text"},"ts":1591189709000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I see so you’re saying that by parsing the src early on like the PR does, we don’t solve *all* the problems yet, because the base URL is also taken into account later...hmm","msgtype":"m.text"},"ts":1591189859000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"correct","msgtype":"m.text"},"ts":1591189884000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: I do think that some of these nondeterminism issues we could maybe just accept, but need to think a bit more carefully if doing so would prevent any future cleanups","msgtype":"m.text"},"ts":1591190013000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: in the sense that it's not too different from the user doing an unexpected navigation","msgtype":"m.text"},"ts":1591190042000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: OK makes sense. I think it’s fine to accept them, but will take a closer look at the navigation algorithm earlier. I’d like to avoid touching it a lot as I think the currently solution is pretty clean, but we’ll see.","msgtype":"m.text"},"ts":1591190141000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"I guess either way I’ll be touching it a little to ensure that delayed iframes don’t delay the load event","msgtype":"m.text"},"ts":1591190159000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: thanks; I'll try to think a bit more about what a good minimum viable product would be here and discuss with others at Mozilla; perhaps srcdoc and perfect policy enforcement are indeed too much","msgtype":"m.text"},"ts":1591204033000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: If you'd like to have a VC with myself and some mozilla folks I'd be happy to do that (partially so I could understand the issues better myself)","msgtype":"m.text"},"ts":1591204075000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: it's still a bit in the planning phase internally, but I'll keep that in mind, thanks; (happy to chat 1:1 earlier if that can help)","msgtype":"m.text"},"ts":1591204367000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"👍","msgtype":"m.text"},"ts":1591204466000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"hey folks, I may be missing something but is there something in the spec that defines events that should/shouldn't be fired for an <option> element as I'm getting a different result between gecko/webkit for click event: https://jsfiddle.net/3uh6nfsr/","msgtype":"m.text"},"ts":1591222907000,"senderName":"gregwhitworth","senderId":"gregwhitworth@irc"},
{"content":{"body":"Looking here: https://html.spec.whatwg.org/multipage/form-elements.html#the-option-element","msgtype":"m.text"},"ts":1591222924000,"senderName":"gregwhitworth","senderId":"gregwhitworth@irc"},
{"content":{"body":"it inherits the Iface of HTMLElement which has the element and the global events so I'd assume they'd work. I may be missing a note or link however to limitations or UA allowance of support given the interop issues of <select>","msgtype":"m.text"},"ts":1591222996000,"senderName":"gregwhitworth","senderId":"gregwhitworth@irc"},
{"content":{"body":"gregwhitworth: what's on the prototype chain doesn't govern what events are fired; you need normative text saying \"fire an event\". Let me look for some...","msgtype":"m.text"},"ts":1591224805000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: thanks - I figured this must be defined somewhere","msgtype":"m.text"},"ts":1591224866000,"senderName":"gregwhitworth","senderId":"gregwhitworth@irc"},
{"content":{"body":"gregwhitworth: ah, click event. It turns out there's nothing in all of web specs that says \"when the user clicks their mouse, fire a click event\". Much less details tricky questions like hit-testing and whether clicking an option counts as clicking the option or its select or...","msgtype":"m.text"},"ts":1591224876000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So basically this is undefined :(","msgtype":"m.text"},"ts":1591224889000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: ahhh, ok - cool","msgtype":"m.text"},"ts":1591224895000,"senderName":"gregwhitworth","senderId":"gregwhitworth@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1591224958000,"senderName":"gregwhitworth","senderId":"gregwhitworth@irc"},
{"content":{"body":"No problem; just wish I had better news for you","msgtype":"m.text"},"ts":1591225333000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I'm adding in the event mapping for <select> in Open UI and while this spec of course is about documenting what to tie to \"options\" (whether HTML Platform or JS impl) I found the interop interesting","msgtype":"m.text"},"ts":1591225375000,"senderName":"gregwhitworth","senderId":"gregwhitworth@irc"},
{"content":{"body":"Domenic: for what it's worth, gecko isn't consistent - it doesn't fire mouseover for options for example","msgtype":"m.text"},"ts":1591225391000,"senderName":"gregwhitworth","senderId":"gregwhitworth@irc"}
]