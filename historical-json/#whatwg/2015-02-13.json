[
{"content":{"body":"nn nn nn nn nn nn nn nn nn (alright!)","msgtype":"m.text"},"ts":1423789460000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"Hey, Synchronous XHR requests on the main thread got deprecated recently.","msgtype":"m.text"},"ts":1423802302000,"senderName":"inian","senderId":"inian@irc"},
{"content":{"body":" I was using them to analyse JavaScript where some dynamic values were sent to the server and the program execution continued based on the values returned by the server. Of course, this was just to analyse JS and not for a user-facing website. Is there any other alternative for carrying out such analyses where the further program execution depends on the result of the XHR call without a sychronous XHR?","msgtype":"m.text"},"ts":1423802303000,"senderName":"inian","senderId":"inian@irc"},
{"content":{"body":"inian: you can block useful functionality until a promise is fullfilled, for example","msgtype":"m.text"},"ts":1423803056000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"show a loading spinner or splash screen until that happens","msgtype":"m.text"},"ts":1423803080000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Request.prototype.abort() -- I can think of three states a Request object can be in. 1) Before passed to fetch(). 2) After passed to fetch(). 3) Exposed to SW (similar to before passed to fetch(), but subtly different in state).","msgtype":"m.text"},"ts":1423819502000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think only in 2) should it actually do something. Making it work in 3) seems confusing, invoking preventDefault() seems like a better alternative.","msgtype":"m.text"},"ts":1423819549000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Am I missing something?","msgtype":"m.text"},"ts":1423819557000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So the problem with articles introducing these application frameworks is that the critique is never really backed up by evidence. E.g. http://calendar.perfplanet.com/2013/diff/ claims \"Attaching event listeners to DOM nodes is painfully slow and memory-consuming.\" as justification for event delegation. Now we want event delegation at some point with native support, but I always thought that was mostly for convenience...","msgtype":"m.text"},"ts":1423835262000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"The recent Flipboard article simply claimed that the DOM was slow. And everyone echoes the sentiment, but it never gets really concrete.","msgtype":"m.text"},"ts":1423835329000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"well, it's not like there aren't aspects of it which are correct","msgtype":"m.text"},"ts":1423835765000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"people touch the DOM, cause unwanted/unexpected layout, hear about the cost of crossing between JS and native code, hear \"we can't optimize calls to native code\", think about creating a bunch of new event listeners in memory for every important node they care about instead of just one, etc","msgtype":"m.text"},"ts":1423835973000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"it doesn't mean it's all true, but you can see how people come to those conclusions","msgtype":"m.text"},"ts":1423835984000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"then you have people writing 3 line benchmarks to prove their case","msgtype":"m.text"},"ts":1423836008000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"or drawing a correlation between MMR vaccines and autism based on a sampling of 12 kids","msgtype":"m.text"},"ts":1423836044000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"people are funny like that","msgtype":"m.text"},"ts":1423836071000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"preconceived notions, confirmation bias, and a tiny bit of fact","msgtype":"m.text"},"ts":1423836094000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"Sure, but I need the facts :-)","msgtype":"m.text"},"ts":1423836560000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"My favourite benchmarks are those where we can LICM the whole benchmark. Why run your benchmark multiple times anyway? That's pointless!","msgtype":"m.text"},"ts":1423836797000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"LICM?","msgtype":"m.text"},"ts":1423836976000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"loop invariant code motion","msgtype":"m.text"},"ts":1423836985000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1423837034000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Decided to ask the author: https://twitter.com/annevk/status/566234156754288640","msgtype":"m.text"},"ts":1423837055000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"If native event delegation would be a big help, we should just go ahead and do it","msgtype":"m.text"},"ts":1423837076000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: why do we want abort() on Request instead of passing a timeout parameter to fetch()?","msgtype":"m.text"},"ts":1423837115000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"it just seems like something more related to the actual fetch() operation, and not all the places Request object is used","msgtype":"m.text"},"ts":1423837215000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I guess having the abort() on the fetch() returned Promise would be ideal","msgtype":"m.text"},"ts":1423837243000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I guess that doesn't exist, though","msgtype":"m.text"},"ts":1423837380000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"reproduces the issue conversation in his head.","msgtype":"m.emote"},"ts":1423837392000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: basically JS VMs are getting better and better at entirely optimizing out benchmarks","msgtype":"m.text"},"ts":1423837547000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"waits for wanderview to resolve","msgtype":"m.emote"},"ts":1423839723000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"aborted.","msgtype":"m.emote"},"ts":1423839997000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hah, that doesn't exist :p","msgtype":"m.text"},"ts":1423840049000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: so another idea Hixie had was to have a message channel between the API initiating the request and the FetchEvent in the service worker; that also seems like something you'd put on Request","msgtype":"m.text"},"ts":1423840114000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: personally I like defining the timeout as a value that the fetch algorithm interprets instead of an external method called by arbitrary script","msgtype":"m.text"},"ts":1423840483000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"as the one issue commented pointed out... you really want an inter-packet timeout... not a total request deadline","msgtype":"m.text"},"ts":1423840510000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: don't we also want a generic way to abort though?","msgtype":"m.text"},"ts":1423840996000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: e.g. if you no longer need something","msgtype":"m.text"},"ts":1423841016000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: in any event, even if we don't have abort(), there's still the problem that sometimes we might want methods on Request to proxy somewhere and that falls apart with how fetch() works","msgtype":"m.text"},"ts":1423841062000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think you need some object representing the fetch operation itself... Request is not that object","msgtype":"m.text"},"ts":1423841561000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"since it can be used for other things, cloned, etc","msgtype":"m.text"},"ts":1423841575000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: can we inherit Promise?","msgtype":"m.text"},"ts":1423841593000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I don't think we want to","msgtype":"m.text"},"ts":1423841666000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: if you get declarative constructs around Promise, any subclass of it would be disadvantaged","msgtype":"m.text"},"ts":1423841698000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: what about a duck-type compatible object that exposes the underlying promise if needed as .promise?","msgtype":"m.text"},"ts":1423841794000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I don't see how that would be different from a subclass","msgtype":"m.text"},"ts":1423841836000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: declarative syntax would still work with the subclass, it's just that the extras are not available (which is why you want to have those elsewhere, not on a subclass)","msgtype":"m.text"},"ts":1423841874000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well... not direct prototype chained...  and gives access to the promise if there is a promise-specific operation to perform","msgtype":"m.text"},"ts":1423841875000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: with a simple method like fetch() that returns a promise, though... I don't see where you stick those extras, though","msgtype":"m.text"},"ts":1423843372000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"MikeSmith: https://www.w3.org/Bugs/Public/show_bug.cgi?id=26338 has spam in last comment added","msgtype":"m.text"},"ts":1423844344000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: one thing some languages have is apparently that you can go from let x = fetch() to let x, y = fetch()","msgtype":"m.text"},"ts":1423844386000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: but that seems unrealistic","msgtype":"m.text"},"ts":1423844395000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: isn't es(something) adding de-structuring like that?","msgtype":"m.text"},"ts":1423844420000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: that leaves you with the value fetch() does return or whatever you pass to fetch()","msgtype":"m.text"},"ts":1423844428000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: yeah, but it would require returning [x, y] which would break existing code","msgtype":"m.text"},"ts":1423844453000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: you can't return multiple values","msgtype":"m.text"},"ts":1423844465000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Also, that doesn't really help with the <img>.request.port.postMessage(...) case","msgtype":"m.text"},"ts":1423844536000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"https://github.com/krisselden/simple-dom is nice","msgtype":"m.text"},"ts":1423844790000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I wonder why they support comments","msgtype":"m.text"},"ts":1423844805000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I suspect they might support comments so that when the simple-dom gets inserted into the real DOM, you can debug and find your kittens","msgtype":"m.text"},"ts":1423845432000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"also, perhaps conditional comments could matter in some cases","msgtype":"m.text"},"ts":1423845454000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"annevk: could we pass an \"abort promise\" to fetch()... if it resolves or rejects, then the fetch should abort","msgtype":"m.text"},"ts":1423848168000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: that's an interesting idea","msgtype":"m.text"},"ts":1423848587000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: how would we solve the messaging use case though?","msgtype":"m.text"},"ts":1423848608000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: or modifying the Request post-fetch in some kind of HTTP/2 scenario","msgtype":"m.text"},"ts":1423848625000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(e.g. changing priority on the fly)","msgtype":"m.text"},"ts":1423848634000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: make promisses transferable?  (to be honest I didn't look at the messaging use case\"","msgtype":"m.text"},"ts":1423848637000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: the messaging use case is primarily about letting an API endpoint (such as <img> or fetch()) communicate with the service worker handling its fetch","msgtype":"m.text"},"ts":1423848692000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: by handing the API endpoint and its FetchEvent a port each","msgtype":"m.text"},"ts":1423848724000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: that seems orthogonal to aborting a fetch() call?","msgtype":"m.text"},"ts":1423848744000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: oh it is, and modification post-fetch is too, but what they have in common is that they need a way to be exposed","msgtype":"m.text"},"ts":1423848805000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: the serviceworker script could tie the onmessage event handler to its \"abort promise\"... although I guess discouraging globals on SWs makes that harder","msgtype":"m.text"},"ts":1423848850000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I'm not sure how you would tie to that promise to be honest","msgtype":"m.text"},"ts":1423848912000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: the onmessage event handler in SW could deliver a message with attributes like fetchevent: { respondedWith: someResponse } or something","msgtype":"m.text"},"ts":1423848916000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"It's a bidirectional communication channel","msgtype":"m.text"},"ts":1423848930000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Let's start again, these are the use cases I have for Request:","msgtype":"m.text"},"ts":1423849156000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"1) request.abort()","msgtype":"m.text"},"ts":1423849161000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"2) request.port.postMessage(...) / request.port.onmessage = ...","msgtype":"m.text"},"ts":1423849179000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"3) request.changePriority(...) (and similar things, where you want to change something about an ongoing fetch)","msgtype":"m.text"},"ts":1423849204000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yea, I don't like any of those on the request object... we really need a handle to an object representing the on-going fetch","msgtype":"m.text"},"ts":1423849310000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Now an alternative solution for 1) and 3) would be some kind of promise you pass in, but that would not work for HTML: https://www.w3.org/Bugs/Public/show_bug.cgi?id=26533 not sure about 2)","msgtype":"m.text"},"ts":1423849336000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wonders if Domenic has any ideas","msgtype":"m.emote"},"ts":1423849377000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: could we set a \"FetchState\" object on the request while its in process?","msgtype":"m.text"},"ts":1423849381000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"that sounds similar to the cancelation token idea C# uses","msgtype":"m.text"},"ts":1423849399000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"fetch injects the state object onto the request... and then removes it when its no longer being operated on by the fetch","msgtype":"m.text"},"ts":1423849407000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"(well, the abort promise idea does, I am still reading downward)","msgtype":"m.text"},"ts":1423849431000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: you mean we augment it for a short period of time?","msgtype":"m.text"},"ts":1423849452000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: why not just have the API there and only enable it while fetch() is ongoing?","msgtype":"m.text"},"ts":1423849467000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yea","msgtype":"m.text"},"ts":1423849467000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"same effect I think... stateful APIs like this kind of suck for the dev, though... don't they?","msgtype":"m.text"},"ts":1423849505000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I mean my idea sucks too","msgtype":"m.text"},"ts":1423849512000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"https://lists.w3.org/Archives/Public/public-webapps/2015JanMar/0607.html","msgtype":"m.text"},"ts":1423849541000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I dunno, maybe we should just solve cancellable promises","msgtype":"m.text"},"ts":1423849592000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: it's a bit weird that you cannot reuse the Request during that period of time","msgtype":"m.text"},"ts":1423849593000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: that doesn't solve 2/3 though","msgtype":"m.text"},"ts":1423849602000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ah I see","msgtype":"m.text"},"ts":1423849608000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: but that's maybe not too bad","msgtype":"m.text"},"ts":1423849617000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: but yeah, having some kind of \"fetch in progress flag\" and exposing that was my idea","msgtype":"m.text"},"ts":1423849636000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: what about fetch functions like abortFetch(someRequest)... and does the thing if an active fetch that matches the request is in progress?","msgtype":"m.text"},"ts":1423849800000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: that sounds like it requires global lookup","msgtype":"m.text"},"ts":1423849862000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"\"is someRequest in your registry?\" \"oh, please kill it for me\"","msgtype":"m.text"},"ts":1423849893000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yes... but the UA could in theory make it happen from any context... vs trying to get the one active Request object to the right place in the dev's code... when we clone it, etc","msgtype":"m.text"},"ts":1423849904000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"What about fetch({ ..., modifyInProgressFetch(abort, setPriority, port) })","msgtype":"m.text"},"ts":1423849914000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"However, now that you mention it, we might need to keep such a registry, but I'm not sure if we want to expose it","msgtype":"m.text"},"ts":1423849919000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: callback I take it? Interesting idea","msgtype":"m.text"},"ts":1423849982000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah I guess you'd call back with it immediately","msgtype":"m.text"},"ts":1423849994000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"kind of like an awkward way of smuggling out multiple return values :-/","msgtype":"m.text"},"ts":1423850004000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it's the Domenic pattern(tm) https://blog.domenic.me/the-revealing-constructor-pattern/","msgtype":"m.text"},"ts":1423850022000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeppp","msgtype":"m.text"},"ts":1423850029000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it seems a bit nicer to put those on Request, I don't really understand the cloning stuff though","msgtype":"m.text"},"ts":1423850046000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(or at least it has leaked out of my head since last time)","msgtype":"m.text"},"ts":1423850066000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"currently when you pass a Request to fetch() we transfer the stream (if any) and copy the rest (stripping bits we don't like, such as synchronous flag)","msgtype":"m.text"},"ts":1423850101000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"if the Request did not have a stream you can pass it to fetch() many times","msgtype":"m.text"},"ts":1423850121000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"iirc","msgtype":"m.text"},"ts":1423850125000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"the callback could be issued on each clone...","msgtype":"m.text"},"ts":1423850167000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"feels complex to me, though","msgtype":"m.text"},"ts":1423850190000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I think changing the design of Request to make it aware of it being passed to fetch() would be better","msgtype":"m.text"},"ts":1423850216000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Oh right, the problem with that is that fetch() only copies from Request what it likes, so we would either have to mutate the Request object, or something else?","msgtype":"m.text"},"ts":1423850312000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":":-(","msgtype":"m.text"},"ts":1423850332000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I still kind of like having fetch stick something on request.. and then script can use that... Request.appendActiveFetch(new ActiveFetch(...))... myRequest.activeFetch.forEach(function(af) { af.abort(); }....","msgtype":"m.text"},"ts":1423850438000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"when fetch clones a response, it would call appendActiveFetch on the new one Request clone, etc...","msgtype":"m.text"},"ts":1423850453000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I think it would be saner for fetch() to mutate rather than clone and set a flag","msgtype":"m.text"},"ts":1423850591000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"does it not makes sense for the arrow function to throw an error on call(), apply(), and bind() as they do not augment the value of `this`?","msgtype":"m.text"},"ts":1423851121000,"senderName":"hemanth_","senderId":"hemanth_@irc"},
{"content":{"body":"I do agree the cloning seems bad","msgtype":"m.text"},"ts":1423851134000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"cloning the stream could happen but the entire object seems unnecessary","msgtype":"m.text"},"ts":1423851154000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Some version of FF was throwing an error, the latest one does not","msgtype":"m.text"},"ts":1423851178000,"senderName":"hemanth_","senderId":"hemanth_@irc"},
{"content":{"body":"well... we can't just clone the body stream until we finish integrating streams into fetch","msgtype":"m.text"},"ts":1423851346000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or I guess do some special one off logic in fetch","msgtype":"m.text"},"ts":1423851357000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I'm starting to think that the right thing is to just make Request a one-off everywhere","msgtype":"m.text"},"ts":1423853726000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: and if you want to reuse it, better clone it first","msgtype":"m.text"},"ts":1423853739000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"cd","msgtype":"m.text"},"ts":1423854353000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"can't handle two keyboards...","msgtype":"m.emote"},"ts":1423854367000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"tyoshino________: when do you sleep!? haha","msgtype":"m.text"},"ts":1423855848000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"anyone know if anyone has looked at how many event listeners typical pages have?","msgtype":"m.text"},"ts":1423867843000,"senderName":"Hixie","senderId":"Hixie@irc"}
]