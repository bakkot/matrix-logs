[
{"content":{"body":"http://engineering.flipboard.com/2015/02/mobile-web/","msgtype":"m.text"},"ts":1423703181000,"senderName":"karlcow","senderId":"karlcow@irc"},
{"content":{"body":"60fps on the mobile Web, problem solved","msgtype":"m.text"},"ts":1423703595000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"we'll just all use canvas!","msgtype":"m.text"},"ts":1423703612000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"it's amazing that nobody's ever thought to do this before","msgtype":"m.text"},"ts":1423703650000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: they speak about Bespin in the article :)","msgtype":"m.text"},"ts":1423703783000,"senderName":"karlcow","senderId":"karlcow@irc"},
{"content":{"body":"Accept is not a simple CORS header? but things like Accept-Language are?","msgtype":"m.text"},"ts":1423704714000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"oh... nm","msgtype":"m.text"},"ts":1423704745000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: https://www.chromestatus.com/metrics/feature/timeline/popularity/465 looks like it's not declining particularly fast","msgtype":"m.text"},"ts":1423729232000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: yeah","msgtype":"m.text"},"ts":1423729287000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zcorpan: still seems sane for browsers to warn about it though","msgtype":"m.text"},"ts":1423729331000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"maybe it's more effective to not talk about removing the feature but only talk about why using it is bad","msgtype":"m.text"},"ts":1423729350000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: e.g. the jQuery crowd started acting based on this I believe","msgtype":"m.text"},"ts":1423729361000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zcorpan: and that latest thread was just ridiculous, someone arguing that you need synchronous fetching for scrolling...","msgtype":"m.text"},"ts":1423729432000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1423729475000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"I wonder if we could quarantine it to only pages that we already know are using it","msgtype":"m.text"},"ts":1423729679000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"origins i guess would be the granularity boundary","msgtype":"m.text"},"ts":1423729723000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Probably eTLD+1 given document.domain, but maybe","msgtype":"m.text"},"ts":1423729804000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"https://www.youtube.com/watch?v=PqHL9hKhX6I This <core-list> seems to be essentially what React is doing, just in a different way","msgtype":"m.text"},"ts":1423730135000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So the argument that putting a lot of items in the DOM and rendering that quickly is impossible, is not disproven","msgtype":"m.text"},"ts":1423730194000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: you want to support promises from the prefixed version of the Fullscreen API?","msgtype":"m.text"},"ts":1423732153000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: no","msgtype":"m.text"},"ts":1423732181000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"did I write a terrible typ?","msgtype":"m.text"},"ts":1423732186000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"so, it would probably not be hard to support it for the prefixed APIs, I'm just not sure what the point would be","msgtype":"m.text"},"ts":1423732285000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"if shipped together with the unprefixed API, people who adapt to use promises should also stop using the prefixed API","msgtype":"m.text"},"ts":1423732313000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"annevk: I have \"Read Fullscreen mail\" on this weeks todo list, if the sudden interest in all things fullscreen seems out of characters","msgtype":"m.text"},"ts":1423732383000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: it sounded like you wanted to add promises before the unprefixed version was shipped","msgtype":"m.text"},"ts":1423732466000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: but perhaps you just meant added to the specification, which seems fine","msgtype":"m.text"},"ts":1423732478000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: like you I have taken a Fullscreen break","msgtype":"m.text"},"ts":1423732498000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: I still need to look at Hixie's changes to the event loop to allow for synchronization with animation frames","msgtype":"m.text"},"ts":1423732522000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: also, I guess we need to decide whether the promise needs to reject or return false or some such","msgtype":"m.text"},"ts":1423732554000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I mean to the spec, and to only return the promises from the unprefixed API, by whatever implementation strategy is required to make it so","msgtype":"m.text"},"ts":1423732590000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"since it's a return value I think it's easy to just not update the prefixed IDL","msgtype":"m.text"},"ts":1423732612000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"annevk: you mean when the fullscreen ready check fails?","msgtype":"m.text"},"ts":1423732635000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: yeah","msgtype":"m.text"},"ts":1423732902000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Okay, so the callback from HTML is \"run the fullscreen rendering steps\" and a timestamp","msgtype":"m.text"},"ts":1423733005000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: do you know what Fullscreen would use the timestamp for?","msgtype":"m.text"},"ts":1423733030000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: no idea, that sounds odd","msgtype":"m.text"},"ts":1423733081000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"https://html.spec.whatwg.org/multipage/webappapis.html#processing-model-9 step 8.8","msgtype":"m.text"},"ts":1423733138000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: re BackgroundSync ux: my current thinking is that one-off syncs should create some kind of sticky notification saying \"Waiting to sync\" or similar until the sync successfully completes","msgtype":"m.text"},"ts":1423734025000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"No idea what to do with periodic syncing though","msgtype":"m.text"},"ts":1423734039000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: where would that display?","msgtype":"m.text"},"ts":1423734066000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: on Android, same place as native notifications","msgtype":"m.text"},"ts":1423734739000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: is one-off a thing that native applications get too?","msgtype":"m.text"},"ts":1423734772000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"only remembers periodic background update UX","msgtype":"m.emote"},"ts":1423734812000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it sure looks like it's just passed for good measure, in case it's needed","msgtype":"m.text"},"ts":1423734866000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: the weird thing about Hixie's setup is that I can't queue some set of steps for this callback","msgtype":"m.text"},"ts":1423734976000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: I'd imagine there being some slot that has the set of actions that needs to be performed","msgtype":"m.text"},"ts":1423735017000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: but perhaps we need to define that ourselves as it's different for all the different cases?","msgtype":"m.text"},"ts":1423735032000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: can't you do whatever you want in \"the fullscreen rendering steps\"?","msgtype":"m.text"},"ts":1423735046000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: yeah I can","msgtype":"m.text"},"ts":1423735058000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: it's just that the whole task queueing model surrounding it does a lot more for you, but I guess that's oaky","msgtype":"m.text"},"ts":1423735089000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"okay*","msgtype":"m.text"},"ts":1423735092000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I had imagined that there would be a generic bucket called \"run the animation frame tasks\" right before the callbacks, and that it would be possible to queue such tasks","msgtype":"m.text"},"ts":1423735115000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"if this spec is implemented quite literally it seems like a bit of an odd polling model","msgtype":"m.text"},"ts":1423735212000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"annevk: https://developer.android.com/reference/android/app/AlarmManager.html see set(). That doesn't seem to deal with connectivity though","msgtype":"m.text"},"ts":1423735395000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"philipj: well it's something like that, except without the generic bucket","msgtype":"m.text"},"ts":1423735457000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: presumably so that all these things happen in the correct order?","msgtype":"m.text"},"ts":1423735474000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I guess, although a task queue also has an order same as regular tasks really","msgtype":"m.text"},"ts":1423735508000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"JakeA: yeah, it seems you have wake-on-time, wake-on-network, wake-periodic-on-network, wake-on-times","msgtype":"m.text"},"ts":1423735553000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"If some of these steps (like resize/scroll) can influence later steps then fixinf the order is reasonable","msgtype":"m.text"},"ts":1423735561000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: so I'd imagine we have a slot on the global and then make HTML's callback run the code in that slot","msgtype":"m.text"},"ts":1423735591000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I don't see network stuff there","msgtype":"m.text"},"ts":1423735602000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"philipj: which is effectively the same as queuing a task except having it run at a specific time","msgtype":"m.text"},"ts":1423735608000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: sorry, was combining that with what we have","msgtype":"m.text"},"ts":1423735622000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: as use cases","msgtype":"m.text"},"ts":1423735631000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ahh gotcha","msgtype":"m.text"},"ts":1423735634000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1423735638000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"iOS has \"Background App Refresh\"","msgtype":"m.text"},"ts":1423735658000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Seems that Android makes wake-when-reconnected quite difficult http://stackoverflow.com/questions/15698790/broadcast-receiver-for-checking-internet-connection-in-android-app","msgtype":"m.text"},"ts":1423735660000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: I guess your rendering steps are going to do nothing at all most of the time?","msgtype":"m.text"},"ts":1423735702000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"I think alarm/calendaring is probably related to the \"notifications\" permission","msgtype":"m.text"},"ts":1423735702000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"just see if there's a pending task and if so run it?","msgtype":"m.text"},"ts":1423735720000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: yeah, I would expect the slot to be empty mostly","msgtype":"m.text"},"ts":1423735721000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: that's why I kinda wish Hixie had formalized the slot idea, perhaps I should ask","msgtype":"m.text"},"ts":1423735753000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah, probably should","msgtype":"m.text"},"ts":1423735765000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"also, the name \"run the fullscreen rendering steps\" probably won't make sense","msgtype":"m.text"},"ts":1423735776000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"nothing is being rendered, it's just events being fired and state being twiddled","msgtype":"m.text"},"ts":1423735795000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: https://www.w3.org/Bugs/Public/show_bug.cgi?id=28001","msgtype":"m.text"},"ts":1423735876000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: perhaps the UX should just be asking for \"background updates\"","msgtype":"m.text"},"ts":1423735994000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: and if you have given both \"notification\" and \"background updates\" you can get alarms","msgtype":"m.text"},"ts":1423736017000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: on Chrome, I believe we roll background & notification into one permission prompt (for push anyway)","msgtype":"m.text"},"ts":1423736060000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I remember not liking what I heard about push and Chrome","msgtype":"m.text"},"ts":1423736105000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"but I don't really recall the specifics","msgtype":"m.text"},"ts":1423736113000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: thanks","msgtype":"m.text"},"ts":1423736156000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"annevk: there's a bit of magic at the moment as we ease ourselves into the idea of sites running code in the background","msgtype":"m.text"},"ts":1423737638000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: specifically, a push event must show a notification unless the site has focus","msgtype":"m.text"},"ts":1423737669000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I'm not sure that's true","msgtype":"m.text"},"ts":1423737689000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: if I granted a site the permission to do work in the background, I don't think a notification would need to be shown","msgtype":"m.text"},"ts":1423737708000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah, but there's a lot of (justified imo) worry around privacy issues","msgtype":"m.text"},"ts":1423737775000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"So we want users to be aware that a site did background work","msgtype":"m.text"},"ts":1423737790000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"As it can be used to track location at an IP level","msgtype":"m.text"},"ts":1423737809000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"The hope is to relax this as we work out the UX and user sentiment","msgtype":"m.text"},"ts":1423737843000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I definitely support making it discoverable and easy to disable, etc. But prominent UI whereas native gets away with a better experience does not seem acceptable","msgtype":"m.text"},"ts":1423737948000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So yeah, that was the thing that irked me about Chrome and push","msgtype":"m.text"},"ts":1423737967000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think mt is handling that mostly from Mozilla, but maybe I should verify that","msgtype":"m.text"},"ts":1423737991000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hmm... CORS filtered response does not filter out Set-Cookie and Set-Cookie2 at all times, oops","msgtype":"m.text"},"ts":1423738994000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Fixed","msgtype":"m.text"},"ts":1423739494000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: once we have a better way to ensure the user knows what's able to run in the background, that restriction will be lifted","msgtype":"m.text"},"ts":1423739730000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I think what was bothering mt was that it was influencing API design","msgtype":"m.text"},"ts":1423739777000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: the big worry is users that are tricked into accepting push for something friendly, but it abusing that without the user knowing","msgtype":"m.text"},"ts":1423739794000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Yeah it's definitely a tricky concept","msgtype":"m.text"},"ts":1423740213000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But I think the problem was that it got to point where Google UX decisions started to influence the API in a way that didn't work for others","msgtype":"m.text"},"ts":1423740291000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Need to check with mt what the latest is","msgtype":"m.text"},"ts":1423740302000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm not aware of API changes that have resulted from this privacy caution","msgtype":"m.text"},"ts":1423740425000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: the only privacy API change I'm aware of is the requirement to encrypt the push body so the message server can't read it. I think that came mainly from Mozilla","msgtype":"m.text"},"ts":1423740492000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: that's the protocol, no?","msgtype":"m.text"},"ts":1423740525000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: that sounds like a good change","msgtype":"m.text"},"ts":1423740535000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it's not the protocol, tls is already required for data transfer","msgtype":"m.text"},"ts":1423740590000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: the requirement is, when you register for push, the reg object gives you a key & an encryption format, which you send to your server. Before your server sends a message to the messaging-service, you encrypt the body using that format & key.","msgtype":"m.text"},"ts":1423740741000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"The messaging-service sends it to the phone, which it decrypts","msgtype":"m.text"},"ts":1423740797000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"So the messaging service doesn't get to see the body of the push","msgtype":"m.text"},"ts":1423740846000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Pretty cool, but really complicates usage & API","msgtype":"m.text"},"ts":1423740867000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I wonder if that could have been done in a simpler way by making use of TLS which is already in place, but I guess people tried to think of that already","msgtype":"m.text"},"ts":1423740978000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: if you can think of a simpler way, it's still up for debate. We're shipping without message bodies in the meantime.","msgtype":"m.text"},"ts":1423741045000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I can't think of a way, but my crypto knowledge is weak","msgtype":"m.text"},"ts":1423741064000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"It seems like you need something like this","msgtype":"m.text"},"ts":1423741231000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: so what parts will the intermediary learn? Just the origin involved?","msgtype":"m.text"},"ts":1423741293000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it'll know the sender & obviously the time of each message","msgtype":"m.text"},"ts":1423741362000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah, seems hard to avoid","msgtype":"m.text"},"ts":1423741385000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Oh course, if push bodies were unencrypted, there's nothing preventing a site adding their own encryption","msgtype":"m.text"},"ts":1423741406000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"But forcing it seems sensible when the browser/os/messaging service aren't all the same provider","msgtype":"m.text"},"ts":1423741434000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Yeah, but as we learned from HTTP, optional is not good long term","msgtype":"m.text"},"ts":1423741445000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: btw, haven't managed to get hold of Hixie, are you up for a call on SW & postMessage tomorrow evening?","msgtype":"m.text"},"ts":1423741540000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: the API draft doesn't seem to include this encryption stuff yet","msgtype":"m.text"},"ts":1423741541000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah, it's still being debated, although I'm not sure where exactly (but I know Mozilla is involved)","msgtype":"m.text"},"ts":1423741574000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I feel like I haven't been involved enough in the development of the various postMessage schemes to know what we should be doing","msgtype":"m.text"},"ts":1423741642000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"For the postMesage stuff, I'm still circling on clients receiving messages at navigator.serviceWorker.onmessage, and serviceworker receiving them at self.onmessage. It breaks some of the symmetry, but it's easy to use and doesn't break existing APIs","msgtype":"m.text"},"ts":1423741690000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: if not Hixie, who has enough of this stuff in their head?","msgtype":"m.text"},"ts":1423741702000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: maybe smaug____","msgtype":"m.text"},"ts":1423741737000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"smaug____: what say you to some form of synchronous communication to help us get unstuck on ServiceWorker & postMessage?","msgtype":"m.text"},"ts":1423741790000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"(and what timezome are you in?)","msgtype":"m.text"},"ts":1423741801000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so the idea is navigator.serviceWorker.onmessage/navigator.serviceWorker.postMessage and self.onmessage/client.postMessage on the other side?","msgtype":"m.text"},"ts":1423741827000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lives in smaug-timezone as someone put it couple of years ago","msgtype":"m.emote"},"ts":1423741828000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"JakeA: I live in Helsinki, so EET","msgtype":"m.text"},"ts":1423741842000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"JakeA+2h","msgtype":"m.text"},"ts":1423741859000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"sync communication ?","msgtype":"m.text"},"ts":1423741893000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: a video/voice call","msgtype":"m.text"},"ts":1423741931000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: swClient.postMessage would land at navgiator.serviceWorker.onmessage, navigator.serviceWorker,controller.postMessage would land at self.onmessage","msgtype":"m.text"},"ts":1423742007000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I think that if we try to explain this in terms of message channels (which I think we need in order for this to work) we might get somewhere","msgtype":"m.text"},"ts":1423742016000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: eh, I thought you were talking about synchronous communication API","msgtype":"m.text"},"ts":1423742071000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"apparently no","msgtype":"m.text"},"ts":1423742074000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"annevk: I guess it could be navigator.serviceWorker.controller.onmessage, but I was hoping there'd be a way for a client to listen for messages from *any* SW, rather than having to add onmessage to each and monitor for new SWs appearing & listen to those too","msgtype":"m.text"},"ts":1423742107000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"has no idea what the issue is","msgtype":"m.emote"},"ts":1423742121000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: we're trying to work out how a serviceworker could send a message to a specific client on the same origin","msgtype":"m.text"},"ts":1423742151000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: that is why you need to look into message channels and how you explain the underlying functionality","msgtype":"m.text"},"ts":1423742160000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"where a client is a window/worker/sharedworker","msgtype":"m.text"},"ts":1423742161000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: yeah, that's fair","msgtype":"m.text"},"ts":1423742173000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: currently you're just trying to invent some sugar without understanding what it comes down to","msgtype":"m.text"},"ts":1423742178000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah, I guess I'm trying to avoid ending up with a semantically pure but virtually impossible to use API. But I should at least be able to explain it in terms of the channel stuff.","msgtype":"m.text"},"ts":1423742270000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I don't think I know enough about the issue to say anything useful. I'd try to follow the SharedWorker model if possible, but perhaps there is some reason why that doesn't work here","msgtype":"m.text"},"ts":1423742477000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"So the main problem with SW is that it can come and go. So its port can get GC'd at any point but we don't really want to lose any messages I think...","msgtype":"m.text"},"ts":1423742655000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So you need some kind of intermediary place where the messages go first. And then whenever an SW boots up they get transmitted until the SW shuts down again.","msgtype":"m.text"},"ts":1423742698000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"smaug____: The browser may terminate the serviceworker while it isn't being used to save memory, so the sharedworker model of connect events & keeping posts in scope doesn't work. Also, in the sharedworker model the client must explicitly connect to the sharedworker before the sharedworker can contact the client. I'm hoping the serviceworker can send","msgtype":"m.text"},"ts":1423742699000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"messages to specific clients, and all the client has to do to receive them is register an onmessage event somewhere","msgtype":"m.text"},"ts":1423742699000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: what if the client instead registers an onserviceworkerconnect handler?","msgtype":"m.text"},"ts":1423742746000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: and gets handed a port there","msgtype":"m.text"},"ts":1423742756000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: when would that fire?","msgtype":"m.text"},"ts":1423742777000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"But yeah, then you have the opposite problem, how to send to the SW","msgtype":"m.text"},"ts":1423742790000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think that problem is solved right? serviceWorkerInstance.postMessage to self.onmessage doesn't feel controversial.","msgtype":"m.text"},"ts":1423742838000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"although I guess there's a reason sharedworker doesn't have something that simple","msgtype":"m.text"},"ts":1423742854000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: that is controversial since you can't explain it in terms of ports","msgtype":"m.text"},"ts":1423742866000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: so I have no idea how it works, exactly","msgtype":"m.text"},"ts":1423742877000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hm","msgtype":"m.text"},"ts":1423742882000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Perhaps something like BroadcastChannel but specific to this scenario?","msgtype":"m.text"},"ts":1423742926000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"that model feels like a better fit, but directed at a specific client. It'd be great if it could reuse broadcastChannel fundamentals because Chrome could implement both","msgtype":"m.text"},"ts":1423742982000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"So BroadcastChannel could work if you have some identifier unique to the client...","msgtype":"m.text"},"ts":1423743013000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I can talk tomorrow night, but I rather not, and also earlier the better","msgtype":"m.text"},"ts":1423743090000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: are you suggesting that the developer has to filter out the messages or that the spec does that?","msgtype":"m.text"},"ts":1423743092000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: hmm lunch","msgtype":"m.text"},"ts":1423743120000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: my idea was we give the dev some identifier for BroadcastChannel (perhaps through a sublcass) so they get one unique for a particular client","msgtype":"m.text"},"ts":1423743145000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"back later","msgtype":"m.text"},"ts":1423743152000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"have a good'un. I really should be writing a talk :(","msgtype":"m.text"},"ts":1423743196000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I think \"this is all horrible, but that's life\" is my new motto","msgtype":"m.text"},"ts":1423745078000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: fits you well :-)","msgtype":"m.text"},"ts":1423745860000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"That was a rather fun email to read","msgtype":"m.text"},"ts":1423745869000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: so here is an idea","msgtype":"m.text"},"ts":1423746046000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: the document/worker creates a ServiceWorkerChannel","msgtype":"m.text"},"ts":1423746065000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: in the service worker we expose some kind of uuid per client","msgtype":"m.text"},"ts":1423746079000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: then you construct a ClientChannel by passing it that uuid","msgtype":"m.text"},"ts":1423746090000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: and then they entangle and things work","msgtype":"m.text"},"ts":1423746101000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: we could not even expose a uuid and instead just use the Client objects as parameter, keeping the identification hidden","msgtype":"m.text"},"ts":1423746132000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: it has the fancy pansy constructor design to please Domenic and seems easy enough to use","msgtype":"m.text"},"ts":1423746195000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: if the SW of a document/worker changes existing ServiceWorkerChannel objects will just get associated anew","msgtype":"m.text"},"ts":1423746235000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: can a single ServiceWorkerChannel get messages from multiple serviceworkers?","msgtype":"m.text"},"ts":1423746299000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: over time","msgtype":"m.text"},"ts":1423746314000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"or is it one per sw","msgtype":"m.text"},"ts":1423746315000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"cool","msgtype":"m.text"},"ts":1423746319000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it's associated with the SW that's associated with the document","msgtype":"m.text"},"ts":1423746334000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So I can get messages from my active worker, an installing worker, and even workers from another scope?","msgtype":"m.text"},"ts":1423746339000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"ohh, so I can't get messages from an installing worker","msgtype":"m.text"},"ts":1423746355000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"we could generalize the design on both sides","msgtype":"m.text"},"ts":1423746377000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"if you pass it a specific worker/client it can only communicate with that worker/client, otherwise all of them?","msgtype":"m.text"},"ts":1423746408000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"however, note that with some clever naming scheme this should be doable on top of BroadcastChannel as well...","msgtype":"m.text"},"ts":1423746469000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"using the client's url as identifier + adding the type of SW (active, installing, any), or leaving them out if you want a more generic BroadcastChannel","msgtype":"m.text"},"ts":1423746540000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"so perhaps BroadcastChannel + library is a better way to go","msgtype":"m.text"},"ts":1423746567000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: if the SW has terminated, how does it get broadcastchannel messages?","msgtype":"m.text"},"ts":1423746701000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"ah right, that's why we need something special","msgtype":"m.text"},"ts":1423746730000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"document/worker -> magic -> service worker","msgtype":"m.text"},"ts":1423746771000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"so yeah, for that primitive we need something very much like BroadcastChannel but with the background queueing","msgtype":"m.text"},"ts":1423746808000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"so perhaps ServiceWorkerChannel(optional name) for document/worker and ClientChannel(optional name) for service worker","msgtype":"m.text"},"ts":1423746868000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: maybe the idea of stashed ports is useful here https://gist.github.com/mkruisselbrink/536632fcd99d45005064","msgtype":"m.text"},"ts":1423746870000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so I'm trying to imagine the flow of that...","msgtype":"m.text"},"ts":1423747211000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think this can be done better in similar terms to broadcastchannel","msgtype":"m.text"},"ts":1423747232000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: C connects, SW gets handed a port, stashes port, gets shutdown","msgtype":"m.text"},"ts":1423747239000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: C posts message, SW is booted, gets C connect event with new port?, gets message about stashed port?","msgtype":"m.text"},"ts":1423747275000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: yeah, perhaps we should call it ServiceWorkerChannel on both sides, for the browser it's clear from context what's supposed to happen anyway","msgtype":"m.text"},"ts":1423747333000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: C connects, SW gets handed a port, stashes port, gets shutdown. C posts message, SW is booted, SW gets self.onportmessage with the port & message","msgtype":"m.text"},"ts":1423747373000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: but I still think there's a simpler model","msgtype":"m.text"},"ts":1423747380000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so if the port is stashed you would not get a connection event but a different one?","msgtype":"m.text"},"ts":1423747402000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: it seems nicer if each time you just run the same code (create a ServiceWorkerChannel)","msgtype":"m.text"},"ts":1423747450000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: In the stashed model, you don't need a connect event","msgtype":"m.text"},"ts":1423747504000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: how do you get handed the port?","msgtype":"m.text"},"ts":1423747515000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: in the onportmessage event? It's transferred from the stash","msgtype":"m.text"},"ts":1423747570000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so why do you need to retrieve it from the stash?","msgtype":"m.text"},"ts":1423747595000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: seems like you should be able to store and delete them","msgtype":"m.text"},"ts":1423747612000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah, you'd need an AsyncPortCollection","msgtype":"m.text"},"ts":1423747633000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I do like this idea as it gives you the entire MessagePort ecosystem","msgtype":"m.text"},"ts":1423747646000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think I dislike it for that reason :D","msgtype":"m.text"},"ts":1423747662000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: everything that people build on top of ports can then automatically be ported to service workers","msgtype":"m.text"},"ts":1423747668000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: so yeah, PortCollection has these problems: https://www.w3.org/Bugs/Public/show_bug.cgi?id=23412","msgtype":"m.text"},"ts":1423747738000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: also, it doesn't give a way for the SW to contact a particular client. You'd have a collection of ports sure, but it isn't clear which is which","msgtype":"m.text"},"ts":1423747747000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: however, PortStorage or some such doesn't really have the same issues I think","msgtype":"m.text"},"ts":1423747764000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: we'd put the ports on the client objects and make the client objects live","msgtype":"m.text"},"ts":1423747783000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: or some such","msgtype":"m.text"},"ts":1423747789000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah, not only that, but if you stash two entangled ports you've got a leak","msgtype":"m.text"},"ts":1423747795000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: that could throw","msgtype":"m.text"},"ts":1423747808000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah I guess you want to store more than just the port, you need some metadata","msgtype":"m.text"},"ts":1423747859000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I both like and dislike that this is a hard problem","msgtype":"m.text"},"ts":1423747966000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: so say in clients ServiceWorker objects are live and in service workers Client objects are life, and both of them expose ports","msgtype":"m.text"},"ts":1423748096000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'd still like this to be more under-the-hood. Say when a new page/worker is created, it creates a port pair. When the SW gets a client object, client.postMessage goes to port2.postMessage. port1.onmessage proxies to navigator.serviceWorker.onmessage. You could call it onserviceworkermessage is the naming is a problem (since many ports would land","msgtype":"m.text"},"ts":1423748119000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"messages there)","msgtype":"m.text"},"ts":1423748120000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: if you want for a particular port to remain active from the point of the service worker you store it, and then you remove it once you no longer care","msgtype":"m.text"},"ts":1423748131000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: once clients are GC'd the corresponding ports in storage can also be GC'd","msgtype":"m.text"},"ts":1423748150000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I think that would work","msgtype":"m.text"},"ts":1423748181000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: that doesn't really solve any of the persistency problems, that's sugar we could add later","msgtype":"m.text"},"ts":1423748241000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(with \"I think that would work\" I was referring to my proposal)","msgtype":"m.text"},"ts":1423748277000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: so, self.clients.getAll().then(c => c[0]) - c[0] has a .port?","msgtype":"m.text"},"ts":1423748337000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: if clients become live, I would expect self.clients[0] or some such to work","msgtype":"m.text"},"ts":1423748379000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: and yes, it would","msgtype":"m.text"},"ts":1423748384000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: but unless you store it, it'll go dead","msgtype":"m.text"},"ts":1423748407000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: why do they need to be live? (I'm worried about the overhead of updating those live)","msgtype":"m.text"},"ts":1423748490000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: because the ports are live and it would be kind of weird for static objects to point to live ports that need to be === identical","msgtype":"m.text"},"ts":1423748573000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: so where would client.port.postMessage land?","msgtype":"m.text"},"ts":1423748690000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: navigator.serviceWorker.x.onmessage","msgtype":"m.text"},"ts":1423748730000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: where x is a SW instance? So navigator.serviceWorker.controller.onmessage?","msgtype":"m.text"},"ts":1423748795000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah","msgtype":"m.text"},"ts":1423748862000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"perhaps the ServiceWorkerChannel idea is not that bad as this does seem rather horrid","msgtype":"m.text"},"ts":1423748913000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"and then have port stashing as a separate feature","msgtype":"m.text"},"ts":1423748924000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think we've happened upon the hardest problem in computer science","msgtype":"m.text"},"ts":1423748940000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: but if there's a way for multiple client ports to post message to serviceWorker.onmessage, I think we're getting close to a solution","msgtype":"m.text"},"ts":1423749015000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"no, ports are 1:1","msgtype":"m.text"},"ts":1423749061000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: if the stashing is under-the-hood, does client.postMessage work?","msgtype":"m.text"},"ts":1423749063000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"hm I'm confused","msgtype":"m.text"},"ts":1423749074000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"something like BroadcastChannel can be N:N","msgtype":"m.text"},"ts":1423749075000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I thought you just said clients[0].postMessage and clients[1].postMessage land at navigator.serviceWorker.controller.onmessage","msgtype":"m.text"},"ts":1423749136000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah, but those would be distinct channels","msgtype":"m.text"},"ts":1423749246000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: one for each client","msgtype":"m.text"},"ts":1423749251000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: and something underneath proxies them to the single controller.onmessage?","msgtype":"m.text"},"ts":1423749299000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I don't know, which is why I suggested that maybe ports were not the best idea and something like BroadcastChannel would be better","msgtype":"m.text"},"ts":1423749735000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"how many SW do you anticipate living together and coordinating together?","msgtype":"m.text"},"ts":1423749891000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"annevk: So if each page/worker created a BroadcastChannel using a unique id, client.postMessage could broadcast to that channel, navigator.serviceWorker.onmessage could receive it. The ServiceWorker could also create a uid BroadCastchannel to explain how serviceWorkerInstance.postMessage works. The trouble is identifying the source of those messages. Ideally","msgtype":"m.text"},"ts":1423750096000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"the page wants to get an instance of the SW with the message, and the SW needs a client instance","msgtype":"m.text"},"ts":1423750096000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"caitp-: serviceworker-to-serviceworker is being looked at by http://mkruisselbrink.github.io/navigator-connect/ - I don't really know a whole lot about it though","msgtype":"m.text"},"ts":1423750150000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"my understanding was that they're sort of expensive, so a single application probably doesn't need to set up a whole bunch of them","msgtype":"m.text"},"ts":1423750209000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"unless the idea is that the facebook api needs their own background thread or something, and all of your different tabs need to talk to it","msgtype":"m.text"},"ts":1423750229000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"caitp-: that's more of a sharedworker thing I think","msgtype":"m.text"},"ts":1423750257000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"A serviceworker registration can have 3 serviceworkers active at once, but that's pretty rare. Usually it's only 1.","msgtype":"m.text"},"ts":1423750298000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"The three are installing (setting itself up to be the next version), waiting (ready to be the next version, but the current version is still in use), and active (the current version)","msgtype":"m.text"},"ts":1423750337000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"The installing one would be running, as it's setting up caches and such. The waiting version is rarely running, although I guess it'd have to wake up if you did a postMessage to it. The active version wakes up when it needs to receive events, such as fetch, push, message etc","msgtype":"m.text"},"ts":1423750452000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: why are you so attached to an existing API?","msgtype":"m.text"},"ts":1423750660000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: if we have something like BroadcastChannel that works for service workers, why not let developers create the abstractions?","msgtype":"m.text"},"ts":1423750687000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: maybe I'm letting existing things get in the way, but I don't want something more complicated than client[method-to-send-a-message](obj) + window.somewhere.addEventListener('receive-the-message', event => event[way-to-id-the-sender-and-post-a-message-back]) + serviceWorkerInstance[method-to-send-a-message] +","msgtype":"m.text"},"ts":1423750989000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"self.addEventListener('receive-the-message', event => event[way-to-id-the-sender-and-post-a-message-back])","msgtype":"m.text"},"ts":1423750989000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"what exists?","msgtype":"m.text"},"ts":1423751034000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"we already shipped something?","msgtype":"m.text"},"ts":1423751040000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":":-(","msgtype":"m.text"},"ts":1423751044000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"huh?","msgtype":"m.text"},"ts":1423751053000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"\"letting existing things get in the way\"","msgtype":"m.text"},"ts":1423751078000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"You brought up the existing bit. \"why are you so attached to an existing API?\"","msgtype":"m.text"},"ts":1423751083000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Ah yeah, it seems like you have some idea what you want and try to layer anything on top of that idea","msgtype":"m.text"},"ts":1423751115000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'd be much more interested in just exposing the primitives that make messaging possible","msgtype":"m.text"},"ts":1423751138000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It seems like we keep realizing that we're bad at API design so we should let developers do it and just expose the bare minimum, but then we don't really do that...","msgtype":"m.text"},"ts":1423751172000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'm all for exposing primitives but only if it offers something useful & not just overcomplicating","msgtype":"m.text"},"ts":1423751217000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"If it's a primitive it's by definition not complex","msgtype":"m.text"},"ts":1423751276000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: am I reading the fetch spec correctly in that Access-Control-Allow-Headers is required? https://fetch.spec.whatwg.org/#cors-preflight-fetch","msgtype":"m.text"},"ts":1423751286000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I don't see flickr returning that header... but it seem our fetch() calls go through","msgtype":"m.text"},"ts":1423751304000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: that's only used for preflights","msgtype":"m.text"},"ts":1423751325000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"An API to allow a serviceworker to message a specific client, and allowing a client to message a specific serviceworker doesn't sound like high-level luxury","msgtype":"m.text"},"ts":1423751335000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"wanderview: and only if custom headers are specified","msgtype":"m.text"},"ts":1423751336000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: trained-to-thrill uses custom headers... passes an x-cache header or something","msgtype":"m.text"},"ts":1423751355000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: those never go to fetch()","msgtype":"m.text"},"ts":1423751370000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"The SW stops requests with that header and never passes them to fetch","msgtype":"m.text"},"ts":1423751389000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I thought I saw it in my network panel last night... I could have been dreaming, though","msgtype":"m.text"},"ts":1423751394000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"is there telemetry anywhere for what charset decoders are being used in browsers?","msgtype":"m.text"},"ts":1423751444000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"wanderview: https://github.com/jakearchibald/trained-to-thrill/blob/master/www/static/js-unmin/sw/index.js#L61","msgtype":"m.text"},"ts":1423751452000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it is a luxury if you add some kind of weird duplication/distribution thing to the mix, rather than keep it 1:1","msgtype":"m.text"},"ts":1423751471000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: oh... I think I saw it in the case where SWs weren't enabled... so a fetch() is not done in that case","msgtype":"m.text"},"ts":1423751490000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: 'accept' is a simple header anyway, so won't trigger preflight","msgtype":"m.text"},"ts":1423751492000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yea","msgtype":"m.text"},"ts":1423751504000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: the alternative is something like BroadcastChannel with optional scoping","msgtype":"m.text"},"ts":1423751509000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: requests with that 'accept' should only be sent if the page is controlled https://github.com/jakearchibald/trained-to-thrill/blob/master/www/static/js-unmin/index.js#L68","msgtype":"m.text"},"ts":1423751566000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"AFAICT, Mozilla doesn't have any telemetry for that, and I get confused looked for stuff in the Google telemetry","msgtype":"m.text"},"ts":1423751593000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"JakeA: hmm... I probably did something stupid :-)","msgtype":"m.text"},"ts":1423751623000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: given that both sides have to cooperate I don't really see the problem with using SWC","msgtype":"m.text"},"ts":1423751957000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: e.g. new SWC(url + swType) on both sides gives you quite specific control","msgtype":"m.text"},"ts":1423751981000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: you can basically scope the messaging in any way you want, rather than being tied to some specific scenarios we cooked up","msgtype":"m.text"},"ts":1423752021000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hswolff: I presume the DECODER_INITIATED was the best you could do, and actually having what encoding a given page is would be too expensive and too much data?","msgtype":"m.text"},"ts":1423752119000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"annevk: dumped some requirements at https://github.com/slightlyoff/ServiceWorker/issues/609#issuecomment-74080640","msgtype":"m.text"},"ts":1423752689000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"hswolff: sorry, wrong nick!","msgtype":"m.text"},"ts":1423752767000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"annevk: what is swType?","msgtype":"m.text"},"ts":1423752811000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: e.g. \"installing\" \"active\"","msgtype":"m.text"},"ts":1423753629000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: hmm, so messages get lost if the sw changes state during a conversation?","msgtype":"m.text"},"ts":1423753657000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: that depends on the conventions of your messaging strategy","msgtype":"m.text"},"ts":1423753688000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: the argument is simply a string","msgtype":"m.text"},"ts":1423753693000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: it's up to developers to decide what granularity they need","msgtype":"m.text"},"ts":1423753714000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Thinking about it some more it's not entirely clear how waking up the service worker would work in a clean way with this proposal","msgtype":"m.text"},"ts":1423753908000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: so yeah, maybe I'm coming around to the weird design","msgtype":"m.text"},"ts":1423754005000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"navigator.serviceWorker.onmessage / navigator.serviceWorker[x].postMessage() vs self.onmessage / self.clients.getClients().then((c) => c[0].postMessage())","msgtype":"m.text"},"ts":1423754093000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: you'd still need a way to stash/register the channel, and it'd need to be per serviceworker rather than per registration, so different to where push registrations are stored","msgtype":"m.text"},"ts":1423754093000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"where event.source is the sending client/serviceworker?","msgtype":"m.text"},"ts":1423754159000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"It's not exactly pretty, and I've no idea what the underlying primitives are, but it could be written out in a way that would work","msgtype":"m.text"},"ts":1423754168000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: a static copy of it I guess?","msgtype":"m.text"},"ts":1423754193000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: would not ===","msgtype":"m.text"},"ts":1423754218000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: will try to think about it some more :/","msgtype":"m.text"},"ts":1423754282000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: !== is already true of clients and SerivceWorker instances. Clients are already static. ServiceWorker instances are live as they have .status and a statuschange event","msgtype":"m.text"},"ts":1423754316000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"\"!== is already true\" urm, by that I mean they're not equal, even if they represent the same SW/client","msgtype":"m.text"},"ts":1423754444000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: hmm, it seems weird if serviceworker instances are live that !== would be true","msgtype":"m.text"},"ts":1423754839000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: is the spec broadcasting these statuschange events to all copies or some such?","msgtype":"m.text"},"ts":1423754865000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah","msgtype":"m.text"},"ts":1423754914000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"it's not exactly live if there's a bunch of copies","msgtype":"m.text"},"ts":1423754944000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"live is what the DOM is like","msgtype":"m.text"},"ts":1423754954000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: === means making expandos work across window objects :(","msgtype":"m.text"},"ts":1423754971000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"e.g. <a> being only a single instance ever","msgtype":"m.text"},"ts":1423754974000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: uhm you'd create one per window obv","msgtype":"m.text"},"ts":1423754991000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: otherwise prototype would already be weird","msgtype":"m.text"},"ts":1423755015000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: actually, === is probably useful in this case. if (messageEvent.source === navigator.serviceWorker.controller)","msgtype":"m.text"},"ts":1423755065000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"uhuh, also in the other case though","msgtype":"m.text"},"ts":1423755085000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"you kind of want live Client / SW objects","msgtype":"m.text"},"ts":1423755115000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah, there is a lack of consistency there. Live client objects sounds really tough","msgtype":"m.text"},"ts":1423755318000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"back later, going to try and get some of this talk done","msgtype":"m.text"},"ts":1423755428000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"is sad \"Be my controlled document\" won't fit on a candy heart.","msgtype":"m.emote"},"ts":1423755761000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"gsnedders i will treasure the time we had together","msgtype":"m.text"},"ts":1423757761000,"senderName":"hswolff","senderId":"hswolff@irc"},
{"content":{"body":"ISO-2022-JP, the Russian edition: https://bugzilla.mozilla.org/show_bug.cgi?id=1130533 (KOI8-R)","msgtype":"m.text"},"ts":1423761861000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"annevk: ^","msgtype":"m.text"},"ts":1423761867000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: I presume the DECODER_INITIATED_* was the best you could do, and actually having what encoding a given page is would be too expensive and too much data?","msgtype":"m.text"},"ts":1423761939000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"I need to learn to WONTFIX stuff like that with less debate","msgtype":"m.text"},"ts":1423761956000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"gsnedders: I figured that counting pages is less interesting, because people might be loading the same thing over and over","msgtype":"m.text"},"ts":1423761990000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"gsnedders: if something isn't used in a session at all, it's a good indication that it doesn't matter","msgtype":"m.text"},"ts":1423762011000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"for that user","msgtype":"m.text"},"ts":1423762014000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"gsnedders: but when something is used, the number of times it is used doesn't really tell you much beyond needing to keep the functionality","msgtype":"m.text"},"ts":1423762043000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: so we removed it from the menu based on statistics right?","msgtype":"m.text"},"ts":1423762083000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: based on what the Thunderbird defaults were","msgtype":"m.text"},"ts":1423762111000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"annevk: i.e. no locale saw the need to default to KOI8-R for outgoing","msgtype":"m.text"},"ts":1423762133000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"annevk: and ru-RU even defaulted to UTF-8","msgtype":"m.text"},"ts":1423762143000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: k, it doesn't seem as bad an encoding as iso-2022-jp, but yeah, dunno","msgtype":"m.text"},"ts":1423762156000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hsivonen: wait, Firefox Nightly does still have this encoding as a preference","msgtype":"m.text"},"ts":1423762189000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"well, I'm not a SeaMonkey dev. they can do whatever they like as long as it doesn't affect the UI in mozilla-central","msgtype":"m.text"},"ts":1423762196000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"annevk: for the Web, yes","msgtype":"m.text"},"ts":1423762208000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"annevk: but there's no UI for choosing KOI8-R for the Web","msgtype":"m.text"},"ts":1423762219000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"as a default that is","msgtype":"m.text"},"ts":1423762223000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"annevk: sorry. let me try again","msgtype":"m.text"},"ts":1423762256000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"annevk: Firefox has this encoding in the menu. but not in the pref panel","msgtype":"m.text"},"ts":1423762270000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: ok, just been playing around with faster decoding, and would be interesting to know how many things are decoded with each, but not all too important","msgtype":"m.text"},"ts":1423762292000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"\"Cyrillic\" in the prefs means windows-1251","msgtype":"m.text"},"ts":1423762299000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: just trying to use something as a somewhat arbitrary proxy :)","msgtype":"m.text"},"ts":1423762313000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"note to self: learn to be less easily trolled into using time to debate people who claim recipients can't deal with UTF-8 yet","msgtype":"m.text"},"ts":1423762426000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"btw, if one wants to combine the encoding topic and the EME topic (who doesn't?), just take a look at PlayReady PSSH boxes.","msgtype":"m.text"},"ts":1423762496000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"wasting bytes by making every second byte zero","msgtype":"m.text"},"ts":1423762515000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"because UTF-16","msgtype":"m.text"},"ts":1423762518000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1423762534000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"such great hobbies","msgtype":"m.text"},"ts":1423762545000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: i've been thinking on this vacation, wouldn't it be great if maybe, just sometimes, we had other hobbies?","msgtype":"m.text"},"ts":1423762660000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"terinjokes: I know one person that tried and didn't really succeed, although he did later quit his online persona","msgtype":"m.text"},"ts":1423762871000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'd argue I haven't succeeded on this vacation either.","msgtype":"m.text"},"ts":1423762986000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"Why do you have an internet connection on vacation?","msgtype":"m.text"},"ts":1423763009000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ooh, is this like a \"why did the chicken cross the road\" joke?","msgtype":"m.text"},"ts":1423763074000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"\"To get to the other side\"?","msgtype":"m.text"},"ts":1423763084000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Ms2ger: I have to book trains and hostels","msgtype":"m.text"},"ts":1423763262000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"Hey TabAtkins, is this a good place to ask you about  the status of ::before and ::after interactions with replaced elements?","msgtype":"m.text"},"ts":1423783585000,"senderName":"TylerH","senderId":"TylerH@irc"},
{"content":{"body":"Specifically \" Note. This specification does not fully define the interaction of :before and :after with replaced elements (such as IMG in HTML). This will be defined in more detail in a future specification. \" from http://www.w3.org/TR/CSS21/generate.html#before-after-content (when will the specification define it in more detail?)","msgtype":"m.text"},"ts":1423783882000,"senderName":"TylerH","senderId":"TylerH@irc"},
{"content":{"body":"TylerH: Either the Pseudo-Elements spec or the Content spec will define that.  Hasn't been done yet.","msgtype":"m.text"},"ts":1423784057000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Hmm, I had to do search and replace on every third <td> element in a table, and I couldn't think of a cleverer way of doing it than n n <space>, and now I have We Will Rock You in my head","msgtype":"m.text"},"ts":1423784942000,"senderName":"jgraham","senderId":"jgraham@irc"}
]