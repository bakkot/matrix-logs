[
{"content":{"body":"at that point use a stream","msgtype":"m.text"},"ts":1539303920000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"should HTMLDocument be considered deprecated?","msgtype":"m.text"},"ts":1539321772000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"if browsers are required to implement it and there are no plans to ever remove it from the platform, then it seems like it shouldn’t be classified as deprecated","msgtype":"m.text"},"ts":1539321852000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"sure it’s just specified as an alias for Document, but it’s still specified","msgtype":"m.text"},"ts":1539322072000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: where is it classified as such?","msgtype":"m.text"},"ts":1539326499000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: there are still some open issues around defining it unfortunately","msgtype":"m.text"},"ts":1539326535000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: in MDN and in https://github.com/mdn/browser-compat-data","msgtype":"m.text"},"ts":1539327169000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"I updated MDN and will make a PR for https://github.com/mdn/browser-compat-data","msgtype":"m.text"},"ts":1539327182000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"in MDN and in that BCD data, some things seem to be flagged as deprecated just because they’re not useful","msgtype":"m.text"},"ts":1539327275000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"e.g., NavigatorID: appName and such","msgtype":"m.text"},"ts":1539327314000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"will fix those too","msgtype":"m.text"},"ts":1539327339000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: interesting, I guess someone had opinions","msgtype":"m.text"},"ts":1539333597000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"https://github.com/httpwg/http-core/issues/148 this took me a while","msgtype":"m.text"},"ts":1539337874000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"are there plans to add async iteration to EventTarget","msgtype":"m.text"},"ts":1539345537000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"`slikts: https://github.com/whatwg/dom/issues/544","msgtype":"m.text"},"ts":1539345757000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"`slikts: it's unclear whether that or async iteration is really a good fit though, as event listeners are called synchronously","msgtype":"m.text"},"ts":1539345785000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"that is about observables, however; what I meant is async iterables","msgtype":"m.text"},"ts":1539345997000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"I strongly believe eventtarget should support the language's native async primitive for streams","msgtype":"m.text"},"ts":1539346014000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"I've made a library for adapting streams to async iterables in the interim; I'll share it in a moment after updating its readme","msgtype":"m.text"},"ts":1539346055000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"it's like streams api-lite","msgtype":"m.text"},"ts":1539346072000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"just because I want to use these things now","msgtype":"m.text"},"ts":1539346087000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"`slikts: yeah, async interables aren't quite compatible","msgtype":"m.text"},"ts":1539346148000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"`slikts: does your library handle invoking preventDefault() from a listener?","msgtype":"m.text"},"ts":1539346166000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"`slikts: (observables have the same issue)","msgtype":"m.text"},"ts":1539346180000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"`slikts: (and the idea was that both observables and streams would also impl the async iterable protocol)","msgtype":"m.text"},"ts":1539346201000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I've not looked into it that deeply; just in the abstract","msgtype":"m.text"},"ts":1539346236000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"I'll read the thread a bit later","msgtype":"m.text"},"ts":1539346257000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"`slikts: FWIW, I'm very supportive of adding a better API on top of events somehow, the problem is finding something that's the right fit","msgtype":"m.text"},"ts":1539346301000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"there won't be a better fit that what's supported natively","msgtype":"m.text"},"ts":1539346324000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"in the base language","msgtype":"m.text"},"ts":1539346333000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"*than","msgtype":"m.text"},"ts":1539346370000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"If by that you mean async iterables, see above about it not working with everything events can do...","msgtype":"m.text"},"ts":1539346380000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"You cannot reframe things on top of a primitive that's a feature mismatch","msgtype":"m.text"},"ts":1539346399000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"where there's a will...","msgtype":"m.text"},"ts":1539346470000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"I mean, it's already questionable whether observables will make it in since they overlap with async iterables","msgtype":"m.text"},"ts":1539346508000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Observables also fail the preventDefault() test","msgtype":"m.text"},"ts":1539346533000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"so an alternative async stream primitive with even less mindshare is even less likely","msgtype":"m.text"},"ts":1539346537000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Something that works for events would be fine","msgtype":"m.text"},"ts":1539346605000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"here's the library: https://github.com/slikts/queueable","msgtype":"m.text"},"ts":1539350359000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"still wip; I'm adding documentation, demos","msgtype":"m.text"},"ts":1539350371000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"So TabAtkins if you're there, do we have that feature yet where you can find who links your spec definition?","msgtype":"m.text"},"ts":1539351967000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Hey! I have a question regarding https://fetch.spec.whatwg.org/#cors-check and the use of origin-or-null. IIUC, a \"null\" origin would match a case where the request has a tainted origin. Should we match that in RT's TAO processing in https://w3c.github.io/resource-timing/#sec-timing-allow-origin?","msgtype":"m.text"},"ts":1539352495000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: what do you currently do?","msgtype":"m.text"},"ts":1539352543000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: it’s also for opaque origins","msgtype":"m.text"},"ts":1539352569000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: current processing just compares the document's origin to the header value, and fails if they don't match","msgtype":"m.text"},"ts":1539352580000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"but not special casing \"null\"","msgtype":"m.text"},"ts":1539352617000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: byte-for-byte-comparison is what's supposed to happen","msgtype":"m.text"},"ts":1539352813000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"OK","msgtype":"m.text"},"ts":1539352849000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: so \"null\" automatically works; it's not specialcased in CORS check either","msgtype":"m.text"},"ts":1539352877000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah, but IIUC, it's \"generated\" in https://fetch.spec.whatwg.org/#serializing-a-request-origin","msgtype":"m.text"},"ts":1539352936000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"which RT is not using (but maybe it should...)","msgtype":"m.text"},"ts":1539352945000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: does RT have a request header that carries an origin?","msgtype":"m.text"},"ts":1539353020000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"not really, the origin comparison are based on the document's origin","msgtype":"m.text"},"ts":1539353051000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"so we can't use Fetch's algorithm directly (unless we abstract it a bit)","msgtype":"m.text"},"ts":1539353071000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: so then you also can't have a tainted origin","msgtype":"m.text"},"ts":1539353103000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: `slikts: see https://stackoverflow.com/questions/39439653/events-vs-streams-vs-observables-vs-async-iterators","msgtype":"m.text"},"ts":1539353116000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yoav: which is probably broken","msgtype":"m.text"},"ts":1539353118000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Async iterables are pull, and a bad fit for events","msgtype":"m.text"},"ts":1539353130000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Observables are push, and a reasonable fit for events. They work fine with preventDefault.","msgtype":"m.text"},"ts":1539353153000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yoav: if the response was gotten via redirects that did something malicious","msgtype":"m.text"},"ts":1539353159000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: they're quite nice for certain applications where you could want to skip events, like frames or mouse moves","msgtype":"m.text"},"ts":1539353167000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"ReadableStreams are becoming async iterators already.","msgtype":"m.text"},"ts":1539353178000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: yeah, I follow that issue","msgtype":"m.text"},"ts":1539353191000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"the thing about it is that async iterables are in the language now","msgtype":"m.text"},"ts":1539353214000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"observables might never be in it","msgtype":"m.text"},"ts":1539353222000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"and observables wouldn't have niceties like generator functions and for-await-of","msgtype":"m.text"},"ts":1539353250000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Domenic: except for promise-returning methods","msgtype":"m.text"},"ts":1539353275000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"also, async iterables aren't just pull, they're pull-push","msgtype":"m.text"},"ts":1539353286000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"\"in the language\" is not an interesting distinction.","msgtype":"m.text"},"ts":1539353301000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yoav: open an issue? I can investigate a bit","msgtype":"m.text"},"ts":1539353308000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Those niceties make no sense for events because those niceties are fundamentally pull (e.g. they buffer and operate on promises which breaks preventDefault)","msgtype":"m.text"},"ts":1539353345000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: it for sure is; having native support, for example, means that engines will focus on optimizations","msgtype":"m.text"},"ts":1539353346000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"That's not true","msgtype":"m.text"},"ts":1539353352000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"as they have already with async iterables and promises","msgtype":"m.text"},"ts":1539353354000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"As an implementer I can guarantee you optimizing user code is just as important","msgtype":"m.text"},"ts":1539353371000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: There's https://github.com/w3c/resource-timing/issues/152 which I thought was a small plumbing issue","msgtype":"m.text"},"ts":1539353375000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Built in things start out slow and catch up to user code as we've seen with promises","msgtype":"m.text"},"ts":1539353387000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: moreover, it's about optics and stability -- a native feature has official approbation and it also won't get yanked away at stage 3","msgtype":"m.text"},"ts":1539353433000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"annevk: but now sounds like potentially something to go with the larger scale Fetch integration","msgtype":"m.text"},"ts":1539353442000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Domenic: it's also about familiarity -- iterables and promises are already familiar to many users","msgtype":"m.text"},"ts":1539353475000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Well, can't really help you with your perception. All I can say is we're not going to base events on async iterables since that's a mismatch; it's like basing them on numbers or something else totally inappropriate.","msgtype":"m.text"},"ts":1539353495000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yoav: well, some of this can probably be done without all that, but who knows","msgtype":"m.text"},"ts":1539353523000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: relying on https://tools.ietf.org/html/rfc6454 is broken too","msgtype":"m.text"},"ts":1539353528000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: even if it's a mismatch, calling it totally inappropriate is an overstatement","msgtype":"m.text"},"ts":1539353552000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Dunno if broken, but definitely seems better to use the same primitives as Fetch","msgtype":"m.text"},"ts":1539353583000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"they're somewhat isomorphic concepts, if that makes sense","msgtype":"m.text"},"ts":1539353592000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"yoav: that entire RFC is replaced by concepts in HTML, URL, and Fetch, but maybe, I guess it depends on the specific usage","msgtype":"m.text"},"ts":1539353663000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"observables are just stage 1; it's really hard to sell people on something like that","msgtype":"m.text"},"ts":1539353745000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Observables are a library","msgtype":"m.text"},"ts":1539353766000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yoav: but yeah, seems like there are a number of issues here, some more easy to fix than others","msgtype":"m.text"},"ts":1539353771000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"You are using a different notion of \"isomorphic\" than the accepted one","msgtype":"m.text"},"ts":1539353780000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: it's even harder to sell people on libraries","msgtype":"m.text"},"ts":1539353785000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Domenic: yeah, I qualified it with \"somewhat\"","msgtype":"m.text"},"ts":1539353799000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Well, not sure why you need to be selling anything here","msgtype":"m.text"},"ts":1539353801000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"you need to squint","msgtype":"m.text"},"ts":1539353803000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Domenic: not here; in general","msgtype":"m.text"},"ts":1539353819000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"something being \"sold\" determines if you get to use it in many cases","msgtype":"m.text"},"ts":1539353833000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"it's the difference whether you can use it for a hobby project or something more serious","msgtype":"m.text"},"ts":1539353850000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"and get other people to collaborate, build an ecosystem, etc.","msgtype":"m.text"},"ts":1539353864000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"I'm very entusiastic about reactive programming, but it's just being realistic that observables have a lot of things working against them","msgtype":"m.text"},"ts":1539353921000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"async iterables are a way to get a foot into the door","msgtype":"m.text"},"ts":1539353939000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Yeah, I think they need to stand on their own merits, without language support.","msgtype":"m.text"},"ts":1539353953000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"since those, too, are declarative and can be used reactively","msgtype":"m.text"},"ts":1539353955000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"above all it's about selling the concept of transformative pipeline programming","msgtype":"m.text"},"ts":1539353985000,"senderName":"`slikts","senderId":"`slikts@irc"},
{"content":{"body":"Almost ready to define new infrastructure for HTTP header parsing","msgtype":"m.text"},"ts":1539355039000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"And then define parsing of all the HTTP headers, to some extent","msgtype":"m.text"},"ts":1539355057000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Content-Type and Content-Length at least, I guess","msgtype":"m.text"},"ts":1539355066000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"This is a little exciting","msgtype":"m.text"},"ts":1539355260000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Any Fetch/HTML WPTs you know if that I can rip off when it comes to testing opaque origins and origin comparison in general?","msgtype":"m.text"},"ts":1539356623000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: not offhand, but there is cors/ and fetch/api/cors/","msgtype":"m.text"},"ts":1539357049000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ok, cool. I'll look for it","msgtype":"m.text"},"ts":1539357095000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"annevk: Would appreciate if you could take a look at https://github.com/w3c/resource-timing/pull/172 and let me know if it seems reasonable","msgtype":"m.text"},"ts":1539357312000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: you need document’s origin in DOM, not the type it holds","msgtype":"m.text"},"ts":1539357397000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: and origins are always serialized in “ASCII” which is why we dropped that from the term","msgtype":"m.text"},"ts":1539357449000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Prolly ok otherwise but omw home on a phone","msgtype":"m.text"},"ts":1539357489000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: not sure what you mean by \"you need document’s origin in DOM, not the type it holds\"","msgtype":"m.text"},"ts":1539357699000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"(none of this is urgent by the way, so we can continue next week if that's better for you)","msgtype":"m.text"},"ts":1539357730000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: you ref concept-origin in HTML, that’s a type","msgtype":"m.text"},"ts":1539363297000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: you want the link I gave in the comment","msgtype":"m.text"},"ts":1539363319000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: that’s a slot on document","msgtype":"m.text"},"ts":1539363334000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Not yet, no.","msgtype":"m.text"},"ts":1539365058000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: Google search found four so far, so there’s that","msgtype":"m.text"},"ts":1539365260000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"https://stackoverflow.com/questions/52771970/use-fetch-streams-api-to-consume-chunked-data-asynchronously-without-using-recur","msgtype":"m.text"},"ts":1539367510000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: so the problem is OOM due to promise allocation?","msgtype":"m.text"},"ts":1539370400000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: if true, I guess that is something not all browsers have tried to optimize and was kind of indicated to be a problem of sorts","msgtype":"m.text"},"ts":1539370503000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: the difference between the two scenarios is 10x promises afaict","msgtype":"m.text"},"ts":1539370573000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah based on “The browser dies at about 50,000 JSON objects” I guess OOM","msgtype":"m.text"},"ts":1539380656000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"}
]