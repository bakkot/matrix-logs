[
{"content":{"body":"annevk: following the metadata/cors thing, I found a scenario where metadata resolution of image can be detected for cross-origin images even with the current patch, due to the behavior of srcset :(","msgtype":"m.text"},"ts":1594025317000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: interesting, did you document that somewhere?","msgtype":"m.text"},"ts":1594025356000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: https://github.com/whatwg/html/pull/5574#issuecomment-654100058","msgtype":"m.text"},"ts":1594025370000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"zcorpan might be able to help out solutions-wise","msgtype":"m.text"},"ts":1594025382000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"looks","msgtype":"m.emote"},"ts":1594025397000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: I guess what should happen there is that 2x will be interpreted as 4x per the rules I proposed","msgtype":"m.text"},"ts":1594025496000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'm beginning to think that both with this and with orientation, the metadata should be completely ignored unless there's either CORS or a new header similar Allow-Timing-Origin","msgtype":"m.text"},"ts":1594025505000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"Yeah, that's what I suggested initially and is rather attractive due to its simplicity","msgtype":"m.text"},"ts":1594025587000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"though it would create a thing where images sometimes rotate correctly and sometimes not, depending on who's presenting them","msgtype":"m.text"},"ts":1594025655000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"which is I guess is unavoidable anyway","msgtype":"m.text"},"ts":1594025689000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"Same with scaling","msgtype":"m.text"},"ts":1594025691000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1594025695000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"but it's unavoidable in a way. it's a matter of what's the default","msgtype":"m.text"},"ts":1594025709000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"To recap: the solutions we have for opaque-response images are 1) ignore metadata 2) use metadata when decoding and creating a bitmap and forget it afterwards","msgtype":"m.text"},"ts":1594025771000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"1) would make images seem different for different embedders. 2) will make images seem different for different embedders under certain conditions only, such as the embedder using srcset or CSS image-orientation","msgtype":"m.text"},"ts":1594025864000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"(2) would maybe allow a nicer working \"default\" but would create somewhat of a set of intricate rules that's difficult to follow and may be subject to change.","msgtype":"m.text"},"ts":1594025972000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"Yeah, I'm also not entirely convinced about a new header for metadata btw. Metadata is data and especially if we decide to expose more image metadata over time (e.g., all of EXIF) it might not be a tradeoff folks are equipped to make well","msgtype":"m.text"},"ts":1594026037000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"2 requires a particular implementation architecture to ensure stuff doesn't leak, which indeed may be tricky and error-prone.","msgtype":"m.text"},"ts":1594026110000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"maybe a header can be more specific, rather than about metadata, it would be about intrinsic geometry (orientation/preferred-size)","msgtype":"m.text"},"ts":1594027166000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"It's a bit of a slippery slope though. And also, some of the rotation values make it easy to determine an image is a selfie. I'm not sure that's the kind of thing people would think of though when deciding to expose it to help with rendering.","msgtype":"m.text"},"ts":1594027353000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yea, I can see that. If we get some consensus behind the direction of blocking metadata for opaque-resource images, I can update my EXIF-resolution patch to do the right thing (probably option 1).","msgtype":"m.text"},"ts":1594027677000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: noamr: not extending capabilities of opaque cross-origin responses seems like a good strategy, though I haven't given it a lot of thought","msgtype":"m.text"},"ts":1594039173000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"in https://mimesniff.spec.whatwg.org/#sniffing-a-mislabeled-binary-resource there is a warning about loading a scriptable mime type, but I don't see WASM/JS which now have `import` listed as scriptable even though they now can load scripts directly","msgtype":"m.text"},"ts":1594043690000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"is there some more background on that call out?","msgtype":"m.text"},"ts":1594043702000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: loading those MIME types is not dangerous since they display as text/plain","msgtype":"m.text"},"ts":1594044810000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"https://html.spec.whatwg.org/multipage/browsing-the-web.html#process-a-navigate-response step 5","msgtype":"m.text"},"ts":1594044855000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Although wasm isn't handled explicitly; I'd imagine it ends up in one of the fallthrough cases","msgtype":"m.text"},"ts":1594044880000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"andreubotella: heya, I'm not sure I understand","msgtype":"m.text"},"ts":1594052193000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"andreubotella: if read were to return a blocking token, wouldn't that require us to update all callers to keep invoking read until it no longer does?","msgtype":"m.text"},"ts":1594052221000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: The idea was to have read block for some time, undefined by the spec, until the implementation got the next byte / scalar value from I/O.","msgtype":"m.text"},"ts":1594052279000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"the token's blocking-ness would be irrelevant once it was returned","msgtype":"m.text"},"ts":1594052298000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"but now that I've thought it over, this idea was probably not the best","msgtype":"m.text"},"ts":1594052332000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"As I said before, I was trying to keep the blockiness of read which was never explicit in the spec","msgtype":"m.text"},"ts":1594052513000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"andreubotella: another alternative might be to have a buffered queue and an I/O queue","msgtype":"m.text"},"ts":1594052601000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"andreubotella: and read blocks when operating on the latter","msgtype":"m.text"},"ts":1594052613000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"andreubotella: this would allow making callers more precise over time","msgtype":"m.text"},"ts":1594052634000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"andreubotella: and we'd say that I/O queue can only be used \"in parallel\"","msgtype":"m.text"},"ts":1594052648000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Do we even want to have read block? Or is there no point in making it async when a page is being loaded?","msgtype":"m.text"},"ts":1594052769000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"andreubotella: it's fine for it to block if you run it in parallel","msgtype":"m.text"},"ts":1594052878000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"andreubotella: and I guess if we were to more formally define, say, the HTML parser, that's what we'd do","msgtype":"m.text"},"ts":1594052895000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"andreubotella: and then only tree construction we'd run on the main thread from tasks (which would also properly deal with mutation observers, script execution, custom elements, and such)","msgtype":"m.text"},"ts":1594052934000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"andreubotella: other kinds of things that decode I/O streams can similarly be run in parallel from the main thread, afaik","msgtype":"m.text"},"ts":1594052967000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I was thinking that for the encoding sniffing algorithm, say, there's not much point in waiting for the 1024 bytes off the main thread, since there's not much else for the thread to do while the page is loading","msgtype":"m.text"},"ts":1594053030000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"but for everything else it must be run in parallel","msgtype":"m.text"},"ts":1594053040000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"but that distinction can be refined later on","msgtype":"m.text"},"ts":1594053090000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"andreubotella: well, while a new document is being loaded, the old document is still active, we wouldn't want to block it","msgtype":"m.text"},"ts":1594053120000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hm, right","msgtype":"m.text"},"ts":1594053135000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"I'm not as familiar with those parts of the HTML spec","msgtype":"m.text"},"ts":1594053142000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"If we find a case where we need to block the main thread on I/O I guess we could remove the \"in parallel\" requirement, but I doubt we will as it seems like a bug","msgtype":"m.text"},"ts":1594053201000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So I think I'll close that PR and wait for #215 to be merged before opening another one with those changes","msgtype":"m.text"},"ts":1594053377000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"Especially since it gets hard to talk about a concept while we're bikeshedding its new name","msgtype":"m.text"},"ts":1594053397000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"Dear Editors, thank you so much for your incredible work on url.spec.whatwg.org","msgtype":"m.text"},"ts":1594069016000,"senderName":"zeroed","senderId":"zeroed@irc"}
]