[
{"content":{"body":"Oh, I guess I just need to fix my concept of 'current token' so it's not simply the most recent token on the stack","msgtype":"m.text"},"ts":1183680000000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: stack?","msgtype":"m.text"},"ts":1183680001000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Well, append-only stack","msgtype":"m.text"},"ts":1183680060000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"so, er, I guess it's more like a list","msgtype":"m.text"},"ts":1183680061000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: do you mean your test harness builds a list of tokens?","msgtype":"m.text"},"ts":1183680180000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"I was just thinking that there's no stack in the tokenizer","msgtype":"m.text"},"ts":1183680181000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"The tokeniser itself builds a list of tokens (and then prints them all out at the end)","msgtype":"m.text"},"ts":1183680300000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(though I can change it to not do that, because it only ever needs a single current token and a bit of cheating to merge character tokens)","msgtype":"m.text"},"ts":1183680301000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Ooh, it sort of almost works, some of the time","msgtype":"m.text"},"ts":1183681140000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"interesting, i never considered parse errors as a token type","msgtype":"m.text"},"ts":1183681320000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i just treat them as an out-of-band callback called during parse (my parser is synchronous, it returns a complete document once the parsing is done)","msgtype":"m.text"},"ts":1183681321000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: I treat both errors and tokens as callbacks","msgtype":"m.text"},"ts":1183681500000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1183681501000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"they are on different interfaces but the handler that generates JSON implements both","msgtype":"m.text"},"ts":1183681502000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Now I pass all of test1.dat and test2.dat except for about half of them which are just bits I haven't quite implemented yet","msgtype":"m.text"},"ts":1183681620000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"needs to write a Perl one after this","msgtype":"m.emote"},"ts":1183681740000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(Actually, I probably don't, since there'd be no point at all)","msgtype":"m.text"},"ts":1183682100000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"why not?","msgtype":"m.text"},"ts":1183682101000,"senderName":"webben","senderId":"webben@irc"},
{"content":{"body":"Because a tokeniser by itself isn't very useful :-)","msgtype":"m.text"},"ts":1183682220000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"http://canvex.lazyilluminati.com/misc/states6.png - now with fewer bugs than before, since implementation seems to pass most of the tests now","msgtype":"m.text"},"ts":1183685400000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"*the implementation","msgtype":"m.text"},"ts":1183685460000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"yay squiggly lines","msgtype":"m.text"},"ts":1183685520000,"senderName":"nickshanks","senderId":"nickshanks@irc"},
{"content":{"body":"Philip`: what's the difference between red and black lines?","msgtype":"m.text"},"ts":1183685580000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"(Oh, I segfault on <x y=\"&\">, which can't be good)","msgtype":"m.text"},"ts":1183685581000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"an especially squiggly red one going from CommentEndDash to Data","msgtype":"m.text"},"ts":1183685640000,"senderName":"nickshanks","senderId":"nickshanks@irc"},
{"content":{"body":"Lachy: Red is transitions that are parse errors, black is transitions that probably aren't","msgtype":"m.text"},"ts":1183685641000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1183685642000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"(\"probably\" because of the parse-error-unless-it's-a-permitted-slash thing, which the graph treats as not-an-error)","msgtype":"m.text"},"ts":1183685643000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"that's awesome","msgtype":"m.text"},"ts":1183685700000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"why not have a red line and a black line when you have the permitted slash thing?","msgtype":"m.text"},"ts":1183685701000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"you do that elsewhere","msgtype":"m.text"},"ts":1183685702000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"yay, bogus doctype only has red arrows leading to it","msgtype":"m.text"},"ts":1183685703000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"same with bogus comment, yay","msgtype":"m.text"},"ts":1183685704000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"you really should use another colour for the EOF transitions","msgtype":"m.text"},"ts":1183685760000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"in fact maybe we should have an EOF state","msgtype":"m.text"},"ts":1183685761000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"instead of having EOF go back to the dat astate","msgtype":"m.text"},"ts":1183685762000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"I can't easily have both because I only generate one arrow per transition from the original algorithm, and then delete all duplicates, so it only ends up with red+black when there are two separate transitions between the same states","msgtype":"m.text"},"ts":1183685820000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"ah ok","msgtype":"m.text"},"ts":1183685821000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"didn't realise it came from actual code","msgtype":"m.text"},"ts":1183685822000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"that graph is awesome","msgtype":"m.text"},"ts":1183685880000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"It's not entirely actual code - the algorithm is represented as data in OCaml, and I can generate that graph or a C++ implementation from that data","msgtype":"m.text"},"ts":1183685881000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"it shows that there are really three basic ideas","msgtype":"m.text"},"ts":1183685882000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"aah","msgtype":"m.text"},"ts":1183685883000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"cool","msgtype":"m.text"},"ts":1183685884000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"is there any reason why you couldn't generate a, say, Python or Ruby implementation from that data?","msgtype":"m.text"},"ts":1183685940000,"senderName":"rubys","senderId":"rubys@irc"},
{"content":{"body":"http://canvex.lazyilluminati.com/misc/states7.png - unless I did something wrong, that has blue lines for every transition that cannot occur if EOF is never consumed","msgtype":"m.text"},"ts":1183686120000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(i.e. all the transitions that are (at least partially) caused by EOF)","msgtype":"m.text"},"ts":1183686121000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"can you try it with a separate state for EOF? or is that more effort than it's worth?","msgtype":"m.text"},"ts":1183686180000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it'd be cool to have the arrows go down to another state for EOF, it would look less cluttered i'd think","msgtype":"m.text"},"ts":1183686181000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"just an idea, don't worry about it if it's more work than a few seconds :-)","msgtype":"m.text"},"ts":1183686182000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"rubys: I don't think there is any reason why that wouldn't work","msgtype":"m.text"},"ts":1183686183000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"this is really cool","msgtype":"m.text"},"ts":1183686184000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"I've still had to manually write a few hundred lines of C++ (which would need to be ported to other languages), mostly for the entity parsing (since that's too boring to do in a more generic way), but then it generates a thousand lines of state-machine code automatically","msgtype":"m.text"},"ts":1183686300000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"I don't know O'Caml, but this sounds like a wonderful excuse to learn.  Will you be publishing your source at some point?","msgtype":"m.text"},"ts":1183686301000,"senderName":"rubys","senderId":"rubys@irc"},
{"content":{"body":"I didn't know it either, so I'm using it as exactly the same excuse ;-)","msgtype":"m.text"},"ts":1183686302000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"I'll try to upload what I've done soonish","msgtype":"m.text"},"ts":1183686360000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"looks like it could be used to generate code coverage testcases too","msgtype":"m.text"},"ts":1183686361000,"senderName":"KevinMarks","senderId":"KevinMarks@irc"},
{"content":{"body":"I'm sure there must be a way to add in a new EOF state in about three lines of code, but I'm also sure they'll take a few minutes to work out...","msgtype":"m.text"},"ts":1183686420000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"http://canvex.lazyilluminati.com/misc/states8.png","msgtype":"m.text"},"ts":1183686900000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(Hmm, it took fourteen lines)","msgtype":"m.text"},"ts":1183686901000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"sweet","msgtype":"m.text"},"ts":1183686960000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"that's totally awesome","msgtype":"m.text"},"ts":1183687020000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Now I just need to make it able to generate the spec text from the algorithm ;-)","msgtype":"m.text"},"ts":1183687080000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"hah","msgtype":"m.text"},"ts":1183687081000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"wonders if people have experience of how much more time it takes to implement tree construction compared to tokenisation","msgtype":"m.emote"},"ts":1183687200000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"about twice as long to write, about three times as long to debug, iirc","msgtype":"m.text"},"ts":1183687201000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"but it's not especially hard","msgtype":"m.text"},"ts":1183687202000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"just tedious","msgtype":"m.text"},"ts":1183687203000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"why is there a blue arrow from data to data?","msgtype":"m.text"},"ts":1183687620000,"senderName":"rubys","senderId":"rubys@irc"},
{"content":{"body":"Because I modified the algorithm so any case which is triggered by EOF and causes a transition into the Data state, was changed to transition into the EOFData state","msgtype":"m.text"},"ts":1183687860000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"but the relevant part inside the Data state bit of the algorithm doesn't transition into the Data state","msgtype":"m.text"},"ts":1183687861000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(because I didn't bother writing in the \"stay in the same state\" bits explicitly)","msgtype":"m.text"},"ts":1183687920000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"so that could be considered a bug in my old-algorithm-to-new-algorithm transformation code, but it'd require too much effort to fix :-)","msgtype":"m.text"},"ts":1183687921000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Hmm, it's far too easy to get exponential growth in these things","msgtype":"m.text"},"ts":1183688280000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"http://canvex.lazyilluminati.com/misc/states9.png - I'm not sure why it's gone quite that bad","msgtype":"m.text"},"ts":1183688400000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"holy crap what the hell is that","msgtype":"m.text"},"ts":1183688460000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"states * pcdata etc?","msgtype":"m.text"},"ts":1183688461000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Yes","msgtype":"m.text"},"ts":1183688520000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"I suppose it's unhappy because lots of states emit start/end tag tokens when they see EOF, and the tokeniser can't tell what the tree constructor is going to do to the content model flag when that happens, so I assume it could end up being set to anything, which causes unpleasant growth","msgtype":"m.text"},"ts":1183688580000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(\"I assume\" = \"I tell the code to assume\")","msgtype":"m.text"},"ts":1183688581000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Looks like that is the case - http://canvex.lazyilluminati.com/misc/states10.png is far better without the EOFs","msgtype":"m.text"},"ts":1183688760000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: what are you using to create those flow charts?","msgtype":"m.text"},"ts":1183688820000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"Graphviz","msgtype":"m.text"},"ts":1183688880000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(It does tend to collapse into a mass of unreadable squiggles when you get past a certain size, and I always tend to use it on things that approach that size, but I've not heard of anything else that does the same kind of thing)","msgtype":"m.text"},"ts":1183689000000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(Uh, \"same kind of thing\" = drawing graphs, not collapsing into squiggles)","msgtype":"m.text"},"ts":1183689060000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"What is whatwg ?","msgtype":"m.text"},"ts":1183689960000,"senderName":"minerale","senderId":"minerale@irc"},
{"content":{"body":"u mean this channel?","msgtype":"m.text"},"ts":1183690020000,"senderName":"wildcfo","senderId":"wildcfo@irc"},
{"content":{"body":"The website needs an 'about' link","msgtype":"m.text"},"ts":1183690021000,"senderName":"minerale","senderId":"minerale@irc"},
{"content":{"body":"I just saw the site in a slashdot sig, went there and was not sure how it related to silverlight","msgtype":"m.text"},"ts":1183690022000,"senderName":"minerale","senderId":"minerale@irc"},
{"content":{"body":"is it some kind of social front end to w3c's html specifications?","msgtype":"m.text"},"ts":1183690200000,"senderName":"minerale","senderId":"minerale@irc"},
{"content":{"body":"minerale: see http://blog.whatwg.org/faq/#whattf","msgtype":"m.text"},"ts":1183690260000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"minerale: we're basically the renegade group that started html5","msgtype":"m.text"},"ts":1183690320000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"My entirely unoptimised C++ tokeniser (which no longer segfaults) takes about 0.4 seconds for the HTML5 spec, which doesn't seem too bad","msgtype":"m.text"},"ts":1183690620000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(It's certainly a bit useless, because it just computes all the tokens and then memory-leaks them away)","msgtype":"m.text"},"ts":1183690740000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: yeah tokenising is easy","msgtype":"m.text"},"ts":1183691520000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Philip`: the tree construction is definitely the more expensive part","msgtype":"m.text"},"ts":1183691580000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"http://html5.googlecode.com/svn/trunk/data/","msgtype":"m.text"},"ts":1183707960000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"enjoy","msgtype":"m.text"},"ts":1183707961000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(hsivonen, jgraham, Philip`, anyone else writing an HTML5 parser ^)","msgtype":"m.text"},"ts":1183708020000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: thank you","msgtype":"m.text"},"ts":1183710480000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hm","msgtype":"m.text"},"ts":1183710720000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"so i have data on attributes-per-element and suchlike","msgtype":"m.text"},"ts":1183710721000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"but i don't know exactly what you want to know","msgtype":"m.text"},"ts":1183710722000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"cumulative percentages of x% had 0 attributes, y% had <=1 attributes, z% had <=2 attributes, etc.","msgtype":"m.text"},"ts":1183710780000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hm","msgtype":"m.text"},"ts":1183710781000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"hm","msgtype":"m.text"},"ts":1183710960000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"if 10 elements had 0 attributes","msgtype":"m.text"},"ts":1183710961000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"and i know there were 20 elements","msgtype":"m.text"},"ts":1183710962000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"and 5 elements had 1 attribute","msgtype":"m.text"},"ts":1183710963000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"I meant element instances, not element names, btw","msgtype":"m.text"},"ts":1183710964000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"that means 75% had <= 1","msgtype":"m.text"},"ts":1183711020000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"right?","msgtype":"m.text"},"ts":1183711021000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1183711022000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i know","msgtype":"m.text"},"ts":1183711023000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1183711024000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"so i just need to add numbers until i get to one where i don't know the number","msgtype":"m.text"},"ts":1183711025000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"hsivonen: ok, see http://html5.googlecode.com/svn/trunk/data/misc.txt","msgtype":"m.text"},"ts":1183713120000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: thank you","msgtype":"m.text"},"ts":1183713360000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"my pleasure","msgtype":"m.text"},"ts":1183713420000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"elements with <= 0 attributes:  33.5% is lower than I would have guessed","msgtype":"m.text"},"ts":1183713421000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"most documents consist primarily of <td>s with bgcolors, <font>s, and such like","msgtype":"m.text"},"ts":1183713480000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"I had guessed that 3 attributes is the common case. not such a bad guess","msgtype":"m.text"},"ts":1183713540000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"I readjust my guess to 5","msgtype":"m.text"},"ts":1183713600000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"amusingly, the more documents i scan, the greater the portion that is XHTML","msgtype":"m.text"},"ts":1183713601000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"in a sample of several dozen billion documents, it was about 0.2%, vs 0.02% for a sample of only a few billion (smaller sample being biased towards western pages with higher page rank)","msgtype":"m.text"},"ts":1183713660000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(0.2% is vs 97.5% for text/html)","msgtype":"m.text"},"ts":1183713720000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: testing whether the stack has \"table\" in table scope is the same as checking whether there's a \"table\" on the stack at all, right?","msgtype":"m.text"},"ts":1183714140000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Hixie: did you find anything with <! \">\" > ?","msgtype":"m.text"},"ts":1183714200000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: didn't have a chance to look into that yet","msgtype":"m.text"},"ts":1183714201000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1183714202000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: but the fact that only IE does it makes me think it's not a big deal","msgtype":"m.text"},"ts":1183714203000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"hsivonen: um","msgtype":"m.text"},"ts":1183714204000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"hsivonen: yeah, i guess so","msgtype":"m.text"},"ts":1183714260000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: ok. thanks","msgtype":"m.text"},"ts":1183714261000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"does the spec ever ask that?","msgtype":"m.text"},"ts":1183714262000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: yes","msgtype":"m.text"},"ts":1183714380000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Hixie: I sent email","msgtype":"m.text"},"ts":1183714381000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"k","msgtype":"m.text"},"ts":1183714382000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: so obviously XHTML lowers your pagerank!","msgtype":"m.text"},"ts":1183714500000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"evil google conspiracy!","msgtype":"m.text"},"ts":1183714501000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"othermaciej: lol","msgtype":"m.text"},"ts":1183714502000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i wouldn't be surprised if that was actually true","msgtype":"m.text"},"ts":1183714503000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i don't think google really supports xhtml","msgtype":"m.text"},"ts":1183714560000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"we probably treat it as text/html and get all confused or something","msgtype":"m.text"},"ts":1183714561000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"like mobiles?","msgtype":"m.text"},"ts":1183714620000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1183714621000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"yeah, probably","msgtype":"m.text"},"ts":1183714980000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: according to markp and Matt Cutts on rubys' blog, the XHTML non-support is changing","msgtype":"m.text"},"ts":1183715580000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hmm. actually, neither of them said anything about Google parsing XHTML right...","msgtype":"m.text"},"ts":1183715880000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"I wonder how much of the nominal html on the web is mobile-targeted (and therefore not really parsed as xhtml)","msgtype":"m.text"},"ts":1183716060000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"othermaciej: btw, did you debug why dom2string hit a \"Maximum call stack size exeeded\" error in webkit?","msgtype":"m.text"},"ts":1183717740000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: haven't had time so far","msgtype":"m.text"},"ts":1183717860000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"zcorpan_: can you remind me of the relevant URL?","msgtype":"m.text"},"ts":1183717861000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"I can try it now","msgtype":"m.text"},"ts":1183717862000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"othermaciej: http://simon.html5.org/temp/html5lib-tests/","msgtype":"m.text"},"ts":1183718040000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: thanks","msgtype":"m.text"},"ts":1183718280000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"does any HTML5 document meet the nesting requirements once parsed?","msgtype":"m.text"},"ts":1183718520000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: what nesting requirement?","msgtype":"m.text"},"ts":1183718580000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: things like <div>test<p>test</p></div>","msgtype":"m.text"},"ts":1183718640000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: yes.","msgtype":"m.text"},"ts":1183718641000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"like, the content model (I say remembering the name)","msgtype":"m.text"},"ts":1183718642000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: oh. no.","msgtype":"m.text"},"ts":1183718643000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"gsnedders: no","msgtype":"m.text"},"ts":1183718644000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"gsnedders: any stream of characters results in a tree. but it might not conform to the content model rules","msgtype":"m.text"},"ts":1183718700000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"I'm just thinking about how plausible it'd be to take arbitrary input and output (machine-checkable) conformant HTML5","msgtype":"m.text"},"ts":1183718760000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: you'd probably need methods similar to what John Cowan's TagSoup uses ","msgtype":"m.text"},"ts":1183718880000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"gsnedders: the HTML5 parsing algorithm itself specifically is not about doing that","msgtype":"m.text"},"ts":1183718881000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: I know. I was just wondering how much it does do in itself.","msgtype":"m.text"},"ts":1183718882000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"even things that parse without parse errors could result in a non-conforming document","msgtype":"m.text"},"ts":1183718883000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"gsnedders: it builds a tree","msgtype":"m.text"},"ts":1183718940000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"gsnedders: it makes sure that tables don't have intervening cruft and it moves stuff between head and body to head","msgtype":"m.text"},"ts":1183718941000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"My issue was really as to how close to being conforming the output of it was, and whether what it did change made those sections conforming","msgtype":"m.text"},"ts":1183718942000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"I wonder if all the machine-checkable conformance criteria are practically machine-fixable","msgtype":"m.text"},"ts":1183719000000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"othermaciej: invalid dates won't be.","msgtype":"m.text"},"ts":1183719001000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"(short of dropping them)","msgtype":"m.text"},"ts":1183719002000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"othermaciej: everything that is machine-checkable is machine-fixable to the point that the machine checker doesn't know the difference (but the result can be totally bogus)","msgtype":"m.text"},"ts":1183719060000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"<title>s in body are still moved to head too, right?","msgtype":"m.text"},"ts":1183719061000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"you could use an ultra-lenient best-guess date parser","msgtype":"m.text"},"ts":1183719062000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"case in point: filling alt attributes with junk","msgtype":"m.text"},"ts":1183719063000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"othermaciej: even that will have limitations.","msgtype":"m.text"},"ts":1183719064000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"or copying src to longdesc to please an accessibility checker","msgtype":"m.text"},"ts":1183719065000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"whether an alt attribute is junk isn't machine-checkable, really","msgtype":"m.text"},"ts":1183719120000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"othermaciej: that's my point","msgtype":"m.text"},"ts":1183719121000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"it might be than an image is a picture of the text \"asdfjkl; i hate conformance checking\"","msgtype":"m.text"},"ts":1183719122000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"and so that would be totally valid alt text","msgtype":"m.text"},"ts":1183719123000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"so anything that is non-conforming in a machine-checkable way can be replaced with stuff that is semantically junk but that is syntactically ok","msgtype":"m.text"},"ts":1183719180000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"I guess it depends on how you want to fix things","msgtype":"m.text"},"ts":1183719181000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"attribute values that would be discarded don't really matter as much as violating content models, in a way","msgtype":"m.text"},"ts":1183719240000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"because in the latter case, there might not be a conforming document that looks and acts the same (at least, without rewriting in-page scripts)","msgtype":"m.text"},"ts":1183719241000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"gsnedders: in many cases, you can \"fix\" content models by wrapping consecutive inline nodes in a single p node","msgtype":"m.text"},"ts":1183719300000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"perhaps <foo => should be a parse error (since it doesn't do what the spec says in any of ie, safari, opera, firefox)","msgtype":"m.text"},"ts":1183720800000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"what does the spec say to do?","msgtype":"m.text"},"ts":1183721100000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"create an attribute with the name = ","msgtype":"m.text"},"ts":1183721160000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"| <foo>","msgtype":"m.text"},"ts":1183721161000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"|   ==\"\"","msgtype":"m.text"},"ts":1183721162000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"opera, moz, safari drop the attribute. ie creates an attribute with the empty string as the name","msgtype":"m.text"},"ts":1183721220000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"the spec behavior is extremely weird then","msgtype":"m.text"},"ts":1183721221000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"not really weird. but doesn't match any browser and it's not a parse error","msgtype":"m.text"},"ts":1183721280000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: email time :-)","msgtype":"m.text"},"ts":1183721880000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"emailed","msgtype":"m.text"},"ts":1183721881000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: what blows the JS stack on that page is the runner/process mutual recursion","msgtype":"m.text"},"ts":1183722360000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"zcorpan_: not sure offhand why they call each other but perhaps it could be a loop instead","msgtype":"m.text"},"ts":1183722420000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"zcorpan_: at some point we will fix the stack limit, it should probably be higher than it is","msgtype":"m.text"},"ts":1183722480000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"othermaciej: ah. so it's not the dom2string that is the problem","msgtype":"m.text"},"ts":1183722481000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: well, it might have been a problem before, but those recurse deeply enough by themselves to exceed the limit","msgtype":"m.text"},"ts":1183722540000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"othermaciej: works when i rewrote it to be a loop","msgtype":"m.text"},"ts":1183723080000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: cool","msgtype":"m.text"},"ts":1183723140000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"zcorpan_: thanks for the workaround","msgtype":"m.text"},"ts":1183723141000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"commited workaround to http://html5.googlecode.com/svn/trunk/parser-tests/","msgtype":"m.text"},"ts":1183726740000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"The OCaml preprocessor makes my brain hurt","msgtype":"m.text"},"ts":1183727760000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"trying to think whether the tree building spec ask implementors do useless stuff takes time...","msgtype":"m.text"},"ts":1183727820000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Oh, nice, the camlp4 documentation has an example that does precisely what I'm trying to do, which means I don't have to understand anything and can just copy-and-paste it in","msgtype":"m.text"},"ts":1183728000000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"hmm. getElementsByClassName doesn't take a string as argument. it did before, didn't it?","msgtype":"m.text"},"ts":1183729500000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: gEBCN() has gone though various iterations including a space separated string, varargs and array of strings.","msgtype":"m.text"},"ts":1183730100000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"yeah. i thought it was either string or array. appears it is array only","msgtype":"m.text"},"ts":1183730160000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"firefox has implemented it as either string or array","msgtype":"m.text"},"ts":1183730520000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"it seems","msgtype":"m.text"},"ts":1183730521000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"which version of FF supports it?","msgtype":"m.text"},"ts":1183730580000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"3","msgtype":"m.text"},"ts":1183730640000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"or actually, it only supports array when it has 1 item","msgtype":"m.text"},"ts":1183730641000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"hopefully that can be fixed before FF3 ships","msgtype":"m.text"},"ts":1183730700000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"it uses space-separated string","msgtype":"m.text"},"ts":1183730701000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"that seems to be more practical anyway to me","msgtype":"m.text"},"ts":1183730702000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"yeah, in some ways it is, but even with an array, it's not hard to do gEBCN([\"foo\"]);","msgtype":"m.text"},"ts":1183730760000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"the array helps when you're programmatically creating a collection of class names, but the space separated string would probably be better optimised for the majority of cases","msgtype":"m.text"},"ts":1183730880000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"classList is an array right","msgtype":"m.text"},"ts":1183730940000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"or can be passed to gEBCN","msgtype":"m.text"},"ts":1183730941000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"it probably is","msgtype":"m.text"},"ts":1183730942000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"it's a DOMTokenList","msgtype":"m.text"},"ts":1183731000000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"http://www.whatwg.org/specs/web-apps/current-work/#domtokenlist0","msgtype":"m.text"},"ts":1183731001000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"does that fit the definition of \"array\" wrt what gEBCN can take as argument?","msgtype":"m.text"},"ts":1183731060000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"whether or not a DOMTokenList can be passed to gEBCN would depend on the language binding","msgtype":"m.text"},"ts":1183731061000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"for ECMAScript","msgtype":"m.text"},"ts":1183731062000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"ideally, it should be possible to pass a DOMTokenList in all languages.  I suggest you send mail about the issue","msgtype":"m.text"},"ts":1183731180000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"it can be passed, just not clear if the result will be useful","msgtype":"m.text"},"ts":1183731181000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"unless the toString conversion is defined","msgtype":"m.text"},"ts":1183731182000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"to do something good","msgtype":"m.text"},"ts":1183731183000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"which probably it should be","msgtype":"m.text"},"ts":1183731184000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"the toString should probably return a space separated list of tokens as a string.","msgtype":"m.text"},"ts":1183731240000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"but I don't think toString is relevant, given the current definition of gEBCN accepting an array","msgtype":"m.text"},"ts":1183731300000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"othermaciej: why does toString matter?","msgtype":"m.text"},"ts":1183731301000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"I thought it took a string, sorry","msgtype":"m.text"},"ts":1183731302000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"defining it to take an array is weird","msgtype":"m.text"},"ts":1183731303000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"why","msgtype":"m.text"},"ts":1183731304000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"it should at the very least accept a string also","msgtype":"m.text"},"ts":1183731305000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"it is true that you can do the varargs thing with an array and it also lets you build up a pre-made array","msgtype":"m.text"},"ts":1183731360000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"but it makes the common case more awkward","msgtype":"m.text"},"ts":1183731361000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"and it requires creating a wasteful temporary object for the common case","msgtype":"m.text"},"ts":1183731362000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1183731363000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"and you can use .apply() to pass an array of arguments to a varargs function in JS","msgtype":"m.text"},"ts":1183731420000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"perhaps the spec should be changed to only take a space separated string as argument. and defined DOMTokenList.toString to be useful","msgtype":"m.text"},"ts":1183731480000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"it could probably be defined to accept either a space separated string, varargs, array or a DOMTokenList.","msgtype":"m.text"},"ts":1183731540000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"I think that would be possible to define, using the IDL described in the latest DOM Language Bindings draft","msgtype":"m.text"},"ts":1183731600000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"Ooh, looks like each tokeniser state can only ever be entered with one (or zero) type of current token","msgtype":"m.text"},"ts":1183736940000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"which is nice because it means I can just cast the current-token pointer without any safety checks, since it's guaranteed to be the right type","msgtype":"m.text"},"ts":1183737000000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"FWIW: http://geoffers.no-ip.com/svn/php-html-5-direct — (Barely started) direct implementation of HTML 5's algorithms","msgtype":"m.text"},"ts":1183752000000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"wonders why the list of whitespace characters differs from the list used in the tokeniser","msgtype":"m.emote"},"ts":1183752180000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: where is it different? It's the same, just in a different order.","msgtype":"m.text"},"ts":1183752360000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"The tokeniser doesn't do U+000D","msgtype":"m.text"},"ts":1183752361000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"\"U+000D CARRIAGE RETURN (CR) characters, and U+000A LINE FEED (LF) characters, are treated specially. Any CR characters that are followed by LF characters must be removed, and any CR characters not followed by LF characters must be converted to LF characters. Thus, newlines in HTML DOMs are represented by LF characters, and there are never any CR characters in the input to the tokenisation stage.\"","msgtype":"m.text"},"ts":1183752362000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"(Input Stream)","msgtype":"m.text"},"ts":1183752363000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"whereas within an attribute a CR could occur through a entity","msgtype":"m.text"},"ts":1183752420000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: the entity case maps to LF as well now","msgtype":"m.text"},"ts":1183752540000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: that was actually changed? ah. I guess the other parts exist to accommodate XHTML5, then?","msgtype":"m.text"},"ts":1183752600000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"actually, XML changes CR as well","msgtype":"m.text"},"ts":1183752601000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"\"The only way to get a #xD character to match this production is to use a character reference in an entity value literal.\" — so you can get it through an entity in XML","msgtype":"m.text"},"ts":1183752660000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Does any of that conversion apply if you do document.write(\"<b\\r>\") ?","msgtype":"m.text"},"ts":1183752720000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: it goes through the input stream, so yes","msgtype":"m.text"},"ts":1183752721000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Ah, okay","msgtype":"m.text"},"ts":1183752840000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"gsnedders: CR is now in the same table as the Windows-1252 NCRS","msgtype":"m.text"},"ts":1183753380000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"NCRs","msgtype":"m.text"},"ts":1183753381000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"gsnedders: if you put an NCR for CR in XML, you get a CR in the infoset/DOM","msgtype":"m.text"},"ts":1183753382000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: ah. I didn't notice it when I implemented that separately a few days ago (though I did just copy/paste the table and create code automagically). that's what I thought about XML, though.","msgtype":"m.text"},"ts":1183753440000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"trying to remember what specs say when so tired probably isn't sensible :)","msgtype":"m.text"},"ts":1183753441000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"notes that the fragment case does bad things to control flow","msgtype":"m.emote"},"ts":1183753500000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"wishes he could find a nice way to output C code from OCaml without just sticking lots of strings together, and without using 25K-line libraries with far too many dependencies","msgtype":"m.emote"},"ts":1183756860000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"wonders what would be the easiest way to prove the tokeniser terminates (assuming the character stream is finite)","msgtype":"m.emote"},"ts":1183758120000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(I don't doubt that it does, but I like having a computer agree with me...)","msgtype":"m.text"},"ts":1183758121000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"oh you are actually proving stuff :-)","msgtype":"m.text"},"ts":1183758180000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"I just trust the html5lib tests :-)","msgtype":"m.text"},"ts":1183758181000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"what is a conforming test case? don't we need conformance requirements for test cases?","msgtype":"m.text"},"ts":1183758360000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"Can you show the input position is steadily increasing?","msgtype":"m.text"},"ts":1183758361000,"senderName":"Dashiva","senderId":"Dashiva@irc"},
{"content":{"body":"Since I've got the tokeniser in this format, I thought I might as well try proving various forms of correctness, to make sure I don't forget all the logic stuff I learnt at university :-)","msgtype":"m.text"},"ts":1183758362000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Dashiva: No, since it doesn't always steadily increase - some states don't always consume a character","msgtype":"m.text"},"ts":1183758420000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"But then you could take those states and how they're always part of a series of states increasing it","msgtype":"m.text"},"ts":1183758421000,"senderName":"Dashiva","senderId":"Dashiva@irc"},
{"content":{"body":"I think that'd probably work - I don't know if it can be done automatically, but I guess it shouldn't be hard to manually define a (partial) ordering of states and check that (input_position, state) is always increasing","msgtype":"m.text"},"ts":1183758540000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: do you use a read()/unread() model?","msgtype":"m.text"},"ts":1183758660000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Philip`: can you prove that there are never two consecutive unreads without a read in between?","msgtype":"m.text"},"ts":1183758661000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"that would at least prove it isn't going backwards","msgtype":"m.text"},"ts":1183758720000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Is \"unread\" where the spec says \"reconsume the character in the something state\"?","msgtype":"m.text"},"ts":1183758780000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"I've made quite a few optimization by just looking hard at the tree building algorithm without proving anything...","msgtype":"m.text"},"ts":1183758781000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Philip`: yes","msgtype":"m.text"},"ts":1183758782000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Philip`: I call unread() before such transitions","msgtype":"m.text"},"ts":1183758783000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: Okay - I've done about the same, with UnconsumeCharacter/ConsumeCharacter","msgtype":"m.text"},"ts":1183758900000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: btw, what's you character datatype? an UTF-8 code unit? UTF-16 code unit? UTF-32 code unit?","msgtype":"m.text"},"ts":1183758960000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"(I've tried to do as literal a translation of the spec text as possible, but 'unconsume' maps onto the state->state [where 'state' means the whole tokeniser state, not just the explicit ones in the spec] transition model much better than 'reconsume in some other state')","msgtype":"m.text"},"ts":1183759020000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"The C++ implementation just uses a wchar_t, which is 2 or 4 bytes, but it ought to be relatively easy to change that to something better if I had any idea of what would work well","msgtype":"m.text"},"ts":1183759080000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"I'd like to be able to just start with the original correct algorithm, and then have code that optimises it into a less naive structure, and then output that (as C++ or whatever else you want), though currently I've got none of the optimisation bit :-)","msgtype":"m.text"},"ts":1183759260000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(...and then if the spec changes, it'd all work nicely and easily since the optimisation things would just apply themselves to a different algorithm and produce a new correct tokeniser)","msgtype":"m.text"},"ts":1183759440000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"(I expect this is all far more complex than necessary, but it's fun anyway)","msgtype":"m.text"},"ts":1183759441000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"hsivonen: i haven't checked, but re </table>, what about:   <table><td><ol><li></table> ?","msgtype":"m.text"},"ts":1183761900000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"vs <table><td><p></table>","msgtype":"m.text"},"ts":1183761901000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"and ignoring the missing <tr>s, oops","msgtype":"m.text"},"ts":1183761902000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: well, yeah. I guess we want the errors there after all. my point was that <ol> gets one error anyway when it goes on the stack","msgtype":"m.text"},"ts":1183762020000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: not in that case, you're in a cell there","msgtype":"m.text"},"ts":1183763040000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: ooh. good point.","msgtype":"m.text"},"ts":1183763760000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Hixie: except then you aren't IN_TABLE","msgtype":"m.text"},"ts":1183763761000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"well, I implemented the spec now","msgtype":"m.text"},"ts":1183763880000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"doesn't in-cell defer to in-table in that case?","msgtype":"m.text"},"ts":1183764000000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"no. it closes the cell first","msgtype":"m.text"},"ts":1183764060000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1183764240000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"hm","msgtype":"m.text"},"ts":1183764241000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"well i'll look at it in detail at some point","msgtype":"m.text"},"ts":1183764242000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":":-)","msgtype":"m.text"},"ts":1183764243000,"senderName":"Hixie","senderId":"Hixie@irc"}
]