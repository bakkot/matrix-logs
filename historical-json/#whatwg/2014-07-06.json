[
{"content":{"body":"SimonSapin: as far as In other words, it should be possible to catch this case just using a conforming tokenizer, without needing a parser.","msgtype":"m.text"},"ts":1404610233000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"oops","msgtype":"m.text"},"ts":1404610238000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"copy pasta","msgtype":"m.text"},"ts":1404610245000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"SimonSapin: meant to say, as far as \"User agents are encouraged to expose parse errors somehow.\", Firefox's View Source also uses that","msgtype":"m.text"},"ts":1404610299000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: for URL parse errors?","msgtype":"m.text"},"ts":1404610324000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: no, in the case of the similar parse-error stuff in the HTML parsing algorithm","msgtype":"m.text"},"ts":1404610335000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"SimonSapin: for URL parse errors, galimatias (a general-purpose URL parsing library) at least does expose the parse errors","msgtype":"m.text"},"ts":1404610394000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"SimonSapin: there might be non-browser cases other than validators where people would like to have access parse errors, but I don't know of specific ones","msgtype":"m.text"},"ts":1404610500000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"ok, apparently you can give galimatias a custom error handler that will receive errors and can do whatever","msgtype":"m.text"},"ts":1404610714000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"a closure (callback) should do","msgtype":"m.text"},"ts":1404610737000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: what you need this for?","msgtype":"m.text"},"ts":1404610785000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: Iâ€™m implementing http://url.spec.whatwg.org/ in Rust","msgtype":"m.text"},"ts":1404610807000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"trying to figure out what to do with non-fatal parse errors","msgtype":"m.text"},"ts":1404610823000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: ah ok","msgtype":"m.text"},"ts":1404610936000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"SimonSapin: well at the very least having an error-reporting URL parser in Rust would mean somebody could eventually use that parser as part of a validator written in Rust, which is worth something","msgtype":"m.text"},"ts":1404611039000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"mathiasbynens: is http://dev.opera.com/articles/showmodaldialog/ still up to date? was the removal delayed another version maybe? (also the demo's popup says 404)","msgtype":"m.text"},"ts":1404642853000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"Ms2ger: I see you heard back from the W3C systeam by now but yeah there was scheduled network outage at MIT that made IRC and everything else inaccessible for a while","msgtype":"m.text"},"ts":1404651156000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Yep, thanks :)","msgtype":"m.text"},"ts":1404651180000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"I return, yet again lamenting the lack of some sort of GC callback in JS :(","msgtype":"m.text"},"ts":1404689926000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"daurnimator: for what?","msgtype":"m.text"},"ts":1404690002000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: interop/other languages running on top of JS","msgtype":"m.text"},"ts":1404690029000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"trying to know when js is done with some object/callback/etc","msgtype":"m.text"},"ts":1404690043000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"frankly, having a standard way to run specific code when an object is finalized is very useful, and we are all poorer for not having it","msgtype":"m.text"},"ts":1404690076000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I'm now sitting here contemplating writing a js parser to analyse functions to decorate them as leaky or not","msgtype":"m.text"},"ts":1404690078000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"we could use it for useful things, like putting the object in a list of dead objects!","msgtype":"m.text"},"ts":1404690153000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: or to force all browsers to have the same GC model and kill all innovation in that space!","msgtype":"m.text"},"ts":1404690195000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"SamB: e.g. I want to run lua in the browser:  x=js.new(window.XHR);x:open(\"GET\", \"google.com\", true); function x:onreadystatechange() print(\"I get leaked\") end; x:send();","msgtype":"m.text"},"ts":1404690205000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"Hixie: having an 'oncollected' callback does not dictate the GC model","msgtype":"m.text"},"ts":1404690234000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"SamB: like closing file handles, for instance","msgtype":"m.text"},"ts":1404690237000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: I know what such things are used for in the real world, yes","msgtype":"m.text"},"ts":1404690260000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"just checking =]","msgtype":"m.text"},"ts":1404690274000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"but here on the web, our file handles aren't even open in the first place ;-)","msgtype":"m.text"},"ts":1404690277000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"daurnimator: actually it does, because people will end up depending on in what order things get GCed","msgtype":"m.text"},"ts":1404690278000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"javascript doesn't strictly live on the web though","msgtype":"m.text"},"ts":1404690288000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Hixie: why? they don't in other languages","msgtype":"m.text"},"ts":1404690289000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"all kinds of things use v8, from databases to web servers","msgtype":"m.text"},"ts":1404690310000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"rhino too","msgtype":"m.text"},"ts":1404690314000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"daurnimator: outside of the web, the people who screw stuff up in the first place get most of the complaints","msgtype":"m.text"},"ts":1404690357000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"not the ones who changed what was meant as an implementation detail","msgtype":"m.text"},"ts":1404690384000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"or, well, outside of networking really","msgtype":"m.text"},"ts":1404690403000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"now *I* would think this was easily solved by having an unintelligable order in the first place, but evidently it isn't so","msgtype":"m.text"},"ts":1404690442000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"daurnimator: the web is an oddly unusual case in that there's orders of magnitude more code, the code isn't maintained but is still compiled by newer compilers every time they come out, and the users are HIGHLY sensitive to breakage and change compilers on a whim so there's a lot of pressure to not break things","msgtype":"m.text"},"ts":1404690544000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"that sounds like a documentation issue, but to prevent people relying on *BROWSER'S* behaviour, just add (excuse the psuedo code): function gc_sweep() shuffle(this.marked_objects); this.marked_objects.forEach(function(o) if o.oncollect then o:oncollect() end free(o) end);","msgtype":"m.text"},"ts":1404690599000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"that is, if you're scared of people relying on order. randomise order","msgtype":"m.text"},"ts":1404690631000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"that still exposes order","msgtype":"m.text"},"ts":1404690673000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it's not just per-cycle order that matters","msgtype":"m.text"},"ts":1404690692000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it's also which cycle","msgtype":"m.text"},"ts":1404690698000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"should make it unreliable enough that people don't rely on it?","msgtype":"m.text"},"ts":1404690700000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"not if the list is one item long each time","msgtype":"m.text"},"ts":1404690711000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: true.","msgtype":"m.text"},"ts":1404690721000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"the problem is some browsers want to optimise for memory pressure, so they'll GC aggressively, and others want to optimise for speed, so they'll aggressively wait for idle cycles to do incremental GC","msgtype":"m.text"},"ts":1404690740000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"and these two have _radically_ different behaviours","msgtype":"m.text"},"ts":1404690748000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"behaviours that can't just be papered over","msgtype":"m.text"},"ts":1404690753000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"anyway, I'd really like to see some sort of oncollect callback. even if it's only on ES6 proxies for e.g.","msgtype":"m.text"},"ts":1404690764000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"i wouldn't hold your breath :-)","msgtype":"m.text"},"ts":1404690823000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"goes back to theorising a JS parser in JS and then writing a GC on top of JS","msgtype":"m.emote"},"ts":1404690861000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"anyway, it turns out that releasing things like file handles only when something is GC'd naturally can have bad results sometimes ...","msgtype":"m.text"},"ts":1404690868000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: yep. 'sometimes'. in the (rare) cases it's not, you still have ob:close()","msgtype":"m.text"},"ts":1404690891000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"a GC on top of JS? lol","msgtype":"m.text"},"ts":1404690894000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: somefunc.toString() ==> parse ==> what happens to arg#2? ==> does it get assigned somewhere? ==> add it to 'leaked' list","msgtype":"m.text"},"ts":1404690949000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"SamB there's a distinction between \"finalized\" and \"collected\"","msgtype":"m.text"},"ts":1404690952000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I think what he's really talking about is finalization","msgtype":"m.text"},"ts":1404690958000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"once there are no live references to an object, he'd probably want to close those file handles","msgtype":"m.text"},"ts":1404690984000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"so, maybe the real solution is to run finalizers after a random delay regardless","msgtype":"m.text"},"ts":1404690986000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"I'd also be happy with that solution","msgtype":"m.text"},"ts":1404690999000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"I just don't want to keep leaking via callbacks (e.g. setTimeout, xhr.onreadystatechange, etc)","msgtype":"m.text"},"ts":1404691032000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"makes writing long running web apps impossible","msgtype":"m.text"},"ts":1404691051000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"why would you leak via callbacks?","msgtype":"m.text"},"ts":1404691059000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: 23:43:25 < daurnimator> SamB: e.g. I want to run lua in the browser:  x=js.new(window.XHR);x:open(\"GET\", \"google.com\", true); function x:onreadystatechange() print(\"I get leaked\") end; x:send();","msgtype":"m.text"},"ts":1404691079000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"the lua function gets a proxy constructed in JS","msgtype":"m.text"},"ts":1404691107000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"now it gets interesting :>","msgtype":"m.text"},"ts":1404691107000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"which is set as the onreadystatechange callback","msgtype":"m.text"},"ts":1404691117000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"ok well step one, don't run lua...","msgtype":"m.text"},"ts":1404691119000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"what browser is this?","msgtype":"m.text"},"ts":1404691132000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"this is applicable to running anything on top of JS","msgtype":"m.text"},"ts":1404691134000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"SamB: all of them","msgtype":"m.text"},"ts":1404691136000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"most of my browsers don't offer to run lua","msgtype":"m.text"},"ts":1404691147000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: https://daurnimator.github.io/lua.vm.js/repl.html","msgtype":"m.text"},"ts":1404691151000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"why would you run a language on top of JS","msgtype":"m.text"},"ts":1404691152000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i expect you could probably build the lua runtime with emscripten, heh","msgtype":"m.text"},"ts":1404691163000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"guessing it's something like that","msgtype":"m.text"},"ts":1404691168000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: that one there is","msgtype":"m.text"},"ts":1404691172000,"senderName":"daurnimator","senderId":"daurnimator@irc"},
{"content":{"body":"ah, right, crazy","msgtype":"m.text"},"ts":1404691174000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: it works except for the fact it leaks proxys >.<","msgtype":"m.text"},"ts":1404691194000,"senderName":"daurnimator","senderId":"daurnimator@irc"}
]