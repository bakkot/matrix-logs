[
{"content":{"body":"One-off test name changes are usually OK for gecko","msgtype":"m.text"},"ts":1614764556000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"hi annevk.  started integration of fetch/resource-timing as we discussed, please take a look at https://github.com/whatwg/fetch/pull/1185 when you get a chance.","msgtype":"m.text"},"ts":1614766335000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: it still had a bunch of TODOs in it?","msgtype":"m.text"},"ts":1614766388000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: one thing I'm not sure about is that it patches the body read operations, wouldn't it make more sense to set the timing as stuff is being put into the stream by the network? Like how would this work when you want to read a request body?","msgtype":"m.text"},"ts":1614766495000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: regarding TODOs - yes it does. but I wanted to see that the main direction of how to do this is aligned. I want to work on this incrementally rather than a big patch with everything","msgtype":"m.text"},"ts":1614766544000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: regarding the body - it shouldn't work for request bodies. Would it make more sense to integrate it into 'streams' instead?","msgtype":"m.text"},"ts":1614766597000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: I think it would make more sense to integrate it where we create the response body stream and enqueue bytes into it","msgtype":"m.text"},"ts":1614766647000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: and don't couple it with the body or streams at all","msgtype":"m.text"},"ts":1614766666000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ok makes sense, let me see what that means in practice","msgtype":"m.text"},"ts":1614766683000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: but that's at a high level as I still need to actually read resource timing in detail","msgtype":"m.text"},"ts":1614766688000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: sure... I'm wondering what to do with the timing that requires intimate knowledge of HTTP/TLS/DNS. Fetch doesn't go that deep... I can either put a general note about it in \"obtain a connection\" but trying to make it accurate would mean going pretty deep into them","msgtype":"m.text"},"ts":1614766809000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: I guess you would describe it in prose somehow when the timing are to be obtained","msgtype":"m.text"},"ts":1614766883000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: will do","msgtype":"m.text"},"ts":1614766897000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: note that obtain a connection will soon have callers outside of Fetch as well","msgtype":"m.text"},"ts":1614766900000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think that's fine, timingInfo will be null and obtain a connection will noop it.","msgtype":"m.text"},"ts":1614766939000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: it might be nicer to store the timing information directly on the connection so they can use it if needed","msgtype":"m.text"},"ts":1614766969000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: interesting, I have to check if that's what resource-timing would expect","msgtype":"m.text"},"ts":1614767023000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: well, in case of fetch it could take it from the connection and forward it","msgtype":"m.text"},"ts":1614767045000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: I guess there are some interesting cases with H/2 and H/3 where connections are reused and this would make that very observable","msgtype":"m.text"},"ts":1614767067000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yes, it's unclear in resource-timing how connection pools are handled. yoav WDYT?","msgtype":"m.text"},"ts":1614767138000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"(that's what I mean by \"what resource timing would expect\"","msgtype":"m.text"},"ts":1614767160000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"goes to look at resource timing","msgtype":"m.emote"},"ts":1614767176000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ah, \"Implementers SHOULD be aware that this document is not stable. Implementers who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways.\" looks like we can do whatever we want :p","msgtype":"m.text"},"ts":1614767213000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"\"Resources for which the fetch was initiated, but was later aborted (e.g. due to a network error) MAY be included as PerformanceResourceTiming objects in the Performance Timeline\" might be tough","msgtype":"m.text"},"ts":1614767370000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"there are a lot of places where we simply return a (new) network error","msgtype":"m.text"},"ts":1614767402000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"and determining when it's safe to expose information on them is just...","msgtype":"m.text"},"ts":1614767414000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"regarding the \"MAY be included\", we should get rid of the MAY parts and enforce exposing that info","msgtype":"m.text"},"ts":1614768269000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"assuming we consider it safe","msgtype":"m.text"},"ts":1614768300000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Also need to clarify that error status code responses don't fall into that bucket","msgtype":"m.text"},"ts":1614768324000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"\"there are a lot of places where we simply return a (new) network error\" - hmm, might be worthwhile to test what implementations are currently doing on that front","msgtype":"m.text"},"ts":1614768386000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Regarding connection pools, RT currently exposes connection reuse","msgtype":"m.text"},"ts":1614768451000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"https://www.w3.org/TR/resource-timing-2/#dom-performanceresourcetiming-connectstart","msgtype":"m.text"},"ts":1614768565000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"this is what the current work is about... defining the points in time where metrics are marked as precisely as possible, like we did before with paint timing.","msgtype":"m.text"},"ts":1614768742000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"I understand and I think it's great that we're doing this 🙂","msgtype":"m.text"},"ts":1614768887000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: aah I see, so I guess we'd return fetchStart if connectStart < fetchStart","msgtype":"m.text"},"ts":1614768987000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: that way we don't have to tell resource timing what kind of connection it is","msgtype":"m.text"},"ts":1614769006000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah, SG","msgtype":"m.text"},"ts":1614769043000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"I guess ideally we also put the security checks directly into Fetch so ResourceTiming can just return the integers Fetch hands out","msgtype":"m.text"},"ts":1614769085000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"👍","msgtype":"m.text"},"ts":1614769110000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"I guess modulo adjusting to the global and jitter stuff","msgtype":"m.text"},"ts":1614769122000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(was just about to comment the same)","msgtype":"m.text"},"ts":1614769149000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1614769153000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"for connection pools though - do we want to obfuscate it or should resource-timing know about it? it's exposed only for same-origin or for origins with TAO","msgtype":"m.text"},"ts":1614769197000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"encodedBodySize is just Content-Length, right? https://github.com/whatwg/fetch/pull/1183 should help with that","msgtype":"m.text"},"ts":1614769231000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: my thinking is that we store the timings on the connection and then fetch takes the timings from the connection and puts them on the struct, adjusting them based on fetchStart as needed","msgtype":"m.text"},"ts":1614769308000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I wonder if we should make <noscript> always parse as if scripting flag is enabled","msgtype":"m.text"},"ts":1614769346000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"annevk: yes, got it.","msgtype":"m.text"},"ts":1614769356000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: and once TAO happens we might have to set a bunch of things to 0","msgtype":"m.text"},"ts":1614769368000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1614769384000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"Fetch gets all the timings, and in the shim between fetch and TAO there will be an algorithm that cleans them up","msgtype":"m.text"},"ts":1614769416000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"zcorpan: you want to test XHR and sandboxed iframes at least","msgtype":"m.text"},"ts":1614769445000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(XHR may already ask for that?)","msgtype":"m.text"},"ts":1614769457000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Is there existing spec text in any CSS specs that defines what to do with the response from a fetch request for a font?","msgtype":"m.text"},"ts":1614769457000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"it's been such a long time that I forgot","msgtype":"m.text"},"ts":1614769477000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: yeah, though to be clear I think fetch should be setting things to 0 based on TAO","msgtype":"m.text"},"ts":1614769519000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(wasn't entirely sure if by cleaning up you meant the jittering/global stuff or also that)","msgtype":"m.text"},"ts":1614769559000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: there's a font spec but as I understand it it's light on details and true type / open type are a mess?","msgtype":"m.text"},"ts":1614769599000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: my point is it's repeatedly used as HTML sanitization bypasses because different places set the scripting enabled flag differently. if we kill the <noscript> functionality and it always parses as text, we kill those attacks (and hopefully don't introduce new ones)","msgtype":"m.text"},"ts":1614769677000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"annevk: also browsers aren't interoperable with when the flag is set (e.g. template.innerHTML)","msgtype":"m.text"},"ts":1614769724000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: yeah I'm not opposed, but XHR / <iframe sandbox> might be places where content relies on this","msgtype":"m.text"},"ts":1614769748000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yes, good point","msgtype":"m.text"},"ts":1614769790000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: I think I'm even in favor as you're right that these mode switches are a pain (it's also a worry I have with decl shadow trees)","msgtype":"m.text"},"ts":1614769808000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"RT decodedBodySize is interesting, we have just enough enough infrastructure to define it I think, but it's also horribly broken","msgtype":"m.text"},"ts":1614770027000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: OK. I’m just looking back at that section of the Fonts spec I patched, and trying to figure out what precisely it should say to do with the <var>response</var> it gets back from the fetch","msgtype":"m.text"},"ts":1614770141000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"yoav: how is secureConnectionStart different? is it just connectStart but 0 for insecure connections?","msgtype":"m.text"},"ts":1614770180000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I find https://drafts.csswg.org/css-font-loading/#font-face-css-connection so I guess I need to hook into that ... somehow","msgtype":"m.text"},"ts":1614770343000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"> A CSS @font-face rule automatically defines a corresponding FontFace object, which is automatically placed in the document’s font source when the rule is parsed. This FontFace object is CSS-connected.","msgtype":"m.text"},"ts":1614770354000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"> The internal [[Urls]] slot of the FontFace object is set to the value of the @font-face rule’s src descriptor, and reflects any changes made to the src descriptor.","msgtype":"m.text"},"ts":1614770381000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"in a spec that’s supposed to be normatively defining UA requirements, the multiple “automatically” words are a bit surprising","msgtype":"m.text"},"ts":1614770685000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"very much wishing I had not pulled at this thread","msgtype":"m.text"},"ts":1614770711000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"anyway I guess I’ll make an attempt at re-updating the @font-face loading requirements in the Fonts spec","msgtype":"m.text"},"ts":1614770921000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"annevk: the prose suggests it's not, but the diagram says your interpretation is correct","msgtype":"m.text"},"ts":1614771608000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"and I'm failing to find a local case where they don't all equal fetchStart","msgtype":"m.text"},"ts":1614771633000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"so here as well, would be good to add tests to see what implementations are actually doing","msgtype":"m.text"},"ts":1614771654000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"I suspect that predictive preconnection mean that these values are typically just fetchStart","msgtype":"m.text"},"ts":1614771703000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"annevk: hmmm, I think the \"scripting flag\" and innerHTML logic in the spec is currently broken. The fragment parsing algo always creates a new Document for parsing the fragment, and that Document has no browsing context, so its \"scripting flag\" is always disabled for innerHTML","msgtype":"m.text"},"ts":1614772545000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"whereas I think the intent was for innerHTML to always parse with \"scripting flag\" enabled*","msgtype":"m.text"},"ts":1614772646000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"(* was a typo)","msgtype":"m.text"},"ts":1614772679000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"yoav: aaah makes sense","msgtype":"m.text"},"ts":1614773119000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zcorpan: could be I filed an issue against DOM parsing for this","msgtype":"m.text"},"ts":1614773178000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: yeah tests would be really good","msgtype":"m.text"},"ts":1614773222000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: you could also file some follow-up issues","msgtype":"m.text"},"ts":1614773271000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: prolly easier to address by someone tackling this for CSS in general","msgtype":"m.text"},"ts":1614773296000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zcorpan: not read all the way up, but fragment parsing should work with scripting disabled, e.g. for cases where content expects to be parsed as a fragment regardless of whether scripting is enabled (e.g., if you're an Atom/RSS feed reader, you might want to render each item's content as a div fragment)","msgtype":"m.text"},"ts":1614776736000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: sure, but that could still parse <noscript> as text instead of as elements","msgtype":"m.text"},"ts":1614777850000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"annevk: how would you suggest associating the connection timing info with a connection? fetch doesn't specify what a 'connection' is. I can either say that a connection info is \"associated\" with a connection, or create a new struct that has the timing-info,  ALPN protocol and actual connection and have 'obtain a connection' return that struct","msgtype":"m.text"},"ts":1614778017000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: yeah, turning https://fetch.spec.whatwg.org/#concept-connection into a struct seems good","msgtype":"m.text"},"ts":1614778288000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: or maybe a thing with associated things, hmm","msgtype":"m.text"},"ts":1614778362000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: but a lot of the usage of `connection` is vague: e.g. \"the <a>connection</a> uses HTTP/2\"","msgtype":"m.text"},"ts":1614778364000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: let's just say that connection has associated fields then, similar to request/response","msgtype":"m.text"},"ts":1614778388000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: alrighty. and if I want to send the same connection, but with something else associated with it, what's the right way do describe that?","msgtype":"m.text"},"ts":1614778432000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"e.g. if a connection comes from a pool, I want to return the connection but without its associated connection info","msgtype":"m.text"},"ts":1614778457000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"I thought to have a struct that includes that opaque connection + connection info, and return that struct from 'obtain a connection', later working with the struct's 'actual connection' (or something to that effect)","msgtype":"m.text"},"ts":1614778547000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: or return a \"return connection with its timing info associated to null\"","msgtype":"m.text"},"ts":1614778846000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: when would it return null for that?","msgtype":"m.text"},"ts":1614778969000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: I would basically expect these fields to be set when a connection is created, if they sometimes have to be null, that could happen there","msgtype":"m.text"},"ts":1614779018000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it's not that. I need to differentiate between connections from pool and newly created connections. Only newly created connections should have the connection timing info","msgtype":"m.text"},"ts":1614779044000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: you don't have to do that per the above discussion","msgtype":"m.text"},"ts":1614779058000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: we can deal with that in the fetch algorithm","msgtype":"m.text"},"ts":1614779076000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ah, maybe I missed part of the discussion. Re-reading","msgtype":"m.text"},"ts":1614779087000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: when fetch gets a connection and its connection.start < fetch.start, fetch.connectStart = fetch.start or some such","msgtype":"m.text"},"ts":1614779120000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ok, clamp it by value. easy enough. was thinking that there might be a corner case where this is not enough, but maybe it's not the case or not an interesting use-case","msgtype":"m.text"},"ts":1614779228000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: I'm always interested in corner cases, but I think this covers what RT is trying to do","msgtype":"m.text"},"ts":1614779329000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yes I think so too","msgtype":"m.text"},"ts":1614779347000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"Domenic: never thought I’d see the day where XHR is used as a pattern to follow 😀","msgtype":"m.text"},"ts":1614795956000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: so maybe we should have a TimoutSignal","msgtype":"m.text"},"ts":1614796004000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Maybe... feels a bit heavyweight, but perhaps fine.","msgtype":"m.text"},"ts":1614796025000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"We'd want APIs that accept `signal` to accept it too, I think?","msgtype":"m.text"},"ts":1614796049000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: yeah, I think we don’t want separate timout inputs everywhere","msgtype":"m.text"},"ts":1614796080000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"That’s what I liked about your proposal","msgtype":"m.text"},"ts":1614796095000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Or we could have some mode of AbortSignal that lets you customize the error thrown... although the AbortSignal -> error thrown channel is indirect (until/unless https://github.com/whatwg/dom/issues/927 happens).","msgtype":"m.text"},"ts":1614796160000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: thanks for pushing on this a bit, I probably would have given up without you prodding...","msgtype":"m.text"},"ts":1614796177000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"👍🏻","msgtype":"m.text"},"ts":1614796222000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It was hard to let go as it would resolve some rather long-standing and hugely popular issues in Fetch","msgtype":"m.text"},"ts":1614796559000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I have a probably silly question as I am trying to understand something the html spec says currently... If you call the have an onclick on an input, which in turn calls focus() - when the focusing steps are evaluated, is a focus trigger of click set or no?","msgtype":"m.text"},"ts":1614810550000,"senderName":"bkardell","senderId":"bkardell@irc"},
{"content":{"body":"bkardell: from what I can see the focus trigger is only \"click\": \"When a user activates a click focusable focusable area\"","msgtype":"m.text"},"ts":1614810715000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"this is how I read it, that the answer is \"no\", right?","msgtype":"m.text"},"ts":1614810819000,"senderName":"bkardell","senderId":"bkardell@irc"},
{"content":{"body":"I just dont want to get it wrong :)","msgtype":"m.text"},"ts":1614810829000,"senderName":"bkardell","senderId":"bkardell@irc"},
{"content":{"body":"Indeed, if there's no user involved, then the answer is no.","msgtype":"m.text"},"ts":1614810843000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"excellent - thank you for clarifying Domenic","msgtype":"m.text"},"ts":1614810854000,"senderName":"bkardell","senderId":"bkardell@irc"}
]