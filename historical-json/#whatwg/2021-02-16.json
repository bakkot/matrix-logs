[
{"content":{"body":"EveryOS: note the \"Assert: parent is a slot.\" a couple steps earlier","msgtype":"m.text"},"ts":1613435221000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So we only get to that step if parent is a slot, and all slots do indeed have roots.","msgtype":"m.text"},"ts":1613435239000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Oh, thanks. I didn't realize that.","msgtype":"m.text"},"ts":1613435799000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"Folks in this channel may enjoy: https://github.com/domenic/specgo","msgtype":"m.text"},"ts":1613450523000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: how do you get single-page HTML?","msgtype":"m.text"},"ts":1613458241000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: the diagrams in that video are great too, if we can have those in the spec...","msgtype":"m.text"},"ts":1613483162000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(it also seems more than 3 people might have watched it)","msgtype":"m.text"},"ts":1613483174000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah I should be able to put something like that in the spec, the slides are HTML","msgtype":"m.text"},"ts":1613483239000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yeah it got more interest than I thought!","msgtype":"m.text"},"ts":1613483249000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I guess with something like https://github.com/whatwg/url/issues/559#issuecomment-763938749 we couldn't have the WPT test change automatically exported, given there's no associated spec change, and at least in some sense it's just experimental to see if it sticks? slightly annoying having tests that fail in WebKit :)","msgtype":"m.text"},"ts":1613485305000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: seems like a good use case for .tentative, but I guess you'd need to create a separate test file and data file.","msgtype":"m.text"},"ts":1613485863000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Or we can just try to get consensus on the change; for a reparse bug that should be pretty quick","msgtype":"m.text"},"ts":1613485895000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah, I suspect if you pinged valenting he'd support banning | in hosts","msgtype":"m.text"},"ts":1613486144000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: this read body incrementally is also what we should use for uploads I think","msgtype":"m.text"},"ts":1613492319000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: instead of the current setup","msgtype":"m.text"},"ts":1613492333000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: and I agree that impl are not teeing for integrity, but I'm not sure how to make the spec work","msgtype":"m.text"},"ts":1613492369000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well I think it's pretty easy for the non-fetch() case","msgtype":"m.text"},"ts":1613492388000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Just have a wrapper algorithm that checks the integrity and calls caller-supplied processBody if it passes, or caller-supplied processBodyError if it doesn't","msgtype":"m.text"},"ts":1613492411000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"For fetch() I'm less sure","msgtype":"m.text"},"ts":1613492421000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: but that means we'd have to duplicate the security check all over?","msgtype":"m.text"},"ts":1613492450000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"No the wrapper lives in fetch","msgtype":"m.text"},"ts":1613492462000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"In particular the read body algorithm you're proposing","msgtype":"m.text"},"ts":1613492492000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: it seems bad for the network to return a response to the caller if there's an integrity mismatch","msgtype":"m.text"},"ts":1613492521000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hmm I see","msgtype":"m.text"},"ts":1613492527000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I suspect we should do it anyway if that's what implementations do but I want stronger confirmation that's what implementations do then...","msgtype":"m.text"},"ts":1613492561000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And that'd require a lot of specs to update to have processBodyError, which don't today","msgtype":"m.text"},"ts":1613492575000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I'm pretty sure that implementations treat it equivalent to a network error today","msgtype":"m.text"},"ts":1613492616000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Sure but how do they implement it","msgtype":"m.text"},"ts":1613492624000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think what you are suggesting ends up extremely inelegant, which might be what implementations are doing today, but I wouldn't want to commit the spec to such a design","msgtype":"m.text"},"ts":1613492707000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: unless you can show it's observable of course","msgtype":"m.text"},"ts":1613492715000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think it's more elegant than teeing the stream, personally.","msgtype":"m.text"},"ts":1613492751000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I asked on networking team chat what they do but they're probably all asleep in Tokyo","msgtype":"m.text"},"ts":1613492807000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: well we could also pass the bytes to some callback, e.g., processEndOfBody (if you supply that callback you cannot read body yourself maybe?)","msgtype":"m.text"},"ts":1613492809000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"How does that solve the problem? Who checks integrity then?","msgtype":"m.text"},"ts":1613492839000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"and maybe if you supply integrity you can only use that callback as you don't get anything before that anyway","msgtype":"m.text"},"ts":1613492844000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Fetch does, on the bytes, before passing the bytes on","msgtype":"m.text"},"ts":1613492853000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ah hmm","msgtype":"m.text"},"ts":1613492856000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"OK this sounds like what I was proposing, what is the difference...","msgtype":"m.text"},"ts":1613492866000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Ah you're using a fetch callback instead of a read body algorithm","msgtype":"m.text"},"ts":1613492878000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think what you were proposing was some operation on body","msgtype":"m.text"},"ts":1613492880000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1613492885000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Why does that help?","msgtype":"m.text"},"ts":1613492898000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Oh you're not allowed to use processResponse if you use processEndOfBody?","msgtype":"m.text"},"ts":1613492919000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yeah, that's what I'm thinking now, making them mutually exclusive","msgtype":"m.text"},"ts":1613492939000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"it doesn't fire any quicker with integrity anyway","msgtype":"m.text"},"ts":1613492949000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I guess that's equivalent to (but more elegant than) allowing both processResponse plus processEndOfBody but disallowing access to body.","msgtype":"m.text"},"ts":1613492971000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So processEndOfBody would get (response, byte sequence-or-null) I guess. Because callers still need to do network error checks, OK status checks, etc.","msgtype":"m.text"},"ts":1613492996000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think that's also still okay, but if you supply integrity processResponse makes no sense as it would fire at the same time as the latter","msgtype":"m.text"},"ts":1613492998000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1613493018000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"This seems good","msgtype":"m.text"},"ts":1613493029000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I still don't know how fetch() works with integrity but that's probably just me","msgtype":"m.text"},"ts":1613493050000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I don't think it's just you, did we consider it with response streams? Seems like something to test...","msgtype":"m.text"},"ts":1613493120000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: I think you really need a tee or a buffering proxy for that (which I guess is what processResponseEndOfBody is in a way)","msgtype":"m.text"},"ts":1613493174000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah. I suspect implementations do buffering","msgtype":"m.text"},"ts":1613493212000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And once done pass along a giant chunk?","msgtype":"m.text"},"ts":1613493357000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"_that_ varies, I bet","msgtype":"m.text"},"ts":1613493409000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But yeah probably within one tick all the bytes are delivered into the ReadableStream, in some variable number of chunks","msgtype":"m.text"},"ts":1613493449000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Safari was doing one chunk for responses from the cache for a while (maybe still) so I'd imagine they do one chunk","msgtype":"m.text"},"ts":1613493468000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So maybe that's what we should do as that works for all callers, but I guess I first want to see if there's a test","msgtype":"m.text"},"ts":1613493549000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(and I guess we might still want to do processResponseEndOfBody in some fashion as it's just convenient to have)","msgtype":"m.text"},"ts":1613493582000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah HTML really wants that","msgtype":"m.text"},"ts":1613493668000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so a buffering proxy is essentially doing a read request on body's stream and then setting body's stream to a new stream that you put things in when you're ready, right?","msgtype":"m.text"},"ts":1613493800000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hmm yeah I guess so","msgtype":"m.text"},"ts":1613493836000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Although... you could also handle this at a lower layer","msgtype":"m.text"},"ts":1613493847000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Before putting any bytes into the stream in the first place","msgtype":"m.text"},"ts":1613493855000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"https://fetch.spec.whatwg.org/#concept-http-network-fetch step 16","msgtype":"m.text"},"ts":1613493895000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"At least as things are defined a service worker could be putting in the bytes","msgtype":"m.text"},"ts":1613493903000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"And handling it there wouldn't catch that","msgtype":"m.text"},"ts":1613493912000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ah cool OK","msgtype":"m.text"},"ts":1613493961000,"senderName":"Domenic","senderId":"Domenic@irc"}
]