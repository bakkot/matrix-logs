[
{"content":{"body":"https://web.dev/cross-origin-isolation-guide/ seems like a pretty good resource","msgtype":"m.text"},"ts":1616046360000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"annevk: looking at the thorough review, especially wondering what to do with this: https://github.com/whatwg/fetch/pull/1185#discussion_r596654405","msgtype":"m.text"},"ts":1616070586000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: it probably needs to be tested to see what actually happens","msgtype":"m.text"},"ts":1616070661000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"RT should also be created when the body is not read","msgtype":"m.text"},"ts":1616070674000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"(I tested it)","msgtype":"m.text"},"ts":1616070676000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"Digging more into chromium, there is an event coming from the network stack called \"OnComplete\" which happens on either errors, connection closed, or EOF","msgtype":"m.text"},"ts":1616070690000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"And I guess we need to decide what we want to happen as well","msgtype":"m.text"},"ts":1616070692000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"And I guess you don't have that with service workers?","msgtype":"m.text"},"ts":1616070747000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Fetch has that as well, kinda, processResponseEndOfBody, but the problem is that currently that also reads the response; I guess here you want a non-consuming variant","msgtype":"m.text"},"ts":1616070815000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(Maybe part of the difficulty is created by Fetch trying to accommodate full duplex while implementations are not.)","msgtype":"m.text"},"ts":1616070873000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yes, what I want is a non-consuming event for a response that gets triggered when the response is either errored or EOF'ed.","msgtype":"m.text"},"ts":1616071200000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: There is an EOF moment in HTTP network-fetch, maybe something can be fired at that moment. In service-workers there's a newly created stream, which can also have an explicit EOF/error moment.","msgtype":"m.text"},"ts":1616071413000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: yeah, I think that's feasible in theory","msgtype":"m.text"},"ts":1616071438000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"\"If stream doesnâ€™t need more data ask the user agent to suspend the ongoing fetch.\" At that moment I can fire the event for response","msgtype":"m.text"},"ts":1616071479000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"I'm not sure about service workers, mostly because I have a hard time recalling some details","msgtype":"m.text"},"ts":1616071514000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: no that's wrong, you need to do it when the stream is closed","msgtype":"m.text"},"ts":1616071555000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ok, yes, one line after.","msgtype":"m.text"},"ts":1616071589000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: a service worker creates a stream in `respondWith`, which has an end-of-body. The response created from SW can fire its own `on response complete` when that happens","msgtype":"m.text"},"ts":1616071624000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"this simplifies fetch/xhr a lot, and also the other callers... all they need is to handle the 'on response complete event', which would already set the response-end time, and call `report resource timing` with the stuff they know (global object, initiator type).","msgtype":"m.text"},"ts":1616071874000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"WDYT?","msgtype":"m.text"},"ts":1616072214000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: I don't think it affects xhr one way or another? xhr actively consumes the response","msgtype":"m.text"},"ts":1616072220000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: right, I guess XHR is ok the way it is.","msgtype":"m.text"},"ts":1616072243000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: I think it will help fetch and we should do it because of that","msgtype":"m.text"},"ts":1616072246000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: cool, new revision on its way. thanks!","msgtype":"m.text"},"ts":1616072275000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: other callers might be okay with an approach similar to xhr, I think, but perhaps we can group things more","msgtype":"m.text"},"ts":1616072277000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"e.g., repurpose the current processResponseEndOfBody to also do this, so that if you can use that callback, you're all set basically","msgtype":"m.text"},"ts":1616072322000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"but we might want to wait with doing too much until we investigate more callers","msgtype":"m.text"},"ts":1616072346000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: most of the caller in HTML are kinda behind... they call fetch but don't specify how they process the response","msgtype":"m.text"},"ts":1616072372000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"... call FETCH with a request and no response algorithms","msgtype":"m.text"},"ts":1616072389000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"So, for now: `on response complete` will fix the issue with `fetch`, and we can leave XHR as is, and see what more is needed once we try to handle more callers","msgtype":"m.text"},"ts":1616072447000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"yeah, HTML has a lot of old text unfortunately. Some of them should be fairly straightforward to tackle and I guess we should approach that incrementally","msgtype":"m.text"},"ts":1616072496000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: bikeshed: processResponseDone (and ideally it's equivalent to processResponseEndOfBody except that also reads)","msgtype":"m.text"},"ts":1616072610000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: re HTML, absolutely. Not sure if to add RT handling to places where it says \"Fetch the request\" without further information, or put it in prose. For now","msgtype":"m.text"},"ts":1616072639000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: we can also use this for the \"done flag\" I suppose","msgtype":"m.text"},"ts":1616072639000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: OK, so it's an algorithm that is part of the parameterse of FETCH?","msgtype":"m.text"},"ts":1616072677000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: I think it has to be for fetch() to use it","msgtype":"m.text"},"ts":1616072782000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: got it","msgtype":"m.text"},"ts":1616072804000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: you mean the existing \"request done flag\" that has the \"Really bad\" note?","msgtype":"m.text"},"ts":1616072933000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: yeah","msgtype":"m.text"},"ts":1616072965000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"would be nice to fix that and get rid of the comment :)","msgtype":"m.text"},"ts":1616072972000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk, yoav: done with another pass, using \"process response done\" for fetch() and leaving XHR mostly as is. Looks much nicer to me. note that now SW \"handle fetch\" accepts a \"process response done\" parameter, which would have to be handled in the SW spec.","msgtype":"m.text"},"ts":1616076988000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"so I've heard that <image> (non-<svg>) is backwards-compatibly mapped to <img>; can someone please point me to the proper place in HTML spec for this?","msgtype":"m.text"},"ts":1616078010000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"looking at https://html.spec.whatwg.org/multipage/images.html now, not sure if that is the right place","msgtype":"m.text"},"ts":1616078043000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"ondras: https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inbody","msgtype":"m.text"},"ts":1616079349000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"Scroll down to \" a start tag whose tag name is  \\\"image\\\"\"","msgtype":"m.text"},"ts":1616079397000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"EveryOS: thanks! what on earth is that \"don't ask\" remark, I would love to ask? ;)","msgtype":"m.text"},"ts":1616079605000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"ondras: My guess is that people get confused a ton and use <image> instead of <img>, and that's partly why they keep that tag.","msgtype":"m.text"},"ts":1616079675000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"Also, don't ask...","msgtype":"m.text"},"ts":1616079675000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":".)","msgtype":"m.text"},"ts":1616079709000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"noamr: so I was looking at hr-time again and one thing I don't understand is https://w3c.github.io/hr-time/#dfn-shared-monotonic-clock","msgtype":"m.text"},"ts":1616084532000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: that says everything has to share a time origin, but what is the time origin when we invoke https://w3c.github.io/hr-time/#dfn-unsafe-shared-current-time?","msgtype":"m.text"},"ts":1616084564000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: it seems it would be undefined...","msgtype":"m.text"},"ts":1616084615000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: ^","msgtype":"m.text"},"ts":1616084619000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yea this is more for yoav... I think the timeOrigin of the shared monotonic clock is not defined (some OS value)","msgtype":"m.text"},"ts":1616084734000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: but yeah, I was thinking we add something to hr-time whereby we get a coarsened timestamp depending on a boolean parameter with the boolean indicating whether or not we have the cross-origin isolated capability","msgtype":"m.text"},"ts":1616084971000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: I'm happy to write that PR and also patch your Fetch PR accordingly, but I do need to understand this time origin business better","msgtype":"m.text"},"ts":1616085004000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: cool :) any help is appreciated.","msgtype":"m.text"},"ts":1616085053000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"I should contribute to the specs some day, but I doubt I would be much help. Half the time, it is already hard enough just understanding them.","msgtype":"m.text"},"ts":1616085121000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"EveryOS: I think that's how most of us started out, or I can say that at least I did","msgtype":"m.text"},"ts":1616085155000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Oh, ok. And you kind of just got used to it?","msgtype":"m.text"},"ts":1616085206000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"EveryOS: I definitely started that way. A few failed PRs with rookie mistakes and I was good to go.","msgtype":"m.text"},"ts":1616085208000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"EveryOS: what helps me a lot is writing demos/tests, although sometimes that leads you into interop rabbit holes rather than actually getting to understand it, but then at least you know something is wrong","msgtype":"m.text"},"ts":1616085244000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Sure, I'll do it that way","msgtype":"m.text"},"ts":1616085362000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"annevk: It's somewhat defined in https://w3c.github.io/hr-time/#dfn-shared-monotonic-clock, pointing back to https://tc39.es/ecma262/#sec-time-values-and-time-range","msgtype":"m.text"},"ts":1616085464000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"EveryOS: also, if you're looking for general contributor advice, https://github.com/whatwg/meta/blob/main/CONTRIBUTING.md has some, including some good references at the end","msgtype":"m.text"},"ts":1616085484000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Thanks","msgtype":"m.text"},"ts":1616085497000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"basically, a monotonically increasing clock that starts at epoch","msgtype":"m.text"},"ts":1616085511000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: so what does \"that is shared by time origins\" mean there?","msgtype":"m.text"},"ts":1616085535000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"all time origins need to use the same monotonic clock (and similarly not skew if the user e.g. changes their system clock)","msgtype":"m.text"},"ts":1616085627000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"agree that the phrasing is odd","msgtype":"m.text"},"ts":1616085633000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: if it's indeed all epoch I guess what I need to define is coarsened shared current time which takes the boolean","msgtype":"m.text"},"ts":1616085636000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: and adjust coarsen time and callers of that in a similar manner","msgtype":"m.text"},"ts":1616085664000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'll poke at this tomorrow / Monday I suspect, I'm rather tired; thanks for the help so far!","msgtype":"m.text"},"ts":1616085764000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'm not 100% clear on why https://w3c.github.io/hr-time/#dfn-current-high-resolution-time is not sufficient for your needs, but happy to discuss more tomorrow/Monday :)","msgtype":"m.text"},"ts":1616085791000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: I cannot pass a global from in parallel I think","msgtype":"m.text"},"ts":1616085895000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: and it's not clear I have a time origin in parallel either","msgtype":"m.text"},"ts":1616085927000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(pretty sure I don't)","msgtype":"m.text"},"ts":1616085939000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I signed the CLA (https://github.com/whatwg/participant-data), don't know when I'll get to actually working on making a PR. I'll take a look at open issues to see what is available to do.","msgtype":"m.text"},"ts":1616085965000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"The global bit sounds easy","msgtype":"m.text"},"ts":1616086035000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"For the time origin bit, you'd need to grab a timestamp from the monotonic clock and do the diffing later","msgtype":"m.text"},"ts":1616086068000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: right, which I think my design allows for, it coarsens the value from the monotonic clock (I guess it won't prevent having to normalize it to a relative time later though, so you still have some redundant words)","msgtype":"m.text"},"ts":1616086255000,"senderName":"annevk","senderId":"annevk@irc"}
]