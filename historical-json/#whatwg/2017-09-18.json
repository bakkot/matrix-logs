[
{"content":{"body":"Is there a section in the fetch spec where things like URL objects are converted into `Request`s before performing the fetch algorithm?","msgtype":"m.text"},"ts":1505698550000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"I ask because it mentions that the input for fetch is a Request, yet the fetch API takes in things like strings and URLs","msgtype":"m.text"},"ts":1505698613000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: see step 2 in the algorithm for the fetch method; it calls the Request constructor with whatever was passed to the fetch method","msgtype":"m.text"},"ts":1505699163000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"domfarolino: https://fetch.spec.whatwg.org/#fetch-method","msgtype":"m.text"},"ts":1505699171000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: wow how'd I miss that. Thank you!","msgtype":"m.text"},"ts":1505699360000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"Mek: perhaps you could answer this, what allows the Request constructor to be called with a URL object as its first param, and still work? Seems the constructor takes in strings and Request objects.","msgtype":"m.text"},"ts":1505701266000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: the magic of WebIDL, which stringifies whichever is passed in (and the URL interface has a stringifier defined)","msgtype":"m.text"},"ts":1505701429000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"(stringifies things passed to a method taking a DOMStirng/USVString)","msgtype":"m.text"},"ts":1505701450000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: Ok so an object with a stringifier defined will pass a \"string\" (DOMString/USVString) type check then?","msgtype":"m.text"},"ts":1505701616000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: well, anything will pass a \"string\" type check (i.e. there is no error throwing in the algorithm to convert a ecmascript value to a DOMString https://heycam.github.io/webidl/#es-DOMString)","msgtype":"m.text"},"ts":1505701717000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"actually, a Symbol would throw a TypeError in the ecmascript spec","msgtype":"m.text"},"ts":1505701854000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: Hmm so I just realized that URL.toString() is called when passing a URL into Request constructor. I guess I'm a little confused as to how in the Request constructor, we can get away with checking for the more general type \"string\" before checking for object of type Request. Because if an object of type Request can be seen as a string, wouldn't we ALWAYS pass the \"if input is a string\" condition?","msgtype":"m.text"},"ts":1505701965000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"I mean obviously we don't, but I'm just confused as to why. Because new Request().toString() will pass (just return an invalid URL is all)","msgtype":"m.text"},"ts":1505701994000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: see the algorithm for converting a union type from ES to IDL (https://heycam.github.io/webidl/#es-union)","msgtype":"m.text"},"ts":1505702029000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"the string conversion isn't attempted till step 14, Request will be handled in step 4","msgtype":"m.text"},"ts":1505702057000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: Ohh so we don't delegate if we recognize a platform object first then","msgtype":"m.text"},"ts":1505702351000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"delegate to ecma ToString, that is","msgtype":"m.text"},"ts":1505702359000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1505702363000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Ok this makes a lot more sense thanks!","msgtype":"m.text"},"ts":1505702378000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"Mek: could you help me understand step 4 substep 1 of the es-union algorithm you sent a bit ago. For example, `new Headers()` is a platform object (right?), however when passed into the `Request` constructor (which looks for a string) we fallback to calling `.toString` (step 14), and I'm not sure what condition in step 4 > substep 1 we're failing","msgtype":"m.text"},"ts":1505706338000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: `new Headers()` does not implement `Request`","msgtype":"m.text"},"ts":1505710606000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: hm does that mean 'new URL()' does then since we're caught at step 4 when passing in 'new URL()'? Or am I misunderstanding something","msgtype":"m.text"},"ts":1505711186000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"No, new URL also fails step 4 substep 1","msgtype":"m.text"},"ts":1505711362000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"new URL ends up in step 14","msgtype":"m.text"},"ts":1505711383000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Ok, so headers and URL are both platform objects so they attempt step 4 dubstep 1 which they fail and move on (eventually hitting 14) correct?","msgtype":"m.text"},"ts":1505712185000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"Substep ** autocorrect","msgtype":"m.text"},"ts":1505712211000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"but of course Request object passes fine","msgtype":"m.text"},"ts":1505712283000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"yeah, because Request is the only interface type included in \"types\"","msgtype":"m.text"},"ts":1505712383000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"annevk: with background fetch I need to process the body of the response as it arrives. \"process response\" is ideal in terms of timing, but it requires an event loop that I may not have. Feels like the task queuing part should be optional.","msgtype":"m.text"},"ts":1505721104000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Has this come up before?","msgtype":"m.text"},"ts":1505721144000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I think usually when there's no even loop you set the sync flag","msgtype":"m.text"},"ts":1505721208000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hmm I guess that doesn't work for you","msgtype":"m.text"},"ts":1505721233000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hmm per spec SRI disables streaming!?","msgtype":"m.text"},"ts":1505721295000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I guess that makes sense, but still....","msgtype":"m.text"},"ts":1505721303000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah, sync means it'll wait for the body before giving me the response","msgtype":"m.text"},"ts":1505721325000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"https://fetch.spec.whatwg.org/#concept-fetch step 19 for the SRI thing","msgtype":"m.text"},"ts":1505721334000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"hah, that (streaming and packaging/sri/signature type things being incompatible) also came up over lunch...","msgtype":"m.text"},"ts":1505721367000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"JakeA: I wonder if you should just have a simple event loop...","msgtype":"m.text"},"ts":1505721387000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so change HTML to define a third type of event loop?","msgtype":"m.text"},"ts":1505721424000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"I can't see how SRI can work without streaming. But that'll provide an interesting challenge for bg fetch too.","msgtype":"m.text"},"ts":1505721546000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: how can you do callbacks without an event loop?","msgtype":"m.text"},"ts":1505721670000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: In spec-speak, I can call out to another algorithm while I'm \"in parallel\". Given that the algorithm I'm calling is on the same thread, it doesn't seem like an event loop is needed for algorithmic callbacks.","msgtype":"m.text"},"ts":1505723000000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so you're happy to block yourself until you got a response, but no further?","msgtype":"m.text"},"ts":1505723169000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: also, who says fetch is on the same thread?","msgtype":"m.text"},"ts":1505723213000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I wonder how background fetch integrates with \"fetch groups\" and the various timing APIs","msgtype":"m.text"},"ts":1505723236000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm happy to block until I've got a response, but it'd nice to hand back to fetch after that so it can process the trailer etc","msgtype":"m.text"},"ts":1505723276000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: main fetch is on the same thread in as much as it can return a response","msgtype":"m.text"},"ts":1505723299000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: you also need the body?","msgtype":"m.text"},"ts":1505723306000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: in that case i'd just use the sync flag","msgtype":"m.text"},"ts":1505723326000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: that waits for the response body","msgtype":"m.text"},"ts":1505723369000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: Since background fetch can be multiple requests combined, I need to be able to handle the stream","msgtype":"m.text"},"ts":1505723409000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: and a response that provides data before failing is still useful, as I can resume from there","msgtype":"m.text"},"ts":1505723488000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: in terms of fetch groups, I'm still figuring that out. Use of clients is also interesting. I'm leaning on keepalive for now, but haven't looked too closely at it.","msgtype":"m.text"},"ts":1505723565000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so Fetch does have an open issue on making the callbacks more explicit","msgtype":"m.text"},"ts":1505724309000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: maybe if that were fixed we could make things more flexible around event loops","msgtype":"m.text"},"ts":1505724334000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"https://github.com/whatwg/fetch/issues/536","msgtype":"m.text"},"ts":1505725537000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: ta, I'll add my use-cases to that issue","msgtype":"m.text"},"ts":1505725546000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: the more I think about it, the sync flag is perfect, except for the \"wait for body\" bit. Mind if I send a PR that adds a flag that means it *doesn't* wait for the body?","msgtype":"m.text"},"ts":1505726847000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it feels a bit like a hack at that point","msgtype":"m.text"},"ts":1505727025000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I'd be worried about the added complexity and ensuring everything remains working well","msgtype":"m.text"},"ts":1505727078000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: thoughts on https://github.com/whatwg/html/issues/3043#issuecomment-329838865?","msgtype":"m.text"},"ts":1505727123000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"xfq: your welcome 😊","msgtype":"m.text"},"ts":1505727144000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I haven't taken the time to look at the current spec enough to validate the design... Maybe later tonight I can.","msgtype":"m.text"},"ts":1505727240000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: leave it then, I'll just go with something and see if it works","msgtype":"m.text"},"ts":1505727298000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: and then we can bikeshed during review","msgtype":"m.text"},"ts":1505727306000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"What is the security model for service workers","msgtype":"m.text"},"ts":1505727371000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"when can a service worker run?","msgtype":"m.text"},"ts":1505727380000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"security is wrong word","msgtype":"m.text"},"ts":1505727385000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: it runs when a document associated with a browsing context or worker is created","msgtype":"m.text"},"ts":1505727471000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"smaug____: and then during the lifetime of that document/worker whenever stuff is fetched","msgtype":"m.text"},"ts":1505727495000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"what about push?","msgtype":"m.text"},"ts":1505727508000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: that can run when there isn't an associated document open. But…","msgtype":"m.text"},"ts":1505727531000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"smaug____: That requires user permission at registration time, and a notification must be shown as a result","msgtype":"m.text"},"ts":1505727550000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"and there is no way to cancel such notification ?","msgtype":"m.text"},"ts":1505727569000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: no way to remove the notification without the user seeing it","msgtype":"m.text"},"ts":1505727684000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"smaug____: There are some cases where you don't have to show a notification, eg there's a page to the origin open. The reason you have to show a notification is so the user is aware the site ran in the background, so there's no need to do that if it's already visibly running.","msgtype":"m.text"},"ts":1505727764000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"sure. I'm just wondering in which all ways web sites may misuse users' machines","msgtype":"m.text"},"ts":1505727809000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"running random JS code","msgtype":"m.text"},"ts":1505727813000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: There are use-case this gets in the way of. Eg, you show a notification on the phone \"You have a new direct message\", but the user views that message on another device, so you want to remove that notification from all devices. We don't have a good answer for that yet","msgtype":"m.text"},"ts":1505727828000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"just read about that bitcoin mining using JS, but that, I guess, isn't SW related","msgtype":"m.text"},"ts":1505727864000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: With background fetch, the plan is to close the service worker during the fetch (unless it's otherwise needed), then run it again to handle completion events once the fetch is complete. During the fetch there'll be a download notification showing progress, so again it's very user-visible","msgtype":"m.text"},"ts":1505727933000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"smaug____: JakeA: I don't believe the spec requires \"notification must be shown\"... firefox uses a different heuristic","msgtype":"m.text"},"ts":1505740966000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: it's somewhat in the spec https://w3c.github.io/push-api/#dom-pushsubscriptionoptions-uservisibleonly","msgtype":"m.text"},"ts":1505741557000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: we don't implement that: http://searchfox.org/mozilla-central/source/dom/webidl/PushManager.webidl#11","msgtype":"m.text"},"ts":1505741617000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"gothca","msgtype":"m.text"},"ts":1505741629000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"um","msgtype":"m.text"},"ts":1505741632000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"gotcha","msgtype":"m.text"},"ts":1505741633000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"goes away to draw gothcat","msgtype":"m.emote"},"ts":1505741647000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: gothca sounds like a pokemon to me","msgtype":"m.text"},"ts":1505741649000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"haha","msgtype":"m.text"},"ts":1505741656000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I wasn't directly involved in our push heuristic, but I think the idea is we believe the throttling is adequate and if a site is abusing it we slow their pushes to the point it doesn't matter","msgtype":"m.text"},"ts":1505741711000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but again, I'm not 100% sure","msgtype":"m.text"},"ts":1505741720000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I guess that enables the \"hide notification\" thing at the very least","msgtype":"m.text"},"ts":1505741887000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yea","msgtype":"m.text"},"ts":1505742124000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: AFAIK the `userVisibleOnly` thing is not feature detectable... does it have any observable change on script?","msgtype":"m.text"},"ts":1505742205000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I don't think so","msgtype":"m.text"},"ts":1505742297000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"ok, that makes me feel a bit better in not implementing it","msgtype":"m.text"},"ts":1505742319000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I mean, if you don't set it to true, we always reject","msgtype":"m.text"},"ts":1505742372000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: what did you mean earlier about SRI not working without streaming?","msgtype":"m.text"},"ts":1505742387000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: don't you need the whole response before you know it matches the hash","msgtype":"m.text"},"ts":1505742416000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: right... ok... maybe I misread what you said","msgtype":"m.text"},"ts":1505742444000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: I guess it depends if we need to reject the outer fetch or if we can abort the body stream... but right now it requires not providing a Response with status=200","msgtype":"m.text"},"ts":1505742475000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"so we can't provide Response before the body is available","msgtype":"m.text"},"ts":1505742487000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: spec says reject the outer fetch","msgtype":"m.text"},"ts":1505742540000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yea, I was more wondering if we could make that more forgiving now that streams exist... I think SRI was integrated before body streams","msgtype":"m.text"},"ts":1505742567000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but I don't think aborting the body is the same","msgtype":"m.text"},"ts":1505742607000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: ohh I see. Yeah, I guess it depends if header access for a non-matching response should be considered dangerous. But I guess it's fine","msgtype":"m.text"},"ts":1505742613000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"or partial body data","msgtype":"m.text"},"ts":1505742625000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"that's definitely risky","msgtype":"m.text"},"ts":1505742642000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"seems unwise","msgtype":"m.text"},"ts":1505742647000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: Isn't userVisibleOnly feature detectable if one has a throwing getter for it in the object passed as dictionary","msgtype":"m.text"},"ts":1505742678000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: oh, I guess so","msgtype":"m.text"},"ts":1505742698000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"doesn't know all the tricks...","msgtype":"m.emote"},"ts":1505742708000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ohh yeah, I keep forgetting about that trick","msgtype":"m.text"},"ts":1505742714000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"has to go do a code review on his house shortly.","msgtype":"m.emote"},"ts":1505742727000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: are you happy to address Domenic's nits in https://github.com/whatwg/html/pull/3038? In terms of comments on the stuff I wrote, there isn't anything I disagree with","msgtype":"m.text"},"ts":1505745308000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah, I likely won't get to it today though","msgtype":"m.text"},"ts":1505745508000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: no rush, I just didn't want to get in the way","msgtype":"m.text"},"ts":1505745521000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: ended up doing it","msgtype":"m.text"},"ts":1505756598000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: hah cheers","msgtype":"m.text"},"ts":1505758115000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: if a user completely disables cookies in chrome, does that block service workers from working?","msgtype":"m.text"},"ts":1505760741000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"similar to 3rd party cookies being disabled blocking service worker itnerception of 3rd party iframes","msgtype":"m.text"},"ts":1505760777000,"senderName":"wanderview","senderId":"wanderview@irc"}
]