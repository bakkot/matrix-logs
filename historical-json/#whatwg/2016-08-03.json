[
{"content":{"body":"you have any advice about how I should preparee fo/win 23","msgtype":"m.text"},"ts":1470197055000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"oofs","msgtype":"m.text"},"ts":1470197058000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"hmm, I thought I knew how download attribute works with <a>","msgtype":"m.text"},"ts":1470230047000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"but apparently I don't","msgtype":"m.text"},"ts":1470230051000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"hmm, or perhaps server can still override the filename?","msgtype":"m.text"},"ts":1470230363000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"JakeA: a couple times last week you mentioned the idea of returning a promise from respondWith() that would resolve after the browser consumes the response","msgtype":"m.text"},"ts":1470232159000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"it didn't quite sit well with me and I couldn't figure out why","msgtype":"m.text"},"ts":1470232170000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I think I finally figured out what bothers me about it","msgtype":"m.text"},"ts":1470232179000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: wouldn't a promise returned from respondWith() essentially provide a callback exactly when we're no longer holding the service worker alive?  its like a \"now its unsafe\" callback","msgtype":"m.text"},"ts":1470232213000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah you'd have to do waitUntil( respondWith(stuff).then(â€¦) )","msgtype":"m.text"},"ts":1470232255000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Which is a bit :/","msgtype":"m.text"},"ts":1470232272000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: or it gets an implicit extension for a micro-task... but feels difficult to explain with our current primitives","msgtype":"m.text"},"ts":1470232298000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or wonky at least","msgtype":"m.text"},"ts":1470232302000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"We already have an extension for a microtask right?","msgtype":"m.text"},"ts":1470233211000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"We talked about that so waitUntil( thing.then(() => waitUntil(anotherThing)) ) works","msgtype":"m.text"},"ts":1470233245000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"hm, my code there is wrong. I mean: thing.then(() => waitUntil(anotherThing)); whatUntil(thing);","msgtype":"m.text"},"ts":1470233286000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"hah, I mean waitUntil","msgtype":"m.text"},"ts":1470233297000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"falls over","msgtype":"m.emote"},"ts":1470233308000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"wanderview: now I think about it, didn't we decide a separate fetcherror event was a better idea?","msgtype":"m.text"},"ts":1470236219000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yea... I was just thinking about the respondWith() promise idea this morning","msgtype":"m.text"},"ts":1470236257000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: I guess I was saying \"not only are we not doing your idea, Jake, but I don't like it either!!!!\"","msgtype":"m.text"},"ts":1470236289000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"sorry","msgtype":"m.text"},"ts":1470236290000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":":-)","msgtype":"m.text"},"ts":1470236298000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"haha","msgtype":"m.text"},"ts":1470236301000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Yeah, the event is better, as you can do something with it","msgtype":"m.text"},"ts":1470236334000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: now I'm trying to remember why we wanted FetchErrorEvent instead of just using the normal Worker global onerror... I guess its more explicit and we can provide a better method to \"resume the connection\" than just preventDefault()","msgtype":"m.text"},"ts":1470236622000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah, preventDefault is really confusing in this case, since it'd make the default thing happen","msgtype":"m.text"},"ts":1470236664000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: https://fetch.spec.whatwg.org/#http-fetch 3.3 - does this suggest a new generic network error is created? Devs have complained that Chrome presents a generic error rather than a more specific one. Does there need to be a spec change to allow the actual error to pass through to the navigation handler?","msgtype":"m.text"},"ts":1470236758000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah, we'd need to change the spec","msgtype":"m.text"},"ts":1470236810000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'll file an issue","msgtype":"m.text"},"ts":1470236821000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: and get security sign off","msgtype":"m.text"},"ts":1470236826000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think the browser could just stash the specific type on an internal value... its never consumed by anyone but the browser","msgtype":"m.text"},"ts":1470236831000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: that is the main reason all errors are the same","msgtype":"m.text"},"ts":1470236852000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah, might need some same-origin checks","msgtype":"m.text"},"ts":1470236876000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: JakeA: in firefox all network error pages are cross origin.. so i don't think the error type can ever be leaked to content... doesn't seem like a security issue to me... might be an issue for chrome with same-origin error pages","msgtype":"m.text"},"ts":1470236910000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: even for that I recall folks not liking it, but there might be APIs exposing that now","msgtype":"m.text"},"ts":1470236931000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: I thought we were discussing specific TypeError exceptions","msgtype":"m.text"},"ts":1470236977000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hmm, I can't think of problems, but will make an issue and see if we can get someone security-minded to look at it","msgtype":"m.text"},"ts":1470236991000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: not if its the same as the face-to-face meeting discussion... it was just showing the right network error page to the user... not exposing different exception types","msgtype":"m.text"},"ts":1470237004000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Okay, I guess I'll follow up on the issue then ðŸ˜Š","msgtype":"m.text"},"ts":1470237051000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Not today, but likely tomorrow","msgtype":"m.text"},"ts":1470237067000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"who might know about blink's MutationObserver implementation","msgtype":"m.text"},"ts":1470237874000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"JakeA: how do you BroadcastChannel to a service worker?","msgtype":"m.text"},"ts":1470252092000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: new BroadcastChannel? It'd only work while the instance is alive","msgtype":"m.text"},"ts":1470252119000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I guess each service worker thread adds an event listener to the BroadcastChannel ?","msgtype":"m.text"},"ts":1470252126000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Yeah","msgtype":"m.text"},"ts":1470252132000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"goes to read BroadcastChannel...","msgtype":"m.emote"},"ts":1470252140000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I don't think it's a problem, just something to think about","msgtype":"m.text"},"ts":1470252140000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it might be worth pointing out that SharedWorker is either not implemented or not supported as a nested worker in any browser today?","msgtype":"m.text"},"ts":1470252176000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but we could make that a pre-req of implementing this?","msgtype":"m.text"},"ts":1470252187000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Good point","msgtype":"m.text"},"ts":1470252195000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: maybe pre-req is too strong a word :-)","msgtype":"m.text"},"ts":1470252225000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA:  I do kind of like the conceptual difference between SharedWorker and ServiceWorker in this design... ServiceWorker instances are ephemeral and fast... if you want synchronous coordination you pay the price and opt-in to SharedWorker","msgtype":"m.text"},"ts":1470252421000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Or IDB (maybe with observers too)","msgtype":"m.text"},"ts":1470252461000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I guess an opt-in to \"single thread always\" for service worker could just be implemented as \"all service worker instances open a SharedWorker and fire their event there\"","msgtype":"m.text"},"ts":1470252472000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: I mean, the browser could implement it that way... no special logic beyond what the content could polyfil themselves","msgtype":"m.text"},"ts":1470252506000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: the browser would just be fixing up the global to connect a few things, etc","msgtype":"m.text"},"ts":1470252518000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Hah! Well, if you're talking about doing that on the developer-side, it's tricky due to what can be cloned/transfered","msgtype":"m.text"},"ts":1470252531000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: once ReadableStream transfer gets spec'd, I think Response/Request objects should be transferable as well?","msgtype":"m.text"},"ts":1470252680000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Agreed","msgtype":"m.text"},"ts":1470252695000,"senderName":"JakeA","senderId":"JakeA@irc"}
]