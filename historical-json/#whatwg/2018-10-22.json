[
{"content":{"body":"I could make that perhaps. I told jib various things too though, I think he’s preparing as well","msgtype":"m.text"},"ts":1540177933000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: I'm a little scared of merging two order-dependent PRs with GitHub in its current fragile state, and also how well any subsequent Travis runs and deploys will go. So if we could wait until https://status.github.com/ calms down a bit that'd be ideal. But yeah nothing blocking on the code front.","msgtype":"m.text"},"ts":1540204235000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: ah yeah, good point","msgtype":"m.text"},"ts":1540204285000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Domenic: I had to try multiple times before I could even successfully submit that issues comment :)","msgtype":"m.text"},"ts":1540204329000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"GitHub kept saying, \"You can '","msgtype":"m.text"},"ts":1540204342000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"\"You can't comment right now.\"","msgtype":"m.text"},"ts":1540204358000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Yeah, I think sometimes it goes through though. Like I've gotten 15 emails from Jake's comment on service worker F2F agenda.","msgtype":"m.text"},"ts":1540204367000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So I actually tried to reply on-thread and then saw it fail and decided to go here instead, to avoid potentially sending N emails of my own while retrying.","msgtype":"m.text"},"ts":1540204383000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: any reason to wait on merging https://github.com/whatwg/html/pull/4099 ?","msgtype":"m.text"},"ts":1540214971000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I guess maybe because GitHub is shaky","msgtype":"m.text"},"ts":1540214999000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I didn't do it because it wasn't sure about the commit message, feel free","msgtype":"m.text"},"ts":1540215365000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"And I guess I wanted to give dbaron some time to chime in, but it's probably okay","msgtype":"m.text"},"ts":1540215381000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgtm","msgtype":"m.text"},"ts":1540215472000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"I was just forwarding an email to the right place...","msgtype":"m.text"},"ts":1540215570000,"senderName":"dbaron","senderId":"dbaron@irc"},
{"content":{"body":"Merged","msgtype":"m.text"},"ts":1540216052000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: working on https://github.com/whatwg/html/pull/4076/files but I am really confused because \"associated Document\" does not seem defined...","msgtype":"m.text"},"ts":1540219105000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: hmm yeah, I guess that was never defined","msgtype":"m.text"},"ts":1540219318000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Trying to formulate something alternate and maybe a bit simpler, but not sure if it's equivalent...","msgtype":"m.text"},"ts":1540219335000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"relevant Document is probably Location object's relevant global object's browsing context's active document","msgtype":"m.text"},"ts":1540219402000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think it's:","msgtype":"m.text"},"ts":1540219453000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"The relevant Document of a Location object loc is loc's relevant settings object's responsible document, if that Document is active, and null otherwise.","msgtype":"m.text"},"ts":1540219454000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yours maybe is better","msgtype":"m.text"},"ts":1540219513000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Is \"active document\" null for detached iframes?","msgtype":"m.text"},"ts":1540219525000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(Sounds like a question we've asked before...)","msgtype":"m.text"},"ts":1540219533000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"That shouldn't be active, I think","msgtype":"m.text"},"ts":1540219568000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"https://github.com/whatwg/html/issues/1073","msgtype":"m.text"},"ts":1540219589000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"good times","msgtype":"m.text"},"ts":1540219651000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think ours are equivalent","msgtype":"m.text"},"ts":1540219691000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Happy with either, although with yours we should add a note pointing to 1073 and clarify the intent","msgtype":"m.text"},"ts":1540219707000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hmm no we need the note with both","msgtype":"m.text"},"ts":1540219722000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I'll capture on GitHub","msgtype":"m.text"},"ts":1540219751000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I really wish documents were dumber/not tied to anything","msgtype":"m.text"},"ts":1540219900000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1540220297000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"o/","msgtype":"m.text"},"ts":1540240049000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Access to Raw Audio... is this something you would consider in scope for WHATWG streams? https://docs.google.com/presentation/d/1WOihY0SMJbWvfbc-41GA78F4yzPSwmyDOJ8GbRoU7dw/edit#slide=id.g445c72bf7e_1_0 (slides 30 to 38)","msgtype":"m.text"},"ts":1540240144000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"I honestly don't know in this case.","msgtype":"m.text"},"ts":1540240144000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: from what I can tell that is about real-time audio processing, which is not as good a fit (in part because real time audio is very specialized). But if you were talking just streaming access to the audio bytes of a RTC stream, that would make sense, and in fact there's a proto-spec for it","msgtype":"m.text"},"ts":1540240516000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Yeah, I think this is mainly about real-time transformation. I guess this is better suited for Worklets.","msgtype":"m.text"},"ts":1540240582000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Domenic: I think we will see a couple of slides tomorrow that suggest using streams for RTP 'n stuff","msgtype":"m.text"},"ts":1540240647000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"https://discourse.wicg.io/t/rfc-proposal-for-integration-streams-mediastreamtrack-api/2256 for streaming access to raw bytes of a MediaStreamTrack","msgtype":"m.text"},"ts":1540240649000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Exciting. I should be able to make it.","msgtype":"m.text"},"ts":1540240661000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Great! :)","msgtype":"m.text"},"ts":1540240678000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Jan-Ivar and I were thinking whether we should create an API that can handle both binary and string data (since that is what WebSocket and Data Channels currently allow to send)... or just binary and say that encode/decode should be a transformation.","msgtype":"m.text"},"ts":1540241529000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"I do kind of like the latter approach.","msgtype":"m.text"},"ts":1540241529000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Yeah the latter is what we're doing with modern APIs these days like fetch","msgtype":"m.text"},"ts":1540241563000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"These days it's as easy (in spec land and in Chrome) as `const stringReadable = byteReadable.pipeThrough(new TextDecoderStream())`","msgtype":"m.text"},"ts":1540241592000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Oh, that's good to know :)","msgtype":"m.text"},"ts":1540241652000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"hi","msgtype":"m.text"},"ts":1540241680000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"jib: You may want to take a look at the latest comment from Domenic (see the log). Might be a neat example.","msgtype":"m.text"},"ts":1540241763000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"I saw","msgtype":"m.text"},"ts":1540241769000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"but that requires cooperation to know what's text and what's not","msgtype":"m.text"},"ts":1540241836000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Then again, the application will usually know. It could even use separate channels for that purpose.","msgtype":"m.text"},"ts":1540241878000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"well sure, but it requires dedicating a single channel per type. that's easy","msgtype":"m.text"},"ts":1540241923000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Today, we can do dc1.send(\"A\"); dc1.send(fileB); do2.send(\"C\");  dc2.onmessage = ({data}) => (data instanceof Blob)? processFile(data) : log(data);","msgtype":"m.text"},"ts":1540241950000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"which lets you mix heterogeneous messages by type at least","msgtype":"m.text"},"ts":1540241979000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Yes and I wouldn't want to change that now. However, it does support the argument that we shouldn't bother about having a stream support strings, too.","msgtype":"m.text"},"ts":1540242030000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"It does? how?","msgtype":"m.text"},"ts":1540242045000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"If we go with .onmessage spitting out streams for binary data and DOMString for strings, then you still have both. If you want to send huge strings, just encode/decode them and send them as binary.","msgtype":"m.text"},"ts":1540242110000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"We might be able to do the same with streams, with e.g. onreadable = ({readable}) => (readable.type == \"bytes\")? readable.pipeTo(fileProcessor) : readable.pipeTo(logger);","msgtype":"m.text"},"ts":1540242124000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"If I encode strings, how will receiver tell them apart from files?","msgtype":"m.text"},"ts":1540242156000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"ss/onreadable/dc2.onreadable/","msgtype":"m.text"},"ts":1540242185000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Why would the receiver not know what it is going to receive?","msgtype":"m.text"},"ts":1540242196000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Which application does stuff like that? :)","msgtype":"m.text"},"ts":1540242213000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"because we support it today? do dc1.send(\"A\"); dc1.send(fileB); do2.send(\"C\");  dc2.onmessage = ({data}) => (data instanceof Blob)? processFile(data) : log(data);","msgtype":"m.text"},"ts":1540242217000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"It seems surprising to me that you've so far privileged one type's byte-serialization (strings) over others, and made it auto-decode. Why not do the same for numbers, or JSON, or protobufs?","msgtype":"m.text"},"ts":1540242228000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"isn't that what websocket does?","msgtype":"m.text"},"ts":1540242264000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Ah, so just following web sockets?","msgtype":"m.text"},"ts":1540242300000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"as opposed to?","msgtype":"m.text"},"ts":1540242313000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Following fetch or other modern APIs","msgtype":"m.text"},"ts":1540242322000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"RTCDataChannel is modeled after websocket. How would we follow fetch?","msgtype":"m.text"},"ts":1540242354000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Operate on bytes, and let applications choose their semantics by decoding those bytes appropriately. This allows a mucher richer set of types to all have equal support, instead of privileging strings.","msgtype":"m.text"},"ts":1540242399000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Also makes the transport less complicated","msgtype":"m.text"},"ts":1540242414000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"makes some sense. Specs are a bit confusing wrt ReadableStream, it seems type-agnostic at times, but other times seems to be bytes only, to me","msgtype":"m.text"},"ts":1540242477000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Let me say again: This is meant as an extension. You can still get strings out of .onmessage. I'm just saying that we shouldn't care about handling backpressure for strings. It would make the stack unnecessarily complicated for a moot use case (IMO). If someone is sending gigantic strings, it could easily drop in TextDecoderStream.","msgtype":"m.text"},"ts":1540242519000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Yeah I can see that. The ones from the network are bytes, but the type itself supports everything, which lets you do things like write transforms that go from ReadableStream<bytes> -> ReadableStream<string> or ReadableStream<JS object> or ReadableStream<number> or...","msgtype":"m.text"},"ts":1540242550000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"lgrahl: ok I'll buy that","msgtype":"m.text"},"ts":1540242586000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"I think you've convinced me","msgtype":"m.text"},"ts":1540242659000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"cheers","msgtype":"m.emote"},"ts":1540242689000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"fewer options simplify slides","msgtype":"m.text"},"ts":1540242707000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Nice side effect :)","msgtype":"m.text"},"ts":1540242730000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Btw on naming, How do we feel about dc.createWritable() ? The word \"stream\" is a bit overloaded in webrtc","msgtype":"m.text"},"ts":1540242737000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"If it were TypeScript, I would like \"createMessage\" because the return type is clear","msgtype":"m.text"},"ts":1540242766000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1540242779000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"but it's not typescript ;)","msgtype":"m.text"},"ts":1540242800000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"likes ducktyping","msgtype":"m.emote"},"ts":1540242825000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"too","msgtype":"m.emote"},"ts":1540242831000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"if it reads and writes like a duck...","msgtype":"m.text"},"ts":1540242845000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Given the overloaded meaning of stream that seems pretty solid.","msgtype":"m.text"},"ts":1540242854000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I assume it should be a function, not a property, because calling it causes some locking or change into \"write via a stream\" mode?","msgtype":"m.text"},"ts":1540242882000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1540242883000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Yeah, it would lock .send","msgtype":"m.text"},"ts":1540242907000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1540242913000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Or, actually... it might not even need to","msgtype":"m.text"},"ts":1540242914000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Seems simpler","msgtype":"m.text"},"ts":1540242924000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Agree. We should lock. Let's not make things more complicated.","msgtype":"m.text"},"ts":1540242943000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"dc1.send(\"A\"); fileB.pipeTo(dc1.createWritable()); do2.send(\"C\"); // emits A, B0, B1, B2 ... Bend, C","msgtype":"m.text"},"ts":1540243004000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"uh s/do2/dc2/","msgtype":"m.text"},"ts":1540243027000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Is there some kind of indications on when the piping is complete?","msgtype":"m.text"},"ts":1540243063000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"it's closed()","msgtype":"m.text"},"ts":1540243072000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"pipeTo promise will settle","msgtype":"m.text"},"ts":1540243074000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1540243081000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1540243084000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Okay, good. Because otherwise the locking would be awkward","msgtype":"m.text"},"ts":1540243088000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"dc1.send(\"A\"); await fileB.pipeTo(dc1.createWritable()); do2.send(\"C\"); // emits A, B0, B1, B2 ... Bend, C","msgtype":"m.text"},"ts":1540243097000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Noob question, why is the last example do2/dc2, not dc1","msgtype":"m.text"},"ts":1540243117000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"cause I cut'n'pasted my earlier typo ;/","msgtype":"m.text"},"ts":1540243135000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"dc1.send(\"A\"); await fileB.pipeTo(dc1.createWritable()); dc2.send(\"C\"); // emits A, B0, B1, B2 ... Bend, C","msgtype":"m.text"},"ts":1540243140000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"OK but why dc2 instead of dc1","msgtype":"m.text"},"ts":1540243149000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"dc1.send(\"A\"); await fileB.pipeTo(dc1.createWritable()); dc1.send(\"C\"); // emits A, B0, B1, B2 ... Bend, C","msgtype":"m.text"},"ts":1540243154000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":":*)","msgtype":"m.text"},"ts":1540243157000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"OK now it makes sense","msgtype":"m.text"},"ts":1540243160000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Heh","msgtype":"m.text"},"ts":1540243161000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Hmm now I guess I see how no-locking might be fine if it's just a queue of stuff to do anyway","msgtype":"m.text"},"ts":1540243188000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"?","msgtype":"m.text"},"ts":1540243196000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"oh with await","msgtype":"m.text"},"ts":1540243205000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"well","msgtype":"m.text"},"ts":1540243207000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"What happens if I do:","msgtype":"m.text"},"ts":1540243225000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Yeah, it's a queue, but we shouldn't encourage people to fill it if we want to avoid backpressure","msgtype":"m.text"},"ts":1540243236000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"No yeah I'm starting to see the problems again","msgtype":"m.text"},"ts":1540243247000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"dc1.send(\"A\"); const p = fileB.pipeTo(dc1.createWritable()); dc1.send(\"C\"); await p; // should probably also emit A, B0, B1, B2 ... Bend, C","msgtype":"m.text"},"ts":1540243258000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"or gremlins","msgtype":"m.text"},"ts":1540243273000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Exception in your face","msgtype":"m.text"},"ts":1540243296000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Yeah there's no way to make that give the order you want I now realize","msgtype":"m.text"},"ts":1540243306000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"If you don't prevent dc1.send() while the piping is ongoing (i.e. while the writable stream is not-closed), then interleaving happens","msgtype":"m.text"},"ts":1540243334000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So yeah locking good","msgtype":"m.text"},"ts":1540243346000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think so","msgtype":"m.text"},"ts":1540243351000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Thanks for bearing with me :)","msgtype":"m.text"},"ts":1540243352000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"sure np!","msgtype":"m.text"},"ts":1540243358000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Btw, my slides are also going to claim that streams of streams make no sense","msgtype":"m.text"},"ts":1540243387000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"just running this by here first, to check","msgtype":"m.text"},"ts":1540243407000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Interleaving of messages on the same channel is actually being prevented by SCTP but... I still think locking makes more sense as users could get the wrong impression on order.","msgtype":"m.text"},"ts":1540243416000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Also makes it either to port to WebSocket later.","msgtype":"m.text"},"ts":1540243417000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"*easier","msgtype":"m.text"},"ts":1540243429000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"I'm not sure they make _no_ sense, but I can see how they wouldn't but you much, and it seems like you've found a nice cut point to introduce them that gets most (all?) of the benefits without disturbing everything","msgtype":"m.text"},"ts":1540243459000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think they would make sense if we would design a new API from scratch","msgtype":"m.text"},"ts":1540243497000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Unsure about that even","msgtype":"m.text"},"ts":1540243511000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"here's my thinking:","msgtype":"m.text"},"ts":1540243515000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Message semantics are appealing for multiple (heterogeneous) finite payloads.","msgtype":"m.text"},"ts":1540243521000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Stream semantics are appealing for single payload; outsourcing chunking & pressure.","msgtype":"m.text"},"ts":1540243527000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"A queue of streams is appealing to manage multiple discrete payloads of large size.","msgtype":"m.text"},"ts":1540243535000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"A “stream of streams” doesn’t add much over queue of streams; hurts: Competing semantics; Outsourcing chunking & pressure again hides messages.","msgtype":"m.text"},"ts":1540243541000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"I don't understand the hurts","msgtype":"m.text"},"ts":1540243582000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yes, shimming stream semantics on top of messages works in demos, but hijacks channel for single payload and loses control of messages. Stream semantics on top of streams has the same problem. A multi-payload quasi-stream as API isn’t a stream","msgtype":"m.text"},"ts":1540243591000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Isn't part of the value of a stream not having any semantic overload of its \"chunks\"?","msgtype":"m.text"},"ts":1540243620000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Like if someone is producing a stream of streams and wants to give it to a Web RTC consumer then making them go through a different API, and lose backpressure on their inner-stream production, seems sad","msgtype":"m.text"},"ts":1540243629000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Not sure exactly what you mean by that","msgtype":"m.text"},"ts":1540243647000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"The semantics of stream of stream hurts my head basically, not sure what it adds over queue of streams","msgtype":"m.text"},"ts":1540243720000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Backpressure and easy piping/interop with other streams-of-streams, I think","msgtype":"m.text"},"ts":1540243747000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(There are no other streams-of-streams yet of course)","msgtype":"m.text"},"ts":1540243757000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"nested backpressure?","msgtype":"m.text"},"ts":1540243777000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"I think it's just a different model. But in comparison to events, we can automatically handle backpressure across multiple messages. Say, if you would pipe a stream of messages from one data channel to another.","msgtype":"m.text"},"ts":1540243790000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"(where messages is another word for Stream<bytes>)","msgtype":"m.text"},"ts":1540243844000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"I thought we settled on sstream of bytes","msgtype":"m.text"},"ts":1540243850000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"*message","msgtype":"m.text"},"ts":1540243851000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1540243851000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Yeah nested backpressure :). Like if your inner-streams are files and your outer-stream is deciding whether to open new files from the filesystem, backpressure would tell you \"don't open a new file yet, I'm backed up processing the ones you already gave me\"","msgtype":"m.text"},"ts":1540243869000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Piping a whole directory","msgtype":"m.text"},"ts":1540243890000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"but why stream a queue?","msgtype":"m.text"},"ts":1540243955000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"because you can process more than one at a time?","msgtype":"m.text"},"ts":1540243988000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"I mean aren't all streams (async) queues? Just queues that you care about backpressure on?","msgtype":"m.text"},"ts":1540244017000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"the backpressure stuff makes sense to me for buffers, but my understanding falls apart for types without a predetermined length","msgtype":"m.text"},"ts":1540244051000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Well at that level the length of every file is \"1\"","msgtype":"m.text"},"ts":1540244093000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And it's a question of \"if I am backed up by 3 files then maybe don't open any more for me\"","msgtype":"m.text"},"ts":1540244103000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1540244105000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"I guess you could do actual file size stuff but I wasn't thinking of it that way","msgtype":"m.text"},"ts":1540244119000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Wow my internet is dying. Maybe a sign it's time to sleep.","msgtype":"m.text"},"ts":1540244129000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1540244137000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"ok thanks for the chat, it was very helpful!","msgtype":"m.text"},"ts":1540244156000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"\\o/","msgtype":"m.text"},"ts":1540244175000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think I'm going to stick with queue of streams for now, maybe my understanding will grow over time with that","msgtype":"m.text"},"ts":1540244196000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"A queue of streams might make sense for proxying websites for example","msgtype":"m.text"},"ts":1540244210000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"backpressure with bytes makes sense to me, e.g. \"ok we can handle 16000 more bytes please\"","msgtype":"m.text"},"ts":1540244345000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Imagine a fetch API that allows to queue fetch operations and move the body into the stream (I guess this could be easily written). That is essentially a Stream<Stream<bytes>>","msgtype":"m.text"},"ts":1540244374000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"but saying \"we can handle 5 more files\" hardly seems deterministic, because it all depends on file sizes","msgtype":"m.text"},"ts":1540244386000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1540244405000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"A requests page 1, 2 and 3. A is very slow in processing the data, though. B now uses that imaginary API to start fetching all pages but with automatic backpressure. B would only fetch the data as fast as A can process it and one after another.","msgtype":"m.text"},"ts":1540244454000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"ok maybe I'm focusing too much on the backpressure value. Maybe there's API value solely in being able to creates pipes out of these things","msgtype":"m.text"},"ts":1540244599000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Yeah, I believe so.","msgtype":"m.text"},"ts":1540244637000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"so what would stream of streams look like for RTCDataChannel?","msgtype":"m.text"},"ts":1540244679000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"The premise of pipeTo() seems to rely on other stream objects of similar type","msgtype":"m.text"},"ts":1540244725000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"or lots of clever transforms","msgtype":"m.text"},"ts":1540244735000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"That might lose a lot of people","msgtype":"m.text"},"ts":1540244753000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"case in point: promises","msgtype":"m.text"},"ts":1540244765000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"async/await is soooo much simpler to explain and get right, than promises","msgtype":"m.text"},"ts":1540244789000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"at least for me","msgtype":"m.text"},"ts":1540244802000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"It would have a .readable attribute of type ReadableStream<ReadableStream<bytes>> and a corresponding .writable attribute. Again, I would only suggest that for NV. I agree it's hard to wrap your head around and we need to find easy and convincing examples first.","msgtype":"m.text"},"ts":1540244845000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"I guess we can add that later, have both","msgtype":"m.text"},"ts":1540244896000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"or, hmm","msgtype":"m.text"},"ts":1540244908000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"I think it will be a while before we discuss NV APIs","msgtype":"m.text"},"ts":1540244927000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Or at least their final versions","msgtype":"m.text"},"ts":1540244948000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"tomorrow? ;)","msgtype":"m.text"},"ts":1540244952000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"Btw, when you say ReadableStream<bytes> with the < and > that's not any webidl syntax is it?","msgtype":"m.text"},"ts":1540244967000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"I'm not sure actually","msgtype":"m.text"},"ts":1540244985000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"I mean, 'bytes' is an abstraction anyway","msgtype":"m.text"},"ts":1540245001000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"sure","msgtype":"m.text"},"ts":1540245005000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"but byte is valid webidl","msgtype":"m.text"},"ts":1540245023000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"https://heycam.github.io/webidl/#idl-promise","msgtype":"m.text"},"ts":1540245054000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"They use Promise<T> so I guess we can use ReadableStream<T>","msgtype":"m.text"},"ts":1540245076000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"except there's no ReadableStream in https://heycam.github.io/webidl/#idl-promise","msgtype":"m.text"},"ts":1540245117000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"I would go that far and say this syntax is fairly well-known","msgtype":"m.text"},"ts":1540245199000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"But for actual WebIDL definitions...","msgtype":"m.text"},"ts":1540245214000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"it's not valid webidl, at least not yet","msgtype":"m.text"},"ts":1540245220000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"TimothyGu: https://github.com/servo/servo/pull/21882/files","msgtype":"m.text"},"ts":1540246859000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"jib: I'll get some sleep :)","msgtype":"m.text"},"ts":1540247208000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"jib: goodnight, thanks for your help!","msgtype":"m.text"},"ts":1540247230000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"uh","msgtype":"m.text"},"ts":1540247233000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"lgrahl: ^","msgtype":"m.text"},"ts":1540247251000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"is tired","msgtype":"m.emote"},"ts":1540247253000,"senderName":"jib","senderId":"jib@irc"},
{"content":{"body":"is so tired that he didn't even see the wrong mention","msgtype":"m.emote"},"ts":1540247286000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Domenic: yay!","msgtype":"m.text"},"ts":1540251303000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"}
]