[
{"content":{"body":"I wonder who thought making <object> a full-fleged form element was a good idea","msgtype":"m.text"},"ts":1495687451000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It has the 6 validity APIs, and a form attribute","msgtype":"m.text"},"ts":1495687478000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I guess in Web Apps 1.0 people still thought <object> might be a good thing, unifying iframe/img/applet/embed? Or maybe not, since they created audio/video?","msgtype":"m.text"},"ts":1495687542000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think it already was and Hixie didn't want to make things inconsistent","msgtype":"m.text"},"ts":1495688276000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Huh OK","msgtype":"m.text"},"ts":1495688291000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I wonder how that worked, back in the brief period where people were excited about implementing object","msgtype":"m.text"},"ts":1495688321000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Maybe some plugin actually created form data or something","msgtype":"m.text"},"ts":1495688327000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: there might have been some more love for <object> early on too, until the complexity was more unearthed","msgtype":"m.text"},"ts":1495688332000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: yeah, maybe, I don't know","msgtype":"m.text"},"ts":1495688362000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: spam: https://www.w3.org/Bugs/Public/show_bug.cgi?id=30114","msgtype":"m.text"},"ts":1495692470000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: thanks yeah saw that and banned them already","msgtype":"m.text"},"ts":1495692523000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith++","msgtype":"m.text"},"ts":1495692548000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wish I could lock our old components there against changes from new users","msgtype":"m.text"},"ts":1495692683000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"annevk: btw I am still not confident about my own understanding of “Main fetch” as far there being any default for the request mode when stepping through that algorithm","msgtype":"m.text"},"ts":1495692817000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: there's no default for request mode","msgtype":"m.text"},"ts":1495692836000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"what I wrote in https://stackoverflow.com/questions/44121783/fetch-api-default-cross-origin-behavior/44125919#44125919 I’m not sure myself that’s correct","msgtype":"m.text"},"ts":1495692847000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: fetch() has a default though","msgtype":"m.text"},"ts":1495692853000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1495692858000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"well see the part of that spec cited in that question:","msgtype":"m.text"},"ts":1495692888000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"> A request has an associated mode, which is \"same-origin\", \"cors\", \"no-cors\", \"navigate\", or \"websocket\". Unless stated otherwise, it is \"no-cors\".","msgtype":"m.text"},"ts":1495692890000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"that is what confused the OP","msgtype":"m.text"},"ts":1495692905000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"and me, really","msgtype":"m.text"},"ts":1495692909000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: ah, the default is different for fetch()","msgtype":"m.text"},"ts":1495692919000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"OK I figured so but I could not find where the spec expicitly says that","msgtype":"m.text"},"ts":1495692941000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: it might be worth removing the default for requests though that would require going through all downstream invocations","msgtype":"m.text"},"ts":1495692947000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"well I think that we should not change","msgtype":"m.text"},"ts":1495692969000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: https://fetch.spec.whatwg.org/#dom-request 5.5","msgtype":"m.text"},"ts":1495692976000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: folks continue to think (justifiably) that fetch() is fetch","msgtype":"m.text"},"ts":1495693026000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1495693033000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"but I think it is (relatively) clear and good, that when, e.g., the HTML invokes the fetch algorithm for, say, <script src> that gets called with mode: no-cors","msgtype":"m.text"},"ts":1495693068000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"right?","msgtype":"m.text"},"ts":1495693071000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"if so that I think we should not change","msgtype":"m.text"},"ts":1495693078000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"looks at https://fetch.spec.whatwg.org/#dom-request step 5.5.","msgtype":"m.emote"},"ts":1495693102000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"ah yes","msgtype":"m.text"},"ts":1495693105000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"> Set fallbackMode to \"cors\".","msgtype":"m.text"},"ts":1495693117000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"so yeah I remember now I assumed that is what was being hit","msgtype":"m.text"},"ts":1495693135000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"wil update that SO answer","msgtype":"m.text"},"ts":1495693185000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: for <script src> it should be \"no-cors\" yes, but we could also note that explicitly in HTML if we wanted to","msgtype":"m.text"},"ts":1495693245000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"OK yeah I may create a PR for that then","msgtype":"m.text"},"ts":1495693266000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: we'd have to find all call sites first","msgtype":"m.text"},"ts":1495693455000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"have done that before :)","msgtype":"m.text"},"ts":1495693468000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"but still dunno.. not sure it would be worth the time, if implementors don’t find it ambiguous or confusing","msgtype":"m.text"},"ts":1495693557000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: we could also add a note under request's mode that the effective default for fetch() and Request is \"cors\"","msgtype":"m.text"},"ts":1495693603000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: or maybe there's a better place to explain that the API and underlying abstraction are separate...","msgtype":"m.text"},"ts":1495693634000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I guess for HTML if we were to explain it, it should be at point of use and the points in the spec that define things that case fetches","msgtype":"m.text"},"ts":1495693739000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"I think that would be the most helpful to authors","msgtype":"m.text"},"ts":1495693749000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"and it seems like authors are the ones that would benefit from have it clarified, not implementors","msgtype":"m.text"},"ts":1495693788000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"anyway, not a high priority so maybe for now I will just raise an issue","msgtype":"m.text"},"ts":1495693817000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"I'm behind the times on Promises. What should I read to learn how to create my own Promises to return from a .then() processing a fetch-provided promise?","msgtype":"m.text"},"ts":1495701085000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: mdn? new Promise takes an init function that is passed a resolve and reject function, which you can use to fulfill the promise is the tl;dr","msgtype":"m.text"},"ts":1495701375000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah, the part I have trouble with, even after reading MDN, is: I do a bit of processing in then(), but what should I return to return and always-succeeding promise to continue the chain?","msgtype":"m.text"},"ts":1495701561000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"examples tend to focus on doing something with an API that returns a promise and not on how to continue the promise chain after the processing you wrote yourself","msgtype":"m.text"},"ts":1495701626000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"(of course, I missing something *very* basic, but what?)","msgtype":"m.text"},"ts":1495701644000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"maybe what I want is learning async/await right away and skipping over how things were like before them","msgtype":"m.text"},"ts":1495701766000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: If you just want the resulting promise to contain a value you obtain from doing stuff in the .then() callback, just return that value; it implicitly gets wrapped in a fresh Promise.","msgtype":"m.text"},"ts":1495701772000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"If you the \"stuff\" you're doing ends up with you holding another Promise, and you want the result of the .then() to contain what's inside of your \"other Promise\", again just return it - it automatically chains the internal value.","msgtype":"m.text"},"ts":1495701835000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: ooh. so magical.","msgtype":"m.text"},"ts":1495701879000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"The only time you ever have to create a new promise manually is if you're not currently in a promise and want to start one.  (Or you're using a legacy async api that doesn't return a promise, and want it to interoperate with a promise chain.)","msgtype":"m.text"},"ts":1495701902000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"hsivonen: It's just a functor/monad. ^_^","msgtype":"m.text"},"ts":1495701913000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: So I just \"return;\" from a .then() callback to return a promise than simply resolves?","msgtype":"m.text"},"ts":1495701914000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Yup.","msgtype":"m.text"},"ts":1495701918000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: thanks","msgtype":"m.text"},"ts":1495701927000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"If you just \"return;\" like that, then the resulting promise will resolve to undefined (your return value), but it will definitely resolve successfully.","msgtype":"m.text"},"ts":1495701951000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"aka:","msgtype":"m.text"},"ts":1495701970000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"let x = fetch(...).then(res=>doSomeWork()); => x is a promise holding the result of doSomeWork().","msgtype":"m.text"},"ts":1495702014000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: thanks. that was what I was missing","msgtype":"m.text"},"ts":1495702036000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"let x = fetch(...).then(res=>doSomeAsyncWork()); => x is a promise that will resolve when doSomeAsyncWork()'s promise resolves, to the same value.","msgtype":"m.text"},"ts":1495702047000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And if doSomeWork() throws, or the promise returned by doSomeAsyncWork() rejects, then x will reject as well.","msgtype":"m.text"},"ts":1495702108000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"annevk: are you going to be unreachable for two (?) months, or just not working? Also, when exactly are you getting back?","msgtype":"m.text"},"ts":1495715824000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: July 4, though week before that I should be available during Mozilla week","msgtype":"m.text"},"ts":1495722178000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: vacation, will likely drop in from time to time from past experience","msgtype":"m.text"},"ts":1495722234000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"should take a long vacation","msgtype":"m.emote"},"ts":1495722267000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"it takes me like 2 weeks to forget about work","msgtype":"m.text"},"ts":1495722278000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: OK, thanks. So for your specs, I was thinking to merge things that I think you'd accept, without waiting for explicit approval, while pinging you for things I'm unsure on. WDYT?","msgtype":"m.text"},"ts":1495722348000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Mostly I am thinking of in-flight PRs you have mostly accepted but are still going through editorial turns or discussions","msgtype":"m.text"},"ts":1495722377000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"all commit message should contain \"while the cats away...\"","msgtype":"m.text"},"ts":1495722378000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: sgtm","msgtype":"m.text"},"ts":1495722380000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hah","msgtype":"m.text"},"ts":1495722386000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hi, using HTML5lib python, how can I set the value of a tag attribute (let say href attribute of <a> tag) in a filter without HTML5lib escaping it?","msgtype":"m.text"},"ts":1495724306000,"senderName":"aleray","senderId":"aleray@irc"},
{"content":{"body":"gsnedders, ^^","msgtype":"m.text"},"ts":1495724465000,"senderName":"aleray","senderId":"aleray@irc"},
{"content":{"body":"wip: http://dpaste.com/18JF8PD","msgtype":"m.text"},"ts":1495724806000,"senderName":"aleray","senderId":"aleray@irc"},
{"content":{"body":"aleray: there's no way to do that","msgtype":"m.text"},"ts":1495726079000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"aleray: essentially, all the escaping is done by the serializer, and the filters can merely alter the contents of the tokens","msgtype":"m.text"},"ts":1495726174000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"jugglinmike: Ask jdm","msgtype":"m.text"},"ts":1495726684000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Erm","msgtype":"m.text"},"ts":1495726689000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"gsnedders, how could I do then? Working directly on the tree?","msgtype":"m.text"},"ts":1495726894000,"senderName":"aleray","senderId":"aleray@irc"},
{"content":{"body":"nox: are you in today?","msgtype":"m.text"},"ts":1495726899000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"In?","msgtype":"m.text"},"ts":1495726917000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"put differently: are you available to talk today (since jgraham tells me that it is a French holiday, and I assume that means you must be in France)?","msgtype":"m.text"},"ts":1495726971000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"I'm working on the `testharness.js` library in the Web Platform Tests project. I'd like to use Promises in that code, and jgraham has previously been reluctant about that. He suggested that this may interfere with Servo's ability to use WPT, so I wanted to learn more before committing any more time to that work","msgtype":"m.text"},"ts":1495727133000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"but if you are celebrating, then by all means enjoy. This can certainly wait","msgtype":"m.text"},"ts":1495727167000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"jugglinmike: (I can't rememeber if this is related to this question, but it isn't possible to make async_test serial by default. You could maybe make it opt-in)","msgtype":"m.text"},"ts":1495727193000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: nope, that's unrelated. This is about honoring promises returned from functions passed to `Test#add_cleanup`","msgtype":"m.text"},"ts":1495727238000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"Oh, right","msgtype":"m.text"},"ts":1495727262000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"I still don't know exactly what the problem is, but my guess is that we don't want all tests to suddenly start requiring the global Promise constructor. That way, consumers that don't define it could still run tests that don't technically need Promises","msgtype":"m.text"},"ts":1495727387000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"but it's to be expected that they would continue to fail those tests that do","msgtype":"m.text"},"ts":1495727411000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"jugglinmike: Which consumers still don't have Promises?","msgtype":"m.text"},"ts":1495727426000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"I don't know. If that is actually the issue that jgraham has in mind when he mentioned Servo, then I would assume Servo","msgtype":"m.text"},"ts":1495727474000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"jyasskin: I don't know if servo managed to integrate promises yet","msgtype":"m.text"},"ts":1495727497000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"https://github.com/servo/servo/issues/4282 is closed, indicating they have.","msgtype":"m.text"},"ts":1495727511000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"jugglinmike: my understanding is the goal of testharness is to be backwards compatible with older browsers whenever possible","msgtype":"m.text"},"ts":1495727545000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Actually, I do think that the general concern may still be relevant. I'm usually","msgtype":"m.text"},"ts":1495727551000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"tobie: yeah, that's the point I was just about to make ^","msgtype":"m.text"},"ts":1495727566000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"There are also polyfills that older browsers could stick in their testharnessreport.js.","msgtype":"m.text"},"ts":1495727591000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"If it will work in Servo I don't have any specific objections fwiw","msgtype":"m.text"},"ts":1495727593000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Practically speaking, though, there's nothing testharness.js can do to make tests that depend on Promises work in older browsers (short of including a polyfill)","msgtype":"m.text"},"ts":1495727616000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"which is not to say we shouldn't be careful","msgtype":"m.text"},"ts":1495727622000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"points out we fixed IE6 support only a year ago in testharness.js","msgtype":"m.emote"},"ts":1495727637000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"because there's still value for older browsers to blacklist tests that truly depend on un-implemented features","msgtype":"m.text"},"ts":1495727649000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"I'd argue that you shouldn't be slowed down by worrying about a lack of Promises in particular.","msgtype":"m.text"},"ts":1495727659000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"I don't consider testing N-1 level  browsers to be particularly interesting, but I do care about keeping servo's main testsuite working in servo (and same for latest Chrome, Firefox, Safari, Edge)","msgtype":"m.text"},"ts":1495727663000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"but that use case would be precluded if testharness.js assumed Promise as a matter of course","msgtype":"m.text"},"ts":1495727706000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"gsnedders: I think we did that because it happened to be trivial","msgtype":"m.text"},"ts":1495727708000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: right","msgtype":"m.text"},"ts":1495727717000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Anyway, I think there's an engineering tradeoff here","msgtype":"m.text"},"ts":1495727733000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"in general I'm against making changes that break testharness.js in old browsers unless the gain is notable","msgtype":"m.text"},"ts":1495727743000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"It depends on the value of this feature vs the cost","msgtype":"m.text"},"ts":1495727744000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"So to assess that we also need to know the value of the feature, not just the cost","msgtype":"m.text"},"ts":1495727767000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"The feature in question is extending `Test#add_callback` to honor promises returned by the provided function","msgtype":"m.text"},"ts":1495727885000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"jugglinmike: Right, but what's the use case?","msgtype":"m.text"},"ts":1495727901000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"It's important for Service Worker tests, where the cleanup logic typically includes an invocation of `ServiceWorkerRegistration#unregisiter`","msgtype":"m.text"},"ts":1495727945000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"jugglinmike: You can probably do that without mentioning the window.Promise object. Just check for and use the .then() method of whatever the provided function returns.","msgtype":"m.text"},"ts":1495727997000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"I'll say that lack of support here hasn't been an issue so far practically, but that lack of support makes a race condition of those tests","msgtype":"m.text"},"ts":1495727999000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"It's easier to do using Promise, but possible without it.","msgtype":"m.text"},"ts":1495728015000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"yeah, I've been thinking about that, too","msgtype":"m.text"},"ts":1495728030000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"I think the heavy lifting would come down to a custom Promise.all implementation, but that's not a difficult thing to implement","msgtype":"m.text"},"ts":1495728063000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"Although I'm not sure. It's been a while since I looked at my patch. I'm happy to try that","msgtype":"m.text"},"ts":1495728085000,"senderName":"jugglinmike","senderId":"jugglinmike@irc"},
{"content":{"body":"OK","msgtype":"m.text"},"ts":1495728091000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"gsnedders, what do you advise then?","msgtype":"m.text"},"ts":1495728737000,"senderName":"aleray","senderId":"aleray@irc"},
{"content":{"body":"It is unfortunate EdgeHTML was not based on Tasman but I guess by the time they realized they need it it was too late.","msgtype":"m.text"},"ts":1495736575000,"senderName":"Yuhong","senderId":"Yuhong@irc"},
{"content":{"body":"In the meantime they keep adding new \"modes\" on Trident with each new version of IE.","msgtype":"m.text"},"ts":1495736609000,"senderName":"Yuhong","senderId":"Yuhong@irc"}
]