[
{"content":{"body":"Hey folks o/","msgtype":"m.text"},"ts":1584452353000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Anyone up for a couple of Streams questions?","msgtype":"m.text"},"ts":1584452363000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Ping, err... Domenic","msgtype":"m.text"},"ts":1584453501000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"(lgrahl: generally it's good to ask the questions, then people can answer them async, when they're around)","msgtype":"m.text"},"ts":1584456132000,"senderName":"miketaylr","senderId":"miketaylr@irc"},
{"content":{"body":"Ok, then I'll dump my questions","msgtype":"m.text"},"ts":1584456208000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"tobie: heya, if you happen to be around, do you know if there's an issue logged about the HTML diff tool failing?","msgtype":"m.text"},"ts":1584456222000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"https://github.com/tobie/pr-preview/issues/51","msgtype":"m.text"},"ts":1584456241000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ah!","msgtype":"m.text"},"ts":1584456268000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"All APIs that I've seen are providing ReadableStream/WritableStream instances do not allow to provide a custom strategy. And I've also seen that WebSocketStream for instance uses a strategy with a desiredSize of 1.","msgtype":"m.text"},"ts":1584456289000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Since TransformStreams allow to add additional buffering, is it good practice to have as little buffering as possible when exposing a raw transport stream?","msgtype":"m.text"},"ts":1584456299000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Follow-up question: A TransformStream can safely use the default strategy where the desiredSize is 1 to avoid additional buffering, correct? But this still adds one additional chunk to the total pipeline buffer per additional TransformStream, or not?","msgtype":"m.text"},"ts":1584456410000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"annevk, Domenic: sorry I missed that issue, though I've been seeing the errors come in.","msgtype":"m.text"},"ts":1584457284000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"lgrahl: these questions are too much for my early morning brain. You might be best off filing them on whatwg/streams. I bet ricea knows the answers off the top of his head, when he's awake.","msgtype":"m.text"},"ts":1584457324000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Any chance he'll read it later? :)","msgtype":"m.text"},"ts":1584457781000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"I don't think he hangs out in this channel.","msgtype":"m.text"},"ts":1584457795000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Ok, thanks.","msgtype":"m.text"},"ts":1584457921000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Domenic, annevk: this seems to be related to a recent W3C update to TLS 1.3 that Heroku doesn't support. As noted in the issue (https://github.com/tobie/pr-preview/issues/51), I'm out of my depth and unsure how to move forward.","msgtype":"m.text"},"ts":1584460345000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":":( thanks for looking in to it...","msgtype":"m.text"},"ts":1584460359000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It's surprising that curl doesn't support TLS 1.3 either","msgtype":"m.text"},"ts":1584460374000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Yves Lafont is looking into it on the W3C side.","msgtype":"m.text"},"ts":1584460562000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"\\o/","msgtype":"m.text"},"ts":1584460569000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Ohhh, I am slightly less confused now, the deprecated versions of TLS are 1.0 and 1.1.","msgtype":"m.text"},"ts":1584460617000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So using TLS 1.3 is being cutting edge, not just non-deprecated.","msgtype":"m.text"},"ts":1584460635000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1584460640000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Now it makes more sense why things would break.","msgtype":"m.text"},"ts":1584460643000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Alright, annevk, others, this is now fixed (thanks to ylafon)","msgtype":"m.text"},"ts":1584461298000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Domenic: Perhaps a more simple... well, a question: I'm still confused by the multitude of ways to cancel/close/error a source/sink and I'm very much lost on when to use what. I can controller.close and controller.error a source but I can only controller.error a sink. Why is that?","msgtype":"m.text"},"ts":1584473677000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: the user of the writable stream sends the close signal.","msgtype":"m.text"},"ts":1584473751000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Whereas the creator of the readable stream sends the close signal.","msgtype":"m.text"},"ts":1584473761000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I'm not sure I understand, yet. Consider wrapping a WebSocket. I get a close event. What do I need to do? Should I error the sink (and why)? Should I close the source (probably)?","msgtype":"m.text"},"ts":1584473908000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Should I error the source if event.wasClean is false?","msgtype":"m.text"},"ts":1584473945000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"And should I error the sink if event.wasClean is false? I mean I've read through the spec but I still don't really understand what parts of the close signal of a bidirectional transport need to go where after having split it into a readable and writable side.","msgtype":"m.text"},"ts":1584474244000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"(Btw. this seems like a common issue for stream APIs. Python's asyncio also makes cancellation complicated when having split a transport into a StreamReader and StreamWriter. Unfortunately, I don't have a good solution other than good docs with good practices.)","msgtype":"m.text"},"ts":1584474472000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Domenic: ^","msgtype":"m.text"},"ts":1584474689000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: the close event comes from the server? Then yes, that's an error. You can no longer write, even though the user of the writable stream did not call writer.close().","msgtype":"m.text"},"ts":1584474738000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"https://streams.spec.whatwg.org/#example-both","msgtype":"m.text"},"ts":1584474768000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(Hmm, that example seem to overwrite onclose a few times, probably should be using addEventListener.)","msgtype":"m.text"},"ts":1584474826000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah, I noticed that, too. Sorry for not having filed an issue. :)","msgtype":"m.text"},"ts":1584474845000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"The thing is that I don't really see that this needs to be an error. Why can't the server close the connection intentionally? If the writer doesn't have any queued writes, this should not be an issue.","msgtype":"m.text"},"ts":1584474910000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Domenic: Okay, so, maybe I'll try to point to different things in the example instead: For the source, shouldn't it also check for event.wasClean and controller.error if it's false?","msgtype":"m.text"},"ts":1584475074000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"It is always an error in the streams contract when you can no longer write despite never having called .close()","msgtype":"m.text"},"ts":1584475098000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hrm, I guess that makes sense.","msgtype":"m.text"},"ts":1584475230000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Domenic: In WebSocketSource, should `this._ws.onclose = () => controller.close();` not be `this._ws.onclose = (event) => { if (event.wasClean) { controller.close() } else { controller.error(...) } };`?","msgtype":"m.text"},"ts":1584475372000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"In WebSocketSink, I don't understand why onclose is being rebound to null if the error event fired.","msgtype":"m.text"},"ts":1584475666000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"And then, finally, in WebSocketSink's abort method, should it really wait until closed?","msgtype":"m.text"},"ts":1584475715000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: I really have a hard time doing these sorts of evaluations synchronously while also doing my other work. I hope you can take these questions to the issue tracker to allow myself and others to better process them.","msgtype":"m.text"},"ts":1584475869000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Will do. Sorry - I know how hard it can be to get into a flow. :)","msgtype":"m.text"},"ts":1584476017000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1584476025000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"tobie: thanks so much!","msgtype":"m.text"},"ts":1584478748000,"senderName":"annevk","senderId":"annevk@irc"}
]