[
{"content":{"body":"i'd like to contribute again and i'm looking at https://github.com/whatwg/html/issues/4626 but i'm not sure what a \"WPT test\" is","msgtype":"m.text"},"ts":1559784886000,"senderName":"jolvera","senderId":"jolvera@irc"},
{"content":{"body":"nvm i just read the readme.md","msgtype":"m.text"},"ts":1559785041000,"senderName":"jolvera","senderId":"jolvera@irc"},
{"content":{"body":"jolvera: great, be sure to let this channel know if you run into issues","msgtype":"m.text"},"ts":1559798236000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: per https://w3c.github.io/ServiceWorker/#importscripts importScripts() will return a network error which I guess will result in a script error so we might have some of those on whatwg.org?","msgtype":"m.text"},"ts":1559809038000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: https://github.com/tc39/proposal-top-level-await/issues/79","msgtype":"m.text"},"ts":1559809549000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yep, I agree. I can't think of anything good you could do with top-level await in service workers","msgtype":"m.text"},"ts":1559809753000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: cool, I think littledan is open to making this change and hopefully nobody in TC39 cares too much about some agents not having it","msgtype":"m.text"},"ts":1559810008000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: though it reached stage 3 just now, so it'd be hard to block anyway :p","msgtype":"m.text"},"ts":1559810025000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"as an example of somewhere this might come up, if you want to use a WebAssembly module, it'd run into this restriction, since we like to give Wasm time to compile itself off the main thread","msgtype":"m.text"},"ts":1559810727000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"but I guess people could get around this by loading the Wasm module later, after initial startup (?)","msgtype":"m.text"},"ts":1559810759000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"JakeA: Does that sound reasonable to you? I'm happy to write this up in spec text if this is what we're agreeing on","msgtype":"m.text"},"ts":1559810795000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"Ideally a service worker is a Wasm module I think","msgtype":"m.text"},"ts":1559810866000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"littledan: how is the wasm imported into the service worker in this case?","msgtype":"m.text"},"ts":1559810886000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I was getting at, it could be with an import statement, with Wasm/ESM integration.","msgtype":"m.text"},"ts":1559810905000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"(which isn't implemented anywhere, but everyone seems to buy into it)","msgtype":"m.text"},"ts":1559810920000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"So `import wasmModule from './whatever.wasm'` - are you saying this uses top level await internally?","msgtype":"m.text"},"ts":1559810951000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: Yes, that's the proposal","msgtype":"m.text"},"ts":1559810959000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"JakeA: So Wasm \"compilation\" takes place when fetching/parsing ,but some engines (currently JSC, but maybe more in the future) do significant work when \"instantiating\", which happens in the ESM evaluation phase","msgtype":"m.text"},"ts":1559810995000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"JakeA: So, the spec is, \"in parallel, queue a task  to...\"","msgtype":"m.text"},"ts":1559811008000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: how is its use of `await` observably different from the parse time a regular script does when importing?","msgtype":"m.text"},"ts":1559811042000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I guess I'm trying to figure out what it means to use `await` 'internally'","msgtype":"m.text"},"ts":1559811085000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: Not sure what you mean by \"observably\". It's like, if you have one module which imports another, the dependency doesn't run its top-level statements until the inner `await` resolves","msgtype":"m.text"},"ts":1559811086000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"and then, at the top level, there's a concept of when we've asynchronously finished executing the module graph, rather than synchronously (but it's fine to ignore this--HTML doesn't use it for much)","msgtype":"m.text"},"ts":1559811114000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"JakeA: Here's a simple, silly example: https://github.com/tc39/proposal-top-level-await#solution-top-level-await","msgtype":"m.text"},"ts":1559811214000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: what if `import wasmModule from './whatever.wasm'` didn't use `await` internally, and it just waited. What would the observable difference be?","msgtype":"m.text"},"ts":1559811246000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"littledan: but those examples aren't an internal use of `await`, they're author-written","msgtype":"m.text"},"ts":1559811265000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"or have I misunderstood how `import wasmModule from './whatever.wasm'` is supposed to work?","msgtype":"m.text"},"ts":1559811289000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: Right, in the draft spec for Wasm modules, we *always* queue a task (for consistency), so if that module calls into JS from its start function, you can see the timing difference","msgtype":"m.text"},"ts":1559811324000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"smaug____ and others were pretty strong in encouraging consistency on whether we're queueing a task or just preceding synchronously (in an earlier draft, it was \"optional\")","msgtype":"m.text"},"ts":1559811369000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: consistency with what? (sorry I'm being dumb)","msgtype":"m.text"},"ts":1559811407000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: Among engines, or within an engine, what the timing will be","msgtype":"m.text"},"ts":1559811422000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: but if wasm modules consistently _didn't_ queue a task, would that be inconsistent with something else?","msgtype":"m.text"},"ts":1559811478000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: Well, it'd mean we're running compilation on the main thread, which isn't so great","msgtype":"m.text"},"ts":1559811679000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"not sure how deep you're interested in the details of why that'd happen","msgtype":"m.text"},"ts":1559811698000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"Working out these Wasm module interactions is why I got started on top-level await","msgtype":"m.text"},"ts":1559811734000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: Gotcha. I guess this relates more to https://github.com/tc39/proposal-top-level-await/issues/79#issuecomment-499402046 then. Allowing `import()` means you can kick off the import early but not be blocked by the compilation","msgtype":"m.text"},"ts":1559811790000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"right, I could imagine telling SW programmers, \"sorry, Wasm has to be done with import()\". I would be a little sad about that, but not the end of the world","msgtype":"m.text"},"ts":1559811849000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"JakeA: Is this what you're thinking?","msgtype":"m.text"},"ts":1559811873000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"JakeA: Or are you thinking, we do compilation on the main thread in this case, and off the main thread in that case?","msgtype":"m.text"},"ts":1559811890000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: The alternative is \"WASM can be imported statically within a service worker, but oh god please don't\"","msgtype":"m.text"},"ts":1559811895000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"littledan: Nah I wasn't thinking about switching to main thread compilation","msgtype":"m.text"},"ts":1559811945000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"well, I still have to learn more about SW to understand exactly how bad this is. This isn't the same order as waiting for network stuff, I think","msgtype":"m.text"},"ts":1559811964000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: The choice still feels like \"disallow it\" vs \"allow it but firefight people actually doing it\"","msgtype":"m.text"},"ts":1559811974000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"littledan: Service worker startup is never blocked on network stuff","msgtype":"m.text"},"ts":1559811987000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"littledan: except the very first time, but at that point the service worker isn't needed for an important event","msgtype":"m.text"},"ts":1559812009000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"OK, so, I'll draft up this text to prohibit async modules for serviceworkers and socialize it a bit, and we'll go from there","msgtype":"m.text"},"ts":1559812028000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"JakeA: Thanks for talking this through","msgtype":"m.text"},"ts":1559812034000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: When a service worker is first run, it's in an 'installing' state. It isn't in the blocking path for fetch/push/sync/etc events. At this point we take everything it imports via `importScripts` (we'd do the same with static imports) and cache them alongside the worker script. Then, when the service worker is in the middle of those important events, we just pull the imported scripts from disk (potentially precompiled). If","msgtype":"m.text"},"ts":1559812182000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"it tries to `importScripts` anything it hasn't already imported, it throws.","msgtype":"m.text"},"ts":1559812182000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"so, if we're importing something that's already cached in the SW, maybe it can be synchronous?","msgtype":"m.text"},"ts":1559812254000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"littledan: if it can be cached, yeah","msgtype":"m.text"},"ts":1559812284000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"littledan: but if one of the static imports `await`s a load of IDB work (for instance), which adds 100s if ms to the `fetch` event being dispatchable, that's what we want to avoid","msgtype":"m.text"},"ts":1559812327000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I see","msgtype":"m.text"},"ts":1559812347000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"of ms*","msgtype":"m.text"},"ts":1559812356000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah, I imagine TLA would be used for exactly that kind of thing","msgtype":"m.text"},"ts":1559812372000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"and when it's \"dispatchable\" is really about, when the module has run?","msgtype":"m.text"},"ts":1559812395000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1559812402000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"We can't dispatch it until `addEventListener('fetch', listener)` has had time to be called","msgtype":"m.text"},"ts":1559812434000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Which is once the script has run","msgtype":"m.text"},"ts":1559812448000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"looks like I'm gonna be updating the wiki this weekend, as our current version of MediaWiki is going EOL this month","msgtype":"m.text"},"ts":1559818472000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"<3 GPHemsley","msgtype":"m.text"},"ts":1559821268000,"senderName":"Domenic","senderId":"Domenic@irc"}
]