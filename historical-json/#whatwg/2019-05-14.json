[
{"content":{"body":"Personally Iâ€™d be fine with just new Image() doing so, but would like to know Jakeâ€™s thoughts as heâ€™s had the most feedback in that realm. Good call","msgtype":"m.text"},"ts":1557792171000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"annevk: where in the spec is the opaque origin assigned based on the sandbox flags?","msgtype":"m.text"},"ts":1557841109000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: it's bad speccing, but \"If the Document's active sandboxing flag set has its sandboxed origin browsing context flag set\"","msgtype":"m.text"},"ts":1557841754000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Once we get to the point where we know when to allocate a Document given a bunch of state, we should be doing this origin assignment there","msgtype":"m.text"},"ts":1557841811000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: because the determination of the agent cluster needs to be after that point..","msgtype":"m.text"},"ts":1557842051000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"That is why I have it in those steps after the application of the sandbox","msgtype":"m.text"},"ts":1557842102000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: well, the current setup is wrong","msgtype":"m.text"},"ts":1557842159000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ping for https://github.com/whatwg/html/pull/4473 green checkmark and/or opinions on multiplication operator typography","msgtype":"m.text"},"ts":1557842209000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"dtapuska: we should not be able to allocate a document without an agent and we should be able to determine an origin for an upcoming agent/global/document without creating a document first","msgtype":"m.text"},"ts":1557842237000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I agree, and I like your approach, but the question is how do we really get there. Chrome has a DocumentInit that we pass into the Document constructor, it really seems we need to specify that... and that the agent would be assigned in the construction of the DocumentInit..","msgtype":"m.text"},"ts":1557842251000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"as well as the opaque origin","msgtype":"m.text"},"ts":1557842258000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"Domenic: I guess I wonder if there is any style guide that other graphic specs use, but I'm prolly about to be disappointed","msgtype":"m.text"},"ts":1557842318000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: yeah, I discussed this other thing with Ian Clelland that I'm also running into now that we have this bunch of inherited state (CSP list, referrer policy, feature policy, base URL) that we really ought to copy when navigation begins (from whoever initiated) and then use when we create the document to default things that are not overridden","msgtype":"m.text"},"ts":1557842424000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"explicitly in case it's a document created by about:blank, srcdoc, blob:, data:, etc.","msgtype":"m.text"},"ts":1557842424000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: which is vaguely related, but different","msgtype":"m.text"},"ts":1557842444000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: I'll r+ given fserb said okay and it's an improvement","msgtype":"m.text"},"ts":1557842486000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"\\o/","msgtype":"m.text"},"ts":1557842513000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"dtapuska: Domenic: perhaps allocating the agents at the wrong point in time is an improvement indeed over waiting for proper documents, I'll have to think about that suggestion some more","msgtype":"m.text"},"ts":1557849095000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: Domenic: I hadn't really considered it so far since it doesn't help Cross-Origin-Opener-Policy, which requires replacing the browsing context","msgtype":"m.text"},"ts":1557849148000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ah yeah, that makes sense. To me it's all just a long backlog, and the more incremental progress we can make the better.","msgtype":"m.text"},"ts":1557850468000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I have a question about `fetch a module script graph`","msgtype":"m.text"},"ts":1557851238000,"senderName":"cybai","senderId":"cybai@irc"},
{"content":{"body":"I found the step 23 in https://html.spec.whatwg.org/multipage/#prepare-a-script said \"Let settings object be the element's node document's relevant settings object.\" and pass it to `fetch a module script graph` in step 24.6 for both classic and module scripts","msgtype":"m.text"},"ts":1557851290000,"senderName":"cybai","senderId":"cybai@irc"},
{"content":{"body":"However, in step 2 of https://html.spec.whatwg.org/multipage/#fetch-a-module-script-tree, we pass two `setting object` to `internal module script graph fetching procedure`","msgtype":"m.text"},"ts":1557851347000,"senderName":"cybai","senderId":"cybai@irc"},
{"content":{"body":"dtapuska: one thing that struck me is that it does not remove the same-site agent stuff, it seems it should be possible to remove that as agents are now explicitly allocated/selected, but admittedly I did not study in detail yet","msgtype":"m.text"},"ts":1557851402000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"We can know from the description of `internal module script graph fetching procedure`, the first setting object is `fetch client settings object` and the second one is `module map settings object`","msgtype":"m.text"},"ts":1557851410000,"senderName":"cybai","senderId":"cybai@irc"},
{"content":{"body":"Should we pass two different setting object from \"prepare a script\" step 24.6 instead?","msgtype":"m.text"},"ts":1557851438000,"senderName":"cybai","senderId":"cybai@irc"},
{"content":{"body":"Thanks ðŸ™‡","msgtype":"m.text"},"ts":1557851447000,"senderName":"cybai","senderId":"cybai@irc"},
{"content":{"body":"(will it be good to file an issue for this?)","msgtype":"m.text"},"ts":1557851604000,"senderName":"cybai","senderId":"cybai@irc"},
{"content":{"body":"annevk: ya I didn't know if we wanted to store the agent somewhere and that would make it easier.. I \"Obtain\" an agent but I don't stash it somewhere.. A same-agent window can just be defined as if the agent is the same object...","msgtype":"m.text"},"ts":1557851797000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: aah I see, I think we need to stash it as the same-site thing is broken when the browsing context is discarded or some such","msgtype":"m.text"},"ts":1557852040000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: though basically if you put it in the agent cluster you can always get it from there as itâ€™ll be the only agent for that key","msgtype":"m.text"},"ts":1557852099000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: only window agent","msgtype":"m.text"},"ts":1557852110000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: My idea is that there may be agent clusters not in the shared agent cluster table though","msgtype":"m.text"},"ts":1557852259000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"annevk: consider a policy as I proposed, a \"document-access\" policy basically puts a document in its own agent","msgtype":"m.text"},"ts":1557852284000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"so it doesn't need to go into the table.","msgtype":"m.text"},"ts":1557852296000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: those should not matter here as the lookup path is diff?","msgtype":"m.text"},"ts":1557852312000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Nor does the table contain the correct agent cluster.. if I look it up based on domain it might return something else","msgtype":"m.text"},"ts":1557852334000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"Why would the lookup path be diff.. it isn't an opaque origin","msgtype":"m.text"},"ts":1557852369000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"I was assuming that if there is a policy we would alter the key or look elsewhere","msgtype":"m.text"},"ts":1557852417000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Otherwise you end up with the same cluster","msgtype":"m.text"},"ts":1557852432000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Right I was thinking the policy could be implement as \"if policy set, return a new AgentCluster{ new Agent()}\" instead of looking at the table.. ie; basically a step inserted into \"obtain similar-origin window agent\"","msgtype":"m.text"},"ts":1557852548000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"that was why I called it \"shared agent clusters\" as opposed to \"list of all agent clusters\"","msgtype":"m.text"},"ts":1557852607000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"cybai|leave: for those cases, they are the same. The worker cases are where they are different.","msgtype":"m.text"},"ts":1557852635000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"cybai|leave: it's fine to file issues for questions like that, or ask here :).","msgtype":"m.text"},"ts":1557852660000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"dtapuska: sure, but when thereâ€™s no policy getting the agent from the bcgâ€™s agent clusters seems fine","msgtype":"m.text"},"ts":1557852828000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Yes it would be, but if we implemented a policy then it would be problematic, we'd need to stash it somewhere. Also a lookup might be expensive if we consider adding a rule around IsPlatformObjectSameOrigin to check that they are same-agent windows.","msgtype":"m.text"},"ts":1557853009000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: I suspect I can leave more considered design feedback tomorrow, but I donâ€™t really see why that is yet. Getting to an agent from a global should be really cheap and does not require a lookup","msgtype":"m.text"},"ts":1557853143000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Sounds good.. have a good evening","msgtype":"m.text"},"ts":1557853196000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: I was missing that as well, allocating globals in the agents rather than out-of-band","msgtype":"m.text"},"ts":1557853220000,"senderName":"annevk","senderId":"annevk@irc"}
]