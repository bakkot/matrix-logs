[
{"content":{"body":"annevk: Need to sanity check something. Imagine the following code `image = new Image(); image.src = \"https://example.com\" image.referrerPolicy = \"no-referrer\"`. This should send a request with no referrer header right?","msgtype":"m.text"},"ts":1563258194000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"Currently Firefox does not apply a Referer header, while Chrome has a full Referer. I believe Chrome is broken here?","msgtype":"m.text"},"ts":1563258302000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"I think the flow is like this, per spec: 1) Src is set, and #updating-the-image-data is invoked, queueing a microtask to finish the algo and fetch the image 2) Image's referrer policy is updated 3) The microtask is eventually run, referencing the latest `referrerPolicy` value of the image, fetching the resource","msgtype":"m.text"},"ts":1563258372000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"(eh, pretend my example is not missing a semicolon)","msgtype":"m.text"},"ts":1563258675000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: yeah seems like a bug in Chrome","msgtype":"m.text"},"ts":1563258834000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: So I think by that logic, the following would send a full referrer: `image = new Image(); image.src = \"https://example.com\"; queueMicrotask(() => { image.referrerPolicy = \"no-referrer\" })`","msgtype":"m.text"},"ts":1563259900000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: yeah, if the spec matches reality","msgtype":"m.text"},"ts":1563261886000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"The image spec hasn’t been maintained well unfortunately","msgtype":"m.text"},"ts":1563261923000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah :(","msgtype":"m.text"},"ts":1563261931000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"The above is correct in Chrome, but only because the first example fails (aka Chrome sends Referer more than it should)","msgtype":"m.text"},"ts":1563262040000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"But fails in Firefox (use Promise.resolve().then() instead of queueMicrotask)","msgtype":"m.text"},"ts":1563262063000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"oddly enoguh, even if you use setTimeout in Firefox (instead of Promise.resolve().then()) it still fails.","msgtype":"m.text"},"ts":1563262119000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"as in, the referrer is not sent when I think it should be. But oh well","msgtype":"m.text"},"ts":1563262134000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: does Fx support queueMicrotask? Also when does Fx include it?","msgtype":"m.text"},"ts":1563262377000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: oh, you're using Promise.resolve() because of lack of queueMicrotask support?","msgtype":"m.text"},"ts":1563262552000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yes","msgtype":"m.text"},"ts":1563262566000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"to your second question","msgtype":"m.text"},"ts":1563262574000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: it still failing with setTimeout is rather peculiar then, I guess that means it queues a task instead","msgtype":"m.text"},"ts":1563262598000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: and timers have higher priority","msgtype":"m.text"},"ts":1563262611000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah I guess it must","msgtype":"m.text"},"ts":1563262615000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"ahh","msgtype":"m.text"},"ts":1563262623000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: if you queue a timeout from a timeout, does that change it? Or versus postMessage()?","msgtype":"m.text"},"ts":1563262632000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: to be fair, queue a task for \"await a stable state\" as I mentioned in the PR would make more sense and is required for when you invoke that from \"in parallel\"","msgtype":"m.text"},"ts":1563262667000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: queueing a timeout from a timeout does not change it at least, request is still sent w/o a Referer.","msgtype":"m.text"},"ts":1563262817000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"annevk: Hmm, queue a task just to queue microtask, and finally continue in parallel?","msgtype":"m.text"},"ts":1563262897000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: it cannot be random which task a microtask ends up in","msgtype":"m.text"},"ts":1563262921000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: that's bad","msgtype":"m.text"},"ts":1563262929000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: True. At the same time, queueing a task I don't think is safe from a compat perspective, right I think it breaks existing behavior (my latest comment in response to yours in the PR thread)","msgtype":"m.text"},"ts":1563263019000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: haven't read that yet, but it seems from these results it's rather unclear what the processing model is","msgtype":"m.text"},"ts":1563263088000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"goes to the PR","msgtype":"m.emote"},"ts":1563263139000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: My assumption is that the only issue with #updating-the-image-data is that it calls \"await a stable state\", when it should instead be manually queueing a microtask.","msgtype":"m.text"},"ts":1563263169000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"That assumption (and the corresponding spec change) would not change current behavior, it is just sort of semantic","msgtype":"m.text"},"ts":1563263197000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: it would mean that the algorithm can only ever be invoked from the main thread, which does seem like a good thing to enforce really","msgtype":"m.text"},"ts":1563263233000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But assuming the intention is to have #updating-the-image-data to queue a microtask to continue the rest of the algorithm (which is basically what it currently does, just by using \"await a ...\" incorrectly), I do not think we can change that to a task w/o compat fallout","msgtype":"m.text"},"ts":1563263259000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: maybe we should note that for the ambiguous caller case that it would have to queue a task if it wasn't same thread","msgtype":"m.text"},"ts":1563263261000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: fair, but it seems that browsers don't queue a microtask? At least Firefox does something else","msgtype":"m.text"},"ts":1563263295000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: But do we have to cater to ambiguous caller cases, if there are none in the spec? (Aka, no invocations of #updating-the-... actually happen from an in-parallel context)","msgtype":"m.text"},"ts":1563263383000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"annevk: Ok true, browsers are obviously not doing this correctly, hence my two examples above :(","msgtype":"m.text"},"ts":1563263423000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: doesn't the spec have an ambiguous caller case?","msgtype":"m.text"},"ts":1563263499000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"\"A user agent that obtains images on demand must update the image data of an img element whenever it needs the image data\"","msgtype":"m.text"},"ts":1563263522000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"That's extremely vague","msgtype":"m.text"},"ts":1563263538000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: lol true I suppose, that's pretty bogus","msgtype":"m.text"},"ts":1563263557000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"annevk: Also, if we were to \"wait\" for some viewport condition to happen before we create the #concept-request, we're defer the URL parsing relative to the node (...) as late as possible. Are you not OK with that?","msgtype":"m.text"},"ts":1563264502000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"(same with the state of some of the attributes, i.e., crossOrigin, referrerPolicy)","msgtype":"m.text"},"ts":1563264524000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: yeah, URL parsing has side effects","msgtype":"m.text"},"ts":1563264610000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: this would be bad for blob URLs for instance","msgtype":"m.text"},"ts":1563264616000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: sorry, really don't know much about blob URLs. Could you elaborate?","msgtype":"m.text"},"ts":1563264688000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: the moment you parse a blob URL the returned URL record takes ownership of the underlying Blob object (so if the blob URL were to be revoked, fetching that URL record later would not fail)","msgtype":"m.text"},"ts":1563264744000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"domfarolino: (implementations have bugs here)","msgtype":"m.text"},"ts":1563264754000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Ah, so if we defer parsing, the blob URL could be revoked before parsing, and therefore fetching would fail in that case?","msgtype":"m.text"},"ts":1563264965000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: yeah","msgtype":"m.text"},"ts":1563264997000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: On https://github.com/whatwg/html/pull/4617  I wanted to define window agent not pulling in \"similar-origin\" because I want to be able to define some feature policy that forces separate agent allocations","msgtype":"m.text"},"ts":1563283612000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"So I tried to not have the \"similar-origin\" name in it.. And I wondered if all the references in the spec should be to the window agent, and however that is allocated is up to the similar-origin window agent algorithm","msgtype":"m.text"},"ts":1563283673000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"In terms of the \"has an associated agent\" that was my definition of a strong reference. Perhaps I'm not understanding how you mean a strong reference.","msgtype":"m.text"},"ts":1563283749000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: I don't think we need two types of window agents and I'd rather not rename the one we have for this refactoring","msgtype":"m.text"},"ts":1563283958000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: furthermore, an Agent Cluster holds a set of Agents, giving one of those Agents a special pointer seems inappropriate even if the window one is somewhat special","msgtype":"m.text"},"ts":1563284005000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: given how often we need to retrieve it simply retrieving the window type from the set seems fine","msgtype":"m.text"},"ts":1563284024000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Huh which Agent has a special pointer?","msgtype":"m.text"},"ts":1563284067000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: your agent cluster has a special pointer to the window agent","msgtype":"m.text"},"ts":1563284083000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yes it has a pointer to the \"one\" window agent","msgtype":"m.text"},"ts":1563284118000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: and it's also somewhat wrong as there are quite a few agent clusters that don't","msgtype":"m.text"},"ts":1563284122000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"The rest of agents in the agent cluster are all unique","msgtype":"m.text"},"ts":1563284129000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"So how do you get the window agent of the window cluster for the algorithm to return it?","msgtype":"m.text"},"ts":1563284159000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"I'd write it the way I wrote it in the original issue I think","msgtype":"m.text"},"ts":1563284181000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"At least, I remember it saying something like \"Return the similar-origin window agent of the agent cluster\"","msgtype":"m.text"},"ts":1563284201000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Which seems accurate enough until TC39 has created more precise language","msgtype":"m.text"},"ts":1563284219000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ok so generally leaving it a little undefined","msgtype":"m.text"},"ts":1563284254000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"I think that is fine.. because my feature policy thing was going to early out in obtaining an agent cluster","msgtype":"m.text"},"ts":1563284290000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: well, there's ever one agent of that type so it's not quite undefined I'd say","msgtype":"m.text"},"ts":1563284301000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"only ever*","msgtype":"m.text"},"ts":1563284319000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"And yeah, any kind of isolation would be at the agent cluster level","msgtype":"m.text"},"ts":1563284357000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"What about the definition of \"similar-origin window agent\" what do you think that would be like?","msgtype":"m.text"},"ts":1563284385000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: I guess I haven't quite thought through yet whether an Agent Cluster holding strong references makes sense, but I guess it does given how termination is supposed to work","msgtype":"m.text"},"ts":1563284445000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: I think ideally it doesn't hold realms and instead whenever we create a realm we add a pointer to the agent, as per the TC39 discussion","msgtype":"m.text"},"ts":1563284500000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: if we don't do that we'd need to start out with the empty set of realms and add the realms as they are created (and remove them at unclear times?)","msgtype":"m.text"},"ts":1563284545000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Right.. so it is just an Agent that can block is false. That really is it","msgtype":"m.text"},"ts":1563284551000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"Yeah, I don't think we have an opinion on the other fields","msgtype":"m.text"},"ts":1563284604000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(Well, and we enforce the set of realms to be Window objects with certain origins, but that's not really tied to creation.)","msgtype":"m.text"},"ts":1563284694000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Can we write some non-normative text around it, maybe a note indicating that the Realms that use this agent should all have the same origin and should be allocated via the obtain-similar-origin-window-agent algorithm?","msgtype":"m.text"},"ts":1563284715000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"s/same/similar","msgtype":"m.text"},"ts":1563284744000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: as a statement of fact without \"should\" that'd be fine","msgtype":"m.text"},"ts":1563284763000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: it's enforced elsewhere (primarily agent cluster selection I guess)","msgtype":"m.text"},"ts":1563284800000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ok; so I'll use \"will\" instead","msgtype":"m.text"},"ts":1563284865000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: \"all have ... and are allocated via ...\" would also work and is slightly nicer","msgtype":"m.text"},"ts":1563284945000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: One other thing related to \"shared agent clusters\".. I named it this way because when I allocate agent clusters based on a feature policy they won't end up in the \"agent cluster map\".","msgtype":"m.text"},"ts":1563286234000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"The agent cluster map seemed to indicate with the name that it would have all agent clusters","msgtype":"m.text"},"ts":1563286252000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"but perhaps that is just me","msgtype":"m.text"},"ts":1563286256000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: so where do you store them instead?","msgtype":"m.text"},"ts":1563286497000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: the key abstraction was meant to allow for storing all things there so they're also easy to find during teardown","msgtype":"m.text"},"ts":1563286540000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"They aren't stored for those documents that have the policy, they can't share data with anyone else.. so the strong reference from the global to the agent is the main thing that is holding onto the agent","msgtype":"m.text"},"ts":1563286574000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: at least all things that have similar-origin window agents","msgtype":"m.text"},"ts":1563286576000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: we might still have to let them go through the browsing context group though in some way so when they are created they get the appropriate COOP/COEP state","msgtype":"m.text"},"ts":1563286746000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: but maybe it's correct that nothing but the document needs to keep a reference (we'll have to be careful about defining the lookup for dedicated worker agent creation)","msgtype":"m.text"},"ts":1563286828000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'm not as deep into this as you two but it seems to me in an ideal world there should be a single \"reference root\", probably the UA, which then keeps things alive. With a general ownership structure of UA -> agent cluster -> agent -> realm <-> global. Not sure where BC groups/BCs fit in there though.","msgtype":"m.text"},"ts":1563286835000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"To be clear though I think having a perfect reference graph is pretty far down on the list of important things to formalize","msgtype":"m.text"},"ts":1563286872000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"domfarolino: BCG holds \"window\" agent clusters; UA holds shared/service worker agent clusters and BCGs","msgtype":"m.text"},"ts":1563286890000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: ^^","msgtype":"m.text"},"ts":1563286895000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: although there was a suggestion that a UA holds session history which holds TLBCs which are part of a BCG, which might be better once we get to session history","msgtype":"m.text"},"ts":1563286952000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"And yeah, it's not entirely clear to me how in dtapuska's model we'd tear down the agent cluster easily when the tab is closed, it seems we'd have to go hunt for it","msgtype":"m.text"},"ts":1563287024000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So I do think it's somewhat important to think this through, with the exception of session history although we should keep that in the back of our minds as well","msgtype":"m.text"},"ts":1563287062000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So can we have a list of all agent clusters, and a separate map of shared agent clusters?","msgtype":"m.text"},"ts":1563287073000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"I don't think we need that immediately in this PR, but leads to the \"shared agent cluster\" naming over \"agent cluster map\"","msgtype":"m.text"},"ts":1563287199000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: what did you think about my earlier idea? That we only have a map and the document with a feature policy ends up with a special agent cluster key","msgtype":"m.text"},"ts":1563287273000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Ya I thought about that too. But the question is what keying material you'd use that would be consistent for the document. You'd need to allocate some type of 'opaque origin' for agent cluster lookup that then the document could maintain I guess","msgtype":"m.text"},"ts":1563287541000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: key can be anything, so UUID or opaque origin or whatever would be fine","msgtype":"m.text"},"ts":1563287612000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"dtapuska: we could even use the Document object","msgtype":"m.text"},"ts":1563287626000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"No you can't use the Document object... the Agent is allocated *before* the document is created","msgtype":"m.text"},"ts":1563287646000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: oops, yeah, we'd have to generate a unique identifier","msgtype":"m.text"},"ts":1563287687000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But ya a \"agent cluster origin\"  could be defined as origin and if policy is set it becomes a opaque origin, and that is passed to the obtain similar-origin window agent algorithm.","msgtype":"m.text"},"ts":1563287739000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"To be clear, \"agent cluster key is an origin or a scheme-and-site\" is meant to be extensible if we have a need, it doesn't have to fit into this mold necessarily","msgtype":"m.text"},"ts":1563287811000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But opaque origin as key even though the agent does not have an opaque origin would certainly work, but we might wanna carefully explain what's going on there if we go down that route","msgtype":"m.text"},"ts":1563287868000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yup ok.. I don't disagree.. so I can change it back to \"agent cluster map\" then","msgtype":"m.text"},"ts":1563287872000,"senderName":"dtapuska","senderId":"dtapuska@irc"},
{"content":{"body":"dtapuska: maybe there should be some kind of lookup on a TLBC that falls back to a BCG so you can more eagerly collect when a TLBC is closed, but not observable so maybe not worth it, although maybe it is until we have remote WindowProxy; yeah it is observable that way…","msgtype":"m.text"},"ts":1563303556000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"o/ There was a cool web API overview page with links to all the specs but I forgot the URL. Maybe someone of you knows what I mean?","msgtype":"m.text"},"ts":1563311789000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Found it: https://platform.html5.org/","msgtype":"m.text"},"ts":1563311830000,"senderName":"lgrahl","senderId":"lgrahl@irc"}
]