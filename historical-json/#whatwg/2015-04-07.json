[
{"content":{"body":"oh jesus","msgtype":"m.text"},"ts":1428372124000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"now nvidia's page is doing clipboard hijacking","msgtype":"m.text"},"ts":1428372132000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"browsers just need to drop copy events and mask copies from pages, it's too abused","msgtype":"m.text"},"ts":1428372158000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"wanderview: reopened that bug","msgtype":"m.text"},"ts":1428386976000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: \"st\" goes to the spec here, Hixie's idea of subdomains for everything works kind of awesome in that respect","msgtype":"m.text"},"ts":1428387049000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"flash update is downloaded from fpdownload.macromedia.com ... :-)","msgtype":"m.text"},"ts":1428389270000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zewt: not providing pages those tools will have them insist on keeping Flash around :-(","msgtype":"m.text"},"ts":1428391593000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: put the revised version up on https://wiki.whatwg.org/wiki/Storage and included some examples of how it can be used with IDB and Cache","msgtype":"m.text"},"ts":1428400433000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Clearly I still fail at GitHub. I downloaded xml5_draft with the GitHub client and created a branch I intended to use for a pull request (also available as option in the client these days), but now it claims I have no permission... I'm guessing that means I didn't actually have permission to create the branch, but the pull request should work I think... At least, the repository seems to allow them.","msgtype":"m.text"},"ts":1428404996000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"If you don't have permission to access the upstream you have to create a branch in your fork and make the PR from that","msgtype":"m.text"},"ts":1428405054000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"But would the PR button then create a PR on my fork or the original one?","msgtype":"m.text"},"ts":1428405186000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"The UI could do all that for me though if it knows I don't have permission... But I guess we're not quite there yet.","msgtype":"m.text"},"ts":1428405215000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Against the original one","msgtype":"m.text"},"ts":1428405285000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"trying to spec a DOMMatrixInit where you can use either .a or .m11 but throw if they are both present with different values, becomes a bit messy. maybe i should only support .m11 for the dictionary?","msgtype":"m.text"},"ts":1428405322000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"https://gist.github.com/anonymous/a8931b3ebac8a418ca23","msgtype":"m.text"},"ts":1428405378000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"to fix https://lists.w3.org/Archives/Public/public-fx/2015JanMar/0119.html","msgtype":"m.text"},"ts":1428405453000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: that email talks about exposing a-f and m11-m44, but more interesting is what internal slots it has I think","msgtype":"m.text"},"ts":1428405710000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zcorpan: but I guess you might still want to initialize from a-f since it's more convenient","msgtype":"m.text"},"ts":1428405744000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: internal slots is m11-m44","msgtype":"m.text"},"ts":1428405754000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"annevk: yeah, that my thinking too","msgtype":"m.text"},"ts":1428405773000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"just needs more work for the impl","msgtype":"m.text"},"ts":1428405787000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: https://dom.spec.whatwg.org/#dom-mutationobserver-observe does a bunch of defaulting and throwing as well...","msgtype":"m.text"},"ts":1428405826000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zcorpan: initialization of an object is not where impl cost is though","msgtype":"m.text"},"ts":1428405848000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zcorpan: it's somewhat meticulous work, but not exactly hard","msgtype":"m.text"},"ts":1428405861000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: thx","msgtype":"m.text"},"ts":1428405871000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"annevk: and i flashblock by default ... not sure i buy the logic that we should give sites the tools to be obnoxious so they use our thing to be obnoxious instead of flash, heh","msgtype":"m.text"},"ts":1428412544000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"zewt: a lot of the sites that use it do it because users actually want that functionality as I understand it","msgtype":"m.text"},"ts":1428412655000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zewt: I agree that UAs should offer the ability to block clipboard access","msgtype":"m.text"},"ts":1428412669000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"if I select text and copy it, it should copy what i told it to and not add freaking ads to the end","msgtype":"m.text"},"ts":1428412704000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"even browser vendors don't always seem to understand that (address bar copying in firefox is a nightmare)","msgtype":"m.text"},"ts":1428412756000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"No disagreement there. I'm thinking about YouTube click-to-copy a link, and similar features elsewhere","msgtype":"m.text"},"ts":1428412779000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"the main annoying case is that pages can intercept when I copy selected text","msgtype":"m.text"},"ts":1428412837000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"(which I know is hard to completely prevent, but it's been made easier rather than harder lately iirc)","msgtype":"m.text"},"ts":1428412939000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"I think Firefox offers options to disable that kind of prevention entirely","msgtype":"m.text"},"ts":1428412977000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"i see dom.event.clipboardevents.enabled, but that seems like too big of a hammer","msgtype":"m.text"},"ts":1428413040000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"SimonSapin: what does https://github.com/servo/rust-url/blob/master/src/format.rs#L65 mean?","msgtype":"m.text"},"ts":1428414160000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it’s https://url.spec.whatwg.org/#url-serializing with the \"exclude fragment flag\"","msgtype":"m.text"},"ts":1428414221000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: ah okay","msgtype":"m.text"},"ts":1428414247000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"SimonSapin: I thought it was talking about URLs which can't have a fragment","msgtype":"m.text"},"ts":1428414270000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(which don't exist)","msgtype":"m.text"},"ts":1428414276000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1428414292000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: if a Rust function lacks an explicit return, is the last line returned?","msgtype":"m.text"},"ts":1428414438000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"SimonSapin: well, last expression looks like","msgtype":"m.text"},"ts":1428414460000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"the last expression, if it doesn’t end with ;","msgtype":"m.text"},"ts":1428414462000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"`if` and `match` are expressions","msgtype":"m.text"},"ts":1428414479000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"Because if it ends with ; I guess the last expression is empty?","msgtype":"m.text"},"ts":1428414518000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1428414527000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"; can be viewed as a separator rather than a terminator","msgtype":"m.text"},"ts":1428414545000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"I'm trying to figure out how to best approach this parser rewrite in a way that also allows me to tackle the issue of handling URLs such as test://relative/something better...","msgtype":"m.text"},"ts":1428414565000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"and the empty expression has type (), the empty tuple aka unit type","msgtype":"m.text"},"ts":1428414565000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"But perhaps rewriting it as functional first and then tackling that would be better","msgtype":"m.text"},"ts":1428414588000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: that sounds mostly orthogonal","msgtype":"m.text"},"ts":1428414600000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"as in, test://relative/something involves figuring out the data model, independently of the algorithm style","msgtype":"m.text"},"ts":1428414635000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: maybe, would be nice to have all the facts upfront :-)","msgtype":"m.text"},"ts":1428414636000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"changing fewer things at a time may also be easier both to do and to review","msgtype":"m.text"},"ts":1428414689000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"Yeah, that's certainly true","msgtype":"m.text"},"ts":1428414789000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"SimonSapin: such an interop drama that data model","msgtype":"m.text"},"ts":1428415144000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"SimonSapin: Chrome does resolve x against test://test/test \"correctly\", but reports a pathname of \"//test/x\"","msgtype":"m.text"},"ts":1428415166000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Safari splits it out in host and path","msgtype":"m.text"},"ts":1428415215000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: should we maintain the \"simple v1\" option next to this more complex option?","msgtype":"m.text"},"ts":1428421539000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: v1 would be to do less, but nothing that is incompatible I guess","msgtype":"m.text"},"ts":1428421562000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: afaict we can ship most of the methods independently","msgtype":"m.text"},"ts":1428421582000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: hmm... ok... I guess I just don't want the simple proposal to get caught up in bikeshedding the bigger proposal","msgtype":"m.text"},"ts":1428421613000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: what would you consider a reasonable v1? I could add a \"Rollout\" section that discusses this","msgtype":"m.text"},"ts":1428421666000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: v1: these methods; v2: the rest","msgtype":"m.text"},"ts":1428421677000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: or do you think we need to present it differently?","msgtype":"m.text"},"ts":1428421694000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think that would be reasonable... what you had for v1 before?","msgtype":"m.text"},"ts":1428421708000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: so everything but boxes?","msgtype":"m.text"},"ts":1428421734000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yea, I think so","msgtype":"m.text"},"ts":1428421787000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: https://wiki.whatwg.org/wiki/Storage#Rollout","msgtype":"m.text"},"ts":1428422018000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: annevk: does this address the concerns from yesterday? https://github.com/yutakahirano/fetch-with-streams/issues/30#issuecomment-90647469","msgtype":"m.text"},"ts":1428426280000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I think it effectively lets fetch steal the body from the original Request as it does today","msgtype":"m.text"},"ts":1428426342000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: you probably want to propose it without the shorthand syntax, or does that enable something that is lost on me?","msgtype":"m.text"},"ts":1428426577000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: you mean without Request.pipeTo()?  That is what enables Domenic's approach to see the consumer WritableStream directly","msgtype":"m.text"},"ts":1428426615000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"its a rename of what we were calling setWriter()","msgtype":"m.text"},"ts":1428426624000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: Domenic: I guess the thing I don't know how to handle with the WritableStream revealer function is a tee() or clone() done by fetch in order to handle redirects","msgtype":"m.text"},"ts":1428426768000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I haven't had time to read much before heading to lunch but I'll just say that largely the point of separating stream and reader was so we could have this tiered high level/low level access. Building in a third tier seems quite bad from that perspective. Everything body-related should be on the res.body stream.","msgtype":"m.text"},"ts":1428426893000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Alternately we could give up on separating the \"response\" and \"response body\" concepts and make Response subclass Readable(Byte)Stream","msgtype":"m.text"},"ts":1428426952000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: but... you're explicitly asking for something to bypass a body ReadableStream so you can see the consumer WritableStream directly...","msgtype":"m.text"},"ts":1428426960000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"But anyway more after lunch","msgtype":"m.text"},"ts":1428426985000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: we don't have to call it pipeTo()... I just thought that accurately described the semantics we talked about yesterday... provide a WritableStream sink and begin pushing data there","msgtype":"m.text"},"ts":1428426988000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"bye","msgtype":"m.text"},"ts":1428426999000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Anyone remember jsbell's GH handle?","msgtype":"m.text"},"ts":1428427517000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Oh found it","msgtype":"m.text"},"ts":1428427542000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"In related news: https://critic.hoppipolla.co.uk/r/4569","msgtype":"m.text"},"ts":1428427567000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"wanderview: ^","msgtype":"m.text"},"ts":1428427573000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: awesome!","msgtype":"m.text"},"ts":1428427736000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I guess I'll bow out until you guys find something","msgtype":"m.text"},"ts":1428428054000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think I share tyoshino's ideas","msgtype":"m.text"},"ts":1428428095000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm not sure where my idea conflicts with his... other than trying to do his \"operations\" ReadableStream idea... but I'm not sure how a wrapper really helps us here","msgtype":"m.text"},"ts":1428430932000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I wonder where JakeA is","msgtype":"m.text"},"ts":1428431138000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: dunno","msgtype":"m.text"},"ts":1428431157000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: what do you think of the formalizing of boxes I did? Was that what you had in mind?","msgtype":"m.text"},"ts":1428431181000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: I also added the examples you asked for how it would work with IDB and Cache","msgtype":"m.text"},"ts":1428431208000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: oh... I started to look at that and then got side-tracked... just a sec","msgtype":"m.text"},"ts":1428431445000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: hmm... would it be too magical if the name of a Cache or IDB matches a box name... then it is a box?","msgtype":"m.text"},"ts":1428431599000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I guess that would prevent multiple Cache object and IDBs in a single box","msgtype":"m.text"},"ts":1428431627000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: did you consider an API like StorageBox.add(caches.open(\"myCache\")) ?","msgtype":"m.text"},"ts":1428431678000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or StorageBox.add(indexedDB.open(\"myDB\"))","msgtype":"m.text"},"ts":1428431731000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I guess it depends on if we want to be able to move a DB or Cache into a box or not... and if we want to support that from an implementation side","msgtype":"m.text"},"ts":1428431802000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: There's a `bikeshed debug --print-exports` command that lists exported vs non-exported terms.  Note that only \"dfn\" type definition are unexported by default - all the rest automatically export unless you explicitly tell them not to.","msgtype":"m.text"},"ts":1428434342000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: do you think it would be useful to have the index section mark exported items somehow?","msgtype":"m.text"},"ts":1428434739000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"maybe it already adds a class and we just need to style it...","msgtype":"m.text"},"ts":1428434746000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: That's not useful information for a spec reader, so no.  I've wanted to expose that more naturally for bikeshed users, but haven't given it enough thought to figure it out.","msgtype":"m.text"},"ts":1428434807000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It seems useful information for anyone writing a spec based on yours","msgtype":"m.text"},"ts":1428434824000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: the name matching seems too magical, .add() seems somewhat nice","msgtype":"m.text"},"ts":1428435250000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: although it requires overloading of sorts on the boxes rather than the other APIs supporting boxes...","msgtype":"m.text"},"ts":1428435289000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: now that i read your thing it feels like it's just renaming .setWriter to .pipeTo, so I am less scared.","msgtype":"m.text"},"ts":1428435302000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: but yeah, should probably tweak that","msgtype":"m.text"},"ts":1428435313000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: any closer to a DOM PR?","msgtype":"m.text"},"ts":1428435321000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: btw, if it could become a single commit in the end that'd be great","msgtype":"m.text"},"ts":1428435339000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm like 1 hour of work away. I was just on vacation without internet for a week.","msgtype":"m.text"},"ts":1428435347000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: that'd avoid spamming Twitter a bunch","msgtype":"m.text"},"ts":1428435351000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"And yeah, no problem squishing the commits.","msgtype":"m.text"},"ts":1428435353000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: ah hope you had a blast","msgtype":"m.text"},"ts":1428435366000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I did!","msgtype":"m.text"},"ts":1428435372000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"BOARD GAME CRUISE THROUGH THE CARIBBEAN","msgtype":"m.text"},"ts":1428435381000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"That's a thing? Haha nice","msgtype":"m.text"},"ts":1428435447000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: i forgot to ask - did you play puerto rico?","msgtype":"m.text"},"ts":1428435451000,"senderName":"jamesr___","senderId":"jamesr___@irc"},
{"content":{"body":"jamesr___: No, it wasn't brought on board I think.","msgtype":"m.text"},"ts":1428435490000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i'm now interested in knowing what board games were played","msgtype":"m.text"},"ts":1428435516000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"terinjokes: Tons. There were about 300 on board, chosen by the ~150 people registered for the con. (It was a normal cruise ship, so the other 5k people on board were just normal cruise people.)","msgtype":"m.text"},"ts":1428435727000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I played, let's see...","msgtype":"m.text"},"ts":1428435732000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Pandemic: The Cure, Patchwork, Roll For The Galaxy, Caverna, Royals, Mysterium, Lords of Waterdeep, Castles of Burgundy, Far Space Foundry, Fleet, Xia, Key Market, Onirim, Abluxxan, and Istanbul.","msgtype":"m.text"},"ts":1428435783000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(I wrote down all of them.)","msgtype":"m.text"},"ts":1428435790000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"wow. i think of those I've only ever played Pandemic","msgtype":"m.text"},"ts":1428436004000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"terinjokes: Note that Pandemic: The Cure is a fast dice-based version of Pandemic.","msgtype":"m.text"},"ts":1428436023000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"been wanting to startup my project of doing a new game on some regular-ish time schedule. i should get back to doing that!","msgtype":"m.text"},"ts":1428436040000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"ah, then nope","msgtype":"m.text"},"ts":1428436048000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"(Like Roll For The Galaxy is a fast dice-based version of Race For The Galaxy.)","msgtype":"m.text"},"ts":1428436051000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"All of these were new to me, too, which was part of the point of the cruise. ^_^  We were scoping out a bunch of things we were interested in buying.","msgtype":"m.text"},"ts":1428436083000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"nice","msgtype":"m.text"},"ts":1428436286000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"annevk: Hm.. just ran into a fun issue with serialising our editor DOM to html. Comments.","msgtype":"m.text"},"ts":1428436828000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"createComment results in an invalid/unserializable DOM.","msgtype":"m.text"},"ts":1428436842000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"https://gist.github.com/Krinkle/1437de41481789ac6c96","msgtype":"m.text"},"ts":1428436849000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"We'll probably run html-escape (in addition to special entity scape for '-' so its xml compliant), and then someone decode that on the client side (using either a static map, or by parsing inside  a detached <textarea> and retreiving textcontent?)","msgtype":"m.text"},"ts":1428436978000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"it's weird to html escape a value before passing to createComment though","msgtype":"m.text"},"ts":1428436991000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"I'm not terribly surprised... just more in the category of mismatches between createXYZ() and the parser","msgtype":"m.text"},"ts":1428437456000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: One can basically insert arbitrary HTML in there, including <script>","msgtype":"m.text"},"ts":1428437609000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"In our case we're not actually appending to innerHTML, that's a terrible practice","msgtype":"m.text"},"ts":1428437708000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Just doing that for simplicity sake","msgtype":"m.text"},"ts":1428437715000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"(and destroys references etc.)","msgtype":"m.text"},"ts":1428437724000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"having some sort of text accessor on Comment nodes so that we can safely insert arbitrary user input into comment nodes would be useful.","msgtype":"m.text"},"ts":1428437954000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"And we'd have to either break createComment or create an alternate constructor.","msgtype":"m.text"},"ts":1428437966000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Some DOMs aren't serializable, that's not going to change","msgtype":"m.text"},"ts":1428438328000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: Interesting. Any other cases you have in mind?","msgtype":"m.text"},"ts":1428440212000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Krinkle|detached: there are several ways to use DOM to create unserializable documents.  It's not too strange.","msgtype":"m.text"},"ts":1428440821000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"For example, you can use DOM to insert an <a> child of an <a>, or have lone <tr>s floating around the document.","msgtype":"m.text"},"ts":1428440852000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: <a> inside <a> works fine in parsing though. Especially in XML.","msgtype":"m.text"},"ts":1428442911000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"It's not \"allowed\" but afaik works fine, no?","msgtype":"m.text"},"ts":1428442912000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Ah, interesting. It cuts off","msgtype":"m.text"},"ts":1428442941000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"No, \"<a>foo<a>bar</a></a>\" parses equivalent to \"<a>foo</a><a>bar</a>\".","msgtype":"m.text"},"ts":1428442949000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Yeah.","msgtype":"m.text"},"ts":1428442951000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"XML doesn't have special per-element parsing rules like the HTML parser does.","msgtype":"m.text"},"ts":1428442986000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Our content model ensures that doesn't happen though. We treat anchor links the same way as bold/italic/etc. as annotations instead of elements. Which apply to offsets in text nodes.","msgtype":"m.text"},"ts":1428442987000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"The tree is then created based on that.","msgtype":"m.text"},"ts":1428443011000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Sure, that's reasonable for an editor.","msgtype":"m.text"},"ts":1428443030000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I was just providing some examples of \"the DOM can produce something unserializable\".","msgtype":"m.text"},"ts":1428443055000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"but we visualise html comments (which some Wiki pages make heavy use of to leave info blurps to other editors) in our editor as <span>.","msgtype":"m.text"},"ts":1428443066000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"But ran into this issue where some editors leave comments including \"--\" in a regular English sentence.","msgtype":"m.text"},"ts":1428443082000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"and then subsequently, broke our serialisation :-/","msgtype":"m.text"},"ts":1428443097000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"You can escape all - chars inside of comments, I suppose.","msgtype":"m.text"},"ts":1428443109000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"No, that'll break viewing source.","msgtype":"m.text"},"ts":1428443128000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Replace them with unicode dashes. ^_^","msgtype":"m.text"},"ts":1428443133000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It needs to round trip :)","msgtype":"m.text"},"ts":1428443140000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"downstream reports are https://phabricator.wikimedia.org/T95039 and https://phabricator.wikimedia.org/T95040","msgtype":"m.text"},"ts":1428443172000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"It seems we're going to be encoding & - and >","msgtype":"m.text"},"ts":1428443201000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Replace every -- with an emdash - they can only occur when the user is in your editor, so that's fine, and you can even roundtrip it by translating back. (That'd make actual em-dashes not *quite* roundtrip correctly, but hey, those are rare.)","msgtype":"m.text"},"ts":1428443205000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Not rare if your user is a Wikipedian.","msgtype":"m.text"},"ts":1428443228000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":":P","msgtype":"m.text"},"ts":1428443232000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Domenic: has the performance impact of always returning a Promise from read() and write() been discussed somewhere?","msgtype":"m.text"},"ts":1428446306000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah. promises are cheap when well-optimized, and certainly cheaper than I/O.","msgtype":"m.text"},"ts":1428446343000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess I'm curious about how one optimizes out the object creation and the required async micro-task cost... it seems those are harder things to optimize out than say the generator object creation","msgtype":"m.text"},"ts":1428446426000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah you don't optimize out object creation, but VMs are good at creating objects. The micro-task cost we discussed and eventually landed on the fact that most reads are going to be async anyway, so the microtask adds no extra overhead.","msgtype":"m.text"},"ts":1428446486000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I mean.. I'm willing to accept Promise costs periodically... but once every 4096 bytes may be a bit much...","msgtype":"m.text"},"ts":1428446488000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: in the case where you have chunks buffered up... it seems like you would want to be able to get all of them synchronously, though... no?","msgtype":"m.text"},"ts":1428446519000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"right, that was the original design with while (rs.state === \"readable\") { rs.read(); }","msgtype":"m.text"},"ts":1428446544000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(read() being sync in that case)","msgtype":"m.text"},"ts":1428446558000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I vaguely remember that... what was the issue that forced the change?","msgtype":"m.text"},"ts":1428446571000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: a combination of wanting rs.readInto(buffer) + non-epoll streams who do their work in a threadpool or similar means you need something like async read(), or setAllocator","msgtype":"m.text"},"ts":1428446638000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: is ReadableByteStream or the new precise-flow-control stuff solving this by letting me say \"read up to this much data before resolving\"?","msgtype":"m.text"},"ts":1428446677000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Unclear how setAllocator would work though given that I/O is IPC though, now that I think about it","msgtype":"m.text"},"ts":1428446681000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I/O doesn't have to be IPC... you can open a file descriptor in the parent and then dup(2) it to the child process... then file reads are in the child process","msgtype":"m.text"},"ts":1428446718000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: the intent of ReadableByteStream's read(view) is that view.byteLength is at least a hint, although I think we didn't want to make it binding...","msgtype":"m.text"},"ts":1428446721000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: network is probably always in the parent process behind IPC, though (because of http 1.1 channels multiplexed on same socket, etc)","msgtype":"m.text"},"ts":1428446737000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: ah OK, just was thinking of the other day when you were talking about IPC costs...","msgtype":"m.text"},"ts":1428446739000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"my vision of read(view) was that you'd pass that view pretty directly to read(2)","msgtype":"m.text"},"ts":1428446765000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so for socket streams you might get back less than view.byteLength","msgtype":"m.text"},"ts":1428446775000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but for file streams, unless you're at end of file, you'll probably get view fully filled","msgtype":"m.text"},"ts":1428446787000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"IIRC read(2) has an option to not return until the buffer is filled ... but it doesn't work with nonblocking sockets?","msgtype":"m.text"},"ts":1428446820000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Ah no, it's recv(2). MSG_WAITALL","msgtype":"m.text"},"ts":1428446864000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"we could make the implementation concatenate buffers i guess? or let that be an option!? i don't see any reason why it's impossible, I was just going for the more direct mapping","msgtype":"m.text"},"ts":1428446967000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it's a latency vs. efficiency thing i guess, which perhaps is best to leave to applications to decide?","msgtype":"m.text"},"ts":1428447049000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"sorry, on phone","msgtype":"m.text"},"ts":1428447086000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"np","msgtype":"m.text"},"ts":1428447100000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"reminds me of this issue https://github.com/whatwg/streams/issues/171","msgtype":"m.text"},"ts":1428447115000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It is true in general that browser promise impls are wildly unoptimized. User-land versions regularly achieve 4x performance and 1/4th the memory consumption, and they don't even have access to all the tricks browsers do (like skipping the microtask queue if calling in from C++)","msgtype":"m.text"},"ts":1428447285000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I wonder if we could do something like .read(numDesiredChunks)","msgtype":"m.text"},"ts":1428447295000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"and the promise resolves when that many are available","msgtype":"m.text"},"ts":1428447304000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: that seems pretty reasonable. Would kind of want to see data that this was a bottleneck, or a non-performance use case, before doing so.","msgtype":"m.text"},"ts":1428447330000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I'll file an issue to track to see if anyone has non-perf use cases","msgtype":"m.text"},"ts":1428447367000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: it seems more appropriate for ReadableByteStream... but might be usable in ReadableStream","msgtype":"m.text"},"ts":1428447384000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: maybe for RBS it's .read(view, { waitUntilFull: true })","msgtype":"m.text"},"ts":1428447424000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: thinking of when you are reading some framed protocol... you probably don't want to get woken up until the next frame is completely there","msgtype":"m.text"},"ts":1428447426000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: I don't think c++ can skip the microtask, can it?  I mean.. it seems like it risks accidentally breaking the micro task guarantee in your API","msgtype":"m.text"},"ts":1428447469000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: it's hard to say precisely what I mean here as the area is so complicated. But the main idea is that C++ always enters back into JS from a clean stack, and that's what microtasks guarantee: a clean stack. One way of seeing this is that the very first thing done after transitioning from C++ to JS is to exhaust the microtask queue. So the very","msgtype":"m.text"},"ts":1428447595000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"first thing that happens on the JS side, after doing resolve_promise_from_cpp(cpp_p, cpp_v), is calling p's onFulfilled handler with v","msgtype":"m.text"},"ts":1428447595000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"IIUC SpiderMonkey doesn't actually implement a microtask queue and just uses their task queue, so maybe it is not so efficient in SpiderMonkey.","msgtype":"m.text"},"ts":1428447627000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: right... but its still an async runnable even if it skips to the head of the (micro)task queue","msgtype":"m.text"},"ts":1428447748000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"the spec says to drain the microtask queue between every regular task queue item","msgtype":"m.text"},"ts":1428447766000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"(if I read it correctly)","msgtype":"m.text"},"ts":1428447774000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"and I guess unwinding and rewinding the stack has noticeable perf impacts when done in too tight a loop","msgtype":"m.text"},"ts":1428447784000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"and after completing execution of a <script> element","msgtype":"m.text"},"ts":1428447817000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"I don’t believe it says to do anything on entry from C++ to JS","msgtype":"m.text"},"ts":1428447827000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"it might be you can do it like that and have no observable behavior difference but it is not obvious how offhand","msgtype":"m.text"},"ts":1428447872000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"in particular, you can exit JS to C++ and re-enter JS sometimes without having performed microtasks","msgtype":"m.text"},"ts":1428447900000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"othermaciej: hmm, maybe i am confused. But that was my interpretation of the spec, modulo the spec not having any \"entry from C++ to JS\" concept.","msgtype":"m.text"},"ts":1428447901000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Oh, that makes sense","msgtype":"m.text"},"ts":1428447921000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"this will occur if you have multiple event handlers for the same event, for instance","msgtype":"m.text"},"ts":1428447923000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"Or just arr.forEach(cb), where hypothetically forEach is implemented in C++.","msgtype":"m.text"},"ts":1428447941000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"the spec is closer to saying that microtasks are run on *exit* from JS to C++, except only if you are on a “clean stack”","msgtype":"m.text"},"ts":1428447976000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"where “clean” == in the top level event loop or in the html parser","msgtype":"m.text"},"ts":1428447986000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"and also it sometimes drains the queue on times you didn’t just exit from JS, in case right when you exited, you did not have a clean stack","msgtype":"m.text"},"ts":1428448017000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"that is how I understand it anyway","msgtype":"m.text"},"ts":1428448022000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"I guess the point I was really trying to make was: in Node.js, if you do `fs.readFile(..., result => resolvePromise(p, result))`, resolvePromise has to actually schedule a microtask to ensure p's handlers are called with a clean stack. So we wait for all the rest of the JS in that event loop turn to run, then unwind the stack, then run the microtask queue,","msgtype":"m.text"},"ts":1428448125000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"with several (perf-impacting) C++-to-JS transitions. Whereas in browsers, you don't have to pay that cost.","msgtype":"m.text"},"ts":1428448125000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"JS environments which try to completely control the event queue, like Angular, do similar optimizations","msgtype":"m.text"},"ts":1428448156000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"where they technically run their promise handlers \"sync\" but if you're programming correctly-according-to-Angular, it's unobservable.","msgtype":"m.text"},"ts":1428448202000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: are you trying to add an interface contract definition for ReadableStream and WritableStream in this issue?  https://github.com/whatwg/streams/issues/312","msgtype":"m.text"},"ts":1428449127000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: that thread has lost me a bit tbh...","msgtype":"m.text"},"ts":1428449169000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think it would be really helpful to have definitions of ReadableStream and WritableStream separate from the default implementation adapting JS functions","msgtype":"m.text"},"ts":1428449213000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: all ReadableStream instances must necessarily adapt JS functions (or JS manifestations of C++ functions)... other things obeying the \"readable stream contract\" might work differently though","msgtype":"m.text"},"ts":1428449284000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"the necessity is because myFetchReadableStream.read === myFileReadableStream.read, if both variables are ReadableStreams.","msgtype":"m.text"},"ts":1428449318000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so a DOM created ReadableStream representing some C++ implementation like a file stream has to be created through the ReadableStream Constructor?","msgtype":"m.text"},"ts":1428449346000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: why is myFetchReadableStream.read === myFileReadableStream.read a necessity?","msgtype":"m.text"},"ts":1428449384000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I mean, it has to obey the observable invariants; if there are tricks you have for getting around that, use them, but...","msgtype":"m.text"},"ts":1428449386000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: if they are both ReadableStreams then they have the same prototype and thus the same method","msgtype":"m.text"},"ts":1428449400000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: if one is a FetchReadableStream and another is a FileReadableStream then yeah they can be different","msgtype":"m.text"},"ts":1428449410000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: analogy---promises","msgtype":"m.text"},"ts":1428449418000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: all C++-created promises are, at least in V8/Blink, created \"via the Promise constructor\"","msgtype":"m.text"},"ts":1428449440000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess what I am saying is, it would be nice if the spec defined the observable invariants instead of making me try to dig them out of a pile of js","msgtype":"m.text"},"ts":1428449441000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"even though the promises will be backed by very different behavior","msgtype":"m.text"},"ts":1428449467000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yeah, agreed on that. We want that anyway so we can say---or better, programatically test---that ReadableByteStream behaves the same as ReadableStream.","msgtype":"m.text"},"ts":1428449503000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"the templated tests are a start","msgtype":"m.text"},"ts":1428449506000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so you are saying you want JS-created ReadableStream objects to have exactly the same prototype as DOM API created ReadableStream objects?","msgtype":"m.text"},"ts":1428449753000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah, exactly, just like Promise.","msgtype":"m.text"},"ts":1428449769000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: pretend I don't know much about Promise :-)","msgtype":"m.text"},"ts":1428449782000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hmm, well, then, yes. The underlying source is meant to provide the customization hooks","msgtype":"m.text"},"ts":1428449824000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"The underlying source could be a JS facade over a C++ object, for sure","msgtype":"m.text"},"ts":1428449852000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess then it would be nice to have a source interface definition... and separate out the js-adapter specifics into a separate implementation of that interface","msgtype":"m.text"},"ts":1428449870000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hmm what's a \"source interface definition\"?","msgtype":"m.text"},"ts":1428449890000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the underlying source","msgtype":"m.text"},"ts":1428449900000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"https://streams.spec.whatwg.org/#rs-constructor kind of tries","msgtype":"m.text"},"ts":1428449917000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"what are js-adapter specifics? there are no implementations of the underlying source interface in the streams spec","msgtype":"m.text"},"ts":1428449937000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"fetch-with-streams has one","msgtype":"m.text"},"ts":1428449949000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: nm... I don't think what I asked makes sense","msgtype":"m.text"},"ts":1428449991000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: do you anticipate things like ReadableStream.pipeTo() operating on the public ws.write() method?  so allowing monkey patching","msgtype":"m.text"},"ts":1428450053000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"the current text pointing at the ref implementation suggests it does","msgtype":"m.text"},"ts":1428450067000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"An implementation could always do something like ReadableStream.prototype.read = function () { switch (this@[[hiddenType]]) { case \"user-created\": return userCreatedImpl(this); case \"fetch\": return fetchStreamImpl(this); } }; where user-created follows more or less the exact spec algorithm and fetchStreamImpl manages to maintain all its observable invariants","msgtype":"m.text"},"ts":1428450093000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but is implemented differently.","msgtype":"m.text"},"ts":1428450093000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Then we have to tease out what the observable invariants are. I guess maybe that's what you're asking for.","msgtype":"m.text"},"ts":1428450121000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I'm asking about monkey-patching .write in this case","msgtype":"m.text"},"ts":1428450143000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"sorry I was still on the previous subject","msgtype":"m.text"},"ts":1428450150000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but I guess .read is the same","msgtype":"m.text"},"ts":1428450153000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: I think the \"underlying source\" model maps reasonably well to the DOM idiom of having an \"inner object\"","msgtype":"m.text"},"ts":1428450186000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hmm interesting","msgtype":"m.text"},"ts":1428450200000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but I guess DOM APIs typically operate explicitly on the inner objects... not on the public APIs","msgtype":"m.text"},"ts":1428450212000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Ah interesting","msgtype":"m.text"},"ts":1428450225000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so rs.pipe(ws) would do something like \"write data to ws's underlying sink\" instead of calling ws.write()","msgtype":"m.text"},"ts":1428450235000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"regarding monkey-patching write and pipeTo... I'm a bit torn on how to handle this. I've probably given up on it using `this.read()` etc.; it can use tamper-proof versions for operating on `this` to reduce complexity. But it seems quite important to allow polymorphic dispatch on the *argument*.","msgtype":"m.text"},"ts":1428450261000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the polymorphism is achieved in this spec by swapping out the underlying sink, no?","msgtype":"m.text"},"ts":1428450291000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"That said as we went through in some thread a while ago it's hard to make that work while still allowing unobservable off-main-thread piping","msgtype":"m.text"},"ts":1428450293000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: heh, I guess that is where my argument leads...","msgtype":"m.text"},"ts":1428450304000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: my hope was that you could create structurally similar writable streams that obey the same contract without being exactly WritableStreams","msgtype":"m.text"},"ts":1428450336000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: going to the inner objects is nice for DOM people like me... but I wonder if its not very javascripty","msgtype":"m.text"},"ts":1428450337000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Yeah, it's definitely not very JavaScriptey. But neither is off-main-thread piping :P","msgtype":"m.text"},"ts":1428450350000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: that seems at odds with requiring prototypes to be exact matches","msgtype":"m.text"},"ts":1428450356000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: nothing requires the prototypes to be exact matches, I was just saying, if they are, then they need to be the same impl","msgtype":"m.text"},"ts":1428450374000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: if you want pure duck types then I don't think we should require exact prototype matches","msgtype":"m.text"},"ts":1428450384000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: you *could* have separate FetchReadableStream that is written from scratch in its own spec and doesn't reference the stream spec at all, except trying to be duck-compatible.","msgtype":"m.text"},"ts":1428450402000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But that seems like a waste of effort.","msgtype":"m.text"},"ts":1428450408000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: like... I think the JS adapter stuff should be in a JSReadableStream that chains from ReadableStream, etc","msgtype":"m.text"},"ts":1428450414000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Anyway, my hope might be silly, is where I was going with that.","msgtype":"m.text"},"ts":1428450423000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"and there is no spec'd concrete implementation of ReadableStream","msgtype":"m.text"},"ts":1428450429000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"This just feels very silly when you go back to the promise analogy","msgtype":"m.text"},"ts":1428450455000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"We don't have every promise-returning API on the web platform creating their own version of the Promise class just so they can get different backing behavior","msgtype":"m.text"},"ts":1428450484000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I don't think we have the optimization concerns with off-main-thread piping, etc, with Promises that we do here...","msgtype":"m.text"},"ts":1428450488000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"something has to give here :-) I don't think all these requirements are compatible","msgtype":"m.text"},"ts":1428450535000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I am leaning toward abandoning duck-compatibility for writable streams","msgtype":"m.text"},"ts":1428450553000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: what about for ReadableStreams?","msgtype":"m.text"},"ts":1428450571000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: unsure, nothing accepts them right now (except their own methods, and JS functions which will operate on a duck level)","msgtype":"m.text"},"ts":1428450603000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: but their own methods will operate directly on underlying source?","msgtype":"m.text"},"ts":1428450625000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah, definitely.","msgtype":"m.text"},"ts":1428450636000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: is there an existing issue for this or shall I write a new one?","msgtype":"m.text"},"ts":1428450681000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: well, I was for a while planning on making pipeTo operate in terms of this.read() and friends, but after doing TeeReadableStream I am leaning away from that.","msgtype":"m.text"},"ts":1428450684000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think it was partially discussed in the transfer issue, but seems it deserves its own issue","msgtype":"m.text"},"ts":1428450701000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: we kind of got sidetracked in the ... web socket issue, was it? into these","msgtype":"m.text"},"ts":1428450705000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ah yeah","msgtype":"m.text"},"ts":1428450707000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I'll write one","msgtype":"m.text"},"ts":1428450715000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ok cool","msgtype":"m.text"},"ts":1428450718000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hmm, promises enable duck-compatibility with Promise.resolve casting .then'ables ..... that's a more sound model actually. Also a complicated one that we probably don't need to build in to the platform?","msgtype":"m.text"},"ts":1428450771000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It should be pretty straightforward to write a JS function duckReadableStreamToRealReadableStream","msgtype":"m.text"},"ts":1428450798000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Then people can use that if they need to","msgtype":"m.text"},"ts":1428450806000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I do think a ReadableStream wrapper constructor would be nice... making it take a duck typed stream would be reasonably","msgtype":"m.text"},"ts":1428450843000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"The promise-esque alternative being that we have ReadableStream.cast = duckReadableStreamToRealReadableStream and every ReadableStream-accepting API does ReadableStream.cast first (like all promise-accepting APIs do Promise.resolve first). Really unnecessary.","msgtype":"m.text"},"ts":1428450847000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"brb cafe closing!!","msgtype":"m.text"},"ts":1428450898000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"forgot he was in pacific time zone.","msgtype":"m.emote"},"ts":1428450913000,"senderName":"wanderview","senderId":"wanderview@irc"}
]