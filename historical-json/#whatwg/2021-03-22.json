[
{"content":{"body":"Does whatwg publish a machine-readable list of valid html names and attribute names anywhere?","msgtype":"m.text"},"ts":1616385282000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"And, actually, for enumerable attribute values for attributes like \"rel\" as well? I'm considering writing an HTML AST for Haskell in a standalone library.","msgtype":"m.text"},"ts":1616385581000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"And the thought occurs to me to just generate most of the code for it from a machine-readable spec (if one exists)","msgtype":"m.text"},"ts":1616385604000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"wroathe: no; see https://github.com/whatwg/html/issues/1246 for some discussion","msgtype":"m.text"},"ts":1616385912000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Thanks. Reading.","msgtype":"m.text"},"ts":1616385953000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Domenic: Hah. Looks like that design proposal never came through.","msgtype":"m.text"},"ts":1616386086000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Domenic: So what you guys would need is an expected format for the data then?","msgtype":"m.text"},"ts":1616386185000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Domenic: That indices table looks to be a good start, but I'm sure there are edge cases to account for","msgtype":"m.text"},"ts":1616386207000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"wroathe: well honestly what we'd need is someone to do the work of creating the data, then updating our tooling to generate the spec indices from the data","msgtype":"m.text"},"ts":1616386210000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Regarding edge cases, if you want those, then a machine-readable form is hopeless","msgtype":"m.text"},"ts":1616386225000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"See discussion in https://www.w3.org/Bugs/Public/show_bug.cgi?id=26491","msgtype":"m.text"},"ts":1616386237000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Before I dig in, do you have an example of an edge case that makes this hopeless right off the top of your head?","msgtype":"m.text"},"ts":1616386292000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"And thanks again, reading the bug discussion.","msgtype":"m.text"},"ts":1616386304000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"wroathe: just clicking around, trying to capture https://html.spec.whatwg.org/#attr-area-coords in a declarative form seems more or less hopeless","msgtype":"m.text"},"ts":1616386373000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It requires something more imperative so that you can do something like `if (in rectangle state) { let coords = splitAccordingToTrickyRules(coords attribute value); assert(coords.length === 4); assert(coords[0] < coords[2]); assert(coords[1] < coords[3]); }`","msgtype":"m.text"},"ts":1616386486000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Even simpler things like \"what attributes are valid\" is very hard for, e.g., <source>, since it depends on its ancestor tree","msgtype":"m.text"},"ts":1616386529000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Or what attributes are valid for <link> and <meta> depends on the value of other attributes","msgtype":"m.text"},"ts":1616386553000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah, so you'd need to pair some sort of machine-readable predicate along with an attribute, which would rapidly get tricky","msgtype":"m.text"},"ts":1616386673000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"if x is true, then attribute y is valid","msgtype":"m.text"},"ts":1616386692000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Man hours aside to work on this, I'm wondering if it still wouldn't be useful to generate a machine-readable index for the elements/attributes/categories/content models that aren't dependent on anything?","msgtype":"m.text"},"ts":1616386813000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"As sort of a version one, until some form of assertion syntax could be decided on for the trickier cases","msgtype":"m.text"},"ts":1616386839000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Anyway, I don't want to take up your time on this too much. Thanks for pointing me to some of the ongoing discussions around this.","msgtype":"m.text"},"ts":1616386877000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Yeah, IMO transposing the existing data from HTML table format into JSON and then generating the HTML tables from it would be useful","msgtype":"m.text"},"ts":1616387314000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Worthwhile, unclear. But useful, yes.","msgtype":"m.text"},"ts":1616387328000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Actually, for the complex cases I think I have a solution. There could be a table of \"named\" predicates in the spec that map a string identifier to a description of the algorithm, for example: in-video-or-audio: the element is in a video or audio element, and then in the machine-readable spec it could be \"contentAttributes\": [..., { \"attribute\": \"src\", \"validWhen\": \"in-video-or-audio\", ... }, ...]","msgtype":"m.text"},"ts":1616387549000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Domenic: So the logic itself wouldn't be contained within the machine-readable index, but an identifier for it would be","msgtype":"m.text"},"ts":1616387575000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Domenic: And then whomever is using it just needs to map that string to a validation routine that implements the logic","msgtype":"m.text"},"ts":1616387593000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Like a big hash table of predicates","msgtype":"m.text"},"ts":1616387621000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Domenic: And then attributes that are always valid for an element would then just omit that \"validWhen\" key","msgtype":"m.text"},"ts":1616387708000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"And to clarify on the above, I was thinking that \"in-video-or-audio: the element is in a video or audio element","msgtype":"m.text"},"ts":1616387805000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"\"","msgtype":"m.text"},"ts":1616387808000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"wouldn't be in the machine-readable spec, but in a table in the main spec","msgtype":"m.text"},"ts":1616387817000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"So that the only references you'd then find in the machine-readable spec would be identifiers like \"in-video-or-audio\" or \"in-picture\"","msgtype":"m.text"},"ts":1616387901000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"At that point I'd have to question what problem you're solving. If a human is in the loop already then the current spec has many years of working well for that.","msgtype":"m.text"},"ts":1616388028000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And if a machine is doing the work then imperative algorithms (validators/conformance checkers) similarly have a good track record.","msgtype":"m.text"},"ts":1616388059000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Such a hybrid approach doesn't seem to solve any common problem I'm aware of","msgtype":"m.text"},"ts":1616388074000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Well, the human would then only have to implement these predicates and store them in a hash table. After doing so you could then generate a validator with nothing but the information contained in the machine-readable spec and the predicate table you build","msgtype":"m.text"},"ts":1616388139000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"A machine-readable list of tags and attributes can be nice for e.g. a syntax highlighter or IDE auto complete, but conformance requirements in some hybrid format... I'm not seeing it.","msgtype":"m.text"},"ts":1616388140000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: And in my case I was thinking about including validation in my HTML AST for Haskell","msgtype":"m.text"},"ts":1616388154000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"I don't think that gives significant advantages over how validators are currently written.","msgtype":"m.text"},"ts":1616388172000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(Just my opinion)","msgtype":"m.text"},"ts":1616388212000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah, I was just trying to think through what might be the next step beyond \"just put the simple cases from that index table in a JSON file and omit anything complex\"","msgtype":"m.text"},"ts":1616388267000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"I think you'd need to have _something_ like this","msgtype":"m.text"},"ts":1616388280000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"Without this you'd then only be able to include the global attributes and \"type\" in contentAttributes for <source>. Everything else in the list is conditional, as you pointed out","msgtype":"m.text"},"ts":1616388354000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"So to take the next step you'd have to have some way of indicating that that set of conditions is","msgtype":"m.text"},"ts":1616388376000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"If it was really vital that there be absolutely no human involvement you could include that predicate table itself in the machine-readable spec with a pseudo-code of the implementation instead of just a description, and then consumers could generate code based on it. Or a shared library could be distributed that contains an implementation of the predicates, and a user could then link it into their program","msgtype":"m.text"},"ts":1616388524000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"and just call the appropriate predicates","msgtype":"m.text"},"ts":1616388530000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"(that shared library thing I mentioned probably wouldn't work, now that I think about it)","msgtype":"m.text"},"ts":1616388579000,"senderName":"wroathe","senderId":"wroathe@irc"},
{"content":{"body":"hi annevk! Reminding you about the FETCH/RT PR :) I saw that the HR-time PR is in, what else is missing?","msgtype":"m.text"},"ts":1616407061000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: thanks, I hope to have some time later today","msgtype":"m.text"},"ts":1616408586000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"interesting - and a bit disappointing - that fetch's Response has json() and not xml()/document() :-(","msgtype":"m.text"},"ts":1616418269000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"yoav: you were also going to do another pass, right?","msgtype":"m.text"},"ts":1616419774000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ondras: that's somewhat intentional, but the lack of a coherent alternative is not (the idea was to offer stream-based parsers fetch could feed into, but I suppose that never really garnered enough demand for someone to put sufficient time into it)","msgtype":"m.text"},"ts":1616419865000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: looking at the output of CI it seems there's several markup problems still","msgtype":"m.text"},"ts":1616420024000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: \"Not exactly. It's called when the steps are aborted, which also happens when there are no more bytes to read.\" is not true","msgtype":"m.text"},"ts":1616421161000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: in particular, once you hit","msgtype":"m.text"},"ts":1616421189000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"> Otherwise, if the bytes transmission for response’s message body is done normally and stream is readable, then close stream and abort these in-parallel steps.","msgtype":"m.text"},"ts":1616421191000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"you go straight to step 19 to return a response","msgtype":"m.text"},"ts":1616421199000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ah gotcha. So I need to queue responseDone also in that 'Otherwise'","msgtype":"m.text"},"ts":1616421346000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: Should I put the queuing of responseDone on the global task here, or is leaving it inside RT sufficient?","msgtype":"m.text"},"ts":1616421460000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: if taskDestination is a global that should be used I think","msgtype":"m.text"},"ts":1616421688000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"RT should not queue as that doesn’t give callers control","msgtype":"m.text"},"ts":1616421780000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ok, fixed fetch, xhr and resource-timing to reflect all we've just spoke.","msgtype":"m.text"},"ts":1616422016000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: i see, thanks for explanation","msgtype":"m.text"},"ts":1616422448000,"senderName":"ondras","senderId":"ondras@irc"},
{"content":{"body":"noamr: it still fails build on HTML validation","msgtype":"m.text"},"ts":1616424073000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: I'll wait for yoav to do a pass","msgtype":"m.text"},"ts":1616424084000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ok, on it","msgtype":"m.text"},"ts":1616424109000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"annevk:trying to debug the HTML validation. make deploy succeeds locally and the line numbers don't give a clue, but I think I'll figure it out.","msgtype":"m.text"},"ts":1616424109000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"yoav: do you know when hr-time will be auto-published? Might be worth asking MikeSmith; he converted a bunch of WebAppSec stuff (that did all use Bikeshed but I think the infra supports both)","msgtype":"m.text"},"ts":1616424273000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'll re-ping to just get it re-published","msgtype":"m.text"},"ts":1616424317000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"auto publishing requires me to send a WG CfC, it seems","msgtype":"m.text"},"ts":1616424339000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"I'll do that as well, but it'll take some time","msgtype":"m.text"},"ts":1616424356000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: there's a tool where you can autopublish on GitHub pages in a way that would allow us to index the editor's draft","msgtype":"m.text"},"ts":1616425036000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: the problem is that currently the editor's draft is partially a pile of script","msgtype":"m.text"},"ts":1616425067000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah, but it seems like I need WG consensus to do that","msgtype":"m.text"},"ts":1616425105000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"which I need to gather","msgtype":"m.text"},"ts":1616425118000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"annevk: fixed the HTML validation","msgtype":"m.text"},"ts":1616425120000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"yoav: huh okay","msgtype":"m.text"},"ts":1616425165000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Anyone with a Gitlab account want to file a bug at https://gitlab.com/inkscape/inbox/-/issues/ for not supporting https://resources.whatwg.org/logo-infra.svg?","msgtype":"m.text"},"ts":1616431474000,"senderName":"annevk","senderId":"annevk@irc"}
]