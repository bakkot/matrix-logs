[
{"content":{"body":"Domenic: ok... I have data that shows multiple read() calls with a promise each is much slower than being able to read buffered chunks synchronously","msgtype":"m.text"},"ts":1428539144000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: talking 30x slower and up... thats with bluebird promises (SM promises are worse, as expected)","msgtype":"m.text"},"ts":1428539298000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: open this and look in your console: https://blog.wanderview.com/streams-promise-read/bluebird.html","msgtype":"m.text"},"ts":1428539454000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"code is here: https://github.com/wanderview/streams-promise-read","msgtype":"m.text"},"ts":1428539499000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: needs I/O to be a real test","msgtype":"m.text"},"ts":1428539824000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":" All you are testing there is promises vs. loops","msgtype":"m.text"},"ts":1428539836000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Not the impact of promises on streams","msgtype":"m.text"},"ts":1428539899000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i wonder what middle-managery person at mozilla thought having a \"start a conversation\" button in the toolbar was a cool idea","msgtype":"m.text"},"ts":1428540151000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Domenic: its the case I described before... the I/O was done previously and written to a pipe... now a consumer is reading from a pipe to process it (perhaps all in memory)","msgtype":"m.text"},"ts":1428540816000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: this is the case you said \"needs citation\" above","msgtype":"m.text"},"ts":1428540830000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: from here:  http://logs.glob.uno/?c=freenode%23whatwg&s=8+Apr+2015&e=8+Apr+2015&h=citation#c944489","msgtype":"m.text"},"ts":1428540931000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I must have misinterpreted. That's not streaming at all... Just buffering.","msgtype":"m.text"},"ts":1428541919000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so buffering is not supported in this stream model?","msgtype":"m.text"},"ts":1428541975000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: a 1000-chunk high water Mark is unrealistic","msgtype":"m.text"},"ts":1428541982000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"of course it is, but you shouldn't use a stream when you're just buffering all data in memory anyway","msgtype":"m.text"},"ts":1428542006000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I'm not saying 1000 is realistic... but 10 chunks is a realistic bugger","msgtype":"m.text"},"ts":1428542031000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"buffer","msgtype":"m.text"},"ts":1428542033000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"A pipe should terminate in I/O on one side or the other","msgtype":"m.text"},"ts":1428542049000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I thought you were gone for the evening so I wrote my thoughts here: https://github.com/whatwg/streams/issues/320#issuecomment-91083647","msgtype":"m.text"},"ts":1428542072000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"If it takes x time to read from the pipe with promises, 0.04x time with batch, and 1000x time to put data in the pipe in the first place, I'm not too concerned.","msgtype":"m.text"},"ts":1428542119000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I kind of am gone, should probably turn off notifications :p","msgtype":"m.text"},"ts":1428542151000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I feel like we've pessimized a common case in order to allow an optimization in obscure case later","msgtype":"m.text"},"ts":1428542163000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I do not think chunks being synchronously generated in a batch is common.","msgtype":"m.text"},"ts":1428542190000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Chunks come from somewhere, ultimately, perhaps after several transforms, but ultimately from I/O. This example does not show that.","msgtype":"m.text"},"ts":1428542232000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Just read your comment... 6 ms is a lot... Absolute numbers help.","msgtype":"m.text"},"ts":1428542376000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Except... 625 microseconds is actually 0.6 ms","msgtype":"m.text"},"ts":1428542463000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Oh, it's per chunk","msgtype":"m.text"},"ts":1428542514000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: yea, sorry... I was trying to make the number easier to compare... so I normalized per chunk","msgtype":"m.text"},"ts":1428542565000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Although I wonder if the code is just not hot enough for the optimizer to kick in for 10 chunks","msgtype":"m.text"},"ts":1428542572000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Maybe do 10 chunks in a loop or something","msgtype":"m.text"},"ts":1428542582000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: well, the higher number loops suggest the sync loop optimizes much better than the promise loop can be optimized... not surprising","msgtype":"m.text"},"ts":1428542606000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Or ten chunks every requestAnimationFrame, since eating the frame budget is the real concern","msgtype":"m.text"},"ts":1428542615000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Yo, sorry for the digression, but random help here: it's a bad idea for an attribute to sometimes be updated sync and sometimes async, according to unknowable impl-specific criteria, right?","msgtype":"m.text"},"ts":1428542629000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I'm not concerned about the relative numbers (see my \"x\" comment above), but about eating 6 ms of frame budget","msgtype":"m.text"},"ts":1428542657000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"TabAtkins: sounds bad, although I could imagine cases that fit that description which are probably ok?","msgtype":"m.text"},"ts":1428542690000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: if we expect this only to happen for modest buffer sizes... I don't see how we can expect the loop to get super hot","msgtype":"m.text"},"ts":1428542745000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Well, the case is whether a FontFace.status is set to \"unloaded\" or \"loading\".  Currently it's always async, but jdaggett/heycam want it to be set syncly when possible (font is a data url, a blob url, a cached font, etc)","msgtype":"m.text"},"ts":1428542752000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Domenic: anyway, I have to go crash and sleep for 12 hours... talk to you tomorrow!","msgtype":"m.text"},"ts":1428542817000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Cached sounds skeevy.... Others sound somewhat reasonable","msgtype":"m.text"},"ts":1428542825000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: ok cool, I'll probably fork your thing and experiment","msgtype":"m.text"},"ts":1428542838000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: please do... just don't judge me by my javascript :-)","msgtype":"m.text"},"ts":1428542860000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: btw... looking at the results I think the jit kicked in at 100 chunks... there was an across the board improvement there... the sync loop got another boost from some optimization going from 1000 chunks to 10,000 chunks... but the promise loop did not","msgtype":"m.text"},"ts":1428542973000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"in spidermonkey of cours.e.. don't know what chrome does","msgtype":"m.text"},"ts":1428542983000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"TabAtkins: I think some of the normal zalgo hazards don't apply here because I can't see a way for code to be written that assumes always sync or always async","msgtype":"m.text"},"ts":1428543018000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: yeah, we need to make sure the code is hot before benchmarking. Kinda pointless to measure non hot code since it doesn't need to be fast.","msgtype":"m.text"},"ts":1428543075000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Cached I definitely see - easy for a dev to accidentally work with cached fonts, and write broken code for users.","msgtype":"m.text"},"ts":1428543099000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And I can see some browsers considering some types of urls as sync, while others dont'.","msgtype":"m.text"},"ts":1428543121000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: but what kind of code would run into this? I would think conditionals on ff.status would work in either case.","msgtype":"m.text"},"ts":1428543173000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Man, I dunno. It just feels super icky to have a line in a spec that says \"If you want you can do this part sync, lol i dunno\"","msgtype":"m.text"},"ts":1428543318000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Yeah, it would have to be normative which cases are sync","msgtype":"m.text"},"ts":1428543401000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: yea, you are right... let me add a call to the tests to prime the jit","msgtype":"m.text"},"ts":1428544250000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: I think I agree the read() promise is fast enough for browsers... but also agree with trevnorris that its probably inadequate for what node.js needs... not sure we can get something that works perfectly for both","msgtype":"m.text"},"ts":1428544905000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ok any opinions on naming? document.scrollingElement? document.viewportElement? https://lists.w3.org/Archives/Public/www-style/2015Apr/0108.html","msgtype":"m.text"},"ts":1428572979000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"document.viewportElement sgtm","msgtype":"m.text"},"ts":1428573309000,"senderName":"paul_irish","senderId":"paul_irish@irc"},
{"content":{"body":"thanks paul_irish","msgtype":"m.text"},"ts":1428573378000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"scrollingElement","msgtype":"m.text"},"ts":1428577958000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"viewportElement isn't correct","msgtype":"m.text"},"ts":1428577972000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"roc: it will be correct when webkit/blink have fixed scrollTop, no?","msgtype":"m.text"},"ts":1428578224000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"i guess background/overflow have different rules, but i think things would work as intended if this API is used for those also","msgtype":"m.text"},"ts":1428578457000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"mathiasbynens: wanna polyfill http://dev.w3.org/csswg/cssom-view/#dom-document-scrollingelement ?","msgtype":"m.text"},"ts":1428584543000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: sounds like fun! will do","msgtype":"m.text"},"ts":1428584685000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":":-)","msgtype":"m.text"},"ts":1428584702000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"Domenic: I am writing more tests","msgtype":"m.text"},"ts":1428594908000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"and it seems that I can construct if I pass undefined to the constructor","msgtype":"m.text"},"ts":1428594932000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"which should be equivalent to pass no arguments, right?","msgtype":"m.text"},"ts":1428594956000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"For optional arguments, yes","msgtype":"m.text"},"ts":1428595084000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"For required arguments, no","msgtype":"m.text"},"ts":1428595090000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"my new wordpress does have a valid rss feed but safari on iOS and OSX do not show the \"reader\" sign. any idea what might be wrong? http://mcnesium.com","msgtype":"m.text"},"ts":1428595714000,"senderName":"mcnesium","senderId":"mcnesium@irc"},
{"content":{"body":"in this case, the object can be constructed with no arguments, so we can assume argument is optional","msgtype":"m.text"},"ts":1428597420000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"can't we?","msgtype":"m.text"},"ts":1428597438000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"Domenic: do you know why the promise cases in the benchmark all take longer to settle than the sync cases?","msgtype":"m.text"},"ts":1428597480000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: is that just variability from runnables in the event queue?","msgtype":"m.text"},"ts":1428597490000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Ms2ger: ?","msgtype":"m.text"},"ts":1428597516000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"I guess it is not","msgtype":"m.text"},"ts":1428597597000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"because in myFunction(myArgument = {}) {} it is different to call myFunction() than myFunction(undefined)","msgtype":"m.text"},"ts":1428597653000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"no, it's the same thing","msgtype":"m.text"},"ts":1428597851000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"Domenic: can you explain again why we need async read() always on getReader()... instead of making getReader().read() sync and getByobReader.read() async?","msgtype":"m.text"},"ts":1428601551000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"sorry... I know you've explained before","msgtype":"m.text"},"ts":1428601561000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"dunno his reasons, but if it's sometimes sync and sometimes async, that's not great for usability","msgtype":"m.text"},"ts":1428602066000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"caitp-: no... its only async if you explicitly opt-in to the \"bring my own buffer\" optimization... and then its always async","msgtype":"m.text"},"ts":1428602651000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yes, and then if you pass that reader to something that doesn't know you brought your own or not, it may or may not be async","msgtype":"m.text"},"ts":1428602676000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"caitp-: that reader has its own type... they are not compatible with each other already","msgtype":"m.text"},"ts":1428603515000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"if they can be used the same way, you can probably expect that they would be","msgtype":"m.text"},"ts":1428604749000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"caitp-: agree in principal, but not sure if its worth baking a performance penalty into getReader() just to satisfy aesthetic similarity to getByobReader()","msgtype":"m.text"},"ts":1428605388000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"i'm sure domenic's reasons are better ones","msgtype":"m.text"},"ts":1428605423000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"or at least, he's probably spending more time thinking about it =p","msgtype":"m.text"},"ts":1428605445000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"hmm... does chrome has something like URLSearchParams?","msgtype":"m.text"},"ts":1428615377000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"doesn't look like it","msgtype":"m.text"},"ts":1428615550000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"well, \"something like\", probably just a JSObject","msgtype":"m.text"},"ts":1428615571000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"not even a JSObject","msgtype":"m.text"},"ts":1428615698000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"not exposed on the interface, and no TODO. should file :o","msgtype":"m.text"},"ts":1428615708000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"i guess it is filed","msgtype":"m.text"},"ts":1428616039000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"yea... I guess that part of the URL spec just needs to be implemented","msgtype":"m.text"},"ts":1428616282000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Is there some way to tell if the origin of a page changed at some point (i.e. that document.domain was set)","msgtype":"m.text"},"ts":1428616374000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"there's no event triggered in the setter algorithm, or anything","msgtype":"m.text"},"ts":1428616715000,"senderName":"caitp","senderId":"caitp@irc"}
]