[
{"content":{"body":"jyasskin: that seems correct. In general putting nullable things in dictionaries is very questionable, as they're already optional so using `null` as a signifier is not great.","msgtype":"m.text"},"ts":1475301064000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I agree that nullable things in dictionaries is sketchy, but why does that paragraph allow nullable interfaces, enumerations, callback functions and typedefs but disallow just nullable dictionaries? Even stranger, if you typedef the dictionary, you can now make it nullable?","msgtype":"m.text"},"ts":1475306646000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"Was there an attempt to constrain WebIDL to only syntactic checks instead of including semantic constraints?","msgtype":"m.text"},"ts":1475306701000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"That would match bz's preference to put the OpenDictionary key-type constraints in the grammar.","msgtype":"m.text"},"ts":1475306740000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"I don't understand how that would be possible, or at least sensible... e.g. what if I do typedefs","msgtype":"m.text"},"ts":1475336019000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I guess even the semantic checks disallow typedefs right now as written?","msgtype":"m.text"},"ts":1475336037000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"can we get HTMLHyperlinkElementUtils.fragment returning '#' when url.href.substr(-1) === '#' and '' when url.href.substr(-1) !== '' ? :P","msgtype":"m.text"},"ts":1475341438000,"senderName":"Netmo","senderId":"Netmo@irc"},
{"content":{"body":"also, hi all","msgtype":"m.text"},"ts":1475341447000,"senderName":"Netmo","senderId":"Netmo@irc"},
{"content":{"body":"* !== '#'","msgtype":"m.text"},"ts":1475341472000,"senderName":"Netmo","senderId":"Netmo@irc"},
{"content":{"body":"Netmo: that seems likely to break a lot of sites, so probably not","msgtype":"m.text"},"ts":1475341761000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"indeed, asking for an alias that behaves that way, .hash and .fragment would behave the same, except that bit","msgtype":"m.text"},"ts":1475341800000,"senderName":"Netmo","senderId":"Netmo@irc"},
{"content":{"body":"https://xkcd.com/927/","msgtype":"m.text"},"ts":1475341855000,"senderName":"Netmo","senderId":"Netmo@irc"},
{"content":{"body":"or, boolean HTMLHyperlinkElementUtils.isEmptyHash or something","msgtype":"m.text"},"ts":1475341918000,"senderName":"Netmo","senderId":"Netmo@irc"},
{"content":{"body":"It seems pretty easy to write a JavaScript function to take care of this. No need to standardize, get agreement from all browsers, and ship extra code to every web page in the world.","msgtype":"m.text"},"ts":1475342155000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"makes sense. i see you guys are spending a lot of effort trying to normalize existing stuff, rather than adding more","msgtype":"m.text"},"ts":1475342476000,"senderName":"Netmo","senderId":"Netmo@irc"},
{"content":{"body":"actually makes sense, dom is already full of redundancies","msgtype":"m.text"},"ts":1475342499000,"senderName":"Netmo","senderId":"Netmo@irc"},
{"content":{"body":"There's definitely a place for new stuff, but ideally when it adds genuinely new capabilities to the platform, or drastically increases effectiveness or similar via a better API.","msgtype":"m.text"},"ts":1475362259000,"senderName":"Domenic","senderId":"Domenic@irc"}
]