[
{"content":{"body":"annevk: ah, sorry, irccloud had logged me out and I hadn't noticed","msgtype":"m.text"},"ts":1611316561000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: wb ðŸ™‚","msgtype":"m.text"},"ts":1611316704000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: so for that WPT PR I'm mainly looking for ideas","msgtype":"m.text"},"ts":1611316730000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: one thing that came to mind is that I could create a Python file per scenario that imports the wav file somehow for the majority of the logic, if we don't want to put everything in the wav file, but none of it seems particularly elegant","msgtype":"m.text"},"ts":1611316791000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I'm also having trouble determining what state the media element should end up in once things fail or succeed, but perhaps observing the network traffic is sufficient for now...","msgtype":"m.text"},"ts":1611316836000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I've usually used query params to handle a lot of that stuff, but I don't know how that'd fit in this case","msgtype":"m.text"},"ts":1611316837000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so the problem with query params is that I need the URL to remain mostly static (unless I explicitly want to change it) as we (plan to) compare the URL in the spec","msgtype":"m.text"},"ts":1611316888000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: one thought I had was to base64 a JSON object that encodes scenarios and put that in a param though","msgtype":"m.text"},"ts":1611316909000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: that would work as it'd be the same as the token, just a static unchanging thing","msgtype":"m.text"},"ts":1611316937000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But maybe I should just write some tests with a switch/case in the wav file and try to abstract things later...","msgtype":"m.text"},"ts":1611317012000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hi","msgtype":"m.text"},"ts":1611318779000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"When linking to a HTML5 <video> with https://video.mp4#t=10,15 it works fine in recent popular browsers, but only when the video is not already playing.","msgtype":"m.text"},"ts":1611318798000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"Does anyone know if there's a standard emerging/planned to do this with videos already playing to do seek jumps? Something like href=\"#my-video-element-id?t=10,15\" would be awesome. I couldn't find anything (just solutions that require javascript).","msgtype":"m.text"},"ts":1611318822000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"rigid: not aware of anything, you could propose it to https://wicg.io/","msgtype":"m.text"},"ts":1611318962000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ehrm, i'm no expert. i'll probably do it wrong :)","msgtype":"m.text"},"ts":1611319059000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"annevk: but i'll try. thank you.","msgtype":"m.text"},"ts":1611319068000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"rigid: https://whatwg.org/faq#adding-new-features has tips","msgtype":"m.text"},"ts":1611319096000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ah, was just about to search for that. awesome!","msgtype":"m.text"},"ts":1611319111000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"rigid: The tricky part is figuring out how this would work without JavaScript. You'd need some kind of input/link that targets a particular media element.","msgtype":"m.text"},"ts":1611319206000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: naively i'd think it would be quite easy to implement. with javascript, one just sets the \"currentTime\" attribute to \"HH:MM:SS.MMM\" of the <video> element. If a browser could replicate this by parsing href=\"#video_element?t=HH:MM:SS.MMM\", it's done.","msgtype":"m.text"},"ts":1611319435000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"i could imagine that in practice it'd be _much_ more complex :)","msgtype":"m.text"},"ts":1611319451000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"and probably needs more parsing. Like als calling the \"play()\" method of the video element (or not) if the the video is paused. Not everyone would want to seek and play. Some might just want to seek and keep the video paused. Etc.","msgtype":"m.text"},"ts":1611319524000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"yeah, maybe targeting the media by id is enough","msgtype":"m.text"},"ts":1611319567000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"in this case, something like href=\"#video_element?t=00:00:05.500&play=true\" (or false) would be needed","msgtype":"m.text"},"ts":1611319587000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"also that would deviate from the current \"t=X,Y\" standard. Lots of issues. But i'll try to RFC anyway","msgtype":"m.text"},"ts":1611319633000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"can't have something that works around current autoplay restrictions","msgtype":"m.text"},"ts":1611319688000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: i think it'd be enough since targeting elements by id is already done for normal #section links","msgtype":"m.text"},"ts":1611319721000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"hm, javascript seems to work around against autoplay restrictions aswell? like: \"var video = $('#myvideo').get(0); video.play()\"","msgtype":"m.text"},"ts":1611319809000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"this in <a onclick=...> plays on click","msgtype":"m.text"},"ts":1611319829000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"ah, but it doesn't work around on external links","msgtype":"m.text"},"ts":1611319853000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"i think I get what you're saying","msgtype":"m.text"},"ts":1611319861000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"rigid: `video.play()` only works if it was called after a user interaction","msgtype":"m.text"},"ts":1611319864000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"(although in some cases muted videos can play)","msgtype":"m.text"},"ts":1611319887000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: how did you test whether the user agent stopped doing requests for the media element?","msgtype":"m.text"},"ts":1611319902000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think I assumed requests wouldn't happen after an error event on the media element","msgtype":"m.text"},"ts":1611320017000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"hm, clicking a link would also be a user interaction. I suppose links from external sites would be the issue. like <a href=\"//notmysite.com/#video?play=true\"> would work around that restriction.","msgtype":"m.text"},"ts":1611320019000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"rigid: right, or indeed links from a native app etc etc","msgtype":"m.text"},"ts":1611320081000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so I can't always get error to fire in Chrome, but it does stop doing requests...","msgtype":"m.text"},"ts":1611320196000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Just for a sanity check, do you agree with https://github.com/w3c/webappsec-referrer-policy/pull/148#issuecomment-765590123 ?","msgtype":"m.text"},"ts":1611338659000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"just reading the FAQ for proposals annevk pasted. It mentions https://github.com/whatwg/html/issues ... where's the difference to https://wicg.io ?","msgtype":"m.text"},"ts":1611341303000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"domfarolino: that goes for all policies","msgtype":"m.text"},"ts":1611343892000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"rigid: the former is for stuff thatâ€™s a bit further along, we should prolly update the FAQ","msgtype":"m.text"},"ts":1611343970000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"oh, i just started writing the github issue :)","msgtype":"m.text"},"ts":1611344050000,"senderName":"rigid","senderId":"rigid@irc"},
{"content":{"body":"Ok just checking","msgtype":"m.text"},"ts":1611344061000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"Except srcdocs shouldnâ€™t inherit the CSP of the initiator of a backwards history traversal I guess? But thatâ€™s not really considered a navigation I think.","msgtype":"m.text"},"ts":1611344143000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"Or I guess more generally policies shouldnâ€™t be inherited from history traversal since theyâ€™re arenâ€™t navigations...","msgtype":"m.text"},"ts":1611344314000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"Sorry, trying to page this all in my head ðŸ˜…","msgtype":"m.text"},"ts":1611344328000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: good question how that would work without bfcache, might have to be stored in history, hmm","msgtype":"m.text"},"ts":1611344582000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"rigid: thatâ€™s fine as a starting point, youâ€™ll get redirected if needed","msgtype":"m.text"},"ts":1611344619000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Yeah so without bfcache my understanding is the document would have to be reloaded, and you're saying reloading it might not be enough to resurrect the same policy container that the original document would've had (that inherits policies from its container doc)? That is, we might need to store the container in history or something?","msgtype":"m.text"},"ts":1611344998000,"senderName":"domfarolino","senderId":"domfarolino@irc"},
{"content":{"body":"domfarolino: yeah maybe, not sure where else it would go if the entry was about:blank or some such","msgtype":"m.text"},"ts":1611346512000,"senderName":"annevk","senderId":"annevk@irc"}
]