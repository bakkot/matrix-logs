[
{"content":{"body":"MikeSmith: https://w3c.github.io/webappsec-mixed-content/ is offline, maybe due to branch renaming?","msgtype":"m.text"},"ts":1613556155000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: oh","msgtype":"m.text"},"ts":1613558569000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"whatever it is, will fix it now","msgtype":"m.text"},"ts":1613558580000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"annevk: do we still say \"abort these steps\" in parallel steps, or is it something different now?","msgtype":"m.text"},"ts":1613571108000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I still say that... we had a recent discussion in https://github.com/whatwg/xhr/pull/311#discussion_r574067070","msgtype":"m.text"},"ts":1613571177000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Cheers!","msgtype":"m.text"},"ts":1613571258000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yeah that","msgtype":"m.text"},"ts":1613572311000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Building Streams abstractions is kinda tough, so many callbacks and dealing with the event loop correctly is just...","msgtype":"m.text"},"ts":1613572413000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah :(","msgtype":"m.text"},"ts":1613573607000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Not sure what could be done better; I was hopeful yesterday we could intervene in concept-http-network-fetch step 16 but the service worker issue makes it tricky.","msgtype":"m.text"},"ts":1613573646000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the buffering proxy is fine, I have most of that logic","msgtype":"m.text"},"ts":1613574136000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: what I have a hard time wrapping my head around is when the read request callbacks fire and whether I need to queue tasks from them or not and how the read request callbacks even work without some event loop","msgtype":"m.text"},"ts":1613574176000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(that is, I have most of that logic in my head, I prolly won't get to it today)","msgtype":"m.text"},"ts":1613574230000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: I'll upload my WIP so you can have a look at that","msgtype":"m.text"},"ts":1613574756000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: https://github.com/whatwg/fetch/pull/1172#discussion_r577697608","msgtype":"m.text"},"ts":1613575113000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: streams can only be manipulated from an event loop, indeed. The read request steps run during promise fulfillment, so, in a microtask.","msgtype":"m.text"},"ts":1613575995000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so I guess the problem is that we want to read from things while in parallel","msgtype":"m.text"},"ts":1613576147000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Do you really need to though?","msgtype":"m.text"},"ts":1613576191000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It seems like you could do it all on the stream's event loop and, if necessary, queue a task once you have realm-independent bytes to send them over to another realm.","msgtype":"m.text"},"ts":1613576225000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so like, upload streams, the moment we finally want to transmit stuff is deeply in parallel land","msgtype":"m.text"},"ts":1613576233000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But you have to get those bytes out of user-supplied JS code / streams machinery running the main thread","msgtype":"m.text"},"ts":1613576261000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So you could do that by posting a task back to the stream's event loop to ask for the bytes","msgtype":"m.text"},"ts":1613576274000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And response bodies?","msgtype":"m.text"},"ts":1613576335000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"The question is how to read them for e.g. json()?","msgtype":"m.text"},"ts":1613576372000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"or sync xhr","msgtype":"m.text"},"ts":1613576383000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Oh yeah you're screwed for sync XHR","msgtype":"m.text"},"ts":1613576392000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"json() is pretty easy though since it's async I think","msgtype":"m.text"},"ts":1613576416000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But sync XHR needs some sort of magical \"pump the event loop the stream is using but only for the stream's tasks and not for anything else\"","msgtype":"m.text"},"ts":1613576433000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Well but also https://fetch.spec.whatwg.org/#concept-http-network-fetch just creates a ReadableStream while in parallel","msgtype":"m.text"},"ts":1613576455000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'm not sure that's terrible (as long as you specify a realm); you just need to post a task when you observably associate that stream with the JS Request object.","msgtype":"m.text"},"ts":1613576513000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I guess it's not how implementations work though","msgtype":"m.text"},"ts":1613576525000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"If we also had underlying C++/Rust streams this wouldn't be a problem","msgtype":"m.text"},"ts":1613576529000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: but we also read from it while in parallel and there's no event loop or microtasks there","msgtype":"m.text"},"ts":1613576547000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: and enqueue onto it, I dunno","msgtype":"m.text"},"ts":1613576563000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Reading from it's a problem but enqueuing is slightly less problematic","msgtype":"m.text"},"ts":1613576574000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I can see salvaging some of this though","msgtype":"m.text"},"ts":1613576576000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Enqueuing is just synchronously pushing into an Infra list","msgtype":"m.text"},"ts":1613576592000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Granted that Infra list lives inside a realm-bound JS object (the ReadableStream)","msgtype":"m.text"},"ts":1613576605000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It does seem like the spec isn't very clear on when implementations should actually create the ReadableStream object on the main thread. They must post a task to do so at some point, but the spec just does so in parallel.","msgtype":"m.text"},"ts":1613576669000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah, I didn't pay close enough attention I think when all the initial stream stuff happened","msgtype":"m.text"},"ts":1613576720000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I was still pretty confused about realms and promises and stuff at the time","msgtype":"m.text"},"ts":1613576738000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"How this works in Chrome I believe is that we have C++ streams (Mojo data pipes) (probably similar to encoding's I/O queues?) which periodically queue a task to transfer bytes via shared memory from the C++ stream into the JS stream.","msgtype":"m.text"},"ts":1613576780000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I vaguely recall pushing for some better abstractions, but also not wanting to block without having more concrete suggestions","msgtype":"m.text"},"ts":1613576783000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah, I definitely argued for that, but you didn't want that","msgtype":"m.text"},"ts":1613576802000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think that would be doable as a spec architecture but it might be a lot of work, I'm not sure.","msgtype":"m.text"},"ts":1613576809000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah I was pretty firmly in the \"everything is JavaScript and should be implemented as if in JavaScript\" camp back then","msgtype":"m.text"},"ts":1613576826000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Cf. Streams being written in complete ECMAspeak","msgtype":"m.text"},"ts":1613576833000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It's possible I/O queues might actually do what we want...","msgtype":"m.text"},"ts":1613576864000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah, hmm","msgtype":"m.text"},"ts":1613577044000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I suspect it needs to be a bit more complex to account for errors and such","msgtype":"m.text"},"ts":1613577238000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think I'll continue with what I have for now to at least find all the places that need updating and also redefine the processResponseEndOfBody callback accordingly","msgtype":"m.text"},"ts":1613577300000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"At least that'll centralize the issues a bit better","msgtype":"m.text"},"ts":1613577325000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah that sounds good","msgtype":"m.text"},"ts":1613577341000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Bikeshed question: https://github.com/w3c/webappsec-upgrade-insecure-requests/blob/main/index.src.html#L64 has some outdated references to HTML dfns that no longer exist","msgtype":"m.text"},"ts":1613585571000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"for example, “responsible browsing context”","msgtype":"m.text"},"ts":1613585598000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"https://github.com/w3c/webappsec-upgrade-insecure-requests/blob/main/index.src.html#L64","msgtype":"m.text"},"ts":1613585604000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"but when I run Bikeshed, no warnings are reported for those","msgtype":"m.text"},"ts":1613585624000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"is there some way I can get Bikeshed to audit those and report warnings for them?","msgtype":"m.text"},"ts":1613585660000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Domenic: when did async/await happen?","msgtype":"m.text"},"ts":1613587780000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hmm good question in this context","msgtype":"m.text"},"ts":1613587793000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I don't think it was really considered as it probably happened after","msgtype":"m.text"},"ts":1613587795000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ES2016 or 2017 I guess","msgtype":"m.text"},"ts":1613587801000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"2017","msgtype":"m.text"},"ts":1613587818000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So sometime in 2016","msgtype":"m.text"},"ts":1613587820000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I tried to find out but I couldn't get the right query; promises was 2016 I think","msgtype":"m.text"},"ts":1613587822000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Nah promises was ES2015 so during 2013-2014","msgtype":"m.text"},"ts":1613587837000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Ah right okay, so yeah, it probably wasn't really considered","msgtype":"m.text"},"ts":1613587853000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"That makes sense","msgtype":"m.text"},"ts":1613587862000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I like it though, prolly an IDL feature if we wanted to do it","msgtype":"m.text"},"ts":1613587921000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah expressing that in IDL + prose today would be kind of annoying","msgtype":"m.text"},"ts":1613587940000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And then it'd work everywhere that takes a promise","msgtype":"m.text"},"ts":1613587941000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Oh interesting","msgtype":"m.text"},"ts":1613587949000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I was thinking opt-in","msgtype":"m.text"},"ts":1613587955000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But there probably aren't that many promise-accepting APIs and the ones that exist would probably like this","msgtype":"m.text"},"ts":1613587967000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"If someone can come up with an example where new Promise is okay but async/await is not that'd be interesting for sure, but that seems like a stretch?","msgtype":"m.text"},"ts":1613588021000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I doubt it'd be possible to come up with one where it's bad but it seems plausible there's cases where you're mostly passing promises from somewhere already existing","msgtype":"m.text"},"ts":1613588248000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"where writing the work inline would be weird for that use case","msgtype":"m.text"},"ts":1613588264000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: Domenic: among any issues you’ve raised against WebAppSec specs, if there are particular ones that you hope to have considered higher priority, please let me know","msgtype":"m.text"},"ts":1613589170000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"especially issues that might be blocking any HTML changes","msgtype":"m.text"},"ts":1613589206000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Domenic: as far as I have found so far, https://github.com/w3c/webappsec-permissions-policy/issues/390 may be the only WebAppSec spec issue you have open","msgtype":"m.text"},"ts":1613589237000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"(or else maybe I’m not using the right search params)","msgtype":"m.text"},"ts":1613589285000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"> It's possible I/O queues might actually do what we want...","msgtype":"m.text"},"ts":1613590191000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"That would've been confusing as hell just 8 months ago 😁","msgtype":"m.text"},"ts":1613590208000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"I'm not sure I/O queues as they are right now are a good fit, but I can see them becoming a good infrastructure for both encoding and streams","msgtype":"m.text"},"ts":1613590256000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"MikeSmith: thanks for asking; I think there are probably a number of open issues that we didn't open ourselves which are relatively high priority. Will do a look.","msgtype":"m.text"},"ts":1613590292000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"For example, right now empty I/O queues (without end-of-queue) block on reading, but adding a \"read if not empty\" method would also help with the HTML parser, I guess","msgtype":"m.text"},"ts":1613590320000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"Domenic: thanks","msgtype":"m.text"},"ts":1613590354000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"andreubotella: they would need to support cancel/abort","msgtype":"m.text"},"ts":1613592958000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: hm, right","msgtype":"m.text"},"ts":1613593051000,"senderName":"andreubotella","senderId":"andreubotella@irc"},
{"content":{"body":"MikeSmith: having someone go through existing issues and fixing Bikeshed warnings and rely on the Bikeshed db more would all be good","msgtype":"m.text"},"ts":1613593065000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: I’ll likely patch SRI as part of Fetch read body changes","msgtype":"m.text"},"ts":1613593104000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"https://github.com/w3c/webappsec-permissions-policy/issues/396 would be nice","msgtype":"m.text"},"ts":1613593418000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Thank ya'll for your hard works on the specs (:","msgtype":"m.text"},"ts":1613594039000,"senderName":"EveryOS","senderId":"EveryOS@irc"},
{"content":{"body":"https://github.com/w3c/webappsec-subresource-integrity/issues/92 and https://github.com/w3c/webappsec-subresource-integrity/issues/41","msgtype":"m.text"},"ts":1613594488000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"You're welcome, EveryOS!","msgtype":"m.text"},"ts":1613594496000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Oh https://github.com/w3c/webappsec-fetch-metadata/issues/58 being dropped seems bad","msgtype":"m.text"},"ts":1613594572000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: thanks","msgtype":"m.text"},"ts":1613606271000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"}
]