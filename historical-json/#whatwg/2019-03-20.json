[
{"content":{"body":"annevk: Catching up on the CSP thing. I'm not sure I understand the problem. When you make a request from a page, the CSP is checked before the request goes to the service worker, but the response is also checked against the original request. The destination is taken from the original request, so service worker can't tamper with it","msgtype":"m.text"},"ts":1553084606000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: the concern is about routing something into a cache","msgtype":"m.text"},"ts":1553085060000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I can't figure out the attack. <img> -> service worker -> fetch() -> cacheâ€¦ but if a response is later pulled from the cache it'll still be CSP checked","msgtype":"m.text"},"ts":1553086069000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so in that setup the fetch() uses SW's CSP","msgtype":"m.text"},"ts":1553086178000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: but would it still consult that SW's CSP if it uses routing to bypass invoking the SW?","msgtype":"m.text"},"ts":1553086213000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I think I managed to convince myself that using the document's CSP is sufficient, since both the document and the SW can pollute the cache, but it's still a little surprising","msgtype":"m.text"},"ts":1553086256000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: the referrer would also be different and there might be other subtle things going on too","msgtype":"m.text"},"ts":1553086267000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: perhaps routing isn't a thing yet though, I don't really know the state of things","msgtype":"m.text"},"ts":1553086295000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: as in the static routes proposal? That's a good question. Using the service worker's CSP would make things more consistent, especially with static route polyfills, but I like the idea of just using the document's CSP since it's all behind the scenes anyway. But yeah, it isn't enough of a thing yet to worry too much about","msgtype":"m.text"},"ts":1553086362000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: okay","msgtype":"m.text"},"ts":1553086452000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1553086478000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm wondering what's the best path forward for CH and a `Sec-` prefix, which we discussed in https://github.com/whatwg/fetch/pull/880","msgtype":"m.text"},"ts":1553087335000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: I'm not sure, I kinda wonder what media elements do for Range when crossorigin is set","msgtype":"m.text"},"ts":1553088715000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: JakeA might be onto something that following Range is the way to go, but what Range does is not fully clear","msgtype":"m.text"},"ts":1553088734000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"They would trigger a preflight right?","msgtype":"m.text"},"ts":1553088785000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: my suspicion is that browsers don't","msgtype":"m.text"},"ts":1553088833000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: and that the treat Range as privileged because they initiated the range request","msgtype":"m.text"},"ts":1553088854000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: similar to EventSource's Last-Event-ID","msgtype":"m.text"},"ts":1553088869000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Interesting. I think Chrome does if it goes via a service worker, so I guess that needs fixing somehow.","msgtype":"m.text"},"ts":1553088876000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: can you expand on what you had in mind? Do we want to add specific CH headers as privileged? All `Sec-` prefixed headers as privileged?","msgtype":"m.text"},"ts":1553089044000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"And if they are privileged, does that mean that SW can copy them from the incoming Request without breaking them?","msgtype":"m.text"},"ts":1553089076000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"s/copy them/forward the incoming request to fetch()/","msgtype":"m.text"},"ts":1553089103000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Domenic: https://github.com/whatwg/html/issues/4400#issuecomment-474827602 what if the network hangs for multiple seconds after the first </script>?","msgtype":"m.text"},"ts":1553089430000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: seems that would result in multiple tasks from the parser to manipulate the tree","msgtype":"m.text"},"ts":1553089450000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: not as currently specced for HTML modules, but, maybe that's thing to raise with the MS folks about their spec?","msgtype":"m.text"},"ts":1553089476000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: ooh, inside an HTML module","msgtype":"m.text"},"ts":1553089489000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: my bad","msgtype":"m.text"},"ts":1553089501000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: no that seems like the right semantics for HTML modules","msgtype":"m.text"},"ts":1553089510000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: Is the intent that `Sec-` headers should pass through a service worker as long as the request isn't modified? And `Sec-` headers shouldn't trigger a preflight unless it was manually set by the developer (or is this forbidden?)","msgtype":"m.text"},"ts":1553089883000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"they are forbidden","msgtype":"m.text"},"ts":1553089903000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Is the rest correct?","msgtype":"m.text"},"ts":1553089910000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yes, I want `Sec-` headers to be able to pass through","msgtype":"m.text"},"ts":1553089928000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"or alternatively, add CH sec headers both before and after SW","msgtype":"m.text"},"ts":1553089948000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"the latter might be better, as it'll add CH headers also when the request was changed","msgtype":"m.text"},"ts":1553089985000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"basically, SW needs to be able to observe those headers, but not modify or add them","msgtype":"m.text"},"ts":1553090014000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: That's kinda how `Range` works, except `Range` will trigger a preflight for cors requests (but I think this is a bug), and `Range` can be set by the developer (in which case it should trigger a preflight)","msgtype":"m.text"},"ts":1553090095000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"But the mechanism that allows `Range` to exist unless the request is modified seems useful for `Sec-`","msgtype":"m.text"},"ts":1553090136000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Can Range headers survive if the request was modified?","msgtype":"m.text"},"ts":1553090319000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"JakeA: I think that would be desirable for CH headers, but not sure how to achieve that. Maybe we should keep a copy of all `Sec-` headers before SW is called and then restore them afterwards?","msgtype":"m.text"},"ts":1553090378000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: \"Can Range headers survive if the request was modified?\" no","msgtype":"m.text"},"ts":1553090751000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yoav: https://github.com/web-platform-tests/wpt/blob/master/fetch/range/general.any.js","msgtype":"m.text"},"ts":1553090827000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yoav: what do you want to happen to the `sec-` headers if the request is modified? Remove them, or set them to some kind of default?","msgtype":"m.text"},"ts":1553090907000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I want to set them back to what they were","msgtype":"m.text"},"ts":1553091004000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"What's the difference between that and doing nothing?","msgtype":"m.text"},"ts":1553091035000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"(given that developers can't set them anyway)","msgtype":"m.text"},"ts":1553091046000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Let's consider `Sec-DPR: 2`. I want to set it before SW (so that SW can observe it and maybe change its response accordingly), but want to make sure it is added to requests going to the server, even if the request was modified","msgtype":"m.text"},"ts":1553091072000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Why do you need to add something that's already there?","msgtype":"m.text"},"ts":1553091103000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"and I want that value to not be modifiable by the developer","msgtype":"m.text"},"ts":1553091104000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"If `Sec-` headers gets blown off when the developer modifies the request, I want to reinstate them","msgtype":"m.text"},"ts":1553091140000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"if they are there, no need to add them again, obviously","msgtype":"m.text"},"ts":1553091154000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"just don't blow them off then?","msgtype":"m.text"},"ts":1553091174000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"ew, phrasing","msgtype":"m.text"},"ts":1553091181000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I think I'm missing something. If you don't want the headers to be removed, instead of removing them and re-adding them, just don't remove them, right?","msgtype":"m.text"},"ts":1553091234000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Maybe I'm missing something. When a SW gets a Request object in its fetch event, is it immutable? Or can they change it?","msgtype":"m.text"},"ts":1553091285000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"It's immutable, but once you do `const request = new Request(event.request)` then `request.headers` are mutable","msgtype":"m.text"},"ts":1553091348000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"oh, so devs will be able to change those request headers without killing any forbidden headers which were present in the original request?","msgtype":"m.text"},"ts":1553091392000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"that'd work","msgtype":"m.text"},"ts":1553091403000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Yeah. That's different to how `Range` works btw. `Range` headers are removed as soon as the developer modifies the headers.","msgtype":"m.text"},"ts":1553091449000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"But it seems like `Sec-` needs to work differently","msgtype":"m.text"},"ts":1553091465000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: Thanks! I'll take a look and come up with a Range-inspired proposal","msgtype":"m.text"},"ts":1553092452000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Domenic: want to do a final pass and land https://github.com/whatwg/html/pull/4360?","msgtype":"m.text"},"ts":1553093357000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: I gotta go soon","msgtype":"m.text"},"ts":1553093362000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Can do","msgtype":"m.text"},"ts":1553095705000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: never mind, Maciej spotted a mistake","msgtype":"m.text"},"ts":1553100773000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: playsinline was added in June 2016, FWIW","msgtype":"m.text"},"ts":1553102795000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ah wow OK","msgtype":"m.text"},"ts":1553102940000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I can look into when the checkpoint flag got added I suppose","msgtype":"m.text"},"ts":1553116048000,"senderName":"annevk","senderId":"annevk@irc"}
]