[
{"content":{"body":"I take it that postMessage() to self in order not to block the event loop without waiting on a timeout is obsolete with promises","msgtype":"m.text"},"ts":1495784748000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"or is it? what's the right way to return a promise that does nothing but let the event loop turn and then resolve?","msgtype":"m.text"},"ts":1495784934000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Hey","msgtype":"m.text"},"ts":1495784953000,"senderName":"Methodist","senderId":"Methodist@irc"},
{"content":{"body":"oh, it's always on microtask queue","msgtype":"m.text"},"ts":1495785003000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"is there a good blackbox function in JS that just returns its argument but that the compiler is guaranteed not to optimize out?","msgtype":"m.text"},"ts":1495787398000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"i.e. something that can force the lack of optimizing out operations being benchmarked","msgtype":"m.text"},"ts":1495787422000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: caitp might have a good answer to that, if sheâ€™s around","msgtype":"m.text"},"ts":1495789826000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Does anyone know if we may see <datalist> support <optgroup>? My understand of the spec is it doesn't really say if it should either way.","msgtype":"m.text"},"ts":1495792208000,"senderName":"jpdevries","senderId":"jpdevries@irc"},
{"content":{"body":"Nevermind. Found something promising ðŸ¤žhttps://www.w3.org/TR/html5/forms.html#the-option-element","msgtype":"m.text"},"ts":1495792286000,"senderName":"jpdevries","senderId":"jpdevries@irc"},
{"content":{"body":" ","msgtype":"m.text"},"ts":1495792312000,"senderName":"jpdevries","senderId":"jpdevries@irc"},
{"content":{"body":"read that wrong, mistook option section for optgroup section ðŸ˜¢","msgtype":"m.emote"},"ts":1495792509000,"senderName":"jpdevries","senderId":"jpdevries@irc"},
{"content":{"body":"can someone enlighten me on the relationship between event firing and task sources?","msgtype":"m.text"},"ts":1495800011000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"looking for something as basic as: \"they're completely orthogonal\" or \"one implies the other\"","msgtype":"m.text"},"ts":1495800067000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"When you queue an event to be fired it is put into a task source. At some point the event loop spins, the event is grabbed from the task source, and it is dispatched","msgtype":"m.text"},"ts":1495800319000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"hsivonen: in v8, the legacy pipeline was very happy to not opt or inline anything if all kinds of stuff was used","msgtype":"m.text"},"ts":1495800385000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"the new pipeline will skip some but not all optimizations if you do certain things, so probably the best you can do is %NeverOptimizeFunction(func)","msgtype":"m.text"},"ts":1495800576000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"there might be some better","msgtype":"m.text"},"ts":1495800619000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"jgraham: right. But can you just fire an event without queueing it?","msgtype":"m.text"},"ts":1495800751000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"jgraham: if so, what's the distinction between these two things and when should you choose one over the other?","msgtype":"m.text"},"ts":1495800813000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie: Yeah, but that means it dispatches synchronously so if you have (pseduocode) <script>fooRan = false; addEventListener(\"foo\", () fooRan = true); fireEvent(\"foo\"); /* now foo handlers run */ assert(fooRan, true)</script>","msgtype":"m.text"},"ts":1495801108000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: right. How do we decide what behavior to go for?","msgtype":"m.text"},"ts":1495801158000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie: Firing synchronous events is very rare","msgtype":"m.text"},"ts":1495801170000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: is there a document that explains which one should be used when","msgtype":"m.text"},"ts":1495801263000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"I think it's async always except if there's some legacy","msgtype":"m.text"},"ts":1495801289000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: oh","msgtype":"m.text"},"ts":1495801296000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"But idk if that's written down somewhere, and I could be wrong in some case I haven't thought of","msgtype":"m.text"},"ts":1495801316000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: it's about firing event when a new sensor reading is received.","msgtype":"m.text"},"ts":1495801343000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"hmm, firing sync events rare? click(), and focus() etc cause various sync events. Mutation Events are sync... But yes, legacy mostly","msgtype":"m.text"},"ts":1495801394000,"senderName":"smaug","senderId":"smaug@irc"},
{"content":{"body":"tobie: if that receiving is already async, then dispatching event sync is probably ok","msgtype":"m.text"},"ts":1495801429000,"senderName":"smaug","senderId":"smaug@irc"},
{"content":{"body":"smaug: it is async, yes. It's a shared memory buffer that's updated","msgtype":"m.text"},"ts":1495801459000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"As part of a task?","msgtype":"m.text"},"ts":1495801471000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"but better to do the sync dispatch at the end of some algorithm, since event handling may change the state of the world","msgtype":"m.text"},"ts":1495801483000,"senderName":"smaug","senderId":"smaug@irc"},
{"content":{"body":"Like if there's already a task on the stack then you can fire events sync","msgtype":"m.text"},"ts":1495801492000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"But otherwise one typically queues a task specifically to fire them","msgtype":"m.text"},"ts":1495801510000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"So the part where the buffer is updated is totally hand-wavy in the spec for now","msgtype":"m.text"},"ts":1495801586000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"So it isn't clearly specified as happening within a task.","msgtype":"m.text"},"ts":1495801611000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Is what you're saying that this happens within a task whether or not I've specifically written it down?","msgtype":"m.text"},"ts":1495801667000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"(This is probably a stupid question but I'm not familiar with how to spec things that happen at the boundary with the underlying C++ code)","msgtype":"m.text"},"ts":1495801713000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"^ smaug, jgraham","msgtype":"m.text"},"ts":1495801721000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"hmm, that is unclear in the specs","msgtype":"m.text"},"ts":1495802126000,"senderName":"smaug","senderId":"smaug@irc"},
{"content":{"body":"I'd say","msgtype":"m.text"},"ts":1495802128000,"senderName":"smaug","senderId":"smaug@irc"},
{"content":{"body":"when data is coming from outside","msgtype":"m.text"},"ts":1495802134000,"senderName":"smaug","senderId":"smaug@irc"},
{"content":{"body":"but implicitly it needs to be in some task source","msgtype":"m.text"},"ts":1495802153000,"senderName":"smaug","senderId":"smaug@irc"},
{"content":{"body":"smaug: maybe I should rephrase this differently. Is there anything that can happen outside of a task source?","msgtype":"m.text"},"ts":1495802546000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie: Sure","msgtype":"m.text"},"ts":1495802553000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"But it's bad :)","msgtype":"m.text"},"ts":1495802561000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Like if you update data in the background then in theory something like (very pseudoCode) <script>getSensorData(\"foo\") == getSensorData(\"foo\")</script> doesn't hold","msgtype":"m.text"},"ts":1495802612000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Typically the platform tries to expose consistent state to each script, but that isn't always the case.","msgtype":"m.text"},"ts":1495802734000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"ok. I think that makes sense.","msgtype":"m.text"},"ts":1495802899000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Thanks.","msgtype":"m.text"},"ts":1495802907000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"smaug, jgraham: would either of you have pointers of other specs doing something similar and that would have gotten this right so I could copy it?","msgtype":"m.text"},"ts":1495803094000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"(off the top of your head)","msgtype":"m.text"},"ts":1495803130000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Not off the top of my head","msgtype":"m.text"},"ts":1495803190000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"alright thanks for the explanation, folks.","msgtype":"m.text"},"ts":1495804342000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie: not sure i fully understand the scenario but i would imagine sensor reading happens off-main-thread. in which case you must queue a task to go back to the main thread in order to fire the event","msgtype":"m.text"},"ts":1495824317000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"You can't fire an event from off-main-thread (i.e. from \"in parallel\" sections)","msgtype":"m.text"},"ts":1495824328000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so what happens is that the underlying layer updates a shared memory buffer whenever there's a new sensor reading.","msgtype":"m.text"},"ts":1495824598000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Domenic: on the JS side this causes an event to be fired. and the sensor.value attribute getter now return the value from that shared buffer (or a copy of it stored in a private var, this is still in flux)","msgtype":"m.text"},"ts":1495824755000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"\"causes an event to be fired\" how?","msgtype":"m.text"},"ts":1495824857000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Does the spec actually speak in terms of shared memory buffers?","msgtype":"m.text"},"ts":1495824870000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: no. It's a infra map","msgtype":"m.text"},"ts":1495824910000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"*an","msgtype":"m.text"},"ts":1495824916000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"OK. But the updating happens \"in parallel\" I'd assume","msgtype":"m.text"},"ts":1495824936000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: yes.","msgtype":"m.text"},"ts":1495824947000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Great. So then yeah, you need to queue a task to fire the event.","msgtype":"m.text"},"ts":1495824956000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So: in parallel, set map[value] to x, then queue a task to fire an event.","msgtype":"m.text"},"ts":1495825021000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"sounds perfect :)","msgtype":"m.text"},"ts":1495825078000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: thanks a bunch, it the \"in parallel, update the map\" bit I was missing to make sense of it all.","msgtype":"m.text"},"ts":1495825129000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"*it's","msgtype":"m.text"},"ts":1495825137000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Domenic: if the map is updated in parallel, an instances have a getter to the map value, doesn't that still risk to cause concurrency issues?","msgtype":"m.text"},"ts":1495825192000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"It does tingle my danger sense... Not sure about if there's a concrete problem though...","msgtype":"m.text"},"ts":1495825226000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Not sure I understand the dangers there very well myself, to be honest","msgtype":"m.text"},"ts":1495825242000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think it might be OK if it's hidden behind a getter?","msgtype":"m.text"},"ts":1495825263000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Because the worst that can happen is that x.value !== x.value","msgtype":"m.text"},"ts":1495825275000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But that's explainable in terms of .value being a getter","msgtype":"m.text"},"ts":1495825290000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I guess it's still unexpected","msgtype":"m.text"},"ts":1495825295000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"If you want to avoid that you can update the map in the queued task too","msgtype":"m.text"},"ts":1495825313000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So it's like: in parallel, wait for a change. When the change happens, queue a task to update the map and fire an event","msgtype":"m.text"},"ts":1495825328000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: ^ this.","msgtype":"m.text"},"ts":1495825341000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Awesome.","msgtype":"m.text"},"ts":1495825360000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Domenic: one last question. The spec was designed with it's own sensor queue that could be disabled for security reasons (e.g. when focus was lost). Does that make sense, and if so, do we need a queue per instance, per browsing context? per what?","msgtype":"m.text"},"ts":1495825988000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"* its","msgtype":"m.text"},"ts":1495825994000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie: This doesn't answer your question, but do you have a good reference for \"when focus is lost\"? NFC and WebAuthn want it, and I think it doesn't exist yet in HTML.","msgtype":"m.text"},"ts":1495826137000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"tobie: To answer your question, https://webbluetoothcg.github.io/web-bluetooth/#notification-events may be a similar situation?","msgtype":"m.text"},"ts":1495826201000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"jyasskin: putting the kids to bed. But yeah that seems what I'm looking for.","msgtype":"m.text"},"ts":1495826239000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie: I am pretty sure event queues are per event loop","msgtype":"m.text"},"ts":1495827069000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: maybe it makes more sense to have a per browsing context global flag for stopping the events for security reasons rather than piggy-backing on top of the event loop.","msgtype":"m.text"},"ts":1495827212000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Hmm yeah","msgtype":"m.text"},"ts":1495827299000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i.e. you'd post a task that says \"if the flag is set, return\", right?","msgtype":"m.text"},"ts":1495827317000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"It depends on if you want ignore-when-unfocused or add-to-backlog-when-unfocused behavior... the latter seems tricky.","msgtype":"m.text"},"ts":1495827421000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah, \"if the flag is set, do the right thing. Otherwise the other right thing.\"","msgtype":"m.text"},"ts":1495827638000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"Domenic: ignore-when-unfocused","msgtype":"m.text"},"ts":1495827798000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Then yeah jyasskin's version sounds perfect","msgtype":"m.text"},"ts":1495827817000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"jyasskin: cool.","msgtype":"m.text"},"ts":1495827831000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"jyasskin: so yes, this seems like a very similar situation https://webbluetoothcg.github.io/web-bluetooth/#notification-events","msgtype":"m.text"},"ts":1495827956000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"jyasskin: wrt \"when focus is lost event\" do you know of an open issue against HTML?","msgtype":"m.text"},"ts":1495827995000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"jyasskin: I couldn't find anything after a cursory look. Could you point me to where in WebBluetooth this is needed? Also if you already have an open issue in your repo on this? Like that I can file a bug an reference all the things","msgtype":"m.text"},"ts":1495828301000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Do not update state without a task","msgtype":"m.text"},"ts":1495829559000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well, that probably should be printed on a whatwg t-shirt?","msgtype":"m.text"},"ts":1495833009000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie: Sorry, had to go home to watch Max. I don't know of an existing issue against HTML. NFC tries to use it in https://w3c.github.io/web-nfc/#handling-window-visibility-and-focus, and WebAuthn has an issue for it in https://github.com/w3c/webauthn/issues/316","msgtype":"m.text"},"ts":1495837613000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"jyasskin: looks like you just found the issue. :)","msgtype":"m.text"},"ts":1495837716000,"senderName":"tobie","senderId":"tobie@irc"}
]