[
{"content":{"body":"+1 on the addition of .closest too, annevk.  Very, very useful for DOM traversal, if my authoring experience with jQuery is any indication.","msgtype":"m.text"},"ts":1401149761000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: yea! closest!","msgtype":"m.text"},"ts":1401165563000,"senderName":"JonathanNeal","senderId":"JonathanNeal@irc"},
{"content":{"body":"annevk: dunno what you said to bring it up, but +1","msgtype":"m.text"},"ts":1401165599000,"senderName":"JonathanNeal","senderId":"JonathanNeal@irc"},
{"content":{"body":"TabAtkins, annevk, “do it for the delegates”","msgtype":"m.text"},"ts":1401165691000,"senderName":"JonathanNeal","senderId":"JonathanNeal@irc"},
{"content":{"body":"my oh my it looks like it’s gonna be a thing! https://github.com/whatwg/dom/commit/fd69cc7ed9251d12b1185b24e6f89d3f0481f39d wooohoo!!","msgtype":"m.text"},"ts":1401167411000,"senderName":"JonathanNeal","senderId":"JonathanNeal@irc"},
{"content":{"body":"maybe dave methvin and john resig should be writing these things","msgtype":"m.text"},"ts":1401168448000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"JonathanNeal: I added it","msgtype":"m.text"},"ts":1401172103000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: SamB: so should we do something about the xhr logo? ask ajax for permission?","msgtype":"m.text"},"ts":1401175311000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: I don't see why it's not fair use","msgtype":"m.text"},"ts":1401175506000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it is, but that's a US thing i think","msgtype":"m.text"},"ts":1401175544000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: not sure then","msgtype":"m.text"},"ts":1401176414000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zcorpan: kinda planning on merging XHR into Fetch at some point so it might become moot","msgtype":"m.text"},"ts":1401176568000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1401176638000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"darobin: tobie: you guys were involved with Ringmark right? Care to comment on https://bugzilla.mozilla.org/show_bug.cgi?id=1016053 ?","msgtype":"m.text"},"ts":1401177292000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I wasn't, it was a Facebook internal project","msgtype":"m.text"},"ts":1401177319000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"I wasn't even aware it was still alive","msgtype":"m.text"},"ts":1401177338000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"Arg.","msgtype":"m.text"},"ts":1401177370000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Ringmark has some... issues","msgtype":"m.text"},"ts":1401177392000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"Lots of reasons why I don't want to comment on this.","msgtype":"m.text"},"ts":1401177466000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"wonders if he cares enough to look up who claimed they fixed all their issues, promise","msgtype":"m.emote"},"ts":1401177590000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"annevk: if there are no other known instances of this being used, I would recommend closing the bug","msgtype":"m.text"},"ts":1401177661000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"also, Kyle seems to indicate that there's some XPConnect magic going on — why that would happen on the Web I don't even","msgtype":"m.text"},"ts":1401177694000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"annevk: commented. imho test needs to be fixed to generate the storageevent properly.","msgtype":"m.text"},"ts":1401178155000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie, want to poke the right people? :)","msgtype":"m.text"},"ts":1401178396000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: Rick is.","msgtype":"m.text"},"ts":1401178410000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Ms2ger:","msgtype":"m.text"},"ts":1401178425000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Rick is the right person.","msgtype":"m.text"},"ts":1401178435000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Do you know if he reads bugmail?","msgtype":"m.text"},"ts":1401178436000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"He probably does, but I'll ping him on twitter.","msgtype":"m.text"},"ts":1401178465000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Ta","msgtype":"m.text"},"ts":1401178502000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: are storage events still on other windows only?","msgtype":"m.text"},"ts":1401179471000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Eh?","msgtype":"m.text"},"ts":1401179492000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Yeah. Spec used to mandate firing storage events on window objects of other open tabs of the same origin.","msgtype":"m.text"},"ts":1401179557000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Nicely conflating a sync storage system and a cross frame communication channel along the way.","msgtype":"m.text"},"ts":1401179608000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie: the test could do new StorageEvent()","msgtype":"m.text"},"ts":1401180224000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"oh. Mind mentioning that in the comment? I'm out of battery.","msgtype":"m.text"},"ts":1401180262000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"JakeA: note that per https://www.w3.org/Bugs/Public/show_bug.cgi?id=24822 we should not advocate allowing localhost by default","msgtype":"m.text"},"ts":1401185920000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: apparently people set up systems locally and do not expect the outside world to be able to read them even if they have CORS headers...","msgtype":"m.text"},"ts":1401185947000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: hmm, that's really tough. I mean, what if you *want* that?","msgtype":"m.text"},"ts":1401186163000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: use case?","msgtype":"m.text"},"ts":1401186197000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: actually, localhost same-origin is prolly fine","msgtype":"m.text"},"ts":1401186245000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Say I'm developing locally, and I have a local version of some API running for testing purposes","msgtype":"m.text"},"ts":1401186325000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: Would jakearchibald.dev be able to reach localhost:3000?","msgtype":"m.text"},"ts":1401186341000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"(assume jakearchibald.dev maps to localhost)","msgtype":"m.text"},"ts":1401186381000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Would XHRing to localhost:3000 behave differently to jakearchibald.dev:3000?","msgtype":"m.text"},"ts":1401186424000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: that's what people are proposing","msgtype":"m.text"},"ts":1401186470000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: maybe leave a comment in that bug","msgtype":"m.text"},"ts":1401186485000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: sicking wants to do this","msgtype":"m.text"},"ts":1401186498000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Done","msgtype":"m.text"},"ts":1401186654000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"tbh, as long as it was flagged in devtools with a button to allow, it'd be ok","msgtype":"m.text"},"ts":1401186692000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"But it seems weird to break CORS like this","msgtype":"m.text"},"ts":1401186702000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I think it's not just CORS that's the issue but accessing localhost in general","msgtype":"m.text"},"ts":1401186971000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"Oh yeah, this wouldn't just block CORS, this would block all the things","msgtype":"m.text"},"ts":1401186985000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"there are a few apps out there that expose a local server, and aren't necessarily well thought out","msgtype":"m.text"},"ts":1401186987000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"(e.g. support GET with side-effects)","msgtype":"m.text"},"ts":1401187017000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"But with CORS, that's an explicit \"allow access\"","msgtype":"m.text"},"ts":1401187057000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I can understand wanting to block new Image().src='http://localhost/...'","msgtype":"m.text"},"ts":1401187099000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: to answer your question, I would expect the block to apply to \"localhost\" and also explicit access to the loopback/local IPs, but not to other (unguessable) names that map to those IPs","msgtype":"m.text"},"ts":1401187104000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"Is loopback/local IPs defined?","msgtype":"m.text"},"ts":1401187195000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"So if I had localtoast mapping to localhost it'd behave like the rest of the web? I guess that's an easy way around it for developers","msgtype":"m.text"},"ts":1401187204000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Does the definition make sense with IPv6?","msgtype":"m.text"},"ts":1401187208000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(as long as localtoast doesn't become a pseudostandard)","msgtype":"m.text"},"ts":1401187216000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"If you know about any of that darobin it might make sense to add to the bug","msgtype":"m.text"},"ts":1401187221000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: that's what I'd expect","msgtype":"m.text"},"ts":1401187263000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"JakeA: Mac OS X makes setting up localhost very easy but doesn't make the implications that clear","msgtype":"m.text"},"ts":1401187281000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well, I don't know *much* but yes IPv6 has ::1","msgtype":"m.text"},"ts":1401187295000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"JakeA: I guess if there was a special dev mode, localdevhost, that could work","msgtype":"m.text"},"ts":1401187298000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"it's pretty easy for developers to run their own local names","msgtype":"m.text"},"ts":1401187314000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"annevk: Does OS X localhost come with CORS as default?","msgtype":"m.text"},"ts":1401187318000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: this is not about CORS","msgtype":"m.text"},"ts":1401187327000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: this is about Fetch","msgtype":"m.text"},"ts":1401187339000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ahh I see, by blocking the get you also block CORS. What about forcing preflight?","msgtype":"m.text"},"ts":1401187361000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"mmmm","msgtype":"m.text"},"ts":1401187515000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"I don't like the idea of forcing preflight","msgtype":"m.text"},"ts":1401187522000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"because it means that if you develop using CORS against localhost, you get a preflight which you won't get when you deploy","msgtype":"m.text"},"ts":1401187539000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"that risks causing confusion","msgtype":"m.text"},"ts":1401187550000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"if your preflight has side-effects you'll end up with really hard to debug behaviour","msgtype":"m.text"},"ts":1401187574000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"more than XHR failing to localhost all together?","msgtype":"m.text"},"ts":1401187575000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"well yeah, if it fails it really just fails","msgtype":"m.text"},"ts":1401187586000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"you don't get weird side effects, just immediate failure","msgtype":"m.text"},"ts":1401187601000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"But that's also confusing","msgtype":"m.text"},"ts":1401187612000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"and your console can report \"ERROR: access to localhost blocked for XHR\"","msgtype":"m.text"},"ts":1401187615000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"I guess maybe there could be a better way","msgtype":"m.text"},"ts":1401187669000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"Fair enough, if there was an option in devtools to \"allow\", I guess its fine","msgtype":"m.text"},"ts":1401187673000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"*if* the origin calling fetch is from a name that maps to the loopback IP, then it's allowed to call to localhost","msgtype":"m.text"},"ts":1401187693000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"anything else is just blocked","msgtype":"m.text"},"ts":1401187700000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"so jakea.dev can call localhost, with all the usual CORS stuff","msgtype":"m.text"},"ts":1401187719000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"but jakea.com, which does not map to 127.0.0.1 or ::1, can't","msgtype":"m.text"},"ts":1401187737000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"I think that stops the attacks, but keeps devs happy and simple","msgtype":"m.text"},"ts":1401187754000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"annevk: WDYT? ^","msgtype":"m.text"},"ts":1401187769000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"feels ok to me","msgtype":"m.text"},"ts":1401187790000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"darobin: yeah I guess something like that makes sense","msgtype":"m.text"},"ts":1401187794000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: do you think you can get to that Fetch / SW integration question today?","msgtype":"m.text"},"ts":1401187975000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I'm gonna look into fetch() / Request / Response after lunch","msgtype":"m.text"},"ts":1401187999000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: The progress events one? https://github.com/slightlyoff/ServiceWorker/issues/289","msgtype":"m.text"},"ts":1401188179000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: https://github.com/slightlyoff/ServiceWorker/issues/242","msgtype":"m.text"},"ts":1401188517000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: If I call event.respondWith(event.default()) for a subresource & it returns a redirect, it doesn't re-enter the SW right?","msgtype":"m.text"},"ts":1401191119000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: the network layer cannot return a redirect normally","msgtype":"m.text"},"ts":1401191169000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: only if explicitly instructed, and only the navigate algorithm does that at the moment per Hixie","msgtype":"m.text"},"ts":1401191186000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: So when you \"Return the result of performing a fetch using request\", it'll have some avoid-sw flag set?","msgtype":"m.text"},"ts":1401191293000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"(when handling 30x)","msgtype":"m.text"},"ts":1401191310000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah something like that","msgtype":"m.text"},"ts":1401191364000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: ideally with source still pointing to the originating client, not the service worker","msgtype":"m.text"},"ts":1401191378000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: so Referer and such are still nice","msgtype":"m.text"},"ts":1401191387000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: If we had request.manualRedirect, which was get/set & respected by fetch(), doesn't that meet the use-cases of event.default()?","msgtype":"m.text"},"ts":1401191770000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":".manualRedirect being true by default if its a navigate, but I could set it for subresources if I wanted. That means I'd return a redirect to fetch, which would follow it & any others (and wouldn't go through the SW because of this avoid-sw flag)","msgtype":"m.text"},"ts":1401191901000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"If a fetch() resolves to a redirect, it'd have to be opaque because of potential tokens passed in the url","msgtype":"m.text"},"ts":1401191983000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: what about Referer or CSP?","msgtype":"m.text"},"ts":1401193439000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: what about the weird thing with fetch() suddenly having two modes","msgtype":"m.text"},"ts":1401193465000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: manualRedirect is a feature, it's not a solution","msgtype":"m.text"},"ts":1401193497000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: you can make fetch() do the same thing as default(), but what you've done at that point is that you've added a special mode to fetch()","msgtype":"m.text"},"ts":1401193519000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I said as much the other day","msgtype":"m.text"},"ts":1401193527000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: If you make requests from SW, losing the Referer and CSP defaults doesn't seem bad","msgtype":"m.text"},"ts":1401193679000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: Yeah, fetch gets a mode, is that weirder than event.default()?","msgtype":"m.text"},"ts":1401193709000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Having event.default() drop back into fetch and then back into SW again feels really weird, but I agree it's the only sane way to implement event.default()","msgtype":"m.text"},"ts":1401193785000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I would be fine actually with event.default() not going back into SW but rather do the same as \"return null\"","msgtype":"m.text"},"ts":1401193814000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: but then you would not be able to store it in the cache","msgtype":"m.text"},"ts":1401193832000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Or more importantly IMO provide a fallback if it fails","msgtype":"m.text"},"ts":1401193845000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: I guess event.default() would return the same promise if called twice, or just fail","msgtype":"m.text"},"ts":1401193924000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: seems like that is up to you to define","msgtype":"m.text"},"ts":1401193971000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: fetch() having a mode in SW context only seems weird to me","msgtype":"m.text"},"ts":1401193986000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: event.default() means you're going to be handling SW responses in two places, for each of the calls into SW","msgtype":"m.text"},"ts":1401194033000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: Eg, event.respondWith( event.default().then(function() { return fetch('/'); }) )","msgtype":"m.text"},"ts":1401194062000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: as you can see from my explanation default() is pretty weird you ask SW for a response, but it actually gives you a callback and asks you to get a response, and then that callback gives you the actual response","msgtype":"m.text"},"ts":1401194071000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: whereas fetch() is very simple just like XHR, it just does a fetch","msgtype":"m.text"},"ts":1401194108000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah, I've got no problem with fetch(). But event.default… ugh","msgtype":"m.text"},"ts":1401194283000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so your solution is to make fetch() ugly?","msgtype":"m.text"},"ts":1401194310000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: overloading is generally a bad strategy","msgtype":"m.text"},"ts":1401194359000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Is it overloading? The fetch spec can manually handle redirects, why shouldn't fetch() be able to do the same (but opaque for security)?","msgtype":"m.text"},"ts":1401194460000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Fetch already does a lot of different stuff depending on the method, headers, origin","msgtype":"m.text"},"ts":1401194519000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: again, this is not about redirects","msgtype":"m.text"},"ts":1401194602000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I don't even see how that works, you get back an OpaqueResponse, it's a redirect, what happens next? You bypass the SW for future requests? What if those fail?","msgtype":"m.text"},"ts":1401194671000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: pretty sure event.default() came about to deal with base urls after redirects","msgtype":"m.text"},"ts":1401194701000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it came about because there was no way to do the same thing as return null","msgtype":"m.text"},"ts":1401194730000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: redirects expose that pretty badly, but they're not the only thing","msgtype":"m.text"},"ts":1401194745000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: you're right, for subresources if you get a successful redirect which results in a failure, you won't hear about it in the SW","msgtype":"m.text"},"ts":1401194827000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1401194828000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: If event.default is the answer, your suggestion of how to hook it into the fetch spec seems the most sensible way","msgtype":"m.text"},"ts":1401194985000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"SimonSapin/TabAtkins: Around?","msgtype":"m.text"},"ts":1401195005000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: yes, but just ask :) http://www.nohello.com/","msgtype":"m.text"},"ts":1401195063000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"JakeA: again, we could overload fetch() to do this too, it would need exactly the same hooks","msgtype":"m.text"},"ts":1401195072000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: the reasons are redirects, correct referrer, correct CSP, correct context, etc.","msgtype":"m.text"},"ts":1401195099000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"SimonSapin: I believe life has found a bug in the CSS syntax spec: https://code.google.com/p/chromium/issues/detail?id=377510","msgtype":"m.text"},"ts":1401195109000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"JakeA: i.e. a fetch() which is passed a Request object that has its UA-bit set","msgtype":"m.text"},"ts":1401195139000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: that solution however seems much less elegant, I'd much rather truncate the UA-bit when such an object is passed to fetch() and have fetch() always do the same thing","msgtype":"m.text"},"ts":1401195178000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"SimonSapin: Basically, when we encounter something like \"+-5\", we check if \"-5\" is a number (which it is), and then continue to parse \"+-5\" as a number, which fails","msgtype":"m.text"},"ts":1401195223000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"annevk: yeah, this is why I was interested in request.send()","msgtype":"m.text"},"ts":1401195254000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yoav: that sounds wrong, let me check","msgtype":"m.text"},"ts":1401195272000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"annevk: although that gets complicated when it comes to those requests going in & out of caches","msgtype":"m.text"},"ts":1401195288000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"SimonSapin: it's fairly possible that I got the spec wrong. This is what happens in my impl (which I think is per spec)","msgtype":"m.text"},"ts":1401195315000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"s/got/read/","msgtype":"m.text"},"ts":1401195323000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"JakeA: the problems would seem to apply to default() too","msgtype":"m.text"},"ts":1401195390000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: request.send() we could still do I suppose and do away with fetch()","msgtype":"m.text"},"ts":1401195410000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: event.default().then(r => console.log(r.url)) - is exposing that a security leak given redirects?","msgtype":"m.text"},"ts":1401195440000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"So. Consume a token starts with \" Consume the next input code point\", which becomes the \"current input code point\". When that’s '+', we check \"If the input stream starts with a number\" which works on three code points, \"the current input code point and the next two input code points, in that order\", so \"+-5\"","msgtype":"m.text"},"ts":1401195537000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"… which returns false","msgtype":"m.text"},"ts":1401195546000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"JakeA: no, note that if it's opaque that would just return the empty string","msgtype":"m.text"},"ts":1401195632000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav: I believe the spec is correct in this case","msgtype":"m.text"},"ts":1401195633000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: OK, so the first code point is the already consumed one?","msgtype":"m.text"},"ts":1401195659000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"If so, the spec's probably right, and I read it wrong","msgtype":"m.text"},"ts":1401195677000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"\"The algorithm described here can be called explicitly with three code points, or can be called with the input stream itself. In the latter case, the three code points in question are the current input code point and the next two input code points, in that order.\"","msgtype":"m.text"},"ts":1401195695000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"current input code point  is defined as      The last code point to have been consumed.","msgtype":"m.text"},"ts":1401195715000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"annevk: but it won't always be opaque. Say it goes to another server, then comes back with a token in the url. The response is non-opaque, but url is leaking data","msgtype":"m.text"},"ts":1401195737000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"SimonSapin: OK, thanks! I'll fix my bugs then :)","msgtype":"m.text"},"ts":1401195756000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"I agree this is a bit convoluted, but I don’t know how to make it better without drowning in verbosity","msgtype":"m.text"},"ts":1401195770000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"JakeA: how would that be different from an XHR doing the same thing?","msgtype":"m.text"},"ts":1401195971000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: btw, that's only non-opaque if it's CORS","msgtype":"m.text"},"ts":1401195986000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: see fourth clause of step 6 of http://fetch.spec.whatwg.org/#concept-fetch","msgtype":"m.text"},"ts":1401196069000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Maybe I need to find out more about the redirect security issue. I thought the final request url was a problem because it may contain tokens added by another server","msgtype":"m.text"},"ts":1401196094000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yes it can","msgtype":"m.text"},"ts":1401196128000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I documented the issue here: http://fetch.spec.whatwg.org/#atomic-http-redirect-handling","msgtype":"m.text"},"ts":1401196152000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: if you can explain to me how you would obtain that secret I'd be happy to hear it","msgtype":"m.text"},"ts":1401196177000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ah, so the request gets tained when it goes to the other server, but remains tained when it comes back to the local server?","msgtype":"m.text"},"ts":1401196191000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yes, once you're tainted there's no going back","msgtype":"m.text"},"ts":1401196218000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ahh ok, that's the bit that was breaking my understanding","msgtype":"m.text"},"ts":1401196236000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: Sorry about that, I thought XHR would come back non-opaque","msgtype":"m.text"},"ts":1401196444000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"XHR would have bailed at that point","msgtype":"m.text"},"ts":1401196463000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1401196474000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"<img> would be tainted","msgtype":"m.text"},"ts":1401196496000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"& fetch() would return OpaqueResponse","msgtype":"m.text"},"ts":1401196516000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"So a cross-origin redirect to a same-origin URL that acts as a paint server cannot communicate using that","msgtype":"m.text"},"ts":1401196547000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah, fetch() without mode set to CORS is basically <img>","msgtype":"m.text"},"ts":1401196570000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"We need to decide what we want as default for mode","msgtype":"m.text"},"ts":1401196581000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"If it's CORS or tainted cross-origin","msgtype":"m.text"},"ts":1401196587000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"!summon Philip`","msgtype":"m.text"},"ts":1401196686000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"annevk: Judged by the request object I guess. I like the idea of setting \"context\" in the Request constructor to set defaults for headers, so probably CORS too","msgtype":"m.text"},"ts":1401196758000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Philip`: Any idea if http://w3c-test.org/2dcontext/fill-and-stroke-styles/2d.pattern.image.broken.html has a race between the image (failing to) load and the assert?","msgtype":"m.text"},"ts":1401196783000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Should there ben an event?","msgtype":"m.text"},"ts":1401196789000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"XHR's behaviour is a good default though","msgtype":"m.text"},"ts":1401196795000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"SimonSapin: I think the source of my mixup is that impl function naming doesn't match the spec. I'll align the impl terminology with the spec's one","msgtype":"m.text"},"ts":1401196863000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: you mean things like \"current input code point\"?","msgtype":"m.text"},"ts":1401196936000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"I admit I haven’t tried to keep my impls that close to the spec","msgtype":"m.text"},"ts":1401196951000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"JakeA: I forgot the idea around context, you might want to file a bug on that","msgtype":"m.text"},"ts":1401197158000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: https://github.com/slightlyoff/ServiceWorker/issues/279","msgtype":"m.text"},"ts":1401197206000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"jgraham: looks like it","msgtype":"m.text"},"ts":1401197269000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: ah right, I guess at some point that should be a bug on Fetch","msgtype":"m.text"},"ts":1401197741000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: not sure how you'd make CORS dependant on that, most contexts allow both","msgtype":"m.text"},"ts":1401197757000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Is that where the Request constructor will live?","msgtype":"m.text"},"ts":1401197774000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah","msgtype":"m.text"},"ts":1401197794000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"cool, makes sense","msgtype":"m.text"},"ts":1401197800000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"SimonSapin: Yeah, that's the part that confused me (currentCP referred to the next non-consumed CP in my impl, which I'm now changing)","msgtype":"m.text"},"ts":1401197852000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"JakeA: any reason the service worker spec has no style sheet?","msgtype":"m.text"},"ts":1401198338000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: is that because someone updated the bs backend system again?","msgtype":"m.text"},"ts":1401198360000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Are we talking about https://slightlyoff.github.io/ServiceWorker/spec/service_worker/? It has styles for me","msgtype":"m.text"},"ts":1401198463000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so maybe it's a mixed content link somewhere that chrome doesn't block?","msgtype":"m.text"},"ts":1401198499000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I get styles in Firefox too","msgtype":"m.text"},"ts":1401198509000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Even in the nightlies","msgtype":"m.text"},"ts":1401198519000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Happens to me from time to time. Not sure what it is.","msgtype":"m.text"},"ts":1401198532000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"JakeA: I use 32.0a1 (2014-05-27)","msgtype":"m.text"},"ts":1401198544000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Console says \"Error: https://slightlyoff.github.io/ServiceWorker/spec/assets/web-spec-framework/bower_components/platform/platform.js is being assigned a //# sourceMappingURL, but already has one\"","msgtype":"m.text"},"ts":1401198566000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I get styles in 32.0a1 (2014-05-21). Updating now","msgtype":"m.text"},"ts":1401198572000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Sounds like dependency management gone wrong","msgtype":"m.text"},"ts":1401198576000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I get that error too, but still get styles","msgtype":"m.text"},"ts":1401198579000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Oh","msgtype":"m.text"},"ts":1401198583000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I don't understand why this spec has such a complex setup :/","msgtype":"m.text"},"ts":1401198613000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"There's a gazillion script files","msgtype":"m.text"},"ts":1401198649000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Hmm, yeah, no styles in 32.0a1 (2014-05-27)","msgtype":"m.text"},"ts":1401198650000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: yeah, it's difficult to deal with. Breaks when parsed with anything but a modern browser (e.g. jsdom doesn't support it very well)","msgtype":"m.text"},"ts":1401200091000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"Hard to get the ToC out as it's inside an iframe. Etc.","msgtype":"m.text"},"ts":1401200117000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"annevk: Welcome to the web of the future","msgtype":"m.text"},"ts":1401200281000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"JakeA: is the current class distinction between response objects useful?","msgtype":"m.text"},"ts":1401200471000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"jgraham: yeah, sincerely hope Web components are more straightforward than the current polyfills. If not, we're in for a world of hurt.","msgtype":"m.text"},"ts":1401200484000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"JakeA: how about a single object with a property to inspect what kind you have?","msgtype":"m.text"},"ts":1401200489000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: requiring typeof seems not really JavaScript-y","msgtype":"m.text"},"ts":1401200506000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I don't have a strong opinion","msgtype":"m.text"},"ts":1401200654000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so if new Request takes (url, init), should new Response take (body, init)?","msgtype":"m.text"},"ts":1401200688000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yes","msgtype":"m.text"},"ts":1401200736000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: https://github.com/slightlyoff/ServiceWorker/issues/192#issuecomment-40737493","msgtype":"m.text"},"ts":1401200759000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: k, sketching out API in Fetch now","msgtype":"m.text"},"ts":1401200795000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: open issues in my API sketch are body and header representation","msgtype":"m.text"},"ts":1401201252000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"\"can you elaborate\" in this instance, guessing not","msgtype":"m.text"},"ts":1401201459000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"zewt: ?","msgtype":"m.text"},"ts":1401201805000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: http://fetch.spec.whatwg.org/#fetch-api","msgtype":"m.text"},"ts":1401202317000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"isn't sure he likes the future","msgtype":"m.emote"},"ts":1401203162000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"also wonders when he gets his jetpack or flying car","msgtype":"m.emote"},"ts":1401203175000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"annevk: looks good, I'll have a think how to provide default values to Request based on a context (maybe context is enough)","msgtype":"m.text"},"ts":1401204186000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: that'd mean we'd have a distinct context and context-for-CSP, which may be okay, but it's yet another field","msgtype":"m.text"},"ts":1401204237000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: should prolly discuss that with implementers","msgtype":"m.text"},"ts":1401204264000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: the alternative is different request constructors. ImageRequest, FontRequest etc etc","msgtype":"m.text"},"ts":1401204280000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"bleh","msgtype":"m.text"},"ts":1401204284000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: no, the alternative is not having the feature","msgtype":"m.text"},"ts":1401204316000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: syntax for the feature is a separate discussion ;-)","msgtype":"m.text"},"ts":1401204327000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(though just a field seems fine, if we do it)","msgtype":"m.text"},"ts":1401204338000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"good morning, Whatwg!","msgtype":"m.text"},"ts":1401205046000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"jgraham: The test should not run until window.onload, and I probably assumed onload would not be triggered until the image had either succeeded or failed to load","msgtype":"m.text"},"ts":1401211352000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Maybe in theory it's possible for the browser to realise the image cannot succeed, so it decides to send the load event, but doesn't actually mark the image as failed until some arbitrary later time","msgtype":"m.text"},"ts":1401211392000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"though that would seem silly","msgtype":"m.text"},"ts":1401211396000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"has no idea what the spec said when he wrote the test, and even less idea what it says now","msgtype":"m.emote"},"ts":1401211411000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Philip`: Yeah, I realised that. It seems like browsers are wrong in not firing an error there, although they will if the PNG header is corrupted","msgtype":"m.text"},"ts":1401211490000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"(I mean firing an error in the canvas operation; I *think* the cases are expected to differ on whether there is a load event for the image)","msgtype":"m.text"},"ts":1401211536000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Additionally it seems like there is some kind of network race in Gecko","msgtype":"m.text"},"ts":1401211550000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"I vaguely remember that the whole thing with images loading/failing was a total mess in implementations and in the spec, so I didn't look at it too closely","msgtype":"m.text"},"ts":1401211615000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Maybe I should just file a bug on Gecko saying \"this seems to race\" and disable the test","msgtype":"m.text"},"ts":1401211663000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"That sounds like shirking responsibility for the problem","msgtype":"m.text"},"ts":1401211824000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"so I approve","msgtype":"m.text"},"ts":1401211829000,"senderName":"Philip`","senderId":"Philip`@irc"},
{"content":{"body":"Sadly, my taking responsibility for every problematic test is a non-converging approach since we are adding new non-deterministic tests faster than I resolve the issues with existing ones.","msgtype":"m.text"},"ts":1401212629000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"So it's a necessary solution :(","msgtype":"m.text"},"ts":1401212642000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"maybe there should be some kind of policy where the people who add the races need to handle it","msgtype":"m.text"},"ts":1401212737000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: Sadly there are a bunch of reasons that doesn't work","msgtype":"m.text"},"ts":1401212989000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Like it isn't clear who added the race","msgtype":"m.text"},"ts":1401212997000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"It isn't clear how important the race is","msgtype":"m.text"},"ts":1401213009000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"that second one looks harder","msgtype":"m.text"},"ts":1401213024000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"It's difficult to reproduce the race on other hardware/configurations/whatever","msgtype":"m.text"},"ts":1401213035000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1401213042000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"and is it hard to reproduce that configuration to bisect the issue?","msgtype":"m.text"},"ts":1401213060000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"In general intermittent tests are the bane of web browser testing","msgtype":"m.text"},"ts":1401213061000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"and I guess intermittence is hard to determine for sure itself","msgtype":"m.text"},"ts":1401213077000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"that's the crux, huh?","msgtype":"m.text"},"ts":1401213082000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"Yeah, everything is hard when bugs are intermittent","msgtype":"m.text"},"ts":1401213237000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"annevk: You around?  I think there's some miscommunication about the \"status\" thing in Font Loading.  Basically, I have no idea what you're talking about. ^_^","msgtype":"m.text"},"ts":1401218545000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"The \"status\" is an exposed enumerated attribute on the FontFace object.  I don't understand what further needs to be done about when it gets set, since the algo that sets it is already async, unless maybe the entire async portion of the algo (and all the rest of my async algos) need to specify what task queue they run in?","msgtype":"m.text"},"ts":1401218604000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: in step 4 you set status to \"loading\"; my question is if anyone can ever observe status being \"loading\"","msgtype":"m.text"},"ts":1401220320000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: and how they are notified of that change that they can now observe such a thing","msgtype":"m.text"},"ts":1401220337000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Oh, now I see what you're saying!","msgtype":"m.text"},"ts":1401220363000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"will Web Components support SVG templates?","msgtype":"m.text"},"ts":1401220364000,"senderName":"jarek","senderId":"jarek@irc"},
{"content":{"body":"e.g. will it be possible to do: <link rel=\"import\" href=\"/someFile.svg\">","msgtype":"m.text"},"ts":1401220377000,"senderName":"jarek","senderId":"jarek@irc"},
{"content":{"body":"Yeah, whether or not that's observable is a good question.","msgtype":"m.text"},"ts":1401220381000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: if in an async algorithm you don't define when a state transition in the main thread happens, you risk obj.status != obj.status due to the asynchronous nature of things and that would be bad","msgtype":"m.text"},"ts":1401220388000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"You can certainly observe \"loading\" at a well-defined time if you have a url-based font - it switches sync when you or the system calls .load().","msgtype":"m.text"},"ts":1401220440000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"But in the binary data case, hm.","msgtype":"m.text"},"ts":1401220447000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Okay, so pretend that I want to make it observable.  How do I fix this?  Push the rest of the algo past that point into another task?","msgtype":"m.text"},"ts":1401220470000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Or queue a task to set it to \"loading\"?","msgtype":"m.text"},"ts":1401220490000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(and then queue another one to set it to \"loaded\" or \"error\"?)","msgtype":"m.text"},"ts":1401220504000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: I don't get why for the parsing case you need to set it to \"loading\"","msgtype":"m.text"},"ts":1401220605000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: it seems like you should just set it to \"loaded\" or \"error\" and that's sufficient","msgtype":"m.text"},"ts":1401220620000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It might not be necessary, sure.","msgtype":"m.text"},"ts":1401220626000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"But it looks like your objection extends to the loaded/error case, too, right?","msgtype":"m.text"},"ts":1401220640000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: no, those are observable due to the promise being resolved/rejected","msgtype":"m.text"},"ts":1401220656000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: the \"loaded\" case has no corresponding task","msgtype":"m.text"},"ts":1401220666000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: well actually, you're right I guess","msgtype":"m.text"},"ts":1401220688000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: you might want to mention this in your guide","msgtype":"m.text"},"ts":1401220700000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: if you set observable state in addition to rejecting/resolving a promise, that ideally happens in the same microtask","msgtype":"m.text"},"ts":1401220726000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Is it implicit that promise resolving always happens in some microtask?","msgtype":"m.text"},"ts":1401220788000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Rather than async sometime in the middle of your executing code?","msgtype":"m.text"},"ts":1401220799000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(Or maybe it doesn't matter, because *responding* to a promise always happens in the next microtask.)","msgtype":"m.text"},"ts":1401220813000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: promise resolving can happen whenever, since it's only observable in a microtask","msgtype":"m.text"},"ts":1401220825000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: however, if you resolve and change observable state at the same time, there's a potential problem that Domenic needs to solve","msgtype":"m.text"},"ts":1401220846000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I felt this was kind of covered in the guide","msgtype":"m.text"},"ts":1401225354000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Queued tasks take place after next microtask","msgtype":"m.text"},"ts":1401225362000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"What’s the status of Element.prototype.findAll / find? Is that still happening?","msgtype":"m.text"},"ts":1401233634000,"senderName":"JonathanNeal","senderId":"JonathanNeal@irc"},
{"content":{"body":"anyone here a JS module expert who can answer me some questions? I'm trying to work out if I can walk the dependency tree using the ES6 module API","msgtype":"m.text"},"ts":1401233717000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"still dubious about adding an api entry point that's basically just an alias for something else","msgtype":"m.text"},"ts":1401233738000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"starts a sentence \"HTML Imports import other Imports\" and then realises he's gonna have to start over","msgtype":"m.emote"},"ts":1401233912000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"HTML imports importing other imports is an important feature","msgtype":"m.text"},"ts":1401234347000,"senderName":"astearns","senderId":"astearns@irc"}
]