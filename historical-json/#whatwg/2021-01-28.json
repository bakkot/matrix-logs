[
{"content":{"body":"JakeA: if you're around could you look at https://github.com/whatwg/fetch/pull/1144?","msgtype":"m.text"},"ts":1611832938000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: in onfetch, can you modify ev.request.headers?","msgtype":"m.text"},"ts":1611832953000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"per https://w3c.github.io/ServiceWorker/#on-fetch-request-algorithm at least that should be no","msgtype":"m.text"},"ts":1611833044000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I didn't think you could modify them","msgtype":"m.text"},"ts":1611833122000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I'll take a look","msgtype":"m.text"},"ts":1611833124000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: thanks, the context is making Fetch and SW play nice for request streams","msgtype":"m.text"},"ts":1611833164000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: \"This may be the first time a single unit of session storage has been shared between a (process, origin) pair\" is an astute observation that might well influence things; I don't actually know enough about how sessionStorage is implemented","msgtype":"m.text"},"ts":1611837727000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hopefully it's similar enough to localstorage so it doesn't matter","msgtype":"m.text"},"ts":1611839922000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk/JakeA: not sure what the context of the discussion is here, but at least in the Chrome implementation of session storage we explicitly don't support sharing session storage across processes, and I think allowing that would be a non-trivial effort with how copy-on-write and change events are implemented in chrome...","msgtype":"m.text"},"ts":1611855168000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: say so in https://github.com/whatwg/storage/issues/119","msgtype":"m.text"},"ts":1611855327000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"will do","msgtype":"m.text"},"ts":1611855604000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: I guess that only really applies when within the same site you go from non-COOP to COOP, as otherwise the relevant processes could be the same. But none of that is really an ideal building block for a coherent model...","msgtype":"m.text"},"ts":1611855819000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I guess the coherent model would be to always reset upon COOP","msgtype":"m.text"},"ts":1611855852000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah, and for the navigation case it wouldn't be bad either since there would only be one process accessing it at a time anyway (i.e. it's changing processes, but still one at a time). The prerender case would be harder (and I thought was one of the reasons portals ended up blocking storage before activation)","msgtype":"m.text"},"ts":1611855893000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: ah okay, that's an important distinction, in that case there might not be a problem at all","msgtype":"m.text"},"ts":1611855955000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"No blocking same-origin though for portals/prerendering.","msgtype":"m.text"},"ts":1611855961000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"oh, I guess I misunderstood where portals currently stands...","msgtype":"m.text"},"ts":1611856043000,"senderName":"Mek","senderId":"Mek@irc"}
]