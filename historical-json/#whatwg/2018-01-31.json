[
{"content":{"body":"a-ja: in browsers?","msgtype":"m.text"},"ts":1517357736000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith, in validator","msgtype":"m.text"},"ts":1517357779000,"senderName":"a-ja","senderId":"a-ja@irc"},
{"content":{"body":"dunno but probably less costly than some other things Iâ€™m already doing","msgtype":"m.text"},"ts":1517358061000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith, fwiw, i've been thinking about a possible change to outline messages...another time, earlier in the day","msgtype":"m.text"},"ts":1517358398000,"senderName":"a-ja","senderId":"a-ja@irc"},
{"content":{"body":"basically re sectioning elements without headings but with aria labelling","msgtype":"m.text"},"ts":1517358483000,"senderName":"a-ja","senderId":"a-ja@irc"},
{"content":{"body":"ah ok","msgtype":"m.text"},"ts":1517358601000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Hm, WebIDL seems to say that I can't put [Exposed] on an interface *and* on that interface's members, but then how am I supposed to say \"all the members are exposed per A, but this one in particular is instead exposed per B\"?","msgtype":"m.text"},"ts":1517359324000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Does this mean I'd have to instead manually add [Exposed] to *every single member*?","msgtype":"m.text"},"ts":1517359350000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(Relevance: in Typed OM we want to expose all of our interfaces widely, but restrict the methods that involve CSS parsing to only be available in Window.)","msgtype":"m.text"},"ts":1517360194000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: I haven't checked this, but can you put the less-exposed ones on a separate partial interface?","msgtype":"m.text"},"ts":1517360226000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"Hm, both the algorithm and some following requirements imply that a member can have a different exposure set from the interface it's a part of.","msgtype":"m.text"},"ts":1517360419000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Yeah, I think this is a WebIDL bug - it contradicts itself in implications.","msgtype":"m.text"},"ts":1517362834000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Oh nm, that restriction is solely about members of *partial* interfaces - [Exposed] on a partial is implicitly putting it on all the members.  So, not relevant to me, but also doesn't seem necessary. Still filing a bug.","msgtype":"m.text"},"ts":1517363041000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: re array methods on Typed OM collections, what's the best case scenario? i.e., what should calling cssNumericArray.map() return? (a CSSNumericArray or just Array? should the type of the value returned from the map() callback be cast to CSSNumericValue?)","msgtype":"m.text"},"ts":1517372059000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"if returning an Array is okay then [LegacyArrayClass] + indexed getter would work, no?","msgtype":"m.text"},"ts":1517372139000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"Right now, it throws because undefined is not a function. ^_^","msgtype":"m.text"},"ts":1517372181000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"For the rest, I don't have a strong opinion, but JS *does* have support for good Array subclassing now, such that .map() could return your subclass.","msgtype":"m.text"},"ts":1517372211000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yeah that's why I said \"should\"","msgtype":"m.text"},"ts":1517372228000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"But it's probably fine to just return an Array too, since the subclass doesn't do anything additional, and our inputs are all `sequence<>`. Only downside would be that you couldn't directly assign to the attribute, when present.","msgtype":"m.text"},"ts":1517372270000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: hmm, is typed om implemented in any browser? If so I'd like to test something","msgtype":"m.text"},"ts":1517372328000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"Well, hm, I'm lying. It would be bad if `(new CSSUnparsedValue([\"one\"])).map(x->x)` returned an Array.","msgtype":"m.text"},"ts":1517372329000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It's behind a flag in Blink right now.","msgtype":"m.text"},"ts":1517372348000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: yeah it seems like different collections want different semantics for array methods","msgtype":"m.text"},"ts":1517372374000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"Sometimes maybe. But returning the same class as you started with seems pretty universally good, and supported by JS now.","msgtype":"m.text"},"ts":1517372403000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"If you really want an Array you can wash it thru `[...foo]`, after all.","msgtype":"m.text"},"ts":1517372423000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: how about type casting though? I assume you would want to force the result of map() to whatever element type is in the original collection?","msgtype":"m.text"},"ts":1517372457000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"TabAtkins: do you know what flag it is in Chrome?","msgtype":"m.text"},"ts":1517372479000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"Yeah, that would presumably cause an error to be thrown during the implicit construction of the new value.","msgtype":"m.text"},"ts":1517372484000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Experimental Web Platform features?","msgtype":"m.text"},"ts":1517372491000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"Precisely *when* the error is thrown (immediately after the callback returns a bad value, or when the callback is totally done) is an open question which needs to be answered, but whose answer is probably not important.","msgtype":"m.text"},"ts":1517372518000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Yeah, that's the flag.","msgtype":"m.text"},"ts":1517372523000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Okay, I'm looking into this","msgtype":"m.text"},"ts":1517372548000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":".push(), etc would also typecheck for you. Basically everything would indirect thru your constructor or your indexed setter, both of which should have the types you want.","msgtype":"m.text"},"ts":1517372581000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TimothyGu: I forget what browser you work for. ^_^","msgtype":"m.text"},"ts":1517372628000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: I'm a first-year undergrad","msgtype":"m.text"},"ts":1517372667000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1517372676000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"ah, kk","msgtype":"m.text"},"ts":1517372679000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I'll intern at Google this summer though","msgtype":"m.text"},"ts":1517372689000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"(Chrome)","msgtype":"m.text"},"ts":1517372693000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"+1","msgtype":"m.text"},"ts":1517372693000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: question: why did y'all decide on rest params for CSSUnparsedValue's constructor instead of a sequence<>?","msgtype":"m.text"},"ts":1517372850000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"seems kinda odd when basically everything else takes a sequence","msgtype":"m.text"},"ts":1517372874000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"I think we didn't have any particular reason, but since it's inconsistent with CSSTransformValue we should harmonize those two.","msgtype":"m.text"},"ts":1517372879000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: yeah, should I file a ticket or is that a known issue?","msgtype":"m.text"},"ts":1517372910000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"file issue plz","msgtype":"m.text"},"ts":1517372916000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: https://github.com/w3c/css-houdini-drafts/issues/618","msgtype":"m.text"},"ts":1517373182000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"danke","msgtype":"m.text"},"ts":1517373271000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"de nada","msgtype":"m.text"},"ts":1517373283000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"TabAtkins: interface exposed a,b meber exposed a should work; does for XHR at least","msgtype":"m.text"},"ts":1517375325000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah, discovered that it's fine, the paragraph I was confused about only applied to *partial* interfaces.","msgtype":"m.text"},"ts":1517375349000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"annevk: Do you have some examples of indexed getters/setters on the platform? I need to see what current ones do when you get/set an index that doesn't have an associated value.","msgtype":"m.text"},"ts":1517375625000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"We donâ€™r use those anymore; theyâ€™re to be renamed legacy","msgtype":"m.text"},"ts":1517375677000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"That's cool and all, but until we actually resolve the array-like issue I'm still using them, and would like to be consistent with the rest of the platform.","msgtype":"m.text"},"ts":1517375945000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(Turns out engines all special-case indexed getters/setters and run them much more efficiently than a general proxy would.)","msgtype":"m.text"},"ts":1517376001000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(I'd love to make them legacy and get something better, they're so manual and frustrating, when so much of it should be automatic.)","msgtype":"m.text"},"ts":1517376038000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"You cannot be consistent if you refuse to be soâ€¦","msgtype":"m.text"},"ts":1517376284000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I can't be consistent with something that's nonexistent, either!","msgtype":"m.text"},"ts":1517376365000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Looks like getters all return null, per the DOM spec. None of these have setters. :/","msgtype":"m.text"},"ts":1517376384000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(It's been almost a year since the last time I said \"hey, my spec has three array-likes, sure would be good to make IDL support that properly\", and nothing's happened since then, so don't try and shame me about this.)","msgtype":"m.text"},"ts":1517376460000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Saying itâ€™s somebody else their problem is a little weird","msgtype":"m.text"},"ts":1517376582000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"And you got ample feedback there too about the platform not doing this","msgtype":"m.text"},"ts":1517376614000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"No, I got pushback from *you* about this, while Boris supported it. Yay for contradictory advice!","msgtype":"m.text"},"ts":1517376653000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Domenic pushed back too","msgtype":"m.text"},"ts":1517376672000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TC39 would push back too","msgtype":"m.text"},"ts":1517376696000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Sure. I don't think counting 2 vs 1 is reasonable here?","msgtype":"m.text"},"ts":1517376700000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Nah, TC39 explicitly supported integer catchalls several years back, and I've gotten feedback that they're just fine perf-wise in engines.","msgtype":"m.text"},"ts":1517376729000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Maybe we should bring it up with the TAG?","msgtype":"m.text"},"ts":1517376732000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I doubt TC39 did that, pointer?","msgtype":"m.text"},"ts":1517376764000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(Nobody ended up *doing* anything about it in TC39, but we still have the records with several people enthusiastically supporting, including several current members.)","msgtype":"m.text"},"ts":1517376772000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It was linked in the WebIDL issue, let me go get it.","msgtype":"m.text"},"ts":1517376782000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"https://lists.w3.org/Archives/Public/public-webapps/2009JulSep/1346.html","msgtype":"m.text"},"ts":1517376844000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(follow the thread linked from that message)","msgtype":"m.text"},"ts":1517376893000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"The outcome of that discussion was to stop doing live lists","msgtype":"m.text"},"ts":1517376913000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yes? That's correct and a good conclusion.","msgtype":"m.text"},"ts":1517376933000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"As I've said multiple times, I'm not doing live lists.","msgtype":"m.text"},"ts":1517376947000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"So why not return arrays then?","msgtype":"m.text"},"ts":1517376985000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":":deep breath: I'm repeating myself, but: because they're not arrays. They're other objects with branding concerns, which have restrictions on what types of objects they contain, and sometimes have useful methods hanging off of them that are only reasonable for their specific type.","msgtype":"m.text"},"ts":1517377078000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Anyway, I think to be more productive I should study what you are trying to do in more detail. Itâ€™s been a while.","msgtype":"m.text"},"ts":1517377090000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Luckily for you, I just posted an update about that: https://github.com/heycam/webidl/issues/345#issuecomment-361814861","msgtype":"m.text"},"ts":1517377125000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It seems you could enforce validation when setting though. Thatâ€™s how everything else works.","msgtype":"m.text"},"ts":1517377132000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Cool, Iâ€™ll check it out later today","msgtype":"m.text"},"ts":1517377161000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"No (a) I can't do that easily (it would be both more expensive *and* would delay catching errors for no author benefit), and (b) that's *not* how everything else works, every single other thing in WebIDL typechecks eagerly as soon as you set a value.","msgtype":"m.text"},"ts":1517377198000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"foo.bar = \"something invalid\" throws immediately; foo[1] = \"something invalid\" should too.","msgtype":"m.text"},"ts":1517377219000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"foo(\"something invalid\") throws immediately, but if the brand check succeeds we generally depend on the object being correct, and don't do recursive type-checking by hand.  (I'd be interested if you could find an instance of such manual recursive type-checking.)","msgtype":"m.text"},"ts":1517377291000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Eg Headers constructor","msgtype":"m.text"},"ts":1517377362000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"That's in Fetch?","msgtype":"m.text"},"ts":1517377380000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Yes","msgtype":"m.text"},"ts":1517377385000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ah, that's not an example of such. (a) it's not recursive, it just checks *one* layer down in the passed sequence, and (b) it's just papering over a deficiency in WebIDL that prevents you from explicitly saying that you take a `map-sequence<ByteString, ByteString>`, so you're having to manually roll that check; all it does it verify that each item has precisely two entries.  (Besides the length-checking, the actual","msgtype":"m.text"},"ts":1517377620000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"type-checking is still done automatically for you by IDL.)","msgtype":"m.text"},"ts":1517377620000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(And that's captured in https://github.com/heycam/webidl/issues/324 too; there are questions about what to do with map-sequence<> as a return type, but as an argument type it's nice and simple.)","msgtype":"m.text"},"ts":1517377733000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"MikeSmith: are you logging URLs too?","msgtype":"m.text"},"ts":1517381718000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"tobie: Yo, would you take a PR for `pair-sequence<>`? Looking at `sequence<>`, it looks pretty easy to spec.","msgtype":"m.text"},"ts":1517382537000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: I didnâ€™t read up on the thread, but if thereâ€™s consensus and implementor interest, sure.","msgtype":"m.text"},"ts":1517382737000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"I'll write it up and we'll see. I think there's only one consumer at the moment - `Headers` - because the only maplike I'm in charge of isn't currently constructable.","msgtype":"m.text"},"ts":1517382848000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Hm, about that: Domenic, annevk, we generally want *all* objects to be constructable, right?  I've got nothing against making StylePropertyMap constructable, you just can't *do* anything with manually constructed instances (all attributes of that type are `readonly`).","msgtype":"m.text"},"ts":1517382948000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: https://github.com/w3ctag/design-principles/issues/44","msgtype":"m.text"},"ts":1517383049000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: so generally yes, with some exceptions","msgtype":"m.text"},"ts":1517383061000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: if it's not useful I wouldn't add a constructor","msgtype":"m.text"},"ts":1517383121000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hm, that's for using constructors vs factory methods.","msgtype":"m.text"},"ts":1517383126000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"kk","msgtype":"m.text"},"ts":1517383126000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Hey everyone! I've seen ricea's comment on data channel streams (https://github.com/w3c/webrtc-pc/issues/1732#issuecomment-361843997) and was wondering how passing a readable stream to the send method would look like if I were to write in chunks... do you have an example for that?","msgtype":"m.text"},"ts":1517398965000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Basically, my question is how the examples (https://github.com/w3c/webrtc-pc/issues/1732#issuecomment-357442429) would have to be rewritten for providing a readable stream on a send call.","msgtype":"m.text"},"ts":1517399001000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: if you construct your own RS you can push stuff in that the data channel would then read","msgtype":"m.text"},"ts":1517400432000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: that is how upload fetch() works, but not yet implemented","msgtype":"m.text"},"ts":1517400462000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'd be interested in how that would look like if I don't have a readable stream beforehand (so, I need to construct one of my own)","msgtype":"m.text"},"ts":1517400518000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: it does not use WS since ideal WS usage requires the underlying buffer, which would require a callback of sorts and was not feasible impl wise","msgtype":"m.text"},"ts":1517400537000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Okay... but that means constructing a writable stream on RTCDataChannel and writing into that is theoretically more effizient with BYOB (once we have that for writable stream)?","msgtype":"m.text"},"ts":1517400676000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"jeez, that German thrown into there... *efficient :)","msgtype":"m.text"},"ts":1517400697000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: could not find a quick example, but https://streams.spec.whatwg.org/#rs-constructor has a description","msgtype":"m.text"},"ts":1517400698000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: if the impl could give you access to the networking layerâ€™s buffer, yes, but not sure how feasible that is given framing and such","msgtype":"m.text"},"ts":1517400769000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: I suspect some piping will be necessary","msgtype":"m.text"},"ts":1517400809000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Fetch should probably have an example for this","msgtype":"m.text"},"ts":1517400889000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I worked on the FF data channel implementation and yeah that should be possible if I'm not mistaken. So, would you rather say we should go for .createWritableStream instead of .send(myReadableStream)?","msgtype":"m.text"},"ts":1517400895000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: or make send() return it; is synchronous acceptable though?","msgtype":"m.text"},"ts":1517400950000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It's only sync so far.","msgtype":"m.text"},"ts":1517400978000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: I mean getting sync access to the buffer","msgtype":"m.text"},"ts":1517401000000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'm not sure what you mean by that","msgtype":"m.text"},"ts":1517401038000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Argh","msgtype":"m.text"},"ts":1517401126000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"lgrahl: Iâ€™m prolly mistaken and itâ€™s not an issue","msgtype":"m.text"},"ts":1517401175000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Returning a writable stream on .send() would be an idea but I'm not a fan of it because I think it creates an awkward API. Also, .send would have to know when it should return a writable stream.","msgtype":"m.text"},"ts":1517401177000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Ms2ger: wb","msgtype":"m.text"},"ts":1517401212000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: it does seem a little weird if this can get away with using WS, but not fetch()","msgtype":"m.text"},"ts":1517401267000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: curious what ricea and yhirano__ think","msgtype":"m.text"},"ts":1517401288000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: fair re send(); be good to keep the name relatively short though","msgtype":"m.text"},"ts":1517401373000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ideas welcome :)","msgtype":"m.text"},"ts":1517401406000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"annevk, I'd actually written some more tests for that createImageBitmap PR you reviewed, but I forgot to commit","msgtype":"m.text"},"ts":1517401430000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Boo, git","msgtype":"m.text"},"ts":1517401432000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: happy to review","msgtype":"m.text"},"ts":1517401452000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Coming up in a minute","msgtype":"m.text"},"ts":1517401461000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: was planning on writing more too for that PR","msgtype":"m.text"},"ts":1517401468000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: now I figured out Blob is similar to <img>","msgtype":"m.text"},"ts":1517401490000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I'll try to find time to do a closer review, but not sure I'll be able to","msgtype":"m.text"},"ts":1517401507000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"aneevk: My current idea was to just throw buffers into the WS (which are then consumed) and hope you come up with a good idea for BYOB writer. Wouldn't that work for fetch too?","msgtype":"m.text"},"ts":1517401528000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Probably some of these tests should run in workers too","msgtype":"m.text"},"ts":1517401562000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"lgrahl: then itâ€™s not better than RS iirc, but really need the others for that discussion","msgtype":"m.text"},"ts":1517401621000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: hopefully junov can help with that","msgtype":"m.text"},"ts":1517401655000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Freenode is flaky for me...","msgtype":"m.text"},"ts":1517401931000,"senderName":"lgrahl_","senderId":"lgrahl_@irc"},
{"content":{"body":"annevk: It's not better but it would allow us to switch later without breaking API. But yeah, it's a good idea if you discuss this together. Ping me if you need me.","msgtype":"m.text"},"ts":1517401941000,"senderName":"lgrahl_","senderId":"lgrahl_@irc"},
{"content":{"body":"lgrahl_: I'm hoping ricea will just chime in, I'm not super invested in this","msgtype":"m.text"},"ts":1517402203000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl_: I'm reading through https://github.com/yutakahirano/fetch-with-streams/issues/30 though to figure out why fetch() uses RS again (a lot of the stuff in the beginning isn't it I think)","msgtype":"m.text"},"ts":1517402246000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Okay. I'll grab lunch in the meantime. :)","msgtype":"m.text"},"ts":1517402348000,"senderName":"lgrahl_","senderId":"lgrahl_@irc"},
{"content":{"body":"lgrahl_: good plan; https://github.com/yutakahirano/fetch-with-streams/issues/30#issuecomment-95161858 seems like the conclusion","msgtype":"m.text"},"ts":1517402687000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl_: basically even with WS there's no guarantee you get the actual final buffer/sink for fetch()","msgtype":"m.text"},"ts":1517402713000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl_: and additionally for fetch() WS became awkward due to how Request works","msgtype":"m.text"},"ts":1517402742000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk, is a video with data URL src cross-origin?","msgtype":"m.text"},"ts":1517404079000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"annevk: Cheers. I don't understand these points entirely (lack of spec knowledge I guess) and so I'm not sure this would apply to data channels, too.","msgtype":"m.text"},"ts":1517404900000,"senderName":"lgrahl_","senderId":"lgrahl_@irc"},
{"content":{"body":"annevk: It really confuses me that readable streams are used by both ends. so I'm surprised by this (at least in terms of terminology).","msgtype":"m.text"},"ts":1517405035000,"senderName":"lgrahl_","senderId":"lgrahl_@irc"},
{"content":{"body":"annevk: Also, if I come back to the low-level use, creating a writer from a WS and passing chunks into it is easy. But constructing a RS and feeding chunks into it seems tedious because you need to write your own RS object (unless I missed something).","msgtype":"m.text"},"ts":1517405388000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Test works and passes right away... What'd I do wrong? :)","msgtype":"m.text"},"ts":1517405593000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Hmm, lgrahl disappeared","msgtype":"m.text"},"ts":1517405838000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: it shouldn't be","msgtype":"m.text"},"ts":1517405852000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: (re data: URL)","msgtype":"m.text"},"ts":1517405858000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: data: URLs are only an opaque origin (cross-origin) when they instantiate a realm","msgtype":"m.text"},"ts":1517405878000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Okay, thanks","msgtype":"m.text"},"ts":1517405930000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"This is getting a little annoying... Every test I try to write just passes in Chrome :)","msgtype":"m.text"},"ts":1517406054000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: have you done zero-width/height SVG inside a Blob yet?","msgtype":"m.text"},"ts":1517406096000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"No","msgtype":"m.text"},"ts":1517406108000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Although I'm not sure Chrome would fail that","msgtype":"m.text"},"ts":1517406126000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: can you help out with https://github.com/w3c/web-platform-tests/pull/9194 btw?","msgtype":"m.text"},"ts":1517406209000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah","msgtype":"m.text"},"ts":1517406231000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Not just now, though :)","msgtype":"m.text"},"ts":1517406237000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"annevk: Jeez, was I gone again? :X","msgtype":"m.text"},"ts":1517406353000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Changed some settings and hope Freenode is less flaky now...","msgtype":"m.text"},"ts":1517406456000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: you mean new RS(impl) is tedious? I guess it's a little more work than the equivalent writer","msgtype":"m.text"},"ts":1517406502000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: I think the main question is when you invoke write() can you ensure that writes to the outgoing buffer that the data channel uses or do you need to consume it somehow first before passing it on","msgtype":"m.text"},"ts":1517406580000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: but again, best to ask in the issue thread from ricea et al","msgtype":"m.text"},"ts":1517406591000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: it's a bit unfortunate the issue is getting sidetracked so much; seems everyone has to learn anew that it's about a single message (me included)","msgtype":"m.text"},"ts":1517406630000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: I find it a bit frustrating that whenever we ask you to do something moderately complicated in your API design, such as keeping consistency with other multimaps, or using arrays instead of proxies, or accepting a pair-sequence, you try to push back and say this really is Web IDL's job to figure out for you. Yes, maybe in an ideal world Web IDL would do more, but we're not there yet, so in the meantime it","msgtype":"m.text"},"ts":1517407022000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"would be good if you were able to accept advice without saying it's not your problem.","msgtype":"m.text"},"ts":1517407022000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(1) Your multimaps already aren't consistent with each other, or with Maps. That's somewhat of a problem, and in the issue about it I've been exploring the space a bit and figuring out what the consistent subset we actually need to work with is. Surprise, different things are sometimes different; trivial consistency is the hobgoblin, etc.","msgtype":"m.text"},"ts":1517407112000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"annevk: lgrahl: using writable stream for sending data is ideal; Fetch not doing that is really unfortunate stemming from some early design choices about the lifecycle of Request/Response objects. But I think Till from Mozilla is still interested in changing that if possible, even if just by adding writable stream sugar to save people the all-too-common pattern of creating an identity transform stream, piping to its","msgtype":"m.text"},"ts":1517407169000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"writable end, and sending the readable end to fetch","msgtype":"m.text"},"ts":1517407169000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I thought there were also some concerns around being actually able to have the highest performance solution rather than something that has to pipe?","msgtype":"m.text"},"ts":1517407220000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah those are Till's concerns, writable streams are more easily performant because piping can hide all the implementation details","msgtype":"m.text"},"ts":1517407247000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(2) \"Arrays instead of proxies\" has been a bugaboo for years; we just super disagree about some fundamental aspects here, and I'm not willing to give up on it. \"Just use arrays\" means accepting a pretty major inconsistency with every other aspect of WebIDL-mediated APIs, and results in a noticeably worse/awkwarder authoring experience.  Finally, the \"use arrays, not proxies\" position that you and Anne present is","msgtype":"m.text"},"ts":1517407256000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"*not* universal; see my frustration in the relevant WebIDL thread when I'm trying to work around y'all's issues and Boris is like \"lol, just use the proxy thing, that's why it's there, dunno what their problem is\".","msgtype":"m.text"},"ts":1517407256000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Domenic: that's not what I was trying to say ðŸ˜ƒ","msgtype":"m.text"},"ts":1517407271000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: I thought the problem was that implementations could not expose the actual underlying buffer to WS","msgtype":"m.text"},"ts":1517407289000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: but also, none of this has shipped, so maybe we should revisit","msgtype":"m.text"},"ts":1517407309000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: I think it can still fit with Request/Response if body is a callback","msgtype":"m.text"},"ts":1517407332000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Ah right about accurate desiredSize, yeah, that may not be perfectly possible, but it's already not possible with the pass-a-ReadableStream design","msgtype":"m.text"},"ts":1517407333000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Sorry guys, I'm getting disconnected all the time but I check the logs, so just ignore this is happening.","msgtype":"m.text"},"ts":1517407350000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"annevk: Yeah, I think new RS is a bit tedious... also when it comes to terminology because both sides use readers now. pipeTo isn't used... all of this seems awkward to me.","msgtype":"m.text"},"ts":1517407350000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"annevk: My understanding is that if I don't use BYOB mode, then I always hand out buffers I cannot reclaim (thus, they are implicitly consumed). So, if I create a non-byob reader for a data channel message, then the implementation hands out buffers that it cannot reclaim. On the other side, if I use a normal writer, I cannot reclaim buffers handed out by calls to .write. Correct me if I'm wrong.","msgtype":"m.text"},"ts":1517407350000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"annevk: Yes, people ask the same question over and over again in the issue... ;)","msgtype":"m.text"},"ts":1517407351000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"(3) Dunno what you're talking about with the pair-sequence thing. I'm saying that pair sequences are currently very awkward to write *and* read in WebIDL, and it'd be better to have it be a named concept. I then today offered to *write the WebIDL text for such a feature*.  The more map-likes that appear on the platform the more valuable this will be; spec authors will work around it (or get things subtly different,","msgtype":"m.text"},"ts":1517407361000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"because it's awkward) otherwise.","msgtype":"m.text"},"ts":1517407361000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Domenic: no, I'm also not talking about Content-Length","msgtype":"m.text"},"ts":1517407362000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well that's the only way I can see WritableStreams exposing the buffer","msgtype":"m.text"},"ts":1517407406000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"TabAtkins: I've given up long ago on convincing you, especially on these issues, but I'm hopeful you'll notice this pattern in your behavior for the future.","msgtype":"m.text"},"ts":1517407434000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And who knows, maybe the TAG will save us from these APIs","msgtype":"m.text"},"ts":1517407446000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So seriously, pretending that I'm pushing back or complaining \"whenever we ask you to do something moderately complicated\" is an incorrect and frankly insulting characterization of this; look at all the other complicated API surface I've happily written and accepted elsewhere.","msgtype":"m.text"},"ts":1517407457000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Hmm","msgtype":"m.text"},"ts":1517407636000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Domenic: I had this notion in my head that doing WS properly was too hard and UAs would have to pipe/consume anyway and couldn't get the developer-provided bytes/memory close enough to the metal","msgtype":"m.text"},"ts":1517407667000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"If I call createImageBitmap with video whose src is a cross-origin URL which redirects to a same-origin URL, is the result origin-clean?","msgtype":"m.text"},"ts":1517407698000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Domenic: but maybe the only issue is Request being too early and a callback being a little awkward","msgtype":"m.text"},"ts":1517407704000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: it should not be","msgtype":"m.text"},"ts":1517407719000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it's been a while but the latter is all I remember. You might be right. I'd be interested to get Till and wanderview in a room :)","msgtype":"m.text"},"ts":1517407744000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"room-slash-GitHub-thread","msgtype":"m.text"},"ts":1517407752000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I'll let you file another bug on Gecko, then :)","msgtype":"m.text"},"ts":1517407753000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: hmm, maybe this is an enshrined side channel leak","msgtype":"m.text"},"ts":1517407794000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: it probably is as if you did this via <iframe> it'd just work, unfortunately","msgtype":"m.text"},"ts":1517407823000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I would really prefer if it's origin-unclean, because I have no idea how to do the other thing in WebKit :)","msgtype":"m.text"},"ts":1517407828000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: it would be better, but if it's not consistently so I don't think it's better","msgtype":"m.text"},"ts":1517407861000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: and I kinda doubt it's consistently so","msgtype":"m.text"},"ts":1517407870000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"This might be a bug in Fetch too, not sure if I tried addressing it yet","msgtype":"m.text"},"ts":1517407897000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: annevk: I feel like I put all my reasons for wanting ReadableStream in the github issue before... if there is a new proposal to add some WritableStream approach for populating a body, then I'd be happy to look at it... but an abstract \"replace ReadableStream with WritableStream\" doesn't make sense to me","msgtype":"m.text"},"ts":1517408073000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"TabAtkins: I think the main problem I have with your argument is that Boris disagreeing with TC39 doesn't mean it's okay. If you convinced TC39 (as a whole), fine, but otherwise I'm really not sure why we'd revisit this","msgtype":"m.text"},"ts":1517408146000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: annevk: I still feel anything added here would end up being the equivalent of ReadableStream + an IdentityTransformStream in the implementation... and its better to let script choose the size of the buffer in the IdentityTransformStream","msgtype":"m.text"},"ts":1517408148000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: https://github.com/yutakahirano/fetch-with-streams/issues/30#issuecomment-95161858 suggest it did have something to do with the actual sink being hard to get to","msgtype":"m.text"},"ts":1517408247000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: And as I said earlier (and linked you to, and said last year when I last visited this issue...) TC39 *is* okay with this, or at least was okay with it several years back. In the meantime, the primary argument against (\"proxies are slow\") turns out to be irrelevant, as Boris explained, because all engines optimize integer catch-alls, due to there being several common APIs that use them.","msgtype":"m.text"},"ts":1517408256000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"wanderview: does https://github.com/yutakahirano/fetch-with-streams/issues/30#issuecomment-95161858 accurately summarize your view?","msgtype":"m.text"},"ts":1517408270000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: I'm wondering whether or not it translates to WebRTC data channels","msgtype":"m.text"},"ts":1517408283000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"This is what keeps annoying the heck out of me - y'all keep trying to shut it down with \"you can't do it, it's slow, TC39 won't allow it\", and, uh, both of those are wrong. And I've explained why they're wrong and documented it and gotten other Web Elders with relevant experience to agree.","msgtype":"m.text"},"ts":1517408312000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"annevk, https://github.com/w3c/web-platform-tests/pull/9313 should be uncontroversial; https://github.com/w3c/web-platform-tests/pull/9314 is for the last thing I mentioned, but no hurry to review it for me","msgtype":"m.text"},"ts":1517408320000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"TabAtkins: that linked thread *definitely* does not reflect \"TC39 is OK with this\". At most, it contains Brendan saying \"we should keep working on this\". TC39 as a whole detests new exotic objects.","msgtype":"m.text"},"ts":1517408330000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: the issue is that Request is something that is disconnected from the data sink... if the WebRTC data channel thing does not use a Request then it doesn't have that problem IMO","msgtype":"m.text"},"ts":1517408330000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Brendan, Mark, Maciej, Jonas...","msgtype":"m.text"},"ts":1517408354000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It also predates ES6 being finalized and our modern understanding of exotic objects.","msgtype":"m.text"},"ts":1517408355000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Only one of which is on TC39 these days","msgtype":"m.text"},"ts":1517408369000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: I still prefer ReadableStream stylistically as it gives you better default back pressure... but I don't think thats a blocker","msgtype":"m.text"},"ts":1517408372000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"TabAtkins: I don't think that 2009 thread accurately reflects TC39's view on this","msgtype":"m.text"},"ts":1517408414000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: in particular catchalls happened and array-likes never did","msgtype":"m.text"},"ts":1517408428000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: and their Map/Set didn't end up with indexed getters/setters either, even though they are ordered and could","msgtype":"m.text"},"ts":1517408466000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: so I think that if you want to push this through, you have to do more due diligence; e.g., make a proposal to TC39, get it progressed","msgtype":"m.text"},"ts":1517408522000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"+1","msgtype":"m.text"},"ts":1517408532000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"The more general solution that solves more problems ended up getting specced, that's not a huge surprise. ^_^ And with that, catch-alls *do* exist, and engines happen to much better-optimize catchalls limited to integer-key gets/sets, so the slower version of what I'm asking for is already possible in userland, and the faster version is possible and already-existing in browserland.","msgtype":"m.text"},"ts":1517408609000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"wanderview: right, but if body were to take a callback that we invoked the moment we hook up the sink, that would work, right?","msgtype":"m.text"},"ts":1517408613000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"The problem with proxies isn't just that they're slow, it's that they're exotic.","msgtype":"m.text"},"ts":1517408652000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(I dunno why one would assume that getting a map/set by index is relevant here. They're ordered, but as a side detail. Getting map/set values by index isn't a common feature in any major language.)","msgtype":"m.text"},"ts":1517408657000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: possible yes, but Proxy-style APIs are discouraged","msgtype":"m.text"},"ts":1517408660000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Using normal arrays is the non-exotic pattern that we use for all TC39 APIs","msgtype":"m.text"},"ts":1517408666000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: could we add it as an additional thing?  sure... should we remove the straightforward \"provide a ReadableStream body\" approach with that?  I don't think so","msgtype":"m.text"},"ts":1517408685000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: I think its very complicated and quite frankly does not reflect what we do in the browser at all","msgtype":"m.text"},"ts":1517408717000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I think that myself and Till believe that the current API will not be \"straightforward\" in the future when everyone's using transform streams and piping things around","msgtype":"m.text"},"ts":1517408730000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(it's 1:30am here and we're continuing to relay the exact same points that were made last year without any further reflection or budging, so i'm gonna go to bed)","msgtype":"m.text"},"ts":1517408765000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Domenic: I guess I'm curious to hear what Till's concern is... AFAIK he defered to someone else to integrate this into the network and DOM layers, so I'm not sure exactly what aspect he is concerned about","msgtype":"m.text"},"ts":1517408817000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah definitely, I'd love to hear your two's conversation. It might be more ergonomics and disconnected from the actual networking, not sure.","msgtype":"m.text"},"ts":1517408861000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: I also heard out-of-band he'd like to have WS here","msgtype":"m.text"},"ts":1517408863000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Maybe we should just set up a call","msgtype":"m.text"},"ts":1517408900000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'd be interested to know if he has actually looked at what that would take to implement in our stack... I have I don't think it would be any different than ReadableStream+Transform... just less control for script","msgtype":"m.text"},"ts":1517408911000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Why less control? You can always introduce your own intermediate buffers","msgtype":"m.text"},"ts":1517408962000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: annevk: internally we use an nsIInputStream which is our native equivalent of a ReadableStream... for probably the last decade","msgtype":"m.text"},"ts":1517408979000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: because you can't control the buffer size the browser inevitably has to introduce to convert from your WritableStream to its internal mechanism","msgtype":"m.text"},"ts":1517409004000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: if the browser uses 0, then you can control it","msgtype":"m.text"},"ts":1517409048000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the idea that content script is going to use a WritableStream to feed directly into the operating system buffer is just not realistic in a multi-process browser architecture, IMO","msgtype":"m.text"},"ts":1517409051000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"So that would be true for data channels too, I think, although lgrahl thinks otherwise (and probably knows)","msgtype":"m.text"},"ts":1517409124000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Domenic: anyway, if we want a WritableStream as a second way to feed the Request.body, I'm ok with that but not sure we would implement in firefox... I feel pretty strongly Request.body should be able to take a ReadableStream as we've agreed in the past","msgtype":"m.text"},"ts":1517409144000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":":-/","msgtype":"m.text"},"ts":1517409168000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk: webrtc is very different, implementation-wise","msgtype":"m.text"},"ts":1517409169000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I see","msgtype":"m.text"},"ts":1517409178000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: annevk: how do you propose to handle the upload cloaning issue with a WritableStream body?","msgtype":"m.text"},"ts":1517409205000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"as in, a POST request is redirected and has to provide the body a second time","msgtype":"m.text"},"ts":1517409225000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: don't we reject for streams anyway?","msgtype":"m.text"},"ts":1517409363000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: I thought opting into streams meant opting out of redirects, unless it was a 303","msgtype":"m.text"},"ts":1517409385000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well, we haven't even shipped streams yet... but yes, we don't support Request streams right now","msgtype":"m.text"},"ts":1517409388000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: oh, you mean in the spec?  I wasn't aware of that restriction","msgtype":"m.text"},"ts":1517409402000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yes, per Fetch","msgtype":"m.text"},"ts":1517409410000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: otherwise you'd have to buffer the entire thing, taking away all the memory optimizations","msgtype":"m.text"},"ts":1517409428000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It seems we actually could support it with the writable stream version, as you'd just call the body function a second time","msgtype":"m.text"},"ts":1517409438000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: you just created a minor security hole","msgtype":"m.text"},"ts":1517409456000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"drrr","msgtype":"m.text"},"ts":1517409499000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I don't know why we can ship ReadableStream body first before trying to eek that last 1% of optimizations out with a complicated WritableStream API","msgtype":"m.text"},"ts":1517409500000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"^can^can't","msgtype":"m.text"},"ts":1517409507000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I'm not opposed to shipping RS FWIW","msgtype":"m.text"},"ts":1517409530000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(aside: the fact that arr[-0] and arr[\"-0\"] are different really freaks me out. I did not know that before today.)","msgtype":"m.text"},"ts":1517409535000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I was just interested again in the rationale around WS","msgtype":"m.text"},"ts":1517409540000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: same","msgtype":"m.text"},"ts":1517409554000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: since yesterday or so I've been worried about being unclear about -0/+0 throughout the platform","msgtype":"m.text"},"ts":1517409584000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: it helps somewhat that unsigned in IDL means it's normalized, but still, there's a lot of signed things","msgtype":"m.text"},"ts":1517409612000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"No need to worry about that... We most definitely are unclear about it everywhere :)","msgtype":"m.text"},"ts":1517409615000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: so you're saying we're consistent? I do like consistency","msgtype":"m.text"},"ts":1517409637000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"The signed integers shouldn't have negative zero at all, but who knows if that's actually written down","msgtype":"m.text"},"ts":1517409663000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Part of the problem is that we haven't really agreed on what a number in a specification means","msgtype":"m.text"},"ts":1517409697000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"But BigNum might solve that, so I'm excited for BigNum","msgtype":"m.text"},"ts":1517409718000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hmm so far the internet is coming out quite strong in favor of getting the answer right https://twitter.com/domenic/status/958711529070710785","msgtype":"m.text"},"ts":1517409802000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Btw. I don't get the argument of buffer size control. Isn't that what .desiredSize on WS is good for?","msgtype":"m.text"},"ts":1517409889000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: can you set desiredSize on a WS you did not create?","msgtype":"m.text"},"ts":1517409967000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: r+ for https://github.com/w3c/web-platform-tests/pull/9306?","msgtype":"m.text"},"ts":1517410010000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: No but in the proposed API, RTCDataChannel creates the WS for me and it knows how much buffer space there is. The user can still decide to ignore it.","msgtype":"m.text"},"ts":1517410035000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: ok, but a user could control the buffer space if they created a Transform... if they wanted to size it exactly for their chunks, etc","msgtype":"m.text"},"ts":1517410125000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"lgrahl: anyway, I don't have any opinions on webrtc API use of ReadableStream vs WritableStream","msgtype":"m.text"},"ts":1517410141000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I haven't really looked at transforms yet. You mean in case the user *requires* a specific chunk size for some transformation?","msgtype":"m.text"},"ts":1517410217000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"other than I think default back pressure mechanism is nicer with ReadableStream and lots of examples in node.js with people getting back pressure wrong with push-style streams... but I won't fight that issue","msgtype":"m.text"},"ts":1517410229000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"lgrahl: when I say a Transform I mean a buffer that exposes a WritableStream end to fill the buffer and a ReadableStream end to read from the buffer... so if an API only takes ReadableStream, but you want to use a WritableStream for some reason, you can use this thing to convert... it would just let you control the size of the buffering taking palce","msgtype":"m.text"},"ts":1517410302000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: Alright, transforming from WS to RS.","msgtype":"m.text"},"ts":1517410405000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"wanderview: You guys are the experts but from the outside, it just looks really weird to have WS and then use RS for pretty much everything.","msgtype":"m.text"},"ts":1517410461000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: I usually call it a \"pipe\", but folks in streams spec like to call it an \"identity transform\"","msgtype":"m.text"},"ts":1517410468000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: What annevk and I wanted to find out is whether there's a reason why we shouldn't go for WS for RTCDataChannel. To me, it originally looked like the way to go.","msgtype":"m.text"},"ts":1517410607000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: I mean, the other reason to go with ReadableStream is you will get adoption faster since more browsers will ship ReadableStream before they ship WritableStream","msgtype":"m.text"},"ts":1517410639000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"lgrahl: but like I said, I'm not really involved with webrtc, so I'm not going to fight you all using WritableStream","msgtype":"m.text"},"ts":1517410708000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"maybe it will work great and it will be the use case used to encourage more WritableStream usage elsewhere","msgtype":"m.text"},"ts":1517410725000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: note that https://github.com/whatwg/encoding/pull/127 uses WS too","msgtype":"m.text"},"ts":1517410847000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yea, I think transformation things like that make the most sense for WS... wfm","msgtype":"m.text"},"ts":1517410903000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: Other than a little API clumsiness (.send(RS) just looks nicer than .createWritableStream()), I haven't seen anything that would be a big blocker to use WS in data channels. But to be honest, I haven't understood all of your points in the issue and stuff like easier backpressure support in RS because I'm just not that deep into the streams spec.","msgtype":"m.text"},"ts":1517410973000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: well, with a pull-style stream like ReadableStream you get automatic back pressure... if the consumer isn't ready for more data they just stop reading","msgtype":"m.text"},"ts":1517411066000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"lgrahl: with a push-style stream like WritableStream the source has to understand the signal that says \"please stop sending data right now\" and back off... its not super hard to implement, but historically its something that people get wrong... and they end up queuing a bunch of data in temporaries and stuff","msgtype":"m.text"},"ts":1517411128000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: Okay, I get that.","msgtype":"m.text"},"ts":1517411170000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"wanderview: I mean, it's a tradeoff, right? And I personally believe it's not too much to ask for the sink implementation to get this right to provide a (at least to me) more appealing way to write data to it. But still, you're the experts regarding streams, so if there are other concerns... let me know. I don't want to create an API that sucks in the end. :)","msgtype":"m.text"},"ts":1517411465000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: using an API that takes ReadableStream allows the sink to get it write... exposing a WritableStream is asking the person pushing the data to get it right... AFAICT anyway","msgtype":"m.text"},"ts":1517411718000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I'm not really sure what the user of a WS writer can get wrong. Granted, when using a WS the user cannot reclaim the buffer (at least not until we have BYOB writers), so this *is* a gotcha. But IIRC you already have a way to claim a buffer somehow, so this could maybe be used?","msgtype":"m.text"},"ts":1517412819000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: looking at some examples it seems rather trivial to ignore backpressure","msgtype":"m.text"},"ts":1517413429000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"of course ReadableStream is not immune either if you have to adapt a push source you don't control into a ReadableStream... but you are kind of out of luck there","msgtype":"m.text"},"ts":1517413645000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"surma: FYI I'll work on the separate-section thing myself since it ties into clarifying some stuff that came up while chatting with lgrahl.","msgtype":"m.text"},"ts":1517420623000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Would be happy to get your review though :)","msgtype":"m.text"},"ts":1517420643000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: sg! Happy to review :D","msgtype":"m.text"},"ts":1517420995000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"blah, trying to figure out what cross-origin requests to blob URLs browsers actually allow... firefox seems to allow nothing (at least nothing I've tried so far), which seems reasonable. But chrome allows some no-cors fetches as well as some navigate fetches (but not all in either case)...","msgtype":"m.text"},"ts":1517423203000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"(the spec seems to allow all no-cors and navigate fetches though, which definitely doesn't match implementations)","msgtype":"m.text"},"ts":1517423255000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: I don't think I carefully considered blob loading and just grouped them with other things","msgtype":"m.text"},"ts":1517423355000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Mek: also yeah, whenever you look into something ill-defined and go, \"how  does this actually work?\", it's always bad news","msgtype":"m.text"},"ts":1517423407000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"When there's enough vagueness in a standard to allow for observable differences, there will be plenty of those","msgtype":"m.text"},"ts":1517423476000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"When the standard is solid, but there are no tests, same deal","msgtype":"m.text"},"ts":1517423486000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah... that definitely matches my experience with these things...","msgtype":"m.text"},"ts":1517423780000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"actually writing a test to determine of a no-opener window.open succeeded or not is kind of annoying...","msgtype":"m.text"},"ts":1517424427000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: BroadcastChannel() to a cross-origin iframe that forwards to its parent maybe?","msgtype":"m.text"},"ts":1517425159000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah, that's what I'm thinking too","msgtype":"m.text"},"ts":1517425676000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: won't work in webkit, but I guess neither would SharedWorker","msgtype":"m.text"},"ts":1517425729000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"whaat, is Garrett Smith back","msgtype":"m.text"},"ts":1517430986000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"is it possible to block a github user from commenting on  issues?","msgtype":"m.text"},"ts":1517431139000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: Yes, if you're an org admin: https://help.github.com/articles/blocking-a-user-from-your-organization/","msgtype":"m.text"},"ts":1517431599000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"aha","msgtype":"m.text"},"ts":1517431633000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"smaug____: There's also the milder https://help.github.com/articles/locking-conversations/","msgtype":"m.text"},"ts":1517431647000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"https://github.com/w3c/webcomponents/issues/713#issuecomment-362062221 is something requiring blocking, I think","msgtype":"m.text"},"ts":1517431705000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"and hopefully such comment can be removed","msgtype":"m.text"},"ts":1517431711000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"MikeSmith: ^","msgtype":"m.text"},"ts":1517431787000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"does window.onload firing guarantee that any iframes in that window have also finished loading?","msgtype":"m.text"},"ts":1517434834000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"(and finished executing sync javascript that sets document.domain)","msgtype":"m.text"},"ts":1517434861000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: yes","msgtype":"m.text"},"ts":1517435082000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Mek: see a bit below https://html.spec.whatwg.org/#iframe-load-event-steps","msgtype":"m.text"},"ts":1517435173000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Mek: the paragraph beginning \"When the iframe's browsing context's active document is not ready for post-load tasks\"","msgtype":"m.text"},"ts":1517435187000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: I think that's about the iframes load event itself, not the load event of the window containing the document containing the iframe, right?","msgtype":"m.text"},"ts":1517435241000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"although it isn't clear if \"the iframe's browsing context\" is the browsing context inside the iframe or the browsing context the iframe lives in...","msgtype":"m.text"},"ts":1517435301000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: the end of the sentence","msgtype":"m.text"},"ts":1517435360000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"oh wait no you're right","msgtype":"m.text"},"ts":1517435388000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"the spec would be clearer if it actually refered to \"the iframe's nested browsing context\", rather than being vague about which exact browsing context it is talking about...","msgtype":"m.text"},"ts":1517435417000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"but yeah, an iframe no delaying the load event of its parent document would explain some (very infrequent) flakiness I'm seeing in some tests in chrome","msgtype":"m.text"},"ts":1517435448000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"it definitely /should/ AFAIK","msgtype":"m.text"},"ts":1517435488000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"per what browsers do","msgtype":"m.text"},"ts":1517435492000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Mek: like this is exactly what the warning where I linked is about","msgtype":"m.text"},"ts":1517435669000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"wait no","msgtype":"m.text"},"ts":1517435675000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"kjdfkdfgkhfdg","msgtype":"m.text"},"ts":1517435676000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"can someone dig me out of this hole?","msgtype":"m.text"},"ts":1517435691000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Mek: I think in the text I linked to by \"the iframe must delay the load event of its document\" means \"the owner document of the iframe\" rather than the one in the iframe?","msgtype":"m.text"},"ts":1517435812000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"I'm not sure...","msgtype":"m.text"},"ts":1517435836000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"I am pretty sure that's what it means, but wow, that is unclear.","msgtype":"m.text"},"ts":1517436006000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Even just \"its node document\" would help me.","msgtype":"m.text"},"ts":1517436016000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: see I went from thinking that was what it meant to being unsure to thinking that was what it meant *and I know what the behaviour should be*.","msgtype":"m.text"},"ts":1517436129000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"yeah, that text could definitely use some clarification...","msgtype":"m.text"},"ts":1517436140000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"and if someone who knows what the correct behaviour per-spec is can't figure out what the spec saysâ€¦","msgtype":"m.text"},"ts":1517436148000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"it does seem like generally chrome does indeed delay the outer onload till the iframe is loaded. But I'm definitely getting (rare) flaky test failures where it seems like outer code waiting for onload runs before the inner iframe has had a chance to set document.domain. But maybe that's just a bug in chrome.","msgtype":"m.text"},"ts":1517436213000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"Mek: the web definitely relies on it","msgtype":"m.text"},"ts":1517436280000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Filed https://github.com/whatwg/html/issues/3436 for those who want to follow along","msgtype":"m.text"},"ts":1517436472000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1517436596000,"senderName":"Mek","senderId":"Mek@irc"},
{"content":{"body":"smaug____: thanks for the heads-up","msgtype":"m.text"},"ts":1517437991000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Domenic: omg, where did you get your twitter header from?","msgtype":"m.text"},"ts":1517441482000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Hmm some Marvel comic... which one was it...","msgtype":"m.text"},"ts":1517441515000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I want to say Ant-Man?","msgtype":"m.text"},"ts":1517441592000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah here we go http://readcomiconline.to/Comic/The-Astonishing-Ant-Man/Issue-5?id=34226#9","msgtype":"m.text"},"ts":1517441730000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Ahahaha, two panels later is gold too. So good.","msgtype":"m.text"},"ts":1517442181000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"}
]