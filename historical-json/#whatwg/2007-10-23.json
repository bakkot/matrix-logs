[
{"content":{"body":"so it still doesn't work...","msgtype":"m.text"},"ts":1193099100000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"didn't get the messages from jgraham for instance","msgtype":"m.emote"},"ts":1193099101000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I had this idea for the database module ...","msgtype":"m.text"},"ts":1193101860000,"senderName":"aa","senderId":"aa@irc"},
{"content":{"body":"the CRUD statements are pretty consistent across implementations, it should be easy, relatively speaking, to spec them, or refer to ANSI SQL.","msgtype":"m.text"},"ts":1193101920000,"senderName":"aa","senderId":"aa@irc"},
{"content":{"body":"it's the creation of the tables and indicies where the real compatibility problems come in.","msgtype":"m.text"},"ts":1193101921000,"senderName":"aa","senderId":"aa@irc"},
{"content":{"body":"what if HTML5 defined DOM APIs to create tables and indicies? This would also allow the types to be defined as standard DOM types, instead of SQL types.","msgtype":"m.text"},"ts":1193101980000,"senderName":"aa","senderId":"aa@irc"},
{"content":{"body":"It would be up to the implementation to do the conversion to whatever it's internal representation is.","msgtype":"m.text"},"ts":1193101981000,"senderName":"aa","senderId":"aa@irc"},
{"content":{"body":"this would provide a real shot at abstracting the implementation (sqlite) from the spec.","msgtype":"m.text"},"ts":1193101982000,"senderName":"aa","senderId":"aa@irc"},
{"content":{"body":"sounds reasonable to me","msgtype":"m.text"},"ts":1193102220000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i recommend sending mail to the list suggesting it, let's see what the other vendors think","msgtype":"m.text"},"ts":1193102221000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hey Hixie","msgtype":"m.text"},"ts":1193103420000,"senderName":"Lachy_","senderId":"Lachy_@irc"},
{"content":{"body":"hey","msgtype":"m.text"},"ts":1193104320000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Lachy_: whatever you did with the blog seems to have helped, \"lhunt\" is never at the top of the process list anymore","msgtype":"m.text"},"ts":1193104380000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"hmmm","msgtype":"m.text"},"ts":1193130900000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"so an explicit database.startTransaction() seems to be the only way to address the issues raised with the sql stuff","msgtype":"m.text"},"ts":1193130960000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"and splitting the load and error case into two seems good, and having error do a rollback seems good too, except for the point about checking for integrity errors...","msgtype":"m.text"},"ts":1193131020000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"maybe rollback only if the function doesn't return false...","msgtype":"m.text"},"ts":1193131140000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"hmmm","msgtype":"m.text"},"ts":1193132940000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"database.transaction(callback, error_callback);","msgtype":"m.text"},"ts":1193132941000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"error_callback gets called if the transaction fails to be created or comitted (or maybe even if it is rolled back?)","msgtype":"m.text"},"ts":1193132942000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"callback is a function with one argument, tx, which is an object with an executeSql() method on it","msgtype":"m.text"},"ts":1193132943000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"tx.executeSql(sql, args, callback, error_callback);","msgtype":"m.text"},"ts":1193132944000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"error_callback gets called for any errors with that statement (even syntax errors), and if it does not return false, the transaction gets rolled back.","msgtype":"m.text"},"ts":1193133000000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"callback is the same as the transaction callback","msgtype":"m.text"},"ts":1193133001000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"if transaction() is called from within a transaction, it create a new (but not nested) transaction.","msgtype":"m.text"},"ts":1193133060000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"transactions commit whenever a callback returns if there are no outstanding calls to executeSql() for that transaction.","msgtype":"m.text"},"ts":1193133061000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"but transactions get rolled back if a callback returns false","msgtype":"m.text"},"ts":1193133120000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"there's no explicit commit or rollback in v1, but in v2 we add those as well as an executeRawSql(sql, args, callback, error_callback) method on database (whose callback doesn't have any arguments).","msgtype":"m.text"},"ts":1193133180000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"any opinions?","msgtype":"m.text"},"ts":1193133181000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"oh and changeVersion(old_version, new_version, callback, error_callback) would work like transaction() except that the transaction would be a complete lock and that the version would be checked at the start of the transaction and set when the transaction was comitted","msgtype":"m.text"},"ts":1193133540000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie, what will executeRawSql do differentfly from executeSql?","msgtype":"m.text"},"ts":1193134560000,"senderName":"Lachy","senderId":"Lachy@irc"},
{"content":{"body":"Lachy: no transaction","msgtype":"m.text"},"ts":1193134860000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"btw, Java makes an interesting case study about strict backwards compat and fixing early design flaws and the rate of adoption","msgtype":"m.text"},"ts":1193135580000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"I just ran a search for references to StringBuffer and it is everywhere","msgtype":"m.text"},"ts":1193135640000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"new code should use StringBuilder","msgtype":"m.text"},"ts":1193135641000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"so the Java6 HotSpot VM takes lock removal to the VM at run time","msgtype":"m.text"},"ts":1193135642000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"so it can mitigate some of the damage of the bad design of StringBuffer","msgtype":"m.text"},"ts":1193135700000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"they did that before StringBuilder was created","msgtype":"m.text"},"ts":1193136120000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"at least some VMs did","msgtype":"m.text"},"ts":1193136121000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"roc: hmm. lock removal / thread-biased locks were mentioned as a Java6 HotSpot feature","msgtype":"m.text"},"ts":1193136180000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"Hashtable and Vector are pretty pervasive, too","msgtype":"m.text"},"ts":1193136240000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"which sucks considering that HashMap and ArrayList are even safe for concurrent reads","msgtype":"m.text"},"ts":1193136241000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":" /me curses xml","msgtype":"m.text"},"ts":1193174160000,"senderName":"jgraham_","senderId":"jgraham_@irc"},
{"content":{"body":"Wow I managed to make a syntax error whilst complaining about a language for its syntax-error intolerance","msgtype":"m.text"},"ts":1193174220000,"senderName":"jgraham_","senderId":"jgraham_@irc"},
{"content":{"body":"hsivonen: just checking out http://packages.qa.debian.org/w/w3c-markup-validator.html","msgtype":"m.text"},"ts":1193174520000,"senderName":"hendry","senderId":"hendry@irc"},
{"content":{"body":"wow, with the amount of time the forms tf has spent discussing when to discuss things, you'd think they could have discussed things by now","msgtype":"m.text"},"ts":1193179560000,"senderName":"Hixie","senderId":"Hixie@irc"}
]