[
{"content":{"body":"Arrow was pretty good :D","msgtype":"m.text"},"ts":1431994147000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hi, In http://www.w3.org/TR/html5/embedded-content-0.html#update-the-image-data talks about update the image data algorithm. I have several questions regarding it - How is this algorithm invoked? Does UI task source enqueue a task to invoke the algorithm? - In step 8 it says that asynchronously await a stable state. What is a stable state in this case? Why can not run the algorithm till step 13 and say run the remaining steps asynchrono","msgtype":"m.text"},"ts":1431998040000,"senderName":"eik","senderId":"eik@irc"},
{"content":{"body":"Domenic: we're still on season 1","msgtype":"m.text"},"ts":1432042393000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: why is it OK to store an empty body in the cache but not to store a body that's been read-to-the-end?","msgtype":"m.text"},"ts":1432052139000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: maybe a question for JakeA or annevk, but IMO a drained Response is not the same as a Response with no body... the drained Response does not conceptually capture the true network response any more","msgtype":"m.text"},"ts":1432052233000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Hmm, that fits very poorly with streams.","msgtype":"m.text"},"ts":1432052283000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I don't follow... why do you say that?","msgtype":"m.text"},"ts":1432052452000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: because of what I wrote in the bug ... \" If I give you a stream I've read all the chunks from (and thus happens to be closed), that should be the same as some random stream that was never read from but is also closed (because nothing was ever enqueued into it). They behave the same in every respect so there's no point in introducing something new","msgtype":"m.text"},"ts":1432052481000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"to differentiate them.\"","msgtype":"m.text"},"ts":1432052481000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: without the \"don't set used flag if the stream is empty\" optimization its all very easy... Cache API looks to see if the stream is closed... if it is, then its \"used\"","msgtype":"m.text"},"ts":1432052501000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: right. That's why I was wondering if we could reject for empty bodies.","msgtype":"m.text"},"ts":1432052523000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the complexity only comes in trying to special case the \"stream is closed, but it doesn't matter because it was empty anyway\" condition","msgtype":"m.text"},"ts":1432052526000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Exactly.","msgtype":"m.text"},"ts":1432052533000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: which unfortunately is already out there in fetch and seems like something reasonably needed for API ergonomics","msgtype":"m.text"},"ts":1432052558000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I don't understand why","msgtype":"m.text"},"ts":1432052564000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"why it improves ergonomics?","msgtype":"m.text"},"ts":1432052577000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Is it expected to be common to say res.text() then cache.put(res) but only if res.text() returned \"\"?","msgtype":"m.text"},"ts":1432052585000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the ergonomics mainly come from being able to reuse Request objects... so var req = new Request(url); fetch(req); fetch(req); cache.add(req);","msgtype":"m.text"},"ts":1432052659000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"you can reuse the same request for multiple calls that consume if there are no bodies","msgtype":"m.text"},"ts":1432052673000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"if there is no body","msgtype":"m.text"},"ts":1432052679000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: how can you tell there's no body.","msgtype":"m.text"},"ts":1432052685000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"without this optimization then you would need:  var req = new Request(url); fetch(req.clone()); fetch(req.clone()); cache.add(req.clone());","msgtype":"m.text"},"ts":1432052705000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: if its a GET request, there is no body","msgtype":"m.text"},"ts":1432052715000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"for example","msgtype":"m.text"},"ts":1432052719000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"i see","msgtype":"m.text"},"ts":1432052729000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but I agree, there is no easy way to inspect it","msgtype":"m.text"},"ts":1432052731000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":".body.empty :-)","msgtype":"m.text"},"ts":1432052736000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"maybe null body vs. empty body makes more sense for GET requests","msgtype":"m.text"},"ts":1432052740000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":".body === null","msgtype":"m.text"},"ts":1432052743000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I don't think that would be very nice for .body.getReader()","msgtype":"m.text"},"ts":1432052757000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I think it would","msgtype":"m.text"},"ts":1432052763000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"now .body.getReader() always needs a if (.body) check first to avoid throwing?","msgtype":"m.text"},"ts":1432052771000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ugh","msgtype":"m.text"},"ts":1432052774000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Yes","msgtype":"m.text"},"ts":1432052775000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Same as fetch()","msgtype":"m.text"},"ts":1432052778000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"You're saying people will do multiple fetch()s because they know there's no body","msgtype":"m.text"},"ts":1432052788000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I thought we were trying to unify null/empty concepts... not make it even harder to work with","msgtype":"m.text"},"ts":1432052796000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I'm saying people will not do .body if they know there's no body","msgtype":"m.text"},"ts":1432052797000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It's the same argument","msgtype":"m.text"},"ts":1432052833000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: what does .body evaluate to if new Request(url, { body: '' })?","msgtype":"m.text"},"ts":1432052901000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: an empty stream. IMO that should not be multi-fetchable().","msgtype":"m.text"},"ts":1432052920000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I'm not sure what the current spec does with that... might not be multi-fetchable","msgtype":"m.text"},"ts":1432052943000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: I'm ok with this suggestion... but it seems tyoshino does not like approach","msgtype":"m.text"},"ts":1432052997000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"from previous github comments","msgtype":"m.text"},"ts":1432053006000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I will try to outline...","msgtype":"m.text"},"ts":1432053086000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: thanks, I have to run to lunch but will be back later","msgtype":"m.text"},"ts":1432053322000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic, in the past discussion you wanted to allow calling text() on a partially consumed response. Is it still your strong preference?","msgtype":"m.text"},"ts":1432054254000,"senderName":"yhirano_","senderId":"yhirano_@irc"},
{"content":{"body":"yhirano_: if it can simplify things a lot I could give it up. But I think my proposal in https://github.com/yutakahirano/fetch-with-streams/issues/37#issuecomment-103584177 lets us keep that and is still sane.","msgtype":"m.text"},"ts":1432054327000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"hrm, packaging-on-the-web might be annoying to prollyfil, since each part can have a different content-encoding, so one would have to ship all of iconv","msgtype":"m.text"},"ts":1432054444000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"at least, from my reading","msgtype":"m.text"},"ts":1432054450000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"terinjokes: only support utf8","msgtype":"m.text"},"ts":1432054558000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Sorry I don't understand. Won't fetch(new Request(url, body: '')) fail with your proposal?","msgtype":"m.text"},"ts":1432054560000,"senderName":"yhirano_","senderId":"yhirano_@irc"},
{"content":{"body":"yhirano_: hmm yes, it will as written. that seems bad. i meant it to work once but not twice.","msgtype":"m.text"},"ts":1432054595000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: why will that one fail?","msgtype":"m.text"},"ts":1432058141000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: haven't read the 11 responses since I got back, but, off the bad body will be a closed stream, and in my proposal fetch()ing a closed stream will fail.","msgtype":"m.text"},"ts":1432058182000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"s/bad/bat","msgtype":"m.text"},"ts":1432058189000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I thought I read in a previous comment there was an initial \"readable\" state and it only went truly closed on first read()","msgtype":"m.text"},"ts":1432058213000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"goes to look at the spec again","msgtype":"m.emote"},"ts":1432058218000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: oh... I was thinking of the state attribute... I guess that went away when we switched to Promise-returning read()","msgtype":"m.text"},"ts":1432058263000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: even before, once the controller of the stream calls close(), the stream is closed.","msgtype":"m.text"},"ts":1432058279000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so there is no way to use .body.getReader().closed here somehow?","msgtype":"m.text"},"ts":1432058323000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: no, empty body will be immediately closed.","msgtype":"m.text"},"ts":1432058383000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"an empty closed stream is the same as a drained closed stream.","msgtype":"m.text"},"ts":1432058400000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"streams don't retain knowledge of how they've been interacted with; they just have a current state.","msgtype":"m.text"},"ts":1432058421000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: well... new Request(url, { body: '' }) could just set body to null as a special case... not sure that works with the other body constructor options, though","msgtype":"m.text"},"ts":1432058448000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah I was thinking that...","msgtype":"m.text"},"ts":1432058461000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: what about creating a wrapper ReadableStream for Request/Response that handles this extra logic","msgtype":"m.text"},"ts":1432058605000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: seems plausible, although annoying... I am losing sight of what we're gaining for all this complexity ... I think it is the ability to fetch() some requests multiple times but not others?","msgtype":"m.text"},"ts":1432059004000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: well... this behavior has been released in fetch for some time now... even if we don't like it, not sure we can get rid of it","msgtype":"m.text"},"ts":1432059081000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I kind of wish it was a .body() function now so we could say the moment you call it we switch into sane mode...","msgtype":"m.text"},"ts":1432059111000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: its not too late for that","msgtype":"m.text"},"ts":1432059128000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but I don't think extra modes would be a good thing","msgtype":"m.text"},"ts":1432059142000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: as a side note... I do think it would be nice to have a synchronous way to get the stream state... it seems right now everything is async through .read() or .closed promise... right?","msgtype":"m.text"},"ts":1432059220000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yes, that is intentional because otherwise it causes GC observability issues, IIRC.","msgtype":"m.text"},"ts":1432059243000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: hmm... not sure I follow","msgtype":"m.text"},"ts":1432059273000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I don't remember the details... probably somewhere in that big GC thread...","msgtype":"m.text"},"ts":1432059292000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I can see GC observability for a callback of some kind... but a sync attribute can't be accessed if the objects it on is GC'd...","msgtype":"m.text"},"ts":1432059336000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hmm that's true","msgtype":"m.text"},"ts":1432059348000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: how does giving up .text() on partially read streams help here?","msgtype":"m.text"},"ts":1432062119000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: no idea, but yhirano_ was asking about it, so I thought I'd put it on record.","msgtype":"m.text"},"ts":1432062133000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess we could have the .body getter set bodyUsed... but thats a little overeager!","msgtype":"m.text"},"ts":1432062158000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: that was kind of what I was thinking with sane-mode... would rather it be a function in that case.","msgtype":"m.text"},"ts":1432062178000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Although 43 shipped today so I can't imagine Chrome would be happy with that change","msgtype":"m.text"},"ts":1432062210000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(hmm, I should probably be celebrating, now that I think about it...)","msgtype":"m.text"},"ts":1432062250000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"seems someone should be able to do var reader = s.body.getReader(); reader.closed.then(itsclosedjim); reader.releaseLock(); without forcing bodyUsed to true","msgtype":"m.text"},"ts":1432062276000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wonders why .closed promise is on the reader instead of the stream...","msgtype":"m.emote"},"ts":1432062293000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1432062294000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"*that* was for GC reasons, I am 100% sure","msgtype":"m.text"},"ts":1432062303000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1432062309000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"does the .closed promise not resolve if you .releaseLock()?","msgtype":"m.text"},"ts":1432062336000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"it is already resolved the moment the reader came into existence.","msgtype":"m.text"},"ts":1432062351000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: for a stream with actual content?","msgtype":"m.text"},"ts":1432062367000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"no, sorry","msgtype":"m.text"},"ts":1432062373000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it will immediately resolve when you releaseLock()","msgtype":"m.text"},"ts":1432062383000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"inactive readers act like closed streams","msgtype":"m.text"},"ts":1432062392000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"still stuck thinking about \" seems someone should be able to do\"","msgtype":"m.text"},"ts":1432062424000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so if I want to observe when the stream consumption is complete I need to do something like s.pipeTo(sink).getReader().closed.then(foo)?","msgtype":"m.text"},"ts":1432062444000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"what if ... bodyUsed was set to true for empty streams (as well as drained ones). But, putting GET requests didn't care about bodyUsed?","msgtype":"m.text"},"ts":1432062451000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: s.pipeTo(sink).then(foo)","msgtype":"m.text"},"ts":1432062464000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess I'm trying to see how the .closed promise is useful if you can only use it when you are the sole reader...","msgtype":"m.text"},"ts":1432062493000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"that's true","msgtype":"m.text"},"ts":1432062533000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it might be vestigial at this point :-S","msgtype":"m.text"},"ts":1432062538000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"well, not quite","msgtype":"m.text"},"ts":1432062558000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the other problem I see with setting bodyUsed in .body getter or a .body()... now you can't check for body null without triggering bodyUsed","msgtype":"m.text"},"ts":1432062565000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"even if you are the sole reader it is quite useful for getting consolidated error notifications for example","msgtype":"m.text"},"ts":1432062573000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yea... some use... just not what I expected when I saw it in the API","msgtype":"m.text"},"ts":1432062601000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I thought it was an external observer","msgtype":"m.text"},"ts":1432062609000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"it was but then GC concerns forced it into hte background. we reasoned we could add it back later.","msgtype":"m.text"},"ts":1432062627000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"s/into hte background/solely into the reader/","msgtype":"m.text"},"ts":1432062651000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it can also be manually added with a Transform that you pipeThrough()","msgtype":"m.text"},"ts":1432062652000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"an ObserverTransform","msgtype":"m.text"},"ts":1432062661000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or whatever","msgtype":"m.text"},"ts":1432062664000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"true","msgtype":"m.text"},"ts":1432062700000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"and if that's author-space it shouldn't have GC issues","msgtype":"m.text"},"ts":1432062710000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"maybe we can add it back","msgtype":"m.text"},"ts":1432062713000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"OK what if we modified my proposal from https://github.com/yutakahirano/fetch-with-streams/issues/37#issuecomment-103584177 to not error for GETs","msgtype":"m.text"},"ts":1432062749000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"well... HEAD OR GET","msgtype":"m.text"},"ts":1432062783000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"so that would mean fetch(new Request(url, { body: \"\", method: \"POST\" })) fails, hmm. seems not great","msgtype":"m.text"},"ts":1432062785000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1432062786000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but can't other methods optionally have bodies or not?","msgtype":"m.text"},"ts":1432062798000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"like PUT and POST","msgtype":"m.text"},"ts":1432062801000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah.","msgtype":"m.text"},"ts":1432062805000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think I prefer the wrapper","msgtype":"m.text"},"ts":1432062816000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I guess we could do the thing you were suggesting and translate empty body to null body","msgtype":"m.text"},"ts":1432062817000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wrapper sounds so heavyweight, but, maybe it is ok.","msgtype":"m.text"},"ts":1432062825000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i still think the overall story here is bizarre","msgtype":"m.text"},"ts":1432062835000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i.e. what we tell developers","msgtype":"m.text"},"ts":1432062841000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"\"sometimes you can multi-fetch, sometimes not. if you read the body to the end you cannot multi-fetch, but if the body was empty in the first place you can.\" etc.","msgtype":"m.text"},"ts":1432062869000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the problem with special casing \"\" is that it won't work if a ReadableStream is passed directly as the body:  new Request(url, { body: streamThatMaybeHasData });","msgtype":"m.text"},"ts":1432062882000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ah right","msgtype":"m.text"},"ts":1432062921000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I agree its a bit awkward... its a consequence of us not wanting to do implicit clone","msgtype":"m.text"},"ts":1432062924000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: what do you think of a just wrapping the inner source?  fetch inserts an inner source wrapper into the body stream... once it gets its \"a byte was read\" state info then it removes its wrapper from the chain","msgtype":"m.text"},"ts":1432062971000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"removing itself could be an implementation optimization","msgtype":"m.text"},"ts":1432062982000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"code?","msgtype":"m.text"},"ts":1432062983000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: it would have to work on the inner concepts of the stream... is there a way to refer to the inner source in code currently?","msgtype":"m.text"},"ts":1432063024000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"this would not be something we would let normal script do, I think","msgtype":"m.text"},"ts":1432063033000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: no, there is not... it's the same kind of layering violation I currently see in Blink I guess, is what you're suggesting.","msgtype":"m.text"},"ts":1432063063000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: to be honest, in gecko I would probably just stick a boolean \"ever got data\" into a private stream slot and let the DOM code inspect it","msgtype":"m.text"},"ts":1432063070000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I think thats the cheapest, simplest solution","msgtype":"m.text"},"ts":1432063103000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"this is making me sad","msgtype":"m.text"},"ts":1432063146000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"\"it won't work if a ReadableStream is passed directly as the body\" what if we say that always errors","msgtype":"m.text"},"ts":1432063179000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(if the ReadableStream is closed)","msgtype":"m.text"},"ts":1432063189000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"we could let \"\" error too","msgtype":"m.text"},"ts":1432063198000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"only null bodies work for multi-fetch","msgtype":"m.text"},"ts":1432063204000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"seems conceptually closer to how things actually work","msgtype":"m.text"},"ts":1432063220000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"you can only multi-fetch when you truly have no body","msgtype":"m.text"},"ts":1432063226000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"is what we're trying to enforce here","msgtype":"m.text"},"ts":1432063235000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"we shouldn't have a loophole for empty bodies","msgtype":"m.text"},"ts":1432063243000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think that creates a bit of the quantum streams problem for a pipe passed as the body... for example, if you consume the stream before pipe writer end is closed, then it works... but if the pipe writer end decides its done and no data was ever written, then now the body can't be used","msgtype":"m.text"},"ts":1432063249000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: I like that, except for the problem were passing \"\" errors without ever being usable","msgtype":"m.text"},"ts":1432063284000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"\"\" erroring seems OK","msgtype":"m.text"},"ts":1432063298000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"don't use body: \"\", use body: null.","msgtype":"m.text"},"ts":1432063308000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"*or*, just clone defensively, if you're unsure.","msgtype":"m.text"},"ts":1432063322000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it would break backward compat... I guess we would have to special case \"\" for all the previously existing body initializers","msgtype":"m.text"},"ts":1432063328000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Let me try to write this up in a bit more detail so we can tear it down more comprehensively.","msgtype":"m.text"},"ts":1432063370000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: can \"\" be expressed for FormData or URLSearchParams?","msgtype":"m.text"},"ts":1432063392000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Blob has .size","msgtype":"m.text"},"ts":1432063406000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I think BufferSource has .length","msgtype":"m.text"},"ts":1432063414000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I guess for FormData and URLSearchParams we can just take the size of the resulting encoded value... they both run serializers... if the encoded value is length 0 then set body to null","msgtype":"m.text"},"ts":1432063451000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Is breaking back-compat there an option? How many people are doing multi-fetch with an empty FormData?","msgtype":"m.text"},"ts":1432063490000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think we can special case all of those to set a null body when empty","msgtype":"m.text"},"ts":1432063824000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: and the new ReadableStream body functions with the closed-is-drained semantics","msgtype":"m.text"},"ts":1432063857000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: I think that works for most cases... pipe might get a bit ugly as I mentioned above","msgtype":"m.text"},"ts":1432063878000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hold on, I appear to be reinventing the bodyUsed flag...","msgtype":"m.text"},"ts":1432063894000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"goes to re-read the thread","msgtype":"m.emote"},"ts":1432063904000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yes, I have begun re-inventing plan(X), as it is called. Nevermind...","msgtype":"m.text"},"ts":1432063985000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I don't think thats the same as plan(X)...  I don't think plan(X) equated stream closed with bodyUsed","msgtype":"m.text"},"ts":1432064042000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah, I was trying to do a different version that allowed you to fetch() once.","msgtype":"m.text"},"ts":1432064064000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"basically we want to define bodyUsed as `.body && .body is closed`","msgtype":"m.text"},"ts":1432064067000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"oh, ok","msgtype":"m.text"},"ts":1432064073000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: wait a minute... how can Response or Request tell if .body is closed initially?  do they have to do a .read() and keep track to see if done:true is returned from the first .read()?","msgtype":"m.text"},"ts":1432064161000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1432064168000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"that seems problematic for .bodyUsed","msgtype":"m.text"},"ts":1432064178000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Not problematic for actual consumption code","msgtype":"m.text"},"ts":1432064185000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but problematic for .bodyUsed.","msgtype":"m.text"},"ts":1432064189000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: what if its not closed... and it gets a chunk back... it can't push it back...","msgtype":"m.text"},"ts":1432064200000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I think we need a sync attribute to tell if closed or not","msgtype":"m.text"},"ts":1432064207000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"then it continues consuming","msgtype":"m.text"},"ts":1432064210000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"no need to push it back","msgtype":"m.text"},"ts":1432064223000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: well, I mean for for .bodyUsed which is itself not a consumer","msgtype":"m.text"},"ts":1432064258000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yes, .bodyUsed is problematic.","msgtype":"m.text"},"ts":1432064268000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think it would need a sync getter, you are right","msgtype":"m.text"},"ts":1432064285000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"why is this so hard -_-. doesn't feel like it should be.","msgtype":"m.text"},"ts":1432064310000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think it would be useful anyway for devs to be able to inspect the state without potentially modifying the stream","msgtype":"m.text"},"ts":1432064316000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"which was one of the reasons we added .bodyUsed","msgtype":"m.text"},"ts":1432064327000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"i like how all access is gated on the reader and on being async","msgtype":"m.text"},"ts":1432064340000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but it's not essential i guess","msgtype":"m.text"},"ts":1432064348000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: this sort of thing would probably take an order magnitude less time if we were all in the same room with a whiteboard","msgtype":"m.text"},"ts":1432064349000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"just seems nice","msgtype":"m.text"},"ts":1432064351000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"heh, that's fair.","msgtype":"m.text"},"ts":1432064356000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: you could make it .body.getReader().state or whatever... so still gated on the lock","msgtype":"m.text"},"ts":1432064450000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"sure","msgtype":"m.text"},"ts":1432064457000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i guess part of the mismatch here is that streams expects trying to consume a consumed stream to be a no-op","msgtype":"m.text"},"ts":1432064499000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"whereas serviceworker and friends expect it to throw","msgtype":"m.text"},"ts":1432064509000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"or reject i guess","msgtype":"m.text"},"ts":1432064524000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"streams is not necessarily better when I put it that way","msgtype":"m.text"},"ts":1432064566000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"right. and service worker has the sync \"will this fail\" getter in bodyUsed","msgtype":"m.text"},"ts":1432064642000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so if we want to translate between the streams model (or even if we were to change the streams model to also be a fail) we'd need a \"will this no-op\" getter on streams.","msgtype":"m.text"},"ts":1432064667000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i guess the motivation is higher in service worker land because failing is something you want to avoid more actively than no-oping","msgtype":"m.text"},"ts":1432064709000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so a bodyUsed getter is more important than a closed getter.","msgtype":"m.text"},"ts":1432064719000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(ugh, boolean adjective getters vs. past-tense promise getters... English is screwing us.)","msgtype":"m.text"},"ts":1432064737000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(I guess it'd be a state getter so crisis averted)","msgtype":"m.text"},"ts":1432064772000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess I would propose a .state getter vs calling it .closed","msgtype":"m.text"},"ts":1432064780000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yesa","msgtype":"m.text"},"ts":1432064786000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yea","msgtype":"m.text"},"ts":1432064788000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ok i remember now why it's a no-op for streams instead of an error. because you never know if the next read() is going to be \"oh actually i have no more chunks for you.\"","msgtype":"m.text"},"ts":1432064844000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"So .read() cannot reject on stream end because it's non-exceptional","msgtype":"m.text"},"ts":1432064859000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But I can understand why readToEnd(stream) rejecting on stream being empty might be exceptional","msgtype":"m.text"},"ts":1432064873000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i'm feeling a bit better as i talk myself through this, hope you don't mind :)","msgtype":"m.text"},"ts":1432064885000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"np","msgtype":"m.text"},"ts":1432064919000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: you see this? https://twitter.com/yaypie/status/600738702038409216","msgtype":"m.text"},"ts":1432065340000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"no, no idea what that's about.","msgtype":"m.text"},"ts":1432065488000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i'm tempted to blame user error until he gives more details; we have plenty of tests for concatenated minified JS.","msgtype":"m.text"},"ts":1432065506000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"in 2015 bugs get filed on twitter instead of where people can find them","msgtype":"m.text"},"ts":1432065541000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"wanderview: posted new proposal based on our discussions. i imagine it will need a few more tweaks...","msgtype":"m.text"},"ts":1432065579000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"thanks, I'll take a look","msgtype":"m.text"},"ts":1432065610000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wow... I opened the email notification in gmail... and the github page was smart enough to take the (1) notification thing out of its tab name","msgtype":"m.text"},"ts":1432065661000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"O_O","msgtype":"m.text"},"ts":1432065716000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Tracking images, yo.","msgtype":"m.text"},"ts":1432065826000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Domenic: I know you don't like my \"quantum streams\", but I think part of the mismatch we get between SW \"fail on consumed streams\" and the streams closed concept is that \"consumed\" implies that someone did something to the stream...  I think its weird conceptually for a stream to become consumed on its own spontaneously (from initially empty or the writer","msgtype":"m.text"},"ts":1432066071000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"end of a pipe being closed, etc)","msgtype":"m.text"},"ts":1432066072000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Yes. I don't understand that part of SW honestly, which is what this new thing is trying to fix. Why would a respones the server made empty be any different from one the developer made empty?","msgtype":"m.text"},"ts":1432066131000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"not sure I understand what you mean by server/developer in this case","msgtype":"m.text"},"ts":1432066226000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"to me \"consumed\" conceptually requires a consumer to take an action on the stream... even if it ends up a no-op","msgtype":"m.text"},"ts":1432066291000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I don't think consumed is a coherent concept","msgtype":"m.text"},"ts":1432066332000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It causes global coordination problems","msgtype":"m.text"},"ts":1432066338000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: can you elaborate on those problems?","msgtype":"m.text"},"ts":1432066357000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I give you an empty string from one part of the program. Have I consumed it yet, or not?","msgtype":"m.text"},"ts":1432066365000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"to be clear, I don't think \"consumed\" is a replacement for \"closed\"","msgtype":"m.text"},"ts":1432066376000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"It implies people should take different paths depending on what's happened in the past, instead of just working with what they're given in their part of the program","msgtype":"m.text"},"ts":1432066423000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Can there be something like iterator's \"done\" flag?  An iterator might be empty at any point, and may or may not have indicated it yet, but once it's emitted \"done\", it's absolutely done.","msgtype":"m.text"},"ts":1432066434000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: yea... thats the kind of semantics I was expecting","msgtype":"m.text"},"ts":1432066466000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"TabAtkins: we have that, it's closed. But service worker wants something different.","msgtype":"m.text"},"ts":1432066468000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"or not","msgtype":"m.text"},"ts":1432066483000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Service worker wants \"has anyone ever iterated over this iterator\"","msgtype":"m.text"},"ts":1432066496000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"which I maintain is a very strange way of programming","msgtype":"m.text"},"ts":1432066506000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"You should work with the thing you're given, and its current state. Who cares how it got that way.","msgtype":"m.text"},"ts":1432066525000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Oh yeah, they just want an exclusive stream.","msgtype":"m.text"},"ts":1432066677000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I mean, single consumer makes sense.","msgtype":"m.text"},"ts":1432066688000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"they have that... they want to be sure nobody ever read it to the end and then decided they were ready to release access to its dead husk","msgtype":"m.text"},"ts":1432066715000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"They don't like dead husks","msgtype":"m.text"},"ts":1432066720000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hmm we could get rid of auto-release-on-close... and in fact not allow release of closed streams??","msgtype":"m.text"},"ts":1432066748000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"then no dead husks should be accessible","msgtype":"m.text"},"ts":1432066759000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Unless, like, you tee it and hand off one of the copies.","msgtype":"m.text"},"ts":1432066773000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Domenic: in fairness, the proposed spec explicitly did the \"release access to its dead husk\" in the .text()/etc methods","msgtype":"m.text"},"ts":1432067014000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: what is the use case for releasing the lock anyway?","msgtype":"m.text"},"ts":1432067315000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: once the stream is closed? not too much of one. You can contrive some ideas though.","msgtype":"m.text"},"ts":1432067348000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I meant ever all unlocking... even while the stream is open","msgtype":"m.text"},"ts":1432067369000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: allowing multiple consumers access to different parts of the stream, e.g. headers, body, trailers","msgtype":"m.text"},"ts":1432067388000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"readHeaders(stream).then(headers => readBody(stream).then(body => [headers, body]))","msgtype":"m.text"},"ts":1432067425000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"readHeaders acquires and releases a lock","msgtype":"m.text"},"ts":1432067432000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: and what would this case do if there were headers and no body... the stream closed and left the lock in place... what would readBody() do?","msgtype":"m.text"},"ts":1432067507000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"with your proposal","msgtype":"m.text"},"ts":1432067513000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah I think it would have to check .locked first... or .state === \"closed\"??","msgtype":"m.text"},"ts":1432067543000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"failing though seems like a reasonable default tbh","msgtype":"m.text"},"ts":1432067578000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"that code seems to expect a body","msgtype":"m.text"},"ts":1432067585000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so an initially-empty stream would start in the state === 'closed' state, but not be locked... then someone could do getReader().read(), which would return done:true and leave the stream locked","msgtype":"m.text"},"ts":1432067655000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah i think that's the gist of it...","msgtype":"m.text"},"ts":1432067671000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so bodyUsed would be `body !== null && body.state !== 'readable' && body.locked`","msgtype":"m.text"},"ts":1432067686000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"sounds right","msgtype":"m.text"},"ts":1432067708000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: this brings us back to the original proposal modulo the \"can't unlock a consumed stream\" thing","msgtype":"m.text"},"ts":1432067710000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"the difference being .locked reflects the current state of the stream instead of historical information about how the current state arose.","msgtype":"m.text"},"ts":1432067750000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think you can infer a lot by looking at state === 'closed' and locked attribute... if its closed, but not locked, then it was initially empty","msgtype":"m.text"},"ts":1432068000000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"currently not true; currently state === 'closed' => locked === false always, because it auto-unlocks on close.","msgtype":"m.text"},"ts":1432068035000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: right, I meant with your proposal","msgtype":"m.text"},"ts":1432068111000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1432068316000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"philipj, Domenic: I tried filing a Chromium bug to get caretPositionFromPoint implemented (instead of nonstandard caretRangeFromPoint) but it didn't work out too well: https://code.google.com/p/chromium/issues/detail?id=388976","msgtype":"m.text"},"ts":1432069436000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"is there a better path?","msgtype":"m.text"},"ts":1432069463000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"oof, that looks like some triage went wrong. I am not a veteran of the best procedures for such things but will ask around... philipj probably is such a veteran.","msgtype":"m.text"},"ts":1432069525000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1432069646000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"I'm trying to log into my chromium.org account, but it's fine to just put that back as Available.","msgtype":"m.text"},"ts":1432070056000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"That's def the worst triage I've ever seen. roc, plz ping if you ever get service that bad.","msgtype":"m.text"},"ts":1432070071000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"oh, I've seen worse :-). Thanks","msgtype":"m.text"},"ts":1432070098000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"chromium.org accounts. the worst.","msgtype":"m.text"},"ts":1432070106000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"are they volunteers?","msgtype":"m.text"},"ts":1432070116000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"no I just meant having separate google accounts to use for chromium is the worst. I dunno about the triagers.","msgtype":"m.text"},"ts":1432070139000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"roc: is Gecko the only engine to implement caretPositionFromPoint so far?","msgtype":"m.text"},"ts":1432072257000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"looks like IE doesn't implement caretPositionFromPoint or caretRangeFromPoint, and WebKit/Blink only the latter","msgtype":"m.text"},"ts":1432072285000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: I guess so","msgtype":"m.text"},"ts":1432074359000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"philipj: I suppose we could revert the spec to caretRangeFromPoint if you think that's best. You should talk to zcorpan about it","msgtype":"m.text"},"ts":1432074384000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"roc: I suppose you don't have any metrics for how often caretPositionFromPoint is used?","msgtype":"m.text"},"ts":1432074455000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"if we're the only browser with it, I'm guessing it's unused","msgtype":"m.text"},"ts":1432074488000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"could be wrong","msgtype":"m.text"},"ts":1432074494000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"so yeah, no data","msgtype":"m.text"},"ts":1432074510000,"senderName":"roc","senderId":"roc@irc"},
{"content":{"body":"caretPositionFromPoint is a less strange API, I can see why it was changed","msgtype":"m.text"},"ts":1432074512000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"good job whoever fixed qSA + camelcased elements/attributes :d","msgtype":"m.text"},"ts":1432074683000,"senderName":"caitp-","senderId":"caitp-@irc"},
{"content":{"body":"I'll start a search in httparchive to see how caretRangeFromPoint is actually used","msgtype":"m.text"},"ts":1432074686000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"TabAtkins: where's that spec where you were writing things in JS? colors maybe?","msgtype":"m.text"},"ts":1432075443000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Yeah, color 4","msgtype":"m.text"},"ts":1432075515000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Found it.","msgtype":"m.text"},"ts":1432075520000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"V8 extras candidate \\o/","msgtype":"m.text"},"ts":1432075528000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: ???","msgtype":"m.text"},"ts":1432076676000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: https://groups.google.com/forum/#!topic/v8-users/D6FmTwlvCgk people asking for a design doc, I'm writing one, was looking for examples of where V8 extras would be a good strategy, color API is definitely one.","msgtype":"m.text"},"ts":1432076711000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Ah, cool.","msgtype":"m.text"},"ts":1432076796000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"}
]