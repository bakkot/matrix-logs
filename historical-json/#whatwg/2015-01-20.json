[
{"content":{"body":"I don't really understand jQuery","msgtype":"m.text"},"ts":1421750198000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"$(\"div\").replaceWith([$(\"div\"), \"<b>test</b>\"])","msgtype":"m.text"},"ts":1421750202000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Gives you \"<b>test</b>\", loses the <div> somehow...","msgtype":"m.text"},"ts":1421750221000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"window.$ = do_what_i_mean","msgtype":"m.text"},"ts":1421750234000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"If you remove ', \"<b>test</b>\"' however, the <div> stays...","msgtype":"m.text"},"ts":1421750244000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: any ideas how to reply to that oldNode.replaceWith() edge case thread?","msgtype":"m.text"},"ts":1421750265000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I've ignored it","msgtype":"m.text"},"ts":1421750326000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: that's not a great way to deal with feedback","msgtype":"m.text"},"ts":1421750387000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: also, I think those algorithms might in fact have some issues","msgtype":"m.text"},"ts":1421750401000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"That's your job :)","msgtype":"m.text"},"ts":1421750404000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"annevk: seems like a bug to remove the div there","msgtype":"m.text"},"ts":1421752423000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"Anyone know if the reftest.list files in CSS are actually correct?","msgtype":"m.text"},"ts":1421752924000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Oh, they seem to be generated so I'll assume they are","msgtype":"m.text"},"ts":1421753283000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Are Flexbox questions allowed here as well? ^_^","msgtype":"m.text"},"ts":1421754459000,"senderName":"GuidoBouman","senderId":"GuidoBouman@irc"},
{"content":{"body":"jgraham: correct how?","msgtype":"m.text"},"ts":1421754521000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"zcorpan_: should after() / before() / replaceWith() all work the same if you pass in the context object?","msgtype":"m.text"},"ts":1421755139000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"zcorpan_: suggestions welcome in that thread","msgtype":"m.text"},"ts":1421755174000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: i think jquery ignores the context node when it appears in an array for after/before/replaceWith","msgtype":"m.text"},"ts":1421755459000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"http://jsbin.com/cunejumepo/1/edit","msgtype":"m.text"},"ts":1421755538000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"what is more valuable, consistency with insertBefore etc, or with jQuery, being easier to debug mistakes, addressing more use cases?","msgtype":"m.text"},"ts":1421755661000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"SimonSapin: Correct in the sense of \"not incorrect\" :)","msgtype":"m.text"},"ts":1421756648000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"e.g. if they were hand-written files that didn't get updated regularly","msgtype":"m.text"},"ts":1421756671000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"I donâ€™t know","msgtype":"m.text"},"ts":1421756690000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"OK","msgtype":"m.text"},"ts":1421756736000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"zcorpan: speed and simplicity were some of the original requirements","msgtype":"m.text"},"ts":1421756748000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ok. i think i'm the wrong person to have an opinion on what is better here","msgtype":"m.text"},"ts":1421756885000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"annevk: I'm having to duplicate the about:blank handling from https://html.spec.whatwg.org/multipage/browsers.html#dom-open for cliens.openWindow() - is it appropiate to file a bug with the HTML spec asking for this to be abstracted?","msgtype":"m.text"},"ts":1421758753000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah, make it clear what you need though","msgtype":"m.text"},"ts":1421758810000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"shall do","msgtype":"m.text"},"ts":1421758821000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"cheers!","msgtype":"m.text"},"ts":1421758824000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: did you see the bug I copied you on?","msgtype":"m.text"},"ts":1421761366000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I can't really figure out how to make service workers not observable...","msgtype":"m.text"},"ts":1421761387000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: even ev.default() will have some effect (though it's unclear what that should be)","msgtype":"m.text"},"ts":1421761408000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: which bug sorry?","msgtype":"m.text"},"ts":1421761461000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: https://www.w3.org/Bugs/Public/show_bug.cgi?id=27524","msgtype":"m.text"},"ts":1421761617000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ta","msgtype":"m.text"},"ts":1421761648000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: annevk: if a document does a network request, triggers a SW fetch event, SW starts a different fetch() or cache.add().... and then the original document navigates away before the SW network requests finish... should those requests triggered from the SW fetch event be canceled or completed?","msgtype":"m.text"},"ts":1421762000000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I'm not sure what should happen to the FetchEvent instance, but the fetch() and cache.add() should succeed I would think","msgtype":"m.text"},"ts":1421762047000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: we don't want to have to traverse the calling stack","msgtype":"m.text"},"ts":1421762060000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well, in gecko we have the concept of a \"load group\"... if we share the load group with the document, then they will get canceled... don't think we need to \"traverse the calling stack\", but maybe I don't understand what you mean","msgtype":"m.text"},"ts":1421762108000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"right now we don't share the document load group directly with the service worker, though","msgtype":"m.text"},"ts":1421762130000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: sorry, forgot to CC you on this bug:  https://bugzilla.mozilla.org/show_bug.cgi?id=1122917","msgtype":"m.text"},"ts":1421762142000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: wanderview: I took a stab at this over in https://github.com/slightlyoff/ServiceWorker/issues/592#issuecomment-68853209","msgtype":"m.text"},"ts":1421762158000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I think that works... basically don't cancel the network request, but abort any resulting stream","msgtype":"m.text"},"ts":1421762290000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: and sorry... I read the later comments there, but somehow missed your comment","msgtype":"m.text"},"ts":1421762310000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: No worries! My comment was just a guess, but we don't really know if the request was associated with the fetch event until that point","msgtype":"m.text"},"ts":1421762352000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"wanderview: I don't like this \"load group\" concept as it's not part of any spec, but I guess we need to define something like it at some point","msgtype":"m.text"},"ts":1421762390000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: yea... since there can be multiple fetch events in flight at once... it seems we have to wait for resolveWith()","msgtype":"m.text"},"ts":1421762397000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: but given a document A and a service worker SW, they should probably never share a load group, except maybe for \"default\" cases, where it is a bit unclear how those should work","msgtype":"m.text"},"ts":1421762420000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: well... load group is a gecko implementation detail... doesn't have to be specifically in the spec... and its kind of hard to work with","msgtype":"m.text"},"ts":1421762433000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah, well we need a concept in specs of all fetches associated with a global","msgtype":"m.text"},"ts":1421762466000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: for various reasons","msgtype":"m.text"},"ts":1421762470000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: event.default() differs from fetch(event.request) in that it'll return redirects that'll be processed by the fetch spec without further SW interaction right? What does the synchronous part do?","msgtype":"m.text"},"ts":1421762494000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: in the event.default() case... gecko treats the load as being performed by the document (with its load group), not the SW...","msgtype":"m.text"},"ts":1421762511000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"synchronous part?","msgtype":"m.text"},"ts":1421762536000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: see the last comment","msgtype":"m.text"},"ts":1421762546000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: sorry, crossing the streams a little, I'm talking about https://www.w3.org/Bugs/Public/show_bug.cgi?id=27524","msgtype":"m.text"},"ts":1421762558000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"wanderview: that is sort of what the spec says for event.default() as well, however, what's unclear is how we deliver notifications to both globals","msgtype":"m.text"},"ts":1421762603000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I didn't realize the SW got any more events for that fetch event() once it did event.default()... or is that something we want to change?","msgtype":"m.text"},"ts":1421762683000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: how does the SW get a Response object out of event.default() if not for some kind of queued task from the network layer?","msgtype":"m.text"},"ts":1421762722000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: and how do we maintain progress updates to the document at the same time?","msgtype":"m.text"},"ts":1421762750000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ohhh, I think I'm starting to understand","msgtype":"m.text"},"ts":1421762758000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"wanderview: seems like it would require a very special path","msgtype":"m.text"},"ts":1421762763000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ah... I missed that it does that! :-)  for some reason I was thinking event.default() basically just sent it back to document... but I guess thats responseWith() using no argument","msgtype":"m.text"},"ts":1421762785000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or maybe I'm confused still","msgtype":"m.text"},"ts":1421762861000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: What if event.default() called fetch in a way that would give it back redirects (opaque if needed), and they're sent back to the original fetch which handles the redirects and doesn't call back into the SW","msgtype":"m.text"},"ts":1421762885000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Is that observable?","msgtype":"m.text"},"ts":1421762892000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"As far as I can remember event.default() was there pave over the redirect behaviour of a new fetch call consuming redirects","msgtype":"m.text"},"ts":1421762944000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I guess there is no respondWith()... you have to do event.respondWith(event.default())","msgtype":"m.text"},"ts":1421763004000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: yeah, download progress is still gone","msgtype":"m.text"},"ts":1421763031000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: the response is passed back to the browser before the stream is read","msgtype":"m.text"},"ts":1421763102000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: you might get the \"progress\" from sending it from SW to A, but the idea is that you get the progress from what actually happens network-wise (at least when using .default())","msgtype":"m.text"},"ts":1421763103000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: that is true","msgtype":"m.text"},"ts":1421763125000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm guessing on the impl side we can make the progress work... but not sure how it should be spec'd","msgtype":"m.text"},"ts":1421763158000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"If progress is judged by content-length headers & the stream, doesn't it just work?","msgtype":"m.text"},"ts":1421763181000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I doubt it \"just\" works :-)","msgtype":"m.text"},"ts":1421763206000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"For one thing there's that bug","msgtype":"m.text"},"ts":1421763213000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"That's my specing style. 1. Just, make it happen. 2. Srs have you even started yet? 3. Return correct response.","msgtype":"m.text"},"ts":1421763292000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1421763310000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: If event.default() made a new fetch, which would return raw redirects, then pass those back to the original fetch, doesn't that get us out of having to go from fetchA to SW to fetchA and back to SW?","msgtype":"m.text"},"ts":1421763380000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: in gecko we have the concept of a \"network callback\" which can be set on a load group to effect many requests, or just on a single network request... progress is communicated back to the document that way (I think)... so we can, in theory, set the progress callback for the document while performing the fetch in the SW context","msgtype":"m.text"},"ts":1421763397000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"So yeah, redirects were observable, anything else?","msgtype":"m.text"},"ts":1421763401000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: then Fetch needs to know SW used default()","msgtype":"m.text"},"ts":1421763471000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: see https://fetch.spec.whatwg.org/#http-fetch for how that would fall apart now","msgtype":"m.text"},"ts":1421763481000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think that's just a side effect of using event.default(). Things don't change from the document's perspective though, as the redirects are handled by the original fetch, baseurls are fine","msgtype":"m.text"},"ts":1421763486000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: Don't see how fetch needs to be aware of event.default(), although I've probably forgotten why","msgtype":"m.text"},"ts":1421763527000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: if default() does not handle redirects you can't store it in the cache as easily anymore","msgtype":"m.text"},"ts":1421763579000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: JakeA: sorry if this was discussed and I missed... but in the case where SW calls respondWith() with a different fetch() or cache.add()... should the document still get progress updates?  is this unique to default()?","msgtype":"m.text"},"ts":1421763585000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: also HTTP Fetch cannot block on all opaque stuff anymore and has to inspect if it's a redirect","msgtype":"m.text"},"ts":1421763607000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: it's a bit unclear","msgtype":"m.text"},"ts":1421763642000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"as a user... I imagine I would expect to still get progress in those cases","msgtype":"m.text"},"ts":1421763665000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: and I think you do given that the progress is mostly about the stream anyway","msgtype":"m.text"},"ts":1421763694000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: though you wouldn't if someone consumed the whole stream in the SW and then constructed a response and then passed that back","msgtype":"m.text"},"ts":1421763722000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: so the terminology we use in our impl is that there is a \"progress event sink\"... can that be spec'd?  so when event.respondWith(resp) is called, the UA sets the progress event sink for the associated document on the response?","msgtype":"m.text"},"ts":1421763747000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"and event.default() starts with the documents progress event sink","msgtype":"m.text"},"ts":1421763772000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: the browser should use the response it gets via respondWith to determine progress. So event.respondWith(fetch(url)) would show progress, event.respondWith(fetch(url).then(r => r,text()).then(t => new Response(t))) wouldn't","msgtype":"m.text"},"ts":1421763778000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Yeah, what JakeA says the specification defines now, that'd be hard to change","msgtype":"m.text"},"ts":1421763802000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I don't see a way around Fetch needing to know about default()","msgtype":"m.text"},"ts":1421763828000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ok, I think we have an impl bug... because I don't think we report progress in that case","msgtype":"m.text"},"ts":1421763834000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"goes to bugzilla.","msgtype":"m.emote"},"ts":1421763845000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: and it knows about default(), you might as well follow all the redirects in SW...","msgtype":"m.text"},"ts":1421763846000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: (so you can store the response in the cache)","msgtype":"m.text"},"ts":1421763855000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: progress events are based on the stream that comes from the network; from the document's perspective, the network is the SW; from the SW, it's the actual network","msgtype":"m.text"},"ts":1421763906000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: we talked about the SW being able to pass a response back that contained something to say \"btw, treat the base url as [whatever]\" to work around this","msgtype":"m.text"},"ts":1421763919000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I think it was dismissed as too hacky at the time","msgtype":"m.text"},"ts":1421763928000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"but maybe it's simpler?","msgtype":"m.text"},"ts":1421763933000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"wanderview: the confusing bit here is that the stream is shared and at some point probably cloned so it can be read simultaneously","msgtype":"m.text"},"ts":1421763940000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yea... but our current impl does not report progress (afaict) for event.respondWith(fetch(url))","msgtype":"m.text"},"ts":1421763946000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: fwiw, I don't Chrome does it with caches. Don't think those stream yet.","msgtype":"m.text"},"ts":1421764010000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: so we'd annotate the response from a .default() somehow?","msgtype":"m.text"},"ts":1421764017000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: as meaning \"imagine you followed a redirect to get here\"","msgtype":"m.text"},"ts":1421764042000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah","msgtype":"m.text"},"ts":1421764049000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it is pretty hacky","msgtype":"m.text"},"ts":1421764051000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":":D","msgtype":"m.text"},"ts":1421764055000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"less hacky than trying to loop back into the SW?","msgtype":"m.text"},"ts":1421764075000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: the alternative is that you don't get anything out of a .default()","msgtype":"m.text"},"ts":1421764114000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: that it's exactly identical to letting the request fly","msgtype":"m.text"},"ts":1421764126000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: sorry, to not do anything with the event","msgtype":"m.text"},"ts":1421764135000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: because now it is a bit different from not doing anything with the event, which is somewhat weird","msgtype":"m.text"},"ts":1421764163000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think event.default().catch(getAFallbackFromCache) needed","msgtype":"m.text"},"ts":1421764351000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"From memory, event.default() was there to let the browser do it's normal thing, but still offer recovery from failure. Caching result is nice too","msgtype":"m.text"},"ts":1421764518000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: if event.default() resolves with the eventual response, it isn't *ideal* for caching as you'd be caching it against the original request url","msgtype":"m.text"},"ts":1421764565000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"So your base urls would be off next time you get from the cache","msgtype":"m.text"},"ts":1421764576000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"(unless it had Jake's patented super magic \"use this as the base url\" hack)","msgtype":"m.text"},"ts":1421764667000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yea... the annoying thing is we don't get stuff like progress events for free with data streams in gecko... network streams are completely different than other streams :-\\","msgtype":"m.text"},"ts":1421764955000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: should we instead drop default() and put a way to mutate a response into requiring a synthetic redirect?","msgtype":"m.text"},"ts":1421764995000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm very interested in that. I've been wanting to kill .default() forever.","msgtype":"m.text"},"ts":1421765085000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I know :-)","msgtype":"m.text"},"ts":1421765096000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: open a ticket?","msgtype":"m.text"},"ts":1421765101000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Shall do","msgtype":"m.text"},"ts":1421765106000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: https://github.com/slightlyoff/ServiceWorker/issues/607","msgtype":"m.text"},"ts":1421766358000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: speccing Client. Multiple methods return a client object, but client doesn't have a constructor (although I guess it could), where would I define the construction steps? As in, taking an environment settings object and setting all the properties etc","msgtype":"m.text"},"ts":1421768247000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: some prose","msgtype":"m.text"},"ts":1421770767000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: \"To /create a Client object/, run these steps:\"","msgtype":"m.text"},"ts":1421770789000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Thanks. Also, I'm hitting the problem I think you tried to explain to me in the past. If the client is a SharedWorker, postMessage doesn't really fit, as SharedWorker doesn't have onmessage (it depends on ports for reasons I've never entirely understood). I guess this is why we should have WindowClient, but then just instances of DedicatedWorker &","msgtype":"m.text"},"ts":1421771031000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"SharedWorker?","msgtype":"m.text"},"ts":1421771032000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Never understood way SharedWorker uses ports the way it does. Why can't it just be sharedWorker.postMessage(â€¦), then the worker can respond via messageEvent.source","msgtype":"m.text"},"ts":1421773025000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"why*","msgtype":"m.text"},"ts":1421773035000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"0","msgtype":"m.text"},"ts":1421773110000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Symmetry?","msgtype":"m.text"},"ts":1421773157000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Symmetry with what?","msgtype":"m.text"},"ts":1421773171000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Could be that it was designed with the idea that everyone would be passing around ports as part of some capabilties system, which might skew one's views on good api design","msgtype":"m.text"},"ts":1421773393000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"JakeA: wait, does client.postMessage() go to window.onmessage?","msgtype":"m.text"},"ts":1421774163000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: or to navigator.serviceWorkers...?","msgtype":"m.text"},"ts":1421774171000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: the way shared worker works is that each worker or document that connects to it gets its own port","msgtype":"m.text"},"ts":1421774230000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: however, when a shared worker is controlled by a service worker we should not use that API","msgtype":"m.text"},"ts":1421774247000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: because that is a completely different relationship","msgtype":"m.text"},"ts":1421774257000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk, I wonder if there's anything useful in https://github.com/operasoftware/presto-testo/tree/master/imported/peter/unicode/html","msgtype":"m.text"},"ts":1421774288000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"annevk: client.postMessage would go to window.onmessage I thought","msgtype":"m.text"},"ts":1421774357000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Ms2ger: double and ent look redundant","msgtype":"m.text"},"ts":1421774358000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: ooooh, that's a lot of branching for window.onmessage then...","msgtype":"m.text"},"ts":1421774392000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I thought the events would go to the associated ServiceWorker object","msgtype":"m.text"},"ts":1421774410000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: maybe the excess stuff but I suspect we already got that covered elsewhere too","msgtype":"m.text"},"ts":1421774459000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ok, thanks for looking","msgtype":"m.text"},"ts":1421774478000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"JakeA: it seems pretty bad to overload window.onmessage like that","msgtype":"m.text"},"ts":1421774504000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: navigator.serviceWorker.onmessage? We don't have that right now, but we could. What's the issue with window.onmessage? https://html.spec.whatwg.org/multipage/comms.html#dom-window-postmessage makes it look simple aside from the transferables","msgtype":"m.text"},"ts":1421774529000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it's already used for cross-window postMessage","msgtype":"m.text"},"ts":1421774557000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: how can only client have postMessage()? How do you postMessage() from the window?","msgtype":"m.text"},"ts":1421774639000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I thought of window-to-window as client-to-client","msgtype":"m.text"},"ts":1421774667000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: no, so ServiceWorker inherits from Worker","msgtype":"m.text"},"ts":1421774682000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: and that has both postMessage() and onmessage","msgtype":"m.text"},"ts":1421774691000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: Client is the other side","msgtype":"m.text"},"ts":1421774702000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: it only makes sense for those two to talk to each other","msgtype":"m.text"},"ts":1421774711000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: messageEvent.source.postMessage would post back to serviceWorkerGlobalScope.onmessage","msgtype":"m.text"},"ts":1421774713000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"thinks","msgtype":"m.emote"},"ts":1421774741000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: so you were thinking the message would go to (await navigator.serviceWorker.getRegistration()).active?","msgtype":"m.text"},"ts":1421774889000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1421774934000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"that's the only thing that made sense to me and would work for both documents and workers","msgtype":"m.text"},"ts":1421774959000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"and would give a somewhat sane API","msgtype":"m.text"},"ts":1421774969000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"and be consistent with what we have for workers today","msgtype":"m.text"},"ts":1421774985000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Are you now going to tell me that Chrome implemented something else?","msgtype":"m.text"},"ts":1421774999000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"We haven't implemented clients yet","msgtype":"m.text"},"ts":1421775023000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"No messaging at all?","msgtype":"m.text"},"ts":1421775034000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Window to SW, but won't think we have a way back yet","msgtype":"m.text"},"ts":1421775073000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I think we need to stop & think about how this stuff works","msgtype":"m.text"},"ts":1421775104000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"registration objects don't feel client-unique to me, so not sure they're a good place for onmessage either","msgtype":"m.text"},"ts":1421775138000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I guess the only problem is that Client objects are currently designed as non-persistent","msgtype":"m.text"},"ts":1421775249000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"That doesn't make for a great message channel receiver","msgtype":"m.text"},"ts":1421775272000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I thought registration object was ServiceWorkerRegistration, not ServiceWorker","msgtype":"m.text"},"ts":1421775321000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(I hate the naming)","msgtype":"m.text"},"ts":1421775329000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yes, so (await navigator.serviceWorker.getRegistration()) is a ServiceWorkerRegistration, then .active is a ServiceWorker","msgtype":"m.text"},"ts":1421775366000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"ServiceWorkerRegistration is an origin-level thing rather than a client-specific thing, so getting client-specific message on it, or its properties feels wrong.","msgtype":"m.text"},"ts":1421775532000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Lemmie write up an issue \\o/","msgtype":"m.text"},"ts":1421775538000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: well, it's the only way to get a reference to a a client's own service worker","msgtype":"m.text"},"ts":1421775627000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: seems fairly fricking specific to me","msgtype":"m.text"},"ts":1421775634000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: a client selects a registration, but many clients can select the same registration","msgtype":"m.text"},"ts":1421775743000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: oh I see what you mean, I had imagined it would go to all of them, but indeed that does not really work","msgtype":"m.text"},"ts":1421776094000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: okay, so yes, we need something new :/","msgtype":"m.text"},"ts":1421776106000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think postMessage & serviceWorker has been handwaved all the way :(","msgtype":"m.text"},"ts":1421776155000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: It could be navigator.serviceWorker.onmessage for messages from a ServiceWorker. Anyway, will write up a ticket. Thanks for dragging me through it","msgtype":"m.text"},"ts":1421776201000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah, the whole \"just like shared workers\" stuff has been somewhat painful to point through","msgtype":"m.text"},"ts":1421776895000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: thanks","msgtype":"m.text"},"ts":1421776904000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Do we still like shared workers?","msgtype":"m.text"},"ts":1421776914000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Pretty sure that the answer is \"No\" for all questions of the form \"do we still like X\" where X is a past web technology, and \"Yes\" where X is a future web technology","msgtype":"m.text"},"ts":1421777050000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"so you're saying there's a chance that opinions might change in 20 years?","msgtype":"m.text"},"ts":1421777533000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"goodness","msgtype":"m.text"},"ts":1421777555000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I'm saying that there's a discontinuity at t=present :p","msgtype":"m.text"},"ts":1421777575000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"annevk: different subject, we're starting to look more seriously at background sync. I see FirefoxOS has something that I think was based on early ideas we had https://bugzilla.mozilla.org/show_bug.cgi?id=1018320 - who'd be best to get involved in making it a standard?","msgtype":"m.text"},"ts":1421777760000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it seems very likely it'll be the same people as service worker","msgtype":"m.text"},"ts":1421777797000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: not sure we can get time from the Firefox OS folks","msgtype":"m.text"},"ts":1421777807000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ok, it'd be good to get their learnings, but I'll sort something out with Jonas & yourself","msgtype":"m.text"},"ts":1421777848000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: copy overholt","msgtype":"m.text"},"ts":1421777932000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: he'll know who to talk to","msgtype":"m.text"},"ts":1421777940000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ta!","msgtype":"m.text"},"ts":1421777945000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: https://github.com/slightlyoff/ServiceWorker/issues/609","msgtype":"m.text"},"ts":1421778331000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"navigator.serviceWorker.onmessage seems to fit","msgtype":"m.text"},"ts":1421778349000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: I managed to confuse myself about \"queue a task\" and microtasks and such again. What do you think would happen in the following?","msgtype":"m.text"},"ts":1421784484000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"1. Queue a task to: 1a. resolve the promise p; 1b. fire an event named \"foo\". Given that I've registered a fulfillment handler on p and a listener for \"foo\", which fires first?","msgtype":"m.text"},"ts":1421784528000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think the listener","msgtype":"m.text"},"ts":1421784566000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"At first I thought it'd be \"foo\" first since events are \"synchronous\". But then I thought it'd be p first since microtasks fire whenever you transition from UA code to user code.","msgtype":"m.text"},"ts":1421784567000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1421784574000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But I have no idea how microtasks work","msgtype":"m.text"},"ts":1421784583000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Do they fire before calling event handlers?","msgtype":"m.text"},"ts":1421784600000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Presumably not, because then you could sniff whether there are event handlers attached for some type","msgtype":"m.text"},"ts":1421784620000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"I ... think so. This might start falling into the unspecced areas :-/. Hixie do you know?","msgtype":"m.text"},"ts":1421784621000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: no microtasks would fire in that case until the first script for the first event listener returned, iirc","msgtype":"m.text"},"ts":1421785158000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: hmm OK. So saying \"microtasks fire whenever transitioning from UA code to user code\" is not really correct of me to say then. That's good to know.","msgtype":"m.text"},"ts":1421785210000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"no it's much more specific than that","msgtype":"m.text"},"ts":1421785823000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Domenic: the event goes first","msgtype":"m.text"},"ts":1421789996000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Domenic: microtasks run end-of-task","msgtype":"m.text"},"ts":1421790020000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"got it :)","msgtype":"m.text"},"ts":1421790045000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"annevk, a few changes for you in https://critic.hoppipolla.co.uk/r/3723","msgtype":"m.text"},"ts":1421791825000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"zcorpan, fyi https://bugzilla.mozilla.org/show_bug.cgi?id=1122897","msgtype":"m.text"},"ts":1421793875000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"annevk: microtasks also run end-of-script","msgtype":"m.text"},"ts":1421795852000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"annevk: are you sure they wouldn't run between two event listeners here?","msgtype":"m.text"},"ts":1421795862000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"They should run between event listeners, I think.  (I could easily be wrong.)","msgtype":"m.text"},"ts":1421795886000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"is missing the context, but if there isn't any other script on stack when event listeners run, microtasks run between them","msgtype":"m.emote"},"ts":1421797099000,"senderName":"smaug____","senderId":"smaug____@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1421797189000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"in conclusion, Domenic, resolving the promise and then firing an event is going to lead to weird behaviour","msgtype":"m.text"},"ts":1421797212000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"yep","msgtype":"m.text"},"ts":1421797230000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: you might be better off resolving then queueing a task to fire the event, or resolving then running microtasks then firing the event","msgtype":"m.text"},"ts":1421797233000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"or not firing the event at all","msgtype":"m.text"},"ts":1421797237000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Yeah the current plan is actually just \"when p fulfills, fire an event named 'foo'\"","msgtype":"m.text"},"ts":1421797273000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"is \"fulfills\" defined?","msgtype":"m.text"},"ts":1421797310000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"like, what does that mean?","msgtype":"m.text"},"ts":1421797319000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"http://www.w3.org/2001/tag/doc/promises-guide#shorthand-reacting","msgtype":"m.text"},"ts":1421797406000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i don't understand","msgtype":"m.text"},"ts":1421797838000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"\"fire an event\" isn't a function","msgtype":"m.text"},"ts":1421797853000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"you can't really define prose-given requirements in terms of javascript code","msgtype":"m.text"},"ts":1421797869000,"senderName":"Hixie","senderId":"Hixie@irc"}
]