[
{"content":{"body":"Oh lgrahl left. I was gonna point out that these are the same people that initially passed on promises. I hope they won’t make that mistake again…","msgtype":"m.text"},"ts":1516944720000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hsivonen: really glad we got that blame setup for the HTML Standard btw","msgtype":"m.text"},"ts":1516954081000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hsivonen: already traced back many things","msgtype":"m.text"},"ts":1516954086000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hsivonen: and much quicker than calculating it locally","msgtype":"m.text"},"ts":1516954096000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Good morning/evening, I'm currently writing my bachelor thesis on service worker and progressive web apps. I'd like to write a small historic introduction of the steps that lead to the current ServiceWorker definition by the W3C and so I discovered the existance of WHATWG ( people outside doesn't know you exist). Can someone share to me some resource of the Web Workers definition story? Did W3C used some part of them to define Service W","msgtype":"m.text"},"ts":1516966916000,"senderName":"gabri","senderId":"gabri@irc"},
{"content":{"body":"@gabri: You can find an extensive history in the repository of the spec: https://github.com/w3c/ServiceWorker","msgtype":"m.text"},"ts":1516967006000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"It’s not necessarily easy to consume, but if you look at older/closed issues and the discussions therein, you should find a lot of interesting information","msgtype":"m.text"},"ts":1516967031000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"Stream spec: Is there anything speaking against turning `controller` in the note here into a link? I often find myself looking up how to define an `underlyingSource` and then having no link to the definition of controller in the vicinity. https://streams.spec.whatwg.org/#rs-constructor","msgtype":"m.text"},"ts":1516967089000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"thank you @surma","msgtype":"m.text"},"ts":1516967150000,"senderName":"gabri","senderId":"gabri@irc"},
{"content":{"body":"ricea: ^^ question about streams","msgtype":"m.text"},"ts":1516967419000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"gabri: workers were inspired by Google Gears; see https://lists.w3.org/Archives/Public/public-whatwg-archive/2008Jul/0110.html for one of the earlier messages summarizing the initial addition","msgtype":"m.text"},"ts":1516967609000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"foolip: so I'm almost never having problems with the build script anymore","msgtype":"m.text"},"ts":1516967969000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"foolip: adding retry seemingly helped","msgtype":"m.text"},"ts":1516967981000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Whenever it fails now it's just my mistake","msgtype":"m.text"},"ts":1516968013000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: huh, which bit are you guessing was failing before?","msgtype":"m.text"},"ts":1516968028000,"senderName":"foolip","senderId":"foolip@irc"},
{"content":{"body":"foolip: curl for bikeshed was failing every now and then","msgtype":"m.text"},"ts":1516968089000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"foolip: I added https://github.com/whatwg/whatwg.org/commit/0db31edad82b56f6419fc555fb9c2d334db7bc16#diff-e9607901cbff22c83689e88cb1c1eca6 and haven't seen it since","msgtype":"m.text"},"ts":1516968098000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ok, so Bikeshed. Well, I guess retry is the way of reliability when networks are involved, even though it feels icky","msgtype":"m.text"},"ts":1516968181000,"senderName":"foolip","senderId":"foolip@irc"},
{"content":{"body":"I never feel icky about whatever TCP does though :)","msgtype":"m.text"},"ts":1516968196000,"senderName":"foolip","senderId":"foolip@irc"},
{"content":{"body":"Well, curl for whatwg.org fails sometimes too, but that I cannot patch in the build script","msgtype":"m.text"},"ts":1516968316000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Would have to patch each caller and it hasn't happened a lot recently so I'm not too bothered","msgtype":"m.text"},"ts":1516968331000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"And yeah, it's bugs all the way down and up","msgtype":"m.text"},"ts":1516968340000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Read your last message in the log. Yeah, what can I say... it's not easy to convince these people.","msgtype":"m.text"},"ts":1516968712000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: I added a comment on the issue that I hope helps","msgtype":"m.text"},"ts":1516968736000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: but my understanding of WebRTC is not great...","msgtype":"m.text"},"ts":1516968759000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah, thanks. I was too tired of it yesterday to add anything.","msgtype":"m.text"},"ts":1516968762000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"At least API-wise it's not great.","msgtype":"m.text"},"ts":1516969047000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"I have a quick question for the Fetch API: IIRC one sends a HTTP request and gets a body mixin as soon as the header of the response has been received. And then one can choose in what kind of data format they want to have it. Is that correct or have I missed something? Disclaimer: I haven't read all of it.","msgtype":"m.text"},"ts":1516969157000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: reading the backlog, a blob provides async access to fixed-size memory (sometimes backed by a file, if the file is changed, the blob will error); given the way a blob is allocated though you cannot really do it before you have all the bytes (arguably maybe you can if you know the size upfront, but that would be new thing of sorts and probably require","msgtype":"m.text"},"ts":1516969289000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"significant impl work)","msgtype":"m.text"},"ts":1516969290000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: once you have all headers, yes","msgtype":"m.text"},"ts":1516969315000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: and yeah, you can pick between \"read all bytes as X\" and \"gimma the stream\"","msgtype":"m.text"},"ts":1516969362000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(at that point)","msgtype":"m.text"},"ts":1516969366000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"back later, lunch","msgtype":"m.text"},"ts":1516969371000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Right, so a Blob is essentially too high-level. It would be massive backpressure on the receiver side (one can argue about the sender side because at least theoretically a Blob could be read in chunks). Whereas a stream is high-level when possible and low-level when I need it. It also allows me to handle backpressure.","msgtype":"m.text"},"ts":1516969559000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"annevk: If there's anything else coming to mind where streams provide an advantage over Blob, let me know. Anything that helps to convince them. :)","msgtype":"m.text"},"ts":1516969792000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"annevk: Coming back to the body mixin... I think this would have been cool for WebSocket and data channels but it's probably too late for that. USVString for example is not something you can choose on the receiver side but rather the sender enforces it by sending one. I'd say streams are our best bet now.","msgtype":"m.text"},"ts":1516970498000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: why could you not make it possible to chose string/bytes on the receiver side?","msgtype":"m.text"},"ts":1516971653000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: it seems if you can enable streams, you can enable that too (not saying it's needed per se though)","msgtype":"m.text"},"ts":1516971671000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Data channels (and I think WebSocket too) have some kind of type inside of a message that indicates whether the message is binary or USVString.","msgtype":"m.text"},"ts":1516971718000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: sure, HTTP has that too through Content-Type, but you can still do whatever","msgtype":"m.text"},"ts":1516971775000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: current API shape might be either/or, but that's not inherent I think","msgtype":"m.text"},"ts":1516971799000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Sure. But it would be kind of confusing to have an API where you either get USVString or binary where you can choose between ArrayBuffer and Blob and (new) Mixin... which again would let you choose to use .text, .json, .blob, ...","msgtype":"m.text"},"ts":1516971890000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"It makes sense for us but will it make sense for them? :)","msgtype":"m.text"},"ts":1516971962000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Yeah, that's probably not the way to go","msgtype":"m.text"},"ts":1516972049000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"lgrahl: the other thing to consider here is that the timing for the event would be different","msgtype":"m.text"},"ts":1516972070000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"In a revised API we should go for it.","msgtype":"m.text"},"ts":1516972075000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Yeah, you mean when you switch between Blob and stream?","msgtype":"m.text"},"ts":1516972107000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: you might just want a new messagestart even or some such","msgtype":"m.text"},"ts":1516972110000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It's not a big deal though as only one message can be received at a time per channel. It's just something API users need to be aware of but most of them will probably not even bother (because it's not really different in terms of usage).","msgtype":"m.text"},"ts":1516972211000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"So, unless I missed something, it would be fine to use 'onmessage' for that. Also, I'm not a big fan of event callbacks because they are hard to handle when you have plenty of them.","msgtype":"m.text"},"ts":1516972324000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"Good morning/afternoon. I'm the same as before asking for resources for his thesis. Now my question is about AppCache, I know it's deprecated but I'd like to have a clarification anyway. There are both W3C and WHATWG documents about this, who is the original proposer? If my questions annoy, tell me and I'll quit","msgtype":"m.text"},"ts":1516977887000,"senderName":"gabri","senderId":"gabri@irc"},
{"content":{"body":"gabri: https://github.com/whatwg/web-history might help","msgtype":"m.text"},"ts":1516978015000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"gabri: basically most things HTML5 originated at the WHATWG","msgtype":"m.text"},"ts":1516978030000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"This might be the right thing I'm looking for, thank you!","msgtype":"m.text"},"ts":1516978071000,"senderName":"gabri","senderId":"gabri@irc"},
{"content":{"body":"yoav_: does preload cache in chrome/webkit sit above or below service worker interception?","msgtype":"m.text"},"ts":1516984901000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yoav_: I know its unspec'd... just curious what browsers are actually doing","msgtype":"m.text"},"ts":1516985031000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yoav_: I've been told it just hooks into memory cache... which I guess means it sits above service worker interception","msgtype":"m.text"},"ts":1516985158000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: above","msgtype":"m.text"},"ts":1516985783000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"annevk: If a data channel's message would be a stream, I could pipe this directly into a HTTP request by using the fetch API and thus upload a large file efficiently, right?","msgtype":"m.text"},"ts":1516986112000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: yeah, in theory","msgtype":"m.text"},"ts":1516986145000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: And practice? :)","msgtype":"m.text"},"ts":1516986159000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: no impl for upload","msgtype":"m.text"},"ts":1516986184000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk. Ah, okay. Are there implementations for Response so far?","msgtype":"m.text"},"ts":1516986236000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"lgrahl: for Response I believe all browsers except firefox have implemented ReadableStream body","msgtype":"m.text"},"ts":1516986264000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"firefox implementation is disabled behind a pref while a few issues are sorted out","msgtype":"m.text"},"ts":1516986330000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: Okay, cheers!","msgtype":"m.text"},"ts":1516986441000,"senderName":"lgrahl","senderId":"lgrahl@irc"},
{"content":{"body":"yoav: thanks","msgtype":"m.text"},"ts":1516986461000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: if a constructor takes one optional argument, what is Interface.length? 0 or 1?","msgtype":"m.text"},"ts":1516991088000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Looks like 0 based on FormData","msgtype":"m.text"},"ts":1516991609000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"surma: I don't own the Streams spec, but there's almost never a problem with more links. Send a patch against https://github.com/whatwg/streams/blob/master/index.bs#L439?","msgtype":"m.text"},"ts":1516991985000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"jyasskin: Noice. Thanks!","msgtype":"m.text"},"ts":1516992029000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"surma: goes for structuredClone too btw","msgtype":"m.text"},"ts":1516992550000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Yes. Planning on tackling (and PR’ing) that in ~2 weeks. Have some travel for the next 2 weeks.","msgtype":"m.text"},"ts":1516992618000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"Cool cool","msgtype":"m.text"},"ts":1516992742000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"surma: you might be interested in the fact that structured cloning with V8 is indeed faster than JSON.parse(JSON.stringify()). Node.js exposes some lower level bindings to V8","msgtype":"m.text"},"ts":1516992815000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"'s serializer/deserializer, and you can test that with v8.deserialize(v8.serialize(obj)).","msgtype":"m.text"},"ts":1516992844000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"v8.serialize() returns a Buffer (a Uint8Array subclass) though, and if you convert that to a string then JSON is still faster","msgtype":"m.text"},"ts":1516992879000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"TimothyGu: That’s super interesting, considering that I haven‘t found any way to be faster than JSON.* in a browser environment","msgtype":"m.text"},"ts":1516993000000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"not by much really, but still some","msgtype":"m.text"},"ts":1516993025000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"Well, even if it’s only a tiny bit faster, it’s win considering it’s more flexible/powerful.","msgtype":"m.text"},"ts":1516993059000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"Good point.","msgtype":"m.text"},"ts":1516993099000,"senderName":"TimothyGu","senderId":"TimothyGu@irc"},
{"content":{"body":"So in Node.js the serialization format is exposed? o_O","msgtype":"m.text"},"ts":1516994125000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"surma: we currently use an HTTP API for Bikeshed; I don’t really know if switching to Docker would end up using less resources…","msgtype":"m.text"},"ts":1516996391000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I wasn’t trying to replace the HTTP API. But if you wanna build offline and don’t want to bother with setting it up, it might come in handy. No worries if you just wanna ignore the entire thing. I mostly built it for myself :)","msgtype":"m.text"},"ts":1516996441000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"surma: I might look into it since I had some issues last I looked into it, but I’m mostly happy just using Travis et al","msgtype":"m.text"},"ts":1516996517000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It might also be nice to lower the barrier to entry to spec work","msgtype":"m.text"},"ts":1516996544000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"If people want to play around with BS and figure out the syntax, they can just dive in straight away","msgtype":"m.text"},"ts":1516996560000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"Well, if they have Docker knowledge and installation","msgtype":"m.text"},"ts":1517000522000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: Installation, yes. Knowledge, not really. You literally copy-paste the command from the readme. It will download the image automatically if necessary. But yes, installing docker would still be required.","msgtype":"m.text"},"ts":1517003861000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"TabAtkins: I am building the stream spec and it seems `<emu-alg>` is not being processed properly. Is that a problem in my setup or is that a stream spec special thing?","msgtype":"m.text"},"ts":1517003898000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"TabAtkins: ^ That is a bikeshed question.","msgtype":"m.text"},"ts":1517003918000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"Streams uses ecmarkup as well, which isn't part of Bikeshed quite yet. Domenic can tell you how to get that set up.","msgtype":"m.text"},"ts":1517003985000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(https://bterlson.github.io/ecmarkup/)","msgtype":"m.text"},"ts":1517004005000,"senderName":"jyasskin","senderId":"jyasskin@irc"},
{"content":{"body":"Thaaaaanks.","msgtype":"m.text"},"ts":1517004015000,"senderName":"surma","senderId":"surma@irc"},
{"content":{"body":"\\o/ My first WHATWG spec PR https://github.com/whatwg/streams/pull/872","msgtype":"m.text"},"ts":1517006001000,"senderName":"surma","senderId":"surma@irc"}
]