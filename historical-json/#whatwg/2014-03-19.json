[
{"content":{"body":"wtf","msgtype":"m.text"},"ts":1395187637000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"json encodes astral characters as their UTF-16 surrogates encoded in ASCII???","msgtype":"m.text"},"ts":1395187656000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"I think I found a bug in Chrome: http://codepen.io/JosephSilber/pen/dFgxo/","msgtype":"m.text"},"ts":1395187674000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"Toggling the \"absolute\" class there doesn't affect the parent's width.","msgtype":"m.text"},"ts":1395187719000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"crbug.com/new","msgtype":"m.text"},"ts":1395187735000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Adding the \"absolute\" class directly in the HTML does work: http://codepen.io/JosephSilber/pen/LiCKA/","msgtype":"m.text"},"ts":1395187737000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"Hixie: Yeah. Just checking here first if I'm misunderstanding expected behavior.","msgtype":"m.text"},"ts":1395187766000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"i don't understand what's going on in that test","msgtype":"m.text"},"ts":1395187798000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"there's three files?","msgtype":"m.text"},"ts":1395187814000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: there are two flex containers, nested.","msgtype":"m.text"},"ts":1395187839000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"The inner container should collapse to its content's width.","msgtype":"m.text"},"ts":1395187854000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"Hixie: yes. The J in JSON is JavaScript, 16bit strings and all","msgtype":"m.text"},"ts":1395187871000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"Setting one of its children's position to absolute should collpase the container's width.","msgtype":"m.text"},"ts":1395187891000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"at least, that’s if you want to backslash-escape such characters. I think just having them literally in UTF-8 should also work","msgtype":"m.text"},"ts":1395187902000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"Work well in Firefox, and also works well in Chrome when not doing it dynamically.","msgtype":"m.text"},"ts":1395187908000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"JosephSilber: is http://software.hixie.ch/utilities/js/live-dom-viewer/?saved=2893 equivalent to your test?","msgtype":"m.text"},"ts":1395188032000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: yes. Shouldn't .inner's width collpase? Like it does here: http://codepen.io/JosephSilber/pen/LiCKA/","msgtype":"m.text"},"ts":1395188098000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"JosephSilber: it seems to work to me... when you set the attribute, the element becomes abs pos and the right thing moves under it. am i missing something?","msgtype":"m.text"},"ts":1395188098000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: check it out in ff","msgtype":"m.text"},"ts":1395188119000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"oh i see, the width is on the inner ones, not the outer ones","msgtype":"m.text"},"ts":1395188124000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"yup, looks like a bug","msgtype":"m.text"},"ts":1395188127000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"k. will report","msgtype":"m.text"},"ts":1395188134000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"(btw when making a test case you really want to use as little as possible. so e.g. all the styles on the button are extraneous here and should be dropped in the test. having a separate <script> block is extraneous if you can just do it inline. etc.)","msgtype":"m.text"},"ts":1395188173000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(i thought the rgba() thing was especially amusing :-) )","msgtype":"m.text"},"ts":1395188184000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"It's scss","msgtype":"m.text"},"ts":1395188218000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"scss?","msgtype":"m.text"},"ts":1395188360000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"in a test? :-)","msgtype":"m.text"},"ts":1395188374000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"ha","msgtype":"m.text"},"ts":1395188550000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"JosephSilber: Yeah, that's a bug.","msgtype":"m.text"},"ts":1395188639000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"reporting","msgtype":"m.text"},"ts":1395188654000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"SimonSapin: raw UTF-8, huh? well, as long as we aren't applying \"UTF-8\" to the UTF-16 ...","msgtype":"m.text"},"ts":1395188798000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"(which is actually called something else)","msgtype":"m.text"},"ts":1395188805000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"wait, what?","msgtype":"m.text"},"ts":1395188835000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"no, it’s not CESU-8","msgtype":"m.text"},"ts":1395188879000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"https://code.google.com/p/chromium/issues/detail?id=353837&thanks=353837&ts=1395188953","msgtype":"m.text"},"ts":1395188973000,"senderName":"JosephSilber","senderId":"JosephSilber@irc"},
{"content":{"body":"tantek: are all of the rel values in the POSH table of the link-relations page meant to be considered conforming/valid?","msgtype":"m.text"},"ts":1395190826000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"no","msgtype":"m.text"},"ts":1395190910000,"senderName":"tantek","senderId":"tantek@irc"},
{"content":{"body":"they're just random author extensions, HTML4 style","msgtype":"m.text"},"ts":1395190920000,"senderName":"tantek","senderId":"tantek@irc"},
{"content":{"body":"basically, they're stuff someone has found in the wild","msgtype":"m.text"},"ts":1395190972000,"senderName":"tantek","senderId":"tantek@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1395191046000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"rel=publisher semms to be used quite a lot","msgtype":"m.text"},"ts":1395191083000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"if there's a spec for rel=publisher, and you think it's a useful value, go ahead and add it to http://microformats.org/wiki/existing-rel-values#HTML5_link_type_extensions","msgtype":"m.text"},"ts":1395191154000,"senderName":"tantek","senderId":"tantek@irc"},
{"content":{"body":"I haven't found a use for it myself so I've ignored it","msgtype":"m.text"},"ts":1395191170000,"senderName":"tantek","senderId":"tantek@irc"},
{"content":{"body":"I figure it someone cares about it enough, they'll do the minimal step of \"registering\" it by editing the wiki","msgtype":"m.text"},"ts":1395191194000,"senderName":"tantek","senderId":"tantek@irc"},
{"content":{"body":"tantek: yeah you're right. I'll wait to see if anybody registers it.","msgtype":"m.text"},"ts":1395191713000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"wow, a phishing attempt with the subject line \"full specification\"","msgtype":"m.text"},"ts":1395195872000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"that's a bit more targetted than i expected!","msgtype":"m.text"},"ts":1395195879000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"am i missing something, or does the JSON specification not say what the root of the grammar is","msgtype":"m.text"},"ts":1395198987000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"rfc4627 does, so i guess i'll use that","msgtype":"m.text"},"ts":1395199172000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(how many specs does one format need, anyway)","msgtype":"m.text"},"ts":1395199184000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Question as to whether something is a bug or feature:","msgtype":"m.text"},"ts":1395199466000,"senderName":"estellevw","senderId":"estellevw@irc"},
{"content":{"body":"when a min and max are both set on <input type=\"number\"> chrome makes the input as narrow as needed for the width of the maximum value -- so when max is not set, the input is much wider. I can see that the #shadow-root <div id=inner-editor> is getting a width set, but I don't see where it is getting that width set.","msgtype":"m.text"},"ts":1395199492000,"senderName":"estellevw","senderId":"estellevw@irc"},
{"content":{"body":"http://codepen.io/estelle/pen/rIlFv/ is the test case","msgtype":"m.text"},"ts":1395199511000,"senderName":"estellevw","senderId":"estellevw@irc"},
{"content":{"body":"FF on the other hand has them all the same width","msgtype":"m.text"},"ts":1395199533000,"senderName":"estellevw","senderId":"estellevw@irc"},
{"content":{"body":"if the question is \"can a user agent vary the width of a type=number field based on the allowed range\", the answer is yes. it can also vary the colour. it can also vary the width based on the time of day.","msgtype":"m.text"},"ts":1395199550000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it can also replace the text field with a button that pops up a dialog that asks the user for the number in roman numerals input via ASL recognised by webcam","msgtype":"m.text"},"ts":1395199586000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it isn't expected behavior though in the minds of most developers","msgtype":"m.text"},"ts":1395199681000,"senderName":"estellevw","senderId":"estellevw@irc"},
{"content":{"body":"unfortunately, that is true","msgtype":"m.text"},"ts":1395199712000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it forces developers to include css width for input types because default width is no longer rational","msgtype":"m.text"},"ts":1395199735000,"senderName":"estellevw","senderId":"estellevw@irc"},
{"content":{"body":"but most developers seem to forget that HTML is not primarily (let alone exclusively) a visual page description language","msgtype":"m.text"},"ts":1395199738000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"ok, thanks","msgtype":"m.text"},"ts":1395199746000,"senderName":"estellevw","senderId":"estellevw@irc"},
{"content":{"body":"so, feature, not bug. thanks","msgtype":"m.text"},"ts":1395199760000,"senderName":"estellevw","senderId":"estellevw@irc"},
{"content":{"body":"i mean, there's nothing about HTML that says that the CSS will even be looked at","msgtype":"m.text"},"ts":1395199760000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"or that the page won't be rendered by speaking it out loud","msgtype":"m.text"},"ts":1395199767000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"or in braille","msgtype":"m.text"},"ts":1395199770000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"on a dynamic braille display","msgtype":"m.text"},"ts":1395199781000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"in other news, wtf, https://www.ietf.org/rfc/rfc4627.txt actually CONTRADICTS the json.org description","msgtype":"m.text"},"ts":1395199890000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"In what way?","msgtype":"m.text"},"ts":1395199988000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"the rfc (and ecma 404) say that whitespace can be before or after tokens, the page says whitespace can only be between tokens.","msgtype":"m.text"},"ts":1395200018000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"yay for competing specs","msgtype":"m.text"},"ts":1395200134000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"not really surprising that a description of a format based on unreadable state diagrams is imprecise","msgtype":"m.text"},"ts":1395200183000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"the diagrams are actually very precise","msgtype":"m.text"},"ts":1395200196000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it's the stuff around them that's confusing","msgtype":"m.text"},"ts":1395200200000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"reminds me of sqlite's documentation: used to be readable, then at some point changed to that style of diagram, which made them completely worthless and unreadable","msgtype":"m.text"},"ts":1395200211000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"you don't like railroad diagrams? why not?","msgtype":"m.text"},"ts":1395200226000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"they're really nice and simple to understand","msgtype":"m.text"},"ts":1395200231000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"because they're hard to read","msgtype":"m.text"},"ts":1395200236000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"if HTML's syntax wasn't such a mess, i'd totally use them to specify everything in HTML too","msgtype":"m.text"},"ts":1395200247000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i find them really easy to read","msgtype":"m.text"},"ts":1395200259000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"you just start on one end and follow the paths","msgtype":"m.text"},"ts":1395200266000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"for documentation, at least (eg. user-facing)","msgtype":"m.text"},"ts":1395200282000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"given http://www.postgresql.org/docs/9.0/static/sql-select.html vs. https://www.sqlite.org/lang_select.html, sqlite's are utterly useless and opaque to me as a user","msgtype":"m.text"},"ts":1395200310000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"oh man, i couldn't disagree more","msgtype":"m.text"},"ts":1395200370000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"the postgre one there is the unreadable one","msgtype":"m.text"},"ts":1395200380000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i can skim and understand postgresql's at a glance; i have to stare and squint at sqlite's","msgtype":"m.text"},"ts":1395200399000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"the mysql docs use the postgre style too and i have to twease them apart each time to work out what they mean","msgtype":"m.text"},"ts":1395200400000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"the sqlite one is just a matter of following the line, so much easier for me","msgtype":"m.text"},"ts":1395200416000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(the sqlite ones are even better than the json ones, since they have arrows)","msgtype":"m.text"},"ts":1395200443000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"maybe for a spec where i was writing a parser, but as a user writing SQL queries postgres's lets me see the command much more naturally","msgtype":"m.text"},"ts":1395200480000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"oh hey, look at that. nothing in ecma 404 says that the keys in a json object must be unique, and the RFC only makes uniqueness a SHOULD.","msgtype":"m.text"},"ts":1395200520000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Well, the rfc says \"Insignificant whitespace is allowed before or after any of the six structural characters\"","msgtype":"m.text"},"ts":1395200540000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"zewt: i have found the opposite, personally","msgtype":"m.text"},"ts":1395200542000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"whereas ecma 404 says before or after any value","msgtype":"m.text"},"ts":1395200545000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"without a parser algorithm, a \"must\" would be pretty meaningless anyway","msgtype":"m.text"},"ts":1395200546000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Krinkle: right, those two agree. but json.org says \"between\".","msgtype":"m.text"},"ts":1395200560000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"so that still leaves a different regarding whitespace before e.g. a non-object as root","msgtype":"m.text"},"ts":1395200565000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"at least as far as parsers go","msgtype":"m.text"},"ts":1395200568000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Krinkle: well that too","msgtype":"m.text"},"ts":1395200579000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"even those two don't agree imho","msgtype":"m.text"},"ts":1395200587000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"e.g. ` \"foo\" `","msgtype":"m.text"},"ts":1395200592000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Krinkle: but the rfc is clear that only object and array are allowed as root","msgtype":"m.text"},"ts":1395200593000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"as the sole json packet","msgtype":"m.text"},"ts":1395200598000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"or some rule that says \"if there are illegal duplicated keys, parsing fails\"","msgtype":"m.text"},"ts":1395200600000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Krinkle: 404 and json.org don't actually say what the root of a json file is (!)","msgtype":"m.text"},"ts":1395200604000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Krinkle: (i was complaining about that earlier)","msgtype":"m.text"},"ts":1395200612000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"from my use of JSON, any type can be the root; \"10\" is valid JSON","msgtype":"m.text"},"ts":1395200630000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"(but I know there are parsers that expect the root to be a dictionary)","msgtype":"m.text"},"ts":1395200641000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Yes, any JSON value (which is specified)","msgtype":"m.text"},"ts":1395200642000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"I don't think it should have to declare a root, you're encoding or decoding values as JSON values.","msgtype":"m.text"},"ts":1395200658000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"that should be sufficient","msgtype":"m.text"},"ts":1395200666000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"the RFC disagrees","msgtype":"m.text"},"ts":1395200673000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Krinkle: well, \"value\" should be the root (using json.org's terminology)","msgtype":"m.text"},"ts":1395200695000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"that should definitely be specified, if json.org is meant to be used as a spec (don't really know if it is)","msgtype":"m.text"},"ts":1395200709000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"decides that for his purposes, JSON objects are gonna have to have unique keys","msgtype":"m.emote"},"ts":1395200718000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Where does the RFC say that root can only be array or object?","msgtype":"m.text"},"ts":1395200726000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"section 2 paragraph 2:    A JSON text is a serialized object or array.","msgtype":"m.text"},"ts":1395200740000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"      JSON-text = object / array","msgtype":"m.text"},"ts":1395200741000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Right","msgtype":"m.text"},"ts":1395200752000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"seems like the main important thing is defining which key is used if there's a duplicate (first or last, presumably)","msgtype":"m.text"},"ts":1395200799000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"zewt: given that these specs all agree that parsers can \"support a superset\" of json... (!)","msgtype":"m.text"},"ts":1395200825000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"So does this actually cause a problem in practice? Or just pointing out an oversight? I think all parsers I've seen just treat 'JSON-text = value' that's the easiest","msgtype":"m.text"},"ts":1395200838000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"i've written JSON parsers and I couldn't even say which behavior my parsers use (but they're only used in controlled environments, where it doesn't matter)","msgtype":"m.text"},"ts":1395200841000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Krinkle: i'm implementing a parser and have no idea what i'm supposed to be doing, either about whitespace, about the root, or about keys in objects.","msgtype":"m.text"},"ts":1395200874000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(most likely the last)","msgtype":"m.text"},"ts":1395200875000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"man, the lack of comments in json is a pain in teh ass","msgtype":"m.text"},"ts":1395200901000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"ignore whitespace, use your 'value' argorythem from the root (don't special case the root, just go straight into parsing the value),","msgtype":"m.text"},"ts":1395200923000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"what about keys in objects?","msgtype":"m.text"},"ts":1395200929000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"FWIW, both Chrome and Firefox's JSON.parse(\"10\") return 10, so on that one I'd have to say the RFC (from what you've described) is wrong","msgtype":"m.text"},"ts":1395200943000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"(a data point which I'm sure you already know, heh)","msgtype":"m.text"},"ts":1395200964000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"the \"value\" thing directly contradicts the RFC, and the others are entirely vague about this, so I'm not convinced about that.","msgtype":"m.text"},"ts":1395200966000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it doesn't contradict it, it just supports a compatible superset.","msgtype":"m.text"},"ts":1395200984000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"one that is quite common","msgtype":"m.text"},"ts":1395200993000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"both of those also return 10 for \" 10\"","msgtype":"m.text"},"ts":1395200997000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"and \"10\" for ' \"10\" '","msgtype":"m.text"},"ts":1395201013000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"Krinkle: of course, if the real definition of JSON is some mysterious superset of what those \"specs\" say, they're pretty worthless as specs","msgtype":"m.text"},"ts":1395201019000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"common sense and simple/lazy implementation","msgtype":"m.text"},"ts":1395201046000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"and I'm sure there's a wide scale of test cases of existing implementations you can plug in to make sure you did it right","msgtype":"m.text"},"ts":1395201080000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"if the specs say whitespace can only lie between tokens and don't allow a newline at the end, that'll break tons of inputs","msgtype":"m.text"},"ts":1395201083000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"(i always output a \\n at the end of JSON, so curl output isn't stupid)","msgtype":"m.text"},"ts":1395201094000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Krinkle: keys in objects, as in, duplicate keys","msgtype":"m.text"},"ts":1395201109000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"if you have to apply liberal common sense and compare against existing implementations to implement JSON because the JSON specs aren't enough, those JSON specs are broken.","msgtype":"m.text"},"ts":1395201127000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"as being the parser, it wouldn't break anything. You'd tolerate more than others if anything, more likely you'd be tolerating what everybody else tolerates.","msgtype":"m.text"},"ts":1395201131000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"being the encoder is slightly more difficult indeed.","msgtype":"m.text"},"ts":1395201144000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"zewt: the json specs being broken is more or less the thesis of my rant tonight, yes.","msgtype":"m.text"},"ts":1395201146000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"JSON.parse('{\"a\": 1, \"a\": 2}').a returns 2 in both chrome and firefox, which is also what I'd expect (parse a key, write it to the dictionary, if it happens to already be in the dictionary overwrite it)","msgtype":"m.text"},"ts":1395201189000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Krinkle: if you need common sense and guessing to fill the holes in a spec, it’s a bad spec","msgtype":"m.text"},"ts":1395201204000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"I'm not saying it's a good spec (I think it's better than most specs and a hell of a lot easier to implement as such), just saying it seems a moot point to doubt over. I think it's interesting to talk about, but if you're unsure what to do in the actual encoding/parser writing, I'd know better.","msgtype":"m.text"},"ts":1395201258000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"the safest route would be to encode as minimal as possible (no whitespace of any kind, and assuming your implementation program language doesn't support dupe keys, that input isn't a problem).","msgtype":"m.text"},"ts":1395201306000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"hardly moot: if the specs are ambiguous or wrong, then they should either be fixed (if whoever's maintaining the spec is willing to fix them, which RFCs seem to have a poor record of) or replaced","msgtype":"m.text"},"ts":1395201311000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"and in the parser, if you encounter a dupe key you can blame the input, garbage in garbage out. throw an error, or silently keep the first or last encounter. Shouldn't matter in practice as I'd consider it invalid input.","msgtype":"m.text"},"ts":1395201441000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"json.org seems more like a description of the file format and not really a spec--it says what the file format looks like, but nothing in precise terms about what to *do* with it. that in mind, the main error seems to be the whitespace issue","msgtype":"m.text"},"ts":1395201455000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Hm.. the spec doesnt' say keys have to be unique. interesting.","msgtype":"m.text"},"ts":1395201460000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"web specs always have to precisely define how \"invalid input\" is handled","msgtype":"m.text"},"ts":1395201479000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"None of the languages listed support that, so it's obviously an oversight (no ambiguity as what the intent was). That should be fixed indeed.","msgtype":"m.text"},"ts":1395201508000,"senderName":"Krinkle","senderId":"Krinkle@irc"},
{"content":{"body":"json.org doesn't (but it doesn't seem to be attempting to be a real spec, so that's probably not a bug)","msgtype":"m.text"},"ts":1395201511000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"I like CSS Syntax’s approach of having non-normative railroad diagrams to get a idea of what the syntax looks like, and precise normative text for implementers","msgtype":"m.text"},"ts":1395202010000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"Krinkle: the RFC says \"SHOULD\", which means it wasn't even an oversight there","msgtype":"m.text"},"ts":1395202374000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"another bug... looks like there's nothing saying that lone surrogates are illegal","msgtype":"m.text"},"ts":1395202426000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(in escapes, i mean)","msgtype":"m.text"},"ts":1395202435000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"interesting, leading zeros in numbers aren't allowed","msgtype":"m.text"},"ts":1395202536000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"pity about the lack of trailing commas","msgtype":"m.text"},"ts":1395202559000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(in objects or arrays)","msgtype":"m.text"},"ts":1395202563000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"they don't seem to be illegal according to chrome/firefox's implementations (but I expect basically zero non-web implementations will, since if you output to UTF-8...)","msgtype":"m.text"},"ts":1395202582000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"also, whoever's responsible for infecting JSON with UTF-16 needs to be exposed and publically shamed","msgtype":"m.text"},"ts":1395202625000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"zewt: that's just from its JS heritage, i guess","msgtype":"m.text"},"ts":1395202692000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"ok. for my purposes, the root can be any value, whitespace is allowed anywhere outside a leaf token, duplicate keys are fatal error invalid, and lone surrogate escapes are fatal error invalid.","msgtype":"m.text"},"ts":1395202796000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"don't know your context, but for general parsing i think duplicate keys shouldn't be a fatal error; take the last seen value","msgtype":"m.text"},"ts":1395202891000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"that seems to be what most implementations land on, intentionally or not (json.loads in Python does the same)","msgtype":"m.text"},"ts":1395202989000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"that seems like a recipe for a security bug","msgtype":"m.text"},"ts":1395203014000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"only if someone has other behavior (like picking the first-seen value), right?","msgtype":"m.text"},"ts":1395203191000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1395203201000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"in particular, if a validator does","msgtype":"m.text"},"ts":1395203217000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"or a serialiser","msgtype":"m.text"},"ts":1395203227000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i guess i could see a streaming parser doing something different (but a streaming parser couldn't enforce unique keys anyway) ... minor since JSON is rarely streamed, but worth mentioning i guess","msgtype":"m.text"},"ts":1395203612000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"huh, no range on numbers, either","msgtype":"m.text"},"ts":1395204067000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"json.loads('9'*100000) gives an exact result in python, heh","msgtype":"m.text"},"ts":1395204175000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"nashorn wtf","msgtype":"m.text"},"ts":1395209268000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Hixie: the last 3 commit emails have an error message","msgtype":"m.text"},"ts":1395218299000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"ooh, maybe the problem is with svn.whatwg.org and not my server","msgtype":"m.text"},"ts":1395221574000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":" /win 4","msgtype":"m.text"},"ts":1395221712000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Hixie: the JSON thing is being fixed","msgtype":"m.text"},"ts":1395224359000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Although I wonder what the difference is between http://tools.ietf.org/html/rfc7158 and http://tools.ietf.org/html/rfc7159","msgtype":"m.text"},"ts":1395224421000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It seems they fixed the date and removed Tim Bray's email address in a <meta> element","msgtype":"m.text"},"ts":1395224643000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"In any event, that RFC matches 404 much closer: http://tools.ietf.org/html/rfc7159#section-2","msgtype":"m.text"},"ts":1395224677000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"As for the SQL definitions in the backscroll: I find neither particularly readable, but then again, I don't know SQL","msgtype":"m.text"},"ts":1395224908000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Is Jeff basically saying power is for sale? https://twitter.com/jeff_jaffe/status/446072553820278785","msgtype":"m.text"},"ts":1395225899000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I don't think it's clear what he's saying","msgtype":"m.text"},"ts":1395226248000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"I think that the problem he's looking at is how much team involvement a given individual member may require","msgtype":"m.text"},"ts":1395226292000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"if it's too high, that would drive the price up","msgtype":"m.text"},"ts":1395226297000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"I'm not sure that's really related to power; I reckon \"power\" is 1) ill-defined in this case and 2) largely orthogonal","msgtype":"m.text"},"ts":1395226322000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"I wonder if there could be an \"Individual College\"","msgtype":"m.text"},"ts":1395226387000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"for every N individual members, there is one seat added to the AC","msgtype":"m.text"},"ts":1395226404000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"and individual members elect representatives to those seats","msgtype":"m.text"},"ts":1395226415000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"I'm not sure that would be of any use, though","msgtype":"m.text"},"ts":1395226421000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"maybe I should join that webizen thing","msgtype":"m.text"},"ts":1395226431000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"sighs","msgtype":"m.emote"},"ts":1395226474000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"there should be a thing where, if you pay extra, you're guaranteed nobody from the team will interfere with your work","msgtype":"m.text"},"ts":1395227518000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Like, Ian Jacobs won't change my specs behind my back?","msgtype":"m.text"},"ts":1395227565000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Well we have that","msgtype":"m.text"},"ts":1395227833000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Except instead of paying extra you pay less","msgtype":"m.text"},"ts":1395227843000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"It's called \"WHATWG\"","msgtype":"m.text"},"ts":1395227849000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Zing","msgtype":"m.text"},"ts":1395227852000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"readies drm.spec.whatwg.org for non-interference-guaranteed work at whatwg","msgtype":"m.emote"},"ts":1395228257000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"whatwg.org/C is out of date again :-(","msgtype":"m.text"},"ts":1395228949000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"MikeSmith: what's that spec supposed to be?","msgtype":"m.text"},"ts":1395232814000,"senderName":"foolip_","senderId":"foolip_@irc"},
{"content":{"body":"april fools?","msgtype":"m.text"},"ts":1395232820000,"senderName":"foolip_","senderId":"foolip_@irc"},
{"content":{"body":"foolip_: hadn't thought it through yet","msgtype":"m.text"},"ts":1395232925000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"jgraham: does wpt-serve support range requests?","msgtype":"m.text"},"ts":1395236003000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"zcorpan: In theory, yes","msgtype":"m.text"},"ts":1395236058000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"I don't know if it works more than the testsuite though","msgtype":"m.text"},"ts":1395236141000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"(that is, there are tests for it but I wouldn't bet my life on the tests or the implementation being correct)","msgtype":"m.text"},"ts":1395236181000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"do you know off-hand of such a test?","msgtype":"m.text"},"ts":1395236255000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"I mean tests in the wptserve testsuite","msgtype":"m.text"},"ts":1395236398000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Although I think I implemented it because some test was implementing a half-assed version of Range in PHP","msgtype":"m.text"},"ts":1395236422000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"All I remember was that it was written by Payman/Joāo","msgtype":"m.text"},"ts":1395236948000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"\"HTTP is now defined by 6, not 2 specs\" :|","msgtype":"m.text"},"ts":1395237625000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"If that isn't Progress I don't know what is","msgtype":"m.text"},"ts":1395237731000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"nothing like splitting one thing into seventy to make it \"easy\" to find stuff","msgtype":"m.text"},"ts":1395237767000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"6>2?","msgtype":"m.text"},"ts":1395237802000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"last i checked","msgtype":"m.text"},"ts":1395238034000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Hixie: the JSON RFC is basically a fork of 404; I would not use it.","msgtype":"m.text"},"ts":1395238452000,"senderName":"Domenic_","senderId":"Domenic_@irc"},
{"content":{"body":"It looks like Jeff Jaffe signed up for twitter just to reply to that tweet?","msgtype":"m.text"},"ts":1395238836000,"senderName":"Domenic_","senderId":"Domenic_@irc"},
{"content":{"body":"Domenic_: that was my impression","msgtype":"m.text"},"ts":1395239324000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"jgraham: that's not how that joke works","msgtype":"m.text"},"ts":1395239363000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hixie: https://www.w3.org/Bugs/Public/show_bug.cgi?id=24860#c12","msgtype":"m.text"},"ts":1395239699000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"good morning, Whatwg!","msgtype":"m.text"},"ts":1395242350000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"wow there really is no difference between 7158 and 7159. weird.","msgtype":"m.text"},"ts":1395246650000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: they just fixed the date","msgtype":"m.text"},"ts":1395246683000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"\"fixed\"?","msgtype":"m.text"},"ts":1395246724000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"there's literally no difference between them, except the second one has errata apparently.","msgtype":"m.text"},"ts":1395246807000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"so let me get this right.","msgtype":"m.text"},"ts":1395246810000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"they'll publish an entirely new rfc just to update the date, but they won't publish an entirely new rfc to fix errors in the content?","msgtype":"m.text"},"ts":1395246825000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i mean it doesn't even really \"fix\" the date, since there's still an rfc with the wrong date out there now.","msgtype":"m.text"},"ts":1395246907000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"correct","msgtype":"m.text"},"ts":1395246931000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"and this new version still doesn't fix the mess around whether values should be unique","msgtype":"m.text"},"ts":1395246964000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"in fact it makes it even more muddled","msgtype":"m.text"},"ts":1395246968000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it's up to the implementation, JavaScript's JSON has last wins iirc","msgtype":"m.text"},"ts":1395247018000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Gotta love a format specifically designed for interchange where \"it's up to the implementation\"","msgtype":"m.text"},"ts":1395247065000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"The RFC was to fix editorial issues, not to make any changes to the format (and making something defined would be a change).","msgtype":"m.text"},"ts":1395247568000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"it did change the format","msgtype":"m.text"},"ts":1395247600000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"quite radically, actually, from the first RFC","msgtype":"m.text"},"ts":1395247611000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"It aligned with ES5 after I and others asked them to do that","msgtype":"m.text"},"ts":1395247824000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"ES6 just defers to 404","msgtype":"m.text"},"ts":1395247846000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"which isn't as well-defined as the RFC","msgtype":"m.text"},"ts":1395247851000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(e.g. it doesn't define the root value, as we were discussing last night)","msgtype":"m.text"},"ts":1395247860000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Yeah, Ecma 404 is what ES5 has","msgtype":"m.text"},"ts":1395247873000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Anything can be root","msgtype":"m.text"},"ts":1395247889000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"it doesn't say that","msgtype":"m.text"},"ts":1395247896000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it actually literally doesn't define the format in the most basic sense","msgtype":"m.text"},"ts":1395247906000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"as far as i can tell","msgtype":"m.text"},"ts":1395247915000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: it says that JSON text is a sequence of code points that conforms to the grammar","msgtype":"m.text"},"ts":1395248001000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1395248011000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"and it doesn't give \"the grammar\"","msgtype":"m.text"},"ts":1395248015000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"\"JSON text is a sequence of tokens formed from Unicode code points that conforms to the JSON value grammar\"","msgtype":"m.text"},"ts":1395248041000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"oh, it says \"the JSON Value grammar\"","msgtype":"m.text"},"ts":1395248044000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"interesting","msgtype":"m.text"},"ts":1395248045000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"seems clear enough","msgtype":"m.text"},"ts":1395248059000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"how did i miss that like 15 times","msgtype":"m.text"},"ts":1395248063000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"weird","msgtype":"m.text"},"ts":1395248066000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Possibly because it has some weirdness about \"Conforming JSON text\" vs \"JSON Text\"","msgtype":"m.text"},"ts":1395248183000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"I actually can't tell if they are supposed to be different","msgtype":"m.text"},"ts":1395248198000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"It looks like maybe \"JSON Text\" is a superset of \"Conforming JSON Text\"","msgtype":"m.text"},"ts":1395248220000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"But \"Conforming JSON Text\" has to \"strictly\" match \"the JSON grammar\", which is undefined","msgtype":"m.text"},"ts":1395248259000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"(\"JSON Text\" merely has to \"conform to\" (not \"strictly\") \"The JSON Value grammar\")","msgtype":"m.text"},"ts":1395248321000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"(but it's hard to tell if \"conforming\" vs \"strictly conforming\" is suspposed to be a substantive difference)","msgtype":"m.text"},"ts":1395248375000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"It isn't really hard to tell, but you could file some bugs for improvement","msgtype":"m.text"},"ts":1395249517000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: you around?","msgtype":"m.text"},"ts":1395249518000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It's hard to tell in the sense that from the ECMA spec I guenuinely don't know","msgtype":"m.text"},"ts":1395249581000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"*genuinely","msgtype":"m.text"},"ts":1395249642000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"The aim of ECMA 404 was to define grammar, not semantics. Which is odd.","msgtype":"m.text"},"ts":1395250090000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"That's always been the goal of JSON though","msgtype":"m.text"},"ts":1395250141000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Not really","msgtype":"m.text"},"ts":1395250168000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"I mean","msgtype":"m.text"},"ts":1395250171000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Implementations do things like rounding on the numbers and such too, which isn't really forbidden either","msgtype":"m.text"},"ts":1395250184000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It was the goal of its creator, unless he changed his mind on the goal midway through","msgtype":"m.text"},"ts":1395250223000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"For a while he didn't even want to define the alphabet in use, until we told him that was a bad idea","msgtype":"m.text"},"ts":1395250253000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"it clearly does define some semantics","msgtype":"m.text"},"ts":1395250273000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"It more or less defines how the numbers work","msgtype":"m.text"},"ts":1395250292000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"in my json parser, [] is an elephant","msgtype":"m.text"},"ts":1395250299000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"a real one","msgtype":"m.text"},"ts":1395250305000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"You would be hard pushed to argue that 10e17 in JSON could be interpreted as 27 or something","msgtype":"m.text"},"ts":1395250333000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Although it doesn't define what + or - means","msgtype":"m.text"},"ts":1395250355000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: sure, but if you don't use decimal storage, are you non-conforming?","msgtype":"m.text"},"ts":1395250372000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Basically istm that Crockford isn't to be trusted with this kind of thing and that JSON has succeeded in spite of him rather than because of him","msgtype":"m.text"},"ts":1395250413000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"So saying \"well the creator wanted X\" doesn't seem like a great argument","msgtype":"m.text"},"ts":1395250437000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"I was talking about goals","msgtype":"m.text"},"ts":1395250470000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"In any event, this doesn't seem like a great use of my time","msgtype":"m.text"},"ts":1395250489000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I highly doubt it was his goal to create a format that couldn't actually be used for interchange reliably","msgtype":"m.text"},"ts":1395250516000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"and if it was his goal seems like one that no one should share","msgtype":"m.text"},"ts":1395250527000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"So either way it seems quite irrelevant","msgtype":"m.text"},"ts":1395250537000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"I think it actually makes sense. It breaks down a bit with generic parsers. But lots of things will be decided at the application layer anyway.","msgtype":"m.text"},"ts":1395250627000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"json succeeded for the same reason xml succeeded (and did better than xml because it is a simpler format than xml)","msgtype":"m.text"},"ts":1395250717000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"the reason is, people have an irrational fear of defining custom core syntaxes","msgtype":"m.text"},"ts":1395250730000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"No","msgtype":"m.text"},"ts":1395250749000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"people think that if you define a vocabulary on top of a core syntax, it's better than defining a vocabulary and a core syntax together","msgtype":"m.text"},"ts":1395250763000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"which confuses me greatly, especially when the formats they use don't really fit the problem space","msgtype":"m.text"},"ts":1395250775000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"It's because having a simple to work with format that has prewritten, predebugged parsers in a range of langauges is a huge win over custom-everything","msgtype":"m.text"},"ts":1395250793000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"It means that you don't have to keep learning people's half-baked formats","msgtype":"m.text"},"ts":1395250824000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"And makes interop simpler","msgtype":"m.text"},"ts":1395250837000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"yeah instead you have to write custom vocabulary interpreters for half-baked vocabularies that you keep having to learn","msgtype":"m.text"},"ts":1395250853000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"and interop fails because neither the syntax nor the vocabulary define error handling","msgtype":"m.text"},"ts":1395250869000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Which is a much easier problem, it turns out, and one that you would have to solve anyway","msgtype":"m.text"},"ts":1395250879000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"how is it easier? it's the same.","msgtype":"m.text"},"ts":1395250890000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"you just change your lexical space from unicode characters to different tokens","msgtype":"m.text"},"ts":1395250918000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Not at all. If I want to interop with, say, the github API I just have to use an off-the-shelf json lib that I have used hundreds of times before and write some simple code to extract the data I care about","msgtype":"m.text"},"ts":1395250945000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"If they had invented GitHub-ON for the purpose I would have to either write a parser or learn their library that I had never used before","msgtype":"m.text"},"ts":1395250989000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"that fails in the same way that people using \"simple code to extract the data\" they care about from HTML fails","msgtype":"m.text"},"ts":1395250990000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"and still write the code to extract the data from the file","msgtype":"m.text"},"ts":1395251003000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"It actually doesn't","msgtype":"m.text"},"ts":1395251015000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"That's why the format has been a success","msgtype":"m.text"},"ts":1395251026000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"In spite of the fact that it's horribly flawed in several ways","msgtype":"m.text"},"ts":1395251041000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"and the people speccing it have managed to make a complete clusterfuck of something that could have been rather straightforward","msgtype":"m.text"},"ts":1395251071000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"i saw somewhere someone was working on a \"JSON5\" which supported more things like comments and unquoted keys","msgtype":"m.text"},"ts":1395251117000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"and trailing commas","msgtype":"m.text"},"ts":1395251130000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"... personally I think JSON+C is exactly the right thing. Except that stupid UTF-16 stuff.","msgtype":"m.text"},"ts":1395253101000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"(But that's what you get for basing it on JS syntax ...)","msgtype":"m.text"},"ts":1395253119000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"annevk: I'm around now.","msgtype":"m.text"},"ts":1395253129000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: any interest in tackling my Selectors questions?","msgtype":"m.text"},"ts":1395253153000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Point me to them?","msgtype":"m.text"},"ts":1395253161000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: emailed www-style","msgtype":"m.text"},"ts":1395253163000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ah, kk.  I'll respond.","msgtype":"m.text"},"ts":1395253170000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"hasn't checked his email yet this morning.","msgtype":"m.emote"},"ts":1395253178000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Basically wondering if I'm invoking the correct hooks and what hooks to use for matches()","msgtype":"m.text"},"ts":1395253196000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hixie: I think it drastically reduces the number of sharp edge cases that need to be dealt with, or at least localizes them a lot better ...","msgtype":"m.text"},"ts":1395253246000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"that's jgraham's position too, i think","msgtype":"m.text"},"ts":1395253273000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i think it just hides them more","msgtype":"m.text"},"ts":1395253278000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"which makes them less likely to be handled","msgtype":"m.text"},"ts":1395253283000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"replicating someone else's buggy parser in another language is not most people's idea of fun","msgtype":"m.text"},"ts":1395253344000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"but replacting someone else's buggy vocabulary interpreter in another language is?","msgtype":"m.text"},"ts":1395253369000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"replicating","msgtype":"m.text"},"ts":1395253374000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"well, many programs don't need to understand the whole vocabulary","msgtype":"m.text"},"ts":1395253388000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"that's the same logic that leads to people writing parsers that don't need to handle the whole syntax","msgtype":"m.text"},"ts":1395253411000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"that's often not possible","msgtype":"m.text"},"ts":1395253425000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"what I mean is that if you are handed a data structure, you don't have to *look* in every nook and cranny; you only need to look in the places relevant to the task at hand","msgtype":"m.text"},"ts":1395253459000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"assuming those places exist. and are the right type. and aren't out of range. and...","msgtype":"m.text"},"ts":1395253498000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"okay, yes, true","msgtype":"m.text"},"ts":1395253519000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"but given that many of these people aren't going to be doing proper error checking ANYWAY ...","msgtype":"m.text"},"ts":1395253603000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"in other news, i've just realised that in json, numbers are special in that they're the one token whose end is determined by look-ahead.","msgtype":"m.text"},"ts":1395253604000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"how annoying.","msgtype":"m.text"},"ts":1395253618000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"what, no lexer?","msgtype":"m.text"},"ts":1395253634000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"?","msgtype":"m.text"},"ts":1395253672000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"... why is this a problem? Are you writing the lexer by hand?","msgtype":"m.text"},"ts":1395253709000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"Hixie: in what environment are you implementing your own JSON parser?","msgtype":"m.text"},"ts":1395253718000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"SamB: yeah","msgtype":"m.text"},"ts":1395253722000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"do you not have a *lex you could use?","msgtype":"m.text"},"ts":1395253750000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"annevk: freepascal. there's lots of existing ones, i just figured it would be fun.","msgtype":"m.text"},"ts":1395253758000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: I see","msgtype":"m.text"},"ts":1395253775000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hixie: are you adding comment support? :-)","msgtype":"m.text"},"ts":1395253783000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hixie: please tell me you're actually implementing JSON+C, yes","msgtype":"m.text"},"ts":1395253790000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: i could use a lexer. i happen to chose not to this time. :-)","msgtype":"m.text"},"ts":1395253809000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"SamB: i'm implementing whatever is needed to parse the tokeniser tests in html5lib's test suite :-)","msgtype":"m.text"},"ts":1395253824000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Oh my","msgtype":"m.text"},"ts":1395253869000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"so why is it that you're using Object Pascal?","msgtype":"m.text"},"ts":1395253876000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"We do touch a fair few bits of edge-cases. :)","msgtype":"m.text"},"ts":1395253879000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: hehe","msgtype":"m.text"},"ts":1395253884000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"This new version of Anolis is going to be built on primitives you implemented yourself Hixie? :-P","msgtype":"m.text"},"ts":1395253886000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"SamB: is best language.","msgtype":"m.text"},"ts":1395253895000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1395253895000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"annevk: yep :-)","msgtype":"m.text"},"ts":1395253902000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"including my own utf-8 decoder :-)","msgtype":"m.text"},"ts":1395253924000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: please make it somewhat clean this time so we can see the source code","msgtype":"m.text"},"ts":1395253973000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hah","msgtype":"m.text"},"ts":1395253989000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i make no promises","msgtype":"m.text"},"ts":1395253992000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"wonders why Object Pascal is so little heard of","msgtype":"m.emote"},"ts":1395254002000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: it was pretty popular on windows for a while (under the name Delphi)","msgtype":"m.text"},"ts":1395254023000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"possibly it has had too many names and too few implementations?","msgtype":"m.text"},"ts":1395254026000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"but yeah, i dunno why it's not more popular","msgtype":"m.text"},"ts":1395254042000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: yes, I know, and it's still used there","msgtype":"m.text"},"ts":1395254052000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"hahaha, json's silly surrogate escape thing triggered my utf-8 system's \"surrogates aren't allowed\" assertion","msgtype":"m.text"},"ts":1395254267000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1395254290000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Hixie: what did you do to cause that?","msgtype":"m.text"},"ts":1395254294000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"Yup, we have lone surrogates in the html5lib tokenizer JSON.","msgtype":"m.text"},"ts":1395254301000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"They're perfectly allowed in JSON :)","msgtype":"m.text"},"ts":1395254307000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"uh","msgtype":"m.text"},"ts":1395254319000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"I mean why is this getting into UTF-8","msgtype":"m.text"},"ts":1395254323000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"gsnedders: eww","msgtype":"m.text"},"ts":1395254331000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: i use utf-8 as my internal representation","msgtype":"m.text"},"ts":1395254336000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"gsnedders: huh","msgtype":"m.text"},"ts":1395254343000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"SamB: We need to test lone surrogates are handled correctly!","msgtype":"m.text"},"ts":1395254346000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Hixie: huh at wha?","msgtype":"m.text"},"ts":1395254349000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"goes to read the spec ...","msgtype":"m.emote"},"ts":1395254356000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"gsnedders: how do you get lone surrogates out of the html parser?","msgtype":"m.text"},"ts":1395254356000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"SamB: the json spec is pretty messed up when it comes to surrogates","msgtype":"m.text"},"ts":1395254374000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: Out of it? We don't. But we have them in the input stream.","msgtype":"m.text"},"ts":1395254378000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: ahhh...","msgtype":"m.text"},"ts":1395254385000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"interesting","msgtype":"m.text"},"ts":1395254386000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"well, my input stream can't support lone surrogates","msgtype":"m.text"},"ts":1395254401000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"so i'm probably ok just skipping those tests","msgtype":"m.text"},"ts":1395254413000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"is there a reason why JSON is ECMA 404?","msgtype":"m.text"},"ts":1395254414000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"i guess i'll turn lone surrogates into FFFD","msgtype":"m.text"},"ts":1395254427000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(in the json parser)","msgtype":"m.text"},"ts":1395254438000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"wants a font where U+FFFD is represented by logo-encoding.svg -- colors and all!","msgtype":"m.emote"},"ts":1395254538000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"hm well that makes unicode escapes into another thing that needs lookahead","msgtype":"m.text"},"ts":1395254538000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: Why are you using utf-8 as the internal representation?  That's an encoding, it's weird to use that internally.  Just use arrays of codepoints.","msgtype":"m.text"},"ts":1395254866000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"what should this show? http://jsbin.com/bubot/1/edit","msgtype":"m.text"},"ts":1395254888000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"TabAtkins: Why would you use arrays of codepoints? That's massively wasteful, esp. if it's mostly ASCII.","msgtype":"m.text"},"ts":1395254908000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"dglazkov: What do you *think* it should show?","msgtype":"m.text"},"ts":1395254919000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"gsnedders: Because it's simpler?  Or use a unicode string, if your language provides that.","msgtype":"m.text"},"ts":1395254938000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ARIAL in arial, INITIAL in times new roman or whatever UA's initial value is?","msgtype":"m.text"},"ts":1395254961000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"Ah, I missed that the initial value is generally a serif font.","msgtype":"m.text"},"ts":1395254995000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"http://jsbin.com/zugojoxa/1/edit?html,output","msgtype":"m.text"},"ts":1395255062000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"This shows the problem a little more clearly - the two \"INITIAL\"s should be the same font.","msgtype":"m.text"},"ts":1395255075000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"annevk: Just to make sure - these are hooks you need for .query() and .matches()?","msgtype":"m.text"},"ts":1395255112000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: I wonder what mozilla/ie do here?","msgtype":"m.text"},"ts":1395255159000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"I'm on ChromeOS, so I can't tell.","msgtype":"m.text"},"ts":1395255196000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"me too :-\\","msgtype":"m.text"},"ts":1395255239000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"TabAtkins: but this is a bug, right?","msgtype":"m.text"},"ts":1395255320000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"Yes.","msgtype":"m.text"},"ts":1395255350000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I'm confused: https://tools.ietf.org/rfcdiff?difftype=--hwdiff&url1=rfc7158&url2=rfc7159","msgtype":"m.text"},"ts":1395255382000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"TabAtkins: because arrays of codepoints take 8 bytes per character and require that the entire input be copied, rather than the input taking 1 byte per character and the data not needing to be copied?","msgtype":"m.text"},"ts":1395255402000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it doesn't seem like there were any changes other than the change in RFC number and in the \"Obsoletes:\" line ...","msgtype":"m.text"},"ts":1395255458000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"Then you have to accept encoding limitations, like the fact that you can't encode a lone surrogate in valid utf-8.","msgtype":"m.text"},"ts":1395255459000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"SamB: Yeah, looks like it.","msgtype":"m.text"},"ts":1395255465000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1395255467000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"i am very happy to accept that limitation :-)","msgtype":"m.text"},"ts":1395255475000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"and the year","msgtype":"m.text"},"ts":1395255477000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"TabAtkins: gecko gets it right","msgtype":"m.text"},"ts":1395255524000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"It's probably something to do with our bizarre parsing of 'font'.","msgtype":"m.text"},"ts":1395255543000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Well, hm, never mind, that still doesn't make sense.","msgtype":"m.text"},"ts":1395255581000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"woot, my json parser found a bug in my test rather than the other way around","msgtype":"m.text"},"ts":1395255615000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"TabAtkins: nah. I found this by code inspection. We just don't do anything sensible there. And I wondered if this was intentional","msgtype":"m.text"},"ts":1395255617000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"(I was wondering if it was parsing as a font named \"inherit\", but that wouldn't help - it would just do fallback, which should produce the default font.)","msgtype":"m.text"},"ts":1395255625000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: we get right to the point where we need to apply property \"initial\", and then we just go \"weeee\" and leave","msgtype":"m.text"},"ts":1395255668000,"senderName":"dglazkov","senderId":"dglazkov@irc"},
{"content":{"body":"Fun.","msgtype":"m.text"},"ts":1395255677000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ouch! http://timelessrepo.com/json-isnt-a-javascript-subset","msgtype":"m.text"},"ts":1395255771000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"oh fun, if I pass difftype=--help to the rfcdiff page, it outputs plaintext as HTML ...","msgtype":"m.text"},"ts":1395256158000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"I mean as text/html","msgtype":"m.text"},"ts":1395256172000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"oh, and otherwise it produces what looks like it's intended to be XHTML labeled as text/html ...","msgtype":"m.text"},"ts":1395256340000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"TabAtkins: I need hooks for querySelector, query, and matches","msgtype":"m.text"},"ts":1395256928000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: querySelector and matches both take an absolute selector afaict","msgtype":"m.text"},"ts":1395256944000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: query takes a relative","msgtype":"m.text"},"ts":1395256950000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"querySelector is an absolute scope-filtered, possibly with a reference set.","msgtype":"m.text"},"ts":1395256972000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"query is relative, definitely with a reference set.","msgtype":"m.text"},"ts":1395257003000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"matches is absolute, definitely with a reference set.","msgtype":"m.text"},"ts":1395257014000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(The only effect of having a reference set is giving meaning to :scope.)","msgtype":"m.text"},"ts":1395257047000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Oh, I thought scoping root was for that","msgtype":"m.text"},"ts":1395257103000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Nope, that's only if you're scoping.","msgtype":"m.text"},"ts":1395257124000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Sorry for the confusing wording, but :scope got named before anything else.","msgtype":"m.text"},"ts":1395257142000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And the scoping root is the default reference set, if you don't specify anything else.","msgtype":"m.text"},"ts":1395257160000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"You generally don't want to scope.  querySelector() does, but really only because it didn't have relative selectors at the time.","msgtype":"m.text"},"ts":1395257201000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"<style scoped> is the only other thing that uses scoping.","msgtype":"m.text"},"ts":1395257208000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"is off to lunch for a bit, will answer any further questions in an hour or so.","msgtype":"m.emote"},"ts":1395257219000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Oh okay. So querySelector using a scoping root is fine.","msgtype":"m.text"},"ts":1395257233000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"However, matches should use a reference set so no scoping is done","msgtype":"m.text"},"ts":1395257257000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"relative selectors?","msgtype":"m.text"},"ts":1395257300000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"hmm, well, ECMA 404 doesn't say you can have unpaired surrogates in your JSON","msgtype":"m.text"},"ts":1395257430000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"Okay, I should look at this again tomorrow, thanks for the pointers so far TabAtkins","msgtype":"m.text"},"ts":1395257443000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"TabAtkins: I do find it a bit odd that you have API hooks for selectors separate from the general selector matching (where is the algorithm for that? and why is it not linked from the API hooks section?)","msgtype":"m.text"},"ts":1395257475000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wonders what Haskell does if you have surrogates in your Strings masquerading as Chars","msgtype":"m.emote"},"ts":1395257633000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"Is there any sane way to find a font that contains a given Unicode codepoint on OS X?","msgtype":"m.text"},"ts":1395257778000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Like, I blatantly have one as it manages to font-switch in places for it.","msgtype":"m.text"},"ts":1395257790000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"But I can't tell what font it comes from","msgtype":"m.text"},"ts":1395257797000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"SamB: It'll allow them, because Char is just an integral type, of range 0–0x10FFFF","msgtype":"m.text"},"ts":1395260625000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"yeah that's basically what i did too, except that i have an operator overload for assignment that checks for surrogates :-)","msgtype":"m.text"},"ts":1395261187000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(and i allow -1 to mean eof)","msgtype":"m.text"},"ts":1395261195000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"SamB: http://dev.w3.org/csswg/selectors/#relative","msgtype":"m.text"},"ts":1395261208000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"You need a type system with dependent types to allow only matched surrogates","msgtype":"m.text"},"ts":1395261261000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"uh no, i want no surrogates :-)","msgtype":"m.text"},"ts":1395261275000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"That's easy :P","msgtype":"m.text"},"ts":1395261359000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"annevk: is there anything in particular i need to do on https://www.w3.org/Bugs/Public/show_bug.cgi?id=24810 or did you reassign to me just so i could look it over? (it looks good)","msgtype":"m.text"},"ts":1395261547000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: I assigned it to you so you could remove the bits in HTML","msgtype":"m.text"},"ts":1395261577000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hixie: e.g. scripting environment is no longer a thing DOM has now or needs HTML to define so you can remove that","msgtype":"m.text"},"ts":1395261601000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hixie: and under microtask checkpoint there's a bit of cleanup you can do","msgtype":"m.text"},"ts":1395261620000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"aaah right","msgtype":"m.text"},"ts":1395261638000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"cool","msgtype":"m.text"},"ts":1395261639000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1395261640000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"gsnedders: Char is not *quite* an integral type, but yeah, I guess it has allow them given the way Enum works ...","msgtype":"m.text"},"ts":1395264156000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"and Bounded","msgtype":"m.text"},"ts":1395264175000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: Okay, it's not an integral type, but it has a 1:1 mapping to one","msgtype":"m.text"},"ts":1395264410000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"back to JSON, RFC 715[89] also doesn't permit unpaired surrogates, but in section 8.2 warns that they have been seen in the wild and that the behaviour of software encountering them is unpredictable","msgtype":"m.text"},"ts":1395264504000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"https://tools.ietf.org/html/rfc7159#section-8.2","msgtype":"m.text"},"ts":1395264537000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"Oooh! That's a change!","msgtype":"m.text"},"ts":1395264575000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Hmm, that section says that it does permit unpaired surrogates","msgtype":"m.text"},"ts":1395267163000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"It just says that the behaviour of unpaired surrogates is undefined","msgtype":"m.text"},"ts":1395267195000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"i'd sooner have it defined as outputting FFFE than being a parse error","msgtype":"m.text"},"ts":1395267271000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"The whole thing is pretty woeful","msgtype":"m.text"},"ts":1395267329000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"so if some API client inputs a string from a user in a UTF-16 env, and the user pastes in a string with a broken surrogate, it doesn't become a server-side error later","msgtype":"m.text"},"ts":1395267335000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"You are kind of expected to guess how string escapes work","msgtype":"m.text"},"ts":1395267348000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"eg. i'd rather there be no possible invalid user inputs as a string, even if it means some (invalid surrogates) not round-tripping through some paths","msgtype":"m.text"},"ts":1395267375000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"zewt: AFAICT the spec simply fails to define how strings are interpreted at all","msgtype":"m.text"},"ts":1395267417000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"sure, i'm just saying how i'd prefer it","msgtype":"m.text"},"ts":1395267429000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"I agree that fatal errors aren't great","msgtype":"m.text"},"ts":1395267454000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"in practice that may be unlikely: most JSON encoders I've used just output UTF-8 for everything and never use \\u escapes anyway","msgtype":"m.text"},"ts":1395267472000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"(or in the case of JS, outputs UTF-16 codepoints that get encoded to UTF-8 later)","msgtype":"m.text"},"ts":1395267518000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"gsnedders: well, I mean, the ABNF doesn't rule them out, but there are no semantics given for them in the prose","msgtype":"m.text"},"ts":1395268316000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"what was that April 1 RFC with the, er, disillusioned definitions for keywords?","msgtype":"m.text"},"ts":1395268501000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"jgraham: What do you want to do with serializer tests for html5lib, BTW?","msgtype":"m.text"},"ts":1395268669000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"jgraham: Given they depend upon so many serialization options, and there are infinitely many valid serializations…","msgtype":"m.text"},"ts":1395268700000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: I don't think I have a strong opinion. It makes sense to have *some* tests for html5lib itself","msgtype":"m.text"},"ts":1395270269000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"I'm not sure that they are worth sharing with other projects though","msgtype":"m.text"},"ts":1395270285000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"SamB: 6919","msgtype":"m.text"},"ts":1395270621000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"jgraham: could you test round-tripping rather than exact serializations?","msgtype":"m.text"},"ts":1395270677000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: Yes, though obviously some tests must test exact serializations","msgtype":"m.text"},"ts":1395270919000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"does anyone here know anything about MSE?","msgtype":"m.text"},"ts":1395270931000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"(https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html)","msgtype":"m.text"},"ts":1395270937000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"SimonSapin: Also note not everything round-trips","msgtype":"m.text"},"ts":1395270993000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: why, and why?","msgtype":"m.text"},"ts":1395271003000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: e.g., We need to make sure serialization of attribute values doesn't expose XSS bugs in old IE","msgtype":"m.text"},"ts":1395271041000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"SimonSapin: and e.g., (XML) <table><tr><td>foo","msgtype":"m.text"},"ts":1395271053000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"SimonSapin: (a tree with no tbody)","msgtype":"m.text"},"ts":1395271064000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: but parse+serialize+parse should still be the same as parse, right?","msgtype":"m.text"},"ts":1395271098000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: No. Well, there is obviously *a* serialization, but some parse errors create odd trees.","msgtype":"m.text"},"ts":1395271159000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"SimonSapin: Like foster parenting can cause odd things","msgtype":"m.text"},"ts":1395271168000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"isn’t serialize+parse idempotent?","msgtype":"m.text"},"ts":1395271187000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"(*not* parse+serialize)","msgtype":"m.text"},"ts":1395271209000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: Given parse+serialize+parse, \"<p><table><p>\" is hard to handle.","msgtype":"m.text"},"ts":1395271220000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"SimonSapin: Because it's serialization isn't at all obvious from the tree it produces.","msgtype":"m.text"},"ts":1395271233000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"*its","msgtype":"m.text"},"ts":1395271238000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"I don’t see the problem","msgtype":"m.text"},"ts":1395271250000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"At the moment we only try to serialize trees that a conforming input can create. i.e., not ones like that","msgtype":"m.text"},"ts":1395271289000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"hmm, you would certainly think that given a just-parsed document, serialize|parse would be idempotent","msgtype":"m.text"},"ts":1395271291000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SamB: yes, that’s what I mean","msgtype":"m.text"},"ts":1395271311000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"is that not the case for HTML?","msgtype":"m.text"},"ts":1395271317000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"It is.","msgtype":"m.text"},"ts":1395271321000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"It's just the serialize case gets exceptionally hard if you want to make it complete.","msgtype":"m.text"},"ts":1395271331000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Like, for <p><table><p> you have to go from an XML infoset like <p><p/><table/></p> to having the second p appear within the table.","msgtype":"m.text"},"ts":1395271371000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Because you can't serialize that tree as <p><p><table></table></p></p> in HTML.","msgtype":"m.text"},"ts":1395271398000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: do you mean that only testing idempotency it not that useful because you can make a serializer that’s idempotent bug wrong? (e.g always return the empty string)","msgtype":"m.text"},"ts":1395271404000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"SimonSapin: that wouldn't make serialize|parse idempotent","msgtype":"m.text"},"ts":1395271425000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"SimonSapin: No, I mean it's impractically hard to do.","msgtype":"m.text"},"ts":1395271428000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"SimonSapin: Because a serializer that's idempotent is really complex to handle cases like (XML) <p><p/><table/></p>","msgtype":"m.text"},"ts":1395271459000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"SimonSapin: I played about with taking all parser tests and checking serializerparser","msgtype":"m.text"},"ts":1395271505000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"so what was the goal again?","msgtype":"m.text"},"ts":1395271525000,"senderName":"SamB","senderId":"SamB@irc"},
{"content":{"body":"The goal is to improve the current testing situation of html5lib's serializer. Which current relies on shared tests in html5lib-tests dependent upon serialization choice.","msgtype":"m.text"},"ts":1395271559000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"https://gist.github.com/gsnedders/9653913 is what currently fails to roundtrip with html5lib. Some (e.g., the script stuff) are obviously bugs.","msgtype":"m.text"},"ts":1395272033000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"<p><b><i><u></p>\\n<p>X is gonna be very hard to serialize correctly","msgtype":"m.text"},"ts":1395272093000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"why?","msgtype":"m.text"},"ts":1395272109000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Well, \"<p><b><i><u></u></i></b></p><b><i><u>\\n<p>X</u></i></b>\" doesn't correspond to the same thing, despite being the obvious serialization of the tree","msgtype":"m.text"},"ts":1395272256000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Or rather, the logic for when you omit the p closing tag is complicated.","msgtype":"m.text"},"ts":1395272300000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1395272306000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Okay, maybe that isn't as bad.","msgtype":"m.text"},"ts":1395272316000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"i would just never omit closing tags","msgtype":"m.text"},"ts":1395272318000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":":-D","msgtype":"m.text"},"ts":1395272324000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"I thought that was the weird case where AAA stuff made it horrible.","msgtype":"m.text"},"ts":1395272337000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"idk.","msgtype":"m.text"},"ts":1395272338000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"I don't have time for this.","msgtype":"m.text"},"ts":1395272341000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1395272341000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"This isn't my dissertation. :)","msgtype":"m.text"},"ts":1395272348000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Hixie: Though that does mean the informative description of when p end tags can be omitted in the spec is wrong :)","msgtype":"m.text"},"ts":1395272509000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Or is Writing HTML Documents normative?","msgtype":"m.text"},"ts":1395272538000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"It appears to be normative for documents, authoring tools, and markup generators.","msgtype":"m.text"},"ts":1395272557000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"In which case the normative description is wrong :)","msgtype":"m.text"},"ts":1395272566000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"gsnedders: it's not wrong. it just doesn't handle non-conforming cases since those cases are already non-conforming.","msgtype":"m.text"},"ts":1395273177000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"gsnedders: if a tool outputs <b><p> then it's bogus regardless of where it closes the </b>","msgtype":"m.text"},"ts":1395273202000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Bah!","msgtype":"m.text"},"ts":1395273215000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"i'm just sayin'","msgtype":"m.text"},"ts":1395273229000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"See, this is what makes serialize|parse idempotency hard!","msgtype":"m.text"},"ts":1395273244000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Like, sure, yeah, obviously any tree the parser creates *can* be serialized.","msgtype":"m.text"},"ts":1395273261000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"should just reguse to serialise anything that's non-conforming","msgtype":"m.text"},"ts":1395273268000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"refuse","msgtype":"m.text"},"ts":1395273269000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"To what degree on non-conformity?","msgtype":"m.text"},"ts":1395273286000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"*of","msgtype":"m.text"},"ts":1395273289000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"human-checked!","msgtype":"m.text"},"ts":1395273293000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":":-D","msgtype":"m.text"},"ts":1395273294000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1395273297000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Do we allow unknown elements? Because their parse-model could change!","msgtype":"m.text"},"ts":1395273312000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"(or, document your tool as requiring conforming input, and if it's given non-conforming input, say that the output could be garbage.)","msgtype":"m.text"},"ts":1395273325000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Yeah, that's the sensible approach. :)","msgtype":"m.text"},"ts":1395273351000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"I originally did this just because I wanted to see how hard it'd be to guarantee serializer||parser idempotency given a tree from the parser. Because if it was easy then we could trivially get way more tests. :)","msgtype":"m.text"},"ts":1395273383000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"There's no schema representing all the content model restrictions, is there?","msgtype":"m.text"},"ts":1395273428000,"senderName":"gsnedders","senderId":"gsnedders@irc"}
]