[
{"content":{"body":"quick WebIDL question: is there an easy way to mark an attribute as non-configurable (other than [LegacyUnforgeable], which does that + more)?","msgtype":"m.text"},"ts":1602482332000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"annevk: are we doing only TPAC breakout sessions, or a \"WG\" meeting this week?","msgtype":"m.text"},"ts":1602488611000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"mathiasbynens: per https://heycam.github.io/webidl/#define-the-attributes attributes are only non-configurable if they're LegacyUnforgeable","msgtype":"m.text"},"ts":1602488812000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"mathiasbynens: but constants are also non-configurable","msgtype":"m.text"},"ts":1602488821000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: I was afraid of that. thanks for confirming","msgtype":"m.text"},"ts":1602488854000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"mathiasbynens: whare are you trying to do?","msgtype":"m.text"},"ts":1602488904000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"zcorpan_: `navigator.webdriver` is currently configurable, and so spammers using WebDriver/Puppeteer like to `delete` it to try and bypass protections","msgtype":"m.text"},"ts":1602489097000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"zcorpan_: all it takes to fix this is to mark it non-configurable, and I was wondering if there was a way to do that directly, since LegacyUnforgeable does more (in particular, it moves it from the prototype to an own property)","msgtype":"m.text"},"ts":1602489140000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"mathiasbynens: hmmm. navigator itself isn't LegacyUnforgeable","msgtype":"m.text"},"ts":1602489344000,"senderName":"zcorpan_","senderId":"zcorpan_@irc"},
{"content":{"body":"annevk: Just checking to see if pr-preview is stable for you since the changes I made last week (I have no signs that it isnâ€™t; just wanted to make sure youâ€™re all good).","msgtype":"m.text"},"ts":1602490670000,"senderName":"tobie","senderId":"tobie@irc"},
{"content":{"body":"tobie: I think so, yes, but I'll ping you if not ðŸ™‚","msgtype":"m.text"},"ts":1602495903000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"tobie: thanks for looking into it","msgtype":"m.text"},"ts":1602495910000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"does AVIF need an entry on https://mimesniff.spec.whatwg.org/#matching-an-image-type-pattern or not?","msgtype":"m.text"},"ts":1602506723000,"senderName":"mathiasbynens","senderId":"mathiasbynens@irc"},
{"content":{"body":"mathiasbynens: afaik it's mp4","msgtype":"m.text"},"ts":1602506957000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"mathiasbynens: or at least an existing container thingy","msgtype":"m.text"},"ts":1602506981000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"mathiasbynens: hmm, but maybe that does mean that should be updated as that only covers images","msgtype":"m.text"},"ts":1602507026000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"mathiasbynens: I had only considered it from the perspective of https://github.com/annevk/orb","msgtype":"m.text"},"ts":1602507047000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wonders if that's enough reason to still try to require a MIME type","msgtype":"m.emote"},"ts":1602507070000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Anyone knows if ES is parsable by LR(1) parser?","msgtype":"m.text"},"ts":1602510700000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"jorendorff: ^","msgtype":"m.text"},"ts":1602511002000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"croraf: You have to use lots of force to jam ES into an LR(1) form","msgtype":"m.text"},"ts":1602511115000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"please see https://github.com/mozilla-spidermonkey/jsparagus/blob/master/js-quirks.md","msgtype":"m.text"},"ts":1602511120000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"if you don't want to read all that, then the answer is no for you :)","msgtype":"m.text"},"ts":1602511138000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"thanks jorendorff , i also put the same quesiton on jsparagus discord :)","msgtype":"m.text"},"ts":1602511155000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"haha","msgtype":"m.text"},"ts":1602511167000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"So in short, does JSparagus use LR(1) or some other type? And which one would you recommend now to use?","msgtype":"m.text"},"ts":1602511241000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"jorendorff,  I remember these quirks being a lot shorter last time i checked half a year ago :|","msgtype":"m.text"},"ts":1602511431000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"croraf: it depends on the goal. if you want a complete JS parser e.g. for writing a standard-compliant JS engine, then","msgtype":"m.text"},"ts":1602511502000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"by far the easiest thing that will work is recursive descent","msgtype":"m.text"},"ts":1602511507000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"this will have bad performance? jorendorff","msgtype":"m.text"},"ts":1602511617000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"Recursive descent can have good performance because it's extremely hackable","msgtype":"m.text"},"ts":1602511647000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"If you write the dumbest thing that can possibly work, then the performance is so-so","msgtype":"m.text"},"ts":1602511661000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"but it's easy to hack in some optimizations to make it a bit faster, and then a bit faster again...","msgtype":"m.text"},"ts":1602511699000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"jorendorff, thanks a lot. I think in Boa we actually use recursive descent.","msgtype":"m.text"},"ts":1602511837000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"Yes, I think so","msgtype":"m.text"},"ts":1602511846000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"I think all the major JS implementations do. jsparagus was trying something outside the mainstream :)","msgtype":"m.text"},"ts":1602511886000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"cool, jorendorff you are the best ;)","msgtype":"m.text"},"ts":1602511939000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"blushes.","msgtype":"m.emote"},"ts":1602511952000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"jorendorff, Was this the case of putting something in the editorial version of the spec that was not LR(1) compliant that was then immediately removed from the spec? https://github.com/tc39/ecma262/issues/776","msgtype":"m.text"},"ts":1602512302000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"The `async of` conflict is separate. As far as I know it was never discussed in the standard committee and hasn't been removed.","msgtype":"m.text"},"ts":1602512392000,"senderName":"jorendorff","senderId":"jorendorff@irc"},
{"content":{"body":"jorendorff, yes, I'm not talking about \"async of\" example but mentioning this as another similar example that was revoked?","msgtype":"m.text"},"ts":1602512562000,"senderName":"croraf","senderId":"croraf@irc"},
{"content":{"body":"Yes, that's right","msgtype":"m.text"},"ts":1602512599000,"senderName":"jorendorff","senderId":"jorendorff@irc"}
]