[
{"content":{"body":"ok, back, although i should probably head out for the day","msgtype":"m.text"},"ts":1428452123000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: you should go home","msgtype":"m.text"},"ts":1428452164000,"senderName":"terinjokes","senderId":"terinjokes@irc"},
{"content":{"body":"this Promise.resolve analogy soothes me greatly","msgtype":"m.text"},"ts":1428452164000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"(in general any time I can analogy to promises, I feel more confident)","msgtype":"m.text"},"ts":1428452179000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"we can let pipeTo only accept true WritableStreams, and if in the future that becomes limiting we can add WritableStream.cast or similar as a mechanism for coping","msgtype":"m.text"},"ts":1428452243000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: https://github.com/whatwg/streams/issues/321","msgtype":"m.text"},"ts":1428452678000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"have a good night!","msgtype":"m.text"},"ts":1428452682000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: https://github.com/slightlyoff/ServiceWorker/issues/607#issuecomment-90819078 - I don't understand \"wait withÂ overrideRequestURL\"","msgtype":"m.text"},"ts":1428475026000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: just not implement it","msgtype":"m.text"},"ts":1428476005000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: what you argue for would be a new special case that did not exist before; the case the implementers brought up was not considered when we figured it as a shorthand for short-circuiting redirects","msgtype":"m.text"},"ts":1428476094000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: we've got some internal customers for this, I'll find out if the API works for them. But yeah, in that case it isn't exactly like a redirect.","msgtype":"m.text"},"ts":1428476302000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: it would be interesting to hear why they can't use Response.redirect()","msgtype":"m.text"},"ts":1428476336000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yeah, I'm digging into that and building them an example","msgtype":"m.text"},"ts":1428476713000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Is anyone using https://atom.io/?","msgtype":"m.text"},"ts":1428480051000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I think the general situation is that Content-Type is ignored for both media elements and <track>","msgtype":"m.text"},"ts":1428482494000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"there's a bit of a history, but since Microsoft caved and started ignoring it in IE I think there's no turning back (which I'm happy about)","msgtype":"m.text"},"ts":1428482527000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: so for X-Content-Type-Options: nosniff we want to give server administrators the feature of enforcing Content-Type for resources so they can't be used in an unexpected context","msgtype":"m.text"},"ts":1428482562000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: this requires a whitelist of MIME types for audio/video and a separate set for track","msgtype":"m.text"},"ts":1428482589000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"uh, ok, I couldn't say how that currently works","msgtype":"m.text"},"ts":1428482597000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: it doesn't for those contexts","msgtype":"m.text"},"ts":1428482650000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: well, it might in IE","msgtype":"m.text"},"ts":1428482656000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I haven't tested IE yet","msgtype":"m.text"},"ts":1428482659000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"for <track> there's just no code that looks at Content-Type, at least not in Blink, if it's not WebVTT then it won't work","msgtype":"m.text"},"ts":1428482672000,"senderName":"philipj","senderId":"philipj@irc"},
{"content":{"body":"philipj: okay, so we could just make the whitelist text/webvtt","msgtype":"m.text"},"ts":1428485592000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: for CSS it's text/css at the moment","msgtype":"m.text"},"ts":1428485599000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: only unclear thing then is the MIME types for audio/video which is somewhat of a trainwreck","msgtype":"m.text"},"ts":1428485630000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"text/vtt*","msgtype":"m.text"},"ts":1428486347000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"http://w3cdreams.tumblr.com/","msgtype":"m.text"},"ts":1428487033000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Wow, well I was enjoying that and then the Service Worker thing guenuninely made me feel ill","msgtype":"m.text"},"ts":1428487271000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: hypno cat?","msgtype":"m.text"},"ts":1428487845000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Possibly","msgtype":"m.text"},"ts":1428487959000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Also made me unable to spell genuinely","msgtype":"m.text"},"ts":1428487985000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"just need to let the eyes follow the circles a few laps and then you'll feel better again","msgtype":"m.text"},"ts":1428488224000,"senderName":"zcorpan","senderId":"zcorpan@irc"},
{"content":{"body":"Domenic: you said there were user space Promise libs that were faster than browser implementations... can you point me at one you recommend for perf?","msgtype":"m.text"},"ts":1428504744000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: bluebird","msgtype":"m.text"},"ts":1428504772000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yep","msgtype":"m.text"},"ts":1428504779000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: should I just be able to drop this in with the stream reference impl?","msgtype":"m.text"},"ts":1428504965000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: ugh, the reference impl is so un-optimized...","msgtype":"m.text"},"ts":1428505039000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: but, yeah, if you do global.Promise = require('bluebird') it should be drop-in-able","msgtype":"m.text"},"ts":1428505058000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"But I mean, all the asserts (in loops too!) and try/catches and the hilarious queue-with-sizes implementation will dwarf the performance change I think","msgtype":"m.text"},"ts":1428505091000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: meeting now... but I'll try to describe the case I'm concerned with... I can write something not use ref impl, but just something similar to tease out the Promise impact","msgtype":"m.text"},"ts":1428505300000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: OK cool. Be sure it does actual I/O too :)","msgtype":"m.text"},"ts":1428505434000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: javascript consumers may not do actual I/O","msgtype":"m.text"},"ts":1428505457000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Ultimately the stream should be grounded in some I/O, most likely","msgtype":"m.text"},"ts":1428505550000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"E.g. maybe your stream vends JS objects but it's derived from some stream that read from a file/network","msgtype":"m.text"},"ts":1428505569000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: is it not reasonable for js to do in-memory operations like your stream demo where its searching for a particular value?  that is not I/O related","msgtype":"m.text"},"ts":1428507408000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: how is that no I/O related?","msgtype":"m.text"},"ts":1428507418000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: the stream is a fetch stream","msgtype":"m.text"},"ts":1428507429000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I thought you meant on the consumption side you wanted it to be I/O","msgtype":"m.text"},"ts":1428507455000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: oh, no, i just meant that each promise produced from the reader should correspond to doing some I/O","msgtype":"m.text"},"ts":1428507471000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i.e., don't test for (let i = 0; i < 1000; ++i) { Promise.resolve(5).then(foo); }; test for (let i = 0; i < 1000; ++i) { fs.read(fd, ...).then(foo); })","msgtype":"m.text"},"ts":1428507539000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the main case I can think of that concerns me is where you write data to a pipe buffer... and then want to read it starting at some later time... in that case the pipe .read() is not related to I/O until the buffer is drained... and draining the buffer will be much slower than with sync .read()","msgtype":"m.text"},"ts":1428507544000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"\"much\" slower citation needed... especially since sync read() would need to use async .ready or similar for backpressure signals","msgtype":"m.text"},"ts":1428507579000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: thats why I want to test with real Promises :-)","msgtype":"m.text"},"ts":1428507594000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"sounds good :)","msgtype":"m.text"},"ts":1428507602000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I agree at least one async operation is needed... but doing it on every buffered chunk seems potentially not good","msgtype":"m.text"},"ts":1428507619000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: I'm going to put this in the batch read issue... I think some kind of .readAllAvailable() would solve this... give me an array of all available chunks... so you get an array of length 1 or greater","msgtype":"m.text"},"ts":1428507690000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"for cases where you just want to read as fast as possible","msgtype":"m.text"},"ts":1428507708000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: sounds good, yeah. Or 0 chunks if end of stream.","msgtype":"m.text"},"ts":1428507712000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess my concern here started by looking at the current rs.pipeTo() implementation... since it waits for each .read() to resolve before calling .read() again... you can't get any pipelining going that way... and then I started to wonder if it should do two .read() calls... so while its writing the first its already started the async process to get","msgtype":"m.text"},"ts":1428508353000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"the next, etc","msgtype":"m.text"},"ts":1428508354000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: right, but that should only delay at most a microtask, and then it will resolve and immediately call read() again, and the stack only has to unwind one frame since we're already in the microtask loop... it's one extra frame per loop iteration basically.","msgtype":"m.text"},"ts":1428508413000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: I've been thinking about cache.add[All]. I've been seeing a lot of examples check the status code of responses before putting them into the cache. Maybe we should revisit the idea of checking response.ok before caching (as an option). This would of course fail on all opaque responses. Do you think it's still useful?","msgtype":"m.text"},"ts":1428508975000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: in a meeting","msgtype":"m.text"},"ts":1428509148000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"no rush","msgtype":"m.text"},"ts":1428509155000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: should it not be added to fetch() then?","msgtype":"m.text"},"ts":1428512811000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: that sounds fine to me... I don't really have an opinion... whatever developers want/expect","msgtype":"m.text"},"ts":1428513307000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"not sure I understand the opaque response thing, though","msgtype":"m.text"},"ts":1428513321000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: the post-ES6 specification plan sounds rather lovely","msgtype":"m.text"},"ts":1428513335000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1428513346000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"we'll see if we can pull it off...","msgtype":"m.text"},"ts":1428513351000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I wonder if WHATWG can gradually convert to that as well","msgtype":"m.text"},"ts":1428513365000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"what plan?","msgtype":"m.text"},"ts":1428513375000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: https://esdiscuss.org/topic/the-great-tooling-revolution","msgtype":"m.text"},"ts":1428513390000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: you mean the two-impls thing?","msgtype":"m.text"},"ts":1428513493000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the tooling and writing style","msgtype":"m.text"},"ts":1428513509000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ah interesting.","msgtype":"m.text"},"ts":1428513523000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"having said that, ES6 is rather hard to digest, but some of the algorithm shorthands you're introducing seem nice","msgtype":"m.text"},"ts":1428513572000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah, I was going to say, \"Ecmaspeak\"'s evolution into something more user-friendly is still in progress (cf. https://streams.spec.whatwg.org/#conventions)","msgtype":"m.text"},"ts":1428513583000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And it's unclear the value of Ecmaspeak vs. some kind of \"spec ES\"","msgtype":"m.text"},"ts":1428513594000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: what does chrome's shipping Response body stream do for a Response returned from cache.match()?  does it stream from disk?","msgtype":"m.text"},"ts":1428513609000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: good... question...... tyoshino are you awake perchance?","msgtype":"m.text"},"ts":1428513632000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I mean... is that implemented in this first version","msgtype":"m.text"},"ts":1428513637000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"oh hi yhirano_ is in here too","msgtype":"m.text"},"ts":1428513650000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Maybe the thing to do is ask on the blink-dev Intent to Ship thread?","msgtype":"m.text"},"ts":1428513689000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: ok, will do... mainly just curious","msgtype":"m.text"},"ts":1428514038000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: what is WritableStream.getWriter() you to mention in that issue update?  I don;t see that in the spec","msgtype":"m.text"},"ts":1428514106000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: https://github.com/whatwg/streams/issues/319 :-S","msgtype":"m.text"},"ts":1428515998000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ok... so not spec'd yet","msgtype":"m.text"},"ts":1428516033000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wasn't sure if it was coming or previous-and-gone","msgtype":"m.text"},"ts":1428516041000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"heh... yeah","msgtype":"m.text"},"ts":1428516064000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: related https://github.com/whatwg/streams/commit/d757e05cf27f73488d13825e51ce5706a759ab27","msgtype":"m.text"},"ts":1428516075000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I didn't want to bikeshed more in the \"getReader is named poorly\" issue... but take() is also widely used for locking concepts :-)","msgtype":"m.text"},"ts":1428516291000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"meeeeeeeeeeehhhhhh","msgtype":"m.text"},"ts":1428516581000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: getReader() does not unlock if the reader gets GC'd right?  or rather, the whole stream has to be GC'd in addition to the reader?","msgtype":"m.text"},"ts":1428516752000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: right. (and in the latter case i'm not sure there's a difference.)","msgtype":"m.text"},"ts":1428516768000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: webkit has a test showing this","msgtype":"m.text"},"ts":1428516778000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"unsure how/whether to put it in the general suite...","msgtype":"m.text"},"ts":1428516795000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I really dislike stuff with explicit release like revokeObjectUrl()...  so many leaks in code that use them... the error paths are atrocious","msgtype":"m.text"},"ts":1428516838000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"from my experience with code in fxos trying to use that kind of API","msgtype":"m.text"},"ts":1428516867000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: well this case is pretty different, since it's not like you could successfully get another reader by waiting for GC of the first one, since that's unreliable","msgtype":"m.text"},"ts":1428516884000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"that's a fair argument for the lifecycle management thread though","msgtype":"m.text"},"ts":1428516900000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yea","msgtype":"m.text"},"ts":1428516901000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I think I mentioned it there","msgtype":"m.text"},"ts":1428516909000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: is there a finally thing on promises for people to always return the reader?","msgtype":"m.text"},"ts":1428516987000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"maybe that makes it less of a problem","msgtype":"m.text"},"ts":1428516994000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: we've been wanting to add finally to promises for a long time, and this cancelable promise stuff might push it over the line.","msgtype":"m.text"},"ts":1428517060000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess its not a huge problem here... since lock is released automatically on close","msgtype":"m.text"},"ts":1428517155000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"its optimized for single reader case... which is what we want","msgtype":"m.text"},"ts":1428517168000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah, that's kind of the idea. if anyone's doing something tricky like parsing a header portion then passing the partially-read stream on to someone else, they can probably remember to release the lock. Although I agree finally would be nice.","msgtype":"m.text"},"ts":1428517475000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: that seems like something easier down with pipeThrough()... although it would be nice to remove the header transform piece after its done","msgtype":"m.text"},"ts":1428517533000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hmm yeah that's true","msgtype":"m.text"},"ts":1428517555000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"^down^done","msgtype":"m.text"},"ts":1428517572000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"i guess most uses of readers are hidden behind the higher-level methods like pipe*() and tee()","msgtype":"m.text"},"ts":1428517576000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"sorry, I just fell and I don't know if you read what I said but","msgtype":"m.text"},"ts":1428518534000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"wanderview: I have a pull request with that test","msgtype":"m.text"},"ts":1428518541000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"all custom tests that we had for WK are now there and waiting for Domenic to merge them","msgtype":"m.text"},"ts":1428518546000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"calvaris: which test?","msgtype":"m.text"},"ts":1428518591000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"the one for the garbage collection regarding the reader","msgtype":"m.text"},"ts":1428518654000,"senderName":"calvaris","senderId":"calvaris@irc"},
{"content":{"body":"Domenic: btw, we apparently do implement microtask queue in gecko now","msgtype":"m.text"},"ts":1428518654000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"calvaris: ah, cool","msgtype":"m.text"},"ts":1428518671000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: ah that's excellent","msgtype":"m.text"},"ts":1428518713000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I still don't think our c++ can optimize around them, though... since js can call into c++ with js still on the stack","msgtype":"m.text"},"ts":1428518744000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: \"Cheaper than I/O\" doesn't say a lot and Promise instantiation speed isn't the only thing to consider. It's the complete time from .push() to .read().","msgtype":"m.text"},"ts":1428523140000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"Domenic: what does it mean for a ReadableStream to .pipeTo() a WritableByteStream... what if the RS produces non-byte things?","msgtype":"m.text"},"ts":1428528198000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: calling .write() (or the equivalent internal operation if we move to that model) will error, causing the pipe to error.","msgtype":"m.text"},"ts":1428528233000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: but if the ReadableStream passes Uint8Array chunks, then its ok?","msgtype":"m.text"},"ts":1428528286000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yes, I would really like that to work","msgtype":"m.text"},"ts":1428528295000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: maybe allow any of the \"BufferView\" types","msgtype":"m.text"},"ts":1428528309000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"or just ArrayBuffer, I presume?","msgtype":"m.text"},"ts":1428528337000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: right, I forgot what the type was called that is a union of all typed arrays + ArrayBuffer + DataView","msgtype":"m.text"},"ts":1428528509000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"\"BufferSource\" apparently","msgtype":"m.text"},"ts":1428528539000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: where is the latest ReadableByteStream proposal?","msgtype":"m.text"},"ts":1428528608000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: https://github.com/whatwg/streams/blob/asyncbytestream/BinaryExtension.md","msgtype":"m.text"},"ts":1428528637000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: so... its starting to feel to me like we should not have a ReadableByteStream at all...  if the underlying source of the stream operates on bytes, then the specialization has already occurred... getReader() can just return a ByobReader","msgtype":"m.text"},"ts":1428528745000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or am I missing something?","msgtype":"m.text"},"ts":1428528750000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"bring-your-own-beerReader","msgtype":"m.text"},"ts":1428528763000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"didn't name it. :-)","msgtype":"m.emote"},"ts":1428528780000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ByobByteStreamReader","msgtype":"m.text"},"ts":1428528791000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: hmm, but adding the BYOB layer changes things quite a lot, adding complexity specifically for the byte case. You would advocate building that complexity into the readable stream itself?","msgtype":"m.text"},"ts":1428528875000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: if a view is not passed to .read()... can it not just do a \"get me the next chunk\" semantics pretty easily?","msgtype":"m.text"},"ts":1428528905000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: spec probably can't define any implementation details, can it?","msgtype":"m.text"},"ts":1428528935000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"wanderview: for example the underlying source needs some kind of hook read(view) -> promise that fills view, and inside the stream/reader mechanisms you need something such that byobReader.read(view) transfers view to view2 then passes view2 to the read hook on the source","msgtype":"m.text"},"ts":1428528952000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"trevnorris: it can define anything observable","msgtype":"m.text"},"ts":1428528958000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"trevnorris: including creation APIs","msgtype":"m.text"},"ts":1428528966000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: the idea is you should opt in to one mode or the other (BYOB or auto-flowing)","msgtype":"m.text"},"ts":1428528987000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: then keep it getByobReader(), but have it reject on streams that don't have the right underlying source","msgtype":"m.text"},"ts":1428529028000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"for example BYOB doesn't have a high water mark or queue in general (although it does probably keep one around since kernel buffers are finite... unsure if that's observable to spec or can be part of the underlying source details)","msgtype":"m.text"},"ts":1428529032000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: ick, that's a very bad API. It would be like Node having a tagName that throws an exception when you try to use it on Comment nodes","msgtype":"m.text"},"ts":1428529055000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: my implementations tie a C++ class to every JS stream, on which a class method can be defined to receive incoming data. .pipe() can detect that and short circuit the JS call by passing from the internal C++ to the implementation defined method.","msgtype":"m.text"},"ts":1428529075000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"unfortunately it depends on certain V8-isms that i'm not sure are currently possible in other engines.","msgtype":"m.text"},"ts":1428529100000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"trevnorris: right, in that case the spec's job is to make your short circuit unobservable","msgtype":"m.text"},"ts":1428529100000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"trevnorris: and that means completely unobservable, even if someone overwrites dest.write to log when called or similar ;)","msgtype":"m.text"},"ts":1428529125000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: what does ReadableByteStream get you beyond the Byob capacility?  It doesn't seem like anything... so maybe it should be a ByobReadableStream","msgtype":"m.text"},"ts":1428529128000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yes, that is indeed the real delta. We figured it was a more user-friendly name? But no real opposition to renaming it","msgtype":"m.text"},"ts":1428529164000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess the problem with that is the producer of the stream does not know if the user wants Byob semantics","msgtype":"m.text"},"ts":1428529187000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Actually we are kind of hoping not to use the term \"BYOB\" in public API. The fact that's in tyoshino's doc is largely just as a placeholder :)","msgtype":"m.text"},"ts":1428529193000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"^user^consumer","msgtype":"m.text"},"ts":1428529198000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I know","msgtype":"m.text"},"ts":1428529203000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: it just feels the \"type\" of the stream is determined by the underlying source... and having to have a special shell around particular underlying sources is clumsy... ReadableStream should just enable the extra features if its constructed with a byte oriented underlying source","msgtype":"m.text"},"ts":1428529254000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: the hope is that it is efficient for streams like fetch/fs/etc. that are bytes-backed to implement ReadableByteStream, and then consumers who want to opt in to BYOB behavior can use .getByobReader(), and normal people (including those agnostic to the chunk type) can just use .getReader()","msgtype":"m.text"},"ts":1428529257000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: I don't agree with that. The logical conclusion of that argument is that streams should be able to bake me a cake if I give them the right underlying source.","msgtype":"m.text"},"ts":1428529306000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Adding fundamentally new capabilities, instead of just different behavior, should require a new type.","msgtype":"m.text"},"ts":1428529325000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"likes cake.","msgtype":"m.emote"},"ts":1428529336000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: what do you anticipate being different about a WritableByteStream?","msgtype":"m.text"},"ts":1428529371000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: hazy right now, but one big thing is it will need to detach any passed-in buffers since they might be sent off thread","msgtype":"m.text"},"ts":1428529396000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: that... seems hard without including it in the WritableStream contract","msgtype":"m.text"},"ts":1428529454000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hmm how so?","msgtype":"m.text"},"ts":1428529486000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: isn't that an optimizaiton that should be negotiated by native underlying source to native underlying sink?","msgtype":"m.text"},"ts":1428529500000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I am talking about var a = new Uint8Array([5, 10, 15, 20]); fileStream.write(a)","msgtype":"m.text"},"ts":1428529544000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I want to send the backing memory of a off into the thread that does file I/O","msgtype":"m.text"},"ts":1428529561000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"and I am pretty sure we don't want to let people do a[0] = 7 and have that mutate the memory, maybe before the write, maybe after the write","msgtype":"m.text"},"ts":1428529602000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: you're talking about effectively making the chunk disappear from content... if under normal circumstances I can do ws.write(chunk); muchAroundWithChunk(chunk); ... how will code based just on WritableStream know that .write() suddently doesn't work that way because it has a WBS?","msgtype":"m.text"},"ts":1428529608000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: I guess I'm saying WritableStream.write() contract should say \"don't expect the chunk to exist in its current form after this call\"  regardless of WritableStream vs WritableByteStream","msgtype":"m.text"},"ts":1428529661000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: that's fair, although I'm not sure in practice how worried we should be. But one easy fix is to add .getTransferringWriter() or similar, whereas .getWriter() does copies?? I dunno.","msgtype":"m.text"},"ts":1428529666000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: I just have no idea how to enforce that contract","msgtype":"m.text"},"ts":1428529686000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"if it's not true for most writable streams, then people might assume it, no matter if the spec has some kind of \"don't assume this please\" note.","msgtype":"m.text"},"ts":1428529706000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: maybe its not enforceable... but we can at least say \"told you so\" when people' stuff breaks :-)","msgtype":"m.text"},"ts":1428529707000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"heh, ok","msgtype":"m.text"},"ts":1428529714000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: it just seems stuff like ByobReader and maybe this TransferringWriter are opportunistic things... optimize in this fashion if its available... otherwise use the lesser stuff","msgtype":"m.text"},"ts":1428529753000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: and I guess in your mind the right way to \"check if its available\" is to do an instanceof on the prototype?","msgtype":"m.text"},"ts":1428529788000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I don't see how to make ByobReader opportunistic. E.g. no way to do https://gist.github.com/domenic/65921459ef7a31ec2839#reading-a-file-chunkwise (old API I think) without explicitly doing things with JS","msgtype":"m.text"},"ts":1428529809000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: check if what is available?","msgtype":"m.text"},"ts":1428529820000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: check if ByobReader is available on a RS, for example","msgtype":"m.text"},"ts":1428529834000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: if (rs.getByobReader) { ... }","msgtype":"m.text"},"ts":1428529848000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: can't see much difference between that and getByobReader() returning null if its not supported","msgtype":"m.text"},"ts":1428529955000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: it's just basic API design... we don't add everything onto a single object. New classes of objects get ... new classes.","msgtype":"m.text"},"ts":1428529988000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Node vs. Element, etc.","msgtype":"m.text"},"ts":1428529996000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think I dislike mixing that with the revealing constructor pattern... the constructor is not revealing all the behavior","msgtype":"m.text"},"ts":1428530019000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: if we had a revealing factory method that could construct the right type... it might seem a bit better to me","msgtype":"m.text"},"ts":1428530039000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I don't see how they're related. Revealing constructor pattern lets you customize a type's behavior. You can have different revealing constructors for different types. We don't use the same type for Promise and ReadableStream, even though they both have customizable behavior via the revealing constructor pattern.","msgtype":"m.text"},"ts":1428530076000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"why would you say the constructor is not revealing all the behavior?","msgtype":"m.text"},"ts":1428530090000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: why would you ever do new ReadableStream(myByteSource)?  shouldn't you *always* do new ReadableByteStream(myByteSource)?","msgtype":"m.text"},"ts":1428530139000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yes?","msgtype":"m.text"},"ts":1428530149000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"did i say otherwise?","msgtype":"m.text"},"ts":1428530160000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: no... but it feels weird to leave that as a footgun for people","msgtype":"m.text"},"ts":1428530175000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"it's the same footgun as new Promise(myByteSource) ... not really worried.","msgtype":"m.text"},"ts":1428530190000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"the type is really associated with the source, not the wrapper object","msgtype":"m.text"},"ts":1428530199000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or new WritableStream(myByteSource)","msgtype":"m.text"},"ts":1428530207000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: except those will fail... ReadableStream(myByteSource) will work, but just prevent consumers from optimizing","msgtype":"m.text"},"ts":1428530226000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"The source is an adapter between the conceptual source and the concrete readable stream type","msgtype":"m.text"},"ts":1428530230000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: why would it work?","msgtype":"m.text"},"ts":1428530238000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: err... from what I can tell new ReadableStream() and new ReadableByteStream() expect the same properties on the passed duck typed source?","msgtype":"m.text"},"ts":1428530304000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"is that not true?","msgtype":"m.text"},"ts":1428530311000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: the argument for ReadableByteStream() is not specced at all yet :)","msgtype":"m.text"},"ts":1428530329000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: it will probably be something like { start() { }, read(view), cancel(reason) { } }","msgtype":"m.text"},"ts":1428530354000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1428530444000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: going back to WritableByteStream... one optimization we have in our native streams is the writing side can pass its destination back into the person doing the write... so in theory this could be passed back to read(view) or something to all a ReadableByteStream to write directly into a WritableByteStream","msgtype":"m.text"},"ts":1428530515000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: good point, i forgot that was also something we definitely want out of ReadableByteStream + WritableByteStream pipes","msgtype":"m.text"},"ts":1428530562000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"they can set up a small buffer pool and reuse buffers to limit total consumption and GC churn ... it will work beautifully ... /me waves his hands","msgtype":"m.text"},"ts":1428530628000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: sorry... I'm used to the DOM stuff which just enforces types and then says \"using X's internal thing, do stuff\"","msgtype":"m.text"},"ts":1428531350000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: np, just concerned about the layering in the design. Ideally *ByteStream should be additive and opt-in, both for consumers and from an architectural level.","msgtype":"m.text"},"ts":1428531473000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: to be honest, things like off-main-thread piping are mostly interesting to me for *ByteStream... for streams with potentially arbitrary js objects for chunks... not sure I can safely move those around off-thread","msgtype":"m.text"},"ts":1428531608000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"not sure if that changes anything","msgtype":"m.text"},"ts":1428531618000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: oh, no, I was never really planning on them being off thread... but i want the model to not change drastically when you move from non-byte to byte streams","msgtype":"m.text"},"ts":1428531638000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: although I guess it could be pretty useful in some cases e.g. if a UA provided stream wants to pass metadata with each chunk like { remotePort, remoteAddress, data } or something instead of just data","msgtype":"m.text"},"ts":1428531681000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I built a bunch of node stream libs to do that kind of thing before... not sure anyone really liked it much","msgtype":"m.text"},"ts":1428531743000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"https://blog.wanderview.com/blog/2013/03/01/composable-object-streams/","msgtype":"m.text"},"ts":1428531773000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: do you have a summary of where we are on https://github.com/yutakahirano/fetch-with-streams/issues/30 ? when i went to bed last night i think we were convering on new Request({ body: readableStream }) + fetch(request, wsRevealer) + cache.add(request, wsRevealer) or similar. But then it changed overnight and now I am confused.","msgtype":"m.text"},"ts":1428531813000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think DOM APIs would prefer to return a structured webidl object with a stream property (like Response)","msgtype":"m.text"},"ts":1428531848000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"?","msgtype":"m.text"},"ts":1428531869000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I objected to putting wsRevealer on the consumer... because Request is no longer representative of the network request","msgtype":"m.text"},"ts":1428531892000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"(I like the UDP object streams BTW!)","msgtype":"m.text"},"ts":1428531894000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Hmm was it ever?","msgtype":"m.text"},"ts":1428531905000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Isn't Request more like RequestMetadata?","msgtype":"m.text"},"ts":1428531926000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: no... before streams came into it, it contained all info to perform a network request","msgtype":"m.text"},"ts":1428531950000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"including the body","msgtype":"m.text"},"ts":1428531952000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"right, info to perform a network request, but not a network request itself....","msgtype":"m.text"},"ts":1428531964000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"which is why you can store it in a cache; you can't store a network request in a cache...","msgtype":"m.text"},"ts":1428532000000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: correct... it is a representation of a possible network request... it is not an actual in progress network request... but if you move the body ws-revealer to fetch() then Request no longer fully describes the possible network request","msgtype":"m.text"},"ts":1428532034000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hmmm","msgtype":"m.text"},"ts":1428532044000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i guess that's true","msgtype":"m.text"},"ts":1428532053000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"and ws-revealer is really \"a sequence of instructions for how to create a body\" so it still goes in the category of \"representation of a possible network request\"","msgtype":"m.text"},"ts":1428532075000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: look at my last proposal... it combines your WritableStream wrapper without the hard coded type switch","msgtype":"m.text"},"ts":1428532078000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Although I doubt you'll store the ws-revealer in the cache...","msgtype":"m.text"},"ts":1428532092000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yeah, I liked that, although unsure how it fits with the rest of the discussion up until that point","msgtype":"m.text"},"ts":1428532119000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: well, right now Cache only supports GET... so can't put a body in... but if you could, Cache would trigger ws-revealer to get the body data","msgtype":"m.text"},"ts":1428532121000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I still have all the code in gecko to store Request bodies","msgtype":"m.text"},"ts":1428532140000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hmm i see","msgtype":"m.text"},"ts":1428532155000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yeah i guess that makes sense","msgtype":"m.text"},"ts":1428532164000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"you reify the body whenever the request gets \"committed\" somewhere","msgtype":"m.text"},"ts":1428532183000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"those are fancy words, but I will nod my head","msgtype":"m.text"},"ts":1428532205000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":":P","msgtype":"m.text"},"ts":1428532216000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"does reify just mean normalize?","msgtype":"m.text"},"ts":1428532224000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"nah ... i'm thinking of it as, make a real set of bytes out of a function that represents a way to get bytes","msgtype":"m.text"},"ts":1428532247000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"ah, ok... serialize then","msgtype":"m.text"},"ts":1428532266000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ws-revealer is a \"potential body\" that gets reified into a real body when you fetch/cache-add","msgtype":"m.text"},"ts":1428532266000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yeah that i guess","msgtype":"m.text"},"ts":1428532272000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I should look up that term I guess","msgtype":"m.text"},"ts":1428532292000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I have more of an EE background so I tend to get lost in the CS theory world","msgtype":"m.text"},"ts":1428532312000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"might be a mathematician thing, I dunno. Or just a pretentious thing :P","msgtype":"m.text"},"ts":1428532333000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so the current proposal is req.{setWriter/pipeTo} plus ... body(ws) { ... } which gets triggered after setWriter/pipeTo plus ... do we allow body: readableStream?","msgtype":"m.text"},"ts":1428532375000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I still want body: readableStream, yes","msgtype":"m.text"},"ts":1428532407000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"poor overloaded body: option","msgtype":"m.text"},"ts":1428532417000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: didn't you hear?  fetch is mostly about sugar :-)","msgtype":"m.text"},"ts":1428532459000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: and to be clear... I only think we need this ws-revealer thing because of the desire to have progress notification that a pipe would obfuscate","msgtype":"m.text"},"ts":1428532547000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: btw... resolving the .write() promises when written to the kernel is going to be somewhat challenging... in gecko we get notification from the network code about progress in a different path from where we write... so we have to match that progress back up to the promises to resolve, etc","msgtype":"m.text"},"ts":1428532657000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"maybe not challenging... but annoying","msgtype":"m.text"},"ts":1428532666000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":":-S","msgtype":"m.text"},"ts":1428532746000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"much easier to integrate that with a progress event (which is what it was designed for, of course)","msgtype":"m.text"},"ts":1428532771000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Well, there's https://github.com/whatwg/streams/issues/316 ...","msgtype":"m.text"},"ts":1428532771000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: doubt this'll have any affect on the spec here, but in previous implementations I've had calls like .write() return a request object so you can trace the status at any point in the future.","msgtype":"m.text"},"ts":1428532796000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"e.g. .progress() to see how much has been written.","msgtype":"m.text"},"ts":1428532808000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"I use that in conjunction with timeouts to cancel writes that are taking too long.","msgtype":"m.text"},"ts":1428532821000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"Domenic: for example, I think gecko network code throttles progress notifications to once every 50ms or something... so you will see batches of .write() promises resolves at the same time, etc.","msgtype":"m.text"},"ts":1428532841000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"trevnorris: sounds like you want cancellable promises :-)","msgtype":"m.text"},"ts":1428532880000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"trolls","msgtype":"m.emote"},"ts":1428532889000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: lol, because the spec says 50 ms, good times :P","msgtype":"m.text"},"ts":1428532896000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"hehe. ;)","msgtype":"m.text"},"ts":1428532901000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"wanderview: is it possible to do something like: var req = ws.write(data); setTimeout(function(req) { if (req.status() != 'complete') req.abort(); }, 1000); ?","msgtype":"m.text"},"ts":1428533151000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"trevnorris: I think you would have to call ws.abort() instead of req.abort()","msgtype":"m.text"},"ts":1428533224000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: what if you did ws.write(data1) ws.write(data2) and I only wanted to abort writing data1?","msgtype":"m.text"},"ts":1428533251000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"with cancelable promises you could do `var p = ws.write(data); setTimeout(() => p.cancel(), 1000). (Assuming calling p.cancel() does nothing on an already-settled promise)","msgtype":"m.text"},"ts":1428533256000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"already-settled promise?","msgtype":"m.text"},"ts":1428533295000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"trevnorris: that seems racy to me... you may end up with data1 and data2 or just data2... also, not all write operations are abortable once they start, etc","msgtype":"m.text"},"ts":1428533327000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"already fulfilled or rejected","msgtype":"m.text"},"ts":1428533329000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yeah, how does that work in POSIX?","msgtype":"m.text"},"ts":1428533348000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: if you've queued up several chunks of data to be written, and only the first has actually been sent to the kernel it should be possible to remove any specific write req from the queue.","msgtype":"m.text"},"ts":1428533372000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"trevnorris: in a multi-threaded environment... it may have been sent to the kernel and you just haven't been notified of it yet","msgtype":"m.text"},"ts":1428533403000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"can you elaborate on a scenario where a Promise could be resolved while a \"child\" Promise has yet to resolve?","msgtype":"m.text"},"ts":1428533416000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"its important to remember cancellation does not mean abrupt termination","msgtype":"m.text"},"ts":1428533418000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"just that it should cancel at the next point","msgtype":"m.text"},"ts":1428533424000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"boogyman: what is a child promise","msgtype":"m.text"},"ts":1428533444000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: as soon as the data is handed off to something else I'll consider it unreachable. in the case of Node I know because we make the call to uv_write() directly.","msgtype":"m.text"},"ts":1428533447000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"if there is not a clearly defines point of cancellation, something should not be cancellable","msgtype":"m.text"},"ts":1428533447000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"defined*","msgtype":"m.text"},"ts":1428533463000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Domenic: however you define \"p.cancel()\" on an already resolved p","msgtype":"m.text"},"ts":1428533477000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"i don't understand","msgtype":"m.text"},"ts":1428533486000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"please phrase your question using code?","msgtype":"m.text"},"ts":1428533503000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"trevnorris: \"something else\" is another thread?  or the kernel?  because in multi-process browsers it goes js->c++->IPC->c++->kernel with thread and process switches in there","msgtype":"m.text"},"ts":1428533505000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"if cancellation is inteded to be similar to abort()/halting a thread it should be rethought","msgtype":"m.text"},"ts":1428533516000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"can't type today","msgtype":"m.emote"},"ts":1428533541000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"right now ws.write() does not return a cancellable promise...","msgtype":"m.text"},"ts":1428533544000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"this is all hand wving","msgtype":"m.text"},"ts":1428533549000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"waving","msgtype":"m.text"},"ts":1428533550000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: anything that takes control away from us over the lifetime of the data. but if I have an array of data chunks and only the first has been sent to uv_write() then the others should be able to be removed from their position in the queue.","msgtype":"m.text"},"ts":1428533554000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"`var p = ws.write(data); setTimeout(() => p.cancel(), 1000). (Assuming calling p.cancel() does nothing on an already-settled promise) <-- Under what circumstance would be have already been resolved if it is dependent upon ws.write(data)","msgtype":"m.text"},"ts":1428533572000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"would p.cancel()*","msgtype":"m.text"},"ts":1428533597000,"senderName":"boogyman","senderId":"boogyman@irc"},
{"content":{"body":"trevnorris: does uv_write() do file writing on a separate IO thread or the main thread?","msgtype":"m.text"},"ts":1428533622000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"boogyman: the adjective \"resolved\" does not apply to the function call p.cancel(), nor to its return value (which is undefined)","msgtype":"m.text"},"ts":1428533628000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: main thread.","msgtype":"m.text"},"ts":1428533632000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"wanderview: but I think at that point the cancellation point would be if the kernel gets it still, once it gets to the kernel it cannot be stopped, so attempts at cancellation would need to propagate to the C++ that flushes to the kernel, and if it has started flushing it is in an uncancellable state","msgtype":"m.text"},"ts":1428533637000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"trevnorris: false?","msgtype":"m.text"},"ts":1428533638000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: though I agree that if the data chunks were immediately sent to another thread to be written then we would have \"lost control\". thus cancel would only be a notification that we no longer need to be notified of its completion.","msgtype":"m.text"},"ts":1428533652000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"Domenic: eh?","msgtype":"m.text"},"ts":1428533654000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"trevnorris: fs writes in io are done in a threadpool?","msgtype":"m.text"},"ts":1428533669000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"trevnorris: ok, then you don't have to deal with the races I do... trying to pick out a single buffer to cancel is going to be hit or miss in browsers or other multi-threaded environments","msgtype":"m.text"},"ts":1428533684000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"they are queued on the main thread though","msgtype":"m.text"},"ts":1428533686000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Domenic: they're a special case. uv_wirte() and uv_try_write() is always done on the main thread.","msgtype":"m.text"},"ts":1428533695000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"*uv_write()","msgtype":"m.text"},"ts":1428533701000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"?","msgtype":"m.text"},"ts":1428533705000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"trevnorris: ah, I thought we were talking about file I/O since wanderview asked \"does uv_write() do file writing\". I guess uv_write is for sockets?","msgtype":"m.text"},"ts":1428533729000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"yes. sorry I missed that. uv_write() is only for sockets.","msgtype":"m.text"},"ts":1428533744000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"filesystem I/O is a pain thanks to kernel incompatibilities.","msgtype":"m.text"},"ts":1428533760000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"gotcha","msgtype":"m.text"},"ts":1428533760000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: what I am getting is they treat the \"write is complete\" state when it leaves main thread... which might not quite be to kernel","msgtype":"m.text"},"ts":1428533762000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1428533773000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: which is different from your goal of \"bytes written to kernel\"","msgtype":"m.text"},"ts":1428533776000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I'm not sure to-kernel is all that much better than an app internal checkpoint","msgtype":"m.text"},"ts":1428533808000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"if you are sure that writes respect backpressure, maybe \"accepted and queued\" is a good enough proxy for upload progress...","msgtype":"m.text"},"ts":1428533812000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"but willing to try to support it","msgtype":"m.text"},"ts":1428533816000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"it's possible to share memory on the req across threads so read-only fields can be used to check its status.","msgtype":"m.text"},"ts":1428533825000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"trevnorris: you have an atomic check-and-set for cancellation across threads?","msgtype":"m.text"},"ts":1428533859000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I think at either point cancellation is a suggestion to w/e you handed it off to","msgtype":"m.text"},"ts":1428533873000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"it needs to be able to continue the work if it has started side effects already","msgtype":"m.text"},"ts":1428533888000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"no real need for locking to my knowledge","msgtype":"m.text"},"ts":1428533905000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: exactly... I guess I was just getting at I find it hard to reason about the need to cancel buffer1 and let buffer2 through... when you cannot know if you got to buffer1 in time","msgtype":"m.text"},"ts":1428533909000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: right now only have it so if I've queued up many small buffers to be written I can check how many of them have actually been sent to the kernel.","msgtype":"m.text"},"ts":1428533924000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"i don't think you should be allowed to know at the time of cancellation","msgtype":"m.text"},"ts":1428533934000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"wanderview: streaming video for example. say you're buffering data to be written. it's better that frames are lost and the data stays current then making sure all the data goes through.","msgtype":"m.text"},"ts":1428533973000,"senderName":"trevnorris","senderId":"trevnorris@irc"},
{"content":{"body":"wanderview: to rephrase, I cannot think of a good reason you should be allowed to know that buffer1 was cancelled before it calls .finally","msgtype":"m.text"},"ts":1428534030000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Domenic: I think we are still not on the same page here:  https://github.com/yutakahirano/fetch-with-streams/issues/30#issuecomment-91057900","msgtype":"m.text"},"ts":1428534050000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"which to me resolves the problem of reasoning","msgtype":"m.text"},"ts":1428534103000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"I guess I'm happy we don't yet allow canceling individual .write() calls... and if we did, I think it would very much have to be a \"best effort\"","msgtype":"m.text"},"ts":1428534113000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"bradleymeck: sure... I think I understand better that its a best effort cancel, for example the video streaming case mentioned","msgtype":"m.text"},"ts":1428534137000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"which is good, I want \"best effort\" and not guaranteed","msgtype":"m.text"},"ts":1428534150000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"cause once side effects start / external systems are involved you need to let them resolve back to valid states (say if you have not finished writing)","msgtype":"m.text"},"ts":1428534182000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"guaranteed cancel would require external systems to stay in valid and buffered states which is a no-no","msgtype":"m.text"},"ts":1428534214000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Domenic: I'll respond in bug... but I think very much \"setWriter()\" should function like a pipeTo()...  we could call it drainToWriter() or something if you want","msgtype":"m.text"},"ts":1428534236000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: doing an atomic field set so the writing thread can check if the queue from another thread is still needed is very much possible.","msgtype":"m.text"},"ts":1428534371000,"senderName":"trevnorris","senderId":"trevnorris@irc"}
]