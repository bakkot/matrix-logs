[
{"content":{"body":"Any reason html.spec.whatwg.org is not CORS-able?","msgtype":"m.text"},"ts":1426845189000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I'm enjoying this \"HTML6\" email already. Not only for the HTML6, but the assertion that javascript frameworks render in 10-50ms","msgtype":"m.text"},"ts":1426853875000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"He may be talking about switching from one \"subpage\" of the SPA to another","msgtype":"m.text"},"ts":1426854833000,"senderName":"espadrine","senderId":"espadrine@irc"},
{"content":{"body":"true","msgtype":"m.text"},"ts":1426857295000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Domenic: if I've already done the work to make our Response.clone() do a zero-copy tee of the underlying body stream... there is nothing in the current proposal that would stop me from using it right?  I would not have to de-opt for some reason?  just concerned that the tee() always makes a new stream will force that on me","msgtype":"m.text"},"ts":1426859417000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I think I could use wrappers to keep the same underlying stream","msgtype":"m.text"},"ts":1426859438000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: based on what you wrote in the github issue, this tweet should really say res.body.getReader().read()?  https://twitter.com/domenic/status/578002598487175168","msgtype":"m.text"},"ts":1426860701000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"not to be pedantic...","msgtype":"m.text"},"ts":1426860713000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but it seems people care about the details","msgtype":"m.text"},"ts":1426860734000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah, good point, can't believe I missed that :-/","msgtype":"m.text"},"ts":1426862011000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: and yeah definitely no reason to de-opt. zero-copy is always the goal.","msgtype":"m.text"},"ts":1426862048000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I think I convinced myself the zero copy is not a concern with shared ArrayBuffer chunks... might be more a concern when ReadableByteStream appears","msgtype":"m.text"},"ts":1426862115000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"yeah, ReadableByteStream is an interesting tradeoff, for sockets at least. If there are chunks in user-space that are too large, but then the consumer requests like 10 bytes, either you have to do some C++ magic to make an ArrayBufferView onto a 10-byte-subset, or you have to do a copy.","msgtype":"m.text"},"ts":1426862318000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Yet, it gives the consumer complete control over allocation, so as to avoid any GC and allow buffer re-use and such","msgtype":"m.text"},"ts":1426862336000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And, for files, where it can connect directly to read(2), it should work beautifully","msgtype":"m.text"},"ts":1426862364000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: https://code.google.com/p/v8/issues/detail?id=3237 makes me sad. Any idea why making APIs up and shipping them is somehow ok in thuis case?","msgtype":"m.text"},"ts":1426865547000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"this*","msgtype":"m.text"},"ts":1426865548000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: no idea at all. It's absolutely horrible.","msgtype":"m.text"},"ts":1426865567000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"My only guess is that the V8 team doesn't have to follow the normal process?","msgtype":"m.text"},"ts":1426865579000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"sadface","msgtype":"m.text"},"ts":1426865588000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"they're indeed outside of the process","msgtype":"m.text"},"ts":1426865798000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"although more recently they've been sending intent to ship/PSAs, which already is a step forward :)","msgtype":"m.text"},"ts":1426865821000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"Hopefully we can get them to remove those APIs. It's kinda shitty","msgtype":"m.text"},"ts":1426866064000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"By \"kinda\" I mean \"absolutely and totally\"","msgtype":"m.text"},"ts":1426866079000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: getting more requests for status code on opaque requests. Going to start looking at it again, perhaps if credentials are omitted. Agree it's contentious though.","msgtype":"m.text"},"ts":1426871962000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Chrome doesn't allow fetch('//other-origin', {mode: 'no-cors'}) from a window, which doesn't make sense to me","msgtype":"m.text"},"ts":1426871987000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I think that's only disallowed because they couldn't come up with a use case and don't support cache in window?","msgtype":"m.text"},"ts":1426872007000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: credentials are not the problem. I recommend reading https://annevankesteren.nl/2015/02/same-origin-policy","msgtype":"m.text"},"ts":1426872023000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Well, they are part of it, but mostly it's firewalls.","msgtype":"m.text"},"ts":1426872061000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it's disallowed because it exposes the existence of a server. Which is weird because it's somehow ok in a SW, and you can use img requests to /favicon.ico to detect servers anyway","msgtype":"m.text"},"ts":1426872332000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"Great article btw","msgtype":"m.text"},"ts":1426872361000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: when I mentioned that I thought that was bullshit someone on blink-dev told me it was because of the reason I just mentioned","msgtype":"m.text"},"ts":1426872377000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hm, that's not what I was told, but maybe I got the info 2nd hand","msgtype":"m.text"},"ts":1426872418000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk, any concerns with changing Notification.close() to return a promise?","msgtype":"m.text"},"ts":1426873141000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"annevk, in short, it could be asynchronous and may cause unexpected behavior if SWR.getNotifications() is called immediately afterwards","msgtype":"m.text"},"ts":1426873177000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"it'll also allow us to reject if it's already closed. none of this should impact current users of the API. I'll write a PR in a bit","msgtype":"m.text"},"ts":1426873206000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"beverloo: better to resolve with a boolean if it's already closed","msgtype":"m.text"},"ts":1426873252000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"As in, resolve with true if something actually changed, false if it was already closed","msgtype":"m.text"},"ts":1426873274000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"closing something that's already closed feels like an exception to me?","msgtype":"m.text"},"ts":1426873291000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"happy to go either way","msgtype":"m.text"},"ts":1426873295000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"beverloo: I think my concern would be that getNotifications() doesn't necessarily take close into account","msgtype":"m.text"},"ts":1426873298000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"beverloo: as per the specification that is deterministic","msgtype":"m.text"},"ts":1426873305000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"beverloo: Unless there's a way to check whether it's closed, and a good reason to make double-closing an error, I wouldn't throw.","msgtype":"m.text"},"ts":1426873320000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"beverloo: closing might be racy","msgtype":"m.text"},"ts":1426873327000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"beverloo: so shouldn't throw, but I'm not really convinced yet this is needed at all","msgtype":"m.text"},"ts":1426873343000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(Python, for example, offers two set deletion functions, depending on whether you care about double-deletion or not.)","msgtype":"m.text"},"ts":1426873357000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ok, I'm convinced to use a boolean rather than reject","msgtype":"m.text"},"ts":1426873358000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"for us, closing a notification will be asynchronous, and I imagine this will the case in other implementations as well","msgtype":"m.text"},"ts":1426873379000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"I mean that's fine, but you could schedule it in such a way that getNotifications still gets the right answer","msgtype":"m.text"},"ts":1426873414000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"that's true, but I'd rather be explicit about the fact that it's not synchronous","msgtype":"m.text"},"ts":1426873551000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"if people don't care they won't use the promise","msgtype":"m.text"},"ts":1426873563000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"like today","msgtype":"m.text"},"ts":1426873566000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"Well it sounds like you want a promise to allow for racy behavior...","msgtype":"m.text"},"ts":1426873588000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"As that was your motivation rather than something about the developer wanting to know whether they already invoked close() before...","msgtype":"m.text"},"ts":1426873624000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hm. Neither are great arguments if we're honest :-).","msgtype":"m.text"},"ts":1426873736000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"because of the way how we're implementing getNotifications it will work fine, but I just don't think it's clear","msgtype":"m.text"},"ts":1426873755000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"it's not racy because of an implementation detail","msgtype":"m.text"},"ts":1426873764000,"senderName":"beverloo","senderId":"beverloo@irc"},
{"content":{"body":"beverloo: well so my argument is that it's already defined to be non-racy and that I haven't seen rationale for exposing closedness","msgtype":"m.text"},"ts":1426881908000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(things to do before posting suggestions about html: know that there's no such thing as \"html6\")","msgtype":"m.text"},"ts":1426894460000,"senderName":"zewt","senderId":"zewt@irc"}
]