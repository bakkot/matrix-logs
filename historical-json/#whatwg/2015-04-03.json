[
{"content":{"body":"annvk — looking at URL spec","msgtype":"m.text"},"ts":1428032870000,"senderName":"mnot1","senderId":"mnot1@irc"},
{"content":{"body":"It doesn't appear to account for http://tools.ietf.org/html/rfc6874","msgtype":"m.text"},"ts":1428032879000,"senderName":"mnot1","senderId":"mnot1@irc"},
{"content":{"body":"Not sure how common that is, but it is coming out of Apple...","msgtype":"m.text"},"ts":1428032895000,"senderName":"mnot1","senderId":"mnot1@irc"},
{"content":{"body":"jgraham: I still have \"Subproject commit 8ce47687cbbfff6b249bbaf189f096869286c677-dirty\" as a change to tools in web-platform-tests","msgtype":"m.text"},"ts":1428041562000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"replied to mnot1 on Twitter","msgtype":"m.emote"},"ts":1428041814000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"In HTTP ABNF, \"text\", how do you indicate text cannot appear in quoted form?","msgtype":"m.text"},"ts":1428046763000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I see, you need quoted-string for that","msgtype":"m.text"},"ts":1428046820000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: You can probably ignore that","msgtype":"m.text"},"ts":1428052347000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: yeah, it seems like it doesn't matter much in terms of getting updates and doing commits, but it's still a bit annoying that it shows up","msgtype":"m.text"},"ts":1428052380000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Right, it should be possible to make it not say that… I'll investigate","msgtype":"m.text"},"ts":1428052421000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham, I believe you need to add *.pyc to the gitignore, if you haven't figured that out yet :)","msgtype":"m.text"},"ts":1428053555000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"Ms2ger: Looking at a problem with my servo PR instead :)","msgtype":"m.text"},"ts":1428053687000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"OK, added a .gitignore file","msgtype":"m.text"},"ts":1428057148000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"JakeA: it seems you're making good progress on cancelation with Domenic so unless I hear otherwise I'll just wait on the outcome of your research","msgtype":"m.text"},"ts":1428060153000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I also tried to reply to all the BackgroundSync things","msgtype":"m.text"},"ts":1428060183000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I have to say by the way that I have \"Background App Refresh\" (as Apple calls it) disabled and have advised others with battery problems to do the same. In that light I'm still not really comfortable with the period synchronization feature...","msgtype":"m.text"},"ts":1428060436000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"anyone around willing to take a look at an HTTP I-D and comment? https://datatracker.ietf.org/doc/draft-combs-http-indeterminate-range/","msgtype":"m.text"},"ts":1428060552000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"rcombs: maybe reuse an existing header to advertise the feature?","msgtype":"m.text"},"ts":1428062202000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I considered extending Accept-Ranges","msgtype":"m.text"},"ts":1428062302000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"annevk: but there's a decent chance that existing implementations just look for the exact string \"bytes\" in there","msgtype":"m.text"},"ts":1428062326000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"rcombs: there's Prefer, bunch of client hints headers I believe","msgtype":"m.text"},"ts":1428062423000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"rcombs: I don't know, just seems like adding a new header for each new thing doesn't really scale","msgtype":"m.text"},"ts":1428062462000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"eh, it's not like you pay per header, or like there's a significant performance penalty for parsing a new one over parsing a variant of an existing one","msgtype":"m.text"},"ts":1428062607000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"I'd have preferred to have something like `Accept-Ranges: bytes, bytes-indeterminate`, but the existing spec isn't clear on multiple values being allowed for that header","msgtype":"m.text"},"ts":1428062679000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"rcombs: 1#range-unit seems quite clear","msgtype":"m.text"},"ts":1428062847000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I actually don't know for sure what that syntax means (is that valid (E|A)BNF?), but assuming it means \"exactly 1 of <range-unit>\", then yeah, that'd be clearly not allowing multiple values","msgtype":"m.text"},"ts":1428063022000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"rcombs: it means one or more comma-separated values","msgtype":"m.text"},"ts":1428063125000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"rcombs: it's HTTP ABNF","msgtype":"m.text"},"ts":1428063132000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"oh, of course it has its own dialect","msgtype":"m.text"},"ts":1428063149000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"that I did not know","msgtype":"m.text"},"ts":1428063157000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"rcombs: https://tools.ietf.org/html/rfc7230#section-7","msgtype":"m.text"},"ts":1428063163000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1428063186000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"hmm, libavformat checks if the first 5 characters of the header are \"bytes\", Chromium checks if the string \"bytes\" appears at all, WebKit just checks if it's not equal to \"none\", and Firefox checks if it's exactly equal to \"bytes\"","msgtype":"m.text"},"ts":1428063703000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"that last one is what I was afraid of","msgtype":"m.text"},"ts":1428063709000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"wow","msgtype":"m.text"},"ts":1428064726000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"that's pretty terrible","msgtype":"m.text"},"ts":1428064730000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"it's almost as if the HTTP WG doesn't really test things","msgtype":"m.text"},"ts":1428064739000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: do you know the details about MIME types and <audio>, <video>, and <track>?","msgtype":"m.text"},"ts":1428065019000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"philipj: I want to fill out https://fetch.spec.whatwg.org/#should-response-to-request-be-blocked-due-to-nosniff?","msgtype":"m.text"},"ts":1428065034000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Tests? What's that?","msgtype":"m.text"},"ts":1428065082000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"HTTP 1.x did great without","msgtype":"m.text"},"ts":1428065104000,"senderName":"darobin","senderId":"darobin@irc"},
{"content":{"body":"if the vast majority of uses of a field have a single value, you can bet at least one implementation will check for that value exactly and fail on all others","msgtype":"m.text"},"ts":1428065205000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"or otherwise check it lazily, and just make sure it works with existing servers (or files or implementations or whatever) then assume it's fine","msgtype":"m.text"},"ts":1428065288000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"hi I'm rcombs and I'm cynical about tech","msgtype":"m.text"},"ts":1428065330000,"senderName":"rcombs","senderId":"rcombs@irc"},
{"content":{"body":"That's why we have test suites on this side","msgtype":"m.text"},"ts":1428065352000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"JakeA: is this how Cache add/addAll/put are supposed to work?  it seems confusing to me...  https://github.com/slightlyoff/ServiceWorker/issues/665#issuecomment-89216340","msgtype":"m.text"},"ts":1428070727000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"hm, jhusain isn't big on fetch either","msgtype":"m.text"},"ts":1428073009000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"why do the cancellation semantics need to be tied to the promise? why not response objects?","msgtype":"m.text"},"ts":1428073379000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: because you need to be able to cancel before the network headers are available and don't have a Response object yet","msgtype":"m.text"},"ts":1428073817000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"caitp: too late?","msgtype":"m.text"},"ts":1428075579000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"fine, fetch.abort(thePromise) then :p","msgtype":"m.text"},"ts":1428075787000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"but I mean","msgtype":"m.text"},"ts":1428075792000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"it doesn't solve how you'd encode cancellation and avoid deadlocks","msgtype":"m.text"},"ts":1428075802000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Deadlocks?","msgtype":"m.text"},"ts":1428075822000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"well you wouldn't resolve or reject the promise","msgtype":"m.text"},"ts":1428075866000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Oh, with your proposal","msgtype":"m.text"},"ts":1428075918000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"unlimited pending also causes some odd things since you can't do a finally style cleanup","msgtype":"m.text"},"ts":1428076023000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yes, that","msgtype":"m.text"},"ts":1428076043000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"er, that's the proble","msgtype":"m.text"},"ts":1428076047000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"m","msgtype":"m.text"},"ts":1428076048000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"this keyboard is really hard to type on","msgtype":"m.text"},"ts":1428076051000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"is still upset that finally is no longer 100% guaranteed in generators","msgtype":"m.emote"},"ts":1428076177000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: JakeA and Domenic have an idea of making .finally work for cancelable promises","msgtype":"m.text"},"ts":1428076459000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"bradleymeck: but not .catch, which seems okayish","msgtype":"m.text"},"ts":1428076473000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"uggggg","msgtype":"m.text"},"ts":1428076538000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"finally, except not like try catch finally","msgtype":"m.text"},"ts":1428076558000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"we use finally to cleanup steps in both cases, since we keep pushing cleanup steps as we perform them","msgtype":"m.text"},"ts":1428076601000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"so if there is an error we would need to always add a .catch to do cleanup?","msgtype":"m.text"},"ts":1428076627000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"`","msgtype":"m.text"},"ts":1428076690000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"bradleymeck: not like that","msgtype":"m.text"},"ts":1428076696000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"bradleymeck: cancelation would trigger finally only, catch/finally still work per usual otherwise","msgtype":"m.text"},"ts":1428076729000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"seems sane, as cancelation is closer to return than throw","msgtype":"m.text"},"ts":1428076751000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"at least we are using .return for cancellation on generators","msgtype":"m.text"},"ts":1428076764000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yeah, that was the inspiration","msgtype":"m.text"},"ts":1428081343000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"not sure it's actually workable or ergonomic yet, but seems theoretically sound-ish","msgtype":"m.text"},"ts":1428081366000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"JakeA: I think I like the onCancelled-handler-chooses approach. That way you get forever-pending by default but the creator can choose.","msgtype":"m.text"},"ts":1428083287000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"JakeA: you *could* even extend it so that .cancel(x) passes x to onCanceled, which would allow .cancel({ rejectWith: e }) if the promise-creator was set up to handle that.","msgtype":"m.text"},"ts":1428083313000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"does it really make sense to use promises at all for something that is more complicated than a success/error response?","msgtype":"m.text"},"ts":1428089050000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: if \"it\" was synchronous, would it make sense as function that returns a value or throws?","msgtype":"m.text"},"ts":1428089379000,"senderName":"jsbell_gardener","senderId":"jsbell_gardener@irc"},
{"content":{"body":"right, but this is re: fetch","msgtype":"m.text"},"ts":1428089437000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"there are more possible outcomes and no real synchronous analog","msgtype":"m.text"},"ts":1428089448000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"ah, missed the context above","msgtype":"m.text"},"ts":1428089489000,"senderName":"jsbell_gardener","senderId":"jsbell_gardener@irc"},
{"content":{"body":"caitp: I think it does.","msgtype":"m.text"},"ts":1428090295000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"caitp: you can think about it in a few ways. One is that a promise is an async extension of \"completion values\" and there are more completion types than just normal and throw.","msgtype":"m.text"},"ts":1428090356000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"well jhusain was saying \"we escaped the land of errnos and sentinel values for a reason, lets not go back!\" well, in addition to other things","msgtype":"m.text"},"ts":1428090479000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"and with the current promise design, how else would you do it?","msgtype":"m.text"},"ts":1428090486000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"You wouldn't use the current promise design, you'd use a cancellable promise design","msgtype":"m.text"},"ts":1428091283000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Promise.all([ fetchThing1(), fetchThing2(), fetchThing3() ]).ohWaitIDontNeedTheseWhatNow()","msgtype":"m.text"},"ts":1428091410000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"it doesn't \"really\" work","msgtype":"m.text"},"ts":1428091424000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I don't really understand either of those two sentences","msgtype":"m.text"},"ts":1428091499000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I mean, if cancellable promises can interact with regular promises, then you can lose the cancelable-ness","msgtype":"m.text"},"ts":1428091533000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"for sure, that's kind of explicitly the point","msgtype":"m.text"},"ts":1428091543000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"which is confusing and notgood","msgtype":"m.text"},"ts":1428091543000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"if you downcast to a regular promise you're removing the cancel-ability","msgtype":"m.text"},"ts":1428091551000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Kind of like downcasting from v8::Value to v8::Handle :P","msgtype":"m.text"},"ts":1428091567000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I dunno, seems like a lot of headaches waiting to happen","msgtype":"m.text"},"ts":1428091653000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Domenic: do you envision a Promise.allCancellable() that would keep the all() behavior and cancellable type?","msgtype":"m.text"},"ts":1428091717000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: CancelablePromise.all([...])","msgtype":"m.text"},"ts":1428091731000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"base Promise type should be entirely undisturbed","msgtype":"m.text"},"ts":1428091739000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: and does that throw if passed a non-cancellable promise or something?","msgtype":"m.text"},"ts":1428091752000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: nah it just converts them to cancelable promises which a no-op cancelation action","msgtype":"m.text"},"ts":1428091772000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: similarly to how Promise.all converts non-promises to fulfilled promises","msgtype":"m.text"},"ts":1428091787000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I know fetch has shipped and all, but it's young and could probably be unshipped in order to fix the design","msgtype":"m.text"},"ts":1428091801000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Domenic: so as a developer, I would just use CancelablePromise.all() all the time right?  why would I ever use Promise.all() any more?","msgtype":"m.text"},"ts":1428091832000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"in case someone gave me a cancellable promise","msgtype":"m.text"},"ts":1428091847000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"or needed to consume my promise as cancellable","msgtype":"m.text"},"ts":1428091863000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"caitp: you really have drunk the kool-aid of that thread ... there's nothing wrong with the fetch design.","msgtype":"m.text"},"ts":1428091882000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: you would use CancelablePromise.all if you wanted the result to be cancelable. But that's pretty rare. Most of the time you don't want to give people the ability to cancel.","msgtype":"m.text"},"ts":1428091903000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i am not really following that thread closely, but we're looking at the design for angular's new http abstraction, and jafar husain brought the points there","msgtype":"m.text"},"ts":1428091921000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"ah yes, he is everywhere bad-mouthing other peoples' work.","msgtype":"m.text"},"ts":1428091961000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i don't know if he's been impolite about it, but he does raise some good points","msgtype":"m.text"},"ts":1428091992000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"i really just disagree with them. he's pretty colored by his observable-philia","msgtype":"m.text"},"ts":1428092007000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"sour grapes that the platform includes promises and not observables, is what i've seen","msgtype":"m.text"},"ts":1428092048000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"i mean, I think the platform does get pretty close to observables with DOM events","msgtype":"m.text"},"ts":1428092083000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"\"pretty\" close","msgtype":"m.text"},"ts":1428092087000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Domenic: not sure I like the \"perma-hang as a default\" idea, especially as a chain can cancel without oncancel being called on any promise","msgtype":"m.text"},"ts":1428092102000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"caitp: heh. I mean, they are both vaguely event-like.","msgtype":"m.text"},"ts":1428092121000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think reject or some third state needs to be default","msgtype":"m.text"},"ts":1428092125000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: hmm. I think the question is, what is the use case for observing cancellation.","msgtype":"m.text"},"ts":1428092177000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: cancelling spinners for one","msgtype":"m.text"},"ts":1428092206000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: if we had better answers for that, we could see if e.g. a .finally version is reasonable","msgtype":"m.text"},"ts":1428092211000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"OK, cool, that does sound finally-friendly","msgtype":"m.text"},"ts":1428092225000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"doAsyncThing().catch(showError).finally(removeSpinner)","msgtype":"m.text"},"ts":1428092243000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: agreed","msgtype":"m.text"},"ts":1428092287000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"This is gonna be a bitch to spec the backend of :P","msgtype":"m.text"},"ts":1428092307000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it's probably not a good idea to have a new class of promise in addition to existing promises","msgtype":"m.text"},"ts":1428092337000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I disagree","msgtype":"m.text"},"ts":1428092345000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"JakeA: I think I'll revive promises-unwrapping, update it to the latest spec. Then we can use it as a base for CancelablePromise.","msgtype":"m.text"},"ts":1428092370000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"no, it's a really bad idea, from a web developer's PoV and from a browser vendor's PoV","msgtype":"m.text"},"ts":1428092432000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"I disagree.","msgtype":"m.text"},"ts":1428092438000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess it just seems weird to me that if you use a legacy library in your Promise chain that does not return CancellablePromise, then you can no longer cancel the source of the chain...","msgtype":"m.text"},"ts":1428092445000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: yeah but the legacy library produces promises that are not meant to be cancelable","msgtype":"m.text"},"ts":1428092468000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"why not just propose an extension to the promise api for es7?","msgtype":"m.text"},"ts":1428092503000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: because not all promises should be cancelable. That's a capability leak to make them so.","msgtype":"m.text"},"ts":1428092519000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: but if the source hasn't finished yet, why does the cancellability of the later processing prevent me from cancelling the source?","msgtype":"m.text"},"ts":1428092532000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic, they might not all be cancellable, but \"finally\" surely makes sense for all promises","msgtype":"m.text"},"ts":1428092555000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: oh, yeah, definitely. That was the plan.","msgtype":"m.text"},"ts":1428092572000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"if you have a single class, you make life much easier for devs","msgtype":"m.text"},"ts":1428092591000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Domenic: it just seems its going to make it harder to glue different modules in the promise ecosystem together... basically creating separate class of modules","msgtype":"m.text"},"ts":1428092599000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"if they all have a cancel method which may or may not do anything, you make life easier","msgtype":"m.text"},"ts":1428092605000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"wanderview: I think that's intended though. You should explicitly opt-in to cancelability.","msgtype":"m.text"},"ts":1428092624000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"caitp: I don't think silent failure like that makes anyone's life easier.","msgtype":"m.text"},"ts":1428092640000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"where's the silent failure","msgtype":"m.text"},"ts":1428092658000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Domenic: I don't see how that jives with CancellablePromise.all() wrapping non-cancellable promises with a no-op cancel()... if thats safe... just give them all a no-op cancel by default","msgtype":"m.text"},"ts":1428092662000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"caitp: canceling something that's not actually cancelable is a logic error. Better to get that error than silently doing nothing.","msgtype":"m.text"},"ts":1428092690000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: it's a shorthand for CancellablePromise.all(mapIterable(i, x => CancelablePromise.resolve(x)))","msgtype":"m.text"},"ts":1428092741000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: just like Promise.all is a shorthand for Promise.all(mapIterable(i, x => Promise.resolve(x)))","msgtype":"m.text"},"ts":1428092769000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I don't see how that behavior is consistent with your statement \"canceling something that's not actually cancelable is a logic error\"","msgtype":"m.text"},"ts":1428092822000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but I am probably just bikeshedding at this point","msgtype":"m.text"},"ts":1428092833000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"gets out of the way.","msgtype":"m.emote"},"ts":1428092842000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I see what you're saying. It's an implicit part of the .all contract that you up-cast though. Whereas it's not an implicit part of the anyValue.anyMethod() contract that you up-cast, IMO. So if anyValue does not have a behavior for anyMethod then it seems better to throw.","msgtype":"m.text"},"ts":1428092901000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I dunno, these kind of things make me want to go back to tokens, but then I see how painful they are to use.","msgtype":"m.text"},"ts":1428092936000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I am 100% sure by this point though that CancelablePromise is much better than Task","msgtype":"m.text"},"ts":1428092954000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I guess I would argue there is a net benefit to the ecosystem to providing a single Promise class with a default no-op vs. splitting the ecosystem into separate classes with more strictly defined throw-if-not-really-cancelable policy","msgtype":"m.text"},"ts":1428092976000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"i think it's worth entertaining the guy's ideas a bit, it's not like he doesn't have a clue about api design","msgtype":"m.text"},"ts":1428092984000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"caitp: I've been down that road.","msgtype":"m.text"},"ts":1428092995000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"caitp: not my first rodeo with Jafar :)","msgtype":"m.text"},"ts":1428093004000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"so what is the big selling point for sticking with promises, other than \"we already shipped\"","msgtype":"m.text"},"ts":1428093047000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"they're a good abstraction. maybe not what you're used to if you come from C# and Rx.NET, but for people coming from many other languages, and from JavaScript itself, they're quite suitable.","msgtype":"m.text"},"ts":1428093100000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"buuuut you admit that you need to invent a new variant of them which actually covers all the use cases","msgtype":"m.text"},"ts":1428093130000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"which doesn't seem very good","msgtype":"m.text"},"ts":1428093135000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"why? why is it bad to extend something that exists instead of creating a whole new paradigm people have to learn and choose between?","msgtype":"m.text"},"ts":1428093157000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"sometimes you want an array, sometimes you want a map, sometimes you want a set","msgtype":"m.text"},"ts":1428093193000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think because you're still creating a new paradigm, it's just that people will confuse one for the other inadvertently","msgtype":"m.text"},"ts":1428093208000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Doesn't mean arrays suck and when we \"invented\" maps/sets that means arrays are not very good","msgtype":"m.text"},"ts":1428093212000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"analogy is imprecise since maps/sets are not a superset of arrays ... should have probably used iterables in there somewhere... but you get the idea.","msgtype":"m.text"},"ts":1428093238000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It's OK for multiple different-but-related things, with different powers, to exist to suit different use cases","msgtype":"m.text"},"ts":1428093262000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"it's closer to the ImmutableMap vs Map discussion","msgtype":"m.text"},"ts":1428093262000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"if people use ImmutableMap and Map interchangeably, they might have a problem","msgtype":"m.text"},"ts":1428093274000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"Sure, that's pretty good, I agree.","msgtype":"m.text"},"ts":1428093275000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"to be honest, there seemed many similarities between the Task and CancellablePromise concepts... they both ref counted users, etc","msgtype":"m.text"},"ts":1428093288000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Not quite a superset relation, but the different-but-similar tools for different situations is analogous","msgtype":"m.text"},"ts":1428093306000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"wanderview: oh? last I saw tasks refused to be called more than once","msgtype":"m.text"},"ts":1428093312000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I'm sure there are differences... but the promise extension being discussed seem closer to the Task thing","msgtype":"m.text"},"ts":1428093360000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: ah I see, they've changed since proposed at TC39 last week","msgtype":"m.text"},"ts":1428093376000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"\"proposed\"","msgtype":"m.text"},"ts":1428093382000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I agree they seem to have coevolved","msgtype":"m.text"},"ts":1428093429000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"The main difference at this point seems to be the C#-style separation between operation and subscription rather than the JavaScript-style both-in-one-object. Jafar is indeed not a fan of the JS style, whether it be for generators, iterators, or promises.","msgtype":"m.text"},"ts":1428093486000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think if we take his Task thing and adapt it to JS style it does end up being CancelablePromise.","msgtype":"m.text"},"ts":1428093496000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: maybe just call it something completely different and split the difference :-)  Its an Activity!  and an Activity is a Promise","msgtype":"m.text"},"ts":1428093528000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"haha","msgtype":"m.text"},"ts":1428093535000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"haven't heard Activity before, that's fun :)","msgtype":"m.text"},"ts":1428093545000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: oh... or its a Suggestion which extends Promise... Suggestions can be ignored","msgtype":"m.text"},"ts":1428093569000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"ah yes, the promises ecosystem needs more puns, definitely let's do that","msgtype":"m.text"},"ts":1428093587000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"stops \"helping\".","msgtype":"m.emote"},"ts":1428093598000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"is still sad it ended up being \"fulfilled\" and \"rejected\" instead of \"kept\" and \"broken\"","msgtype":"m.emote"},"ts":1428093600000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1428093610000,"senderName":"caitp","senderId":"caitp@irc"},
{"content":{"body":"new Promise((keep, break) => { /* oops SyntaxError :( */ })","msgtype":"m.text"},"ts":1428093643000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It all started with stringify. That was the start of the namepocalypse","msgtype":"m.text"},"ts":1428093674000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"its a sad truth that bikeshedding names is more fun than c++","msgtype":"m.text"},"ts":1428093752000,"senderName":"wanderview","senderId":"wanderview@irc"}
]