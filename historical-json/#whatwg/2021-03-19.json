[
{"content":{"body":"annevk: with FETCH/RT, I'm contemplating between the current approach (responseDone -> the caller calls FETCH.report) and an approach of passing initiatorType as a param to FETCH , and having FETCH report it instead of passing it as a param... this way in the HTML spec all we have to do is \"Fetch the request with initiatorType set to link\" and FETCH can report with that param and the request's client's global object","msgtype":"m.text"},"ts":1616149728000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: I think it's okay to add initiator type to request, though maybe we should call it legacy destination or some such to avoid more folks taking a dependency","msgtype":"m.text"},"ts":1616149866000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it's not really a legacy destination, it's the \"resource initiator type\" for Resource Timing","msgtype":"m.text"},"ts":1616149904000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: that would mean FETCH does all the reporting, and perhaps queues the task on the global object so that RT doesn't have to deal with that. Sounds good?","msgtype":"m.text"},"ts":1616149959000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: well, it is, but if RT was done today that wouldn't have been a thing is what I'm saying","msgtype":"m.text"},"ts":1616150409000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: yeah, I think that makes sense for all main thread callers of fetch","msgtype":"m.text"},"ts":1616150435000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: well, hmm, it depends a bit on the specifics of how we integrate all this, as e.g. I still think it makes sense that if the caller dispatches a load event, that happens in the same task","msgtype":"m.text"},"ts":1616150482000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"that is possible, to be clear, but it requires processResponseEndOfBody to be a superset of processResponseDone","msgtype":"m.text"},"ts":1616150510000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm thinking to do this outside the whole streams thing, and do it when there are no more bytes in the response. That way, it's done before those bytes are fed to the stream and processResponseEndOfBody is called","msgtype":"m.text"},"ts":1616150667000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"where I do reporting in my current PR, there is not really a real connection with processResponseEndOfBody, not sure why it needs to be a superset","msgtype":"m.text"},"ts":1616150769000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"can be HTTP receives bytes -> if no more bytes, report to RT and mark \"request done\" -> pass bytes to stream that the body consumer is reading","msgtype":"m.text"},"ts":1616150806000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: otherwise, I'd rather keep the current setup where the processResponseDone event is separate from streams","msgtype":"m.text"},"ts":1616151016000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: the way I was thinking about it is that if someone passes processResponseEndOfBody, and processResponseDone happens, we'd fully read and pass on the data as well as do the RT steps, and the caller would fire the load event from there; or are RT objects consistently created way before the load event?","msgtype":"m.text"},"ts":1616151492000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: it seems likely that implementations do things incrementally and once all bytes are in they'd create the RT object, update state, and fire the load event all at once","msgtype":"m.text"},"ts":1616151562000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: implementations set the response_end right when all the bytes come from the HTTP source, and report it at some unspecified time in the future, sometimes after a timer","msgtype":"m.text"},"ts":1616151808000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"ah `processResponseEndOfBody`, got confused with `processEndOfBody`. does any spec use that one?","msgtype":"m.text"},"ts":1616151930000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: I think it would be good to align the reporting with the load event","msgtype":"m.text"},"ts":1616151951000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"noamr: processEndOfBody is for body read algorithms only, right? XHR prolly does","msgtype":"m.text"},"ts":1616152018000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"(I was talking about the fetch algorithm itself)","msgtype":"m.text"},"ts":1616152045000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: XHR callse processEndOfBody","msgtype":"m.text"},"ts":1616152262000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"not processResponseEndOfBody","msgtype":"m.text"},"ts":1616152267000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"ah it uses processResponseEndOfBody for sync responses","msgtype":"m.text"},"ts":1616152312000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: right, I thought that's what you were asking. processResponseEndOfBody isn't used at the moment, but I would expect HTML to use that as HTML typically wants all the bytes in one go","msgtype":"m.text"},"ts":1616152316000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"oh right, XHR uses it too","msgtype":"m.text"},"ts":1616152324000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: so you're proposing the caller would report RT in its processResponseEndOfBody, or that FETCH would report RT right before calling processResponseEndOfBody if that exists? I'm a bit confused","msgtype":"m.text"},"ts":1616152424000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"annevk: we can do a thing where FETCH reports RT right before calling processResponseEndOfBody, otherwise report it at EOF, and in either case only if it has a \"resource initiator type\" as a FETCH param. but maybe instead we can keep the current design where the caller reports RT, and some callers can report in their  processResponseEndOfBody, leaviing processResponseDone for callers like fetch()","msgtype":"m.text"},"ts":1616152562000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"since from what you're saying seems like we might want to have callers do slightly different things so that reporting is synchornized with load events, maybe the latter would be best (keep current design and align with processResponseBodyEnd for some callers)","msgtype":"m.text"},"ts":1616152614000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: I think you got the idea, but I tend to agree that we should maybe only do this once we have a better understanding of the callers","msgtype":"m.text"},"ts":1616152697000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: yea, so for now the PR uses processResponseDone for fetch(), and XHR knows by itself when to report. Can we try to move forward with this, and iterate on the following callers?","msgtype":"m.text"},"ts":1616152800000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"most of the rest of the callers are not properly integrated with fetch","msgtype":"m.text"},"ts":1616152866000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: yeah I think so, I'm not sure I'll get to review today, I do have the hr-time proposal ready","msgtype":"m.text"},"ts":1616153149000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: cool. looking forward!","msgtype":"m.text"},"ts":1616153211000,"senderName":"noamr","senderId":"noamr@irc"},
{"content":{"body":"noamr: yoav: https://github.com/w3c/hr-time/pull/112","msgtype":"m.text"},"ts":1616153523000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Will look after lunch","msgtype":"m.emote"},"ts":1616154300000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"Merged!","msgtype":"m.text"},"ts":1616156106000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"I'll ping folks to get it published, so that it will get picked up by the bots","msgtype":"m.text"},"ts":1616156132000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"yoav: thanks, I guess I somehow convinced you of this approach since yesterday then? ðŸ™‚","msgtype":"m.text"},"ts":1616162299000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yeah, you did :)","msgtype":"m.text"},"ts":1616162332000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"I'm not convinced there's a real risk in storing timestamps in renderers, but seems fair to enable browsers to do so if they disagree","msgtype":"m.text"},"ts":1616162494000,"senderName":"yoav","senderId":"yoav@irc"},
{"content":{"body":"https://github.com/hyperium/hyper/issues/2470 Fascinating, I didn't think of that.","msgtype":"m.text"},"ts":1616164576000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"nox: heh, I wrote those tests very recently ðŸ™‚","msgtype":"m.text"},"ts":1616166093000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I assumed it was you :D","msgtype":"m.text"},"ts":1616166109000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"well, actually, I wrote a lot of them in 2018 and then recently got around to getting them merged","msgtype":"m.text"},"ts":1616166112000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"any browser that has implemented Sanitizer API under a flag as of now?","msgtype":"m.text"},"ts":1616193662000,"senderName":"howdoi","senderId":"howdoi@irc"},
{"content":{"body":"Also, there is no way to print the version on javascriptcore REPL?","msgtype":"m.text"},"ts":1616193687000,"senderName":"howdoi","senderId":"howdoi@irc"}
]