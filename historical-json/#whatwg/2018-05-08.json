[
{"content":{"body":"Why does HTMLLinkElement not have a boolean property \"disabled\" in the spec but has one in Gecko?","msgtype":"m.text"},"ts":1525769283000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: tracked by https://github.com/whatwg/html/issues/1081","msgtype":"m.text"},"ts":1525769622000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"hsivonen: seems nobody was motivated enough to figure out the mismatch thus far","msgtype":"m.text"},"ts":1525769637000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: sigh. seemingly simple stuff is complicated","msgtype":"m.text"},"ts":1525769781000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"annevk: thanks","msgtype":"m.text"},"ts":1525769788000,"senderName":"hsivonen","senderId":"hsivonen@irc"},
{"content":{"body":"hsivonen: JakeA: iirc https://github.com/whatwg/html/issues/3672 is of interest to you","msgtype":"m.text"},"ts":1525770672000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"yoav_: same","msgtype":"m.text"},"ts":1525770703000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: does From-Origin have any implications for http cache?  I guess if a server provides different From-Origin headers on the same URL at different times they would need to either block caching or use a Vary header?","msgtype":"m.text"},"ts":1525792231000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: if we go with my \"make it part of CORB\" proposal then no","msgtype":"m.text"},"ts":1525792328000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: at least not as CORB is currently specified","msgtype":"m.text"},"ts":1525792343000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: because it would be blocked before it reaches http cahce?","msgtype":"m.text"},"ts":1525792352000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I guess I was thinking CORB and From-Origin checking took place above http cache","msgtype":"m.text"},"ts":1525792372000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"actually... it seems From-Origin must be checked above http cache since multiple origins share the http cache","msgtype":"m.text"},"ts":1525792406000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: as currently proposed it's not above the http cache, but maybe we should change that","msgtype":"m.text"},"ts":1525792541000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: it's not entirely clear what the attack angle is though if networking is its own process without scripting","msgtype":"m.text"},"ts":1525792560000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: it seems bad if origin A requests a response with From-Origin:A, it goes into http cache, and then later origin B can get it out of the http cache","msgtype":"m.text"},"ts":1525792569000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: https://github.com/whatwg/fetch/pull/686#issuecomment-387432176","msgtype":"m.text"},"ts":1525792616000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: how would B be able to obtain a non-masked one though?","msgtype":"m.text"},"ts":1525792644000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: B would just get an empty response if the response had that header","msgtype":"m.text"},"ts":1525792664000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I'm sorry... what makes it an empty response?","msgtype":"m.text"},"ts":1525792722000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"I don't understand why it would be an empty response coming out of http cache if the From-Origin check is done below http cache... if it made it to http cache as a full repsonse, what converts it to empty pulling it out of cache?","msgtype":"m.text"},"ts":1525792874000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: the CORB processing model if it incorporates From-Origin","msgtype":"m.text"},"ts":1525792898000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"main fetch -> CORB stuff -> service worker / network / cache","msgtype":"m.text"},"ts":1525792926000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: surely that is main fetch -> CORB stuff -> service worker -> CORB stuff -> network/cache... right?","msgtype":"m.text"},"ts":1525793031000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but ok","msgtype":"m.text"},"ts":1525793125000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: if the service worker invokes main fetch again, yeah","msgtype":"m.text"},"ts":1525793260000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ok, that model makes more sense to me","msgtype":"m.text"},"ts":1525793303000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"and the server can avoid issues with differing headers using Vary","msgtype":"m.text"},"ts":1525793318000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Domenic: note that I'm not totally opposed to always serialize before processing URLs (some browsers also do it for about:blank), but it does seem a little weird","msgtype":"m.text"},"ts":1525793504000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: hmm I don't really get your point. data:, javascript:, and std: are all cases where you want to process \"stuff after the scheme\"","msgtype":"m.text"},"ts":1525793546000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: but we could embrace it and just accept things get a little weird with relative URLs and such","msgtype":"m.text"},"ts":1525793548000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"URL Standard doesn't have a concept of \"stuff after scheme\" so you can either serialize + strip leading scheme: or you can try to process path[0] + ? + query + # + fragment","msgtype":"m.text"},"ts":1525793574000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think there are lots of such URLs, not legacy","msgtype":"m.text"},"ts":1525793592000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"E.g. blob is also like that I think?","msgtype":"m.text"},"ts":1525793601000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"mailto:","msgtype":"m.text"},"ts":1525793607000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"etc.","msgtype":"m.text"},"ts":1525793608000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: the question is whether javascript://somehost/%0Aalert(1) should work or not; same for these other URLs","msgtype":"m.text"},"ts":1525793626000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hmm I see","msgtype":"m.text"},"ts":1525793645000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: and use them as base URL, etc.","msgtype":"m.text"},"ts":1525793647000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Well the way I'm doing it now is the same as for data: URLs. You parse, then serialize, then strip leading scheme:","msgtype":"m.text"},"ts":1525793668000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: I tend to see that as somewhat problematic that it works","msgtype":"m.text"},"ts":1525793669000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"It seems reasonable to me; the alternative is treating these as opaque strings where URL decoding doesn't work. Which is weird if we call them URLs.","msgtype":"m.text"},"ts":1525793693000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I think it goes against the spirit of the RFCs somewhat","msgtype":"m.text"},"ts":1525793794000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"new Promise(resolve => resolve()).then(foo) guarantees that foo is called after the current code has run  to completion, right?","msgtype":"m.text"},"ts":1525793809000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"And it also makes our object-based approach rather convoluted (except we need it for blobs somewhat)","msgtype":"m.text"},"ts":1525793823000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: yeah, think so","msgtype":"m.text"},"ts":1525793837000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Ms2ger: Promise.resolve().then(foo) also works fwiw","msgtype":"m.text"},"ts":1525793896000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Oh, neat","msgtype":"m.text"},"ts":1525793908000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"},
{"content":{"body":"annevk: hmm I don't really understand this spirit of the RFCs thing.","msgtype":"m.text"},"ts":1525794254000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Also maybe I misunderstood.","msgtype":"m.text"},"ts":1525794258000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"javascript://somehost/%0Aalert(1) would work if we used URL components (e.g. path[0]). But it wouldn't work if we did serialize-then-strip.","msgtype":"m.text"},"ts":1525794287000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"And it seems better (more RFC-ey, even) for it to not work?","msgtype":"m.text"},"ts":1525794306000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It does work with serialize-then-strip","msgtype":"m.text"},"ts":1525794321000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"how so?","msgtype":"m.text"},"ts":1525794328000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Oh becaues of the // lol","msgtype":"m.text"},"ts":1525794331000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"It wouldn't work if we aborted if host was non-null","msgtype":"m.text"},"ts":1525794340000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I see","msgtype":"m.text"},"ts":1525794356000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"I guess this is probably worth a more general issue discussed with a wider community. Plus maybe API affordances if we figure something out. I think I understand enough to open such an issue now.","msgtype":"m.text"},"ts":1525794390000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"That'd be great, I was thinking along similar lines","msgtype":"m.text"},"ts":1525794403000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"We should indeed just enshrine the pattern set by data/javascript and either label it legacy or \"this is what we do\"","msgtype":"m.text"},"ts":1525794425000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"E.g., it'd make more sense if the serialize had a way to omit the scheme too for this kind of thing","msgtype":"m.text"},"ts":1525794458000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Yeah exactly","msgtype":"m.text"},"ts":1525794494000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: copy mnot maybe?","msgtype":"m.text"},"ts":1525794504000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"good idea","msgtype":"m.text"},"ts":1525794510000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"biab","msgtype":"m.text"},"ts":1525794514000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Posted https://github.com/whatwg/url/issues/385","msgtype":"m.text"},"ts":1525796008000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"\\o/","msgtype":"m.text"},"ts":1525797327000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Whenever someone says again that you can’t just deprecate existing APIs in the browser from one day to another...","msgtype":"m.text"},"ts":1525817639000,"senderName":"justJanne","senderId":"justJanne@irc"},
{"content":{"body":"...I’ll link https://arstechnica.com/gaming/2018/05/chromes-autoplay-video-blocker-is-accidentally-killing-web-based-games/","msgtype":"m.text"},"ts":1525817643000,"senderName":"justJanne","senderId":"justJanne@irc"},
{"content":{"body":"specifically, Chrome’s WebAudio autoplay restrictions in recent versions breaking tons of sites","msgtype":"m.text"},"ts":1525817667000,"senderName":"justJanne","senderId":"justJanne@irc"},
{"content":{"body":"> To get around this, Web-based games now have to actively restart that pre-loaded audio object when the player makes an action to start the game, even if that audio wasn't autoplaying beforehand.","msgtype":"m.text"},"ts":1525818071000,"senderName":"laughinghan","senderId":"laughinghan@irc"},
{"content":{"body":"that's an interesting choice. Is there a Chromium ticket with discussion of why they couldn't go with something less disruptive?","msgtype":"m.text"},"ts":1525818102000,"senderName":"laughinghan","senderId":"laughinghan@irc"},
{"content":{"body":"e.g. enabling the audio object once the player has made one of the actions they've instrumented without requiring restarting the object?","msgtype":"m.text"},"ts":1525818197000,"senderName":"laughinghan","senderId":"laughinghan@irc"}
]