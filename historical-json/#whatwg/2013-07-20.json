[
{"content":{"body":"man, it's one thing for people to top-post in e-mail","msgtype":"m.text"},"ts":1374278497000,"senderName":"Hixie_","senderId":"Hixie_@irc"},
{"content":{"body":"but in bugs?!","msgtype":"m.text"},"ts":1374278501000,"senderName":"Hixie_","senderId":"Hixie_@irc"},
{"content":{"body":"really?!","msgtype":"m.text"},"ts":1374278502000,"senderName":"Hixie_","senderId":"Hixie_@irc"},
{"content":{"body":"trim your fricking context people","msgtype":"m.text"},"ts":1374278520000,"senderName":"Hixie_","senderId":"Hixie_@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1374278529000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"i'm slowly caring less about top-posting in email, mostly because of mobile where editing quotes is just not happening","msgtype":"m.text"},"ts":1374278540000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"is it possible to fire function while image is loading and then another function when image is loaded","msgtype":"m.text"},"ts":1374279558000,"senderName":"galant","senderId":"galant@irc"},
{"content":{"body":"I want to do this, create img element assign src new image which is not loaded check when image is loaded then make another image that is loaded src attribute to be src of the first image, is this good idea?  because I want to put another image when is loaded into src attribute of another imageto change images in img element but when second is fully loaded","msgtype":"m.text"},"ts":1374279829000,"senderName":"galant","senderId":"galant@irc"},
{"content":{"body":"can I do something like this, element1.parentNode.element2 ?","msgtype":"m.text"},"ts":1374311180000,"senderName":"galant","senderId":"galant@irc"},
{"content":{"body":"It's impossible for a DOCTYPE token's name to be an empty string, right?","msgtype":"m.text"},"ts":1374342962000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"(It's either missing or non-empty.)","msgtype":"m.text"},"ts":1374342968000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"Domenic_: understood, but DOM Promises have their own way, okay? (via the Resolver interface passed to ctor's function argument)","msgtype":"m.text"},"ts":1374346173000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"ondras_: DOM promises do it one way, the same way RSVP and then/promise and other Promises/A+ implementations do---all of those pass resolving abilities to the constructors function argument. Q has both deferreds and `Q.promise` which is something like the promise constructor. I don't know of any popular Promises/A+ libraries that put the ability to resolve,","msgtype":"m.text"},"ts":1374347448000,"senderName":"Domenic_","senderId":"Domenic_@irc"},
{"content":{"body":"fulfill, or reject directly on the promise---that's bad practice, since it prohibits you from separating the right to resolve a promise from the right to react to it via `then`.","msgtype":"m.text"},"ts":1374347448000,"senderName":"Domenic_","senderId":"Domenic_@irc"},
{"content":{"body":"Domenic_: while the separation makes sense, the approach with callback-as-ctor-argument looks ugly to me","msgtype":"m.text"},"ts":1374348437000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"i.e. a typical promise producent in my scenario","msgtype":"m.text"},"ts":1374348462000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"has an async method","msgtype":"m.text"},"ts":1374348467000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"X.prototype.doStuff = function() { this._promise = new Promise(); ...; return this._promise; }","msgtype":"m.text"},"ts":1374348496000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"which, using the pattern described above, needs to look like...","msgtype":"m.text"},"ts":1374348587000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"doStuff = function() { var p = new Promise(function(r) { this._resolver=r; }); ...; return  p; }","msgtype":"m.text"},"ts":1374348616000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"not very readable imho","msgtype":"m.text"},"ts":1374348623000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"ondras_: you seem to be claiming subjective readability is more important than security... that's not really going to work for a foundational web platform standard.","msgtype":"m.text"},"ts":1374349221000,"senderName":"Domenic_","senderId":"Domenic_@irc"},
{"content":{"body":"Domenic_: okay, well, then the promises/a+ shall perhaps somehow accent that? my impl was based solely on a+ and the spec did not have any hints about how the fulfillment/rejection shall be handled, so I took the (in my opinion) most straightforward approach...","msgtype":"m.text"},"ts":1374349575000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"(also because security is not that great deal for me - my promise's consumer is never going to manipulate its state, even if the api de facto allows that)","msgtype":"m.text"},"ts":1374349629000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":"ondras_: Promises/A+ core spec is focused on the minimal amount necessary for interoperability, and that's a `then` method. Kind of the point of it is to not be very prescriptive about promise creation. It's totally fine for Promises/A+ implementations to be insecure; that way people who find it more readable that way, and don't value security, can use such","msgtype":"m.text"},"ts":1374349946000,"senderName":"Domenic_","senderId":"Domenic_@irc"},
{"content":{"body":"an insecure implementation---but because it conforms to Promises/A+, it's interoperable with everyone else's implementation, just by virtue of having a well-behaved `then` method!","msgtype":"m.text"},"ts":1374349946000,"senderName":"Domenic_","senderId":"Domenic_@irc"},
{"content":{"body":"ondras_: the upcoming Promises/A+ 1.1 revision tries to explain this in the readme a bit better. https://github.com/promises-aplus/promises-spec#promisesa","msgtype":"m.text"},"ts":1374350006000,"senderName":"Domenic_","senderId":"Domenic_@irc"},
{"content":{"body":"Domenic_: okay then, thanks for explanation!","msgtype":"m.text"},"ts":1374350336000,"senderName":"ondras_","senderId":"ondras_@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1374350457000,"senderName":"Domenic_","senderId":"Domenic_@irc"},
{"content":{"body":"can Google web dev tools slows the oppening of webpage? becasue after I uploaded their file to my server the page is opening little slower, I am not sure if it is because of their link or what","msgtype":"m.text"},"ts":1374350909000,"senderName":"galant","senderId":"galant@irc"},
{"content":{"body":"sry google webmaster tools","msgtype":"m.text"},"ts":1374350931000,"senderName":"galant","senderId":"galant@irc"},
{"content":{"body":"I'm confused about some tree construction in the HTML spec, am I in the right place?","msgtype":"m.text"},"ts":1374353916000,"senderName":"nolanw","senderId":"nolanw@irc"},
{"content":{"body":"nolanw: yes, although I probably canâ€™t answer myself","msgtype":"m.text"},"ts":1374353966000,"senderName":"SimonSapin","senderId":"SimonSapin@irc"},
{"content":{"body":"alright cool. Suppose I'm parsing the markup `<table><math>` and I get to the start tag named \"math\" in tree construction","msgtype":"m.text"},"ts":1374354387000,"senderName":"nolanw","senderId":"nolanw@irc"},
{"content":{"body":"the spec says \"insert a foreign element for the token\"","msgtype":"m.text"},"ts":1374354403000,"senderName":"nolanw","senderId":"nolanw@irc"},
{"content":{"body":"the current node is the `table` node, but in the description of inserting a foreign element it says \"the current node, when the insert a foreign element algorithm is invoked, is always itself a non-HTML element\"","msgtype":"m.text"},"ts":1374354426000,"senderName":"nolanw","senderId":"nolanw@irc"},
{"content":{"body":"so my question is: does the element I insert for the `<math>` token undergo foster parenting?","msgtype":"m.text"},"ts":1374354456000,"senderName":"nolanw","senderId":"nolanw@irc"}
]