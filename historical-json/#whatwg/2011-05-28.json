[
{"content":{"body":"Hixie: ping","msgtype":"m.text"},"ts":1306548600000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Hixie: just so that i answer the right question. In the email about how to use the boolean property I am proposing for websockets, are you asking how you use this in general (i.e. does the question also apply to .binaryType), or how you use my proposed property specifically?","msgtype":"m.text"},"ts":1306548660000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Philip`: (No, it's just CPU-time iterating over the tree and mutating it mostly. Well, that and parsing/serializing.)","msgtype":"m.text"},"ts":1306550040000,"senderName":"gsnedders","senderId":"gsnedders@irc"},
{"content":{"body":"interesting to see Guha posting to the whatwg list","msgtype":"m.text"},"ts":1306564320000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"hey MikeSmith","msgtype":"m.text"},"ts":1306565580000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"hey man","msgtype":"m.text"},"ts":1306565581000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"how are things?","msgtype":"m.text"},"ts":1306565760000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"word","msgtype":"m.text"},"ts":1306566540000,"senderName":"JonathanNeal","senderId":"JonathanNeal@irc"},
{"content":{"body":"othermaciej: things is OK. working on my inbox. e-mail is a curse","msgtype":"m.text"},"ts":1306567320000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"MikeSmith: I feel a lot better now that I had a valium and half a bottle of wine","msgtype":"m.text"},"ts":1306567380000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"heh","msgtype":"m.text"},"ts":1306567440000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"sicking: i am asking how you expect the script code to look if not all text messages are guaranteed to be just strings","msgtype":"m.text"},"ts":1306567441000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"othermaciej: if I lived in CA I would medicate with more than valium","msgtype":"m.text"},"ts":1306567500000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"damn, I should get a prescription","msgtype":"m.text"},"ts":1306567501000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"Hixie: once you know that the next message is going to contain something which you want to store as a blob, set the .getAsBlob to true, wait for onmessage, set it back to false","msgtype":"m.text"},"ts":1306567560000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Hixie: I don't see any difference between binary and textual data","msgtype":"m.text"},"ts":1306567561000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: that seems very brittle.","msgtype":"m.text"},"ts":1306567562000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: after all, text data is just a special case of binary data","msgtype":"m.text"},"ts":1306567563000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Hixie: how so?","msgtype":"m.text"},"ts":1306567564000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: the difference is that with doing this only for binary, you can just always use text frames as the frame that warns you what you're expecting next","msgtype":"m.text"},"ts":1306567620000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: that only works if the other side is listening for that","msgtype":"m.text"},"ts":1306567621000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: ?","msgtype":"m.text"},"ts":1306567622000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: that only works if the other side listens for messages containing whatever it is that you're putting in your text message that tells it to put the .binaryType back","msgtype":"m.text"},"ts":1306567680000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Hixie: i don't see why that is less brittle","msgtype":"m.text"},"ts":1306567681000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"othermaciej: can get a prescription in ten minutes from the doctor office right next to the dispensary. you got enough stress to merit one","msgtype":"m.text"},"ts":1306567682000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Hixie: i'm still not sure what code you're worried about people are going to write that will break","msgtype":"m.text"},"ts":1306567740000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"JonathanNeal: hi ho","msgtype":"m.text"},"ts":1306567741000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"Hixie: so i'm not sure why you think it's brittle","msgtype":"m.text"},"ts":1306567742000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: if your protocol is normally text frames, except with a few binary frames like \"here's the user's profile pic\" (want as blob) or \"here's the game map\" (want as arraybuffer) then you just wait for the message that warns you the next message is a profile pic or game map, and set binaryType accordingly","msgtype":"m.text"},"ts":1306567743000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"sicking: and if the server burps and says \"here's a profile pic\" and never sends it, or \"here's a game map\" and sends two, it's not a big deal, because you'll \"resync\" with the next text message","msgtype":"m.text"},"ts":1306567800000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: what's to say that people will want to use text frames for the \"normal\" messages?","msgtype":"m.text"},"ts":1306567801000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: if they're using only binary frames then binaryType is doomed just like what you're proposing","msgtype":"m.text"},"ts":1306567802000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: if that happens it seems like you have pretty bad problems. Whatever state machine is used on the client is bound to break","msgtype":"m.text"},"ts":1306567860000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Hixie: how do you mean?","msgtype":"m.text"},"ts":1306567861000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"\"doomed just like what you're proposing\"?","msgtype":"m.text"},"ts":1306567862000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: you can make it quite resistent if the protocol uses text frames for state messages and that doesn't interact with binaryType, since you always get the text frames, they are never hidden in blobs or whatnot","msgtype":"m.text"},"ts":1306567920000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"sicking: i mean brittle","msgtype":"m.text"},"ts":1306567921000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"sicking: easy to get out of sync if you have the slightest bug","msgtype":"m.text"},"ts":1306567922000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: one option is to make the flag \"i want the next frame to be a blob, and only the next frame\", rather than \"I want all following frames to be blobs\". I don't know if that addresses your concern though as I still don't understand it","msgtype":"m.text"},"ts":1306567923000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: send two profile pics in a row instead of warning frame, profile pic frame, warning frame, profile pic frame, and now you're off by one on the receiving side and you'll treat every profile pic as a control message and every control message as a profile pic (or whatever) and get royally confused","msgtype":"m.text"},"ts":1306567980000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"MikeSmith: you seem to know a lot about this topic","msgtype":"m.text"},"ts":1306567981000,"senderName":"othermaciej","senderId":"othermaciej@irc"},
{"content":{"body":"Hixie: that seems to be the case even if you aren't using blobs at all","msgtype":"m.text"},"ts":1306567982000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: yes, that would address my concern, but it wouldn't make the api simpler","msgtype":"m.text"},"ts":1306567983000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"othermaciej: I read about it on Wikipedia","msgtype":"m.text"},"ts":1306567984000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"sicking: if you're using text frames for control then you can't get out of sync: you'll always get the control frames, even if the binary frames are messed up","msgtype":"m.text"},"ts":1306568040000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"sicking: btw, converting a string to blob doesn't seem hugely useful. you'd have to specify an encoding, or assume utf-8; it wouldn't give you anything that you couldn't get just by having the server send you the text in a binary blob","msgtype":"m.text"},"ts":1306568041000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: why wouldn't you end up putting the control-string as profile picture and then try to read control data out of the binary profile picture?","msgtype":"m.text"},"ts":1306568100000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: what?","msgtype":"m.text"},"ts":1306568101000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: if the state machine on the server and on the client get out of sync, why wouldn't it be a jumble no matter what?","msgtype":"m.text"},"ts":1306568160000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: you don't need a state machine if the text frames are control","msgtype":"m.text"},"ts":1306568161000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"sicking: every text frame always is a control frame","msgtype":"m.text"},"ts":1306568162000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: that seems to be entirely up to the page","msgtype":"m.text"},"ts":1306568163000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"sicking: sure","msgtype":"m.text"},"ts":1306568220000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"sicking: it's impossible if you do it your way though","msgtype":"m.text"},"ts":1306568221000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: what is impossible?","msgtype":"m.text"},"ts":1306568222000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"having a system that always resets with a text frame","msgtype":"m.text"},"ts":1306568223000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: no, you just always reset on the next frame","msgtype":"m.text"},"ts":1306568280000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"that seems even simpler","msgtype":"m.text"},"ts":1306568281000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"doesn't that mean that we completely lose the entire point of the feature from the browser's perspective? i mean, if it keeps getting reset there's no way for the browser to know ahead of time what to do with incoming data","msgtype":"m.text"},"ts":1306568340000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"MikeSmith: hi ho back :D","msgtype":"m.text"},"ts":1306568341000,"senderName":"JonathanNeal","senderId":"JonathanNeal@irc"},
{"content":{"body":"well, you don't reset if you know that the next frame is something you want as a blob","msgtype":"m.text"},"ts":1306568400000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Hixie: i think i still need to see some sort of code to fully understand the type of bugs you are concerned about. I'm a little bit guessing in the dark here it feels like","msgtype":"m.text"},"ts":1306568460000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"telling the browser what to do with a message before you have it seems like it would be hard to pipeline; seems like it'd make more sense for each message to have a text (or json, or whatever; an HTTP-header-analog) part at the beginning; the browser calls a callback when it receives it, asking what to do with the \"body\" of the message","msgtype":"m.text"},"ts":1306568700000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"\"It would be much easier to do if you guys would simply say when you couldn't implement the spec as written.\"","msgtype":"m.text"},"ts":1306568820000,"senderName":"yuhong","senderId":"yuhong@irc"},
{"content":{"body":"Well, you see, most of the differences between the modes are related to *CSS*, not HTML>","msgtype":"m.text"},"ts":1306568880000,"senderName":"yuhong","senderId":"yuhong@irc"},
{"content":{"body":"Well, you see, most of the differences between the modes are related to *CSS*, not HTML.","msgtype":"m.text"},"ts":1306568881000,"senderName":"yuhong","senderId":"yuhong@irc"},
{"content":{"body":"If you hasn't guessed, this is from :http://lists.w3.org/Archives/Public/public-html/2007Apr/0637.html","msgtype":"m.text"},"ts":1306568882000,"senderName":"yuhong","senderId":"yuhong@irc"},
{"content":{"body":"zewt: by the time you've received the message it's too late. even doing it on the previous message is probably too late, really.","msgtype":"m.text"},"ts":1306569120000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: the more I think about it, the more I like the idea of having an automatically resetting property. As you pointed out, blobs are mostly useful if you aren't going to touch all of the data right away anyway which is likely the exception","msgtype":"m.text"},"ts":1306569240000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"http://damowmow.com/playground/demos/websocket/ideas/001.txt","msgtype":"m.text"},"ts":1306569300000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"with some protocols, everything will need to be treated as blob","msgtype":"m.text"},"ts":1306569301000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: that goes even if we go for supporting blobs for textual data or not","msgtype":"m.text"},"ts":1306569302000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"e.g. if you're using WebSocket to populate an image cache in IndexDB","msgtype":"m.text"},"ts":1306569303000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"or to download samples for sound effects","msgtype":"m.text"},"ts":1306569304000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"or whatnot","msgtype":"m.text"},"ts":1306569360000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"there's all kinds of cases where you only want binary data as blobs","msgtype":"m.text"},"ts":1306569361000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"it would be a perf disaster if the UA always treated those as array buffer until the last minute","msgtype":"m.text"},"ts":1306569362000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: so do you expect that to be the common case, or a rare case? It's still supported to get all as blobs, you just set the property in every onmessage.","msgtype":"m.text"},"ts":1306569363000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"i have no data on which is likely to be more common, but i expect that all array buffer, all blob, and highly mixed are going to all be common","msgtype":"m.text"},"ts":1306569364000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: from an implementation point of view, switching from in-memory to blob is the nice way of switching anyway","msgtype":"m.text"},"ts":1306569365000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Hixie: you don't need the whole message, just a header; while the browser is passing the header to a script and waiting for a response, the rest of the message is just buffering in the TCP stack","msgtype":"m.text"},"ts":1306569420000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Hixie: most likely that's what you'll end up doing anyway since the socket layer will keep the data in memory until it can be sent to the main thread","msgtype":"m.text"},"ts":1306569421000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"if you can switch from in-memory to blob, we should just expose both as getters (and you get whichever you call first)","msgtype":"m.text"},"ts":1306569422000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"of course, that requires the protocol to have separate header/body data, like HTTP, which this protocol may not have","msgtype":"m.text"},"ts":1306569423000,"senderName":"zewt","senderId":"zewt@irc"},
{"content":{"body":"Hixie: Why wasn't full SGML DOCTYPE parsing (one that do not consider > as the end of the declaration regardless of whether it is inside []) made it into HTML5?","msgtype":"m.text"},"ts":1306569424000,"senderName":"yuhong","senderId":"yuhong@irc"},
{"content":{"body":"if you receive a GB frame, you almost certainly want the network layer to send it straight to disk","msgtype":"m.text"},"ts":1306569425000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: it's not a matter of what can be implemented. It's what can be implemented efficently","msgtype":"m.text"},"ts":1306569426000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"Hixie: Old Mozilla supported it.","msgtype":"m.text"},"ts":1306569427000,"senderName":"yuhong","senderId":"yuhong@irc"},
{"content":{"body":"yuhong: what's the use case?","msgtype":"m.text"},"ts":1306569480000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"sicking: i need to head to bed, but happy to continue this on the thread.","msgtype":"m.text"},"ts":1306569481000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: Of course, since HTML5 is not based on SGML, it would be silly for it to have any meaning.","msgtype":"m.text"},"ts":1306569482000,"senderName":"yuhong","senderId":"yuhong@irc"},
{"content":{"body":"Hixie: sounds good","msgtype":"m.text"},"ts":1306569483000,"senderName":"sicking","senderId":"sicking@irc"},
{"content":{"body":"ttyl","msgtype":"m.text"},"ts":1306569484000,"senderName":"Hixie","senderId":"Hixie@irc"},
{"content":{"body":"Hixie: BTW, on SGML comments, Arjun Ray complained about the \"incorrect\" parsing long before 1999.","msgtype":"m.text"},"ts":1306569540000,"senderName":"yuhong","senderId":"yuhong@irc"},
{"content":{"body":"Arjun has an old test page with the HTML 2.0 DOCTYPE.","msgtype":"m.text"},"ts":1306569600000,"senderName":"yuhong","senderId":"yuhong@irc"},
{"content":{"body":"Hixie: I think in the source for the the W3C version of the spec, you're missing closing brace for the checkFeedbackForm(form) function","msgtype":"m.text"},"ts":1306574880000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"unless it's caused by some edit I made to the WD","msgtype":"m.text"},"ts":1306574881000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"anyway, I'm fixing it in the TR LCWD copy of the spec","msgtype":"m.text"},"ts":1306574940000,"senderName":"MikeSmith","senderId":"MikeSmith@irc"},
{"content":{"body":"blames MikeSmith ","msgtype":"m.emote"},"ts":1306577280000,"senderName":"Ms2ger","senderId":"Ms2ger@irc"}
]