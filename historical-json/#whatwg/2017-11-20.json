[
{"content":{"body":"Domenic: At least Servo and Gecko have [Foo = \"bar\"] custom IDL attributes.","msgtype":"m.text"},"ts":1511136189000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"Don't know about other vendors, but at least for those it wouldn't be a problem extending WebIDL right now.","msgtype":"m.text"},"ts":1511136228000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"huh, this looks like a positive change","msgtype":"m.text"},"ts":1511136493000,"senderName":"KiChjang","senderId":"KiChjang@irc"},
{"content":{"body":"i've encountered this footgun before","msgtype":"m.text"},"ts":1511136507000,"senderName":"KiChjang","senderId":"KiChjang@irc"},
{"content":{"body":"where the content attribute != the webidl attribute","msgtype":"m.text"},"ts":1511136534000,"senderName":"KiChjang","senderId":"KiChjang@irc"},
{"content":{"body":"That's still true though.","msgtype":"m.text"},"ts":1511136570000,"senderName":"nox","senderId":"nox@irc"},
{"content":{"body":"albeit it's surfaced up at the webidl level","msgtype":"m.text"},"ts":1511137044000,"senderName":"KiChjang","senderId":"KiChjang@irc"},
{"content":{"body":"instead of being hidden in the HTML spec somewhere","msgtype":"m.text"},"ts":1511137057000,"senderName":"KiChjang","senderId":"KiChjang@irc"},
{"content":{"body":"so this is fun... apparently a lot of animated GIFs are missing the block terminator byte of the Application Extension Block","msgtype":"m.text"},"ts":1511139566000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"presumably because the spec forgets to define its contents (despite mentioning that the byte exists)","msgtype":"m.text"},"ts":1511139583000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"...that can't be right","msgtype":"m.text"},"ts":1511139838000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"i've read the figure element description, but it's not clear if it's correct to use a <figure><img> inside an index of posts","msgtype":"m.text"},"ts":1511149766000,"senderName":"jolvera","senderId":"jolvera@irc"},
{"content":{"body":"since the image is self-contained in it's own list of articles","msgtype":"m.text"},"ts":1511149777000,"senderName":"jolvera","senderId":"jolvera@irc"},
{"content":{"body":"since the image is self-contained on each item from the list of articles*","msgtype":"m.text"},"ts":1511149796000,"senderName":"jolvera","senderId":"jolvera@irc"},
{"content":{"body":"e.g., https://cl.ly/1i2T0y2X2Y0e","msgtype":"m.text"},"ts":1511149851000,"senderName":"jolvera","senderId":"jolvera@irc"},
{"content":{"body":"what would be better, figure>img or aside>img ?","msgtype":"m.text"},"ts":1511149876000,"senderName":"jolvera","senderId":"jolvera@irc"},
{"content":{"body":"jolvera: Those don't look like figures to me; nothing else in the document references them by saying e.g. figure 1.2","msgtype":"m.text"},"ts":1511153742000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"oh, makes sense, thanks!","msgtype":"m.text"},"ts":1511153789000,"senderName":"jolvera","senderId":"jolvera@irc"},
{"content":{"body":"hmm... it seems perhaps I have been misinterpreting the GIF spec when it comes to block terminators...","msgtype":"m.text"},"ts":1511155509000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"},
{"content":{"body":"annevk: If data is to be persisted across browser restarts, the correct way to do this is to associate it with a https://storage.spec.whatwg.org/#bucket, right? As in, we should attach both service worker registrations and cache storages off buckets.","msgtype":"m.text"},"ts":1511185121000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: yeah, I haven't really defined a hook for it as I don't know what it should look like","msgtype":"m.text"},"ts":1511185292000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: but that's exactly the kind of thing we need to be doing across quite a few specs to make sure Clear-Site-Data and storage.clear() end up being well-defined","msgtype":"m.text"},"ts":1511185316000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: and persistence, yeah. I guess \"A bucket has an associated cache storage\" is good enough.","msgtype":"m.text"},"ts":1511185440000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I guess the question is whether you need any kind of cleanup hooks","msgtype":"m.text"},"ts":1511185512000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: I think IDB does","msgtype":"m.text"},"ts":1511185516000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: so we might want something where you reserve space with some \"spec callbacks\" that get invoked as things happen","msgtype":"m.text"},"ts":1511185559000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Yeah. \"Add the following steps to bucket's cleanup steps:\". Dunno if we need them for service worker or the cache api.","msgtype":"m.text"},"ts":1511185602000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I guess the problem with that is the order of callback steps isn't clear, should it ever become observable","msgtype":"m.text"},"ts":1511185650000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: the other slight problem with \"y has an associated x\" is that clearing y doesn't mean x is gone","msgtype":"m.text"},"ts":1511185657000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: it's probably clear enough and certainly better than what we have, but doesn't quite feel proper yet","msgtype":"m.text"},"ts":1511185678000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: wouldn't GC rules apply here? If the bucket is gone, and there are no JS references remaining, the underlying data can no longer be accessed.","msgtype":"m.text"},"ts":1511185728000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I guess that depends on whether the bucket is replaced or emptied","msgtype":"m.text"},"ts":1511185788000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: if we define clear() as replacing that would indeed be fine","msgtype":"m.text"},"ts":1511185804000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: ah I assumed it was replacing. Gotcha.","msgtype":"m.text"},"ts":1511185825000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: currently https://w3c.github.io/webappsec-clear-site-data/ doesn't mention buckets at all, so I guess it can go either way","msgtype":"m.text"},"ts":1511185860000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: updated https://github.com/whatwg/storage/issues/18 with this conversation","msgtype":"m.text"},"ts":1511186404000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: bleh, sorry for missing that issue way back. (Going to review https://github.com/whatwg/fetch/issues/631#issuecomment-344583026 today)","msgtype":"m.text"},"ts":1511186495000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: don't worry, I would have bothered you more if it was high priority","msgtype":"m.text"},"ts":1511186561000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: in regards to GC semantics... i think some operations are more immediate... like the user purposefully deleting storage for an origin (even if that site is open at the moment)","msgtype":"m.text"},"ts":1511189542000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I think from a theoretical perspective that could still be modeled as GC though","msgtype":"m.text"},"ts":1511189629000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: we disconnect Cache objects even if referenced by js and they start rejecting if the user does that","msgtype":"m.text"},"ts":1511189654000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: same for service worker registrations?","msgtype":"m.text"},"ts":1511189701000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: we are not as good about those, but yes, we should be treating them as quota storage and purge atomically with Cache/IDB/etc","msgtype":"m.text"},"ts":1511189732000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: but there you cannot observe a clear operation?","msgtype":"m.text"},"ts":1511189761000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: we've gotten some privacy related bugs from people reporting this stuff still exists after they click the \"clear storage\" button, so we are trying to be more aggressive about it","msgtype":"m.text"},"ts":1511189765000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: honestly I'm not sure what we do in that case... if a page is controlled by a service worker when the service worker is purged by the user...  maybe we should make it uncontrolled... right now I think we leave it controlled and it ends up reinstalling its scripts right away","msgtype":"m.text"},"ts":1511189824000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: oh","msgtype":"m.text"},"ts":1511189859000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I guess this does argue for making it explicit how clearance is handled","msgtype":"m.text"},"ts":1511189881000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"a user purge should probably be more immediate than a normal unregister() call, IMO","msgtype":"m.text"},"ts":1511189901000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: it's not just user, soon it's also receiving an HTTP header or invoking storage.clear()","msgtype":"m.text"},"ts":1511189929000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I think maybe we changed our storage purge stuff recently to do an unregister() and then wait until the SW leaves to declare itself complete... that can delay the purge a long time","msgtype":"m.text"},"ts":1511189934000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: ideally those all use the same path","msgtype":"m.text"},"ts":1511189936000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"header yes","msgtype":"m.text"},"ts":1511189960000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"not sure about storage.clear() when it comes to service workers","msgtype":"m.text"},"ts":1511189969000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but I am just getting my first cup of coffee..","msgtype":"m.text"},"ts":1511189983000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I guess the privacy related bugs are worth calling out in a section, but if they don't touch upon observable behavior from sites it's less important that the spec covers that in detail I think","msgtype":"m.text"},"ts":1511190059000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: conceivably we could have UX that says \"you are clearing storage for these sites, we need to close these windows to perform this operation\"...","msgtype":"m.text"},"ts":1511190104000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I think Clear-Site-Data does have something like refresh associated with it","msgtype":"m.text"},"ts":1511190152000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: that's probably what you need with service worker registrations to properly do it","msgtype":"m.text"},"ts":1511190169000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"that would be interetsing... if we had that for Clear-Site-Data then we could just reuse it for the browser UX to manually clear storage","msgtype":"m.text"},"ts":1511190199000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"Re: https://github.com/w3c/web-platform-tests/issues/8308#issuecomment-345680118, I'd be amused to see a setup that communicated test results back from a paint worklet via the pixel patterns of some element.","msgtype":"m.text"},"ts":1511190965000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Domenic: how do you read those pixels?","msgtype":"m.text"},"ts":1511191308000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hmm. There must be some way to get them onto a canvas.","msgtype":"m.text"},"ts":1511191333000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"Or, reftests!","msgtype":"m.text"},"ts":1511191336000,"senderName":"Domenic","senderId":"Domenic@irc"},
{"content":{"body":"That you could do","msgtype":"m.text"},"ts":1511191347000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Clever","msgtype":"m.text"},"ts":1511191352000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I see a test api for getting an element onto a canvas in out future","msgtype":"m.text"},"ts":1511191433000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"*our","msgtype":"m.text"},"ts":1511191436000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: it’s been proposed various times, but SOP makes it painful","msgtype":"m.text"},"ts":1511193575000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: Emphasis on *test* API","msgtype":"m.text"},"ts":1511193597000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: ah doh","msgtype":"m.text"},"ts":1511193617000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Like this is a pretty straightforward addition to testdriver.js modulo usual concerns about pages with multiple windows/frames","msgtype":"m.text"},"ts":1511193666000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"(which are basically: the webdriver story for interacting with multiple windows/frames is pretty broken)","msgtype":"m.text"},"ts":1511193689000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"gsnedders: ^","msgtype":"m.text"},"ts":1511193705000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Making people write reftests to test  js apis inside paint worklets seems pretty broken, so if people are doing that we should fix this sooner rather than later","msgtype":"m.text"},"ts":1511193752000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: I'm actually not sure what the testing plan for paint worklets is","msgtype":"m.text"},"ts":1511194142000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"jgraham: this discussion was mostly about testing test262 in agents, for which this is not a priority","msgtype":"m.text"},"ts":1511194161000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"OK","msgtype":"m.text"},"ts":1511194348000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"Still, don't tell people to write reftests to do that, let's fix it to work better before then","msgtype":"m.text"},"ts":1511194366000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"jgraham: okay, are we at the point where we can get cross-browser privileged APIs?","msgtype":"m.text"},"ts":1511194538000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"jgraham: if that was discussed at TPAC that sounds great, since it's been somewhat of a blocker for lots of types of tests","msgtype":"m.text"},"ts":1511194560000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: At the moment we can iff the API is exposed in WebDriver or there's a defined test API (of course)","msgtype":"m.text"},"ts":1511194589000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"So far I think priviledged click (same document only) works and key input is going to be added soon","msgtype":"m.text"},"ts":1511194630000,"senderName":"jgraham","senderId":"jgraham@irc"},
{"content":{"body":"JakeA: I  think I responded to quickly to your parallel queue issue; after more consideration it makes sense as an extension of a parallel queue","msgtype":"m.text"},"ts":1511195761000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: I've used somewhat hacky wordings to 'wait' for multiple parallel things to complete before. Your proposal would work there too","msgtype":"m.text"},"ts":1511195844000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: eg step 7 https://wicg.github.io/background-fetch/#attempt-a-background-fetch","msgtype":"m.text"},"ts":1511195872000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: when you just go in parallel, do several things in parallel, and then continue? Fair enough","msgtype":"m.text"},"ts":1511195883000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: in that linked case, I want an early exit if one fails, which would be harder. Maybe waiting for a value isn't as hacky as I think.","msgtype":"m.text"},"ts":1511195929000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: I'm thinking a counter would probably work","msgtype":"m.text"},"ts":1511195950000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: increment when you see a shared thing, decrement when it's done","msgtype":"m.text"},"ts":1511195967000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: when you dequeue a non-shared thing wait for the counter to hit 0","msgtype":"m.text"},"ts":1511195989000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: hmm, but then not tied to a parallel queue","msgtype":"m.text"},"ts":1511196003000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: maybe it doesn't need to be. But I'd need aborting for the linked case. But maybe the linked case is already doing it well enough","msgtype":"m.text"},"ts":1511196051000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"it is using a counter","msgtype":"m.text"},"ts":1511196055000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: thanks for the WPT test case review!","msgtype":"m.text"},"ts":1511196653000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"JakeA: if you decrement when you abort seems okay","msgtype":"m.text"},"ts":1511196934000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"annevk: decrement by whatever it currently equals?","msgtype":"m.text"},"ts":1511196976000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"wanderview: no problem!","msgtype":"m.text"},"ts":1511196988000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: oh, I was thinking for each you abort you decrement by 1","msgtype":"m.text"},"ts":1511197002000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: maybe something like what you have is fine","msgtype":"m.text"},"ts":1511197070000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: it seems a bit similar to spec-level promises in a way, so you might want .all or .any semantics","msgtype":"m.text"},"ts":1511197115000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: what do you mean by \"Eventually I'd like to get rid of the \"job\" concept entirely, and replace it with appending steps to the appropriate parallel queue.\"","msgtype":"m.text"},"ts":1511197335000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"annevk: yeah, .all is the behaviour I'm looking for here. Maybe this is separate to the parallel queue \"shared\" thing.","msgtype":"m.text"},"ts":1511197360000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"wanderview: I find the whole 'job' thing a bit weird, since it contains arguments and the name of the thing to do. I'd rather there was a single parallel queue for all the things that must happen in sequence, and algorithms are just called with arguments within that queue","msgtype":"m.text"},"ts":1511197473000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"JakeA: hmm... I guess I find the job concept easy to reason about and we've aligned our implementation with it conceptually","msgtype":"m.text"},"ts":1511197533000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"but maybe what you are thinking would fit easily too... not sure... I just worry about accidentally allowing async operations to overlap by accident, etc","msgtype":"m.text"},"ts":1511197566000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"the job stuff prevents that","msgtype":"m.text"},"ts":1511197569000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"and we spent a long time getting that right","msgtype":"m.text"},"ts":1511197577000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: parallel queue prevents that too and is grounded in the \"in parallel\" primitive","msgtype":"m.text"},"ts":1511197912000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: having said that, I haven't studied jobs so maybe they fulfill the same criteria","msgtype":"m.text"},"ts":1511197936000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"wanderview: the switch to parallel queues shouldn't involve any behaviour change","msgtype":"m.text"},"ts":1511197945000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"annevk: wanderview: there's some brokenness in the spec today which is being fixed by adding parallel queues https://github.com/w3c/ServiceWorker/pull/1229","msgtype":"m.text"},"ts":1511198019000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"\\o/","msgtype":"m.text"},"ts":1511198461000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: right now we allow the next job to run in the middle of an algorithm by resolving a promise... its unclear to me how that will be done with parallel queues based on non-overlapping algorithms","msgtype":"m.text"},"ts":1511198882000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"anyway, I have to run out for a bit...","msgtype":"m.text"},"ts":1511198893000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: I guess I need to take a closer look at that bit","msgtype":"m.text"},"ts":1511199707000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"That sounds like shared steps","msgtype":"m.text"},"ts":1511199819000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"Hmm","msgtype":"m.text"},"ts":1511199824000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"JakeA: annevk: I'm thinking of step 6 in the Install algorithm: https://w3c.github.io/ServiceWorker/#install","msgtype":"m.text"},"ts":1511199974000,"senderName":"wanderview","senderId":"wanderview@irc"},
{"content":{"body":"wanderview: you can still bail out of queued parallel steps by going parallel again (or queuing a task if that makes more sense). But not sure if that solves this case.","msgtype":"m.text"},"ts":1511202860000,"senderName":"JakeA","senderId":"JakeA@irc"},
{"content":{"body":"I was thinking that too, sounds like something that does something synchronous, then does in parallel","msgtype":"m.text"},"ts":1511204089000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"I like how Barack Obama is seemingly aware of all the great memes about him and Joe Biden: https://twitter.com/BarackObama/status/932685522820042754","msgtype":"m.text"},"ts":1511205277000,"senderName":"annevk","senderId":"annevk@irc"},
{"content":{"body":"oh cool, the XMP extension to GIF totally ignores the way GIF stores data and then adds a hack at the end to get the parser back on track","msgtype":"m.text"},"ts":1511205966000,"senderName":"GPHemsley","senderId":"GPHemsley@irc"}
]