[
{"content":{"body":"TabAtkins: I think \"add 1 to this value\" can also be done with this:","msgtype":"m.text"},"ts":1615420804000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615420804000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"((x |> say(?)) + 1) |> print(?)","msgtype":"m.text"},"ts":1615420804000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615420804000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Those parens ar emaking me physically recoil","msgtype":"m.text"},"ts":1615420865000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"That's *precisely* the sort of code contortions I want to make sure are never necessary.","msgtype":"m.text"},"ts":1615420908000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Going from `x |> say(?) |> print(?)` to... that, just because you realized you needed to incrememnt the value in the middle","msgtype":"m.text"},"ts":1615420927000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(realistically you'd write `x |> say(?) |> x=>x+1 |> print(?)` tho)","msgtype":"m.text"},"ts":1615420990000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I've considered proposing functional operators for those kinds of cases too, which are similar to F# symbolic operators.","msgtype":"m.text"},"ts":1615421020000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"And I dont' think that's an unreasonable thing to propose on its own, but as a way of avoiding Hack-style pipelines, it's just piling more and more new features ^_^","msgtype":"m.text"},"ts":1615421078000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Basically `{+}` which means `(a, b) => a + b`, plus fixed arguments: `2 {+}` meaning `(b) => 2 + b`","msgtype":"m.text"},"ts":1615421081000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"So, you'd end up with:","msgtype":"m.text"},"ts":1615421139000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615421139000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> say(?)","msgtype":"m.text"},"ts":1615421139000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  |> {+} 1","msgtype":"m.text"},"ts":1615421139000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  |> print(?)","msgtype":"m.text"},"ts":1615421139000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615421140000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Or","msgtype":"m.text"},"ts":1615421140000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615421141000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"[1, 2, 3, 4].reduce({+}, 0)","msgtype":"m.text"},"ts":1615421141000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615421142000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Or even:","msgtype":"m.text"},"ts":1615421213000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615421213000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> filter({>} 0)","msgtype":"m.text"},"ts":1615421213000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  |> map({+} 1)","msgtype":"m.text"},"ts":1615421213000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  |> reduce({*}, 1)","msgtype":"m.text"},"ts":1615421213000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615421214000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I'd just as well have Operator.add or something at that point, I think","msgtype":"m.text"},"ts":1615421242000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I mean, it's not bad. Now do the same thing for all the other cases in the comparison slide. ^_^","msgtype":"m.text"},"ts":1615421253000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"rkirsling: Yeah, I have a package with operators like that.","msgtype":"m.text"},"ts":1615421264000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"TabAtkins: `|> _ => (/*whatever was in the slide*/)` ?","msgtype":"m.text"},"ts":1615421288000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Yes, you're proposing ways to avoid having to write an arrow function","msgtype":"m.text"},"ts":1615421323000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"partial-application, operator-funcs, etc","msgtype":"m.text"},"ts":1615421341000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ljharb Do you know where the 2021 Ecma/TC39/2021/012 document was posted?  All I can find is https://tc39.es/ecma262/ which looks like the evolving draft.","msgtype":"m.text"},"ts":1615421453000,"senderName":"msaboff","senderId":"msaboff@irc"},
{"content":{"body":"it's on the releases page","msgtype":"m.text"},"ts":1615421474000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"https://github.com/tc39/ecma262/releases/tag/es2021-candidate-2021-03","msgtype":"m.text"},"ts":1615421505000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"namely https://github.com/tc39/ecma262/releases/download/es2021-candidate-2021-03/ECMA-262.12th.edition.June.2021.pdf","msgtype":"m.text"},"ts":1615421520000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"er","msgtype":"m.text"},"ts":1615421548000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that's the PDF version, I mean","msgtype":"m.text"},"ts":1615421558000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"HTML version is https://tc39.es/ecma262/2021","msgtype":"m.text"},"ts":1615421564000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling Thanks","msgtype":"m.text"},"ts":1615421574000,"senderName":"msaboff","senderId":"msaboff@irc"},
{"content":{"body":"sure!","msgtype":"m.text"},"ts":1615421582000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615422520000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const Op = {","msgtype":"m.text"},"ts":1615422520000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  set(obj, key, value) { obj[key] = value; return obj; },","msgtype":"m.text"},"ts":1615422520000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  new(f, ...args) { return new f(...args); },","msgtype":"m.text"},"ts":1615422520000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"};","msgtype":"m.text"},"ts":1615422520000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> o.m(?)","msgtype":"m.text"},"ts":1615422521000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> o.m(0, ?)","msgtype":"m.text"},"ts":1615422522000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> Op.new(o.m, ?)","msgtype":"m.text"},"ts":1615422522000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> ? {+} 1","msgtype":"m.text"},"ts":1615422523000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> Array.of(0, ?)","msgtype":"m.text"},"ts":1615422523000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> Op.set({}, \"key\", ?)","msgtype":"m.text"},"ts":1615422524000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> o.m(?) |> await","msgtype":"m.text"},"ts":1615422524000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> o.m(?) |> /* tough one because `yield` is valid on its own... */","msgtype":"m.text"},"ts":1615422525000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615422525000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Meta operators (mostly tongue-in-cheek idea, but maybe...?):","msgtype":"m.text"},"ts":1615422889000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615422889000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> o.m(?) |> await.?","msgtype":"m.text"},"ts":1615422889000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> o.m(?) |> yield.?","msgtype":"m.text"},"ts":1615422889000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615422890000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"That works! Note tho that every single line you wrote is either identical to Hack-style, or longer/more complex/new features.","msgtype":"m.text"},"ts":1615422896000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"the `Op.new` thing is because I currently disallow `new f(?)`, but I could remove that restriction.","msgtype":"m.text"},"ts":1615422934000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Sure, the exact set of ops isn't that imporant; you need more than the two you listed anyway, like `get`","msgtype":"m.text"},"ts":1615422998000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Also, I was thinking that F# has multiple pipeline operators: `|>`, `||>`, `|||>`. Though for those its about piping multiple inputs (i.e., `a b ||> f` is equivalent to `f a b` in F#)","msgtype":"m.text"},"ts":1615423016000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"JS has that reasonably covered already - `[a, b] |> f(...#)`","msgtype":"m.text"},"ts":1615423047000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"We could have both (as long as the topic and the placeholder don't share the same token).","msgtype":"m.text"},"ts":1615423056000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615423097000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x ||> [0, #]","msgtype":"m.text"},"ts":1615423097000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615423097000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I just don't like overloading the syntax that much though.","msgtype":"m.text"},"ts":1615423098000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I agree that I'm not a fan of mixing partial-app and Hack-style. I just think that the result of that unease is to regard it as one more strike against partial-app.","msgtype":"m.text"},"ts":1615423171000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"the only thing infeasible with F#+papp compared to Hack is yield. Honestly though, if you're yielding in the middle of a pipeline that seems a bit like code-smell...","msgtype":"m.text"},"ts":1615423183000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Likely, yeah; `yield` is important to me only in the sense that we carved out a special exception to make `await` work, but left this other very similar keyword out in the cold.","msgtype":"m.text"},"ts":1615423235000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It feels dirty, is all. But I don't think it's important in practical terms.","msgtype":"m.text"},"ts":1615423247000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Very much a \"theoretical purity\"-level concern in the priority of constituencies.","msgtype":"m.text"},"ts":1615423270000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"We could do the same thing we do in async generators with `yield promise` and just have `|>` await the result for you...","msgtype":"m.text"},"ts":1615423289000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Not that I'm a fan of that","msgtype":"m.text"},"ts":1615423302000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Yeah, not a fan of that magic outside of the explicit async boundary.","msgtype":"m.text"},"ts":1615423322000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"but something explicit like `await.?` informing the pipeline would work for `yield.?` too...","msgtype":"m.text"},"ts":1615423361000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Like I said during the talk, ultimately the two are *so close to identical*. Ignoring await, *every single* Hack-style pipeline like `val |> XXXXX` becomes an F#-style with `val |> x=>XXXXX`. And *every single* F#-style pipeline like `val |> XXXXX` becomes a Hack-style with `val |> XXXXX(#)`. Doesn't matter how complex the XXXXX expression is, the transform works in 100% of cases (ignoring await).","msgtype":"m.text"},"ts":1615423426000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"`await` and `yield` violate TCP, so they're always going to be tough to work around.","msgtype":"m.text"},"ts":1615423466000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"With await, the only diff is that F#-style *requires* you to unfold the XXXXX into two or three steps, with the promise isolated in the middle step. `val |> foo(await fetch(#))` must be unfolded into `val |> fetch |> await |> foo`; you can't write `val |> x=>foo(await fetch(x))`.","msgtype":"m.text"},"ts":1615423539000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(Technically you could write `val |> async x=>foo(await fetch(x)) |> await`, but ugh.)","msgtype":"m.text"},"ts":1615423586000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I was also considering that `|> yield` could be a special form like `|> await`, and if you *really* wanted to yield `undefined` you could use parens or `do` or something:","msgtype":"m.text"},"ts":1615423659000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615423659000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> m.o(?) |> yield |> print(?); // basically `print(yield(m.o(x)))`","msgtype":"m.text"},"ts":1615423659000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const memo = _ => () => _;","msgtype":"m.text"},"ts":1615423659000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> m.o(?) |> memo(yield) |> print(?); // basically `print((m.o(x), yield))`","msgtype":"m.text"},"ts":1615423659000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615423663000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I don't understand how the `memo(yield)` part works. That doesn't produce a function.","msgtype":"m.text"},"ts":1615423808000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"F#+papp only requires you to unfold the steps if you are awaiting the \"topic\":","msgtype":"m.text"},"ts":1615423811000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615423811000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> o.m(?, await p); // perfectly reasonable.","msgtype":"m.text"},"ts":1615423811000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615423811000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Since you only have a single \"topic\", awaiting it in the middle isn't that burdensome (and if anything is clearer)","msgtype":"m.text"},"ts":1615423812000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`memo` produces a function","msgtype":"m.text"},"ts":1615423820000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: The moment your expression is complex enough to need an arrow-func, not partial-app or operator-funcs or what-have-you, it fails regardless of what you're awaiting.","msgtype":"m.text"},"ts":1615423857000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It produces a function that always returns the argument passed to `memo`:","msgtype":"m.text"},"ts":1615423867000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615423868000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const memo = _ => () => _;","msgtype":"m.text"},"ts":1615423868000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const f = memo(3);","msgtype":"m.text"},"ts":1615423868000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"console.log(f()); // 3","msgtype":"m.text"},"ts":1615423868000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"console.log(f()); // 3","msgtype":"m.text"},"ts":1615423868000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"console.log(f()); // 3","msgtype":"m.text"},"ts":1615423868000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615423869000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: Right, but `yield` isn't a function.","msgtype":"m.text"},"ts":1615423871000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Yeah, you evaluate an expression that returns a function. `memo(yield)` is an expression. I was illustrating the exceedingly rare case of \"I want to `yield` the value `undefined` and return its result\"","msgtype":"m.text"},"ts":1615423929000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"That's the reason `|> yield` doesn't work but `|> await` does.","msgtype":"m.text"},"ts":1615423943000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`await` requires an operand, `yield` does not.","msgtype":"m.text"},"ts":1615423952000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Ohhhh, okay, so it's not the same as the preceding line (which interprets `yield` as a special form that yields the topic)","msgtype":"m.text"},"ts":1615423952000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Yield should behave the same as await.","msgtype":"m.text"},"ts":1615423977000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"no, I was explicitly illustrating the \"if you *really* wanted to yield `undefined` you could use parens or `do` or something:\" case","msgtype":"m.text"},"ts":1615423981000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Okay, using the parens from a wrapping function call was confusing me. ^_^","msgtype":"m.text"},"ts":1615423998000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"jridgewell: As I said, the reason it doesn't is that `yield` (no operand) is a valid expression in JS","msgtype":"m.text"},"ts":1615424011000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"So `x |> yield` might mean something different to one person vs. another.","msgtype":"m.text"},"ts":1615424030000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Yes, in pipe, it should be treated like `await`","msgtype":"m.text"},"ts":1615424034000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"It could mean, \"I want to yield x\", or it could mean \"I want to call the function resulting from yielding `undefined` with the value of `x`","msgtype":"m.text"},"ts":1615424055000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"jridgewell: I was proposing we do something like `|> await.?` and `|> yield.?` to be more specific about the behavior, but I generally agree. `|> yield` should be treated like `|> await` if it comes down to it.","msgtype":"m.text"},"ts":1615424103000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"That's resolve by `|> (yield)` vs `|> yield`","msgtype":"m.text"},"ts":1615424121000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"If you want the \"I want to call the function resulting from yielding `undefined` with the value of `x case just do `|> (yield)`.","msgtype":"m.text"},"ts":1615424137000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1615424138000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"The first invokes the return of yield, and the second yields the pipeline arg","msgtype":"m.text"},"ts":1615424160000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"But this all comes down to `yield` being inherently incorrect, it should have been spec'd like `await`","msgtype":"m.text"},"ts":1615424206000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"It always takes an arg, and if you wanted to yield nothing, do `yield undefined`","msgtype":"m.text"},"ts":1615424224000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Requiring that `yield` have an operand is a very \"iterator-centric\" point of view and ignores other generator/coroutine-like scenarios.","msgtype":"m.text"},"ts":1615424270000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"You might always just want to write `const x = yield` since it only matters what you're sent, not what you receive.","msgtype":"m.text"},"ts":1615424298000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"That's making very similar operators behave very differently for, what I imagine, is .0000000000000000000001% of the uses.","msgtype":"m.text"},"ts":1615424413000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Regardless, its too late to change that.","msgtype":"m.text"},"ts":1615424419000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I agree that we could make the distinction that `|> await` and `|> yield` behave the same.","msgtype":"m.text"},"ts":1615424442000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"In F# pipes, if you wanted pipe `x` into a function stored in a Promise, you'd have to do `x |> (await pfn)` anyways","msgtype":"m.text"},"ts":1615424489000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"No different from `x |> (yield y)` really","msgtype":"m.text"},"ts":1615424518000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Why would you have to do that? Aside from the \"bare await\" syntax carve-out, the RHS is just an arbitrary expression that must resolve to a function, so in F#, `x |> await pFn` should be completely valid.","msgtype":"m.text"},"ts":1615425875000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011&build=&builtIns=false&spec=false&loose=true&code_lz=B4AgPgfCCGDu0EsAuIAOAxAdkA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=stage-0&prettier=true&targets=&version=7.13.10&externalPlugins=","msgtype":"m.text"},"ts":1615425957000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"We forbid await without parens to avoid the ambiguity","msgtype":"m.text"},"ts":1615425977000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"But it could be made lega","msgtype":"m.text"},"ts":1615425985000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"legal**","msgtype":"m.text"},"ts":1615425988000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"That's not an unreasonable position to take, imo.","msgtype":"m.text"},"ts":1615425994000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Oh, Babel didn't even implement `x |> await`, though","msgtype":"m.text"},"ts":1615426040000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"So I have no idea.","msgtype":"m.text"},"ts":1615426043000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"A) we need a way to `await` the \"topic\"","msgtype":"m.text"},"ts":1615426199000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"B) we want to reduce confusion and be consistent.","msgtype":"m.text"},"ts":1615426199000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"If we want consistency between `await` and `yield`, then we need to explicit.","msgtype":"m.text"},"ts":1615426199000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`|> await` has no operand and awaits the topic","msgtype":"m.text"},"ts":1615426199000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`|> (await p)` awaits `p` and invokes the result with the topic","msgtype":"m.text"},"ts":1615426199000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`|> yield` has no operand and yields the topic","msgtype":"m.text"},"ts":1615426200000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`|> (yield)` yields `undefined` and invokes the result with the topic","msgtype":"m.text"},"ts":1615426200000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`|> (yield p)` yields `p` and invokes the result with the topic","msgtype":"m.text"},"ts":1615426201000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Both `|> await` and `|> yield` would need NLTs and restrictions to forbid a leading `AwaitExpression` or `YieldExpression`.","msgtype":"m.text"},"ts":1615426202000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Also, due to the precedence of `yield`, you probably need to parenthesize it since `yield`'s precedence will probably conflict with `|>`","msgtype":"m.text"},"ts":1615426203000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426290000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// if no parens, for this:","msgtype":"m.text"},"ts":1615426290000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> yield |> F","msgtype":"m.text"},"ts":1615426290000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// you probably wanted:","msgtype":"m.text"},"ts":1615426290000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"(x |> yield) |> F","msgtype":"m.text"},"ts":1615426291000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// but you got this instead:","msgtype":"m.text"},"ts":1615426292000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> (yield |> F)","msgtype":"m.text"},"ts":1615426292000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426293000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"or rather","msgtype":"m.text"},"ts":1615426307000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"That example was incorrect.","msgtype":"m.text"},"ts":1615426347000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426350000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> yield a |> F","msgtype":"m.text"},"ts":1615426350000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// would be","msgtype":"m.text"},"ts":1615426350000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> yield (a |> F)","msgtype":"m.text"},"ts":1615426350000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// but you wanted","msgtype":"m.text"},"ts":1615426350000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"(x |> yield a) |> F","msgtype":"m.text"},"ts":1615426350000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"``","msgtype":"m.text"},"ts":1615426350000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426357000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Agreed.","msgtype":"m.text"},"ts":1615426402000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"So, forcing the parens is better for user expectations:","msgtype":"m.text"},"ts":1615426422000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426422000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// no precedence concerns","msgtype":"m.text"},"ts":1615426422000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> (yield a) |> F","msgtype":"m.text"},"ts":1615426422000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426422000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"So, if we want to avoid precedence issues and remain consistent, `|> await` and `|> yield` would be special forms, and if you don't want the special forms, you use `|> (await ...)` and `|> (yield ...)`","msgtype":"m.text"},"ts":1615426464000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: For your point A), I think a more general statement is that we need a way to `await` *things* inside a pipeline. The topic is one thing and often what you'll want, but not the sole thing, depending on what your code is doing.","msgtype":"m.text"},"ts":1615426489000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Not unreasonable to start from `val |> x=>foo(\"arg\", x)` and later realize you actually need to grab `\"arg\"` from the network.","msgtype":"m.text"},"ts":1615426532000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Yeah. Outside of the position immediately to the right of `|>`, you could use `await` anywhere else in the pipeline expression, i.e. `x |> foo(?, await y)`.","msgtype":"m.text"},"ts":1615426558000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Sucks if `val |> x=>foo(await fetch(\"/arg\"), x)` doesn't work and there's no way to make it work without contortions","msgtype":"m.text"},"ts":1615426559000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Well, that wouldn't work unless you made the arrow async anyways...","msgtype":"m.text"},"ts":1615426578000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Again that point is *only* valid so long as you can avoid an arrow-function wrapper.","msgtype":"m.text"},"ts":1615426581000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(\"that point\" being that you could just drop an `await` into partial-app)","msgtype":"m.text"},"ts":1615426605000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426620000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> foo(await fetch(\"/arg\"), ?)","msgtype":"m.text"},"ts":1615426620000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426620000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Would be valid in F#+papp","msgtype":"m.text"},"ts":1615426620000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Yes, because the RHS happens to be simple enough to be expressible in partial-app. If that's not true, you need a wrapper function.","msgtype":"m.text"},"ts":1615426656000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"The `await fetch(\"/arg\")` happens first, before the papp function is returned.","msgtype":"m.text"},"ts":1615426658000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"And suddenly you need to contort yourself.","msgtype":"m.text"},"ts":1615426662000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Assume that you're gonna manipulate the topic as well so you can't papp it, like `foo(await fetch(\"/arg\"), ? + 1)`","msgtype":"m.text"},"ts":1615426695000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"`x |> ? + 1 |> foo(await fetch(\"/arg\"), ?)` works for that, but I see your point.","msgtype":"m.text"},"ts":1615426743000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"well","msgtype":"m.text"},"ts":1615426749000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426785000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> ? {+} 1 |> foo(await fetch(\"/arg\"), ?)","msgtype":"m.text"},"ts":1615426785000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426785000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rather, if we're talking functional operators...","msgtype":"m.text"},"ts":1615426785000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I guess one of my issues with Hack-style is that you don't need new syntax for it.","msgtype":"m.text"},"ts":1615426836000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Yeah, my point is that suddenly you're having to do *larger* rewrites from your starting point of `val |> x=>foo(\"arg\", x+1)`","msgtype":"m.text"},"ts":1615426846000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"rbuckton: explain?","msgtype":"m.text"},"ts":1615426870000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426884000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"var _;","msgtype":"m.text"},"ts":1615426885000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"(","msgtype":"m.text"},"ts":1615426885000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  _ = x,","msgtype":"m.text"},"ts":1615426885000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  _ = _ + 1,","msgtype":"m.text"},"ts":1615426885000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  _ = foo(await fetch(\"/arg\"), _),","msgtype":"m.text"},"ts":1615426885000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  _","msgtype":"m.text"},"ts":1615426885000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":")","msgtype":"m.text"},"ts":1615426886000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615426887000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"That's a hack pipe with no new syntax.","msgtype":"m.text"},"ts":1615426896000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"plus, you can control your topic variable.","msgtype":"m.text"},"ts":1615426907000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"No new syntax, sure. But quite a lot of tax.","msgtype":"m.text"},"ts":1615426932000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"F# doesnt' require any new syntax either:","msgtype":"m.text"},"ts":1615426958000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Not much, you're replacing `|>` with `_=` and `,`","msgtype":"m.text"},"ts":1615426967000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`function pipe(val, ...fns) { for(const fn of fns) val = fn(val); return val; }` is F# pipe.","msgtype":"m.text"},"ts":1615426987000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"`pipe(val, {+} 1, foo(await fetch(\"/arg\"), ?))`","msgtype":"m.text"},"ts":1615427022000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Except static analysis for type systems sucks for that case.","msgtype":"m.text"},"ts":1615427025000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Valid, tho not a concern for 90%+ of JS devs. ^_^","msgtype":"m.text"},"ts":1615427057000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"In TypeScript, you end up with an overload ladder that eventually bottoms out.","msgtype":"m.text"},"ts":1615427063000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"And given that, as I said earlier, Hack and F# pipelines are *trivially* translatable between each other, if Hack-style is bad because you can already write it in existing syntax, then F# is too.","msgtype":"m.text"},"ts":1615427207000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Tbf, it does invoke a slightly larger tax - every line would have a `(_)` at the end of it.","msgtype":"m.text"},"ts":1615427228000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Regardless, tho, \"you can use comma and assignment to get the same effect at a similar cost in characters\" doesn't fly in practice, because people still love method chaining but don't love it enough to do comma-and-assignment. It feels much, much nastier and heavier-weight even if the raw character weight is similar.","msgtype":"m.text"},"ts":1615427334000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"When I started down the road of looking into `|>` and papp several years ago, my design choices were driven by projects like lodash and Ramda. Specifically, designing a syntax that doesn't heavily prefer one over the other as I don't want it to feel like TC39 is \"choosing a winner\"","msgtype":"m.text"},"ts":1615427345000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"this was following on the heels of the earlier `::` bind proposal.","msgtype":"m.text"},"ts":1615427363000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Yeah, \"better `::`\" is one of the reasons I came to support `|>` too.","msgtype":"m.text"},"ts":1615427383000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"One of the upsides of the F#+papp proposal, is that it worked equally well with both (and other) fp-style libraries.","msgtype":"m.text"},"ts":1615427406000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Hack-style works too, but favors lodash, since Ramda uses currying.","msgtype":"m.text"},"ts":1615427452000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615427647000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// F#+papp","msgtype":"m.text"},"ts":1615427647000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// lodash-style","msgtype":"m.text"},"ts":1615427647000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> map(?, _ => _ + 1)","msgtype":"m.text"},"ts":1615427647000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// Ramda-style","msgtype":"m.text"},"ts":1615427647000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> map(_ => _ + 1)","msgtype":"m.text"},"ts":1615427647000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// Hack","msgtype":"m.text"},"ts":1615427648000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// lodash-style","msgtype":"m.text"},"ts":1615427649000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> map(?, _ => _ + 1)","msgtype":"m.text"},"ts":1615427649000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// Ramda-style","msgtype":"m.text"},"ts":1615427650000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x |> map(_ => _ + 1, ?) // can't leverage Ramda currying","msgtype":"m.text"},"ts":1615427651000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615427651000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Plus, lodash and Ramda both support partial application:","msgtype":"m.text"},"ts":1615428096000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615428096000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// Ramda","msgtype":"m.text"},"ts":1615428096000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"R.curry(g)(R.__, 2, 3)(4)","msgtype":"m.text"},"ts":1615428097000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// lodash","msgtype":"m.text"},"ts":1615428097000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"_.partial(g, _, 2, 3)(4)","msgtype":"m.text"},"ts":1615428098000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615428098000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"But that requires a fair amount of code beneath the surface to support, vs:","msgtype":"m.text"},"ts":1615428099000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615428100000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"g(?, 2, 3)(4)","msgtype":"m.text"},"ts":1615428100000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1615428101000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Sorry, wife came home and I had to rush off to make dinner. I'll pick up tomorrow.","msgtype":"m.text"},"ts":1615429803000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"}
]