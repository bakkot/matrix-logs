[
{"content":{"body":"Jitsi video conferencing is now open.  Meeting starts in 13 mins.","msgtype":"m.text"},"ts":1618926412000,"senderName":"robpalme","senderId":"robpalme@irc"},
{"content":{"body":"Is there a way to get rid of the #&$(*!@#(* buttons that the video conference software displays on top of the slides?","msgtype":"m.text"},"ts":1618928097000,"senderName":"wsdferdksl","senderId":"wsdferdksl@irc"},
{"content":{"body":"removing the mouse cursor from the window should do the trick","msgtype":"m.text"},"ts":1618928166000,"senderName":"rricard","senderId":"rricard@irc"},
{"content":{"body":"rricard: It doesn't. They're always there. Makes slides unreadable.","msgtype":"m.text"},"ts":1618928266000,"senderName":"wsdferdksl","senderId":"wsdferdksl@irc"},
{"content":{"body":"I would try clicking in the window and removing then","msgtype":"m.text"},"ts":1618928290000,"senderName":"rricard","senderId":"rricard@irc"},
{"content":{"body":"rricard: Tried that. Clicking in the window doesn't do anything.","msgtype":"m.text"},"ts":1618928371000,"senderName":"wsdferdksl","senderId":"wsdferdksl@irc"},
{"content":{"body":"well I don't know, I do use the electron client maybe it has the feature","msgtype":"m.text"},"ts":1618928395000,"senderName":"rricard","senderId":"rricard@irc"},
{"content":{"body":"wsdferdksl make your window taller","msgtype":"m.text"},"ts":1618928899000,"senderName":"akirose","senderId":"akirose@irc"},
{"content":{"body":"wsdferdksl: paste this in your console:","msgtype":"m.text"},"ts":1618929671000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"((a) => a.parentNode.removeChild(a))(document.getElementsByClassName('toolbox-content')[0])","msgtype":"m.text"},"ts":1618929673000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"isn't Intl effectively all optional? why do we care that much about data size?","msgtype":"m.text"},"ts":1618930533000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"I don't think it's optional for browsers?","msgtype":"m.text"},"ts":1618930627000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"its not optional for browsers","msgtype":"m.text"},"ts":1618930633000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"michaelficarra: who's \"we\"? the committee?","msgtype":"m.text"},"ts":1618930695000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: yes","msgtype":"m.text"},"ts":1618930702000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"i wanted to add `\\U{character name instead of codepoint}` but browsers were against it due to size","msgtype":"m.text"},"ts":1618930745000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ystartsev: Bakkot: The APIs are not optional, but the data set can be effectively empty, right? There should be no conformance issue.","msgtype":"m.text"},"ts":1618930767000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"what would be the point of that","msgtype":"m.text"},"ts":1618930788000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah conformance is not a goal for products","msgtype":"m.text"},"ts":1618930795000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"that's what node did for years","msgtype":"m.text"},"ts":1618930798000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"intl but all the intl apis return garbage","msgtype":"m.text"},"ts":1618930805000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well, that's a little overgeneralization. but conformance is never prioritized over actually providing useful APIs","msgtype":"m.text"},"ts":1618930852000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"lol https://gc.gy/86635848.png","msgtype":"m.text"},"ts":1618930852000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"because then we are saying, as a standards body, \"if you want to provide this functionality, here is how you provide it. If it is too costly, you don't have to provide anything.\"","msgtype":"m.text"},"ts":1618930855000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"michaelficarra: it in no way follows from that size doesn't matter","msgtype":"m.text"},"ts":1618930891000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"you still want to make an effort to minimize cost so providing it is more likely","msgtype":"m.text"},"ts":1618930908000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"also we should not standardize things which no one is going to ship","msgtype":"m.text"},"ts":1618930945000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or, worse, that they're going to ship in a form which is useless","msgtype":"m.text"},"ts":1618930959000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"on the emoji names example, development time tooling could \"support\" the API and output a replacement","msgtype":"m.text"},"ts":1618931101000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"I dunno, seems not entirely useless to standardise these things","msgtype":"m.text"},"ts":1618931113000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"standardizing a thing which has runtime implications but is only used at build time would be... strange","msgtype":"m.text"},"ts":1618931151000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"there have been suggestions of having a build-time specification for js","msgtype":"m.text"},"ts":1618931185000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not sure how i feel about that but","msgtype":"m.text"},"ts":1618931190000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it would enable this sort of thing in one way","msgtype":"m.text"},"ts":1618931212000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I generally feel like there should be implementations before a standard","msgtype":"m.text"},"ts":1618931302000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"like if webpack or whatever wants to add build-time stuff and other people want to interop with that, then it would be the appropriate time to standardize","msgtype":"m.text"},"ts":1618931325000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but the implementations are the important part, we can't just summon them from the void by saying \"wouldn't it be neat if something existed with these semantics\" like happens with browsers","msgtype":"m.text"},"ts":1618931357000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah i think my perspective on that is that its so local that there would never be a need to standardize. you can always add `devsneks-cool-unicode-names-transform` to your package.json","msgtype":"m.text"},"ts":1618931386000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"michaelficarra: sorry my attention was split","msgtype":"m.text"},"ts":1618931438000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"sorry is this speaker \"MD\"? for the notes","msgtype":"m.text"},"ts":1618931452000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"current speaker is Markus Scherer","msgtype":"m.text"},"ts":1618931519000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: MWS","msgtype":"m.text"},"ts":1618931521000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1618931530000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"other speakers in this topic are MB and MED","msgtype":"m.text"},"ts":1618931552000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"MED hasn't talked yet, right?","msgtype":"m.text"},"ts":1618931684000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah pretty sure he hasn't talked yet","msgtype":"m.text"},"ts":1618931729000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"devsnek: https://gist.github.com/leobalter/16364bb167633cb3cb31e0f95e160a2a","msgtype":"m.text"},"ts":1618931875000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"I had the chance to quickly discuss the topic with Rick. He did not review this gist but I believe I captured my thoughts there.","msgtype":"m.text"},"ts":1618931929000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"leobalter: thanks for the writeup","msgtype":"m.text"},"ts":1618931976000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"saying that, I'm sorry the discussion got heated from my side and I got off the rails yesterday. I'd appreciate to be part of the discussion, but that's not an excuse for being aggressive.","msgtype":"m.text"},"ts":1618932019000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"no hard feelings... i'm grateful for your input","msgtype":"m.text"},"ts":1618932269000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: PTAL again, I included a note about coverage + engine262","msgtype":"m.text"},"ts":1618932613000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"üëçüèª","msgtype":"m.text"},"ts":1618932651000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this is along the lines of the \"nothing can casefold to ASCII\" guarantee","msgtype":"m.text"},"ts":1618932652000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"we just have to trust the Unicode consortium to not do stupid things","msgtype":"m.text"},"ts":1618932678000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"well, we don't just have to trust, we can ask them to write down that they won't","msgtype":"m.text"},"ts":1618932728000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and then trust","msgtype":"m.text"},"ts":1618932730000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Instead of having to trust, why no use syntax to denote the type of a property and with what contructs if can be used?","msgtype":"m.text"},"ts":1618932854000,"senderName":"msaboff","senderId":"msaboff@irc"},
{"content":{"body":"msaboff: eh, they both work in practice though","msgtype":"m.text"},"ts":1618932874000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"sounds like Thomas hasn't written a parser","msgtype":"m.text"},"ts":1618932931000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"who is thomas","msgtype":"m.text"},"ts":1618932943000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"for the notes","msgtype":"m.text"},"ts":1618932946000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"we already need Unicode data for ID_Start, ID_Continue, WSP, etc","msgtype":"m.text"},"ts":1618932953000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"Bakkot: TLY","msgtype":"m.text"},"ts":1618932973000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1618932975000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I don't know who they represent","msgtype":"m.text"},"ts":1618932984000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"Evernote apparently","msgtype":"m.text"},"ts":1618932993000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"We require Unicode data for all the Unicode related properties.","msgtype":"m.text"},"ts":1618932996000,"senderName":"msaboff","senderId":"msaboff@irc"},
{"content":{"body":"gibson042: Nested [ [ ] ] ] are allowed in the existing lexical grammar. Follow the productions in 12.8.5","msgtype":"m.text"},"ts":1618933012000,"senderName":"wsdferdksl","senderId":"wsdferdksl@irc"},
{"content":{"body":"may we pray that 12.8.5 never changes ever","msgtype":"m.text"},"ts":1618933063000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"RegularExpressionFirstChar and RegularExpressionChar don't allow unescaped `[` except as part of RegularExpressionClass `[‚Ä¶]`, which itself cannot contain unescaped `]`","msgtype":"m.text"},"ts":1618933950000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"so I guess the tokenization doesn't follow the semantic structure, but nonetheless can work","msgtype":"m.text"},"ts":1618934076000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"subject to the no-unescaped-`/` constraint","msgtype":"m.text"},"ts":1618934121000,"senderName":"gibson042","senderId":"gibson042@irc"},
{"content":{"body":"gibson042: This is exactly the reason why I had added the no-unescaped-/ constraint to the proposal here.","msgtype":"m.text"},"ts":1618934582000,"senderName":"wsdferdksl","senderId":"wsdferdksl@irc"},
{"content":{"body":"we are starting up in 2 mins","msgtype":"m.text"},"ts":1618937871000,"senderName":"robpalme","senderId":"robpalme@irc"},
{"content":{"body":"can someone take over notes for the next 30 seconds, I want to start a cup of tea","msgtype":"m.text"},"ts":1618938187000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"won't be hard, bot likes shu","msgtype":"m.text"},"ts":1618938199000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"also someone fill in the last thirty seconds please, my network dropped","msgtype":"m.text"},"ts":1618938342000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"who is legendecas, for the notes?","msgtype":"m.text"},"ts":1618939220000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I am having difficulty capturing this comments for the notes","msgtype":"m.text"},"ts":1618939296000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"CZW","msgtype":"m.text"},"ts":1618939342000,"senderName":"robpalme","senderId":"robpalme@irc"},
{"content":{"body":"the example in the survey was absolutely lower case","msgtype":"m.text"},"ts":1618939435000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"because I wrote in the exact same concern, even though I don't think the quoted words were mine","msgtype":"m.text"},"ts":1618939454000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i don't think i saw the survey","msgtype":"m.text"},"ts":1618939514000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"a script could also call `Object.defineProperty(globalThis, 'GrowableSharedArrayBuffer', { value: globalThis.GrowableSharedArrayBuffer, writeable: false, configurable: false })` at the beginning of the script","msgtype":"m.text"},"ts":1618940223000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so I am hopeful moddable can resolve this that way","msgtype":"m.text"},"ts":1618940229000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(not saying that it needs to happen in the next thirty seconds)","msgtype":"m.text"},"ts":1618940286000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I just don't think it would be especially burdensome for Moddable to resolve this","msgtype":"m.text"},"ts":1618940293000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"likely not but it seems reasonable to say that they should get an opportunity to explore that","msgtype":"m.text"},"ts":1618940311000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sure, or at least to quantify that burden so we can better evaluate it as a committee","msgtype":"m.text"},"ts":1618940436000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1618940526000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think Moddable's concern is not just this feature, but the precedent.","msgtype":"m.text"},"ts":1618940571000,"senderName":"msaboff","senderId":"msaboff@irc"},
{"content":{"body":"right, but if it turns out the precedent isn't actually a problem, that is ideal","msgtype":"m.text"},"ts":1618940599000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"For the record -- I didn't say this, but I support the proposal and appreciate all the work you did here to address mozilla's concerns shu","msgtype":"m.text"},"ts":1618941241000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"I would really prefer not to wake up at 6:30am if it's avoidable","msgtype":"m.text"},"ts":1618941249000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"where was the concern with AggregateError?","msgtype":"m.text"},"ts":1618941268000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I hope we have more time for that","msgtype":"m.text"},"ts":1618941300000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"ugh I wish we were calling these immutable arrays and not tuples","msgtype":"m.text"},"ts":1618941399000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"i have to go for a bit, just want to be sure I get to say I like this proposal but have concerns about conversation about the names using past forms of verbs (e.g. \"I pushed 1 onto the array\" .push()? or .pushed()?)","msgtype":"m.text"},"ts":1618941581000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"shu: overlooked, really. i'd have brought it up then if it had occurred to me","msgtype":"m.text"},"ts":1618941644000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: and Realms/Compartments/whatever?","msgtype":"m.text"},"ts":1618941695000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: if there's a natural place to nest those, i think we should","msgtype":"m.text"},"ts":1618941719000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: and to clarify, your position here is purely organizational, right?","msgtype":"m.text"},"ts":1618941891000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: yes","msgtype":"m.text"},"ts":1618941909000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu: it's a bit easier to polyfill etc this way also, but that's a lesser concern since it's already a thing","msgtype":"m.text"},"ts":1618941926000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: is it? wouldn't it be harder?","msgtype":"m.text"},"ts":1618941942000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"what if e.g. SharedArrayBuffer didn't exist? (SABs aren't polyfillable but suppose they were)","msgtype":"m.text"},"ts":1618941958000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"then i'd be able to stick it on ArrayBuffer","msgtype":"m.text"},"ts":1618941972000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"as opposed to having to make a new global, which might conflict with any existing global, etc","msgtype":"m.text"},"ts":1618941982000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"right, but what if you also needed to make the new global?","msgtype":"m.text"},"ts":1618941987000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"then i'm no worse off","msgtype":"m.text"},"ts":1618941993000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(than with SAB)","msgtype":"m.text"},"ts":1618941999000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"is this rgn talking?","msgtype":"m.text"},"ts":1618942008000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i agree it's a minimal difference ofc, which is why it's very secondary to \"organizational\"","msgtype":"m.text"},"ts":1618942009000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: it's rick button","msgtype":"m.text"},"ts":1618942022000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: not sure the acronym","msgtype":"m.text"},"ts":1618942026000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbu","msgtype":"m.text"},"ts":1618942030000,"senderName":"rricard","senderId":"rricard@irc"},
{"content":{"body":"sorry, thanks","msgtype":"m.text"},"ts":1618942030000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: i was thinking it's worse off than existing because for 2 different globals, their polyfills would compose naturally and just work","msgtype":"m.text"},"ts":1618942037000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ljharb: but if they're nested, there's more coordination","msgtype":"m.text"},"ts":1618942041000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i have to stop notes","msgtype":"m.text"},"ts":1618942163000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"poo ^","msgtype":"m.text"},"ts":1618942170000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"shu: i think it's the same that way","msgtype":"m.text"},"ts":1618942173000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: okay, i think high order bit for me is i do not want to spend any more time on this","msgtype":"m.text"},"ts":1618942267000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"same as yesterday I gotta got AFK the rest of the meeting but will leave the bot running, sorry if it dies","msgtype":"m.text"},"ts":1618942315000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: i think i'll withdraw my opinion and just ask for Stage 3 with namespaced -- barring possible objections from the other side, of course","msgtype":"m.text"},"ts":1618942442000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: i think moddable's claim is stronger than mine; if not for that i'd be willing to go with globals. just ftr.","msgtype":"m.text"},"ts":1618942488000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"understood","msgtype":"m.text"},"ts":1618942512000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"anybody hearing an intermittent pop on the audio?","msgtype":"m.text"},"ts":1618942536000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"when nobody was speaking earlier i was hearing a weird warble, but it's fine when someone is speaking","msgtype":"m.text"},"ts":1618942565000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"is this just proposing to shorten {}.hasOwnProperty.call to Object.has?","msgtype":"m.text"},"ts":1618942584000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"michaelficarra: yeah, afaict","msgtype":"m.text"},"ts":1618942593000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1618942611000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"michaelficarra: it's useful for null-proto things","msgtype":"m.text"},"ts":1618942614000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"are we going to do Object.toString next?","msgtype":"m.text"},"ts":1618942618000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"if Symbol.toStringTag hadn't made it useless, i'd say maybe :-p","msgtype":"m.text"},"ts":1618942631000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu: it's not, both of those work on null-proto things","msgtype":"m.text"},"ts":1618942634000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"can we get stage 2 on this","msgtype":"m.text"},"ts":1618942655000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it has spec text","msgtype":"m.text"},"ts":1618942661000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"michaelficarra: you don't think it's useful to be able to type Object.has vs `{}.hasOwnProperty.call`?","msgtype":"m.text"},"ts":1618942667000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"especially with understanding `call` semantics?","msgtype":"m.text"},"ts":1618942675000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: not really? they're almost identical","msgtype":"m.text"},"ts":1618942688000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"also `Object.prototype.hasOwnProperty.call` versus `{}.hasOwnProperty.call` is a thing","msgtype":"m.text"},"ts":1618942700000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I've found beginners are not comfortable (or don't know how) to do `Object.prototype.hasOwnProperty.call`","msgtype":"m.text"},"ts":1618942708000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"this would provide one nice, short, static method","msgtype":"m.text"},"ts":1618942710000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'm pretty positive on this despite its being an alias, yeh","msgtype":"m.text"},"ts":1618942718000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah*","msgtype":"m.text"},"ts":1618942719000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"also, hasOwnProperty says \"own\" in the name, whereas I would assume Object.has had \"in\" semantics","msgtype":"m.text"},"ts":1618942723000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"maybe we can name it hasOwn","msgtype":"m.text"},"ts":1618942734000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes, i think i would prefer hasOwn vs has","msgtype":"m.text"},"ts":1618942736000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618942758000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const uncurryThis = Function.prototype.bind.bind(Function.prototype.call);","msgtype":"m.text"},"ts":1618942758000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const hasOwn = uncurryThis(Object.prototype.hasOwnProperty);","msgtype":"m.text"},"ts":1618942758000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"hasOwn({ a: 1 }, \"a\"); // true","msgtype":"m.text"},"ts":1618942758000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618942758000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"either has or hasOwn works fine for me","msgtype":"m.text"},"ts":1618942763000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton: `Function.bind.call(Object.prototype.hasOwnProperty)` is a bit shorter :-p","msgtype":"m.text"},"ts":1618942784000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"+1 to the general discussion -- one thing we were also discussing was the proxy has trap, and reflector.hass","msgtype":"m.text"},"ts":1618942786000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"rbuckton: but yes, that's exactly what the `has` package does","msgtype":"m.text"},"ts":1618942791000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"as potentially confusing bits","msgtype":"m.text"},"ts":1618942799000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"Yeah, but I use `uncurryThis` quite a bit :)","msgtype":"m.text"},"ts":1618942799000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: https://npmjs.com/call-bind is what all my packages use for that","msgtype":"m.text"},"ts":1618942826000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"we will need to educate people on Object.has vs Reflect.has","msgtype":"m.text"},"ts":1618942847000,"senderName":"robpalme","senderId":"robpalme@irc"},
{"content":{"body":"robpalme: you're assuming anyone knows about Reflect.has","msgtype":"m.text"},"ts":1618942858000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"does Reflect.has have `in` semantics?","msgtype":"m.text"},"ts":1618942866000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1618942870000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"I think `hasOwn` is my preference, for the same reasoning as ystartsev. `Object.getOwnPropertyDescriptor -> Reflect.getOwnPropertyDescriptor` so `Object.has -> Reflect.has`. Going with `hasOwn` is less confusing.","msgtype":"m.text"},"ts":1618942871000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"meanwhile in node https://gc.gy/86647883.png","msgtype":"m.text"},"ts":1618942884000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I agree with @rbuckton, but it's a mild feeling","msgtype":"m.text"},"ts":1618942905000,"senderName":"robpalme","senderId":"robpalme@irc"},
{"content":{"body":"devsnek: basically the first few lines of every JS program I write","msgtype":"m.text"},"ts":1618942928000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"currying > use strict","msgtype":"m.text"},"ts":1618942941000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`Object.(keys|values|entries)` returns arrays while `(Map|Set).(keys|values|entries)` returns an iterator, so its not a 1:1 comparison.","msgtype":"m.text"},"ts":1618942977000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"jridgewell: FWIW I pull things off Object.prototype with {}, Array.prototype with [], and Function.prototype with Date","msgtype":"m.text"},"ts":1618943206000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"\"and Function.prototype with Date\"... wat?","msgtype":"m.text"},"ts":1618943234000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"can we ask for stage 4","msgtype":"m.text"},"ts":1618943248000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"don't judge","msgtype":"m.text"},"ts":1618943249000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1618943252000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1618943259000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"date is always available, unlike `function() {}`","msgtype":"m.text"},"ts":1618943275000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"You can always pull `hasOwnProperty` off of `Object`, though it will do a prototype walk to get to it :)","msgtype":"m.text"},"ts":1618943302000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`Object.hasOwnProperty.call(obj, key)`","msgtype":"m.text"},"ts":1618943309000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"that's why we can't name this `Object.hasOwnProperty` :-p","msgtype":"m.text"},"ts":1618943331000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Object.hasOwnProperty2","msgtype":"m.text"},"ts":1618943345000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ship it","msgtype":"m.text"},"ts":1618943353000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"+1","msgtype":"m.text"},"ts":1618943355000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"Very true. Not sure I have a major preference of `has` vs `hasOwn`, but still prefer `hasOwn`.","msgtype":"m.text"},"ts":1618943382000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"if hasOwn isn't a web compat risk, i think it is a good choie","msgtype":"m.text"},"ts":1618943405000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"i think the analogy with collections is very weak","msgtype":"m.text"},"ts":1618943423000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"problem: \"i need an ergonomic way to check if an object has an own property\"","msgtype":"m.text"},"ts":1618943428000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ownness doesn't matter for collections","msgtype":"m.text"},"ts":1618943429000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: +1","msgtype":"m.text"},"ts":1618943432000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I'm just super in favor of anything that moves these awkward Object.prototype things to less awkward locations.","msgtype":"m.text"},"ts":1618943463000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"same","msgtype":"m.text"},"ts":1618943476000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"+1 to the point about the problem statement that michaelficarra just brought up","msgtype":"m.text"},"ts":1618943476000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"qq: Earlier it was mentioned that built-in modules essentially died on the vine. Was the proposal officially withdrawn, or is it just stale?","msgtype":"m.text"},"ts":1618943529000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: indefinitely stalled / push back against both reserving specifiers from web and using new syntax from various","msgtype":"m.text"},"ts":1618943578000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"likely could move somewhat if we could resolve either of those","msgtype":"m.text"},"ts":1618943600000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"but last I heard about this was from msaboff","msgtype":"m.text"},"ts":1618943613000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Stale","msgtype":"m.text"},"ts":1618943644000,"senderName":"msaboff","senderId":"msaboff@irc"},
{"content":{"body":"there's a more fundamental disagreement for built-in modules: it bifurcates the ecosystem","msgtype":"m.text"},"ts":1618943644000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I still kind of wish we had the ability to do something like `import { Object } from <builtins>` or `import { ResizableArrayBuffer } from <collections>` from both the _Script_ and _Module_ goals.","msgtype":"m.text"},"ts":1618943681000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"pattern matching woooo","msgtype":"m.text"},"ts":1618943687000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rbuckton Me too.","msgtype":"m.text"},"ts":1618943709000,"senderName":"msaboff","senderId":"msaboff@irc"},
{"content":{"body":"terminator is championing this proposal","msgtype":"m.text"},"ts":1618943718000,"senderName":"ryzokuken","senderId":"ryzokuken@irc"},
{"content":{"body":"`echo \"export const Object = globalThis.object\" > './<builtins>'`","msgtype":"m.text"},"ts":1618943719000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why don't we propose static `import` from Script like Allen said a few years ago, just ban `async` flagged graphs like service workers do","msgtype":"m.text"},"ts":1618943771000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: we had some discussion about that","msgtype":"m.text"},"ts":1618943802000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"i'm strongly against anything that disables async graphs","msgtype":"m.text"},"ts":1618943802000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"That's different when not in a frozen realm where someone can do `Object  = function () {}`, or as a way to avoid the concerns Moddable had about introducing new globals.","msgtype":"m.text"},"ts":1618943809000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"service workers are bad enough","msgtype":"m.text"},"ts":1618943812000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rbuckton: node goes *REALLY* far to deal w/ doing essentially that with our `primordials`","msgtype":"m.text"},"ts":1618944000000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"like the uncurryThis snippet devsnek pasted","msgtype":"m.text"},"ts":1618944018000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"I smell a new protocol for matching :-)","msgtype":"m.text"},"ts":1618944108000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"michaelficarra: where the first class protocols at","msgtype":"m.text"},"ts":1618944154000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"michaelficarra: good nose","msgtype":"m.text"},"ts":1618944154000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the phrase \"avoiding footguns\" was literally used, what","msgtype":"m.text"},"ts":1618944192000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"`Function.prototype.uncurryThis`","msgtype":"m.text"},"ts":1618944200000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"i think wsdferdksl1 is reading ahead","msgtype":"m.text"},"ts":1618944204000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: :'( I need to spend time on it","msgtype":"m.text"},"ts":1618944227000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"rbuckton that is infuriating","msgtype":"m.text"},"ts":1618944233000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"The presentation of goals here was excellent","msgtype":"m.text"},"ts":1618944253000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"you would have to bind uncurryThis to uncurryThis","msgtype":"m.text"},"ts":1618944256000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i dislike this syntax","msgtype":"m.text"},"ts":1618944259000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but i like pattern matching","msgtype":"m.text"},"ts":1618944264000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bradleymeck: can't tell if joking or serious? I'm joking, tbh.","msgtype":"m.text"},"ts":1618944264000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"cries","msgtype":"m.emote"},"ts":1618944309000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i do want uncurryThis tho","msgtype":"m.text"},"ts":1618944318000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"TS does not like that fn","msgtype":"m.text"},"ts":1618944329000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"just to get support for it","msgtype":"m.text"},"ts":1618944335000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: `const uncurryThis: <T, A extends any[], R>(f: (this: T, ...args: A) => R) => (this_: T, ...args: A) => R = Function.prototype.bind.bind(Function.prototype.call);`","msgtype":"m.text"},"ts":1618944356000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Doesn't work with overloaded signatures though.","msgtype":"m.text"},"ts":1618944369000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"having to type `when (...)` makes me angry","msgtype":"m.text"},"ts":1618944422000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why?","msgtype":"m.text"},"ts":1618944428000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"just let me type the `...`","msgtype":"m.text"},"ts":1618944430000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bradleymeck: `Function.prototype.uncurryThis` would have been something like `const hasOwn = Object.prototype.hasOwn.uncurryThis()`, the alternative would be `const hasOwn = Function.uncurryThis(Object.prototype.hasOwnProperty)`","msgtype":"m.text"},"ts":1618944436000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"devsnek: it's needed, keep watching","msgtype":"m.text"},"ts":1618944448000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: did smth change since our last convo","msgtype":"m.text"},"ts":1618944471000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: probably","msgtype":"m.text"},"ts":1618944478000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: the last month's been busy","msgtype":"m.text"},"ts":1618944483000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton we do a different signature that does a little better https://github.com/nodejs/node/blob/master/typings/primordials.d.ts#L1 , but yea it is still pretty unhappy usually","msgtype":"m.text"},"ts":1618944491000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i think we should ensure that the common case doesn't have extra syntax","msgtype":"m.text"},"ts":1618944501000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rbuckton: yea, that would let us more sanely do some stuff w/o deopts is the hope","msgtype":"m.text"},"ts":1618944535000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"devsnek: that's certainly a goal","msgtype":"m.text"},"ts":1618944537000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"bradleymeck: Improving support for handling function signatures in type-space is something I'm experimenting with.","msgtype":"m.text"},"ts":1618944594000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Do patterns allow arbitrary expressions, like `when ([\"go\", fn()]) { ... }`? The `as` clause will be tricky for TypeScript, since we use that in expression positions to do type assertions","msgtype":"m.text"},"ts":1618944712000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: wait a slide or two","msgtype":"m.text"},"ts":1618944722000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton: p sure it should be fine with TS","msgtype":"m.text"},"ts":1618944735000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"worst case you can release typescript 3","msgtype":"m.text"},"ts":1618944749000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"4?","msgtype":"m.text"},"ts":1618944758000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"We're on TS 4 already :)","msgtype":"m.text"},"ts":1618944758000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1618944766000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"typescript 5 then","msgtype":"m.text"},"ts":1618944768000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"regexps don't need a special case if the returned value from the protocol describes the introduced bindings","msgtype":"m.text"},"ts":1618944782000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"michaelficarra: true","msgtype":"m.text"},"ts":1618944796000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"michaelficarra: i don't think engines would like that","msgtype":"m.text"},"ts":1618944799000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"no dynamic scope bindings","msgtype":"m.text"},"ts":1618944802000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"michaelficarra: but in that case, the returned value would be the match object","msgtype":"m.text"},"ts":1618944802000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"this isn't dynamic, the capture group names are static","msgtype":"m.text"},"ts":1618944812000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"And we've already changed our assertion syntax once. `<X>a` originally (and still), but `a as X` as well (since the `<X>a` syntax conflicted with JSX).","msgtype":"m.text"},"ts":1618944813000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"ljharb: the return value is dynamic","msgtype":"m.text"},"ts":1618944821000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"michaelficarra: which means you'd have to do `as { groups: { a, b } }` to get the bindings","msgtype":"m.text"},"ts":1618944822000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yeah we're pretty explicitly agaisnt the user-defined stuff implicitly introducing bindings. Bindings need to be visible from source.","msgtype":"m.text"},"ts":1618944823000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"devsnek: right but the literal pattern form is special, not a regex object","msgtype":"m.text"},"ts":1618944830000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"agree with tab here","msgtype":"m.text"},"ts":1618944845000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rbuckton: so for this concern, it'd be `^(x as y)` and should work fine","msgtype":"m.text"},"ts":1618944851000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: with a regex object, bindings *only ever* come from an explicit `as`","msgtype":"m.text"},"ts":1618944866000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"hm","msgtype":"m.text"},"ts":1618944884000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i thought they came from the group names","msgtype":"m.text"},"ts":1618944900000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: only in the literal pattern form","msgtype":"m.text"},"ts":1618944912000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"in no way would we try to introduce magic implicit bindings :-)","msgtype":"m.text"},"ts":1618944923000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"oh i see what you're saying","msgtype":"m.text"},"ts":1618944933000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Also concerned about `^`, since I'm still a fan of `^x` creating an index object that can be used in arrays (which I believe was presented last meeting).","msgtype":"m.text"},"ts":1618944935000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"it's an open question tho, we don't have to have that sugar for the literal pattern form.","msgtype":"m.text"},"ts":1618944936000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"makes more sense now","msgtype":"m.text"},"ts":1618944937000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"we should 100% have that sugar","msgtype":"m.text"},"ts":1618944947000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rbuckton: happy to bikeshed that operator","msgtype":"m.text"},"ts":1618944948000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"this presentation is very nice :-)","msgtype":"m.text"},"ts":1618944951000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"devsnek: üëç","msgtype":"m.text"},"ts":1618944953000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"michaelficarra: üéâ","msgtype":"m.text"},"ts":1618944961000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"still against when() though","msgtype":"m.text"},"ts":1618944962000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"But it seems to be unique enough, though if both existed you might have a `when ^^1` :)","msgtype":"m.text"},"ts":1618944963000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: lol true, it wouldn't conflict except conceptually. altho you'd need `^(^1)`","msgtype":"m.text"},"ts":1618944979000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton: `^` is only allowed with an identifier, or a parenthesized expression","msgtype":"m.text"},"ts":1618944997000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I see.","msgtype":"m.text"},"ts":1618945004000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"good clarification","msgtype":"m.text"},"ts":1618945049000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ljharb: i didn't see anything saying why when has to exist","msgtype":"m.text"},"ts":1618945062000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe i'm horrible at listening","msgtype":"m.text"},"ts":1618945078000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: hm, i guess i was thinking the `if` and `else` headers. but since we came up with `^` i guess we could go straight into the pattern","msgtype":"m.text"},"ts":1618945097000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: it does seem nice to me to have a syntactic marker tho","msgtype":"m.text"},"ts":1618945103000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'll put a topic","msgtype":"m.text"},"ts":1618945120000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: without that, we'd have to require `;` between clauses, or have ASI kick in","msgtype":"m.text"},"ts":1618945121000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: In general I like this proposal. I've been thinking more about Rust-style ADT enums (I still have that `enum` proposal I may eventually bring to committee), and how that could work with pattern matching.","msgtype":"m.text"},"ts":1618945122000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"multiple clauses on the same line should never exist","msgtype":"m.text"},"ts":1618945139000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rbuckton: I really hope that enum proposal is nothing like TypeScript enums anymore","msgtype":"m.text"},"ts":1618945156000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"I really really hate the idea of relying on array holes to avoid the need for a nil matcher. :(","msgtype":"m.text"},"ts":1618945233000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I think the catch integration should be a follow-on proposal","msgtype":"m.text"},"ts":1618945235000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"michaelficarra: Anything I put together will need to support a number of scenarios, including the ones in TS. Even if the default behavior is creating symbol-valued properties for JS, I still want to be able to create number-valued properties.","msgtype":"m.text"},"ts":1618945238000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"5 minutes oof","msgtype":"m.text"},"ts":1618945238000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"michaelficarra: yes, definitely","msgtype":"m.text"},"ts":1618945266000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"why does logical or use `|` in patterns","msgtype":"m.text"},"ts":1618945292000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"could it not just be ||","msgtype":"m.text"},"ts":1618945308000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I do agree that ^ is the least intuitive part but I haven't thought of a better alternative","msgtype":"m.text"},"ts":1618945312000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the concept of pinning is pretty crucial for this proposal though so we'll need to figure out something","msgtype":"m.text"},"ts":1618945363000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"devsnek: that's the norm in other languages; it's only a \"logical\" OR if you analogize with an existing conditional, but here it's really a \"separator for alternatively\"","msgtype":"m.text"},"ts":1618945368000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i wish rust had pinning","msgtype":"m.text"},"ts":1618945373000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"*alternatives","msgtype":"m.text"},"ts":1618945373000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i accidentally deleted the next person on the queue","msgtype":"m.text"},"ts":1618945374000,"senderName":"akirose","senderId":"akirose@irc"},
{"content":{"body":"devsnek: No particular reason","msgtype":"m.text"},"ts":1618945389000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(for that reason, I'd probably prefer that we not say \"logical\" OR)","msgtype":"m.text"},"ts":1618945393000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ü§∑üèª","msgtype":"m.text"},"ts":1618945411000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"brad4d: no, absolutely not","msgtype":"m.text"},"ts":1618945413000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"brad4d: if you want the brittle instanceof you have to type that yourself, or add the protocol to your class to provide it","msgtype":"m.text"},"ts":1618945427000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"words aside, `||` would be problematic precisely because the disjuncts *aren't* boolean","msgtype":"m.text"},"ts":1618945455000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"oh the strictness with object matching seems to motivate a rest form without a binding","msgtype":"m.text"},"ts":1618945481000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"My earliest version of the `enum` proposal actually introduced a new value type that had both a name and a value (similar to C# enums), so that they are essentially unique:","msgtype":"m.text"},"ts":1618945490000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618945490000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"enum Color { Red };","msgtype":"m.text"},"ts":1618945490000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"enum Animal { Dog };","msgtype":"m.text"},"ts":1618945490000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Color.Red === Animal.Dog; // false","msgtype":"m.text"},"ts":1618945490000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Number(Color.Red) === Number(Color.Dog); // true","msgtype":"m.text"},"ts":1618945490000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Number(Color.Red); // 0","msgtype":"m.text"},"ts":1618945491000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"String(Color.Red); // \"Red\"","msgtype":"m.text"},"ts":1618945491000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"typeof Color.Red; // \"enum\"","msgtype":"m.text"},"ts":1618945491000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618945492000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"However I was concerned introducing a new value type and typeof tag would be too difficult to advance.","msgtype":"m.text"},"ts":1618945493000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"how about \"or\" as a keyword","msgtype":"m.text"},"ts":1618945505000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"sure, that'd be an option","msgtype":"m.text"},"ts":1618945526000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"michaelficarra: What do you mean?","msgtype":"m.text"},"ts":1618945723000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ljharb: I asked because one of the example seemed to imply that `AggregateError` would have such a static property.","msgtype":"m.text"},"ts":1618946095000,"senderName":"brad4d","senderId":"brad4d@irc"},
{"content":{"body":"ljharb: `as` may be fine in that context (though possibly confusing for TS users), but I'm curious if you've considered anything like https://www.python.org/dev/peps/pep-0572/ (using the `:=` operator to introduce a binding). Granted, Python introduced `:=` because of how variables work in that language, so its not a direct comparison.","msgtype":"m.text"},"ts":1618946119000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: I think that's directionally problematic","msgtype":"m.text"},"ts":1618946179000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"\"directionally problematic\"?","msgtype":"m.text"},"ts":1618946202000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"it's an afterthought, like \"and we need to be able to refer to it as\"","msgtype":"m.text"},"ts":1618946228000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Not if you reclassify it the statement to \"and we need to be able to restrict it to\"","msgtype":"m.text"},"ts":1618946278000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618946380000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// start with","msgtype":"m.text"},"ts":1618946380000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"when ([\"go\", dir]) { ... } // dir in scope","msgtype":"m.text"},"ts":1618946380000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// add restriction","msgtype":"m.text"},"ts":1618946380000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"when ([\"go\", dir := (\"N\" | \"S\" | \"E\" | \"W\")]) { ... } // dir in scope","msgtype":"m.text"},"ts":1618946380000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// alternative, use a keyword like 'is'","msgtype":"m.text"},"ts":1618946381000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"when ([\"go\", dir is (\"N\" | \"S\" | \"E\" | \"W\")]) { ...  } // dir in scope","msgtype":"m.text"},"ts":1618946382000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618946382000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"My concerns about `as` may be unfounded, I'll have to check the repo after the changes ljharb have mentioned are merged to reflect the current state.","msgtype":"m.text"},"ts":1618946514000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I'm a little concerned about `match (x)` though, since you either need an NLT between `)` and `{`, or a massive cover grammar, and that pushes people towards a specific style (brace on same-line vs brace on next line). That's why I'd switched `using (x) {` to match Java's `try using (x) {`.","msgtype":"m.text"},"ts":1618946648000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"yeah, I feel like putting the binding name first makes it look like an unconditional pattern match, since the \"restriction\" there is just a normal pattern match and not a guard","msgtype":"m.text"},"ts":1618946655000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rbuckton: we'd use an NLT. nobody uses allman","msgtype":"m.text"},"ts":1618946665000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I seem to recall that being a concern for `using (x) {}` a few years back.","msgtype":"m.text"},"ts":1618946705000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"If pattern matching moves forward with `match ( Expression ) [no LineTerminator here] MatchBlock`, maybe I'll switch `using` back. For `using`, there were always two cases I wanted to support. One that introduced bindings, and one that didnt.","msgtype":"m.text"},"ts":1618947092000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I've been thinking of dropping `try using` in favor of `using const x = ...`, but haven't been happy with `using value Expression`, so maybe I just do `using const x = ...` (block scoped binding) and `using ( Expression ) [NLT] { ... }` (block-lifetime for expression).","msgtype":"m.text"},"ts":1618947092000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: `as` is consistent with named imports/exports tho","msgtype":"m.text"},"ts":1618947329000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"But inconsistent with destructuring. I can understand `as` in imports though, since the bindings are \"live\", but we could have just done `import { x: y } from \"foo\"`. I've seen that some of the CommonJS ecosystem does `const { x: y } = require(\"foo\")` when not using a module transpiler. Is the binding in a match \"live\" as well, or is it just a copy of the matched value?","msgtype":"m.text"},"ts":1618947587000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Oh, ljharb: Any chance `browserify/resolve` will get support for NodeJS export maps? I was just moving a project over to using them but ran into Jest not supporting them because they're waiting on `resolve`. Currently I'm trying to implement my own custom resolver for Jest to work around the issue.","msgtype":"m.text"},"ts":1618947622000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"ugh I am not enthusiastic about the idea of a new cover grammar","msgtype":"m.text"},"ts":1618947998000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"akirose: bnb: robpalme we forgot to get reviewers for Object.hasOwn, can we do that first thing tomorrow? i'll volunteer to be one of them","msgtype":"m.text"},"ts":1618948653000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton: tbh i think the real thing that sucks is that object destructuring used `:` instead of `as`","msgtype":"m.text"},"ts":1618948669000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton: it's not live, just like destructuring isn't","msgtype":"m.text"},"ts":1618948680000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton: as for `using` i'm personally fine with an NLT; if we decide we can't do that, then all new keywords are off limits, and the only people hurt by it are using a brace style that causes bugs in JS and that all style guides and common linters discourage","msgtype":"m.text"},"ts":1618948721000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bad idea: introduce a trailing `\\` for anyone who *really* wants braces on a new line:","msgtype":"m.text"},"ts":1618948871000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618948871000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"match (x)\\","msgtype":"m.text"},"ts":1618948871000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"{","msgtype":"m.text"},"ts":1618948871000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618948871000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618948871000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"yeah if object destructing used `as` it would make me much happier in match()","msgtype":"m.text"},"ts":1618948901000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"rbuckton: i thought shitposts were supposed to go in tdz :-p","msgtype":"m.text"},"ts":1618949397000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Not a shitpost, just a bad idea.","msgtype":"m.text"},"ts":1618949410000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":":-p","msgtype":"m.text"},"ts":1618949459000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if they didn't need that for `return \\` then they don't need it ¬Ø\\_(„ÉÑ)_/¬Ø","msgtype":"m.text"},"ts":1618949472000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I mean, this works:","msgtype":"m.text"},"ts":1618949478000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618949478000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"let x = \"a\\","msgtype":"m.text"},"ts":1618949478000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"b\";","msgtype":"m.text"},"ts":1618949478000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x; // \"ab\"","msgtype":"m.text"},"ts":1618949478000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"x.length; // 2","msgtype":"m.text"},"ts":1618949479000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618949479000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"TabAtkins: it sounds like the object matching makes an exhaustiveness assertion which you can disable by adding a rest binding","msgtype":"m.text"},"ts":1618950590000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"but if you don't want that, I imagine you would just add a `...`?","msgtype":"m.text"},"ts":1618950601000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"No, object matching is explicitly non-exhaustive","msgtype":"m.text"},"ts":1618950603000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"array matching is exhaustive","msgtype":"m.text"},"ts":1618950609000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"oh, I misunderstood that part of the presentation then","msgtype":"m.text"},"ts":1618950618000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"okay","msgtype":"m.text"},"ts":1618950619000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"(exhaustive object matching would be unusable from the get-go, as you'd need to include, at minimum, all the Object.prototype properties in every pattern)","msgtype":"m.text"},"ts":1618950633000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"or just put a ‚Ä¶ to switch the behaviour","msgtype":"m.text"},"ts":1618950653000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"What I mean is that you'd need to put that in *every* pattern, because you'd *never* want an exhaustive match.","msgtype":"m.text"},"ts":1618950673000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"fair","msgtype":"m.text"},"ts":1618950685000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"late to all this but yeah I think I could be swayed to have arrays be non-exhaustive for consistency's sake, but objects definitely have to be non-exhaustive","msgtype":"m.text"},"ts":1618952199000,"senderName":"mpcsh","senderId":"mpcsh@irc"},
{"content":{"body":"although I do definitely think the most intuitive version is arrays are exhaustive, objects are not","msgtype":"m.text"},"ts":1618952211000,"senderName":"mpcsh","senderId":"mpcsh@irc"},
{"content":{"body":"it's inconsistent, yes, but it best models what folks will try to do. being able to express \"an array of exactly this length and give me these bindings\" is very powerful","msgtype":"m.text"},"ts":1618952236000,"senderName":"mpcsh","senderId":"mpcsh@irc"},
{"content":{"body":"array and object destructuring are already similarly inconsistent around trying to destructure nullish values","msgtype":"m.text"},"ts":1618952373000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and they both make perfect sense in isolation","msgtype":"m.text"},"ts":1618952383000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I *really* don't think we can make arrays non-exhaustive. It would clash with author's expectations *so hard*","msgtype":"m.text"},"ts":1618953032000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I don't know if I agree that it's such a hard clash - `const [a, b] = [1, 2, 3, 4]` works. I think the better argument is the expressiveness that non-exhaustive matching enables","msgtype":"m.text"},"ts":1618954066000,"senderName":"mpcsh","senderId":"mpcsh@irc"},
{"content":{"body":"i could go either way on it","msgtype":"m.text"},"ts":1618954146000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if it's non-exhaustive, you *can* do `[‚Ä¶rest] & { length: 2 } & [a, b]` but i don't think you can go the other way as easily?","msgtype":"m.text"},"ts":1618954184000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"eugh, that's pretty gross","msgtype":"m.text"},"ts":1618954551000,"senderName":"mpcsh","senderId":"mpcsh@irc"},
{"content":{"body":"and requires `&` at the outset","msgtype":"m.text"},"ts":1618954555000,"senderName":"mpcsh","senderId":"mpcsh@irc"},
{"content":{"body":"Could reuse tuple syntax for exhaustive arrays, since tuples have a fixed length? Unless you wanted to reserve `#[]` to explicitly match *only* tuples.","msgtype":"m.text"},"ts":1618954618000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"`when (#[a, b]) { ... }`","msgtype":"m.text"},"ts":1618954627000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"though that's only a few characters shorter than `when([a, b, ...]) { ... }`, so ¬Ø\\_(„ÉÑ)_/¬Ø","msgtype":"m.text"},"ts":1618954693000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"we'd probably want `#[]` to only match tuples, yeah","msgtype":"m.text"},"ts":1618954719000,"senderName":"mpcsh","senderId":"mpcsh@irc"},
{"content":{"body":"Would `[]` only match arrays then? I'd want to be able to match either...","msgtype":"m.text"},"ts":1618954763000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"hm, I think that's probably a question for the record & tuple folks. my intuition would be they're both exclusive and if you want both you can do `[a, b] | #[a, b]`, or write a custom class with the match protocol method we presented","msgtype":"m.text"},"ts":1618954967000,"senderName":"mpcsh","senderId":"mpcsh@irc"},
{"content":{"body":"mpcsh: indeed, it is gross. but it's at least possible.","msgtype":"m.text"},"ts":1618955074000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton: tuples are primitives, arrays aren't","msgtype":"m.text"},"ts":1618955092000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`[ ]` is destructuring. `#[]` is just like `3`","msgtype":"m.text"},"ts":1618955103000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so `#[a, b]` Just Works using `===`","msgtype":"m.text"},"ts":1618955118000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(with extra magic needed for the bindings, ofc)","msgtype":"m.text"},"ts":1618955132000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I take it `|` shortcuts? It's odd to see the same binding identifier repeated.","msgtype":"m.text"},"ts":1618955139000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"It is a bit odd to see `|` and `&` used for this (even though its similar to how TypeScript uses them in type-space for unions/intersections).","msgtype":"m.text"},"ts":1618955197000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"yes, it's \"or\" semantics","msgtype":"m.text"},"ts":1618955207000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"how we spell the combinators or the pin operator is certainly bikesheddable","msgtype":"m.text"},"ts":1618955296000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but i haven't heard any suggestions that make _more_ sense to me yet","msgtype":"m.text"},"ts":1618955306000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Is `^` only `Identifier` or `ParenthesizedExpression`?","msgtype":"m.text"},"ts":1618955569000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"(roughly)","msgtype":"m.text"},"ts":1618955582000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"actually we'd talked about it also including chains and CallExpressions","msgtype":"m.text"},"ts":1618955603000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'm sure people will want to do this:","msgtype":"m.text"},"ts":1618955608000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618955608000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"import * as foo from \"foo\";","msgtype":"m.text"},"ts":1618955608000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"match (x) {","msgtype":"m.text"},"ts":1618955608000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ^foo.Class { ... }","msgtype":"m.text"},"ts":1618955608000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618955608000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618955609000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"right, with chains that'd work fine","msgtype":"m.text"},"ts":1618955616000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Could always use a similar restricted grammar as decorators.","msgtype":"m.text"},"ts":1618955631000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"conceptually i think it should work bare with \"one thing\" and with parens with \"multiple things\"","msgtype":"m.text"},"ts":1618955640000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Anything more complex needs `()`.","msgtype":"m.text"},"ts":1618955648000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"yeah presumably pattern matching and decorators would share the same syntax limits there","msgtype":"m.text"},"ts":1618955659000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"You could also use a different clause name than `when` for expression matchers, or a keyphrase like `when is` rather than an esoteric `^`.","msgtype":"m.text"},"ts":1618955786000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"the expression stuff needs to be nestable","msgtype":"m.text"},"ts":1618955811000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so if it's a keyword, you'd get into super awkward precedence/paren things like `await` has","msgtype":"m.text"},"ts":1618955821000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's why we ended up leaning towards a sigil","msgtype":"m.text"},"ts":1618955855000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(and just spelling `when` differently doesn't nest)","msgtype":"m.text"},"ts":1618955888000,"senderName":"mpcsh","senderId":"mpcsh@irc"},
{"content":{"body":"Isn't it `when (Pattern) {}` anyways? How would `is` have a precedence issue?","msgtype":"m.text"},"ts":1618955907000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: a pattern has to be able to have \"an expression\" at any level tho","msgtype":"m.text"},"ts":1618955925000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton: like `{ a: { b: { c: [a, b, ^c] } } } }`","msgtype":"m.text"},"ts":1618955939000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I see.","msgtype":"m.text"},"ts":1618955957000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: that'd be `[a, b, when c]`, but if `c` is a parenthesized one, it gets weirder","msgtype":"m.text"},"ts":1618955960000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and forcing parens with a keyword is also weird.","msgtype":"m.text"},"ts":1618955971000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(open to ideas ofc, just that's the thought process e went through)","msgtype":"m.text"},"ts":1618956018000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"*we","msgtype":"m.text"},"ts":1618956022000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"If expressions are nestable, why have the headless form `when ^Name {}` and not just `when (^Name) {}` for consistency?","msgtype":"m.text"},"ts":1618956085000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"we could, just seemed like nice sugar","msgtype":"m.text"},"ts":1618956111000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`when (^Name)` would still work regardless","msgtype":"m.text"},"ts":1618956124000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but `when (^(‚Ä¶))` looks worse than `when ^(‚Ä¶)` ¬Ø\\_(„ÉÑ)_/¬Ø","msgtype":"m.text"},"ts":1618956153000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'm a bit wary of the parenless form only because it reduces syntax space for any possible future extensions to the `when` clause (of which we may have none yet, but look at where ASI has lead us).","msgtype":"m.text"},"ts":1618956430000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"devsnek suggested we get rid of the `when` entirely","msgtype":"m.text"},"ts":1618956494000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I really like the proposal. A few things make me squeamish though (like the `with` keyword)","msgtype":"m.text"},"ts":1618956512000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"so it'd just be `^Name { }` or `^(<expr>) {}` or  `(<pattern>) {}`","msgtype":"m.text"},"ts":1618956524000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rbuckton: yeah i _really_ don't like spelling it \"with\"","msgtype":"m.text"},"ts":1618956532000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"That's odd with the `if` and `else` clauses though","msgtype":"m.text"},"ts":1618956542000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"yeah that's a reasonable counter to \"remove `when`\", to be sure","msgtype":"m.text"},"ts":1618956556000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i _do_ like how `when` and `else` are the same length, so they all line up in oneliners :-p","msgtype":"m.text"},"ts":1618956574000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"one of the complaints i hear a lot about let/const is that they're not all 3 letters","msgtype":"m.text"},"ts":1618956614000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Then again, PowerShell does interesting things in its `switch` clause that are similar:","msgtype":"m.text"},"ts":1618956645000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618956645000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"switch ($x) {","msgtype":"m.text"},"ts":1618956645000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  Foo { ... }    # Foo interpreted as \"Foo\"","msgtype":"m.text"},"ts":1618956645000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  Bar { ... }    # Bar interpreted as \"Bar\"","msgtype":"m.text"},"ts":1618956645000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  {$_ -gt 3} { ... }  # ScriptBlock with $_ topic variable","msgtype":"m.text"},"ts":1618956645000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618956645000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618956646000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Almost want to use `as` instead of `with`. Or `into`.","msgtype":"m.text"},"ts":1618956784000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"pretty sure we can pick anything we want since it's not an expression space","msgtype":"m.text"},"ts":1618956800000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I was tinkering with a LINQ-like comprehension syntax for JS that used `into` as a keyword:","msgtype":"m.text"},"ts":1618956887000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618956887000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x =","msgtype":"m.text"},"ts":1618956887000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  from user of users","msgtype":"m.text"},"ts":1618956887000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  select user.name into name","msgtype":"m.text"},"ts":1618956887000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  where name !== \"Bob\"","msgtype":"m.text"},"ts":1618956944000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  select name;","msgtype":"m.text"},"ts":1618956944000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618956944000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"or invert the clause:","msgtype":"m.text"},"ts":1618956944000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618956944000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"when [first, last] from ^Name { ... }","msgtype":"m.text"},"ts":1618956944000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618956944000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"which matches the right-to-left reading-order of the underlying array destructuring :`const [first, last] = Name[Symbol.matcher](x)`","msgtype":"m.text"},"ts":1618956996000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Or just chain whens like `when ^Name when [first, last] { ... }` (since `^Name` produces a new object to match, that you might even want to further reduce)","msgtype":"m.text"},"ts":1618957112000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"More verbose, but a deeper nesting might allow something like:","msgtype":"m.text"},"ts":1618957237000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618957237000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"match (...) {","msgtype":"m.text"},"ts":1618957237000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ^Name match {","msgtype":"m.text"},"ts":1618957237000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"    when ([\"foo\", bar]) {","msgtype":"m.text"},"ts":1618957237000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"    }","msgtype":"m.text"},"ts":1618957237000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"    when ([first, last]) {","msgtype":"m.text"},"ts":1618957238000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"    }","msgtype":"m.text"},"ts":1618957238000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  }","msgtype":"m.text"},"ts":1618957239000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618957239000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618957240000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Or, if you prefer sigils, maybe use an indirection like `when ^Name -> [first, last] { }`.","msgtype":"m.text"},"ts":1618957509000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Generally I think I like `into` since you could consider it as taking the return value of one match and passing it into another pattern:","msgtype":"m.text"},"ts":1618957509000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618957509000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"match (...) {","msgtype":"m.text"},"ts":1618957509000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ^Name into { firstName, lastName } { ... } // result must have `firstName` and `lastName` properties.","msgtype":"m.text"},"ts":1618957509000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618957509000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618957510000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"The only value `with` has is that its a keyword. Unfortunately one with a bad rep.","msgtype":"m.text"},"ts":1618957511000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"One last thought, then I'll stop bugging you about the proposal. The current explainer uses `->` into an expression context, but the new version uses \"implicit 'do' blocks\". That's probably fine for most expressions, but its going to be cumbersome for returning object literals:","msgtype":"m.text"},"ts":1618957960000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618957960000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x = match(y) {","msgtype":"m.text"},"ts":1618957960000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ({ z }) { [z] } // array","msgtype":"m.text"},"ts":1618957960000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ({ w }) { ({ w }) } // object","msgtype":"m.text"},"ts":1618957960000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"};","msgtype":"m.text"},"ts":1618957960000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618957961000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"vs.","msgtype":"m.text"},"ts":1618957961000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618957961000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x = match (y) {","msgtype":"m.text"},"ts":1618957962000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ({ z }) -> [z]","msgtype":"m.text"},"ts":1618958015000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ({ w }) -> {w}","msgtype":"m.text"},"ts":1618958015000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"};","msgtype":"m.text"},"ts":1618958015000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618958015000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I think it may catch some users off-guard. Makes me feel the cost savings of `when (^Name)` vs `when ^Name` don't quite cover the complexity of `{ ({ x }) }` :/","msgtype":"m.text"},"ts":1618958162000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"that's already true for `do` expressions tho, right?","msgtype":"m.text"},"ts":1618958942000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yeah, but `do` expressions have a specific use case, where you use them *because* you need a statement context. A lot of use cases for `match` are in expressions and you may not need a statement context, but one is forced on you.","msgtype":"m.text"},"ts":1618958997000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: The `into` keyword works for me if `with` is a no-go spelling. ^_^","msgtype":"m.text"},"ts":1618959000000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Not happy with the inverted order of your `from` example, I think it makes things *less* clear, since execution order actually jumps around","msgtype":"m.text"},"ts":1618959021000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"`with` isn't no-go, its just... well, `with`.","msgtype":"m.text"},"ts":1618959023000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Right.","msgtype":"m.text"},"ts":1618959030000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I didn't mean no-go from a parsing standpoint, just from an acceptability standpoint.","msgtype":"m.text"},"ts":1618959045000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It just happens to be how I first spelled it in my proposal.","msgtype":"m.text"},"ts":1618959055000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"But I actually kinda like the implicit meaning of `into` better","msgtype":"m.text"},"ts":1618959067000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"for the reason you gave above","msgtype":"m.text"},"ts":1618959084000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I wouldn't block on it using `with`, it just has that \"there be dragons\" feel to it","msgtype":"m.text"},"ts":1618959085000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"also, re: your issue about returning object literals, yeah, i feel you","msgtype":"m.text"},"ts":1618959146000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I'd be fine with just having the RHS be an expression, and relying on literal do-blocks when you need more. That was in an earlier version, I assume Jordan/Mark swapped it out for taste earlier.","msgtype":"m.text"},"ts":1618959190000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"`match` is just a better `?:` right (/s)? why not use `:` for expression-only, and `{}` for implicit `do` :)","msgtype":"m.text"},"ts":1618959206000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"rbuckton: i'll have on the repo an \"enhancement\" we could do where the RHS can just be a bare expression","msgtype":"m.text"},"ts":1618959237000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the reason we removed the `do` is because it would encourage people to do `async do` there, and have match expressions that only sometimes return a promise","msgtype":"m.text"},"ts":1618959259000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"we could do `when (‚Ä¶) <expr>` and `when (‚Ä¶) do { ‚Ä¶ }` and then let `async match` upgrade all the `do`s to `async do`s, i suppose","msgtype":"m.text"},"ts":1618959302000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959318000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x = match(y) {","msgtype":"m.text"},"ts":1618959319000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ({ z }): [z]","msgtype":"m.text"},"ts":1618959319000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ({ w }): { w }","msgtype":"m.text"},"ts":1618959319000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ({ v }) {","msgtype":"m.text"},"ts":1618959319000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"    // more complex statement-level processing","msgtype":"m.text"},"ts":1618959319000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  }","msgtype":"m.text"},"ts":1618959320000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618959320000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959321000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"and for a bare `if`?","msgtype":"m.text"},"ts":1618959365000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Heh, consider dropping blocks *and* `when` and you get this:","msgtype":"m.text"},"ts":1618959402000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959403000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x = match(y) {","msgtype":"m.text"},"ts":1618959403000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  ({ z }): [z], // need terminator so as not to interpret next line as call...","msgtype":"m.text"},"ts":1618959403000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  ({ w }): { w },","msgtype":"m.text"},"ts":1618959403000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  ({ v }) {","msgtype":"m.text"},"ts":1618959403000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"    // statements go here","msgtype":"m.text"},"ts":1618959403000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  }","msgtype":"m.text"},"ts":1618959403000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618959403000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959404000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"yeah, that seems a bit confusing with object literals","msgtype":"m.text"},"ts":1618959418000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959752000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x = match (obj.y) { // what if getter has side-effects","msgtype":"m.text"},"ts":1618959752000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  if (test(obj.y)): \"a\",","msgtype":"m.text"},"ts":1618959752000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  else: \"b\"","msgtype":"m.text"},"ts":1618959752000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"};","msgtype":"m.text"},"ts":1618959752000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// vs","msgtype":"m.text"},"ts":1618959753000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x = test(y) ? \"a\" : \"b\";","msgtype":"m.text"},"ts":1618959753000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959753000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"bare `if` feels weird without a topic variable (and I'm not a fan of topic variables), since side-effects are a thing. I'd almost rather do this:","msgtype":"m.text"},"ts":1618959754000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959755000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x = match (obj.y) { // what if getter has side-effects","msgtype":"m.text"},"ts":1618959755000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when (z) if (test(z)): \"a\",","msgtype":"m.text"},"ts":1618959756000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  else: \"b\"","msgtype":"m.text"},"ts":1618959756000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618959757000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959757000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"you could do `match (obj.y) as z {` and then `z` is your topic variable","msgtype":"m.text"},"ts":1618959878000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"otherwise it's just \"whatever you put in the matchable position\", which seems fine to me","msgtype":"m.text"},"ts":1618959894000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`match` is interesting in that you can ab^M^Muse it to introduce a temporary binding:","msgtype":"m.text"},"ts":1618959908000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959908000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x = match (fn()) { when (y) { y + y } };","msgtype":"m.text"},"ts":1618959908000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"// vs","msgtype":"m.text"},"ts":1618959908000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const x = do { let y = fn(); y + y; };","msgtype":"m.text"},"ts":1618959908000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618959908000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"the latter seems simpler to me","msgtype":"m.text"},"ts":1618959983000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so i'm not really worried about people doing that","msgtype":"m.text"},"ts":1618959989000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I assume each match pattern will evaluate `Get`? This introduces interesting side effects too:","msgtype":"m.text"},"ts":1618960069000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618960069000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const obj = {","msgtype":"m.text"},"ts":1618960069000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  count: 0,","msgtype":"m.text"},"ts":1618960069000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  get x() { return ++this.count; },","msgtype":"m.text"},"ts":1618960069000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"};","msgtype":"m.text"},"ts":1618960069000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"match (obj) {","msgtype":"m.text"},"ts":1618960069000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when({ x, y }) { }","msgtype":"m.text"},"ts":1618960070000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when({ x, count }) { console.log(count); } // prints: 2","msgtype":"m.text"},"ts":1618960070000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618960071000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618960071000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"i don't think it has to re-evaluate it","msgtype":"m.text"},"ts":1618960090000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Oh yeah we didn't talk about the `as`-on-matchable part of the grammar","msgtype":"m.text"},"ts":1618960099000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"each clause has to memoize any array-iterator values from the matchable already","msgtype":"m.text"},"ts":1618960101000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"so it seems reasonable to me to memoize the result of the Get too","msgtype":"m.text"},"ts":1618960112000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"to minimize observable operations","msgtype":"m.text"},"ts":1618960120000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"You can't memoize operations using `^` though, unless you match through a `Proxy` or something, so there's still an (albiet minor?) side-effect hazard there.","msgtype":"m.text"},"ts":1618960243000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"indeed that's true. but i think that would be expected.","msgtype":"m.text"},"ts":1618960262000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"And you wouldn't want to use a `Proxy`","msgtype":"m.text"},"ts":1618960263000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"most people don't have getter/proxy-based side effects in their program anyways","msgtype":"m.text"},"ts":1618960273000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"fair. And the `if` clauses can introduce side-effects anyways.","msgtype":"m.text"},"ts":1618960278000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Yeah, and you'd get the same side-effects there with an if-else chain","msgtype":"m.text"},"ts":1618960309000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ahem:","msgtype":"m.text"},"ts":1618960386000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618960386000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"match (x) {","msgtype":"m.text"},"ts":1618960386000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when(/a/) { ... }","msgtype":"m.text"},"ts":1618960386000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when(/b/) { ... }","msgtype":"m.text"},"ts":1618960386000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618960386000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"RegExp.$_; // ?","msgtype":"m.text"},"ts":1618960386000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618960387000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Regardless, I'm looking forward to pattern matching. I really do want to spend more time on my `enum` proposal to find something that everyone could agree on, and extend it to ADT-style enums:","msgtype":"m.text"},"ts":1618960771000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618960771000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"enum Foo {","msgtype":"m.text"},"ts":1618960771000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  A, // value","msgtype":"m.text"},"ts":1618960771000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  B(x, y), // tuple","msgtype":"m.text"},"ts":1618960771000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  C{ x, y } // record","msgtype":"m.text"},"ts":1618960772000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618960772000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"...","msgtype":"m.text"},"ts":1618960772000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"match (value) {","msgtype":"m.text"},"ts":1618960772000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ^Foo.A { ... }","msgtype":"m.text"},"ts":1618960773000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ^Foo.B into [x, y] { ... }","msgtype":"m.text"},"ts":1618960773000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when ^Foo.C into {x, y} { ... }","msgtype":"m.text"},"ts":1618960774000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618960774000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618960775000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Though I would have preferred a way to do something like this:","msgtype":"m.text"},"ts":1618960853000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618960854000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"match (value) {","msgtype":"m.text"},"ts":1618960854000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when Foo.A { ... }","msgtype":"m.text"},"ts":1618960854000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when Foo.B(x, y) { ... }","msgtype":"m.text"},"ts":1618960854000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  when Foo.C{x, y} { ... }","msgtype":"m.text"},"ts":1618960854000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"}","msgtype":"m.text"},"ts":1618960854000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618960854000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"I mean, if it's a language built-in, we can talk","msgtype":"m.text"},"ts":1618960960000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"If we've got `-Infinity` in as a literal matcher, we can do other things.","msgtype":"m.text"},"ts":1618960987000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It looks like that would consume the syntax space for dotted stuff, but it might be worthwhile to spend it on that.","msgtype":"m.text"},"ts":1618961059000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"The biggest complexity of the `enum` proposal is that I need to be sure it supports the constraints that ljharb and michaelficarra have brought to me, while still leaving room for the constraints that TypeScript has.","msgtype":"m.text"},"ts":1618961168000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"TypeScript needs number-valued enums, and IIRC, ljharb and michaelficarra would prefer Symbol-valued enums. I think its feasible to support both (and other kinds as well), with some kind of default behavior as long as there's a way to override it.","msgtype":"m.text"},"ts":1618961168000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"yeah, last time i looked at the enum proposal repo i was fairly happy with the way it allowed for both","msgtype":"m.text"},"ts":1618961196000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"iirc just by going off of the first value with an initializer, or something?","msgtype":"m.text"},"ts":1618961221000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"or there was some syntax? i forget. it was fine either way","msgtype":"m.text"},"ts":1618961229000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(i know i'd prefer symbol-valued enums by default; type confusion is a hell of a drug)","msgtype":"m.text"},"ts":1618961292000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"IIRC, in my last conversation with them about the proposal they were adamantly against number-valued enums from even existing, despite the fact that most languages support them and that they have their uses.","msgtype":"m.text"},"ts":1618961297000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"oh, we definitely need the ability to ahve them, for bitflags if nothing else","msgtype":"m.text"},"ts":1618961314000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"It was by going off of an `of` keyword, with a symbol-protocol for handling definitions.","msgtype":"m.text"},"ts":1618961326000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"ah yeah, right","msgtype":"m.text"},"ts":1618961338000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618961701000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"const enum Color of Symbol {","msgtype":"m.text"},"ts":1618961701000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  Red, // Symbol(Color.Red)","msgtype":"m.text"},"ts":1618961701000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  Green,","msgtype":"m.text"},"ts":1618961701000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  Blue","msgtype":"m.text"},"ts":1618961701000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Not sure how much of that made it through :/","msgtype":"m.text"},"ts":1618961722000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"and ignore the `const` part. Fingers on autopilot from TypeScript's `const enum` declarations :)","msgtype":"m.text"},"ts":1618961770000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"Its a bit like Python's enums, with `@@toEnum` serving as `_generate_next_value_`:","msgtype":"m.text"},"ts":1618961987000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618961987000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"class Color(Enum):","msgtype":"m.text"},"ts":1618961987000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  RED = auto()","msgtype":"m.text"},"ts":1618961987000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  BLUE = auto()","msgtype":"m.text"},"ts":1618961987000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"  GREEN = auto()","msgtype":"m.text"},"ts":1618961988000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"```","msgtype":"m.text"},"ts":1618961988000,"senderName":"rbuckton","senderId":"rbuckton@irc"},
{"content":{"body":"(and python also has IntEnum, IntFlags)","msgtype":"m.text"},"ts":1618961989000,"senderName":"rbuckton","senderId":"rbuckton@irc"}
]