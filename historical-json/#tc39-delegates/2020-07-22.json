[
{"content":{"body":"whoever is managing the schedule, the function tostring item is ready to be rescheduled for whenever works","msgtype":"m.text"},"ts":1595430343000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"quick reminder, we have #t39-beginners and i am doing descriptions of ongoing topics with a goal of explaining as much as possible","msgtype":"m.text"},"ts":1595437427000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"ystartsev: you should announce that in #tc39 too!","msgtype":"m.text"},"ts":1595438635000,"senderName":"akirose","senderId":"akirose@irc"},
{"content":{"body":"I believe a different chat tool would be easier to handle multiple channels but IRC is not helpful as it does not show the many options.","msgtype":"m.text"},"ts":1595438724000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"I don't have anything against more channels, but I believe it will eventually be very hard to find, even more for beginners. All because IRC","msgtype":"m.text"},"ts":1595438787000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"leobalter: we can add a section to the reflector (and maybe to the introductory email) listing out all the channels perhaps?","msgtype":"m.text"},"ts":1595438836000,"senderName":"ryzokuken","senderId":"ryzokuken@irc"},
{"content":{"body":"<3 for changing away from upsert","msgtype":"m.text"},"ts":1595438889000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I say this because I 100% agree with the issue you point out, but the whole debate to change chat platforms is extremely bikeshed-dy.","msgtype":"m.text"},"ts":1595438898000,"senderName":"ryzokuken","senderId":"ryzokuken@irc"},
{"content":{"body":"(and might take forever)","msgtype":"m.text"},"ts":1595438913000,"senderName":"ryzokuken","senderId":"ryzokuken@irc"},
{"content":{"body":"ryzokuken: it's remains counterintuitive. It's a different tool and land. Even worse if you consider beginners might not have access to the reflector (yet?) or are not used to it","msgtype":"m.text"},"ts":1595438921000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"even if \"emplace\" is different from the C++ meaning, I'm just excited that it's a real word","msgtype":"m.text"},"ts":1595438938000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I don't see IRC as ideal for our chat, I'm not a big fan of any chat tool, but fragmentation of multiple channels without a good handling might have negative effects.","msgtype":"m.text"},"ts":1595438990000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"it's unfortunate, because it's not at anyone's fault","msgtype":"m.text"},"ts":1595439005000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"again, while I 100% agree, I think it would take quite a lot of back and forth discussion to actually choose an alternative and make the switch.","msgtype":"m.text"},"ts":1595439037000,"senderName":"ryzokuken","senderId":"ryzokuken@irc"},
{"content":{"body":"oh, I see TC39 trying a new chat tool since I started participating","msgtype":"m.text"},"ts":1595439059000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"I know I also don't want Slack, but I'd personally like discord. I believe it would be very hard to have consensus.","msgtype":"m.text"},"ts":1595439124000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"ftr i abhor discord and love slack, so i agree it's a hard thing to solve","msgtype":"m.text"},"ts":1595439330000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i have a js discord server. its mostly full of noobs asking about discord.js but it could in theory host other discussions as well","msgtype":"m.text"},"ts":1595439389000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Can we mute Brian please?","msgtype":"m.text"},"ts":1595440304000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"bterlson: can you mute?","msgtype":"m.text"},"ts":1595440312000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"bterlson ^","msgtype":"m.text"},"ts":1595440314000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"does anyone else hear \"in-place\" every time someone says \"emplace\"?","msgtype":"m.text"},"ts":1595440590000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"Someone kicked me from the meeting.","msgtype":"m.text"},"ts":1595440592000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"jridgewell: i kicked you on purpose. kind of. I kicked the \"Unknown User\"","msgtype":"m.text"},"ts":1595440640000,"senderName":"akirose","senderId":"akirose@irc"},
{"content":{"body":"i agree with waldemar on emplace, we really should not name this emplace","msgtype":"m.text"},"ts":1595440640000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I don't know how to set my name on the iPad app","msgtype":"m.text"},"ts":1595440686000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"i have it set in Teams","msgtype":"m.text"},"ts":1595440690000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"IIRC emplace does mean a slightly different thing in C++","msgtype":"m.text"},"ts":1595440747000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"... perhaps more than slightly actually","msgtype":"m.text"},"ts":1595440756000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"jridgewell: i set it in the ipad app when clicking the teams link, before clicking \"sign in as guest\"","msgtype":"m.text"},"ts":1595440816000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu: +1","msgtype":"m.text"},"ts":1595440820000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I will say that, for CSS purposes, .getDefault() will *not* help me, but update() will.","msgtype":"m.text"},"ts":1595440871000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(Properties always exist on the property maps.)","msgtype":"m.text"},"ts":1595440878000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Ahh, signing up for Teams was a mistake then.","msgtype":"m.text"},"ts":1595440900000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"yay ty jridgewell !!","msgtype":"m.text"},"ts":1595440905000,"senderName":"akirose","senderId":"akirose@irc"},
{"content":{"body":"Will try again as a guest","msgtype":"m.text"},"ts":1595440907000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Oh, hm, calling `this.update()` from the insert() is an interesting case for the handler pattern.","msgtype":"m.text"},"ts":1595441244000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"What's bradley's irc nick?","msgtype":"m.text"},"ts":1595441382000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"bradleymeck","msgtype":"m.text"},"ts":1595441389000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Ah, skipped that because their last name is Farias.","msgtype":"m.text"},"ts":1595441411000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"bradleymeck: Yo, on review I see you *do* have a section in the proposal explicitly for \"update only\", I just missed it on my first quick read, sorry about that.","msgtype":"m.text"},"ts":1595441439000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"k","msgtype":"m.text"},"ts":1595441458000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"ljharb: Iterable is definitely a noun? An iterable, as distinct from an iterator?","msgtype":"m.text"},"ts":1595441640000,"senderName":"bterlson","senderId":"bterlson@irc"},
{"content":{"body":"iterable is any object with Symbol.iterator","msgtype":"m.text"},"ts":1595441686000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it doesn't prescribe a behaviour beyond that","msgtype":"m.text"},"ts":1595441697000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"\"An iterable isn't a noun\" 🤔","msgtype":"m.text"},"ts":1595441702000,"senderName":"bterlson","senderId":"bterlson@irc"},
{"content":{"body":"this is the same issue we had with iterator helpers","msgtype":"m.text"},"ts":1595441710000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"arguing about whether they should be iterable helpers","msgtype":"m.text"},"ts":1595441716000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bterlson: as a noun, you're right. but it really means \"it's one of the things that are iterable\"","msgtype":"m.text"},"ts":1595441842000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"An iterator is the same story isn't it?","msgtype":"m.text"},"ts":1595441871000,"senderName":"bterlson","senderId":"bterlson@irc"},
{"content":{"body":"i suppose that's true, but the iterator helpers proposal makes a canonical Iterator","msgtype":"m.text"},"ts":1595441902000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and that's what i'd expect Number.range to return","msgtype":"m.text"},"ts":1595441908000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"^ I wouldn't expect that. I would expect what MM expects, that the return of `Number.range()` could be iterated multiple times","msgtype":"m.text"},"ts":1595441957000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"rickbutton: the return of .keys/values/entries on arrays/maps/sets, and .matchAll, can't be","msgtype":"m.text"},"ts":1595441985000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and neither can the iterator produced by a userland generator","msgtype":"m.text"},"ts":1595441992000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"iow, \"can iterate multiple times\" is an expectation that will already bite you in a ton of places","msgtype":"m.text"},"ts":1595442004000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's true, but I guess I'm using the mental model of a concrete `Range` object that is safe to iterate many times, the same way you can iterate an `Array` many times","msgtype":"m.text"},"ts":1595442050000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"I like devsnek's reasoning.","msgtype":"m.text"},"ts":1595442085000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"+1","msgtype":"m.text"},"ts":1595442089000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"If it's a constructor, then it should be an iterable","msgtype":"m.text"},"ts":1595442096000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"agreed","msgtype":"m.text"},"ts":1595442101000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"If it's a function, it should be an iterator","msgtype":"m.text"},"ts":1595442103000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"like, in a language without iterators, I would assume `Number.range(a,b)` would return an `Array` with values from a->b","msgtype":"m.text"},"ts":1595442113000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"rickbutton: as would i. but this language has them","msgtype":"m.text"},"ts":1595442125000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'm also mildly in favor of `range(n)` == `range(0,n)` - I won't die if it's not there, but it's useful and clear.","msgtype":"m.text"},"ts":1595442128000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"it's the same reason matchAll didn't return an array","msgtype":"m.text"},"ts":1595442132000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"jridgewell: +1, yeah, if it's an iterator we *have* to go all the way to a class, or else the design feels incoherent","msgtype":"m.text"},"ts":1595442155000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I agree with function vs constructor => iterator vs iterable","msgtype":"m.text"},"ts":1595442160000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"UGH *iterable","msgtype":"m.text"},"ts":1595442162000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(as a design pattern)","msgtype":"m.text"},"ts":1595442173000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1595442177000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"So I think we need to look at the call pattern.","msgtype":"m.text"},"ts":1595442244000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"i also think sticking a function on the front is good from the perspective of being clear about when you're reusing something","msgtype":"m.text"},"ts":1595442246000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"It's used as `range(…)`, not `new Range(…)`","msgtype":"m.text"},"ts":1595442269000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"^","msgtype":"m.text"},"ts":1595442274000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"agree with \"big missing piece\"","msgtype":"m.text"},"ts":1595442357000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Strong +1 to Waldemar's upcoming question about start==end with inclusive; it should return the value once.","msgtype":"m.text"},"ts":1595442492000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I use range() a lot in Python, and I *have absolutey no idea* whether it's reusable or not. I have literally never once stored a range in a variable.","msgtype":"m.text"},"ts":1595442597000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"^ ditto 😅","msgtype":"m.text"},"ts":1595442652000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"same","msgtype":"m.text"},"ts":1595442654000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i think that observation is the key one","msgtype":"m.text"},"ts":1595442669000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"tab's, that is. the reusability sticking point is a red herring in practice","msgtype":"m.text"},"ts":1595442686000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i tried to note in the issue that it almost never happens","msgtype":"m.text"},"ts":1595442702000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"because people treat them as logic","msgtype":"m.text"},"ts":1595442706000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not data","msgtype":"m.text"},"ts":1595442708000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Wait that's a lie, I'm looking at a line where I do store a range in a variable (so I can manually increment it in the following loop), but it's not reused.","msgtype":"m.text"},"ts":1595442766000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"wow","msgtype":"m.text"},"ts":1595442780000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm sorry for disappointing you, devsnek","msgtype":"m.text"},"ts":1595442794000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: would it be prohibitive to stick it in a function if you needed that in JS?","msgtype":"m.text"},"ts":1595442826000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"absolutely not, i think \"wrap it in a function\" is completely reasonable here","msgtype":"m.text"},"ts":1595442843000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"wsdferdksl: Can you open an issue for your queue item","msgtype":"m.text"},"ts":1595442858000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"I think it should be addressed","msgtype":"m.text"},"ts":1595442874000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"hax is the only person i know that isn't on board with \"wrap it in a function\"","msgtype":"m.text"},"ts":1595442881000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"sorry to be a time stickler friends, but we're over time. Reminder to pick conservative timeboxes if you definitely want your proposal to advance 😀","msgtype":"m.text"},"ts":1595442903000,"senderName":"bterlson","senderId":"bterlson@irc"},
{"content":{"body":"actually maybe mark as well","msgtype":"m.text"},"ts":1595442908000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"couldn't tell","msgtype":"m.text"},"ts":1595442910000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Hmm. Yeah, these operators just avoid `Promise` and `()`. That's minor, but also, I can easily see it actually being mildly significant in a codebase that's heavily async.","msgtype":"m.text"},"ts":1595443072000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ljharb: stack traces in v8 already have nice stuff for Promise.all","msgtype":"m.text"},"ts":1595443131000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if they always use the built-in promise operations there's probably some performance implications as well","msgtype":"m.text"},"ts":1595443133000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it will tell you which index the error came from","msgtype":"m.text"},"ts":1595443140000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah I think it's pretty cool but syntax is soooo expensive, I don't know if this is one of those things we need to push on language learners","msgtype":"m.text"},"ts":1595443143000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"Bakkot: it'd be cool to see those numbers","msgtype":"m.text"},"ts":1595443160000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"devsnek: that is nice","msgtype":"m.text"},"ts":1595443207000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"michaelficarra: Bakkot: my intuition here is that the performance cost promise combinators is not the synchronous logic of the combinator","msgtype":"m.text"},"ts":1595443211000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"people *really* like using the shiny await syntax","msgtype":"m.text"},"ts":1595443219000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"speeding that up probably won't help","msgtype":"m.text"},"ts":1595443220000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"michaelficarra: On the other hand, idents/property access I think is the lightest possible syntax addition? Readable and even searchable, unlike grawlix operators.","msgtype":"m.text"},"ts":1595443226000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"and by having to use Promise.all to gain concurrency, a lot of code is unnecessarily sequential","msgtype":"m.text"},"ts":1595443236000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"providing await syntax for it would go a long way imo to improve that","msgtype":"m.text"},"ts":1595443251000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: i don't understand that point, how does this add new concurrency?","msgtype":"m.text"},"ts":1595443257000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I am also not sure on that point","msgtype":"m.text"},"ts":1595443298000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"what would be more interesting is for-await-concurrent","msgtype":"m.text"},"ts":1595443298000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"sure, but that's a different proposal","msgtype":"m.text"},"ts":1595443308000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: `await.all x` over `await Promise.all(x)` is identically concurrent","msgtype":"m.text"},"ts":1595443314000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: you said \"a lot of code is unnecessarily sequential\", implying new syntax will make them... concurrent?","msgtype":"m.text"},"ts":1595443340000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: i'm saying that people are more likely to *use* Promise.all semantics if there's syntax for it, because they *really* like using `await` and are under the misimpression that they don't have to use Promise things when using it","msgtype":"m.text"},"ts":1595443342000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu: i'm saying there's a lot of places people are doing `await x; await y;` where they could do `await.all [x, y]` instead (or `await Promise.all([x, y])` instead), and they're more likely to do that change if it's got syntax","msgtype":"m.text"},"ts":1595443376000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the current scenario is that `await` is an attractive nuisance *because* it makes it too easy to avoid properly using `Promise.all`","msgtype":"m.text"},"ts":1595443403000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: Agree, I think the syntax affordance, while *relatively* minor, can easily have outsized effects on actual usage.","msgtype":"m.text"},"ts":1595443415000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"hm, okay, that's an interesting point","msgtype":"m.text"},"ts":1595443436000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"that dan's making now i guess","msgtype":"m.text"},"ts":1595443440000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"`await.all ArrayLiteral` doesn't feel right to me yet","msgtype":"m.text"},"ts":1595443479000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but i like the general idea","msgtype":"m.text"},"ts":1595443482000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I mean, [] is the only way to invoke an n-ary operator, I guess.","msgtype":"m.text"},"ts":1595443507000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"fwiw, I suspect the \"use original value but accidentally call into customizable stuff\" is accidental - it probably *wants* to just use purely original stuff, like `await` does. (And I think it should do that.)","msgtype":"m.text"},"ts":1595443560000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"we could make `await.all (a, b)` work, but I don't seem much reason to","msgtype":"m.text"},"ts":1595443601000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the array literal is more orthogonal","msgtype":"m.text"},"ts":1595443608000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'm imagining some sort of block thing","msgtype":"m.text"},"ts":1595443619000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but i don't have it worked out yet","msgtype":"m.text"},"ts":1595443625000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Yeah, given that Promise.all() takes an array, having the syntax take n-ary args instead would be a very bad thing","msgtype":"m.text"},"ts":1595443673000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"just say no to varargs","msgtype":"m.text"},"ts":1595443691000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i still don't feel convinced that await.all significantly improves discoverability","msgtype":"m.text"},"ts":1595443764000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Sigh, if only we had named args...","msgtype":"m.text"},"ts":1595443765000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"that's what the argument comes down to, right?","msgtype":"m.text"},"ts":1595443772000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"TabAtkins: we do!","msgtype":"m.text"},"ts":1595443776000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that folks using await are simply unaware that it's promises under the hood","msgtype":"m.text"},"ts":1595443782000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"^ +1","msgtype":"m.text"},"ts":1595443791000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"shu: I don't understand what you're saying.","msgtype":"m.text"},"ts":1595443802000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"the assumption is that they don't know about promises","msgtype":"m.text"},"ts":1595443814000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: yes","msgtype":"m.text"},"ts":1595443814000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but know about await","msgtype":"m.text"},"ts":1595443816000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: that is accurate","msgtype":"m.text"},"ts":1595443818000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah I would rather educate","msgtype":"m.text"},"ts":1595443822000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"TabAtkins: the argument put forth by dan and jordan is that today, because devs know about async/await and _only_ know about async/await, they never learn it's all Promises under the hood","msgtype":"m.text"},"ts":1595443844000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i tell about 30 people a week on irc, every week for 5 years now, that `async`/`await` is not a replacement for promises, and that they still need to understand promises to use it properly.","msgtype":"m.text"},"ts":1595443850000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"\"dont' know about promises\" is not equal to \"reaches for linear awaits rather than Promise.all(), by default\"; the latter is the arg here.","msgtype":"m.text"},"ts":1595443851000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I don't think this is necessarily more obvious, because it's syntax that no one would expect to exist","msgtype":"m.text"},"ts":1595443852000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"it's not that they'll discover it","msgtype":"m.text"},"ts":1595443871000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it's that they can be told to use it, via review or a linter","msgtype":"m.text"},"ts":1595443876000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"TabAtkins: why do they reach for the linear awaits rather than Promise.all if they are aware of promises?","msgtype":"m.text"},"ts":1595443884000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"fair","msgtype":"m.text"},"ts":1595443884000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"It really is just easier to type `await p1; await p2;` than `await Promise.all([p1, p2]);`","msgtype":"m.text"},"ts":1595443887000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"shu: because most people don't seem to understand that promises are like a dependency graph, and that you should only await something when there's no additional work to kick off","msgtype":"m.text"},"ts":1595443911000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: on that note I had somebody talk about hitting no-return-await this morning and it was somebody I definitely thought should have known","msgtype":"m.text"},"ts":1595443913000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yep","msgtype":"m.text"},"ts":1595443918000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Without counting chars I can't tell if *three* promises in a row is shorter or longer than P.all(), but it's still *easier* to type - in particular, no `([...])` to type, which is slightly tricky.","msgtype":"m.text"},"ts":1595443931000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i mean, eslint even has a `require-await` rule, which is totally nonsensical, because the eslint maintainers didn't seem to understand async/await properly at the time.","msgtype":"m.text"},"ts":1595443940000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"are people just as likely to write their promise chains needlessly flat","msgtype":"m.text"},"ts":1595443973000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"heck, i see code all the time like `async function foo(promise) { let result = await promise; return result; }`","msgtype":"m.text"},"ts":1595443995000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"with promises, i find people are more likely to write things as separate variables than in a single long chain (which is what an async function full of `await`s is)","msgtype":"m.text"},"ts":1595444001000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yup, same intuition here.","msgtype":"m.text"},"ts":1595444023000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"https://es.discourse.group/t/array-prototype-uniqby/138","msgtype":"m.text"},"ts":1595444025000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: TabAtkins: thanks","msgtype":"m.text"},"ts":1595444064000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"This slope really isn't that slippery.","msgtype":"m.text"},"ts":1595444219000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I'm sorry I don't endorse hating on programming languages but i really do hate that about teaching/learning Ruby","msgtype":"m.text"},"ts":1595444272000,"senderName":"akirose","senderId":"akirose@irc"},
{"content":{"body":"what was the note about ruby","msgtype":"m.text"},"ts":1595444319000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"to be fair you could probably make filterMap much faster than filter + map","msgtype":"m.text"},"ts":1595444327000,"senderName":"keith_miller","senderId":"keith_miller@irc"},
{"content":{"body":"since you don't have to iterate the array twice","msgtype":"m.text"},"ts":1595444343000,"senderName":"keith_miller","senderId":"keith_miller@irc"},
{"content":{"body":"(I just had a WG discussion earlier today about adding more numeric constants to CSS (we already have e and pi); dealing with slippery-slope is a basic requirement of language design, not something we can or should ever be absolute about.)","msgtype":"m.text"},"ts":1595444354000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"`flatMap`?","msgtype":"m.text"},"ts":1595444365000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Yeah, filterMap() is actually specifically an example I'd use  as something to *add* ^_^","msgtype":"m.text"},"ts":1595444375000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"devsnek: there's a method for everything","msgtype":"m.text"},"ts":1595444391000,"senderName":"akirose","senderId":"akirose@irc"},
{"content":{"body":"does that mean we now need to do combinatorics of every prototype method?","msgtype":"m.text"},"ts":1595444402000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"jridgewell flatMap is a single operation for people coming from a fp background; I don't think that's true of filterMap etc","msgtype":"m.text"},"ts":1595444403000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`filterMap` and `mapFilter`?","msgtype":"m.text"},"ts":1595444410000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"then again there are all kinds of weird performance pathologies in the std library design I tell people fix on their own","msgtype":"m.text"},"ts":1595444415000,"senderName":"keith_miller","senderId":"keith_miller@irc"},
{"content":{"body":"Who would you differentiate between \"remove this\" and \"false\"?","msgtype":"m.text"},"ts":1595444422000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"how**","msgtype":"m.text"},"ts":1595444437000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"jridgewell: sentinel value provided to the callback","msgtype":"m.text"},"ts":1595444441000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"My favorite is that i tell everyone to relpace all the typed array methods with a per type one","msgtype":"m.text"},"ts":1595444441000,"senderName":"keith_miller","senderId":"keith_miller@irc"},
{"content":{"body":"Because you don't get hit with the polymorphism perf hit","msgtype":"m.text"},"ts":1595444468000,"senderName":"keith_miller","senderId":"keith_miller@irc"},
{"content":{"body":"drousso: \"if we do X, doesn't that mean we'd have to do combinations(X)\" is precisely the argument I was just saying isn't a valid argument here; applying judgement here on where the line is is already a basic part of language design.","msgtype":"m.text"},"ts":1595444486000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"oh yeah no i agree","msgtype":"m.text"},"ts":1595444499000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"keith_miller: pre-fused methods seems fine to me tbh if they're common enough","msgtype":"m.text"},"ts":1595444503000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i should've been clearer i was being more of a \"devils advocate to prove the problem\" 😅","msgtype":"m.text"},"ts":1595444545000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"this reminds me of how Dart's standard library has .splitMapJoin()","msgtype":"m.text"},"ts":1595444554000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ljharb: stepping back a conversation, what about having the linter complain about `await p1; await p2;` in current code?","msgtype":"m.text"},"ts":1595444626000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"drousso: Right, it's just never a useful objection to bring up at all, imo. \"If we add this, what else hits the same line? Is it a lot? Are we okay with that?\" is reasonable, but usually instead it's presented as an ipso facto rejection.","msgtype":"m.text"},"ts":1595444632000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i do think there is a very valid argument for \"if this passes muster, what are the criteria for other things passing that muster\"","msgtype":"m.text"},"ts":1595444670000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"btw, i'm signing off the meeting for the rest of the afternoon, got prep work for CSS f2f next week. (I'll still be in chat, just saying I won't be in convos.)","msgtype":"m.text"},"ts":1595444683000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I do agree that \"if we do X then we need to combinations(X)\" is not helpful","msgtype":"m.text"},"ts":1595444697000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"drousso: Right. Say that, instead, and I'll be happy. ^_^","msgtype":"m.text"},"ts":1595444697000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"fair","msgtype":"m.text"},"ts":1595444706000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"(Basically I've become very wary and alert, after twelve years of standards work, for fully-general counterarguments. If you apply the argument to virtually any topic with no change, it's not an argument, it's stop energy.)","msgtype":"m.text"},"ts":1595444757000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"*if you can apply","msgtype":"m.text"},"ts":1595444781000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ljharb: i'd still love to see some examples of people unwittingly serial awaiting where there is no inherent serialization required","msgtype":"m.text"},"ts":1595444931000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"oh that should be very easy to find","msgtype":"m.text"},"ts":1595444955000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"my experience is that serialization is rarely wrong, and that may be another reason why it's reached for by default","msgtype":"m.text"},"ts":1595444969000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"whereas you usually have to do a lot more thinking to make things parallel","msgtype":"m.text"},"ts":1595444993000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"almost by definition, serializing is almost never *wrong* compared with Promise.all()","msgtype":"m.text"},"ts":1595445017000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"well, precisely","msgtype":"m.text"},"ts":1595445038000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"this DX argument talks about an affordance so Promise combinators are easier to reach for, and if inadvertent incorrectness is a factor, that should affect the argument","msgtype":"m.text"},"ts":1595445158000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"bbl lunch","msgtype":"m.text"},"ts":1595445164000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"rkirsling: sometimes that's actually desired tho","msgtype":"m.text"},"ts":1595445203000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu: i see lots of things like `const a = await getA(); const b = await getB(); const c = await getC(B);` which should be `const [a, b] = await Promise.all([getA(), getB()]); const c = await getC(B);` (and even that's unnecessarily serial if what follows the `c` declaration doesn't actually require a, b, or c)","msgtype":"m.text"},"ts":1595445284000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"iow, i'd say serialization is wrong if it's not necessary","msgtype":"m.text"},"ts":1595445299000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"\u0015fwiw I almost never encounter this; glancing around my codebases it's all very linear data dependencies, at least within an individual function","msgtype":"m.text"},"ts":1595445358000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'm sure it varies by codebase domain, and individual programmer mindset","msgtype":"m.text"},"ts":1595445388000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but i'm often writing code where i have to make multiple async requests for data, but they can be intermixed in ways that increase concurrency.","msgtype":"m.text"},"ts":1595445429000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like, 2 requests require no input, 2 requests require input from 1 of the first one, and a final request requires 3 of the 4 results, or something","msgtype":"m.text"},"ts":1595445458000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"how about a native api for limiting concurrency","msgtype":"m.text"},"ts":1595445535000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i guess that's an option for Promise.all","msgtype":"m.text"},"ts":1595445544000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Isn't that just what the combinators/chaining already are?","msgtype":"m.text"},"ts":1595445568000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"not really for Promise.all","msgtype":"m.text"},"ts":1595445572000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Prome.all takes a set of promises for results which are already being computed","msgtype":"m.text"},"ts":1595445595000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh right no since you pass the already existing promises to promise.all","msgtype":"m.text"},"ts":1595445597000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so yeah concurrent scheduling api","msgtype":"m.text"},"ts":1595445611000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"class Promise.Queue","msgtype":"m.text"},"ts":1595445627000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Right. What I mean is, Promise.all() is already \"everything's concurrent\" and Promise#then() is already \"these two are serial\". So all the tools are already there. A more ergonomic API for setting up a dag out of promises might be reasonable, tho.","msgtype":"m.text"},"ts":1595445667000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"out of async functions, not promises","msgtype":"m.text"},"ts":1595445734000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"TabAtkins: its more like saying, only have 4 http requests going at once","msgtype":"m.text"},"ts":1595445736000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you'd set up a queue that schedules when the async functions are called","msgtype":"m.text"},"ts":1595445750000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Ah, ok, yeah that's a useful thing (tho I think beyond the scope of this discussion?)","msgtype":"m.text"},"ts":1595445799000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yeah it is","msgtype":"m.text"},"ts":1595445809000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i just momentarily messed up the abstraction in my head","msgtype":"m.text"},"ts":1595445816000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"re saying it was an option for promise.all","msgtype":"m.text"},"ts":1595445821000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: Oh, getting async function composition, hm.","msgtype":"m.text"},"ts":1595445828000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Like, the problem here is that the \"best\" way to handle async stuff is to *always* store async values in promise variables, and then *only* await them at the moment they're needed. If you do that, you can even do serial awaiting without a problem - you've already kicked off the operations, so serially awaiting the results is just fine (difference is just a few microtasks).","msgtype":"m.text"},"ts":1595445942000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"But people dont' do that, they await the operation immediately because it lets them continue to think about their code in sync terms, which is totally reasonable - asynchrony is *hard*.","msgtype":"m.text"},"ts":1595445980000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"So anything that makes it easier for people to reach for better asynchrony at the point of making async function calls is good, I think. `await.all` feels like it would help there, I think. (but i don't have strong feelings about it yet)","msgtype":"m.text"},"ts":1595446055000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(I was going to suggest that having an op that let you more easily treat a promise as its value at the point of use might help, but that's literally just `await` already. We just, uh, kinda screwed up the ergonomics of `await` from the get-go.)","msgtype":"m.text"},"ts":1595446256000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"nah await is good","msgtype":"m.text"},"ts":1595447085000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i agree with tab, `await` is way too easy to misuse in my experience.","msgtype":"m.text"},"ts":1595447212000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"await has *awful* ergonomics, because it's a low-precedence prefix operator.","msgtype":"m.text"},"ts":1595447263000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Can't mix it into a method chain without terribly awkward contortions, for instance.","msgtype":"m.text"},"ts":1595447283000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"about await* -- I really don't like the * use in generators; it feels like a mistake to me. i wish we'd use spread instead.","msgtype":"m.text"},"ts":1595447297000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"foo.bar().asyncaz()","msgtype":"m.text"},"ts":1595447299000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"await ...arr","msgtype":"m.text"},"ts":1595447311000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"`foo.bar().asyncBaz().qux()` is instead `(await foo.bar().asyncBaz()).qux()`, just awful","msgtype":"m.text"},"ts":1595447328000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I think Rust *slightly* screwed up their solution, but it's overall the right direction.","msgtype":"m.text"},"ts":1595447345000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"hence pipeline I guess","msgtype":"m.text"},"ts":1595447364000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Pipeline does make it a bit easier, yeah","msgtype":"m.text"},"ts":1595447375000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Eh, scratch that, pipeline basically solves that problem, yeah.","msgtype":"m.text"},"ts":1595447407000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"shu: your mic is enabled, if you didn't know","msgtype":"m.text"},"ts":1595447436000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"TabAtkins: in fact, my advice to all newcomers is \"start with no promise chains and no `await`s whatsoever. make a new variable for every `.then`/`.catch`. then, once everything's tested and working, refactor to use Promise.all _wherever possible_. then, make chains. and only *then*, use `await` in front of each chain","msgtype":"m.text"},"ts":1595447439000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: That's great advice, I wish everyone followed it. ^_^","msgtype":"m.text"},"ts":1595447454000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"rickbutton: i have a hardware mute","msgtype":"m.text"},"ts":1595447454000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"+1","msgtype":"m.text"},"ts":1595447460000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"thank you","msgtype":"m.text"},"ts":1595447487000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I tell newcomers the exact opposite of that","msgtype":"m.text"},"ts":1595447488000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"shu rickbutton on the hardware mute, Shush is a very nice app if you're on MacOS","msgtype":"m.text"},"ts":1595447523000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"write it with sequential `await`s first so the logic is clear, refactor to use `Promise.all` afterwards only when you have a reason to","msgtype":"m.text"},"ts":1595447530000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"premature optimization is the root of all evil","msgtype":"m.text"},"ts":1595447536000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"nice, TIL leobalter","msgtype":"m.text"},"ts":1595447549000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"more important to make the logic clear and correct","msgtype":"m.text"},"ts":1595447555000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"\"premature optimization *and* casual deoptimization are both pretty bad evils\" is my feeling, honestly","msgtype":"m.text"},"ts":1595447585000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"\"yeah I deopt, but I like to keep it casual\"","msgtype":"m.text"},"ts":1595447717000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ime the logic - which includes the implied dependency graph -  is clearer to newcomers with promises","msgtype":"m.text"},"ts":1595447967000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but obv both of our positions are anecdotal and subjective","msgtype":"m.text"},"ts":1595447989000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"this still doesn't support arbitrary compound keys though, since they can only contain value types","msgtype":"m.text"},"ts":1595448273000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"it could if it didn't disallow objects","msgtype":"m.text"},"ts":1595448309000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"although to be fair I think they have a solution to that by representing an object's identity","msgtype":"m.text"},"ts":1595448325000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"i'm hoping we can at least get boxes","msgtype":"m.text"},"ts":1595448365000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i wouldn't consider symbol weakmap stuff to be the solution here","msgtype":"m.text"},"ts":1595448406000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i came in late did this state that the value is normalized to a +0 value or if they are just equal for ==/===","msgtype":"m.text"},"ts":1595448509000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: pretty sure the latter","msgtype":"m.text"},"ts":1595448520000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"bradleymeck: it consider -0 === +0","msgtype":"m.text"},"ts":1595448527000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"does not normalize","msgtype":"m.text"},"ts":1595448532000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it also considers NaN === NaN","msgtype":"m.text"},"ts":1595448539000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"@wsdferdksl the earlier slide showed that order of entries in a record is *not* significant for equality","msgtype":"m.text"},"ts":1595448677000,"senderName":"robpalme","senderId":"robpalme@irc"},
{"content":{"body":"for which reason Symbols are disallowed as record keys","msgtype":"m.text"},"ts":1595448730000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"my computer just froze","msgtype":"m.text"},"ts":1595449473000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"why are symbols as record keys not possible?","msgtype":"m.text"},"ts":1595449475000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: i have comments ofc but i am restarting","msgtype":"m.text"},"ts":1595449485000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"devsnek: that's my queue question - i think it's because there's no way to sort them.","msgtype":"m.text"},"ts":1595449488000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: what does \"sort\" mean","msgtype":"m.text"},"ts":1595449495000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: as in, sorting the keys","msgtype":"m.text"},"ts":1595449501000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"why do keys need to be sorted","msgtype":"m.text"},"ts":1595449514000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so that `#{ a: 1, b: 2 }` and `#{ b: 2, a: 1 }` are equivalent","msgtype":"m.text"},"ts":1595449518000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"https://github.com/tc39/proposal-record-tuple/issues/15#issuecomment-662135746","msgtype":"m.text"},"ts":1595449520000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"https://github.com/tc39/proposal-record-tuple/issues/15#issuecomment-662415531","msgtype":"m.text"},"ts":1595449532000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the order of getOwnPropertySymbols seems very unmotivating","msgtype":"m.text"},"ts":1595449583000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"\"what the order is\", surely. but \"that it's consistent\"? i think it's pretty important","msgtype":"m.text"},"ts":1595449608000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"generally its just weird to me","msgtype":"m.text"},"ts":1595449613000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"as in, you are OK with Object.is(a, b) being true but getOwnPropertySymbols(a) not being the same as getOwnPropertySymbols(b)?","msgtype":"m.text"},"ts":1595449614000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that the order has to be part of this","msgtype":"m.text"},"ts":1595449617000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like you shouldn't need to sort the non-symbol keys either","msgtype":"m.text"},"ts":1595449625000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: yeah totally 100%","msgtype":"m.text"},"ts":1595449644000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"same for Object.keys","msgtype":"m.text"},"ts":1595449648000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"mm","msgtype":"m.text"},"ts":1595449657000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"well","msgtype":"m.text"},"ts":1595449658000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that is an opinion one could hold","msgtype":"m.text"},"ts":1595449663000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1595449667000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: two records with different orders and the same keys shouldn't be distinguishable tho.","msgtype":"m.text"},"ts":1595449669000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"are people determining identity by the order of keys on things?","msgtype":"m.text"},"ts":1595449698000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the other way around","msgtype":"m.text"},"ts":1595449707000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"people assume that if a and b are the same, then then are indistinguishable","msgtype":"m.text"},"ts":1595449718000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this being what it means to be \"the same\"","msgtype":"m.text"},"ts":1595449723000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"A is A","msgtype":"m.text"},"ts":1595449726000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it seems to me that they're the same even if the keys are in different orders","msgtype":"m.text"},"ts":1595449739000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't hold that intuition","msgtype":"m.text"},"ts":1595449772000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if they are distinguishable they are not that same","msgtype":"m.text"},"ts":1595449775000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"*not the same","msgtype":"m.text"},"ts":1595449778000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"things are the same only when every single aspect of them are identical","msgtype":"m.text"},"ts":1595449782000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"otherwise they can only be similar, not the same","msgtype":"m.text"},"ts":1595449790000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"an engine can have a stable sorting of symbols","msgtype":"m.text"},"ts":1595449797000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"as littledan is explaining right now","msgtype":"m.text"},"ts":1595449804000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"how would we specify that tho","msgtype":"m.text"},"ts":1595449847000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"what is mark saying rn","msgtype":"m.text"},"ts":1595449848000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"side channel through symbol keys?","msgtype":"m.text"},"ts":1595449856000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb gloabl incrementing counter works fine","msgtype":"m.text"},"ts":1595449856000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"without communicating \"symbol creation time\"","msgtype":"m.text"},"ts":1595449859000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"we could put a counter on them","msgtype":"m.text"},"ts":1595449875000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like if i do `const a = Symbol(); const b = Symbol(); return [b, a]` you shouldn't be able to determine that i made `a` first","msgtype":"m.text"},"ts":1595449877000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"agent.symbolcounter","msgtype":"m.text"},"ts":1595449878000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek I believe the example is https://github.com/tc39/proposal-record-tuple/issues/15#issuecomment-662545733","msgtype":"m.text"},"ts":1595449879000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"my computer froze at a most inopportune","msgtype":"m.text"},"ts":1595449881000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"time","msgtype":"m.text"},"ts":1595449882000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"bakkot: what was said about implementer concerns?","msgtype":"m.text"},"ts":1595449892000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ah i see","msgtype":"m.text"},"ts":1595449907000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"we had a similar concern to this as well","msgtype":"m.text"},"ts":1595449914000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"Bakkot: in terms of implementation i was thinking of using the value's hash code to sort","msgtype":"m.text"},"ts":1595449918000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: I said I want implementation buy in before stage 3, ystartsev said they've been talking about it and are tentatively in favor, moddable said they're concerned","msgtype":"m.text"},"ts":1595449919000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the object/record issue","msgtype":"m.text"},"ts":1595449921000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"\"fatigue\" is a very good word","msgtype":"m.text"},"ts":1595449922000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that wouldn't reveal their creation order","msgtype":"m.text"},"ts":1595449941000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: okay thanks","msgtype":"m.text"},"ts":1595449957000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"devsnek: how would two symbols with the same description have different hash codes, but not reveal creation order","msgtype":"m.text"},"ts":1595449962000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: and also not be random","msgtype":"m.text"},"ts":1595449970000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: yep, we have been talking to them a lot and giving feedback. we aren't 100% \"yes this should happen\", but we do see the motivation and think its worth investing more time / giving it stage 2 (just to reiterate)","msgtype":"m.text"},"ts":1595449974000,"senderName":"ystartsev","senderId":"ystartsev@irc"},
{"content":{"body":"devsnek it would probably reveal memory addresses, which is worse","msgtype":"m.text"},"ts":1595449975000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek that's like an actual security issue","msgtype":"m.text"},"ts":1595449979000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"hashes aren't memory addresses","msgtype":"m.text"},"ts":1595449982000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for objects with identity they frequently are","msgtype":"m.text"},"ts":1595449990000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if they're not deterministically based on observable traits, how could they not be","msgtype":"m.text"},"ts":1595450004000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"iirc v8 chooses them from a pseudorandom number generator","msgtype":"m.text"},"ts":1595450007000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: literally hashing the counter?","msgtype":"m.text"},"ts":1595450018000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"or using a PRNG, another fair example","msgtype":"m.text"},"ts":1595450034000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"michaelficarra hashing the counter would work, but if you have a counter, just use the counter, and then it's stable across engines too","msgtype":"m.text"},"ts":1595450035000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"though I guess leaks the thing","msgtype":"m.text"},"ts":1595450051000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"personally I kind of like random-but-stable ordering; I proposed it in the above issue I think","msgtype":"m.text"},"ts":1595450072000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"maybe I proposed random-per-read","msgtype":"m.text"},"ts":1595450081000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"found it https://source.chromium.org/chromium/chromium/src/+/master:v8/src/execution/isolate.cc;drc=0ee4438ca83448bca93cb11bc3012856d29303dd;l=3893","msgtype":"m.text"},"ts":1595450086000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek yeah they do that because of exactly the security issue I mention, I am pretty sure","msgtype":"m.text"},"ts":1595450107000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I reject Mark's claim that it necessarily leads to a communications channel","msgtype":"m.text"},"ts":1595450112000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"if there was no ordering it would be a communication channel","msgtype":"m.text"},"ts":1595450125000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Is the \"Equality semantics for `-0` and `NaN`\"(https://github.com/tc39/proposal-record-tuple/issues/65) postponed to be decided at stage3 so it's not a concern to have consensus at this stage? It's been quite a hot debate (154 comments).","msgtype":"m.text"},"ts":1595450134000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"devsnek but compare: https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--","msgtype":"m.text"},"ts":1595450134000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"haxjs: afaict it's decided","msgtype":"m.text"},"ts":1595450147000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"\"This is typically implemented by converting the internal address of the object into an integer\"","msgtype":"m.text"},"ts":1595450147000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: lets not do what java does","msgtype":"m.text"},"ts":1595450154000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"haxjs: SameValueZero, basically","msgtype":"m.text"},"ts":1595450157000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek :P fair","msgtype":"m.text"},"ts":1595450159000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek but that means we have to write something down which isn't \"do whatever you want\", is my point","msgtype":"m.text"},"ts":1595450175000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"because the obvious whatever-you-want thing is memory address","msgtype":"m.text"},"ts":1595450182000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb  it is labeled as \"undecided point\"","msgtype":"m.text"},"ts":1595450207000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"I think we should allow implementations to use the memory address if they want","msgtype":"m.text"},"ts":1595450213000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"haxjs: ah. if it gets stage 2 with those semantics i would take that as decided","msgtype":"m.text"},"ts":1595450225000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Moddable may choose to use the memory address, for example","msgtype":"m.text"},"ts":1595450232000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"haxjs: but i suppose it could change within stage 2 if needed","msgtype":"m.text"},"ts":1595450233000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: \"a unique number which is not correlated with the object's location in memory or when it was created\"","msgtype":"m.text"},"ts":1595450243000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":":P","msgtype":"m.text"},"ts":1595450244000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"works for me tbh","msgtype":"m.text"},"ts":1595450264000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what is \"memory\" according to the spec","msgtype":"m.text"},"ts":1595450278000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"spec does not have the concept","msgtype":"m.text"},"ts":1595450286000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this actual wording wouldn't work","msgtype":"m.text"},"ts":1595450289000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"does atomics not talk about memory","msgtype":"m.text"},"ts":1595450298000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but we could find something like it","msgtype":"m.text"},"ts":1595450299000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek nope","msgtype":"m.text"},"ts":1595450302000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"well","msgtype":"m.text"},"ts":1595450305000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"e","msgtype":"m.text"},"ts":1595450306000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it has a memory model","msgtype":"m.text"},"ts":1595450307000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but not in the sense which is relevant here","msgtype":"m.text"},"ts":1595450313000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"we could definitely specify this","msgtype":"m.text"},"ts":1595450321000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"is the point","msgtype":"m.text"},"ts":1595450322000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that V8 identity hash is very slightly biased to 1","msgtype":"m.text"},"ts":1595450324000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"whoever is anonymous wombat, you are doing an awesome job is taking note, my hands are burning! ","msgtype":"m.emote"},"ts":1595450337000,"senderName":"howdoi","senderId":"howdoi@irc"},
{"content":{"body":"michaelficarra: report to h1","msgtype":"m.text"},"ts":1595450348000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":":^)","msgtype":"m.text"},"ts":1595450350000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i am not sure that we can _definitely_ spec \"memory\" writ large","msgtype":"m.text"},"ts":1595450375000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"we can say that it shouldn't be correlated to when the object was created","msgtype":"m.text"},"ts":1595450404000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and leave security to implementors","msgtype":"m.text"},"ts":1595450414000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: +1","msgtype":"m.text"},"ts":1595450438000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"not all implementors have the same security model","msgtype":"m.text"},"ts":1595450453000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"its my right to make a js engine that can be pwned","msgtype":"m.text"},"ts":1595450455000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"normative note: must not allow pwnage","msgtype":"m.text"},"ts":1595450467000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it's your right to catch covid too i guess","msgtype":"m.text"},"ts":1595450473000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"that depends on your system of morality","msgtype":"m.text"},"ts":1595450474000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this feels like tdz now","msgtype":"m.text"},"ts":1595450486000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"michaelficarra / devsnek if you have a concrete way of specing symbols in records which wouldn't violate either the \"Object.is implies indistinguishable\" constraint or the \"does not side channel symbol creation time\" constraint, I think it would be worth opening on the issue tracker","msgtype":"m.text"},"ts":1595450577000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"though it would probably be a followon proposal at this point","msgtype":"m.text"},"ts":1595450587000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"brad4d: The reason symbols were disallowed was because there was no way to ever make a symbol \"weak\" if one can reconstruct it at will.","msgtype":"m.text"},"ts":1595451381000,"senderName":"wsdferdksl","senderId":"wsdferdksl@irc"},
{"content":{"body":"can we stay on the current proposal, is that a point of order","msgtype":"m.text"},"ts":1595451411000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"This led to the debate over whether we should disallow some symbols and no others, and after a while we decided to not allow any.","msgtype":"m.text"},"ts":1595451423000,"senderName":"wsdferdksl","senderId":"wsdferdksl@irc"},
{"content":{"body":"s/no/not/","msgtype":"m.text"},"ts":1595451485000,"senderName":"wsdferdksl","senderId":"wsdferdksl@irc"},
{"content":{"body":"there has to be some sort of thing","msgtype":"m.text"},"ts":1595451496000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that fulfills being a nice api","msgtype":"m.text"},"ts":1595451501000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and the ses requirements","msgtype":"m.text"},"ts":1595451504000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh man i would love if r&t could just hold objects","msgtype":"m.text"},"ts":1595451705000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you don't lose the performance of deeply immutable by it referencing an object do you?","msgtype":"m.text"},"ts":1595451850000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the benefit of deep immutable to performance is that you can safely pass it around without having copying","msgtype":"m.text"},"ts":1595451871000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if it holds an object that is no longer the case, and you have to defensively copy all records and tuples","msgtype":"m.text"},"ts":1595451885000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"how is that the case","msgtype":"m.text"},"ts":1595451896000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which of those two things?","msgtype":"m.text"},"ts":1595451909000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the loss of no-copy","msgtype":"m.text"},"ts":1595451914000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"uh","msgtype":"m.text"},"ts":1595451923000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the point of defensive copying is that you can hand it to someone you don't trust, and not worry about your data getting mangled","msgtype":"m.text"},"ts":1595451938000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if you hand them a pointer to a mutable thing you still want to use, you have to worry about that","msgtype":"m.text"},"ts":1595451951000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but if you put an unfrozen object in your record/tuple, aren't you already explicitly ok with that?","msgtype":"m.text"},"ts":1595451964000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"even if the pointer is embedded in an immutable thing","msgtype":"m.text"},"ts":1595451965000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh so you weren't answering the performance question","msgtype":"m.text"},"ts":1595451973000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I was answering the performacne question","msgtype":"m.text"},"ts":1595451982000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the performance benefit is, you don't have to defensive-copy to avoid this worry","msgtype":"m.text"},"ts":1595451994000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you still don't have to defensively copy the record","msgtype":"m.text"},"ts":1595452006000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"its immutable","msgtype":"m.text"},"ts":1595452009000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if it holds an object, then you do have to","msgtype":"m.text"},"ts":1595452021000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(deeply)","msgtype":"m.text"},"ts":1595452026000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"because handing it out gives you access to a mutable thing","msgtype":"m.text"},"ts":1595452038000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"don't put the secure part in an object","msgtype":"m.text"},"ts":1595452038000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"just because you can have an object in a record doesn't mean you have to","msgtype":"m.text"},"ts":1595452054000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah it just means you have to be defensive all the time, instead of being able to trust that records and tuples are safe to hand around","msgtype":"m.text"},"ts":1595452090000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i don't understand what you're defending against","msgtype":"m.text"},"ts":1595452116000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"people forgetting that something is an object?","msgtype":"m.text"},"ts":1595452121000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you still have to defensively remember to use records","msgtype":"m.text"},"ts":1595452148000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if my API takes records, I can use them and hand them to other people without worrying about breaking my caller's guarantees","msgtype":"m.text"},"ts":1595452181000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if it takes records but records can hold objects, this is not the case","msgtype":"m.text"},"ts":1595452191000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that breaks the guarantee that you can pass an object","msgtype":"m.text"},"ts":1595452198000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"my point being that there are a lot of tradeoffs here","msgtype":"m.text"},"ts":1595452214000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"how does it break that guarantee?","msgtype":"m.text"},"ts":1595452226000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or like","msgtype":"m.text"},"ts":1595452246000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what guarantee are you talking about, I guess","msgtype":"m.text"},"ts":1595452250000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the ability to pass an object","msgtype":"m.text"},"ts":1595452259000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"also why is it your api's problem if the caller passes a mutable structure","msgtype":"m.text"},"ts":1595452277000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I can take an object just fine I just have to deep-copy it first, which I do not have to do with records","msgtype":"m.text"},"ts":1595452313000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"why do you have to deep copy it","msgtype":"m.text"},"ts":1595452324000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"its the caller's object","msgtype":"m.text"},"ts":1595452332000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe they already deep copied it before giving it to you","msgtype":"m.text"},"ts":1595452337000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it is my API's problem if it mutates things its caller expects not to be mutated","msgtype":"m.text"},"ts":1595452343000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"don't do that","msgtype":"m.text"},"ts":1595452348000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"mutating an object you didn't create doesn't seem like a defensible practice","msgtype":"m.text"},"ts":1595452358000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"right, the point is I am trying to avoid doing this","msgtype":"m.text"},"ts":1595452369000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and if it's a record you can't mutate it anyways","msgtype":"m.text"},"ts":1595452370000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"right, the point is that I don't have to worry about it if it's a record","msgtype":"m.text"},"ts":1595452385000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that is the whole point","msgtype":"m.text"},"ts":1595452390000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i don't understand how <random thing from person> ends up being mutated","msgtype":"m.text"},"ts":1595452390000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if you're not mutating it, you don't have to worry regardless","msgtype":"m.text"},"ts":1595452397000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and if you are, you can't take a record anyways","msgtype":"m.text"},"ts":1595452402000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'm confused","msgtype":"m.text"},"ts":1595452406000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"\"oops i accidentally created a property on the value\" i don't get how this would happen","msgtype":"m.text"},"ts":1595452411000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this happens if I am handing it off to other code","msgtype":"m.text"},"ts":1595452432000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sure, *that* code might mutate it","msgtype":"m.text"},"ts":1595452438000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the security of the object was not yours to begin with","msgtype":"m.text"},"ts":1595452453000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but similarly, it can't take a record if it's doing that","msgtype":"m.text"},"ts":1595452453000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it was whoever gave it to you","msgtype":"m.text"},"ts":1595452462000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek that is a position one can take, but I am very glad that position is not widely held among library authors","msgtype":"m.text"},"ts":1595452494000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so to give it something and have it not mutate it, you already have to know if \"it mutates\"","msgtype":"m.text"},"ts":1595452496000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i mean, i don't *want* anything someone gives me to be mutated, even transitively","msgtype":"m.text"},"ts":1595452512000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb if the other code takes a record, I don't have to know that!","msgtype":"m.text"},"ts":1595452512000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i would be very sad to know the only reason library authors aren't mutating things is because they *can't*","msgtype":"m.text"},"ts":1595452520000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ystartsev: Thanks for keeping the symbols as weakmap keys proposal honest on Stage 2 requirements. We need to do better about not deviating from the stage process.","msgtype":"m.text"},"ts":1595452529000,"senderName":"sffc","senderId":"sffc@irc"},
{"content":{"body":"Bakkot: so you're saying, this relieves a code auditing burden of your deps?","msgtype":"m.text"},"ts":1595452537000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb if the other code takes a record, I can trust that it is not going to accidentally mutate stuff, without checking its implementation","msgtype":"m.text"},"ts":1595452542000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1595452544000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"could we give object in record/tuple a special syntax to avoid such problem?","msgtype":"m.text"},"ts":1595452545000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"no one audits their deps","msgtype":"m.text"},"ts":1595452548000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i still don't get the whole \"accidentally mutate\" thing","msgtype":"m.text"},"ts":1595452558000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: i do :-p but i'm not confused now, thanks","msgtype":"m.text"},"ts":1595452561000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb I have seen you contribute to projects for which I am 100% confident you have not read all the code in the transitive dependency graph of the project","msgtype":"m.text"},"ts":1595452601000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"probably doesn't have security concerns about those projects?","msgtype":"m.text"},"ts":1595452629000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it's not a security concern","msgtype":"m.text"},"ts":1595452640000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it's a correctness concern","msgtype":"m.text"},"ts":1595452643000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you said it was a security concern","msgtype":"m.text"},"ts":1595452646000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I did not","msgtype":"m.text"},"ts":1595452649000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: contribute to, sure, but maintain? i should hope not","msgtype":"m.text"},"ts":1595452654000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: please lmk if that's not true","msgtype":"m.text"},"ts":1595452659000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if i'm going to accidentally mutate something","msgtype":"m.text"},"ts":1595452662000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why don't i accidentally forget to enforce it being a record","msgtype":"m.text"},"ts":1595452671000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you don't solve forgetfulness by adding self-checked requirements","msgtype":"m.text"},"ts":1595452696000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: if I am calling a library, then either I need to a.) trust it not to mutate the object, b.) check its implementation, or c.) be guaranteed that it cannot mutate the object because it takes records rather than objects","msgtype":"m.text"},"ts":1595452742000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"a.) and b.) both suck","msgtype":"m.text"},"ts":1595452747000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"c.) only works if \"it takes records\" implies \"it cannot mutate its arguments\"","msgtype":"m.text"},"ts":1595452757000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'm not sure i've ever had this problem","msgtype":"m.text"},"ts":1595452764000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like i don't feel the need to ensure libraries don't mutate things i pass to them","msgtype":"m.text"},"ts":1595452774000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"/shrug","msgtype":"m.text"},"ts":1595452780000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"c) there is the -entire- benefit of immutable data structures over mutable ones","msgtype":"m.text"},"ts":1595452787000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"like I said, it's a correctness thing","msgtype":"m.text"},"ts":1595452788000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it means that you don't need to reason about a whole class of problems, because they cannot happen","msgtype":"m.text"},"ts":1595452804000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"rickbutton: no one is taking away the immutable structure","msgtype":"m.text"},"ts":1595452807000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if records can contain mutable data, then yes, you are","msgtype":"m.text"},"ts":1595452824000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you're taking away the \"deeply\" part","msgtype":"m.text"},"ts":1595452826000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yes, i should say, deeply","msgtype":"m.text"},"ts":1595452831000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"only if you create that","msgtype":"m.text"},"ts":1595452832000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"no one is making you create that","msgtype":"m.text"},"ts":1595452835000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"no one's forcing you to mutate regular objects","msgtype":"m.text"},"ts":1595452841000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"use those","msgtype":"m.text"},"ts":1595452842000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so if u don't want it mutate , don't send record with objects...","msgtype":"m.text"},"ts":1595452850000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"i'm mostly interested in records for compound values","msgtype":"m.text"},"ts":1595452875000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"not for the immutability","msgtype":"m.text"},"ts":1595452878000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"then you are not the main target audience","msgtype":"m.text"},"ts":1595452886000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it can have multiple target audicnes","msgtype":"m.text"},"ts":1595452893000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes, and tradeoffs were decided for the immutable audience","msgtype":"m.text"},"ts":1595452897000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"as long as you can still have a deeply mutable record","msgtype":"m.text"},"ts":1595452950000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek \"just be careful when writing it\" means that you _do_ have to reason about this class of problems","msgtype":"m.text"},"ts":1595452959000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek: that's not how the guarantees work","msgtype":"m.text"},"ts":1595452967000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i'm unconvinced but also not the majority so 🤷🏻","msgtype":"m.text"},"ts":1595453087000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"you're unconvinced that's not how guarantees work?","msgtype":"m.text"},"ts":1595453104000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i'm unconvinced the guarantee is useful enough to warrant this design choice","msgtype":"m.text"},"ts":1595453126000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah, then i daresay that is a pretty fringe opinion on the benefits of the deeply immutable guarantee","msgtype":"m.text"},"ts":1595453154000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i've used languages like rust that enforce immutability and people invent a lot of ways out","msgtype":"m.text"},"ts":1595453204000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"refs boxes pointers etc","msgtype":"m.text"},"ts":1595453215000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it has a type system","msgtype":"m.text"},"ts":1595453236000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the type system says the reference is immutable","msgtype":"m.text"},"ts":1595453250000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but you can get a mut ref to one of the children","msgtype":"m.text"},"ts":1595453256000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"same vein","msgtype":"m.text"},"ts":1595453262000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I have no idea what this JSON.stringify example is doing. Why is serialization needed?","msgtype":"m.text"},"ts":1595453268000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"i missed that","msgtype":"m.text"},"ts":1595453297000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"We already have the serializer arg to encode a `BigInt` into whatever you want.","msgtype":"m.text"},"ts":1595453318000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"you don't return a string from that","msgtype":"m.text"},"ts":1595453330000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't think","msgtype":"m.text"},"ts":1595453334000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"You can return anything","msgtype":"m.text"},"ts":1595453344000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"you can't return a bigint","msgtype":"m.text"},"ts":1595453348000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"jridgewell  i guess it allow u to deal with json generated by others.","msgtype":"m.text"},"ts":1595453351000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"you can't return a string of digits","msgtype":"m.text"},"ts":1595453354000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or rather, you can return a string containing digits","msgtype":"m.text"},"ts":1595453362000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but it will be a string in the json","msgtype":"m.text"},"ts":1595453368000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but not a sequence of digits which will appear in the json","msgtype":"m.text"},"ts":1595453368000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"not a number type","msgtype":"m.text"},"ts":1595453370000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1595453374000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so you can't stringify bigints larger than 2**53","msgtype":"m.text"},"ts":1595453387000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"jridgewell: for example, this proposal would have saved twitter a *ton* of engineering effort when tweet IDs hit 2**53","msgtype":"m.text"},"ts":1595453397000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"some lib may output int64","msgtype":"m.text"},"ts":1595453398000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"shu: JSON.parse with a reviver is performance sensitive?","msgtype":"m.text"},"ts":1595453404000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"https://www.irccloud.com/pastebin/Laqx6roR/stringify.js","msgtype":"m.text"},"ts":1595453416000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"jridgewell: they had to add `id_str` next to `id` on every single API response, and input, rather than just providing a serializer/reviver","msgtype":"m.text"},"ts":1595453420000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"michaelficarra: dunno, but JSON.parse in general is","msgtype":"m.text"},"ts":1595453425000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"jridgewell: that's a string, not numeric digits","msgtype":"m.text"},"ts":1595453430000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"michaelficarra: something worth verifying. this is asking for an extra allocation per reviver call","msgtype":"m.text"},"ts":1595453439000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"jridgewell: when the (non-JS) server parses that, it will get a string and not an integer","msgtype":"m.text"},"ts":1595453442000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"You need an interpreter on both sides","msgtype":"m.text"},"ts":1595453459000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"shu: I imagine most of the performance sensitive cases do not take a reviver","msgtype":"m.text"},"ts":1595453461000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"no","msgtype":"m.text"},"ts":1595453462000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"jridgewell: non-JS JSON parsers handle numbers larger than MAX_SAFE_INTEGER just fine, since json allows it","msgtype":"m.text"},"ts":1595453476000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"jridgewell: right now the use case is a json numeric literal that is greater than a double","msgtype":"m.text"},"ts":1595453479000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"jridgewell: it is *only* JS that can't handle the full range of json numbers","msgtype":"m.text"},"ts":1595453483000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"string literal also useful","msgtype":"m.text"},"ts":1595453496000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"ljharb that's not true at all","msgtype":"m.text"},"ts":1595453537000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no?","msgtype":"m.text"},"ts":1595453540000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"very few languages can handle the full range of JSON numbers","msgtype":"m.text"},"ts":1595453544000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1595453546000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1595453547000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"most do not have arbitrary-precision floats","msgtype":"m.text"},"ts":1595453550000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"JSON numbers are infinite","msgtype":"m.text"},"ts":1595453553000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"even if they have bigints","msgtype":"m.text"},"ts":1595453556000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"at least they can deal with int64","msgtype":"m.text"},"ts":1595453560000,"senderName":"haxjs","senderId":"haxjs@irc"},
{"content":{"body":"well, for example, the apache thrift json code - that tons of things use - produces and accepts numbers that JS can't","msgtype":"m.text"},"ts":1595453564000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"js is unique in that it can't do 64 bits","msgtype":"m.text"},"ts":1595453567000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well mostly unique","msgtype":"m.text"},"ts":1595453571000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so all of twitter's non-JS stack could handle tweet IDs except JS","msgtype":"m.text"},"ts":1595453575000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"discord uses snowflakes but it makes them strings","msgtype":"m.text"},"ts":1595453599000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"michaelficarra: you're not convinced of the need for serialization?","msgtype":"m.text"},"ts":1595453746000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah nvm","msgtype":"m.text"},"ts":1595453759000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the need to create arbitrary JSON","msgtype":"m.text"},"ts":1595453821000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"there is not need, and if you do need that, you probably don't want to be using JSON.stringify","msgtype":"m.text"},"ts":1595453833000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"arbitrary module namespace identifiers are cool and we should advance to stage 4","msgtype":"m.text"},"ts":1595454034000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"allowing a \"*default*\" export that's not the default export breaks the Shift AST :-(","msgtype":"m.text"},"ts":1595454173000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"devsnek: +1","msgtype":"m.text"},"ts":1595454190000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"michaelficarra: *default* is runtime right? how did that leak into shift ast 👀","msgtype":"m.text"},"ts":1595454241000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bradleymeck: the prose at the top of the spec says utf8","msgtype":"m.text"},"ts":1595454303000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek function declarations require a binding identifier, binding identifier for `export default function (){}` is `*binding*`","msgtype":"m.text"},"ts":1595454372000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: doh","msgtype":"m.text"},"ts":1595454401000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"(not a choice I'm all that thrilled about)","msgtype":"m.text"},"ts":1595454403000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah I don't love that we did it, but it was following spec","msgtype":"m.text"},"ts":1595454423000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"Bakkot: that's at runtime though","msgtype":"m.text"},"ts":1595454427000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"in the ast that's `export default HoistableDeclaration[+Default]`","msgtype":"m.text"},"ts":1595454439000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it has no bindingidentifier in the ast","msgtype":"m.text"},"ts":1595454443000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devnsek: when we parse, we put a synthesised one","msgtype":"m.text"},"ts":1595454458000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"yeah, we could have said function decls don't require a bindingidentifier, but that would be painful","msgtype":"m.text"},"ts":1595454468000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"because almost all of them do","msgtype":"m.text"},"ts":1595454471000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"to avoid making the BindingIdentifier of the FunctionDeclaration optional","msgtype":"m.text"},"ts":1595454472000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"yeah my point was make the BindingIdentifier nullable","msgtype":"m.text"},"ts":1595454487000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"just like the spec grammar","msgtype":"m.text"},"ts":1595454493000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"fair enough though","msgtype":"m.text"},"ts":1595454502000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think I still prefer \"*default*\" over optional BindingIdentifier of FunctionDeclaration","msgtype":"m.text"},"ts":1595454532000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1595454553000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"alternative is to make an explicit ExportFunctionDeclaration type or whatever","msgtype":"m.text"},"ts":1595454566000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i very much dislike putting a synthetic identifier","msgtype":"m.text"},"ts":1595454566000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: you ready to present Function#toString PR?","msgtype":"m.text"},"ts":1595454572000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"i can be","msgtype":"m.text"},"ts":1595454584000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"spec also puts a synthetic name, just in a differnet place","msgtype":"m.text"},"ts":1595454586000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek: you're scheduled to be next","msgtype":"m.text"},"ts":1595454609000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"michaelficarra: yeah saw that","msgtype":"m.text"},"ts":1595454617000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"thx","msgtype":"m.text"},"ts":1595454619000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"can the chairs advance the TCQ topic so I can add a reply?","msgtype":"m.text"},"ts":1595454850000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"we still have four minutes to get monads into the language","msgtype":"m.text"},"ts":1595455019000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"michaelficarra: if you have any desires for how you want me to refactor spec feel free to just bother me","msgtype":"m.text"},"ts":1595455025000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"number destructuring is a really top-notch proposal, not convinced it's a wrong answer","msgtype":"m.text"},"ts":1595455070000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"https://twitter.com/littledan/status/1285816792796061701","msgtype":"m.text"},"ts":1595455077000,"senderName":"benjamn","senderId":"benjamn@irc"},
{"content":{"body":"shu: core-js 2 did it, it broke a lot of things","msgtype":"m.text"},"ts":1595455086000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"what","msgtype":"m.text"},"ts":1595455094000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: oh sorry that was iterable numbers, nvm","msgtype":"m.text"},"ts":1595455097000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah i'm talking about syntax","msgtype":"m.text"},"ts":1595455107000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"bradleymeck: like… all of ecma262?","msgtype":"m.text"},"ts":1595455182000,"senderName":"michaelficarra","senderId":"michaelficarra@irc"},
{"content":{"body":"for *default*","msgtype":"m.text"},"ts":1595455231000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"since we gotta stop using it for [[ImportName]] and [[ExportName]]","msgtype":"m.text"},"ts":1595455288000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Could just use a [[Type]] enum?","msgtype":"m.text"},"ts":1595457438000,"senderName":"jridgewell","senderId":"jridgewell@irc"}
]