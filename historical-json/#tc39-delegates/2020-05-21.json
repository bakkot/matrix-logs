[
{"content":{"body":"bradleymeck: Buffer seems like it might be a big issue here, or at least the Buffer polyfill","msgtype":"m.text"},"ts":1590020797000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I could believe it, but I also am skeptical of it's actual usage","msgtype":"m.text"},"ts":1590021068000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"The only big API people use on it is slice from node side which is what it is emulating","msgtype":"m.text"},"ts":1590021117000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"bradleymeck: slice is already overridden; i think usage of .map and .filter on Buffers should be rare","msgtype":"m.text"},"ts":1590021248000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"bradleymeck: so that leaves .subarray, which is the same semantics as Buffer#slice in node at least","msgtype":"m.text"},"ts":1590021271000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"any intuition on whether people use subarray over slice?","msgtype":"m.text"},"ts":1590021282000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"mmmm, i think slice is the most common, but no clue it only takes 1 super popular package to skew results","msgtype":"m.text"},"ts":1590021320000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"well, for node itself i guess it's \"fine\" so far as its buffer.js is updated in lockstep with V8 releases","msgtype":"m.text"},"ts":1590021361000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i think we could see usage % of that polyfill and then go back and do a more in depth check of what methods are being used of it","msgtype":"m.text"},"ts":1590021364000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"oh? how do we see that?","msgtype":"m.text"},"ts":1590021390000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: we can check Node's gzemnid DB to scan the npm registry then do popularity queries","msgtype":"m.text"},"ts":1590021469000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"but for old deploys it won't help","msgtype":"m.text"},"ts":1590021474000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i am more interested in a crawl of the pages with the buffer polyfill on w/e browser domain","msgtype":"m.text"},"ts":1590021497000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"hm","msgtype":"m.text"},"ts":1590021512000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i am not good enough for http archive but it seems possible to craft some kind of query","msgtype":"m.text"},"ts":1590021523000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"err, good enough to craft a query for http archive","msgtype":"m.text"},"ts":1590021532000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"maybe MylesBorins has experience enough here if you can craft the hueristic to look for","msgtype":"m.text"},"ts":1590021573000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i know he has done some bigquery stuff before","msgtype":"m.text"},"ts":1590021585000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"shu: the buffer polyfill is pulled in any time literally any npm module references `Buffer`","msgtype":"m.text"},"ts":1590028982000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"tape, or deep-equal, or qs, i forget which, has to some kind of crazy hack to have an `isBuffer` impl without forcing the entire buffer polyfill into people's bundles","msgtype":"m.text"},"ts":1590029009000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"indeed","msgtype":"m.text"},"ts":1590029045000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the question is whether they use the inherited methods that create new Uint8Arrays","msgtype":"m.text"},"ts":1590029054000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"s/they/there is significant","msgtype":"m.text"},"ts":1590029070000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"idk why one would map or filter a buffer","msgtype":"m.text"},"ts":1590030491000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah that's my hunch too, it comes down to subarray","msgtype":"m.text"},"ts":1590032518000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"subarray is popular","msgtype":"m.text"},"ts":1590032673000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well idk if its popular in those projects","msgtype":"m.text"},"ts":1590032681000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but people use it to pass to textdecoders and stuff","msgtype":"m.text"},"ts":1590032689000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or textencoders","msgtype":"m.text"},"ts":1590032692000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"one of those","msgtype":"m.text"},"ts":1590032694000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"passing to TextDecoder would be fine as it’s just treating the subarrayed Buffer as a Uint8Array","msgtype":"m.text"},"ts":1590035795000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"unless this is some Node-specific TextDecoder that takes Buffers","msgtype":"m.text"},"ts":1590035812000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"no its standardized","msgtype":"m.text"},"ts":1590036238000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rkirsling! thanks, I wasn't sure what the expectation was. :)","msgtype":"m.text"},"ts":1590077835000,"senderName":"davepoole","senderId":"davepoole@irc"},
{"content":{"body":"bradleymeck: ystartsev: littledan: fyi i wrote up a taxonomy of subclassing (thanks to domenic): https://github.com/syg/proposal-rm-builtin-subclassing#taxonomy-of-subclassing","msgtype":"m.text"},"ts":1590090052000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i'm still poking around on if there are any actual usages except feature detections before finalizing a detection script","msgtype":"m.text"},"ts":1590090116000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"we need more proposals with `rm` in the name","msgtype":"m.text"},"ts":1590090488000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I like the ㊟","msgtype":"m.text"},"ts":1590090598000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1590090621000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"why is delegating to `this.constructor` not sufficient","msgtype":"m.text"},"ts":1590090648000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what does \"sufficient\" mean?","msgtype":"m.text"},"ts":1590090661000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"said another way, why did @@species ever exist","msgtype":"m.text"},"ts":1590090671000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"because MS tried to ship just delegating to `this.constructor` and it broke stuff","msgtype":"m.text"},"ts":1590090687000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"devsnek: well I've uncovered all sorts of hellish stuff with false positives","msgtype":"m.text"},"ts":1590090689000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yea ^","msgtype":"m.text"},"ts":1590090694000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"aw","msgtype":"m.text"},"ts":1590090702000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Array.prototype.map.call(window, String, 1) is a thing apparently","msgtype":"m.text"},"ts":1590090715000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"IDK WHAT IT MEANS","msgtype":"m.text"},"ts":1590090720000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"what are you doing","msgtype":"m.text"},"ts":1590090724000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"to be clear: broke stuff that expected, pre ES6, to always return e.g. an Array","msgtype":"m.text"},"ts":1590090735000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"[].slice.call(arguments) is also a big thing, same for NodeList","msgtype":"m.text"},"ts":1590090756000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"lots of those","msgtype":"m.text"},"ts":1590090762000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"ok and for the static promise methods","msgtype":"m.text"},"ts":1590090770000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i feel like people rely on those doing delegation to `this`","msgtype":"m.text"},"ts":1590090790000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"those were added in ES6 and were given the delegation treatment out of consistency","msgtype":"m.text"},"ts":1590090800000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"are there actual subclasses of Promise that depend on the delegation in the constructor methods?","msgtype":"m.text"},"ts":1590090814000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i'm fairly sure i've seen that","msgtype":"m.text"},"ts":1590090858000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but i'd have to double check","msgtype":"m.text"},"ts":1590090861000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i haven't really, citations would be good","msgtype":"m.text"},"ts":1590090872000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"wowsers, I'd finished reading through this before but I didn't realize about Type III","msgtype":"m.text"},"ts":1590090902000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"extending Promise is super rare with a bunch of regexp checks against httparchive","msgtype":"m.text"},"ts":1590090909000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"Type III and IV are the \"delenda est\" types but unfortunately Type II already incurs a big cost :(","msgtype":"m.text"},"ts":1590090960000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1590090969000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"dan proposed an alternative in issue #1, would be interesting to think through if we can support Type II somehow without the burden","msgtype":"m.text"},"ts":1590090978000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: there's another category, not yet relevant, which is whether built-in methods delegate to property lookups on their _arguments_, rather than looking into their slots directly (e.g. would (new Set).union(myFakeSet)` look up `Symbol.iterator` on `myFakeSet`)","msgtype":"m.text"},"ts":1590091152000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah interesting","msgtype":"m.text"},"ts":1590091190000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"is that really a species concern?","msgtype":"m.text"},"ts":1590091226000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"or just a protocol concern","msgtype":"m.text"},"ts":1590091235000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"no, not really, but neither is type IV in the above taxonomy","msgtype":"m.text"},"ts":1590091245000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"well, is it a *subclassing* concern","msgtype":"m.text"},"ts":1590091263000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I have more feelings about this one because you can't work around it by overriding enough methods, which you can for all the other types","msgtype":"m.text"},"ts":1590091279000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the reason Type IV is included is because actions on builtin regexps are unreasonably difficult to optimize because there are hooks on via `this.exec` or whatever","msgtype":"m.text"},"ts":1590091318000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: i can squint and look at your type and sweep it under the rug as \"not harmful\" in the way that RegExp[@@match] isn't so bad if you just look at it as a protocol that String uses, and not RegExp built-ins themselves use","msgtype":"m.text"},"ts":1590091366000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: union(arg) accepting any iterable arg is reasonable and not too much burden for implementations","msgtype":"m.text"},"ts":1590091420000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"conceptually you basically specced a union that takes Sets, and an overload that takes iterables","msgtype":"m.text"},"ts":1590091435000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"you have a single decision point of going to the slow path that's easy-ish to stay on","msgtype":"m.text"},"ts":1590091475000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: `difference` is maybe a more interesting case, because there you want to invoke `.has` on your argument, not `[Symbol.iterator]`","msgtype":"m.text"},"ts":1590091517000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1590091522000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah that's harder","msgtype":"m.text"},"ts":1590091532000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"still a protocol, just using a named property instead of a symbol one","msgtype":"m.text"},"ts":1590091535000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(I guess a third way is to add `Symbol.has`)","msgtype":"m.text"},"ts":1590091561000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i think my preference here is to be to require explicit casts via Set()","msgtype":"m.text"},"ts":1590091620000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"s/to be//","msgtype":"m.text"},"ts":1590091626000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i actually prefer constructor hooks, a la bradley's map proposal","msgtype":"m.text"},"ts":1590091635000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"remind me what that is?","msgtype":"m.text"},"ts":1590091650000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"then no methods need to be overridden ever, you'd just provide different hooks","msgtype":"m.text"},"ts":1590091652000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like `super(iterable, { toValue() {} })` etc","msgtype":"m.text"},"ts":1590091664000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"hmm, seems scary","msgtype":"m.text"},"ts":1590091694000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"for example, i could see Map and Set accepting a hook that lets you use something besides SameValueZero for comparison","msgtype":"m.text"},"ts":1590091697000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu: :(, that means you can't use a subclass without big-O penalties","msgtype":"m.text"},"ts":1590091707000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: yeah, i can live with a protocol","msgtype":"m.text"},"ts":1590091740000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ljharb historically \"you can't add functionality on top of the built in things, you just have to trust the language designers to have added all the things you might need already\" has not been a good philosophy, I think","msgtype":"m.text"},"ts":1590091756000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh totally agree","msgtype":"m.text"},"ts":1590091769000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but might ask there be explicit in-spec fast paths then for passing actual Sets","msgtype":"m.text"},"ts":1590091772000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and i think you should be *able* to add new things","msgtype":"m.text"},"ts":1590091772000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but i also think that all the use cases of *overriding* existing things could be done with hooks","msgtype":"m.text"},"ts":1590091789000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu: I feel like engines could just do the actual property gets, confirm they're the built-in ones, and then go to the fast path","msgtype":"m.text"},"ts":1590091808000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no?","msgtype":"m.text"},"ts":1590091816000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if that's so I wouldn't think the spec would need to add the fast paths","msgtype":"m.text"},"ts":1590091826000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: i was thinking the fast path would have no observable get of .has","msgtype":"m.text"},"ts":1590091848000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: it'd consult the internal slots of the Set only","msgtype":"m.text"},"ts":1590091861000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ljharb of course they could be done with _enough_ hooks, but, like, I don't think we should trust that we can add the things one might reasonably need","msgtype":"m.text"},"ts":1590091874000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb as another example I think it is perfectly reasonable to make a thing which is not a Set at all under the hood, but conforms to the interface, which could be passed as an argument to Set.prototype.union","msgtype":"m.text"},"ts":1590091915000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: i totally agree that hooks would never be sufficient","msgtype":"m.text"},"ts":1590091924000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i don't agree with that last point tho","msgtype":"m.text"},"ts":1590091935000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"things that accept arraylikes, versus things that accept arrays, are different things","msgtype":"m.text"},"ts":1590091948000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu that would make me sad but it wouldn't be the end of the world","msgtype":"m.text"},"ts":1590091951000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb Arrays are magic; they are not a good example to follow.","msgtype":"m.text"},"ts":1590091978000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok, things that accept thenables are different than things that accept promises","msgtype":"m.text"},"ts":1590091998000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or toStringables vs strings, etc","msgtype":"m.text"},"ts":1590092007000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: isn't this the same reason RegExp subclassing is bad now? maybe difference reasonly only has one such override point with `.has`, but it's a death by thousand cuts kind of thing","msgtype":"m.text"},"ts":1590092009000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"hm something went wrong with the input field there","msgtype":"m.text"},"ts":1590092024000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: at any rate it's also kind of that ^ that it's fine if \"the interface\" is one method, but not fine if it's N","msgtype":"m.text"},"ts":1590092039000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu I think the tradeoffs are different, basically. I don't think there's that much utility in making a fake regexp, and there people care about absolutely maximum speed, whereas there is a lot of utility in making a Set-like, and the speed is not quite so much of a concern","msgtype":"m.text"},"ts":1590092116000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb I basically do not understand what analogy you are trying to make","msgtype":"m.text"},"ts":1590092163000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"hm, ok","msgtype":"m.text"},"ts":1590092170000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: crucially, a lot of utility in making a Set-like by actually subclassing Set and overriding e.g. has","msgtype":"m.text"},"ts":1590092183000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"not a completely custom Set-like","msgtype":"m.text"},"ts":1590092187000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"(there's also utility in doing that and not having `Set.prototype.has.call` provide different behavior)","msgtype":"m.text"},"ts":1590092206000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu two things: 1.) if you do that, then the fast-path has to use the userland has, and 2.) I don't agree actually; I think the \"wraps a Set\" vs \"extends Set\" distinction is basically an implementation detail and either approach is reasonable","msgtype":"m.text"},"ts":1590092261000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb I don't think users should think about Set.prototype.has.call basically ever","msgtype":"m.text"},"ts":1590092279000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"shu s/the fast path has to use the userland has/there cannot be a fast-path which avoids observable .has lookup/","msgtype":"m.text"},"ts":1590092326000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: hm, i'd have to think more about the \"speed is not quite so much of a concern\"","msgtype":"m.text"},"ts":1590092402000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ofc none of this is an issue if speed is not a concern","msgtype":"m.text"},"ts":1590092413000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"well, not quite true","msgtype":"m.text"},"ts":1590092437000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but this would all be decidedly less concerning, at least","msgtype":"m.text"},"ts":1590092452000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: reading through the current Set code i remain leaning towards another way to provide custom 'has' functionality than overriding the method","msgtype":"m.text"},"ts":1590092597000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: one can reasonably expect Set#delete or Set#add to invoke Set#has, but it does not","msgtype":"m.text"},"ts":1590092621000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"> one can reasonably expect Set#delete or Set#add to invoke Set#has","msgtype":"m.text"},"ts":1590092644000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"... can one?","msgtype":"m.text"},"ts":1590092646000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"by contrast, the set constructor itself does invoke Set#add","msgtype":"m.text"},"ts":1590092655000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that is certainly a good point","msgtype":"m.text"},"ts":1590092668000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"(which falls under your type 4 taxonomy)","msgtype":"m.text"},"ts":1590092695000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"shu: but also, as I say I am more concerned with invoking these methods on _arguments_ than on `this`; for `this` you can always get around it by overriding all the methods","msgtype":"m.text"},"ts":1590092732000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i can certainly see the argument that different data structures have different expectations of being subclassable piecemeal","msgtype":"m.text"},"ts":1590092839000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: btw you mentioned trying to deal with a single method as an experiment, but I think for us it's ArraySpeciesCreate as a whole that results in greatest implementation complexity","msgtype":"m.text"},"ts":1590096363000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: yeah, good point, should've been more precise in what i meant","msgtype":"m.text"},"ts":1590096428000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"(mind you I'm not used to digging into this particular area so there could be more stuff that's just not jumping out as obviously, but most of the rest just seems to be reflecting the spec itself, whereas our DFG has watchpoints for array species)","msgtype":"m.text"},"ts":1590096472000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: it'd be good to look at the diff of an implementation of a single builtin under two scenarios: both types II and III removed, and only type III removed","msgtype":"m.text"},"ts":1590096478000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah that's fair","msgtype":"m.text"},"ts":1590096508000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: for V8 at least, the stuff that looks out for species looks out for more than species, despite the name, which might be a gotcha","msgtype":"m.text"},"ts":1590096510000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ahh yeah, could be","msgtype":"m.text"},"ts":1590096538000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"TabAtkins: wow, that's the most positive subdiscussion I've seen in the pipeline repo in recent memory","msgtype":"m.text"},"ts":1590102477000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"#yay","msgtype":"m.text"},"ts":1590102482000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah it's weird how heated people get","msgtype":"m.text"},"ts":1590102632000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"rkirsling which?","msgtype":"m.text"},"ts":1590102812000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"last two comments at https://github.com/tc39/proposal-pipeline-operator/issues/167","msgtype":"m.text"},"ts":1590102855000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"makes me kinda excited","msgtype":"m.text"},"ts":1590102914000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"let's do this","msgtype":"m.text"},"ts":1590102919000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"TabAtkins: is the style you prefer the `x => await => y` form where x and y are functions? or is it a different one","msgtype":"m.text"},"ts":1590102985000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"That's F#-style, so no","msgtype":"m.text"},"ts":1590103000000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"hm, ok","msgtype":"m.text"},"ts":1590103022000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'm going to be advocating for plain-jane Hack-style, where the RHS is just \"any expression\", and there's a binding for the # variable over it (bound to the LHS).","msgtype":"m.text"},"ts":1590103042000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"littledan's frameworks outreach call today seemed to prefer that one iirc","msgtype":"m.text"},"ts":1590103044000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's what point (6) is about","msgtype":"m.text"},"ts":1590103046000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"littledan is going to be advocating for that, yeah","msgtype":"m.text"},"ts":1590103059000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"so you'd do `await #` if that's the semantic you wanted?","msgtype":"m.text"},"ts":1590103071000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Put the await wherever you need it, yeah.","msgtype":"m.text"},"ts":1590103084000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(i don't like # as the placeholder choice there but obv that's a stage 2 debate)","msgtype":"m.text"},"ts":1590103087000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(Rather than being forced to put it by itself on a pipeline step)","msgtype":"m.text"},"ts":1590103095000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1590103099000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`val |> async(#) |> foo(await #)` if that's the clearest way to express your intent, for instance","msgtype":"m.text"},"ts":1590103123000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"and for those who prefer the F# style, you could immediately invoke \"the function you used in F#\" to use it in \"hack-style\"?","msgtype":"m.text"},"ts":1590103138000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`val |> asyncFn(#) |> foo(await #)`, rather","msgtype":"m.text"},"ts":1590103144000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Yeah, you just call it like you would in normal JS.","msgtype":"m.text"},"ts":1590103158000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"If normal JS would have you do `let x = foo(1,2)(3)`, the hack-style pipeline does `3 |> foo(1,2)(#)`","msgtype":"m.text"},"ts":1590103186000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"`|> await` is certainly the part that makes me frown the most about the other approach","msgtype":"m.text"},"ts":1590103191000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"your point (7) is strangely compellingly worded for being as obvious as it is though","msgtype":"m.text"},"ts":1590103211000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"TabAtkins: and expressions are lazily or eagerly evaluated?","msgtype":"m.text"},"ts":1590103221000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"TabAtkins if you present on this, can you contrast to just writing `$ = val; $ = asyncFn($); $=foo(await $)`?","msgtype":"m.text"},"ts":1590103227000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"rkirsling: It's apparently not obvious! I've polished it over time talking with other people!","msgtype":"m.text"},"ts":1590103233000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":":)","msgtype":"m.text"},"ts":1590103250000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"good work","msgtype":"m.text"},"ts":1590103255000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ljharb: eagerly, it's *exactly* as if you'd taken the LHS and put it in the RHS in place of the #","msgtype":"m.text"},"ts":1590103260000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(module the fact that the LHS is only executed once even if you use # multiple times)","msgtype":"m.text"},"ts":1590103276000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins wait that would be very surprising to me","msgtype":"m.text"},"ts":1590103293000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lazily seems the obvious thing","msgtype":"m.text"},"ts":1590103297000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah that surprises me too","msgtype":"m.text"},"ts":1590103304000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: Basically that exact example is the main *competitor* to pipeline ^_^","msgtype":"m.text"},"ts":1590103305000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"wait now i'm surprised","msgtype":"m.text"},"ts":1590103313000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"wait what does lazy mean in this context","msgtype":"m.text"},"ts":1590103316000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that's the same in every pipeline","msgtype":"m.text"},"ts":1590103318000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"if I don't hit a step in the pipeline, I don't expect to see side effects from the hitting that step","msgtype":"m.text"},"ts":1590103319000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`console.log(1) |> await # |> console.log(2)`","msgtype":"m.text"},"ts":1590103320000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"OH","msgtype":"m.text"},"ts":1590103327000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i would expect 2 not to log until after the tick","msgtype":"m.text"},"ts":1590103331000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ok yeah","msgtype":"m.text"},"ts":1590103334000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yeah I think there was a misspeak?","msgtype":"m.text"},"ts":1590103334000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that's lazily","msgtype":"m.text"},"ts":1590103335000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(i believe)","msgtype":"m.text"},"ts":1590103346000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yeah, LHS is executed, *then* pipeline body is.","msgtype":"m.text"},"ts":1590103369000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"You literally can't execute the RHS until you're done with the LHS.","msgtype":"m.text"},"ts":1590103382000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1590103387000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"TabAtkins re \"that exact example is the main *competitor* to pipeline\" - right, so, contrasting to the main competitor seems like it would be valuable in your presentation","msgtype":"m.text"},"ts":1590103393000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"its like normal evaluation","msgtype":"m.text"},"ts":1590103396000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"presumably they're parsed eagerly but evaluated lazily","msgtype":"m.text"},"ts":1590103399000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1590103401000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"except with a different delimiter","msgtype":"m.text"},"ts":1590103404000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'd be interested to see some codebases where pipelining comes in handy","msgtype":"m.text"},"ts":1590103446000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: Yup, explaining the benefit of pipeline over \"just write JS without pipeline\" is of course a necessary piece of this ^_^","msgtype":"m.text"},"ts":1590103450000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i don't think i've ever had something that felt ungangly and in need of a pipeline","msgtype":"m.text"},"ts":1590103457000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ungainly*","msgtype":"m.text"},"ts":1590103467000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"TabAtkins well, it's more dramatic for Hack style than F# style, since in F# style you are composing functions directly, whereas in Hack style you're just having a binding created for you - that is, Hack style is much closer to that sample than F# style is","msgtype":"m.text"},"ts":1590103516000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"The benefit actually ends up *relatively* small; it's not a world-changer like arrow-function syntax. But it does let you write some common code patterns in a cleaner way, and importantly, lets you get the benefit of doing complex manipulations of a value via multiple statements, but in an expression context.","msgtype":"m.text"},"ts":1590103528000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I think anywhere you have 2+ nested calls it could be potentially nicer","msgtype":"m.text"},"ts":1590103541000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"devsnek: react HOCs is a big one","msgtype":"m.text"},"ts":1590103546000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: currently it's `withA(withB(withC(withD(Component))))`","msgtype":"m.text"},"ts":1590103557000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yuck","msgtype":"m.text"},"ts":1590103567000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"\"lets you get the benefit of doing complex manipulations of a value via multiple statements\": mm, sometimes, but only if you don't need intermediate values multiple times; do expressions seem like a much more general solution to that problem","msgtype":"m.text"},"ts":1590103572000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"like trying to extend multiple things?","msgtype":"m.text"},"ts":1590103576000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: `Component |> withD |> withC |> withB |> withA` is much clearer","msgtype":"m.text"},"ts":1590103580000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: it's not extending, it's composing/wrapping, but yes","msgtype":"m.text"},"ts":1590103585000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"HOC is a \"higher-order component\"","msgtype":"m.text"},"ts":1590103597000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"seems like a weird pattern","msgtype":"m.text"},"ts":1590103615000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: Yup, cut the gordian knot of do exprs and I'd be okay with dropping pipelines ^_^","msgtype":"m.text"},"ts":1590103632000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"devsnek: it's also how every single usage of redux in the react world worked, prior to hooks. it's a common pattern.","msgtype":"m.text"},"ts":1590103645000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i've never really done any frontend stuff","msgtype":"m.text"},"ts":1590103673000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"because i hear that patterns like HOC are a thing","msgtype":"m.text"},"ts":1590103699000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lessee, from the HOC documentation:","msgtype":"m.text"},"ts":1590103703000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"https://reactjs.org/docs/higher-order-components.html","msgtype":"m.text"},"ts":1590103705000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i really want to move do expressions forward","msgtype":"m.text"},"ts":1590103716000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"const CommentListWithSubscription = withSubscription(","msgtype":"m.text"},"ts":1590103716000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"  CommentList,","msgtype":"m.text"},"ts":1590103716000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"  (DataSource) => DataSource.getComments()","msgtype":"m.text"},"ts":1590103717000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":");","msgtype":"m.text"},"ts":1590103717000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"> the HOC doc","msgtype":"m.text"},"ts":1590103721000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"FTFY","msgtype":"m.text"},"ts":1590103721000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"devsnek: just `do` it","msgtype":"m.text"},"ts":1590103747000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"would be `const CommentListWithSubscription = CommentList |> withSubscription(#, DataSource=>DataSource.getComments());`","msgtype":"m.text"},"ts":1590103751000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"but people think that control flow inside a block that is part of a do expression is not good","msgtype":"m.text"},"ts":1590103759000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek some people (like me) think that, but other people disagree","msgtype":"m.text"},"ts":1590103790000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I can *definitely* see how confusing that would be with another withX() wrapper or two","msgtype":"m.text"},"ts":1590103796000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"devsnek completion values are also a sticking point","msgtype":"m.text"},"ts":1590103797000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek though, it occurs to me you could just require the last statement in the `do` be an expression, so it'd be obvious...","msgtype":"m.text"},"ts":1590103812000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"iirc completion values were less of a blocker and more of a \"fine assuming we make sure completions in the spec are clean\"","msgtype":"m.text"},"ts":1590103825000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek ehhh: https://github.com/tc39/proposal-do-expressions/issues/21","msgtype":"m.text"},"ts":1590103835000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i wouldn't like to force that","msgtype":"m.text"},"ts":1590103882000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: i mean, it'd be useful in express middlewares too, i'd imagine","msgtype":"m.text"},"ts":1590103887000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"isn't express middleware flat","msgtype":"m.text"},"ts":1590103897000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`app.use(x); app.use(y)`","msgtype":"m.text"},"ts":1590103903000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"atm yes","msgtype":"m.text"},"ts":1590103904000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: Forcing that means I don't get the nice clean \"turn if() into an expression by wrapping it in a do{}\" functionality :(","msgtype":"m.text"},"ts":1590103912000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"(ftr i also think control flow in do expression blocks is bad)","msgtype":"m.text"},"ts":1590103915000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"TabAtkins: yeah i want that too lol","msgtype":"m.text"},"ts":1590103924000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"TabAtkins hm, true","msgtype":"m.text"},"ts":1590103952000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in any case my argument was that people use repls","msgtype":"m.text"},"ts":1590103957000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which have the same semantics as do expressions","msgtype":"m.text"},"ts":1590103965000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and aside from block/object parsing, they seem ok with how those work","msgtype":"m.text"},"ts":1590103982000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"people also use completion of scripts with the node vm module","msgtype":"m.text"},"ts":1590104014000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"people are OK with repls because they don't care what the completion value of a declaration or a loop is","msgtype":"m.text"},"ts":1590104034000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but it tells them what it is","msgtype":"m.text"},"ts":1590104047000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"^ that","msgtype":"m.text"},"ts":1590104048000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"sure","msgtype":"m.text"},"ts":1590104051000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"and they don't go on twitter raving about it","msgtype":"m.text"},"ts":1590104055000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but that doesn't mean they pay attention to it","msgtype":"m.text"},"ts":1590104056000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek yeah but that doesn't mean they know","msgtype":"m.text"},"ts":1590104056000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"afaik","msgtype":"m.text"},"ts":1590104057000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol the completion value of `console.log` is undefined, and that actually *does* confuse a ton of people, they ask on irc a lot","msgtype":"m.text"},"ts":1590104078000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I will say that I've written plenty of for loops in my repl and never once realized consciously that it even has a value","msgtype":"m.text"},"ts":1590104079000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"github puts an enormous green checkmark on the highest rated comment now","msgtype":"m.text"},"ts":1590104115000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like it solves the issue or smth","msgtype":"m.text"},"ts":1590104120000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"alternative possibility: the last statement cannot be a loop or declaration","msgtype":"m.text"},"ts":1590104134000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek: huh, link?","msgtype":"m.text"},"ts":1590104144000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"not being a declaration makes sense","msgtype":"m.text"},"ts":1590104146000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: highest _rated_?","msgtype":"m.text"},"ts":1590104149000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"defining \"last\" is a little weird though","msgtype":"m.text"},"ts":1590104152000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"https://github.com/tc39/proposal-do-expressions/issues/21#issuecomment-359160212","msgtype":"m.text"},"ts":1590104153000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but i would use loops too","msgtype":"m.text"},"ts":1590104159000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I do not see a giant checkmark","msgtype":"m.text"},"ts":1590104166000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"nor do I","msgtype":"m.text"},"ts":1590104169000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"devsnek ... would you? why?","msgtype":"m.text"},"ts":1590104172000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek: i do not see that. github chrome extension?","msgtype":"m.text"},"ts":1590104174000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: maybe you're using \"refined github\"","msgtype":"m.text"},"ts":1590104179000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i am using refined github","msgtype":"m.text"},"ts":1590104184000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"why would anyone ever want the completion value of a loop?","msgtype":"m.text"},"ts":1590104186000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it could be that i guess","msgtype":"m.text"},"ts":1590104188000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it does a bunch of weird things, that must be one of them","msgtype":"m.text"},"ts":1590104188000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: because they can have values","msgtype":"m.text"},"ts":1590104203000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and i want to use that","msgtype":"m.text"},"ts":1590104205000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek specifically when?","msgtype":"m.text"},"ts":1590104212000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"when do you want to use that?","msgtype":"m.text"},"ts":1590104216000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"idk","msgtype":"m.text"},"ts":1590104219000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":":|","msgtype":"m.text"},"ts":1590104222000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sometimes you have to factor a loop out","msgtype":"m.text"},"ts":1590104234000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"to use `return` from the body","msgtype":"m.text"},"ts":1590104238000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"fwiw a _lot_ of people get confused by loops in React not making an array","msgtype":"m.text"},"ts":1590104241000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or assign to a variable","msgtype":"m.text"},"ts":1590104242000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like, endlessly they are confused by this","msgtype":"m.text"},"ts":1590104247000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: completion value of a loop is *basically* the return value of a .reduce()","msgtype":"m.text"},"ts":1590104253000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"\"loops in react not making an array\" what?","msgtype":"m.text"},"ts":1590104254000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"s/in React/in JSX/","msgtype":"m.text"},"ts":1590104256000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what does a loop in jsx mean","msgtype":"m.text"},"ts":1590104263000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://stackoverflow.com/questions/22876978/loop-inside-react-jsx","msgtype":"m.text"},"ts":1590104272000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's just people not understanding the basics of imperative programming","msgtype":"m.text"},"ts":1590104302000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"That said, if I'm reducing like that, I already need to declare a var to hold the intermediate results, so I might as well just list that var's name *after* the loo pto get it returned","msgtype":"m.text"},"ts":1590104314000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"that seems pretty JSX-specific, in that it's conflating things that wouldn't be conflated in a templating language","msgtype":"m.text"},"ts":1590104345000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"In `let sum = do{let sum = 0; for(const x of vals) sum += x; sum};`, the `; sum;` at the end isn't killing me","msgtype":"m.text"},"ts":1590104378000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"anyway if we make sure completions in the language are clean","msgtype":"m.text"},"ts":1590104384000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think a lot of people will be surprised that `do { for (i = 0; i < 10; ++i) i }` does not give you an array with [0, ..., 9]","msgtype":"m.text"},"ts":1590104387000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and people generally don't do weird stuff","msgtype":"m.text"},"ts":1590104396000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't think it will be a problem","msgtype":"m.text"},"ts":1590104399000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like there's always that one person who writes jsfuck","msgtype":"m.text"},"ts":1590104413000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Looking back at the hoc docs, they give an example of using multiple hocs at once as:","msgtype":"m.text"},"ts":1590104437000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"https://github.com/tc39/proposal-do-expressions/issues/14 is the issue for loops in particular","msgtype":"m.text"},"ts":1590104438000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`withRouter(connect(commentSelector)(WrappedComponent))`","msgtype":"m.text"},"ts":1590104440000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Bakkot: let them be surprised, they might learn how imperative programming works","msgtype":"m.text"},"ts":1590104447000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and already I'm having trouble reading that.","msgtype":"m.text"},"ts":1590104448000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"devsnek :(","msgtype":"m.text"},"ts":1590104453000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek that seems like... not a good design principle","msgtype":"m.text"},"ts":1590104463000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`WrappedComponent |> connect(commentSelector)(#) |> withRoute(#)`","msgtype":"m.text"},"ts":1590104466000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i mean","msgtype":"m.text"},"ts":1590104468000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't think do expressions exacerbate that misunderstanding","msgtype":"m.text"},"ts":1590104495000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: specifically, there is nothing about \"imperative programming\" which means that has to return a single value and not an array","msgtype":"m.text"},"ts":1590104498000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: I do disagree with the OP there though","msgtype":"m.text"},"ts":1590104510000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"we could define do expressions in a way which makes that return an array","msgtype":"m.text"},"ts":1590104510000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it still doesn't make any sense to me that a loop has a completion value.","msgtype":"m.text"},"ts":1590104511000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you're doing something and not putting the value anywhere","msgtype":"m.text"},"ts":1590104512000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek I mean that is true for any do expression","msgtype":"m.text"},"ts":1590104529000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the whole point of using completion values is that you are not putting the value anywhere","msgtype":"m.text"},"ts":1590104541000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"like i get that its confusing for n=1","msgtype":"m.text"},"ts":1590104541000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it just gets picked up for you","msgtype":"m.text"},"ts":1590104544000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"as TabAtkins said, why wouldn't you expect it to be the reduce result? why would you expect it to build you a thing implicitly?","msgtype":"m.text"},"ts":1590104548000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"devsnek: why would you have a loop with n < 2","msgtype":"m.text"},"ts":1590104552000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: actually i find it confusing with n > 1","msgtype":"m.text"},"ts":1590104568000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: i get that people are surprised about completions","msgtype":"m.text"},"ts":1590104581000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but if you evaluate it x times","msgtype":"m.text"},"ts":1590104588000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"where x is not one","msgtype":"m.text"},"ts":1590104592000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like, if there is no array, where would it come from","msgtype":"m.text"},"ts":1590104593000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: the array thing i don't find reasonable","msgtype":"m.text"},"ts":1590104601000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i don't understand the logic of where all those values are doing","msgtype":"m.text"},"ts":1590104611000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"going*","msgtype":"m.text"},"ts":1590104613000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(altho the for..of part kind of makes sense to me)","msgtype":"m.text"},"ts":1590104613000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"to me it feels like someone copy pasted some code without understanding it","msgtype":"m.text"},"ts":1590104633000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"isn't that stackoverflow's growth model","msgtype":"m.text"},"ts":1590104650000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it feels like the kind of question we get in discord.js support server","msgtype":"m.text"},"ts":1590104662000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I don't think that \"the completion value of a loop is an array holding all of the completion values of each step of the loop\" is a totally unreasonable thing to think","msgtype":"m.text"},"ts":1590104681000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it isn't, but like, there is no particular reason for it not to be","msgtype":"m.text"},"ts":1590104691000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah but at that point you have some idea of completion values","msgtype":"m.text"},"ts":1590104702000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"... yes?","msgtype":"m.text"},"ts":1590104714000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and?","msgtype":"m.text"},"ts":1590104715000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"diy list comprehension, yo","msgtype":"m.text"},"ts":1590104721000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"insofar as users have no conception of completion values, sure lol","msgtype":"m.text"},"ts":1590104722000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the jsx thing has nothing to do with completions","msgtype":"m.text"},"ts":1590104723000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ok pretend I never brought up JSX","msgtype":"m.text"},"ts":1590104737000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i'm down to talk about making the loop produce an array","msgtype":"m.text"},"ts":1590104748000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ehh","msgtype":"m.text"},"ts":1590104754000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I don't really think it should","msgtype":"m.text"},"ts":1590104758000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but i don't think anything here is beyond comprehension","msgtype":"m.text"},"ts":1590104759000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i also don't think it should","msgtype":"m.text"},"ts":1590104766000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"^ pun intended?","msgtype":"m.text"},"ts":1590104767000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"lol ross","msgtype":"m.text"},"ts":1590104771000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"my actual position is that we should not expose to users the completion value of a loop","msgtype":"m.text"},"ts":1590104774000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I will concede that https://github.com/tc39/proposal-do-expressions/issues/14#issuecomment-359529937 gives me pause","msgtype":"m.text"},"ts":1590104780000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"^ +1","msgtype":"m.text"},"ts":1590104781000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah I think I can agree with that sentence too","msgtype":"m.text"},"ts":1590104793000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ok to rephrase","msgtype":"m.text"},"ts":1590104795000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm ok talking about what the completion value of a loop should be","msgtype":"m.text"},"ts":1590104802000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but i don't think a loop having a completion value is inherently a bad thing","msgtype":"m.text"},"ts":1590104814000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right, and my position is the negation of that last sentence","msgtype":"m.text"},"ts":1590104824000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"whether its undefined or an array or the last expression or whatever","msgtype":"m.text"},"ts":1590104833000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I am cool with all the non-obvious statement cases being defined as producing undefined. So long as if() and try/catch give me their final values, everything else can take a hike as far as i'm concerned","msgtype":"m.text"},"ts":1590104868000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: the if block?","msgtype":"m.text"},"ts":1590104881000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1590104887000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: blocks having a completion value of their last statement's makes sense to me","msgtype":"m.text"},"ts":1590104890000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"any blocks","msgtype":"m.text"},"ts":1590104892000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but not loop bodies","msgtype":"m.text"},"ts":1590104900000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"my position is, I would like us to only allow do expressions for which the completion value is going to be obvious - so, you should not be able to end a do expression in a loop (or a declaration, which is also weird)","msgtype":"m.text"},"ts":1590104901000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i agree with tabatkins","msgtype":"m.text"},"ts":1590104913000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"sounds like we have a compromise point","msgtype":"m.text"},"ts":1590104925000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that being","msgtype":"m.text"},"ts":1590104930000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the loop is allowed to be the last item","msgtype":"m.text"},"ts":1590104935000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but it just always gives undefined","msgtype":"m.text"},"ts":1590104939000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh. i don't think that was what tab said","msgtype":"m.text"},"ts":1590104942000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"wait whoa why is `do {} while (false)` different from `{}`","msgtype":"m.text"},"ts":1590104943000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(I'm also fine with \"everything works exactly as if you just plugged it into eval()\", fwiw.)","msgtype":"m.text"},"ts":1590104944000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"rkirsling: because it's a loop and `{}` is not","msgtype":"m.text"},"ts":1590104957000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek accurately summarized me, yeah","msgtype":"m.text"},"ts":1590104959000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yes","msgtype":"m.text"},"ts":1590104960000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that is my question","msgtype":"m.text"},"ts":1590104967000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"TabAtkins would you also be ok with, ending a do expression with a loop is a syntax error?","msgtype":"m.text"},"ts":1590104976000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's part of the es2015 completion reform","msgtype":"m.text"},"ts":1590104977000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1590104981000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Bakkot: i would be against that","msgtype":"m.text"},"ts":1590104991000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rkirsling basically \"things are sometimes empty, sometimes not, at runtime\" was held to be confusing","msgtype":"m.text"},"ts":1590104993000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"rkirsling: i'm saying that's why it's different. loops make 0, 1, or N completion values, blocks make 1. there's no ambiguity about blocks, there is with loops","msgtype":"m.text"},"ts":1590104996000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"idk how strongly exactly","msgtype":"m.text"},"ts":1590104997000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek why?","msgtype":"m.text"},"ts":1590104998000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1590105019000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"right, you might not even enter a loop body","msgtype":"m.text"},"ts":1590105029000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that's a good point","msgtype":"m.text"},"ts":1590105034000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"it feels wrong to limit things like that","msgtype":"m.text"},"ts":1590105054000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"maybe i can be convinced","msgtype":"m.text"},"ts":1590105062000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i can't be convinced about control flow though, that's a must","msgtype":"m.text"},"ts":1590105073000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek fwiw this is the sort of limitation we could relax later","msgtype":"m.text"},"ts":1590105075000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek :(","msgtype":"m.text"},"ts":1590105078000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it feels wrong but it's not unthinkable","msgtype":"m.text"},"ts":1590105080000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"devsnek control flow is also a thing which could be relaxed later","msgtype":"m.text"},"ts":1590105090000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"nah my use case doesn't work without it","msgtype":"m.text"},"ts":1590105098000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well","msgtype":"m.text"},"ts":1590105101000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"there are other use cases","msgtype":"m.text"},"ts":1590105103000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"loops would be puntable where non-loop block-based constructs aren't","msgtype":"m.text"},"ts":1590105106000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"sometimes we add things which do not meet your particular use case","msgtype":"m.text"},"ts":1590105110000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that is ok","msgtype":"m.text"},"ts":1590105110000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i mean my motivation for possibly furthering the proposal","msgtype":"m.text"},"ts":1590105118000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah, fair","msgtype":"m.text"},"ts":1590105124000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"is to allow control flow in expression positions","msgtype":"m.text"},"ts":1590105129000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1590105135000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's something i feel pretty strongly shouldn't be allowed","msgtype":"m.text"},"ts":1590105146000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Given that the point of a do-expr is to *return a value*, I don't see a signfiicant difference between \"ending with a loop returns undefined\" and \"ending with a loop is a syntax error\".","msgtype":"m.text"},"ts":1590105148000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: yeah i see both sides","msgtype":"m.text"},"ts":1590105159000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"^ I like this phrasing","msgtype":"m.text"},"ts":1590105163000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ok I might try to present the minimal form of do expressions","msgtype":"m.text"},"ts":1590105164000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"TabAtkins: it's also to have statements in expression position","msgtype":"m.text"},"ts":1590105166000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i just don't like limitations","msgtype":"m.text"},"ts":1590105167000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"The latter will catch programming mistakes earlier; the former will allow me to spin a loop for side effects at expression context.","msgtype":"m.text"},"ts":1590105168000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: which doesn't require a value","msgtype":"m.text"},"ts":1590105169000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"which basically ban anything confusing or contentious","msgtype":"m.text"},"ts":1590105171000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i find your banning of contentious items contentious","msgtype":"m.text"},"ts":1590105183000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1590105186000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb what expression positions don't require a value?","msgtype":"m.text"},"ts":1590105187000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: i mean, there must *be* a value - like undefined - but it doesn't have to have meaning","msgtype":"m.text"},"ts":1590105202000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah the whole point of expression context is \"here comes a value, beep beep\"","msgtype":"m.text"},"ts":1590105203000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"devsnek sure, but the alternative appears to be \"do expressions stagnate forever\", so...","msgtype":"m.text"},"ts":1590105204000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"combining \"make everything an expression\" and \"for side effects\" just hurt my head","msgtype":"m.text"},"ts":1590105224000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"`void do { … }` is a totally fine way to run side effects in expression positions.","msgtype":"m.text"},"ts":1590105228000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(or maybe it was my heart)","msgtype":"m.text"},"ts":1590105231000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"where \"fine\" is that dog meme","msgtype":"m.text"},"ts":1590105235000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah like","msgtype":"m.text"},"ts":1590105238000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb I mean to say, when would that come up? I feel like \"I am forced to be in expression position, but I don't care what the value is\" is fairly rare","msgtype":"m.text"},"ts":1590105241000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"its weird","msgtype":"m.text"},"ts":1590105241000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: true","msgtype":"m.text"},"ts":1590105248000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but that's what i like about js","msgtype":"m.text"},"ts":1590105251000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: but i think ending with a loop, and not a value, is equally rare","msgtype":"m.text"},"ts":1590105266000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: or will be in an expression position, i mean","msgtype":"m.text"},"ts":1590105276000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb well, I think some people will expect it to get an array, is the thing","msgtype":"m.text"},"ts":1590105288000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and try it, and get bit","msgtype":"m.text"},"ts":1590105292000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"fair","msgtype":"m.text"},"ts":1590105295000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I mean, I would say it's on par with the early error for **","msgtype":"m.text"},"ts":1590105309000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"what if the completion value of a loop is a string containing info for the mailing list","msgtype":"m.text"},"ts":1590105322000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"… maybe still better than \"last value\"","msgtype":"m.text"},"ts":1590105340000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":":-p","msgtype":"m.text"},"ts":1590105351000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"\"congrats you're the 10,000th caller! what do you think this should do\"","msgtype":"m.text"},"ts":1590105383000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"\"side effects in expression context, don't care about the value\" can still be done with `do{ for(){...}; 0}`","msgtype":"m.text"},"ts":1590105393000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1590105394000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"my main thing is thinking about how generated code can use do expressions","msgtype":"m.text"},"ts":1590105403000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that's my primary use case for them anyway","msgtype":"m.text"},"ts":1590105414000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"TabAtkins: very true.","msgtype":"m.text"},"ts":1590105415000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: generated code can also generate boilerplate to capture whatever return value you want","msgtype":"m.text"},"ts":1590105426000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah but that's extraordinarily difficult","msgtype":"m.text"},"ts":1590105439000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what sort of generated code","msgtype":"m.text"},"ts":1590105451000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"generated code has a lot of freedom to just do things in a different way","msgtype":"m.text"},"ts":1590105456000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"like babel codemods","msgtype":"m.text"},"ts":1590105458000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"put an IIFE there, rewrite control flow, whatever","msgtype":"m.text"},"ts":1590105461000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i don't mean compiler output","msgtype":"m.text"},"ts":1590105462000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: how is it difficult? add `let completion;` to the top, and `completion =` in front of the last value in the loop body, and `completion;` after?","msgtype":"m.text"},"ts":1590105509000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"TabAtkins re the \"reduce\" thing, one other case is, you are searching for an item and want that item","msgtype":"m.text"},"ts":1590105513000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in which case it's more awkward","msgtype":"m.text"},"ts":1590105517000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ljharb: i was talking more about control flow","msgtype":"m.text"},"ts":1590105520000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this is the example in https://github.com/tc39/proposal-do-expressions/issues/34","msgtype":"m.text"},"ts":1590105525000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"under \"for loop\"","msgtype":"m.text"},"ts":1590105530000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"rewiring the values is pretty easy","msgtype":"m.text"},"ts":1590105538000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"rewiring the control flow is also pretty easy","msgtype":"m.text"},"ts":1590105559000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah yeah, without a `break with` that rewrites the completion value, you gotta do the \"declare a temp, for(), temp\" thing","msgtype":"m.text"},"ts":1590105571000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yeah just fork regenerator","msgtype":"m.text"},"ts":1590105573000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"generators are way more powerful than the break-continue-return kind of control flow we're talking about here","msgtype":"m.text"},"ts":1590105597000,"senderName":"Bakkot","senderId":"Bakkot@irc"}
]