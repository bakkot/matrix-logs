[
{"content":{"body":"ljharb: so about https://github.com/tc39/proposal-atomics-wait-async/issues/28","msgtype":"m.text"},"ts":1585267471000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ljharb: jridgewell has now convinced me in the status quo, namely that validation errors *should* return early; trigger finger was too quick on making the agenda PR. i imagine no issues with deleting the item without a PR","msgtype":"m.text"},"ts":1585267528000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"no, there'd be no issues with that, but i'm not sure if that's true","msgtype":"m.text"},"ts":1585267556000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"axel's article is fine advice for userland, and something i tend to follow as well, but the explicit decision (after that was posted) for `async function` was that it's zalgo to have sync errors from an async function","msgtype":"m.text"},"ts":1585267584000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"eg, it should be impossible for an `async function` to synchronously throw under any circumstances","msgtype":"m.text"},"ts":1585267602000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"also `Promise.all()` rejects, it does not throw","msgtype":"m.text"},"ts":1585267651000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"that's a pretty clear precedent for \"all errors of any kind only ever reject\"","msgtype":"m.text"},"ts":1585267668000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"justin has graciously provided counterexamples that it does","msgtype":"m.text"},"ts":1585267725000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Promise.all.call({}, [1, 2, 3]) // => Uncaught TypeError: #<Object> is not a constructor","msgtype":"m.text"},"ts":1585267729000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"hm","msgtype":"m.text"},"ts":1585267735000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it's inconsistent with the ES6 ones, true","msgtype":"m.text"},"ts":1585267745000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"you may argue that it's somehow a categorically different kind of validation error","msgtype":"m.text"},"ts":1585267747000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i'd say it kind of is","msgtype":"m.text"},"ts":1585267757000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'd say i disagree :)","msgtype":"m.text"},"ts":1585267767000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"in this case tho, it's because it can't know what kind of promise to create without a constructor","msgtype":"m.text"},"ts":1585267775000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"OTOH webidl agrees with you and disagrees with me","msgtype":"m.text"},"ts":1585267860000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it seems strange if `waitAsync` can't be implemented with an `async function`.","msgtype":"m.text"},"ts":1585267902000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i don't understand what that means","msgtype":"m.text"},"ts":1585268145000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"like you can't self-host it with an async function?","msgtype":"m.text"},"ts":1585268152000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"(why is that weird? i'm a novice at actual software engineering with async features)","msgtype":"m.text"},"ts":1585268233000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah that's what i meant","msgtype":"m.text"},"ts":1585268242000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i think it's weird if a promise-returning function can't be self-hosted with the syntax for a promise-returning function.","msgtype":"m.text"},"ts":1585268254000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i see","msgtype":"m.text"},"ts":1585268316000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"right, ok","msgtype":"m.text"},"ts":1585268320000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ljharb: okay, i need some time to digest. i don't really have skin in the game, so i'm kind of see-sawing","msgtype":"m.text"},"ts":1585268418000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"fair enough","msgtype":"m.text"},"ts":1585268424000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i can see where the promise subclassing error is just categorically different","msgtype":"m.text"},"ts":1585268433000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and that since webidl as a matter of course converts all exceptions to rejected promises","msgtype":"m.text"},"ts":1585268448000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"alignment with that seems most useful","msgtype":"m.text"},"ts":1585268455000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I think following web API's practices would be good","msgtype":"m.text"},"ts":1585268707000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"My position was a weakly held \"promise returning functions _could_ sync throw\"","msgtype":"m.text"},"ts":1585268727000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"But looking through every example I could think of, the only ones I could find were the Promise constructor's static methods","msgtype":"m.text"},"ts":1585268760000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"I'd accept that's a 1-off exception :drum","msgtype":"m.text"},"ts":1585268787000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"I'd accept that's a 1-off exception :drum:","msgtype":"m.text"},"ts":1585268791000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Agh, my pun is ruined.","msgtype":"m.text"},"ts":1585268805000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"id say the errors should be async","msgtype":"m.text"},"ts":1585268993000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"they're validating the arguments right","msgtype":"m.text"},"ts":1585269004000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I can maybe just barely see the argument for sync throw with the receiver being invalid","msgtype":"m.text"},"ts":1585269026000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but I'd rather that was async too","msgtype":"m.text"},"ts":1585269031000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah, my impression was definitely that the webidl convention is pretty universal in modern js","msgtype":"m.text"},"ts":1585269209000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it's also what node does, at least for `fs.promises`","msgtype":"m.text"},"ts":1585269254000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if we were to deviate here I would expect the justification to be something specific to atomics, but I don't think there is such a reason","msgtype":"m.text"},"ts":1585269311000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"btw, in case anyone didn't get the \"zalgo\" reference, it's https://blog.izs.me/2013/08/designing-apis-for-asynchrony","msgtype":"m.text"},"ts":1585269483000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Facebook apparently replaces promises with fake promises that can resolve without waiting a tick","msgtype":"m.text"},"ts":1585269621000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"great, thanks for all the datapoints","msgtype":"m.text"},"ts":1585271206000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"will turn the errors async and ask for consensus for it","msgtype":"m.text"},"ts":1585271223000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"incidentally how do folks feel about a Promise introspection API for the power uses that want to do something synchronously with Promises?","msgtype":"m.text"},"ts":1585271276000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"domenic pointed me to a previous iteration: https://github.com/jamiebuilds/proposal-promise-prototype-inspect","msgtype":"m.text"},"ts":1585271281000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so much nope","msgtype":"m.text"},"ts":1585271325000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the demos are like literally the antithesis of the design of promises","msgtype":"m.text"},"ts":1585271399000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"that promises being non-introspectable is central to its design?","msgtype":"m.text"},"ts":1585271435000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i missed that","msgtype":"m.text"},"ts":1585271439000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"zalgo again","msgtype":"m.text"},"ts":1585271457000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yes, it shouldn’t be possible to observe the result synchronously","msgtype":"m.text"},"ts":1585271474000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"if you want to do that just don't use promises","msgtype":"m.text"},"ts":1585271483000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so it's a slippery slope argument, that it'll enable that use case?","msgtype":"m.text"},"ts":1585271486000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"is there any other use case","msgtype":"m.text"},"ts":1585271500000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the repo seems entirely focused on \"the promise is fulfilled but you don't want to wait a tick to get the result\"","msgtype":"m.text"},"ts":1585271538000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well, the current design of Atomics.waitAsync misses an optimization opportunity because mixing sync and async is a no go, and introspecting promises synchronously is no go","msgtype":"m.text"},"ts":1585271550000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"if there were a way to do the latter, if that's somehow more palatable than the former, that'd re-enable that optimization opportunity","msgtype":"m.text"},"ts":1585271566000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"optimization where you don't have to wait a tick?","msgtype":"m.text"},"ts":1585271572000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1585271581000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"what's the optimization?","msgtype":"m.text"},"ts":1585271586000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right the design of promises is that you always have to wait a tick","msgtype":"m.text"},"ts":1585271592000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"https://github.com/tc39/proposal-atomics-wait-async/blob/master/SYNC-RESOLVE.md","msgtype":"m.text"},"ts":1585271608000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"basically, the point of the wait API is a building block for efficient mutexes in userland","msgtype":"m.text"},"ts":1585271636000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"waitNonblocking seems fine to me","msgtype":"m.text"},"ts":1585271641000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"like i said, the solution is to not use promises","msgtype":"m.text"},"ts":1585271650000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"it... can't not use promises","msgtype":"m.text"},"ts":1585271655000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"devsnek: waitNonBlocking returns a promise","msgtype":"m.text"},"ts":1585271658000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that is the whole point of it","msgtype":"m.text"},"ts":1585271660000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh","msgtype":"m.text"},"ts":1585271665000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"also the name is out of date, it's waitAsync now sorry","msgtype":"m.text"},"ts":1585271669000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"well","msgtype":"m.text"},"ts":1585271671000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but anyway the point of the API is a conditional wait","msgtype":"m.text"},"ts":1585271675000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Atomics.tryWait","msgtype":"m.text"},"ts":1585271676000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or something","msgtype":"m.text"},"ts":1585271681000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i'm not sure what that means","msgtype":"m.text"},"ts":1585271690000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it exits out if it would block","msgtype":"m.text"},"ts":1585271701000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"and then you can go do other things or call the waitAsync function","msgtype":"m.text"},"ts":1585271711000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah but whether an agent can block or not is a static property of the agent. the main thread can't block","msgtype":"m.text"},"ts":1585271719000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it's not that the user is choosing to block or to get a promise, it's that there's no choice","msgtype":"m.text"},"ts":1585271731000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"can you not just do Atomics.read, and then a compare, and then Atomics.waitAsync?","msgtype":"m.text"},"ts":1585271760000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it somehow doesn't always return a promise","msgtype":"m.text"},"ts":1585271763000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: yep, that's the workaround at the end","msgtype":"m.text"},"ts":1585271771000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"oh, cool","msgtype":"m.text"},"ts":1585271774000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that seems fine to me in honesty; I would not expect that to be a significant performance difference","msgtype":"m.text"},"ts":1585271796000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: that's probably just fine in practice 99% of the time. there's a TOTCTOU problem so you might get really surprising degraded mutex performance once on a blue moon","msgtype":"m.text"},"ts":1585271797000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: agreed, i don't plan to change it, just got to thinking about it again","msgtype":"m.text"},"ts":1585271819000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the weirdness is mainly that it *feels* weird to have a conditional wait API that's supposed to \"fail fast\" and signal when you don't need to wait, but for the async version, you can't observe that signal until the microtask checkpoint","msgtype":"m.text"},"ts":1585271852000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"at which point, you'd probably already waited a while","msgtype":"m.text"},"ts":1585271862000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i guess its worse for the web since it has the big render cycle thing to deal with","msgtype":"m.text"},"ts":1585271886000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the TOTCTOU problem is there for atomics.waitAsync too, yeah? nothing prevents the value from changing out from under you immediately as soon as the promise resolves, before you have had time to read from it?","msgtype":"m.text"},"ts":1585271889000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"shu anyway the alternative is, you return either `{ fast: true, value: value }` or `{fast: false, promise: promise }`","msgtype":"m.text"},"ts":1585271912000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and then the user switches on `fast`, and awaits the promise if they got one","msgtype":"m.text"},"ts":1585271924000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: ah good point, the problem is there for the entered-the-wait-queue path as well","msgtype":"m.text"},"ts":1585271935000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but i don't think in practice, once a thread is woken","msgtype":"m.text"},"ts":1585271944000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"you care about what the value of the futex location is","msgtype":"m.text"},"ts":1585271951000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: yeah, that also feels kinda gross, so status quo seems all right for now","msgtype":"m.text"},"ts":1585271980000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"once atomics.read has returned the right value, you also don't care, right?","msgtype":"m.text"},"ts":1585271982000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"you do, because you want the \"the read value is the right one, now enter the wait queue\" to be an atomic action","msgtype":"m.text"},"ts":1585272003000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"in case there's a lot of contention, for instance","msgtype":"m.text"},"ts":1585272013000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"if the value read is the right one, why are you entering the queue?","msgtype":"m.text"},"ts":1585272040000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's the futex api, you enter the wait queue when *addr == val","msgtype":"m.text"},"ts":1585272051000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"wait ok correction. why is the thing you would do after Atomics.waitAsync has fulfilled successfully any different from the thing you would do after Atomics.read has returned the value you were looking for?","msgtype":"m.text"},"ts":1585272103000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(it has been a while since I did low-level multithreading, sorry)","msgtype":"m.text"},"ts":1585272126000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"because the thing you do next is entering the wait queue","msgtype":"m.text"},"ts":1585272135000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"which should be atomic","msgtype":"m.text"},"ts":1585272138000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh after it fulfills","msgtype":"m.text"},"ts":1585272149000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"nvm","msgtype":"m.text"},"ts":1585272150000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: the canonical example is something like, you have a tri-state mutex: 0 == unlocked, 1 == locked, 2 == locked and contended","msgtype":"m.text"},"ts":1585272156000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: if there's contention, you don't want to immediately block the thread and wait, you want to do that if there's contention","msgtype":"m.text"},"ts":1585272174000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"that last message has a typo presumably, both of your branches are \"there's contention\"","msgtype":"m.text"},"ts":1585272202000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oops, if there's *no* contention you don't want to immediately block","msgtype":"m.text"},"ts":1585272229000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"sounds like we need futures","msgtype":"m.text"},"ts":1585272269000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: so if the state is != 0, you wait only if the state is already == 2, or successfully  compxchg the state from 1 to 2","msgtype":"m.text"},"ts":1585272273000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"otherwise, sometimes it gets \"fast unlocked\" in the interim and you just acquire the lock","msgtype":"m.text"},"ts":1585272296000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"so the futex wait call is on that state == 2","msgtype":"m.text"},"ts":1585272357000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"does the TOTCTOU make sense now?","msgtype":"m.text"},"ts":1585272434000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"still thinking through it","msgtype":"m.text"},"ts":1585272441000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: https://eli.thegreenplace.net/2018/basics-of-futexes/","msgtype":"m.text"},"ts":1585272461000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"search for \"simple mutex\"","msgtype":"m.text"},"ts":1585272466000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"there's a nice commented code snippet","msgtype":"m.text"},"ts":1585272470000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"this snippet seems like you could implement it just fine using Atomics.compareExchange + the promise-based Atomics.waitAsync (in place of the sleep)","msgtype":"m.text"},"ts":1585272635000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess the point is that you want to return early if it has been unlocked _between_ your compare-exchange and your call to waitAsync?","msgtype":"m.text"},"ts":1585272710000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this being the \"fast unlock\" thing","msgtype":"m.text"},"ts":1585272725000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1585272741000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"where the cmoment says \"Note that it's not necessary to loop around this syscall\"","msgtype":"m.text"},"ts":1585272745000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the loop in JS land with waitAsync is waiting until the microtask checkpoint","msgtype":"m.text"},"ts":1585272758000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"which... might be short, might be long, who knows? app dependent","msgtype":"m.text"},"ts":1585272779000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"If the syscall was guarded on `if (Atomics.read(atom) != 0) {`, would that not do the thing you want?","msgtype":"m.text"},"ts":1585272908000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"thinks","msgtype":"m.emote"},"ts":1585272942000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"no, i don't think so, you can imagine some scheduler that executes that line","msgtype":"m.text"},"ts":1585273064000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"then basically parks that thread","msgtype":"m.text"},"ts":1585273069000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"in the meantime 2 other threads do their locking/unlocking thing, and by the time you resume the first thread, you have 0 again, right?","msgtype":"m.text"},"ts":1585273094000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1585273164000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1585273164000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1585273165000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i don't think it's possible to fix in userland","msgtype":"m.text"},"ts":1585273172000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"but the chances of failure are exceedingly small","msgtype":"m.text"},"ts":1585273177000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and \"failure\" just means extra long to acquire a lock, not deadlock or anything","msgtype":"m.text"},"ts":1585273190000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1585273341000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and the case it comes up is specifically where someone has unlocked your futex between the time you looked and the time you went to enter the queue, which is pretty much the immediate next operation you are doing","msgtype":"m.text"},"ts":1585273400000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"having the extra microtask tick on the main thread in that case seems ok","msgtype":"m.text"},"ts":1585273424000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this is definitely an Atomics-specific reason to be able to return early sometimes, though; if we wanted to address it I think having your API return sometimes-sync sometimes-promise (ideally wrapped, as in my example above) would be a better fix than introducing a general-purpose promise introspection utility","msgtype":"m.text"},"ts":1585273517000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1585273701000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Bakkot: yeah, that sounds very reasonable","msgtype":"m.text"},"ts":1585273727000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"need to stew on whether we want to return a wrapped thing","msgtype":"m.text"},"ts":1585273758000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"it's kinda unergonomic to not be able to write `await Atomics.waitAsync(...)` but shrug","msgtype":"m.text"},"ts":1585273780000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"hmm, yeah","msgtype":"m.text"},"ts":1585273808000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I guess it would be ok for it to not be wrapped, given that await can be passed a non-promise value","msgtype":"m.text"},"ts":1585273823000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I dislike that fact but it is what it is","msgtype":"m.text"},"ts":1585273828000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"though, actually, does that `await` not introduce an additional microtask tick in the case that waitAsync returns a promise?","msgtype":"m.text"},"ts":1585273910000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it doesn't","msgtype":"m.text"},"ts":1585273924000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"though it used to","msgtype":"m.text"},"ts":1585273933000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ahh","msgtype":"m.text"},"ts":1585273935000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"cool","msgtype":"m.text"},"ts":1585273936000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that was the \"await optimization\" thing the chakracore people brought at some point","msgtype":"m.text"},"ts":1585273948000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"changed it to just do Promise.resolve(v).then(resume)","msgtype":"m.text"},"ts":1585273958000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"The await optimization took it from 3 ticks to 1 tick.","msgtype":"m.text"},"ts":1585274066000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"But using `await` always ticks.","msgtype":"m.text"},"ts":1585274089000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"The only way a sync-promise would work is if you did `Atomics.waitAsync(...).then(syncStuff)`","msgtype":"m.text"},"ts":1585274114000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"shu: I guess I am convinced that a not-wrapped value would be OK. I would maybe prefer `{ fast: true, value: 0 }` or `{ fast: false, value: promise }`, so that you don't have to do the typeof check and can still do the handy `await Atomics.waitAsync().value`.","msgtype":"m.text"},"ts":1585274587000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but, also, I don't think this necessarily needs solving","msgtype":"m.text"},"ts":1585274595000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i think wrapped is the way to go if we wanna solve it, but yeah i agree i’m not sure this needs solving","msgtype":"m.text"},"ts":1585278469000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Btw, I know I missed this meeting's deadline (not thru laziness! we just came up with the idea too late!), but putting this out there in prep for the next meeting: https://github.com/tabatkins/proposal-item-method","msgtype":"m.text"},"ts":1585331750000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"hopefully we can dedicate 30-40m to bikeshedding the name","msgtype":"m.text"},"ts":1585331841000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: fortunately the justification for this one is in many ways tied to the name being exactly `item`","msgtype":"m.text"},"ts":1585331909000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which is quite nice","msgtype":"m.text"},"ts":1585331914000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"why not at()","msgtype":"m.text"},"ts":1585331964000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"read the readme","msgtype":"m.text"},"ts":1585331972000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"tldr is \"to match the DOM\"","msgtype":"m.text"},"ts":1585332004000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i think we've been all right about bikeshedding recently","msgtype":"m.text"},"ts":1585332016000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"we don't *have* to match the dom though","msgtype":"m.text"},"ts":1585332032000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"we don't have to do a lot of things","msgtype":"m.text"},"ts":1585332042000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"not that i disagree with the motivation","msgtype":"m.text"},"ts":1585332046000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"devsnek: we don't have to, but the advantage of matching is not just for consistency but that it allows the DOM array-wrapping apis to avoid some magic","msgtype":"m.text"},"ts":1585332112000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i like the proposal","msgtype":"m.text"},"ts":1585332248000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"just wanted to point out it was technically not imperative","msgtype":"m.text"},"ts":1585332256000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ah, yeah","msgtype":"m.text"},"ts":1585332261000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah it's not imperative, just, there's a strong built-in bias towards one particular name, which helps avoid bikeshedding","msgtype":"m.text"},"ts":1585332331000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"TabAtkins: fwiw it looks like mootools does _not_ have `.item`; it was the largest offender on fragile builtin overrides pattern, to my knowledge. so that's hopeful.","msgtype":"m.text"},"ts":1585332444000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Nice.","msgtype":"m.text"},"ts":1585332452000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"smooshIntoCollectionIndex(n)","msgtype":"m.text"},"ts":1585332476000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Prototype / Ext also had issues in the past (goes off to check)","msgtype":"m.text"},"ts":1585332482000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"they both do not have that method","msgtype":"m.text"},"ts":1585332545000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"double nice","msgtype":"m.text"},"ts":1585332744000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"re: bikeshedding; I","msgtype":"m.text"},"ts":1585332763000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1585332765000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"clearly we need to add a new syntax","msgtype":"m.text"},"ts":1585332780000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"japanese quotation marks","msgtype":"m.text"},"ts":1585332789000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"re: bikeshedding; I'm one of the people who've desperately wanted negative indexing as well, so *any* name would make me happy on those grounds, but yeah, using exactly .item() would make me even happier","msgtype":"m.text"},"ts":1585332799000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"there was a proposal from someone at some point for indexing/stepping syntax","msgtype":"m.text"},"ts":1585332829000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"might've been on the discourse","msgtype":"m.text"},"ts":1585332839000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"API would be simpler / provides benefits that can be backported cheaper","msgtype":"m.text"},"ts":1585332866000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"yeah i agree","msgtype":"m.text"},"ts":1585332877000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot/bradleymeck: thanks, added the info to the proposal","msgtype":"m.text"},"ts":1585333075000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"btw, am I right in my findings that the TypedArray superclass isn't publicly exposed under any name, and so the way to add to all typed arrays' prototypes is indeed `Uint8Array.__proto__.prototype.item = item;`?","msgtype":"m.text"},"ts":1585333192000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: use Object.setPrototypeOf as Deno/Node don't guarantee __proto__ anymore, but yes","msgtype":"m.text"},"ts":1585333238000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"getPrototypeOf*","msgtype":"m.text"},"ts":1585333294000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i wonder if we should have an Iterator.prototype.nth","msgtype":"m.text"},"ts":1585333343000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"-1th","msgtype":"m.text"},"ts":1585333357000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"probably not since we can't really lower it for perf","msgtype":"m.text"},"ts":1585333361000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"but its nice in rust","msgtype":"m.text"},"ts":1585333366000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Anything that implies random access over an iterator is probably bad.","msgtype":"m.text"},"ts":1585333419000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"You want to be more explicit that you're first discarding N-1 values from the iterator, then taking the next one.","msgtype":"m.text"},"ts":1585333468000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"there was an interesting discussion along that line in the proposal","msgtype":"m.text"},"ts":1585333479000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"about giving an index in the map/etc functions","msgtype":"m.text"},"ts":1585333486000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"That can def be worthwhile to build into the Iterator protocol under an easy name, it just needs to be clear in its semantics.","msgtype":"m.text"},"ts":1585333496000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yeah rn you'd do skip(n).next() i guess","msgtype":"m.text"},"ts":1585333505000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1585333514000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"or skip(n - 1) i guess","msgtype":"m.text"},"ts":1585333517000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"seems fine to me","msgtype":"m.text"},"ts":1585333526000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no, skip(n) is correct","msgtype":"m.text"},"ts":1585333532000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"that's plenty explicit","msgtype":"m.text"},"ts":1585333536000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if you want the fifth item you'd skip four and take one","msgtype":"m.text"},"ts":1585333554000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"where's the zeroth item?","msgtype":"m.text"},"ts":1585333576000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"you filthy 1-indexer","msgtype":"m.text"},"ts":1585333586000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"skip(0) is no-op","msgtype":"m.text"},"ts":1585333588000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"exactly","msgtype":"m.text"},"ts":1585333592000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"its the number of items to skip","msgtype":"m.text"},"ts":1585333597000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Yes, I know.","msgtype":"m.text"},"ts":1585333603000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I'm saying that \".nth(0)\" is \"skip 0 items, get the next one\"","msgtype":"m.text"},"ts":1585333617000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"oh i see what you mean","msgtype":"m.text"},"ts":1585333638000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"because the 5th item is at index 5, and thus has five items before it","msgtype":"m.text"},"ts":1585333642000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yeah by fifth item i meant","msgtype":"m.text"},"ts":1585333646000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1585333651000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"*violent agreement*","msgtype":"m.text"},"ts":1585333681000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what if it was named nst","msgtype":"m.text"},"ts":1585335653000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: what if you were named nst","msgtype":"m.text"},"ts":1585335801000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"let's compromise and name is nnd","msgtype":"m.text"},"ts":1585335812000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"n2d sgtm","msgtype":"m.text"},"ts":1585335832000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"`nnd` -- takes a number but rounds it to the nearest integer ending in a 2 first","msgtype":"m.text"},"ts":1585336629000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"proposal to add rounding mode flag to Math.round","msgtype":"m.text"},"ts":1585336666000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"oh wow","msgtype":"m.text"},"ts":1585336845000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"https://upload.wikimedia.org/wikipedia/commons/8/8a/Comparison_rounding_graphs_SMIL.svg","msgtype":"m.text"},"ts":1585336847000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"what a delightful chart","msgtype":"m.text"},"ts":1585336851000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"this svg has hover effects","msgtype":"m.text"},"ts":1585336890000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I did not know you could do that","msgtype":"m.text"},"ts":1585336893000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"neither did i","msgtype":"m.text"},"ts":1585336928000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"Oh yeah, hover is great","msgtype":"m.text"},"ts":1585337365000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I don't think *this chart* uses them very well; it's still nearly unreadable when you hover one, but hey","msgtype":"m.text"},"ts":1585337380000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i'm impressed by the number of things and the different colors","msgtype":"m.text"},"ts":1585337670000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"(node still guarantees __proto__ by default, what flags do is different)","msgtype":"m.text"},"ts":1585338477000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"TabAtkins: so, aside from the DOM pushing a specific name, what semantics does that push for, specifically around validation errors/exceptions and edge cases?","msgtype":"m.text"},"ts":1585338528000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"That's a good question and I'll figure it out and document it","msgtype":"m.text"},"ts":1585338566000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"TabAtkins: because i'm only mildly annoyed by the web predetermining the name, but if they predetermine other semantics that don't align with what would actually be conventional for JS, i'm a lot more annoyed","msgtype":"m.text"},"ts":1585338607000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I highly suspect that the more detailed semantics aren't important to compat here","msgtype":"m.text"},"ts":1585338650000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"that's ideal :-)","msgtype":"m.text"},"ts":1585338767000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: so i think a uniform way to do relative indexing for indexable data is the high-order bit; if the web compat bit cost is naming, that sounds pretty win-win to me","msgtype":"m.text"},"ts":1585338891000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"TabAtkins: NodeList's item does not support negative indexes","msgtype":"m.text"},"ts":1585339057000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"changing that behavior seems like it might be breaking","msgtype":"m.text"},"ts":1585339088000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I doubt that. We'll see!","msgtype":"m.text"},"ts":1585339152000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Before this ships we'll probably need to instrument and verify.","msgtype":"m.text"},"ts":1585339173000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"if not that would be ideal","msgtype":"m.text"},"ts":1585339180000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Not hard to measure how many pages pass negative numbers to it right now","msgtype":"m.text"},"ts":1585339230000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"great","msgtype":"m.text"},"ts":1585339290000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it is easy to imagine someone doing `i = list.length - 1; do { e = list.item(i); doThing(e); --i; } while (e != null)` or whatever","msgtype":"m.text"},"ts":1585339333000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"people write all sorts of crazy loops","msgtype":"m.text"},"ts":1585339343000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"what does NodeList's item do now when passed a negative number?","msgtype":"m.text"},"ts":1585339352000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"returns `null`","msgtype":"m.text"},"ts":1585339368000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(nb not `undefined`, which is probably also something which would have to change)","msgtype":"m.text"},"ts":1585339391000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah","msgtype":"m.text"},"ts":1585339745000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: oh sure, for naming that's why i'm only mildly annoyed","msgtype":"m.text"},"ts":1585342994000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(fwiw i do consider the feature useless without support for negative numbers)","msgtype":"m.text"},"ts":1585343015000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yeah, DOM stuff always returns null, another Java legacy.","msgtype":"m.text"},"ts":1585343261000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"But since most people test for null with either a `== null` or `!` check, switching to undefined has a good chance of being safe.","msgtype":"m.text"},"ts":1585343284000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"honestly this seems like arguments to not use `.items`","msgtype":"m.text"},"ts":1585343342000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"er `.item`","msgtype":"m.text"},"ts":1585343350000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Unless they prove to be breaking, they're not.  And the point of me introducing this is to try and get .item() specifically.","msgtype":"m.text"},"ts":1585343436000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"In the worst case, we just don't upgrade the legacy interfaces.","msgtype":"m.text"},"ts":1585343459000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"And JS is free to do whatever.","msgtype":"m.text"},"ts":1585343465000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i mean you'd have to prove no code does `=== null`","msgtype":"m.text"},"ts":1585343471000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or yeah we can not make the web use the new behaviour","msgtype":"m.text"},"ts":1585343491000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"No, we just have to have reasonable assurance, and not see reported breakage in dev/beta channels.","msgtype":"m.text"},"ts":1585343492000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"seems like a lot of trouble for no payoff","msgtype":"m.text"},"ts":1585343528000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"The payoff is I get to quit writing `[...document.querySelectorAll(\"a\")].map(foo)`","msgtype":"m.text"},"ts":1585343597000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"becasue NodeList is a freakin' Array now","msgtype":"m.text"},"ts":1585343610000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"wait do you actually want to replace NodeList with Array","msgtype":"m.text"},"ts":1585343651000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"(Or rather today I always do a `function findAll(sel) { return [...document.querySelectorAll(sel)];}` at the top of my projects","msgtype":"m.text"},"ts":1585343661000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"No, with ObservableArray, which is a proxy around Array that lets us still intercept get/set/etc.","msgtype":"m.text"},"ts":1585343682000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Domenic wrote it up and got it into WebIDL just a little bit ago.","msgtype":"m.text"},"ts":1585343691000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I have never seen someone spell that function anything other than `$$`","msgtype":"m.text"},"ts":1585343692000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so you want it to be called .item so you don't have to worry about whether you're dealing with an ObservableArray or an Array","msgtype":"m.text"},"ts":1585343778000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or something else","msgtype":"m.text"},"ts":1585343785000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"TabAtkins: you should already be writing `Array.from(document.querySelectorAll('a'), foo)` :-p","msgtype":"m.text"},"ts":1585344160000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"god why","msgtype":"m.text"},"ts":1585344180000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so you don't create an intermediate array","msgtype":"m.text"},"ts":1585344185000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Array.from's mapper function is a godsend, i use it allllll the time","msgtype":"m.text"},"ts":1585344200000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: ObservableArray is a proxy over Array, so it's not a matter of \"which one you see\" - as far as the author is concerned they're getting an Array.","msgtype":"m.text"},"ts":1585344217000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"something something premature optimization","msgtype":"m.text"},"ts":1585344221000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"TabAtkins: well in theory ObservableArray could be a subclass and a proxy","msgtype":"m.text"},"ts":1585344238000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"see the doc for exploration of some of the alternate choices and why i prefer not to have them","msgtype":"m.text"},"ts":1585344241000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"the iterator protocol is slow ¯\\_(ツ)_/¯","msgtype":"m.text"},"ts":1585344244000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"not just a proxy","msgtype":"m.text"},"ts":1585344246000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"including that one in particular","msgtype":"m.text"},"ts":1585344247000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Bakkot: but yeah fair","msgtype":"m.text"},"ts":1585344250000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb for arrays? is it really?","msgtype":"m.text"},"ts":1585344261000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: NodeList isn't an array","msgtype":"m.text"},"ts":1585344278000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yah it's fakey fake fake","msgtype":"m.text"},"ts":1585344285000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"s/arrays/nodelists/","msgtype":"m.text"},"ts":1585344287000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: i'm sure it's optimized for the common use cases in modern engines, the ones where perf matters the least","msgtype":"m.text"},"ts":1585344297000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i wouldn't describe iterators as slow","msgtype":"m.text"},"ts":1585344308000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"what i also personally like is, not having to rely on `.map` being there","msgtype":"m.text"},"ts":1585344319000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but i wouldn't describe them as blistering fast either","msgtype":"m.text"},"ts":1585344321000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb yeah I mean if you observe that you have performance issues I am all for using whatever hacks are necessary to become fast, though usually that means using imperative loops rather than function style","msgtype":"m.text"},"ts":1585344437000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if you have not yet observed that, keep your code readable","msgtype":"m.text"},"ts":1585344446000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"https://twitter.com/devsnek/status/1243586726976724992","msgtype":"m.text"},"ts":1585344496000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lul","msgtype":"m.text"},"ts":1585344709000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Bakkot: i find the array.from example readable personally","msgtype":"m.text"},"ts":1585344730000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"devsnek: lol","msgtype":"m.text"},"ts":1585344735000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"readable because you know the signature of Array.from","msgtype":"m.text"},"ts":1585344754000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I didn't know about that second arg","msgtype":"m.text"},"ts":1585344788000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"TabAtkins: your site is making me dizzy","msgtype":"m.text"},"ts":1585344809000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the homepage?","msgtype":"m.text"},"ts":1585344821000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ya lol","msgtype":"m.text"},"ts":1585344826000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1585344838000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"my website is literally text/plain though so i can't really throw shade","msgtype":"m.text"},"ts":1585344878000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"ljharb it's fine if you and all future readers of the code can be expected to know about the second argument, but I don't think people should know about it. people should learn about `Array.from()` with one argument, and learn about `map`, and those compose naturally, and then there is no reason to ever learn this third thing (Array.from takes a second argument).","msgtype":"m.text"},"ts":1585344879000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(unless they start getting into microoptimization, of course, but that's gonna need to be backed up with bechmark data for their particular codebase and userbase)","msgtype":"m.text"},"ts":1585344927000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i don't think it's unreasonable to expect people to know about something built into the language, that's not esoteric","msgtype":"m.text"},"ts":1585344928000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it should be esoteric","msgtype":"m.text"},"ts":1585344937000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"because there is no reason to learn it","msgtype":"m.text"},"ts":1585344946000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"in theory an engine can combine Array.from().map","msgtype":"m.text"},"ts":1585344978000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if the map argument is pure at least","msgtype":"m.text"},"ts":1585344995000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"if there's no reason to learn it, then why was it shipped","msgtype":"m.text"},"ts":1585344997000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb do you also use the second argument to Array.p.map?","msgtype":"m.text"},"ts":1585345016000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek: only if the mapper doesn't access or detect the third argument","msgtype":"m.text"},"ts":1585345016000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"like i said, if its pure","msgtype":"m.text"},"ts":1585345029000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"we ship plenty of things we don't want people to learn, what","msgtype":"m.text"},"ts":1585345035000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"devsnek: it can be pure even if it accesses it","msgtype":"m.text"},"ts":1585345039000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"do you also think it is reasonable to expect them to learn that?","msgtype":"m.text"},"ts":1585345039000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: no, true enough","msgtype":"m.text"},"ts":1585345044000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"shu: are you telling me i should've bother learning String.prototype.blink","msgtype":"m.text"},"ts":1585345081000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"there's a lot of reason to learn that over second argument to map or from","msgtype":"m.text"},"ts":1585345113000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"- street cred","msgtype":"m.text"},"ts":1585345120000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"...what's the second argument to map()","msgtype":"m.text"},"ts":1585345120000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ok but the `this` argument to .map was added in 2009, before arrows, and before .bind was common","msgtype":"m.text"},"ts":1585345126000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"thisArg","msgtype":"m.text"},"ts":1585345128000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"- historian cred","msgtype":"m.text"},"ts":1585345133000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"oh, to the map callback","msgtype":"m.text"},"ts":1585345137000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"phew","msgtype":"m.text"},"ts":1585345139000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Array.from's mapper arg was added in 2015, along with array spread","msgtype":"m.text"},"ts":1585345139000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"oh no wait i see","msgtype":"m.text"},"ts":1585345143000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"so what was the rationale for it, if it's not worth learning?","msgtype":"m.text"},"ts":1585345148000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"TabAtkins: and the callback itself takes (item, index, array)","msgtype":"m.text"},"ts":1585345150000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think you mean (element, index, collection) (EIC, still waiting for \"haltToken\")","msgtype":"m.text"},"ts":1585345173000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1585345181000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"can confirm that's how brendan himself teaches it","msgtype":"m.text"},"ts":1585345191000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"`(element, index, collection, signal)`","msgtype":"m.text"},"ts":1585345197000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I don't understand how you could replace these not-an-arrays with `ObservableArray`","msgtype":"m.text"},"ts":1585345212000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"well if it only breaks less than .0003% of the web or whatever chrome's metric is","msgtype":"m.text"},"ts":1585345244000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"We'd have to add every method that the no-an-array has to `ObservableArray` or `Array`?","msgtype":"m.text"},"ts":1585345255000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"jridgewell: There's precisely one.","msgtype":"m.text"},"ts":1585345268000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":".item()","msgtype":"m.text"},"ts":1585345270000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"For all the not-an-arrays?","msgtype":"m.text"},"ts":1585345280000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"For a lot of them, at least","msgtype":"m.text"},"ts":1585345284000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"NodeList, StyleSheetList","msgtype":"m.text"},"ts":1585345288000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ljharb: the reason for the mapper function for Array#from was it enables easier array subclassing","msgtype":"m.text"},"ts":1585345295000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"(ugh)","msgtype":"m.text"},"ts":1585345313000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Ok.","msgtype":"m.text"},"ts":1585345315000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"shu: how?","msgtype":"m.text"},"ts":1585345323000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(does this mean `e, i, c, h` is the `s t a b` of JavaScript)","msgtype":"m.text"},"ts":1585345324000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"So because `Array` would now conform the the API provided by `NodeList`, it wouldn't matter that we now returned an array...","msgtype":"m.text"},"ts":1585345336000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"shu: you mean like a subclass doesn't have to override `.map`, just `static from`?","msgtype":"m.text"},"ts":1585345338000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Would there still be the perf cliff?","msgtype":"m.text"},"ts":1585345347000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Eg, a live `NodeList`","msgtype":"m.text"},"ts":1585345365000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"jridgewell: I mean, we still need the proxy for things that are live.","msgtype":"m.text"},"ts":1585345368000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ljharb: https://github.com/tc39/notes/blob/master/meetings/2013-01/jan-30.md#revising-the-array-subclassing-kind-issue","msgtype":"m.text"},"ts":1585345369000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"shu: lol that says there's a thisArg, but there isn't one","msgtype":"m.text"},"ts":1585345404000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but well, now i feel dirty, because one of my favorite parts of the language was created to enable a dumb and inconsistent subclassing model","msgtype":"m.text"},"ts":1585345412000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"no i think the lesson here is just all artifacts exist historically","msgtype":"m.text"},"ts":1585345441000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"fair","msgtype":"m.text"},"ts":1585345473000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i retract my implication that existence proves usefulness","msgtype":"m.text"},"ts":1585345482000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(but i still find this one useful)","msgtype":"m.text"},"ts":1585345490000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rkirsling: yes","msgtype":"m.text"},"ts":1585345553000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"yeah i think for computers especially after some time the original motivations don't really matter","msgtype":"m.text"},"ts":1585345558000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"> existence proves usefulness *cries in abstract equality*","msgtype":"m.text"},"ts":1585345564000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"TabAtkins: :D","msgtype":"m.text"},"ts":1585345566000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(i still dont' understand what the `s t a b` mean, either individually or collectively)","msgtype":"m.text"},"ts":1585345571000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"it's `s t` and `a b` separately but adjacent","msgtype":"m.text"},"ts":1585345589000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"which comically forms a word","msgtype":"m.text"},"ts":1585345601000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"if you try to explain Lenses to me here in IRC i will fight you","msgtype":"m.text"},"ts":1585345614000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"I absolutely will not 😂 I actually only understand it at a very high level myself","msgtype":"m.text"},"ts":1585345646000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah i know roughly how to use it, but no clue whatsoever how the abstraction works","msgtype":"m.text"},"ts":1585345689000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"i.e. \"pure FP decided it wanted in on the property access thing too\"","msgtype":"m.text"},"ts":1585345713000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"which annoys me becasue people complain about monads and, like, they're trivial, so i'm not sure if lenses are in the same boat and i haven't hit the insight yet, or they're actually complicated and it's okay","msgtype":"m.text"},"ts":1585345715000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"that kind of functional programming is basically that kindergarten game where you need to find the right shaped hole for objects","msgtype":"m.text"},"ts":1585345742000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"and then being very proud you stacked several objects together and put it into a novel shaped hole","msgtype":"m.text"},"ts":1585345767000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"isn't that kind of the whole idea of naturality in category theory though? :p","msgtype":"m.text"},"ts":1585345803000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"basically yeah","msgtype":"m.text"},"ts":1585345813000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"someone was really upset that we put in optional chaining instead of a method on properties that returns Option","msgtype":"m.text"},"ts":1585345863000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"took me an embarrassingly long time to figure out you were talking about lenses and not pokemon","msgtype":"m.text"},"ts":1585345866000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"as much as i dunk on pokemon, pokemon is orders of magnitude more beneficial for society than category theory","msgtype":"m.text"},"ts":1585345893000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"( https://bulbapedia.bulbagarden.net/wiki/Same-type_attack_bonus )","msgtype":"m.text"},"ts":1585345900000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"shu: ouch","msgtype":"m.text"},"ts":1585345908000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Bakkot: fascinating","msgtype":"m.text"},"ts":1585345926000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that Baez guy is all about applying category theory to save the planet though","msgtype":"m.text"},"ts":1585346044000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"here's hoping he finds success 🍷","msgtype":"m.text"},"ts":1585346067000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i think mathematicians are exempt from my hot take","msgtype":"m.text"},"ts":1585346261000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"😆","msgtype":"m.text"},"ts":1585346274000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"agendas repo seems like it should maybe be read-only for non delegates, if that is a possibility?","msgtype":"m.text"},"ts":1585348339000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"+1","msgtype":"m.text"},"ts":1585348373000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"is it not?","msgtype":"m.text"},"ts":1585348482000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"evidently not, no","msgtype":"m.text"},"ts":1585348504000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i wasn't able to modify it until i became a delegate","msgtype":"m.text"},"ts":1585348517000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i was in the invited experts team before that","msgtype":"m.text"},"ts":1585348522000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh, sorry, I meant issues as well as the code","msgtype":"m.text"},"ts":1585348525000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"only for a 24 hour period as a time","msgtype":"m.text"},"ts":1585348542000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"all issues are open for all on github","msgtype":"m.text"},"ts":1585348548000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"huh","msgtype":"m.text"},"ts":1585348556000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bleh","msgtype":"m.text"},"ts":1585348574000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":":(","msgtype":"m.text"},"ts":1585349757000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Bakkot: you're saying \"must implement as specified\" is weaker than \"must not implement except as specified\"? like, the former would still allow for bonus params or something?","msgtype":"m.text"},"ts":1585350984000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"er sorry \"must not extend except as specified\"","msgtype":"m.text"},"ts":1585351032000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: yes","msgtype":"m.text"},"ts":1585351063000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I see","msgtype":"m.text"},"ts":1585351068000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"and also in the case that 402 is not active it says \"the following is used\", rather than \"the following must be used\" or whatever","msgtype":"m.text"},"ts":1585351070000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"wait but \"is\" sounds even more unwavering to me than \"must\"","msgtype":"m.text"},"ts":1585351097000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"sorry, the \"it\" in that sentence is \"BigInt.prototype.toLocaleString\"","msgtype":"m.text"},"ts":1585351285000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"so, yes, that's my point - the current BigInt.prototype.toLocaleString does not read as a strong of a requirement as the forbidden extensions does","msgtype":"m.text"},"ts":1585351314000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"alright","msgtype":"m.text"},"ts":1585351443000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I see","msgtype":"m.text"},"ts":1585351559000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"do you agree that it seems like an unintentional omission though?","msgtype":"m.text"},"ts":1585351581000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"can't we just say \"extensions to builtins that are otherwise specified in 402 are forbidden\"","msgtype":"m.text"},"ts":1585351653000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or something along those lines","msgtype":"m.text"},"ts":1585351658000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"bikeshedding needed","msgtype":"m.text"},"ts":1585351662000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah it might be ideal to not have to keep maintaining the list","msgtype":"m.text"},"ts":1585351695000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"it seems like a spec bug, but still a normative change","msgtype":"m.text"},"ts":1585351815000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i also think it would be good to avoid the list","msgtype":"m.text"},"ts":1585351826000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(especially since you can already grep for \"402\" in the spec to find all those extension points)","msgtype":"m.text"},"ts":1585351841000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rkirsling yes it's definitely accidental; this is just a process point","msgtype":"m.text"},"ts":1585351915000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"we can resolve it in two minutes in plenary","msgtype":"m.text"},"ts":1585351935000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"cool","msgtype":"m.text"},"ts":1585352268000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Bakkot: Added a list of upgradeable interfaces, and a (comprehensive afaict) list of the changes from current behavior with an exploration of the possible breakages that could result.","msgtype":"m.text"},"ts":1585352369000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"thanks for the push to do it","msgtype":"m.text"},"ts":1585352378000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"nice!","msgtype":"m.text"},"ts":1585352379000,"senderName":"Bakkot","senderId":"Bakkot@irc"}
]