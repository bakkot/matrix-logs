[
{"content":{"body":"I guess it's possible to implement such a rule whether Object.strictEquals is built-in or defined in user code. I'm still not really convinced that you want those semantics all the time (and continued assertions of \"it's broken\" aren't so persuasive to me), but if JS programmer does what to write those checks for their code, sure, they can go for it.","msgtype":"m.text"},"ts":1590574014000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"I feel like we might've added edge cases or functions in the past when there were specific requests made, but that that's not really the best design method in general. For one example, I'm not sure if `BigInt.asIntN` is all that useful, even if it had a role in selecting BigInt over Int64--we could've just chosen BigInt without adding that function.","msgtype":"m.text"},"ts":1590574088000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"Bakkot: I'm really happy you're bringing do expressions back to the game. on slide 10: I believe it's ok w/ loops and it does not create anything we don't know. `for (let a of 'abc') a;` completes to  'c' already, this should not be \"bad\". It's just a pre-existing fact","msgtype":"m.text"},"ts":1590598048000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"leobalter: it's a fact very few people are exposed to currently, and which many people have expressed surprise at in the context of this proposal","msgtype":"m.text"},"ts":1590598082000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"on slide 11: declarations is as bad as declarations in blocks.","msgtype":"m.text"},"ts":1590598094000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"?","msgtype":"m.text"},"ts":1590598112000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"declarations in blocks are fine in general","msgtype":"m.text"},"ts":1590598116000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"do you mean, in do-expressions?","msgtype":"m.text"},"ts":1590598120000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the idea is that the prohibition on loops and declarations ending a do-expression would be applied recursively in the last statement(s) of the block, so that all of `do { let x; }`, `do { { let x; } }`, `do { if (foo) { let x; } else { 0; } }` etc would be a syntax error","msgtype":"m.text"},"ts":1590598175000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"https://www.irccloud.com/pastebin/cKAO7oSY/","msgtype":"m.text"},"ts":1590598214000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"ah, that's specifically because of B.3.3 hoisting, which I am also proposing to prohibit in do-expressions","msgtype":"m.text"},"ts":1590598284000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that code would give you an error in a module, which I think is reasonable","msgtype":"m.text"},"ts":1590598301000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"(or any other strict context)","msgtype":"m.text"},"ts":1590598310000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I believe this is a concern for userland, a linter should worry about it","msgtype":"m.text"},"ts":1590598317000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"hmm","msgtype":"m.text"},"ts":1590598329000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I don't think there is any reason someone would want to end a do-expression with a declaration currently.","msgtype":"m.text"},"ts":1590598344000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I'm not objecting to anything but expressing a preference, to be clear here","msgtype":"m.text"},"ts":1590598349000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"so I don't see a benefit to allowing it","msgtype":"m.text"},"ts":1590598360000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I agree no one want to end a do-expression with a declaration, but I'd keep the semantics equivalent for blocks. We are just capturing the completion result","msgtype":"m.text"},"ts":1590598400000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"it's not allowing it, it's actually not creating special rules to disallow it","msgtype":"m.text"},"ts":1590598438000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"strong agree with leobalter but i think you knew that already","msgtype":"m.text"},"ts":1590598479000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"most of these problems will be taken care of in strict mode / module code","msgtype":"m.text"},"ts":1590598481000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"my general philosophy is that if there is a place where a syntactic construct would always be surprising, we should just disallow that syntax","msgtype":"m.text"},"ts":1590598489000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"always be surprising or undesirable, I should say","msgtype":"m.text"},"ts":1590598504000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"also `do {}` should just be undefined","msgtype":"m.text"},"ts":1590598504000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`do {}` being undefined I am on board with","msgtype":"m.text"},"ts":1590598524000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I'll start writing that instead of `void 0`","msgtype":"m.text"},"ts":1590598534000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"lol","msgtype":"m.text"},"ts":1590598552000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I am really happy to see do expressions in the agenda, I'm a big supporter of this feature","msgtype":"m.text"},"ts":1590598552000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"as for disallowing certain syntax","msgtype":"m.text"},"ts":1590598564000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think its just kind of awkward at the statement level cuz you have to start worrying about what happens if you comment out a line","msgtype":"m.text"},"ts":1590598587000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"hmm, that's a fair point","msgtype":"m.text"},"ts":1590598616000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"this is also a big thing: `do { throw 'foo' }` we solve the lack of throw expressions","msgtype":"m.text"},"ts":1590598643000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"but not the tendency of people to throw strings :P","msgtype":"m.text"},"ts":1590598667000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"don't ask me to form a full example in irc chat","msgtype":"m.text"},"ts":1590598689000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"haha","msgtype":"m.text"},"ts":1590598694000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think the main reason for throw expressions was concise bodies","msgtype":"m.text"},"ts":1590598708000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"for declarations, the other option is to change the completion value for the declaration to be the RHS (or undefined)","msgtype":"m.text"},"ts":1590598711000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"at which point you might as well just drop the `do` and use a non-concise body","msgtype":"m.text"},"ts":1590598722000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"or in the case of class or function declarations the original value of the binding (because they are hoisted), though that's... awkward","msgtype":"m.text"},"ts":1590598728000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"devsnek: throw expressions also make sense in default parameters and a few other cases","msgtype":"m.text"},"ts":1590598756000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"i think undefined makes the most sense","msgtype":"m.text"},"ts":1590598756000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"oh fair point","msgtype":"m.text"},"ts":1590598763000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I think if someone writes `do { function f(){} }` they should either get an error or `f`","msgtype":"m.text"},"ts":1590598780000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah i'm fine with making function declarations return the relevant function","msgtype":"m.text"},"ts":1590598807000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"wait are function declarations mutable","msgtype":"m.text"},"ts":1590598816000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1590598819000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and hoisted","msgtype":"m.text"},"ts":1590598820000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"aw man","msgtype":"m.text"},"ts":1590598825000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"so that one is awkward; probably you want to do the original value of the binding, I guess?","msgtype":"m.text"},"ts":1590598834000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"which is weird","msgtype":"m.text"},"ts":1590598838000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah","msgtype":"m.text"},"ts":1590598839000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"well i don't think binding fits into it","msgtype":"m.text"},"ts":1590598847000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"this is part of why I want to disallow declarations here :P","msgtype":"m.text"},"ts":1590598856000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"its more like function declarations know the function instance they create","msgtype":"m.text"},"ts":1590598878000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"without going through the binding","msgtype":"m.text"},"ts":1590598884000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i think we need to just very carefully go through completions","msgtype":"m.text"},"ts":1590598896000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"yeah, same thing","msgtype":"m.text"},"ts":1590598897000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"the surprising completions are mostly just declarations and loops","msgtype":"m.text"},"ts":1590598942000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"it is maybe a bit surprising that the completion of a `try { } finally { }` comes from the `try` and not the `finally`, but not that surprising I think.","msgtype":"m.text"},"ts":1590598970000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"once you know what the deal with finally is","msgtype":"m.text"},"ts":1590598992000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"should do expressions blocks always run in strict mode?","msgtype":"m.text"},"ts":1590598994000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"well there is precedence with classes","msgtype":"m.text"},"ts":1590599019000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"leobalter: it's a little tempting, but the last time we discussed it people did not like having strictness change within a function body","msgtype":"m.text"},"ts":1590599068000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"as opposed to the boundary of a function","msgtype":"m.text"},"ts":1590599082000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"or class","msgtype":"m.text"},"ts":1590599096000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"given static initializers","msgtype":"m.text"},"ts":1590599102000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"classes are functions basically","msgtype":"m.text"},"ts":1590599110000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"yeah i meant, since they appear to be within something shaped like a function `name parens block body`","msgtype":"m.text"},"ts":1590599138000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"since they don't* appear","msgtype":"m.text"},"ts":1590599148000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"I am still leaning towards banning declarations as the last statement in a do, I think","msgtype":"m.text"},"ts":1590599567000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"they are just too surprising","msgtype":"m.text"},"ts":1590599569000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"unless we can change their completion semantics to be less surprising","msgtype":"m.text"},"ts":1590599587000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"I think with destructuring any possible thing is surprising","msgtype":"m.text"},"ts":1590599651000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"would just having it be the RHS really be surprising, even with destructuring?","msgtype":"m.text"},"ts":1590599810000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that's how assignments work (... I hope)","msgtype":"m.text"},"ts":1590599817000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: it can have more than one rhs","msgtype":"m.text"},"ts":1590600975000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"`let a = 1, b = 2`","msgtype":"m.text"},"ts":1590600993000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"eh, `a = 1, b = 2` completes to `2`; seems fine to me to do the same thing when there's a `let` in front of it","msgtype":"m.text"},"ts":1590601552000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and to give `undefined` when there's no initializer, though that one seems not useful (but at least not surprising)","msgtype":"m.text"},"ts":1590601592000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"no initializer on the last declarator, that is","msgtype":"m.text"},"ts":1590601619000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"Bakkot: the debugger statement is also kind odd","msgtype":"m.text"},"ts":1590602012000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"it just returns whatever the host wants","msgtype":"m.text"},"ts":1590602053000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"does anywhere not return undefined?","msgtype":"m.text"},"ts":1590602058000,"senderName":"bradleymeck","senderId":"bradleymeck@irc"},
{"content":{"body":"i don't think so","msgtype":"m.text"},"ts":1590602068000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"Bakkot: you could use `do { throw x }` in default params etc too tho, no?","msgtype":"m.text"},"ts":1590602735000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: does the completion of a try/finally come from the finally if the finally has a `return`?","msgtype":"m.text"},"ts":1590602761000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb re first question: yes, that's the point","msgtype":"m.text"},"ts":1590604126000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"re second question: yes, or a `break`, which is actually relevant because `do { x: try {} finally {0; break x} }` would be legal under the proposal as I intend to propose it","msgtype":"m.text"},"ts":1590604163000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"though, you know, don't write that code","msgtype":"m.text"},"ts":1590604183000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"hard agree","msgtype":"m.text"},"ts":1590604407000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"oh geez I can't believe I hadn't thought about putting function decls in a do block","msgtype":"m.text"},"ts":1590608086000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Bakkot: I think `do {}` has to be undefined though, right? how else can if-without-else work? (and only allowing if-with-else would be uncomfortable...)","msgtype":"m.text"},"ts":1590608179000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"if-without-else has a completion value; it's `undefined`","msgtype":"m.text"},"ts":1590608203000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"`0; if (false) ;` completes to `undefined`, not `0`","msgtype":"m.text"},"ts":1590608213000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"but yeah I think undefined makes sense","msgtype":"m.text"},"ts":1590608232000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"and `0; if (true) ;` ?","msgtype":"m.text"},"ts":1590608238000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"also undefined","msgtype":"m.text"},"ts":1590608243000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"ah k, but `0; if (true) 1;` would be 1?","msgtype":"m.text"},"ts":1590608255000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"indeed","msgtype":"m.text"},"ts":1590608259000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"sgtm","msgtype":"m.text"},"ts":1590608261000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I hadn't thought about that, but yeah, I think requiring that knowledge incurs the trivia cost jorendorff talked about","msgtype":"m.text"},"ts":1590608318000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"probably best for the user to be correct for the wrong reason 😅","msgtype":"m.text"},"ts":1590608341000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"hmm pipeline still needs to be added to the agenda","msgtype":"m.text"},"ts":1590608401000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"hurry up TabAtkins, before it spills into the following meeting XD","msgtype":"m.text"},"ts":1590608420000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"No it's going in the next","msgtype":"m.text"},"ts":1590608491000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"Instead","msgtype":"m.text"},"ts":1590608494000,"senderName":"TabAtkins","senderId":"TabAtkins@irc"},
{"content":{"body":"ohh I misunderstood","msgtype":"m.text"},"ts":1590608501000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"sounded like you had your arguments all in order 😅","msgtype":"m.text"},"ts":1590608515000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I don't actually understand what's being proposed with the spaceship operator thing","msgtype":"m.text"},"ts":1590610007000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"is it dependent upon operator overloading?","msgtype":"m.text"},"ts":1590610028000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: it's going for stage 1, so it's just about solving a problem :-)","msgtype":"m.text"},"ts":1590610119000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rkirsling: but that solution would be `a <=> b` as sugar for `a[Symbol.compare](b)` or similar, which would return 0, a negative number, or a positive number","msgtype":"m.text"},"ts":1590610148000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I see","msgtype":"m.text"},"ts":1590610168000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"rkirsling: the same semantics it has in ruby already","msgtype":"m.text"},"ts":1590610177000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but is that just following the suit of a general operator overloading mechanism in Ruby?","msgtype":"m.text"},"ts":1590610372000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"not that intimately familiar with Ruby but I'm imagining something like `__add__ ` in Python","msgtype":"m.text"},"ts":1590610437000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah looks like it's the same thing except that Ruby allows `<=>` as a function name","msgtype":"m.text"},"ts":1590610769000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"(how very Scala-like)","msgtype":"m.text"},"ts":1590610775000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"well sure, it does just fall out of ruby's overall semantics","msgtype":"m.text"},"ts":1590612650000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but the specific use case is valuable; ie, a generic protocol to compare values","msgtype":"m.text"},"ts":1590612660000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"strings have localeCompare, numbers have subtraction, other types don't have anything","msgtype":"m.text"},"ts":1590612682000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah no I'm not worried about it being a valid problem to solve","msgtype":"m.text"},"ts":1590612722000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I was just confused by what's being proposed, since it'd be weird to have a proposal depend on operator overloading and not be clear about that","msgtype":"m.text"},"ts":1590612789000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"it very much does not","msgtype":"m.text"},"ts":1590612956000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"instanceof already calls into a symbol protocol, as does ==","msgtype":"m.text"},"ts":1590612972000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"this is just another one of those","msgtype":"m.text"},"ts":1590612975000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"`==`?","msgtype":"m.text"},"ts":1590613020000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"doesn't it? with Symbol.toPrimitive?","msgtype":"m.text"},"ts":1590613090000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or maybe only if one of the types is a primitive, i forget","msgtype":"m.text"},"ts":1590613097000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I gotcha","msgtype":"m.text"},"ts":1590613128000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Symbol.parenthesized when","msgtype":"m.text"},"ts":1590613157000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"either way there's precedent with instanceof","msgtype":"m.text"},"ts":1590613166000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"wasn't that more about finding some way to describe instanceof behaviour","msgtype":"m.text"},"ts":1590613187000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"on function instances or something","msgtype":"m.text"},"ts":1590613193000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i don't know the motivation, i know it made an unreliable operator useless :-p","msgtype":"m.text"},"ts":1590613225000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but that's because instanceof is something that often needs to be known robustly; comparison isn't","msgtype":"m.text"},"ts":1590613243000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I actually didn't realize Symbol.hasInstance existed until days ago","msgtype":"m.text"},"ts":1590617544000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"what was the motivation there?","msgtype":"m.text"},"ts":1590617548000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"masochism, presumably","msgtype":"m.text"},"ts":1590618026000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"omg same","msgtype":"m.text"},"ts":1590618140000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"and it's existed for a while too","msgtype":"m.text"},"ts":1590618149000,"senderName":"drousso","senderId":"drousso@irc"},
{"content":{"body":"o.0","msgtype":"m.text"},"ts":1590618152000,"senderName":"drousso","senderId":"drousso@irc"}
]