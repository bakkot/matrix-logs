[
{"content":{"body":"there is not a formal process","msgtype":"m.text"},"ts":1592795366000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"that said, I'd suggest reaching out to the relevant people, including authors and champions, first","msgtype":"m.text"},"ts":1592795384000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"if nothing else to make sure you don't misrepresent their positions","msgtype":"m.text"},"ts":1592795391000,"senderName":"Bakkot","senderId":"Bakkot@irc"},
{"content":{"body":"imo, definitely always ask first before you post about somebody. that said, if someone's championing a proposal they've kind of signed up for their name to be associated with it, so i'd be surprised if that was a problem","msgtype":"m.text"},"ts":1592803410000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"did we want `eval?.(x)` to be considered a direct eval? https://github.com/tc39/test262/pull/2667","msgtype":"m.text"},"ts":1592804307000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"it seems like we could choose to make it indirect","msgtype":"m.text"},"ts":1592804316000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"pretty sure that's a spec bug","msgtype":"m.text"},"ts":1592804702000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"JSC/SM/V8 all have a direct eval and I understood the intention to be \"act as if the ?. weren't there\"","msgtype":"m.text"},"ts":1592804891000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that's what the test is testing","msgtype":"m.text"},"ts":1592804911000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'm asking, should `eval?.()` be an indirect eval instead","msgtype":"m.text"},"ts":1592804920000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"because we want less direct evals, not more","msgtype":"m.text"},"ts":1592804926000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I always have trouble remembering the implication there","msgtype":"m.text"},"ts":1592804962000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"but the point is we're not assigning anything","msgtype":"m.text"},"ts":1592804998000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"sure, but given that `x?.(...a)` arguably desugars to `do { const tmp = x; tmp === null | tmp === undefined ? tmp : tmp(...a) }`, that'd be an indirect eval :-D","msgtype":"m.text"},"ts":1592805138000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"lol lol","msgtype":"m.text"},"ts":1592805282000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"oops","msgtype":"m.text"},"ts":1592805291000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"just meant one lol","msgtype":"m.text"},"ts":1592805296000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I don't think that reflects anyone's actual viewpoint though","msgtype":"m.text"},"ts":1592805412000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the user viewpoint can just think of ?: or && and the AST viewpoint can just wrap the eval call in an optional node","msgtype":"m.text"},"ts":1592805491000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"sure, i get the easy arguments to direct","msgtype":"m.text"},"ts":1592805510000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i'm just wondering if it's a missed opportunity to kill more direct eval calls","msgtype":"m.text"},"ts":1592805521000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I wish we could have avoided the optional call form. This has sailed.","msgtype":"m.text"},"ts":1592806228000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"is it really a web compat issue to change tho?","msgtype":"m.text"},"ts":1592806255000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"It seems reasonable to have it as an indirect eval. I can’t read the specs right now (no computer at Sunday night policy at home)","msgtype":"m.text"},"ts":1592806289000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"What does the spec says today?","msgtype":"m.text"},"ts":1592806311000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"is lazy","msgtype":"m.emote"},"ts":1592806321000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"oh i assume it says it's direct, from that test262 PR, let me check","msgtype":"m.text"},"ts":1592806543000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"\"direct eval\" links to https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation , but it deals with cover grammars and MemberExpression and i can't tell if `?.` is part of that","msgtype":"m.text"},"ts":1592807068000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the test262 PR is saying it's indirect","msgtype":"m.text"},"ts":1592807498000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that's why I said there's a spec bug","msgtype":"m.text"},"ts":1592807505000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"ohhhh ok","msgtype":"m.text"},"ts":1592807511000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i misread the OP then","msgtype":"m.text"},"ts":1592807523000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"indirect seems better to me","msgtype":"m.text"},"ts":1592807531000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah but everybody shipped with the intent of direct is the point","msgtype":"m.text"},"ts":1592807572000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"PR is saying that, but apparently engines disagree. I’ll check the spec tomorrow.","msgtype":"m.text"},"ts":1592807604000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"it's possible Claude did that intentionally and none of us knew what to look for, but","msgtype":"m.text"},"ts":1592807605000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i hope it's an engine bug tbh","msgtype":"m.text"},"ts":1592807631000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I think it's a spec bug either way if everyone read it wrong","msgtype":"m.text"},"ts":1592807660000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"fair","msgtype":"m.text"},"ts":1592807695000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"hmmmmmmmmm","msgtype":"m.text"},"ts":1592807965000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"https://github.com/tc39/proposal-optional-chaining/issues/21","msgtype":"m.text"},"ts":1592807966000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"looks like it's intentional","msgtype":"m.text"},"ts":1592808057000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"never heard of `(0,eval)(foo)` but if \"going out of one's way for indirect eval\" is a thing then I guess that'd give `eval?.()` a reason to exist beyond like, \"it seemed weirder to ban it\" (which was my understanding)","msgtype":"m.text"},"ts":1592808152000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"new forms of direct eval are what should imo be avoided","msgtype":"m.text"},"ts":1592808212000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(`(0,x.y)()` is a common form in babel output for \"don't bring the receiver along\", fwiw)","msgtype":"m.text"},"ts":1592808256000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ah cool","msgtype":"m.text"},"ts":1592808389000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that's good to know","msgtype":"m.text"},"ts":1592808397000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"i also often use it when i don't want nasty ES6 name inferencing breaking my anonymous function test cases","msgtype":"m.text"},"ts":1592808682000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"guess you'll have to apply that to logical assignment too then","msgtype":"m.text"},"ts":1592808752000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"that's too bad","msgtype":"m.text"},"ts":1592808757000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yup","msgtype":"m.text"},"ts":1592808763000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Bakkot: roger that!","msgtype":"m.text"},"ts":1592846756000,"senderName":"howdoi","senderId":"howdoi@irc"},
{"content":{"body":"ljharb rkirsling: ok, reading specs ... I believe it's indirect. I can stress it out with step by step, not to long but can be boring","msgtype":"m.text"},"ts":1592846830000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"thanks, i'd love to understand if you have the time :-)","msgtype":"m.text"},"ts":1592846920000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'm writing it all down","msgtype":"m.text"},"ts":1592848076000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"ljharb: rkirsling https://gist.github.com/leobalter/0b32f73470b134617bed170492cd2089","msgtype":"m.text"},"ts":1592848490000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"please correct me if I'm wrong. It's Monday morning :)","msgtype":"m.text"},"ts":1592848518000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"wouldn't be a monday morning without some discussion of indirect eval","msgtype":"m.text"},"ts":1592848742000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"leobalter: i'm not clear on how you get from EvaluateCall to eval()","msgtype":"m.text"},"ts":1592848895000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: Call() calls eval","msgtype":"m.text"},"ts":1592849021000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"the actual %eval%","msgtype":"m.text"},"ts":1592849030000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"where does the fourth arg to `PerformEval` come from?","msgtype":"m.text"},"ts":1592849101000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"https://tc39.es/ecma262/#sec-eval-x","msgtype":"m.text"},"ts":1592849122000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"EvaluateCall, step 7, the Call will defer to eval, as devsnek mentioned. I just skipped that part but you can go to Call, then F.[[Call]] and https://tc39.es/ecma262/#sec-built-in-function-objects-call-thisargument-argumentslist","msgtype":"m.text"},"ts":1592849262000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"ohh i see","msgtype":"m.text"},"ts":1592849463000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"thanks","msgtype":"m.text"},"ts":1592849464000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"makes sense to me","msgtype":"m.text"},"ts":1592849467000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"https://gc.gy/60554244.png","msgtype":"m.text"},"ts":1592849486000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"classic case of having too much abstraction","msgtype":"m.text"},"ts":1592849502000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"doesn't this mean that babel/ts transforms for optional chaining are incorrect for eval?.()","msgtype":"m.text"},"ts":1592851553000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"i feel like eval?.() should not be indirect eval","msgtype":"m.text"},"ts":1592852396000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"why not","msgtype":"m.text"},"ts":1592852474000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"?","msgtype":"m.text"},"ts":1592852475000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i can see the argument both ways, ofc, but it seems like when either answer makes sense we should pick the one that avoids the bad thing","msgtype":"m.text"},"ts":1592852780000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"because the original motivation was analyzability, and a global `eval?.()` is perfectly analyzable. and a pretty weak simplicity argument: less stuff to remember if the property is \"non-member calls to e-v-a-l\" instead of \"non-member non-optional calls to e-v-a-l-(\"","msgtype":"m.text"},"ts":1592852863000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"the second argument being pretty weak since maybe for some folks just remembering \"e-v-a-l-(\" is the easier thing","msgtype":"m.text"},"ts":1592852883000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"interesting, i didn't know the original motivation","msgtype":"m.text"},"ts":1592852884000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ljharb: it is THE backwards breaking change. without saying indirect eval didn't have access to the local bindings, i honestly think JS wouldn't have taken off the way it has","msgtype":"m.text"},"ts":1592852932000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i mean, i think i get why indirect eval matters","msgtype":"m.text"},"ts":1592852968000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"i didn't think about it in terms of analyzability","msgtype":"m.text"},"ts":1592852979000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"yeah we wouldn't have been able to put bindings on-stack otherwise","msgtype":"m.text"},"ts":1592853093000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"direct eval is big deopt","msgtype":"m.text"},"ts":1592853162000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"shu: in this case we need a normative change. I'm not opposed to any direction we pick. I'd prefer consistency with what web developers expect. And as a web dev, I see `eval?.(x)` as `eval ?? eval(x)`, in the direct form. That's totally debatable.","msgtype":"m.text"},"ts":1592853169000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"leobalter: yeah, i agree we should err towards minimizing surprises for this one","msgtype":"m.text"},"ts":1592853198000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"there're no good first-principles arguments","msgtype":"m.text"},"ts":1592853207000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"i think the whole direct/indirect thing is weird enough that there is no useful rule to follow","msgtype":"m.text"},"ts":1592853215000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"right, i think we can revisionist history to justify either decision equally","msgtype":"m.text"},"ts":1592853232000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"https://gc.gy/60558260.png","msgtype":"m.text"},"ts":1592853262000,"senderName":"devsnek","senderId":"devsnek@irc"},
{"content":{"body":"PRNG has spoken","msgtype":"m.text"},"ts":1592853340000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"but yeah I don't want to implement this unless we're sure","msgtype":"m.text"},"ts":1592853661000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"seeing as we have consistency in what's shipping right now","msgtype":"m.text"},"ts":1592853678000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"it's a little weird to me that SM moved so quickly","msgtype":"m.text"},"ts":1592853691000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"I wonder who is relying on eval today (they do exist, right?) and what they really expect. I'd find odd of anyone relying on the very specific `eval?.(x)` case. The test came in after an implementation for ESLint, so I don't think they care if it's direct eval or not other than for spec consistency.","msgtype":"m.text"},"ts":1592853715000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"I'm fine with whichever we choose","msgtype":"m.text"},"ts":1592853881000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Side note: `eval ?? eval(x)` is incorrect, because it won't eval the RHS","msgtype":"m.text"},"ts":1592853899000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"I think we should add interrobang operator `!?` to do \"RHS if LHS is non-nullish\"","msgtype":"m.text"},"ts":1592853934000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"I can understand an argument for utility if `eval?.()` is easier than `(0,eval)()` but I don't think that implies that it's intuitive","msgtype":"m.text"},"ts":1592854140000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"it's kind of a fancy hack","msgtype":"m.text"},"ts":1592854161000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"yeah i guess i don't really care","msgtype":"m.text"},"ts":1592854218000,"senderName":"shu","senderId":"shu@irc"},
{"content":{"body":"I think the easier option is to make it a direct eval","msgtype":"m.text"},"ts":1592854249000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Because every implementation (except engine262) and transpiler uses direct eval","msgtype":"m.text"},"ts":1592854275000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Ooo, XS does indirect, too.","msgtype":"m.text"},"ts":1592854329000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"yeah I think the reason we all agreed on it was because we were all understanding that the behavior of ?. is meant to be just the behavior without it, when the LHS is non-nullish","msgtype":"m.text"},"ts":1592854342000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"That makes sense to me.","msgtype":"m.text"},"ts":1592854378000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"that was me trying to be smart instead of using &&","msgtype":"m.text"},"ts":1592854395000,"senderName":"leobalter","senderId":"leobalter@irc"},
{"content":{"body":"jridgewell: wait, how is that incorrect","msgtype":"m.text"},"ts":1592854469000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"jridgewell: `x?.(y)` is like `x ?? x(y)`, no? including the short-circuiting?","msgtype":"m.text"},"ts":1592854485000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"(just not including the double evaluation of x)","msgtype":"m.text"},"ts":1592854497000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"no there's no call if you're satisfied with `x`","msgtype":"m.text"},"ts":1592854509000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"`x ?? y` is `x == null ? y : x`","msgtype":"m.text"},"ts":1592854511000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"`x?.()` is `x == null ? undefined : x()`","msgtype":"m.text"},"ts":1592854528000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"So `x ?? x()` is `x == null ? x() : x`","msgtype":"m.text"},"ts":1592854589000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"We invoke a `null`/`undefined`","msgtype":"m.text"},"ts":1592854601000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"oh right, the opposite","msgtype":"m.text"},"ts":1592854613000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"Yah","msgtype":"m.text"},"ts":1592854617000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"so it'd be like `x ‽ x(y)` i guess","msgtype":"m.text"},"ts":1592854623000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"So, interrobang does a not-nullish check, instead of a nullish check.","msgtype":"m.text"},"ts":1592854634000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1592854638000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or &&","msgtype":"m.text"},"ts":1592854656000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"would it be !? or ?! tho","msgtype":"m.text"},"ts":1592854661000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I like it because interrobangs should be a thing","msgtype":"m.text"},"ts":1592854665000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"?. is a more precise &&, ?? is a more precise ||","msgtype":"m.text"},"ts":1592854667000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"And `!?` reads \"not nullish\"","msgtype":"m.text"},"ts":1592854676000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"would you then expect `a!?.b` even tho that be silly since it'd always throw?","msgtype":"m.text"},"ts":1592854699000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"or only as a binary operator","msgtype":"m.text"},"ts":1592854711000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"> ?. is a more precise &&","msgtype":"m.text"},"ts":1592854749000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Only if you mean property access. Doesn't work well for root value","msgtype":"m.text"},"ts":1592854749000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Only the binary operator, `!?.` makes no sense (and is already valid-but-bad typescript code)","msgtype":"m.text"},"ts":1592854777000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"right","msgtype":"m.text"},"ts":1592854791000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"but `??` can be read as \"falls back to\" and to `?.` covers the `&&` guarding usage so","msgtype":"m.text"},"ts":1592854798000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Only if you're doing property access","msgtype":"m.text"},"ts":1592854829000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"I don't think this `!?` would actually be very useful...I think it could really confuse wrt ?.","msgtype":"m.text"},"ts":1592854834000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Babel had a case with private optional","msgtype":"m.text"},"ts":1592854839000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"Where we do `obj == null : undefined : getPrivate(obj)`","msgtype":"m.text"},"ts":1592854870000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"And that can't be represented with either `?.` nor `??`.","msgtype":"m.text"},"ts":1592854885000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"We need interrobang to do it.","msgtype":"m.text"},"ts":1592854893000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"So, `??` is stricter `||` and `!?` is stricter `&&`.","msgtype":"m.text"},"ts":1592854949000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"i don't think ?? is a stricter ||","msgtype":"m.text"},"ts":1592854964000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"stricter || would be \"true or false\" instead of \"truthy or falsy\"","msgtype":"m.text"},"ts":1592854971000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"And `?.` is a special case of `&&` for property access/call","msgtype":"m.text"},"ts":1592854979000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"I'm just saying, this whole tangent started because of a genuine mistake where !? wouldn't have actually been appropriate","msgtype":"m.text"},"ts":1592855025000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"and viewing !? as a solution is dangerous if it's going to confuse people that should be using ?.","msgtype":"m.text"},"ts":1592855061000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"`!?` is the appropriate solution, though.","msgtype":"m.text"},"ts":1592855091000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"`eval !? eval('test')`","msgtype":"m.text"},"ts":1592855103000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"but that code should never be written","msgtype":"m.text"},"ts":1592855148000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"The Babel case needed it, too.","msgtype":"m.text"},"ts":1592855198000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"sure I get that you already came up with it previously for that reason, yeah","msgtype":"m.text"},"ts":1592855228000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"seems like the case you gave could be handled _inside_ the function instead though, and while `!?.` would be nonsensical, `!?=` would be expected, yet of questionable utility","msgtype":"m.text"},"ts":1592857146000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"the issue is that with || and &&, truthy and falsy are on equal footing","msgtype":"m.text"},"ts":1592857167000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"nullish can never be on equal footing with non-nullish because if we could go back and do things over again, we would just have null and not nullish","msgtype":"m.text"},"ts":1592857204000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"so even though ?? and ?. bear similarity with these, there's a baked-in notion of \"falling back\" since it's all about convenient null-guarding and not about two similar buckets","msgtype":"m.text"},"ts":1592857405000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"Hey everyone, let's try to keep technical discussion in #tc39 when possible, so it's publicly accessible","msgtype":"m.text"},"ts":1592860005000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"But this is publicly accessible?","msgtype":"m.text"},"ts":1592860036000,"senderName":"jridgewell","senderId":"jridgewell@irc"},
{"content":{"body":"littledan: this channel is publicly accessible already","msgtype":"m.text"},"ts":1592860039000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"the only place we can't have technical discussions is the reflector.","msgtype":"m.text"},"ts":1592860057000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"I'm not talking about in terms of policy requirements, but we have more non-delegates hanging out in #tc39, since we advertise the existence of #tc39 publicly","msgtype":"m.text"},"ts":1592860092000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"(sorry, my comment was imprecise)","msgtype":"m.text"},"ts":1592860106000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"sure. but sometimes we don't want to have the discussion with non-delegates, and that's what this channel is for","msgtype":"m.text"},"ts":1592860108000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"ok","msgtype":"m.text"},"ts":1592860113000,"senderName":"littledan","senderId":"littledan@irc"},
{"content":{"body":"sometimes it's just inertia over where a topic started","msgtype":"m.text"},"ts":1592860178000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"or like","msgtype":"m.text"},"ts":1592860180000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"if there's multiple topics then our channel count is effectively our thread count","msgtype":"m.text"},"ts":1592860200000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"hehe","msgtype":"m.text"},"ts":1592860205000,"senderName":"rkirsling","senderId":"rkirsling@irc"},
{"content":{"body":"spec question: is it valid to use a spec-List as a `this` argument to a function `Call`? (specifically, the `this` argument of the `adder` in a usage of `AddEntriesFromIterable`. it is mentioned that spec-types should not be used as object properties or variable values, but does that also apply to `this`?","msgtype":"m.text"},"ts":1592864404000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"rickbutton: it's not valid","msgtype":"m.text"},"ts":1592868103000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rickbutton: spec values can't be exposed to user code","msgtype":"m.text"},"ts":1592868109000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"rickbutton: in the AddEntriesToIterable case, you could argue that it's not exposed, but that'd be an editorial question the editors haven't previously had to consider","msgtype":"m.text"},"ts":1592868132000,"senderName":"ljharb","senderId":"ljharb@irc"},
{"content":{"body":"makes sense.","msgtype":"m.text"},"ts":1592868924000,"senderName":"rickbutton","senderId":"rickbutton@irc"},
{"content":{"body":"I don't think I will be able to re-use AddEntriesFromIterable in that case, will have to create a new op. either way its a small amount of spec","msgtype":"m.text"},"ts":1592869060000,"senderName":"rickbutton","senderId":"rickbutton@irc"}
]