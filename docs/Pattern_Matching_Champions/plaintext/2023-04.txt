2023-04-01
[17:05:39.0443] <TabAtkins>
Or the same as an in-progress slides https://docs.google.com/presentation/d/1x5i5nJVwVhbAtQURTCFeezscTNH0Banxgq0_5EgogFY/edit?usp=drivesdk


2023-04-03
[08:01:43.0513] <ljharb>
reminder i'll be a half hour late

[08:03:07.0291] <TabAtkins>
kk

[08:06:17.0599] <rbuckton-pto>
I won't be able to attend today due to moving. 

[10:56:25.0904] <TabAtkins>
Short notes from today's meeting, we discussed my proposal for matchers-everywhere https://hackmd.io/ubn93HPNT2GCjFwNOPzWCA

[11:00:52.0925] <Jack Works>
> Somewhat against the extractor syntax, partially due to Scala experience.

[11:01:21.0171] <Jack Works>
any info of why scala experience is bad?

[11:15:14.0709] <TabAtkins>
ljharb: ^^^

[12:42:32.0021] <ljharb>
i'll flesh out the notes again. but mainly that scala is a mess of syntax that means tons of things in different contexts, and it's very unintuitive to me that you can kind of use constructors as extractors

[12:46:21.0848] <ljharb>
either way it's more that `foo()` syntax imo shouldn't mean anything except invocation, and `foo{}` is just weird

[13:08:45.0954] <mgaudet>
(Could I get permissions for those notes?)

[13:16:19.0082] <TabAtkins>
Anyone with the link has permission, you just need to be signed into hackmd

[13:17:39.0514] <TabAtkins>
re: scala/extractors; I find this syntax fairly appealing here - the constructor/extractor syntax similarity is identical to array/object literals/destructuring.

[13:19:05.0758] <TabAtkins>
So just like how `let x = [1, {foo: 2}]` constructs some object, and `let [a, {foo: b}] = obj;` deconstructs them, `let x = Foo(1, 2)` constructs an object and `let when Foo(bar, baz) = obj;` deconstructs it.

[13:23:38.0070] <TabAtkins>
Also the syntax being more compact *is* pretty compelling for stacked cases: `when Foo(a, Baz(b, c))` vs `when ${Foo} with [a, ${Baz} with [b, c]]`

[13:38:06.0689] <TabAtkins>
Back when I was first reading some Scala code I did find the syntax confusing, because it wasn't clear to me that it *was* basically destructuring, or how it happened, because the unapply methods were created implicitly. (Same with Haskell's similar feature, actually.) But if you have to write them manually in JS I think it's somewhat less of an issue?

[14:05:04.0104] <ljharb>
`let x = Foo(1, 2)` doesn't construct an object tho, necessarily. only `new Foo(1, 2)` does.

[14:05:34.0726] <TabAtkins>
You know what I mean :p

[14:05:39.0639] <TabAtkins>
(worst part of JS syntax imo)

[14:05:56.0110] <ljharb>
i do, but i still think that's a big issue

[14:06:10.0251] <ljharb>
function call syntax isn't exclusively, or even mostly, used for constructing objects

[14:06:34.0620] <TabAtkins>
Sure, but it *is* used for constructing objects.

[14:06:40.0850] <ljharb>
sometimes, sure.

[14:06:50.0062] <ljharb>
but only with `new` is that always the case

[14:07:30.0772] <rbuckton-pto>
Extractors also mirror Rust ADT enum destructuring. 

[14:07:54.0884] <TabAtkins>
I'm not sure what your objection here is. It parallels object creation, but also just function-calling in general. If you have *any* function that takes two arguments and returns something, you can give it a custom matcher that takes the something and pulls it apart into two arguments.

[14:08:22.0881] <rbuckton-pto>
This is a conversation I'd love to spend more time discussing, but thst will have to wait until I'm done with my move ðŸ˜•

[14:08:34.0449] <rbuckton-pto>
* This is a conversation I'd love to spend more time discussing, but that will have to wait until I'm done with my move ðŸ˜•

[14:08:36.0081] <ljharb>
i don't yet have any objection to the need for extractors, but i do object to the two forms of syntax tab showed

[14:08:49.0943] <ljharb>
object creation is done with `{ }`. *instance* creation is done with `new`

[14:09:04.0513] <TabAtkins>
Without this syntax, we already *have* extractors (via interpolation patterns). The syntax is the point.

[14:09:16.0008] <ljharb>
and destructuring of objects is also done with `{ }`. i can't think of anything that would be the inverse of `new` tho

[14:09:20.0878] <ljharb>
> <@tabatkins:matrix.org> Without this syntax, we already *have* extractors (via interpolation patterns). The syntax is the point.

i'm not sure what you mean?

[14:09:43.0365] <TabAtkins>
`when Foo(a, b)` is literally identical to `when ${Foo} with [a, b]`. It's *purely* a syntax sugar.

