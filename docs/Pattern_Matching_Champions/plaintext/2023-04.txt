2023-04-01
[17:05:39.0443] <TabAtkins>
Or the same as an in-progress slides https://docs.google.com/presentation/d/1x5i5nJVwVhbAtQURTCFeezscTNH0Banxgq0_5EgogFY/edit?usp=drivesdk


2023-04-03
[08:01:43.0513] <ljharb>
reminder i'll be a half hour late

[08:03:07.0291] <TabAtkins>
kk

[08:06:17.0599] <rbuckton-pto>
I won't be able to attend today due to moving. 

[10:56:25.0904] <TabAtkins>
Short notes from today's meeting, we discussed my proposal for matchers-everywhere https://hackmd.io/ubn93HPNT2GCjFwNOPzWCA

[11:00:52.0925] <Jack Works>
> Somewhat against the extractor syntax, partially due to Scala experience.

[11:01:21.0171] <Jack Works>
any info of why scala experience is bad?

[11:15:14.0709] <TabAtkins>
ljharb: ^^^

[12:42:32.0021] <ljharb>
i'll flesh out the notes again. but mainly that scala is a mess of syntax that means tons of things in different contexts, and it's very unintuitive to me that you can kind of use constructors as extractors

[12:46:21.0848] <ljharb>
either way it's more that `foo()` syntax imo shouldn't mean anything except invocation, and `foo{}` is just weird

[13:08:45.0954] <mgaudet>
(Could I get permissions for those notes?)

[13:16:19.0082] <TabAtkins>
Anyone with the link has permission, you just need to be signed into hackmd

[13:17:39.0514] <TabAtkins>
re: scala/extractors; I find this syntax fairly appealing here - the constructor/extractor syntax similarity is identical to array/object literals/destructuring.

[13:19:05.0758] <TabAtkins>
So just like how `let x = [1, {foo: 2}]` constructs some object, and `let [a, {foo: b}] = obj;` deconstructs them, `let x = Foo(1, 2)` constructs an object and `let when Foo(bar, baz) = obj;` deconstructs it.

[13:23:38.0070] <TabAtkins>
Also the syntax being more compact *is* pretty compelling for stacked cases: `when Foo(a, Baz(b, c))` vs `when ${Foo} with [a, ${Baz} with [b, c]]`

[13:38:06.0689] <TabAtkins>
Back when I was first reading some Scala code I did find the syntax confusing, because it wasn't clear to me that it *was* basically destructuring, or how it happened, because the unapply methods were created implicitly. (Same with Haskell's similar feature, actually.) But if you have to write them manually in JS I think it's somewhat less of an issue?

[14:05:04.0104] <ljharb>
`let x = Foo(1, 2)` doesn't construct an object tho, necessarily. only `new Foo(1, 2)` does.

[14:05:34.0726] <TabAtkins>
You know what I mean :p

[14:05:39.0639] <TabAtkins>
(worst part of JS syntax imo)

[14:05:56.0110] <ljharb>
i do, but i still think that's a big issue

[14:06:10.0251] <ljharb>
function call syntax isn't exclusively, or even mostly, used for constructing objects

[14:06:34.0620] <TabAtkins>
Sure, but it *is* used for constructing objects.

[14:06:40.0850] <ljharb>
sometimes, sure.

[14:06:50.0062] <ljharb>
but only with `new` is that always the case

[14:07:30.0772] <rbuckton-pto>
Extractors also mirror Rust ADT enum destructuring. 

[14:07:54.0884] <TabAtkins>
I'm not sure what your objection here is. It parallels object creation, but also just function-calling in general. If you have *any* function that takes two arguments and returns something, you can give it a custom matcher that takes the something and pulls it apart into two arguments.

[14:08:22.0881] <rbuckton-pto>
This is a conversation I'd love to spend more time discussing, but thst will have to wait until I'm done with my move ðŸ˜•

[14:08:34.0449] <rbuckton-pto>
* This is a conversation I'd love to spend more time discussing, but that will have to wait until I'm done with my move ðŸ˜•

[14:08:36.0081] <ljharb>
i don't yet have any objection to the need for extractors, but i do object to the two forms of syntax tab showed

[14:08:49.0943] <ljharb>
object creation is done with `{ }`. *instance* creation is done with `new`

[14:09:04.0513] <TabAtkins>
Without this syntax, we already *have* extractors (via interpolation patterns). The syntax is the point.

[14:09:16.0008] <ljharb>
and destructuring of objects is also done with `{ }`. i can't think of anything that would be the inverse of `new` tho

[14:09:20.0878] <ljharb>
> <@tabatkins:matrix.org> Without this syntax, we already *have* extractors (via interpolation patterns). The syntax is the point.

i'm not sure what you mean?

[14:09:43.0365] <TabAtkins>
`when Foo(a, b)` is literally identical to `when ${Foo} with [a, b]`. It's *purely* a syntax sugar.

[14:10:15.0328] <ljharb>
sure, i get that. and i see value in providing sugar for that. but that specific sugar is confusing to me.

[14:10:21.0818] <TabAtkins>
(and, shitpostily: the opposite of "new" is obviously "wen", which we spell "when".)

[14:10:23.0222] <rbuckton-pto>
I'm strongly against interpolation patterns, I don't think they're necessary with the right binding syntax, and they will make patterns a mess. 

[14:11:43.0016] <TabAtkins>
No, interpolations are necessary. `when String()` is *not* identical to `when ${String}`, for instance - the former imposes an addition `with []` constraint.

[14:12:11.0902] <TabAtkins>
Not to mention being able to reference values for value-comparison (without having to rephrase ident patterns, which would break from destructuring).

[14:13:01.0703] <rbuckton-pto>
I disagree that they are necessary. 

[14:14:02.0949] <TabAtkins>
I mean, I just explained why they are. Unless you think it should be *required* that authors handle the return value of a custom matcher, even when they don't need it?

[14:14:18.0114] <rbuckton-pto>
Pattern matching doesn't need to solve every problem, it needs to solve a specific problem well. Interpolation means we failed to solve the specific problem. 

[14:14:34.0234] <TabAtkins>
I don't understand that objection.

[14:14:38.0268] <ljharb>
me neither

[14:14:52.0999] <ljharb>
certainly anything in particular doesn't need to solve every problem, but solving more problems than intended isn't a failure, it's a bonus

[14:15:18.0903] <rbuckton-pto>
I've had a long day. like I said, I will need to circle back to this next week when I'm settled in. 

[14:19:06.0939] <rbuckton-pto>
The gist of what I'm saying is that interpolation makes a very complex syntax infinitely harder to read because you can stuff _anything_ in a pattern. If interpolation is intended to solve a problem, a solution that does not require interpolation will be vastly superior. The only way I would agree to interpolation were for it to be proven it is the only solution to a problem that is worth solving in that design space. I don't think it is. 

[14:19:42.0560] <TabAtkins>
Even if we move binding patterns to a different syntax, so plain idents can invoke custom matchers, we still need the escape hatch of arbitrary-expressions for *getting* the custom matcher. I'm always super wary of any proposal that suggests we can get by solely with dotted/bracketed ident syntax for referring to things; in practice it always means people having to awkwardly write temp variables somewhere else in their code to store the expression, just so they can provide it via a name later.

[14:19:45.0279] <rbuckton-pto>
No other pattern matching syntax in prior art requires interpolation, to my knowledge. 

[14:20:10.0382] <TabAtkins>
Like, `when [a, ${"foo-" + a}]` is a perfectly cromulent thing to want.

[14:20:23.0864] <TabAtkins>
and the `if() pattern similarly allows escaping to arbitrary-expression syntax.

[14:20:43.0237] <rbuckton-pto>
> <@tabatkins:matrix.org> Even if we move binding patterns to a different syntax, so plain idents can invoke custom matchers, we still need the escape hatch of arbitrary-expressions for *getting* the custom matcher. I'm always super wary of any proposal that suggests we can get by solely with dotted/bracketed ident syntax for referring to things; in practice it always means people having to awkwardly write temp variables somewhere else in their code to store the expression, just so they can provide it via a name later.

For something as complex as pattern matching, saving things off to another variable far improves readability. 

[14:21:34.0349] <rbuckton-pto>
> <@tabatkins:matrix.org> Like, `when [a, ${"foo-" + a}]` is a perfectly cromulent thing to want.

You can do that with `if`, which is an acceptable escape hatch

[14:21:40.0334] <TabAtkins>
In both cases, the arbitrary expression is securely wrapped in some sort of brace construct, so it's clear from a parsing perspective, at least, what the boundaries are between "pattern syntax" and "expression syntax". And should be reasonably clear to readers as well, modulo people's ability to write arbitrarily bad code.

[14:22:16.0680] <ljharb>
nb, it is very much a goal that you be able to use a match construct in expression position, which means other variables simply aren't an option we should be requiring for anything

[14:23:51.0431] <TabAtkins>
"`if()` arbitrary expressions are fine, `${}` arbitrary expressions are overly complex" isn't a distinction I can understand right now. 

[14:24:34.0672] <rbuckton-pto>
> <@ljharb:matrix.org> nb, it is very much a goal that you be able to use a match construct in expression position, which means other variables simply aren't an option we should be requiring for anything

This is a complexity bar that is far too high. I'm sure there is no chance I can convince the committee to allow arbitrary expressions in a RegExp, which is the only existing pattern matching syntax in JS. 

[14:24:58.0789] <ljharb>
i'm not sure why it would be too high?

[14:25:06.0752] <ljharb>
regexps are drastically different because they're limited to strings

[14:25:16.0877] <TabAtkins>
And the regex *itself* isn't composable.

[14:25:20.0134] <ljharb>
(also they're famously confusing and easy to create vulnerabilities with, which wouldn't apply here)

[14:25:24.0551] <rbuckton-pto>
> <@tabatkins:matrix.org> "`if()` arbitrary expressions are fine, `${}` arbitrary expressions are overly complex" isn't a distinction I can understand right now. 

`if` in the sense that you can have only one and it comes after the pattern, not in the `if` pattern approach you recently suggested. 

[14:25:43.0344] <rbuckton-pto>
Because it breaks pattern space from normal expression space. 

[14:25:53.0926] <ljharb>
i don't think it's reasonable to think of pattern matching in the same terms as regexps; they're just two different beasts

[14:26:13.0168] <rbuckton-pto>
* `if` in the sense that you can have only one and it comes after the pattern in `match..when`, not in the `if` pattern approach you recently suggested. 

[14:26:17.0051] <TabAtkins>
(Ron, go continue being on vacation. ^_^)

[14:27:00.0820] <rbuckton-pto>
> <@ljharb:matrix.org> i don't think it's reasonable to think of pattern matching in the same terms as regexps; they're just two different beasts

They really aren't, but that's a matter of perspective. 

[14:27:04.0693] <ljharb>
s/vacation/moving, which is nobody's idea of vacation/

[14:27:41.0258] <rbuckton-pto>
True. And my fridge wasn't delivered today, so I'm making do with this for a week

[14:28:14.0948] <TabAtkins>
oof

[14:28:44.0834] <ljharb>
everybody head to ron's for a kegger, bring your own solo cups

[14:29:00.0668] <TabAtkins>
(my point really tho is just that if you don't have time/energy to interact, it's better to stop interacting rather than partially interact and then have to bow out partway thru)

[14:29:35.0210] <rbuckton-pto>
That was, in fact, my eldest's mini fridge from their college dorm last year

[14:33:48.0506] <ljharb>
lol my college mini fridge kept drinks coke outside my parents house for almost 20 years before it broke down, those things are great

[14:37:49.0951] <ljharb>
 * lol my college mini fridge kept drinks cold outside my parents house for almost 20 years before it broke down, those things are great


2023-04-06
[12:10:29.0739] <littledan>
If we switched to Tab's "patterns everywhere" proposal as a baseline, and then debated which subset of it to include in the MVP, I'd be happy

[12:11:03.0863] <littledan>
My <del>toxic trait</del>personal opinion is that all of the contexts for using patterns should be supported.


2023-04-07
[13:06:12.0205] <TabAtkins>
I'm doing some tweaking of the proposal based on the feedback from last meeting + littledan's private feedback, and littledan had a good idea for the binding syntax, I think.

[13:07:39.0986] <TabAtkins>
Jordan wanted the ability to drop matchers into destructuring, using the same syntax as what I'm proposing for function args. This sounds great in general, and it means that the `let` and `for` syntaxes no longer become new additions; they're just destructuring that happens to use the first argument form (`when ...` only, no arg name) for the top-level destructuring pattern.

[13:08:21.0925] <TabAtkins>
So this would mean that adding a matcher to a destructuring pattern like `{a, b: c}` would be spelled like `{a, b: c when ...}`.

[13:09:26.0738] <TabAtkins>
@littledan suggests that we can use that same syntax *in* matchers as the "naming a chunk of the pattern" syntax - `when [a, b when {prop}]: ...;` to bind the first value to `a`, the second to `b`, and additionally test the second value to make sure it has a `.prop` (and bind that value too, while we're at it).

[13:09:38.0857] <TabAtkins>
This sounds pretty good to me; I'm gonna rewrite toward that pattern.


2023-04-10
[13:23:48.0083] <rbuckton>
What are the goals for pattern matching now? It sounds like we're dialing up the complexity of the proposal quite a bit.

[13:25:53.0034] <littledan>
Well, I think if we added a mechanism for naming, and removed `and`, it could reduce confusion. In my opinion, we should be looking at removing quite a number of features of pattern matching from the initial proposal, but "using in all LHS contexts" and "having some kind of mechanism to handle both naming and matching things" are somewhat core/common across languages (the first more than the second; I could do without the second, but I'd prefer that we don't permit a naming construct in only some contexts but not others)

[13:27:42.0801] <rbuckton>
I'm not certain what the proposal even looks like currently, I'm getting caught up now.

[13:28:35.0831] <littledan>
https://gist.github.com/tabatkins/ee6dfe274e81d76b6069c5ed37d3dcbf is what I'm going off of

[13:29:07.0176] <rbuckton>
I'd honestly hoped the syntax I've been suggesting was both simple as well as more than sufficient to cover the proposal goals.

[13:29:23.0229] <littledan>
that gist seems to be taking a "yes and" approach to the feedback received--some of the feedback was about missing expressiveness/features, and this adds those. However, much/most of the feedback was about reducing features

[13:29:29.0106] <littledan>
> <@rbuckton:matrix.org> I'd honestly hoped the syntax I've been suggesting was both simple as well as more than sufficient to cover the proposal goals.

Do you have a writeup of this?

[13:29:59.0909] <rbuckton>
I don't think special syntax is necessary for `if` or `while`. I don't think interpolation is warranted.

[13:30:00.0995] <littledan>
Is this the extractors proposal, or something else?

[13:30:26.0097] <rbuckton>
One moment, I have a meeting.

[13:30:31.0727] <littledan>
hmm, I don't really understand the argument against `if` and `while`--these seem pretty useful to me, and have precedent way back to SNOBOL

[13:30:33.0601] <littledan>
(sorry no rush)

[13:33:07.0889] <rbuckton>
I'm saying that `is` already covers `if` and `while`.

[13:33:14.0892] <rbuckton>
special syntax isn't necessary.

[13:33:48.0856] <littledan>
does `is` allow bindings to be created? I think it's pretty useful to conditionally destructure something.

[13:34:10.0806] <rbuckton>
It does in my version of the syntax.

[13:34:27.0542] <littledan>
interesting, is it written down somewhere?

[13:37:49.0872] <rbuckton>
Bits and pieces, in this channel and on GitHub. I'm working on a more comprehensive writeup.

[13:39:57.0900] <littledan>
great, looking forward

[13:43:47.0654] <rbuckton>
Here's a summary of my preferred syntax:
- `is` expressions (`expr is pattern`)
- `match` expressions
- literal constant patterns (i.e., `1`, `true`, `null`)
- qualified name patterns (i.e., `undefined`, `NaN`, `Infinity`, `Option.Some`, etc.)
- object patterns (i.e., `{ x: 1, y: 2 }`)
- array patterns (i.e., `[1, 2]`)
- `and` patterns (conjunctions)
- `or` patterns (disjunctions)
- `not` patterns (negation)
- `let` (`const`/`var`?) patterns (i.e., `let x`)
- grouping patterns (i.e., `(1 or true)`)
- extractor patterns (i.e., `Foo({ x: 1, y: 2 })`)
- relational patterns (i.e., `>= 0`)

[13:44:26.0316] <rbuckton>
The design is based on C#, Scala, and Rust.

[13:44:58.0260] <rbuckton>
https://gist.github.com/rbuckton/76a0836b799cedcb882fbccdaac57552#ron-bucktons-pattern-matching-with-extractor-objects-epics-proposal has more details, plus a few extras I don't consider to be MVP.

[13:47:02.0502] <rbuckton>
In my proposed syntax, you don't need special syntax for `if` or `while`, because it would be handled by `is` expressions and `let` patterns. A `let` pattern introduces a `let` variable in the current scope. If the pattern matches successfully, the variable is initialized. If the pattern does not match, the variable remains unbound (i.e., stays in TDZ).

[13:47:57.0829] <rbuckton>
So you can easily write:
```js
if (value is Point({ x: let x, y: let y })) {
  console.log(x, y);
}
```
without special syntax for `if`.

[13:48:46.0944] <rbuckton>
You don't need interpolation, because bindings are explicit. Therefore every free identifier in the pattern is an _IdentifierReference_.

[13:49:20.0469] <rbuckton>
However, the syntax is relaxed slightly to allow for qualified names (i.e., `a.b.c`) in addition to regular identifiers, much like _DecoratorMemberExpression_.

[13:50:21.0772] <littledan>
would you allow matching implicitly in assignment expressions, like `[let x, let y] = expr();`

[13:50:47.0481] <littledan>
or that would be done just by `assert(expr() is [let x, let y])`

[13:50:49.0036] <rbuckton>
No. That mixes destructuring with pattern matching.

[13:51:06.0725] <littledan>
Would it work in parameter positions?

[13:51:10.0303] <rbuckton>
Its possible my proposal could be extended to support that in some way, I haven't really looked into it though.

[13:51:46.0026] <rbuckton>
> <@littledan:matrix.org> Would it work in parameter positions?

No, not without special syntax. Parameters already support binding patterns.

[13:52:04.0209] <rbuckton>
I'm also not convinced that makes sense to do.

[13:52:57.0353] <rbuckton>
I'm not entirely a fan of the idea to use patterns to support some kind of function overloading.

[13:54:22.0038] <rbuckton>
the phrase "when you have a hammer, every problem looks like a nail" comes to mind. 

[13:54:52.0437] <littledan>
I'm not talking about function overloading...

[13:55:17.0475] <rbuckton>
You mentioned parameters though

[13:55:41.0878] <littledan>
I guess I'm surprised that my intuition that pattern matching should be supported everywhere where we bind things isn't held so widely by others. I can accept it but I don't understand it yet.

[13:55:54.0447] <littledan>
yeah, this would be purely to fail by throwing

[13:56:05.0124] <rbuckton>
Binding and assignment are definite. They either happen or an error is thrown. Match patterns are conditional.

[13:56:41.0785] <littledan>
it's pretty common across languages to reuse match patterns in this definite mode

[13:58:04.0208] <rbuckton>
The time to do that would have been pre 2015, however. Unless we want to shoehorn pattern matching into destructuring as-is, we already have a "pattern" syntax for assignments and bindings.

[13:58:12.0296] <rbuckton>
 * The time to do that would have been pre 2015, however. Unless we want to shoehorn pattern matching into destructuring as-is, we already have a "pattern" syntax for definite assignments and bindings.

[13:58:38.0806] <rbuckton>
By `as-is`, I mean: `const { x: 10, y } = point;`

[13:58:47.0661] <littledan>
well, I guess Tab's proposal is, you use `when` to switch to the other mode

[13:58:50.0434] <rbuckton>
 * By "as-is", I mean: `const { x: 10, y } = point;`

[13:59:05.0382] <littledan>
definitely unfortunate to have a separate mode

[13:59:14.0254] <rbuckton>
I am not certain we should be flipping back and forth between modes. It will just be confusing.

[13:59:31.0419] <littledan>
I don't really understand what would be more intuitive--to draw an analogy (usable in similar places) or contrast (use in complementary places)

[13:59:56.0767] <rbuckton>
We _could_ extend assignment and binding patterns, if we're willing to give up on some of the promises of pattern matching.

[14:00:21.0561] <littledan>
What I like about the explicit `when` is it makes a contrast clear locally each place pattern matching is used (even if in analogous places).

[14:00:40.0835] <littledan>
> <@rbuckton:matrix.org> We _could_ extend assignment and binding patterns, if we're willing to give up on some of the promises of pattern matching.

What do you mean by this?

[14:00:41.0914] <rbuckton>
I'm not entirely partial to just tacking on a `when` keyword everywhere, either. It doesn't read well.

[14:01:02.0813] <rbuckton>
https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b

[14:01:29.0386] <rbuckton>
If we extend assignment and binding patterns to be the pattern matching mechanism, we lose out on exhaustiveness.

[14:01:51.0545] <rbuckton>
It also doesn't work well with free variables.

[14:02:15.0458] <rbuckton>
i.e., `{ x: Infinity, y } = point` will attempt to overwrite `Infinity` today.

[14:02:24.0969] <rbuckton>
 * i.e., `({ x: Infinity, y } = point)` will attempt to overwrite `Infinity` today.

[14:03:25.0648] <rbuckton>
I use C# as prior art for much of my syntax. C# has destructuring, but pattern matching is separate. 

[14:03:34.0040] <littledan>
Yeah I agree that we can't just extend destructuring to become pattern matching. And we can emphasize the contrast by only allowing them in complementary syntax positions, if we want (possibly with allowances by making a form of extractor available outside patterns too)

[14:03:47.0922] <littledan>
yeah I should study C# more, and your doc looks interesting, will have to read it

[14:03:53.0803] <rbuckton>
In C#, you can do `let (x, y) = (10, 20)`, but not `let (10, y) = (10, 20)`.

[14:05:04.0975] <rbuckton>
In Rust, you can use some patterns in a `let` or `let mut`, but if you actually want conditional patterns, you have to use a `if-let` statement (which is covered by `if..is` in my proposal).

[14:05:51.0748] <rbuckton>
 * In C#, you can do `var (x, y) = (10, 20)`, but not `let (10, y) = (10, 20)`.

[14:06:03.0038] <rbuckton>
 * In C#, you can do `var (x, y) = (10, 20)`, but not `var (10, y) = (10, 20)`.

[14:06:17.0527] <littledan>
OK, I think I'm starting to understand

[14:06:35.0030] <littledan>
do you think extractors could use the same protocol whether used in pattern or destructuring context?

[14:07:09.0526] <rbuckton>
If pattern matching is its own thing, separate from destructuring, then you can define a consistent and pure pattern language that is limited to `is` and `match`.

[14:07:39.0135] <littledan>
huh, pure?

[14:07:47.0108] <rbuckton>
> <@littledan:matrix.org> do you think extractors could use the same protocol whether used in pattern or destructuring context?

Yes. That's what C# and Scala do.

[14:08:13.0598] <rbuckton>
By "pure" I mean not polluted with existing destructuring caveats.

[14:08:27.0253] <rbuckton>
such as exhaustiveness.

[14:09:25.0456] <littledan>
OK, thanks, I think I see what you're getting at. Will need to think on this a bit more.

