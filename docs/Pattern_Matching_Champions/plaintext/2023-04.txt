2023-04-01
[17:05:39.0443] <TabAtkins>
Or the same as an in-progress slides https://docs.google.com/presentation/d/1x5i5nJVwVhbAtQURTCFeezscTNH0Banxgq0_5EgogFY/edit?usp=drivesdk


2023-04-03
[08:01:43.0513] <ljharb>
reminder i'll be a half hour late

[08:03:07.0291] <TabAtkins>
kk

[08:06:17.0599] <rbuckton-pto>
I won't be able to attend today due to moving. 

[10:56:25.0904] <TabAtkins>
Short notes from today's meeting, we discussed my proposal for matchers-everywhere https://hackmd.io/ubn93HPNT2GCjFwNOPzWCA

[11:00:52.0925] <Jack Works>
> Somewhat against the extractor syntax, partially due to Scala experience.

[11:01:21.0171] <Jack Works>
any info of why scala experience is bad?

[11:15:14.0709] <TabAtkins>
ljharb: ^^^

[12:42:32.0021] <ljharb>
i'll flesh out the notes again. but mainly that scala is a mess of syntax that means tons of things in different contexts, and it's very unintuitive to me that you can kind of use constructors as extractors

[12:46:21.0848] <ljharb>
either way it's more that `foo()` syntax imo shouldn't mean anything except invocation, and `foo{}` is just weird

[13:08:45.0954] <mgaudet>
(Could I get permissions for those notes?)

[13:16:19.0082] <TabAtkins>
Anyone with the link has permission, you just need to be signed into hackmd

[13:17:39.0514] <TabAtkins>
re: scala/extractors; I find this syntax fairly appealing here - the constructor/extractor syntax similarity is identical to array/object literals/destructuring.

[13:19:05.0758] <TabAtkins>
So just like how `let x = [1, {foo: 2}]` constructs some object, and `let [a, {foo: b}] = obj;` deconstructs them, `let x = Foo(1, 2)` constructs an object and `let when Foo(bar, baz) = obj;` deconstructs it.

[13:23:38.0070] <TabAtkins>
Also the syntax being more compact *is* pretty compelling for stacked cases: `when Foo(a, Baz(b, c))` vs `when ${Foo} with [a, ${Baz} with [b, c]]`

[13:38:06.0689] <TabAtkins>
Back when I was first reading some Scala code I did find the syntax confusing, because it wasn't clear to me that it *was* basically destructuring, or how it happened, because the unapply methods were created implicitly. (Same with Haskell's similar feature, actually.) But if you have to write them manually in JS I think it's somewhat less of an issue?

