2023-09-01
[20:16:01.0795] <Jack Works>
> <@rbuckton:matrix.org> How does that break that expectation?

tenary does not have a "block" to be scoped

[20:24:23.0006] <rbuckton>
The block would be the block containing the ExpressionStatement, not the expression itself. 

[20:26:35.0392] <rbuckton>
Block scopes are always at the statement level, though `match`/`when` may end up being the lone exception

[05:23:16.0539] <Jack Works>
> <@rbuckton:matrix.org> The block would be the block containing the ExpressionStatement, not the expression itself. 

I think that's even worse

[07:25:36.0700] <rbuckton>
That's the behavior that C# has, so there is precedent

[07:26:22.0297] <rbuckton>
And it's consistent with normal `let`/`const`

[11:41:47.0062] <TabAtkins>
Yeah, I'm not sure I see the confusion, the scopes are exactly the same as normal. The fact that the binding is established in an expression rather than a statement doesn't change anything, in my mind.

[12:05:01.0161] <rbuckton>
We just need to clarify corner cases like parenthesized statement heads in `if`, `switch`, `with`, and `while`. And maybe the expression in `for..of` and `for..in`.

[12:45:03.0991] <TabAtkins>
Yeah, statement heads are the corner case - they're halfway between the outer scope and their inner block scope. But they're already complex in various ways, so that's nothing new.

[15:23:14.0357] <ljharb>
i think statement heads making bindings make sense intuitively. i do not think expressions making bindings make sense.


2023-09-02
[18:03:42.0221] <rbuckton>
> <@ljharb:matrix.org> i think statement heads making bindings make sense intuitively. i do not think expressions making bindings make sense.

I don't think expression-local block scoping makes sense, but I disagree with respect to bindings. Expressions introducing bindings is quite common in many languages, so I don't think it would be difficult to adopt or learn. 

[18:30:15.0128] <ljharb>
other languages aren’t the rubric; either now or eventually, most JS devs have or will have never used another language

[18:49:48.0034] <rbuckton>
I don't find that argument compelling. It assumes JS devs cannot adapt and the language itself cannot evolve. Besides, even JS can introduce bindings in expressions and has been able to do so since it was created. It's just that most often it was unintentional. 

[18:53:57.0630] <rbuckton>
And I'm not arguing that *because X has it, we should have it". I'm arguing that it's a compelling feature with reasonable semantics in many languages that JS also shares other syntax with. It's not a huge leap to adopt the capability, and not difficult to learn or understand. I'm also arguing that it's a feature I've seen requested from several sources, one of which is a noted language designer. It's also a feature that is regularly present in FP style languages and has a long history, and a large part of the JS community uses it for functional programming. 

[18:54:11.0297] <rbuckton>
* And I'm not arguing that "because X has it, we should have it". I'm arguing that it's a compelling feature with reasonable semantics in many languages that JS also shares other syntax with. It's not a huge leap to adopt the capability, and not difficult to learn or understand. I'm also arguing that it's a feature I've seen requested from several sources, one of which is a noted language designer. It's also a feature that is regularly present in FP style languages and has a long history, and a large part of the JS community uses it for functional programming.


2023-09-03
[21:10:04.0372] <ljharb>
i'm not saying that "other languages do it" is an anti-argument. i'm saying it's a very very weak argument.

[21:10:41.0110] <ljharb>
and yes, i do feel that an expression producing a binding would be a wildly surprising, brand new capability in the language, and i can't conceive of what would convince me that that capability is anything short of catastrophic

[21:11:18.0789] <ljharb>
if you're going to say "noted language designer" i'm going to ask what, besides TS, applies - because TS as a language has so many flaws that i don't think that's the "pro" you think it is.

[21:12:14.0757] <ljharb>
eg, does pascal have the ability to produce bindings in expressions? what else does?


2023-09-04
[01:27:24.0336] <mpcsh>
hey y'all, as of this coming week I have reached the end of my hiatus; I'm offline tomorrow (today) for labor day, but expect me to be back going forward!

[01:27:39.0666] <mpcsh>
 * hey y'all, as of this coming week I have reached the end of my hiatus; I'm offline tomorrow (today) for labor day / family visiting, but expect me to be back going forward!

[08:07:35.0573] <ljharb>
thinking about it more, i think we still need the `if` clause in a match expression


2023-09-05
[04:39:17.0965] <Jack Works>
I started to edit spec and found there is something we need to figure out before we continue

[04:40:06.0621] <Jack Works>
the current spec create a new DeclarativeEnvironment for each binding (https://tc39.es/proposal-pattern-matching/#sec-add-match-binding)

[04:41:19.0914] <Jack Works>
to support `for` head, https://tc39.es/ecma262/#sec-createperiterationenvironment, we need to pre-determinate what binding it contains

[04:42:33.0805] <Jack Works>
this brings the question: how is the `let` `const` binding work inside a pattern.

[04:43:37.0502] <Jack Works>
for example, is `[1, let a] or [2, let a]` valid? or is it an early error?

[04:49:03.0500] <Jack Works>
is every level of MatchPattern creates a DeclarationEnvironment?

```
{ // level 1 DeclEnv
    let x,
    y: [ // level 2 DeclEnv
        let x, x
    ]
} // matches { x: 1, y: [2, 3] } and creates binding of x that is value ...?
```

[04:50:51.0644] <Jack Works>
or only the top level MatchPattern creates a DeclarationEnvironment (in this case the previous example gives an early error)?

[04:53:17.0404] <Jack Works>
what's the syntax when it is used in `for...of`?

`for (const x is pattern of expr)`? `for (match pattern of expr)`?

[07:01:07.0907] <rbuckton>
> <@ljharb:matrix.org> eg, does pascal have the ability to produce bindings in expressions? what else does?

Pascal does not, to my knowledge, but there are many languages that support bindings in expressions: C#, F#, LCF, Haskell (LCF derivative), Scheme (LCF derivative), ML (LCF derivative), Python, Clojure, Racket (Scheme derivative), OCaml (ML derivative), Perl, Raku (Perl derivative) PHP, M (aka PowerQuery), and that is not an exhaustive list.

[07:01:59.0089] <rbuckton>
> <@ljharb:matrix.org> and yes, i do feel that an expression producing a binding would be a wildly surprising, brand new capability in the language, and i can't conceive of what would convince me that that capability is anything short of catastrophic

I have a very difficult time believing that something like this would be catastrophic. 

[07:06:22.0659] <rbuckton>
> <@jackworks:matrix.org> for example, is `[1, let a] or [2, let a]` valid? or is it an early error?

In earlier discussions, a pattern could allow multiple declarations of the same binding, such as in different branches of a disjunction. Variables that are not initialized would remain in TDZ. We did not fully describe what would happen in the case where the same declaration was initialized twice. For `let` we could either error or possibly just reassign. For `const` we would probably error (unless maybe we tried to initialize it to the same value).

[07:09:27.0359] <rbuckton>
> <@jackworks:matrix.org> for example, is `[1, let a] or [2, let a]` valid? or is it an early error?

Personally, I would like this to not be an error for the sake of developer convenience, but could see an argument for it not being so. Simple disjunctions like this could be rewritten to `[1 or 2, let a]`, but more complex disjunctions that don't share much of the same shape couldn't be simplified.

[07:12:46.0864] <rbuckton>
> <@jackworks:matrix.org> is every level of MatchPattern creates a DeclarationEnvironment?
> 
> ```
> { // level 1 DeclEnv
>     let x,
>     y: [ // level 2 DeclEnv
>         let x, x
>     ]
> } // matches { x: 1, y: [2, 3] } and creates binding of x that is value ...?
> ```

Why would you create new declarative environments? My assumption was that you would descend into expressions and patterns to look for `let` and `const` bindings in `BoundNames`, and only need to create a single declarative environment for each `when` clause of `match`, or use the current declarative environment for `is`.

[08:01:27.0941] <ljharb>
> <@rbuckton:matrix.org> I have a very difficult time believing that something like this would be catastrophic. 

we can certainly see what the committee thinks, but i’m surprised that you have such different expectations tbh

[08:04:42.0951] <Jack Works>
> <@rbuckton:matrix.org> Why would you create new declarative environments? My assumption was that you would descend into expressions and patterns to look for `let` and `const` bindings in `BoundNames`, and only need to create a single declarative environment for each `when` clause of `match`, or use the current declarative environment for `is`.

we need to decide if `is` can leak variable bindings. it will be a breaking change adding it in the future 

[08:41:56.0115] <rbuckton>
> <@jackworks:matrix.org> we need to decide if `is` can leak variable bindings. it will be a breaking change adding it in the future

My intent with `is` is that the bindings are declared in the nearest block scope, otherwise we would not be able to emulate `if let`/`while let` with `is`, which is one of the key capabilities:

```
if (x is Option.Some(let value)) {
  value;
}

const y = x is Option.Some(let value) ? value + 1 : 0;
```
If the `let` is only visible within the pattern itself, it makes it useless as a destructuring mechanism.

