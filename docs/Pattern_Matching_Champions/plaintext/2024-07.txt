2024-07-08
[07:37:18.0125] <Jack Works>
do we have topic today?

[08:00:57.0251] <rbuckton>
Unsure. I've joined

[08:02:58.0395] <rbuckton>
We could talk about discards, if there's interest

[08:03:08.0280] <ljharb>
i'm here for a half hour


2024-07-10
[08:49:17.0005] <Jack Works>
there is a discussion about pipeline in a group I'm in

[08:51:56.0872] <Jack Works>
they want the function has the ability to know how they're called, normal function? or pipeline? and they want to have different call other in those two cases:

```js
onClick: xxx(prevent(listener)) |> stop |> yyy,
```

I don't know what exact he want, but someone mentioned `new.target`. The function can be aware of that if they're called like `new f()` or `f()`

[08:55:14.0660] <Jack Works>
This reminds me that we can also use Meta property (although I'm not sure if it is a good idea) to behave differently as a custom matcher. for example
```js
function f(x) {
if (function.matches) return function.matches(x.__val__) // { matches: true, value: x.__val__ } ?
return x.__val__
}
```

[08:55:28.0681] <Jack Works>
* This reminds me that we can also use Meta property (although I'm not sure if it is a good idea) to behave differently as a custom matcher. for example
```js
function f(x) {
if (function.matches) return function.matches(x.__val__)
// { matches: true, value: x.__val__ } ?

return x.__val__
}
```

[08:58:55.0381] <ljharb>
it seems like a really bad idea to make functions have different behavior based on what syntax constructs are used to invoke them. a function call is a function call

[09:19:20.0668] <TabAtkins>
Yes, that is def a bad idea imo.

[10:08:56.0461] <Jack Works>
> <@ljharb:matrix.org> it seems like a really bad idea to make functions have different behavior based on what syntax constructs are used to invoke them. a function call is a function call

ok


2024-07-11
[18:07:58.0736] <rbuckton>
Sounds like what they want is F# pipes or the ability to supply tacit unary functions. I still prefer F#-style, tbh, and I think it would have been easier to advance if we'd pushed back on supporting `await` and `yield` (e.g., `(await (x |> y)) |> z`) and just clarified the precedence of `|>` vs. `=>`

