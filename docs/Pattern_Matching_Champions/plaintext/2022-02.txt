2022-02-01
[11:47:40.0118] <TabAtkins>
I'm applying all our resolutions right now, and I'm finally to the binding visibility one, and I have a question.

[11:48:27.0374] <TabAtkins>
So `&`/`|` is simple, as is array patterns; bindings from earlier patterns are visible to later patterns. But what about object matchers?

[11:49:05.0595] <TabAtkins>
Should `{a, b: ${console.log(a)}}` work? If so, I presume `{b: ${console.log(a)}, a}` wouldn't work? Or should neither work?

[11:58:18.0205] <mpcsh>
is both working an option?

[11:59:20.0174] <TabAtkins>
That seems impossible; `{a: ${console.log(b)||"a"}, b: ${console.log(a)||"b"}}` logs what, exactly?

[11:59:31.0646] <mpcsh>
yeah you're right

[12:00:18.0327] <mpcsh>
I'm gonna say we should match destructuring here:
```js
const x = {a: 1, b: 2};
const {a, c = a} = x; // works
const {d = b, b} = x; // doesn't work
```

[12:00:46.0396] <TabAtkins>
that's my preference too, i just hadn't checked what worked yet

[12:00:47.0203] <mpcsh>
(I didn't know those semantics off the top of my head, just worked it out in the console)

[12:00:48.0872] <mpcsh>
 * (I didn't know those semantics off the top of my head, just worked it out in the console)

[12:02:33.0015] <TabAtkins>
Also I don't have a real opinion on this PR, someone else can merge it if they like: https://github.com/tc39/proposal-pattern-matching/pull/237

[12:02:37.0062] <TabAtkins>
 * Also I don't have a real opinion on this PR, someone else can merge it if they like: https://github.com/tc39/proposal-pattern-matching/pull/237

[12:10:41.0580] <rbuckton>
Axel Rauschmayer posted an example of `Option` using classes on twitter a few months ago that looked something like this:
```js
class Option {
  static Some = class extends Option {
    constructor(value) {
      this.value = value;
    }
  };

  static None = class extends Option {
  };
}
```

This effectively encodes the "kind" into the [[Prototype]] and allows you to test whether something is a `Some` or a `None` _and_ whether something is an `Option`

[12:11:14.0968] <TabAtkins>
oh woah, interesting

[12:11:37.0637] <TabAtkins>
that is *exceedingly* clever, phew

[12:11:40.0081] <rbuckton>
My hope is that an engine could optimize a native ADT to reduce polymorphic lookups against the "kind", which is something we don't get today.

[12:13:40.0766] <rbuckton>
> <@tabatkins:matrix.org> rbuckton: Right, the constructor pattern I used just needed *some* value. The null isn't exposed, it could be a 0 or false or undefined instead. It's the second arg that tells whether it's a None or Some.

 * Axel Rauschmayer posted an example of `Option` using classes on twitter a few months ago that looked something like this:
```js
class Option {
  static Some = class extends Option {
    constructor(value) {
      this.value = value;
    }
  };

  static None = class extends Option {
  };
}
```

This effectively encodes the "kind" into the [[Prototype]] and allows you to test whether something is a `Some` or a `None` _and_ whether something is an `Option`

