2022-02-01
[11:47:40.0118] <TabAtkins>
I'm applying all our resolutions right now, and I'm finally to the binding visibility one, and I have a question.

[11:48:27.0374] <TabAtkins>
So `&`/`|` is simple, as is array patterns; bindings from earlier patterns are visible to later patterns. But what about object matchers?

[11:49:05.0595] <TabAtkins>
Should `{a, b: ${console.log(a)}}` work? If so, I presume `{b: ${console.log(a)}, a}` wouldn't work? Or should neither work?

[11:58:18.0205] <mpcsh>
is both working an option?

[11:59:20.0174] <TabAtkins>
That seems impossible; `{a: ${console.log(b)||"a"}, b: ${console.log(a)||"b"}}` logs what, exactly?

[11:59:31.0646] <mpcsh>
yeah you're right

[12:00:18.0327] <mpcsh>
I'm gonna say we should match destructuring here:
```js
const x = {a: 1, b: 2};
const {a, c = a} = x; // works
const {d = b, b} = x; // doesn't work
```

[12:00:46.0396] <TabAtkins>
that's my preference too, i just hadn't checked what worked yet

[12:00:47.0203] <mpcsh>
(I didn't know those semantics off the top of my head, just worked it out in the console)

[12:00:48.0872] <mpcsh>
 * (I didn't know those semantics off the top of my head, just worked it out in the console)

[12:02:33.0015] <TabAtkins>
Also I don't have a real opinion on this PR, someone else can merge it if they like: https://github.com/tc39/proposal-pattern-matching/pull/237

[12:02:37.0062] <TabAtkins>
 * Also I don't have a real opinion on this PR, someone else can merge it if they like: https://github.com/tc39/proposal-pattern-matching/pull/237

[12:10:41.0580] <rbuckton>
Axel Rauschmayer posted an example of `Option` using classes on twitter a few months ago that looked something like this:
```js
class Option {
  static Some = class extends Option {
    constructor(value) {
      this.value = value;
    }
  };

  static None = class extends Option {
  };
}
```

This effectively encodes the "kind" into the [[Prototype]] and allows you to test whether something is a `Some` or a `None` _and_ whether something is an `Option`

[12:11:14.0968] <TabAtkins>
oh woah, interesting

[12:11:37.0637] <TabAtkins>
that is *exceedingly* clever, phew

[12:11:40.0081] <rbuckton>
My hope is that an engine could optimize a native ADT to reduce polymorphic lookups against the "kind", which is something we don't get today.

[12:13:40.0766] <rbuckton>
> <@tabatkins:matrix.org> rbuckton: Right, the constructor pattern I used just needed *some* value. The null isn't exposed, it could be a 0 or false or undefined instead. It's the second arg that tells whether it's a None or Some.

 * Axel Rauschmayer posted an example of `Option` using classes on twitter a few months ago that looked something like this:
```js
class Option {
  static Some = class extends Option {
    constructor(value) {
      this.value = value;
    }
  };

  static None = class extends Option {
  };
}
```

This effectively encodes the "kind" into the [[Prototype]] and allows you to test whether something is a `Some` or a `None` _and_ whether something is an `Option`

[13:45:13.0322] <ljharb>
i like axel's, it's simple. altho i'd do `this.#value = value;` and provide a getter to it rather than a public property.

[13:47:49.0189] <TabAtkins>
Okay, all open issues resolved; we're down to just the new issue opened today (which is pretty weird and I think we'll almost certainly reject, but we're giving the OP time to respond)

[13:48:45.0354] <TabAtkins>
ljharb: Well, if you're not trying to protect Nones from getting assigned, being able to assign to a Some is useful. Otherwise you're forced into using `.map()` to change the value.

[13:49:23.0325] <ljharb>
that seems ideal; immutable instances > > > mutable instances

[13:49:52.0922] <TabAtkins>
lol i'm not getting into that

[13:49:55.0246] <ljharb>
just like a Promise for x is always for x, an Option for x would always be for x

[13:50:03.0881] <TabAtkins>
it is certainly a decision that can be made, and not wrong

[13:50:10.0045] <ljharb>
iow, Options to me are synchronous Promises :-) (a different flavor of burrito)

[13:50:14.0059] <ljharb>
 * iow, Options to me are synchronous Promises :-)

[13:50:24.0157] <ljharb>
 * iow, Options to me are synchronous Promises :-) (a different flavor of burrito_

[13:50:26.0004] <ljharb>
 * iow, Options to me are synchronous Promises :-) (a different flavor of burrito)


2022-02-02
[16:00:44.0787] <rbuckton>
> <@tabatkins:matrix.org> ljharb: Well, if you're not trying to protect Nones from getting assigned, being able to assign to a Some is useful. Otherwise you're forced into using `.map()` to change the value.

A real ADT enum value would be shallowly immutable (at the very least), so the constructors would probably have an `Object.freeze(this)` at the end somewhere anyways.

[16:01:11.0774] <ljharb>
fair, that's another alternative. but frozen objects are weird and unidiomatic, so i wouldn't expect a builtin to do that


2022-02-04
[11:24:18.0657] <TabAtkins>
Does the group feel good about going for Stage 2 at the March meeting? If so, I can start assembling slides. I think the only big thing that should be done before then is updated draft spec text.

[11:24:36.0252] <TabAtkins>
ljharb: You've done the spec text so far - do you think you can update it?

