2022-07-05
[19:10:40.0385] <Jack Works>
should we try to advance to stage 2? next meeting only have 5 days to the deadline

[08:00:48.0533] <ljharb>
that would be great if we have sufficient spec text

[09:06:05.0541] <Jack Works>
> <@jackworks:matrix.org> Missing parts:
> Static Semantics (including early errors, BoundName stuff)
> @@matcher
> Builtin matchers

üëÜ

[09:06:45.0103] <Jack Works>
but I guess built-in matchers will be hard to specify

[09:30:42.0169] <ljharb>
i don't think most of them will be

[09:31:08.0949] <ljharb>
eg, Boolean's matcher is "does it have a [[BooleanData]] internal slot", etc

[09:31:22.0492] <ljharb>
the only one that's tricky will be the error subclasses, because those will be like "has a [[ErrorData]] internal slot, and also "constructor is %TypeError%" or something

[09:31:38.0476] <Jack Works>
brand check is a big topic in tc39

[09:31:49.0650] <ljharb>
we do brand checks all over the place

[09:32:13.0854] <ljharb>
 * the only one that's tricky will be the error subclasses, because those will be like "has a [[ErrorData]] internal slot, and also "constructor is %TypeError%" or something

[09:32:20.0329] <ljharb>
like, a ton of places

[09:39:09.0672] <Jack Works>
Do we have a list of early errors? 

[09:41:26.0076] <ljharb>
"everything that's invalid syntax" :-p i don't think we made a concrete list

[09:59:27.0148] <Jack Works>
> <@ljharb:matrix.org> "everything that's invalid syntax" :-p i don't think we made a concrete list

I mean, for example, the top level identifier pattern can only appear at most once and at the end

[10:00:07.0139] <ljharb>
that's probably one of the few that we're artificially applying (as opposed to, falls out of the syntax)


2022-07-06
[06:52:00.0177] <Jack Works>
üëÄ we only have 3 days until deadline. do we want to advance it?

[07:53:26.0816] <ljharb>
i still say yes :-) what more do we think we need in the spec text for it to be sufficient?

[07:57:52.0088] <Jack Works>
early errors. I think a non-normative list will be enough, we can normatively specify it later.

[09:10:38.0300] <ljharb>
what early errors are there besides the "fake else must be in the else position" one?

[09:14:30.0955] <Jack Works>
> <@ljharb:matrix.org> what early errors are there besides the "fake else must be in the else position" one?

I don't know, this is why I need help üòÇ

[09:15:06.0551] <ljharb>
lol

[09:15:13.0123] <ljharb>
maybe let's just make the list of 1 right now?

[09:15:22.0546] <ljharb>
the spec doesn't have to be perfect, just initial


2022-07-07
[22:47:49.0608] <Jack Works>
Oh I remember

[22:48:02.0216] <Jack Works>
pattern `a | b & c` is an early error

[02:38:37.0678] <Jack Works>
ok I believe the spec is mostly completed

[02:38:46.0616] <Jack Works>
added early errors & built-in matchers

[02:39:03.0330] <Jack Works>
https://tc39.es/proposal-pattern-matching/

[02:56:19.0410] <Jack Works>
The built in matchers are very problematic. I believe it will be a blocker of this proposal. 

[02:57:15.0229] <Jack Works>
Problems:
subclassing Error, Map, Array, Set
Promise
AsyncFunction/AsyncGeneratorFunction

[02:57:46.0044] <Jack Works>
Also, the wrapper object of primitive types

[07:14:11.0869] <ljharb>
subclasses will have the right internal slot

[07:14:20.0761] <ljharb>
as do boxed primitives

[07:14:24.0616] <ljharb>
* as do boxed primitives

[07:14:36.0938] <ljharb>
I‚Äôm not sure why it‚Äôll be difficult; I‚Äôll try to make a PR today

[16:04:51.0519] <ljharb>
k, i've pushed up a bunch of spec fixes; i'm working on the builtin matchers now


2022-07-08
[20:44:56.0556] <ljharb>
i filed https://github.com/tc39/proposal-pattern-matching/pull/263 - i'm going to merge it later this evening if anyone wants to comment in the meantime, and then i'll file the relevant issues and add the agenda item for stage 2. (we can always retract the request later)

[22:22:35.0397] <ljharb>
ok - i've merged that PR, and updated https://github.com/tc39/proposal-pattern-matching/issues/175 to point to the 5 open questions, all of which i consider stage 2 concerns. there's 3 spec TODO comments for me that i'll get to in the coming days. If there's additional TODOs, please file an issue, or, push up an editor's emu-note with a TODO in it.

i've also added "pattern matching for stage 2" to the agenda with a 60 minute timebox, with me to present. Please directly push up a change to the agenda if you'd like to help me present, and please discuss here if the timebox should be longer or shorter.

[22:23:15.0488] <ljharb>
anyone who wants to volunteer to make the slides would also help me out; i'm much better at battledecks then i am at making content :-) (cc mpcsh)

[23:07:29.0811] <Jack Works>
> <@ljharb:matrix.org> i filed https://github.com/tc39/proposal-pattern-matching/pull/263 - i'm going to merge it later this evening if anyone wants to comment in the meantime, and then i'll file the relevant issues and add the agenda item for stage 2. (we can always retract the request later)

I see the new spec it's better!

[23:22:36.0186] <ljharb>
awesome, thanks!

[23:47:23.0123] <Jack Works>
I think we can reuse the slide last presented

[00:15:26.0558] <ljharb>
i was hoping so, with minor edits, and I‚Äôll do that if nobody gives me anything better :-)

[11:15:54.0228] <ljharb>
Jack Works: does https://tc39.es/proposal-pattern-matching/#prod-MatchPropertyList (and MatchElementList) allow for an optional trailing comma?

[11:16:08.0659] <ljharb>
 * Jack Works: does https://tc39.es/proposal-pattern-matching/#prod-MatchPropertyList (and MatchElementList) allow for an optional trailing comma?

[11:25:40.0421] <Jack Works>
> <@ljharb:matrix.org> Jack Works: does https://tc39.es/proposal-pattern-matching/#prod-MatchPropertyList (and MatchElementList) allow for an optional trailing comma?

I copied the spec of deconstructing, so it should be the same

[11:26:03.0977] <Jack Works>
* I copied the spec of deconstructing, so it should be the same

[11:27:56.0102] <ljharb>
hm, k

[11:30:19.0671] <ljharb>
i see the unobservable WeakMap and Set - any reason that's not a Record of Lists?

[11:34:27.0606] <Jack Works>
It's easier to express the semantics. Because I need a prop-value cache which might not be simple to specify using Record/List

[11:43:37.0100] <ljharb>
is SameValue the right cache key to use tho?

[11:43:59.0828] <ljharb>
for properties, it's just strings and symbols, and for iterables, if it yields the same thing twice it should still appear twice

[11:44:58.0217] <ljharb>
i totally get why you'd use a weakmap ofc, just wondering if it'd work almost as easily to use a Record

[11:47:43.0831] <ljharb>
same question with IteratedItems, why an array instead of a List

[11:48:39.0433] <Jack Works>
> <@ljharb:matrix.org> same question with IteratedItems, why an array instead of a List

Because I cannot store a spec list on a ECMAScript object 

[11:50:10.0434] <Jack Works>
And for every matchable it will have its own cache (to keep track of iterable/property access), so (to be stored in a WeakMap) the cache is an ES value too

[11:50:43.0814] <Jack Works>
* And for every matchable it will have its own cache (to keep track of iterable/property access), so (to be stored in a WeakMap) the cache is an ES value too

[11:56:24.0414] <ljharb>
ahh i see, so you want the ES object keyed, and Records can't do that

[11:56:35.0579] <ljharb>
and once you have a weakmap, you can't put spec values there.

[11:56:36.0207] <ljharb>
makes sense

[11:58:19.0492] <Jack Works>
I can make a new ES object with an internal slot that stores Record, but it seems unnecessary since there are already so many ES values

[12:06:49.0244] <ljharb>
yeah i agree

[12:07:03.0600] <ljharb>
a spec Map that can key on ES values would work, but that's also a lot


2022-07-10
[20:39:18.0632] <Jack Works>
https://twitter.com/littledan/status/1545619478385491968

[20:39:34.0453] <Jack Works>
üò• looks like people don't like pattern matching

[09:09:33.0147] <ljharb>
actually seems pretty positive to me

[09:10:05.0138] <ljharb>
naysayers are always the loudest and there‚Äôs very few and ‚Äúoverengineered‚Äù is the worst feedback - which implies they don‚Äôt understand all the use cases :-)


2022-07-11
[19:40:49.0797] <TabAtkins>
Yeah that feedback doesn't look unreasonable. I feel very safe ignoring "overengineered", since we're actually triangulating reasonably well on a minimal (but complete) feature set; that is indeed just people not realizing the use-cases we're trying to hit.

[20:19:01.0218] <rbuckton (PTO: 7/5 - 7/16)>
I'm still unhappy that `${x}` would likely block extractors in the future because of the `id{x}` conflict with `$` as a legal identifier. I'm hoping to present on extractors and the relation to pattern matching and ADT enums in a future TC39, but I'm in the middle of a cross-country move currently so I didn't have much time to prepare anything for next week's plenary. 

[20:23:39.0975] <TabAtkins>
Do you have a link to extractors again? 

[20:24:44.0775] <rbuckton (PTO: 7/5 - 7/16)>
I was thinking about putting together an extractor proposal that just relied on `Symbol.matcher` rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses `with`:
```js
const result = Option.Some{ value: 10 };
const Option.Some{ value } = result; // extractor is dual/inverse of constructor
...
match (result) {
  when Option.Some{ value }: console.log(value); // also dual/inverse here
  when Option.None: console.log("none");
}
```



[20:25:20.0731] <rbuckton (PTO: 7/5 - 7/16)>
I haven't updated it in a bit, but the gist is here: https://gist.github.com/rbuckton/ae46b33f383ba69880c7138c49b5e799

[20:32:40.0595] <rbuckton (PTO: 7/5 - 7/16)>
One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:

```js
enum Message of ADT {
  Quit,
  Move{ x, y },
  Write(message)
}

const msg = Message.Move{ x: 10, y: 10 };
const Message.Move{ x, y } = msg; // ok, declares x and y and initializes values
const Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)

match (msg) {
  when Message.Quit: process.exit();
  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);
  when Message.Write(message): console.log(message); 
}
```

Where the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`

[20:34:09.0983] <rbuckton (PTO: 7/5 - 7/16)>
 * One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:

```js
enum Message of ADT {
  Quit,
  Move{ x, y },
  Write(message)
}

const msg = Message.Move{ x: 10, y: 10 };
const Message.Move{ x, y } = msg; // ok, declares x and y and initializes values
const Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)

match (msg) {
  when Message.Quit: process.exit();
  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);
  when Message.Write(message): console.log(message); 
}
```

Where the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`

[20:37:25.0713] <rbuckton (PTO: 7/5 - 7/16)>
The `id{}` syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:
```js
element.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; 
```

[20:43:22.0757] <rbuckton (PTO: 7/5 - 7/16)>
`${}` doesn't "have" to block `id{}`, since `id {}` could still be legal, but it would be confusing to allow `x{}`, `x {}`, and `$ {}` but not `${}` because of its collision with `${}` in `match`.

[07:59:51.0148] <TabAtkins>
rbuckton (PTO: 7/5 - 7/16): So for extractors, I'm still eh on the {} arglist part even separate from this `${}` conflict. Having a keyword-only constructor seems just as annoying as having the indexed-only constructors we have today. I'd rather pursue a keyword+ arglist syntax, a la Python's.

[07:59:53.0774] <TabAtkins>
But I do see the reason you have it existing - as a parallel to the `{}` destructuring pattern.

[08:02:11.0595] <TabAtkins>
And your nested-extractors example is compelling for why going with something similar to match's `with` syntax isn't great.

[08:03:31.0094] <rbuckton (PTO: 7/5 - 7/16)>
I'm not clear on what you mean by "keyword only constructor"

[08:08:52.0474] <TabAtkins>
`Move{x:1, y:1}` - listed as an enum constructor and possibly a normal-object constructor

[08:12:32.0861] <TabAtkins>
And hm, not *ideal*, but I suppose today's answer for keyword args - just pass an object - would work for extracting too. Just return a single-item array from unapply containing the object.

[08:17:10.0670] <TabAtkins>
`const Message.Move({x, y}) = foo()`, yeah that doesn't look awful to me?

[08:20:33.0770] <Jack Works>
> <@rbuckton:matrix.org> I'm still unhappy that `${x}` would likely block extractors in the future because of the `id{x}` conflict with `$` as a legal identifier. I'm hoping to present on extractors and the relation to pattern matching and ADT enums in a future TC39, but I'm in the middle of a cross-country move currently so I didn't have much time to prepare anything for next week's plenary. 

There is still ThisKindOf(pattern) extractor left for you 

[08:23:25.0807] <rbuckton (PTO: 7/5 - 7/16)>
That just adds more overhead, and potentially overcomplicated the ADT pattern for structured enum members:
```
const msg = Message.Move({ x: 10, y: 10 });
msg[0].x; // 10 

// vs

const msg = Message.Move{x: 10, y: 10 };
msg.x; // 10
```


2022-07-12
[21:27:10.0477] <Jack Works>
I found this part is not correct. Step 7 should not use `?` otherwise it will not close iterators

[09:53:43.0956] <ljharb>
good catch; want to put up a PR to fix it? the grammar stuff is more your domain than mine :-)

[12:07:04.0576] <ljharb>
any reviews on https://github.com/tc39/proposal-pattern-matching/pull/273 ?

[16:35:58.0734] <ljharb>
Jack Works: in addition to the step 7 PR, any chance you'd be able to put up a PR to handle a) adding semicolons between match clauses, and b) to require parens on or/and combinators? (see https://github.com/tc39/proposal-pattern-matching/issues/275#issuecomment-1182580760 ) i'm not entirely sure how to fix it


2022-07-13
[20:51:24.0843] <Jack Works>
that's also hard for me üòÇ

[20:51:30.0432] <ljharb>
lol oops

[20:51:42.0613] <ljharb>
not sure if anyone of the champion group is better at spec grammar

[20:51:57.0487] <ljharb>
i doubt any of this is a stage 2 blocker fwiw, but if we can rush in the fixes before plenary that'll help

[20:52:14.0269] <Jack Works>
I can fix RS problems now

[20:52:20.0271] <ljharb>
awesome

[09:53:42.0925] <ljharb>
TabAtkins: review on https://github.com/tc39/proposal-pattern-matching/pull/273 ? i'd like to land it before making another PR for the "universal subclassing" accomodations


2022-07-14
[11:03:58.0664] <TabAtkins>
FYI: Useful info from pre-meeting among Google folks:

[11:04:42.0222] <TabAtkins>
* Waldemar is hesitant about complexity (no surprise) but won't block since he knows others find it useful. Will very likely bring up specific syntax concerns, which we've been pretty good at addressing.

[11:06:06.0036] <TabAtkins>
Specifically, the "no separator between end of one clause and start of another" bit (third item in his OP of issue 275) is bothering him - I don't think we have any objections to ending clauses with semicolons and allowing ASI to generally make them omittable?

[11:08:10.0719] <TabAtkins>
* Might get pushback on the regex literal matcher. I consider it an important matcher, but not critical - we could drop it if it's required. However, I'd prefer to push back if the complaint comes up; the person who gave the feedback had apparently never written code that was "regexes in an if-else chain", so didn't understand the use-case. Considering that precise use-case was one of the major reasons Python added the `:=` operator, it's *definitely* highly prevalent. Still, this is potentially a topic we can relent on if necessary, imo.

[11:11:27.0752] <TabAtkins>
* Might get pushback on the lack of an automatic instanceof check. This is *extremely* easy to write a custom matcher for (especially with the bool handling now - `static [Symbol.matcher](val) { return val instanceof MyClass; }`), so we've avoided it partly to *appease* people concerned about feature bloat, but this is also a place I think we could relent on if necessary. Either doing it automatically (if the result of the interpolation pattern is a non-primitive without a matcher method, automatically do an instanceof check instead of a === check), or with syntax (`instanceof ${...}` as grammar?).

[11:23:32.0347] <ljharb>
i'm 100% on board with requiring semicolons (and letting ASI fix the error of omitting them)

[11:23:51.0391] <ljharb>
> <@tabatkins:matrix.org> * Might get pushback on the regex literal matcher. I consider it an important matcher, but not critical - we could drop it if it's required. However, I'd prefer to push back if the complaint comes up; the person who gave the feedback had apparently never written code that was "regexes in an if-else chain", so didn't understand the use-case. Considering that precise use-case was one of the major reasons Python added the `:=` operator, it's *definitely* highly prevalent. Still, this is potentially a topic we can relent on if necessary, imo.

i'd love to hear more about this pushback, was it just "doesn't seem useful to me personally"?

[11:23:57.0411] <ljharb>
PR 279 adds that, in a way that's robust for builtins but effectively uses instanceof for userland classes. the current approach there uses a new slot; i'm currently authoring an alternative approach that avoids adding a new slot to every object.

[11:24:15.0603] <ljharb>
> <@tabatkins:matrix.org> * Might get pushback on the lack of an automatic instanceof check. This is *extremely* easy to write a custom matcher for (especially with the bool handling now - `static [Symbol.matcher](val) { return val instanceof MyClass; }`), so we've avoided it partly to *appease* people concerned about feature bloat, but this is also a place I think we could relent on if necessary. Either doing it automatically (if the result of the interpolation pattern is a non-primitive without a matcher method, automatically do an instanceof check instead of a === check), or with syntax (`instanceof ${...}` as grammar?).

 * PR 279 adds that, in a way that's robust for builtins but effectively uses instanceof for userland classes

[11:24:37.0229] <ljharb>
 * PR 279 adds that, in a way that's robust for builtins but effectively uses instanceof for userland classes. the current approach there uses a new slot; i'm currently authoring an alternative approach that avoids adding a new slot to every object.

[11:24:54.0923] <TabAtkins>
Yes, the pushback was generally "this looks like unnecessary complexity and I don't get why it's there"

[11:25:13.0903] <TabAtkins>
and when I gave the example of a chain of if/else with regexes, the response was "i've never seen code that like before"

[11:25:45.0398] <ljharb>
since multiple folks will respond with "i write/read that kind of code all the time", i'm not concerned with that pushback

[11:26:16.0090] <TabAtkins>
yeah, and i'd like to push back with that exact argument, just giving a heads-up and my approval of "yeah we can drop it" if it proves necessary

[11:27:37.0507] <TabAtkins>
Real easy to write a custom matcher for it if it proves necessary, after all. just `function Regex(re){ return val=>({matches:re.test(val), value:re.exec(val)}); }`

[11:28:10.0802] <ljharb>
RegExp.prototype would have one anyways

[11:28:18.0184] <ljharb>
so you'd just `${/whatever/g}`, and you'd have to explicitly name bindings with `with`

[11:28:30.0731] <ljharb>
 * so you'd just `${/whatever/g}`, and you'd have to explicitly name bindings with `with`

[11:29:11.0207] <TabAtkins>
Oh right, we'd just drop that in there since adding those is "free" complexity. ^_^

[11:29:46.0644] <TabAtkins>
Re: 279, ah, I didn't realize that's what you were doing there. So the idea is that'll work for all classes, not just built-ins, automatically doing effectively an instanceof check?

[11:43:28.0733] <ljharb>
yes

[11:43:33.0636] <ljharb>
i just pushed up the latest commit; TAL

[12:22:47.0582] <TabAtkins>
ljharb: I see how the new AO would work to check something is a subclass, but I'm not seeing how it's invoked for arbitrary things, just a number of built-ins. Is there something I'm missing that will make `${Foo}` automatically instanceof-check the matchable to be a Foo or subclass, if there's no matcher manually specified?

[12:30:30.0563] <ljharb>
oh right - that's why i had Object set up this way (cc Jack Works )

[12:30:34.0745] <ljharb>
 * oh right - that's why i had Object set up this way (cc Jack Works )

[12:31:03.0732] <ljharb>
so basically, anything that extends from Object, or any non-primitive-wrapper builtin, will inherit a matcher that will work

[12:31:38.0029] <ljharb>
so if you do `class Foo {}` and then `${Foo}`, it will grab the Object matcher, which (after i update it) will walk the prototype and detect that the instance's `.constructor === Foo`, and return true

[12:31:47.0969] <TabAtkins>
I assumed I'd see something like that, yeah, just didn't see it.

[12:32:26.0497] <ljharb>
it's there in the MatchConstructorInstance AO - note, not in main, in PR 297

[12:32:40.0362] <ljharb>
oh wait, in `class Foo {}`, `Foo` inherits from `Function`, so it will just work as-is (with PR 297)

[12:33:25.0893] <ljharb>
 * it's there in the MatchConstructorInstance AO - note, not in main, in PR 297

[12:33:33.0864] <ljharb>
 * oh wait, in `class Foo {}`, `Foo` inherits from `Function`, so it will just work as-is (with PR 297)

[12:35:09.0664] <TabAtkins>
Yeah, I'm looking at 297. It won't work, because the Function checker still opens with an check for callables, immediately failing if the matchable isn't callable.

