2022-07-05
[19:10:40.0385] <Jack Works>
should we try to advance to stage 2? next meeting only have 5 days to the deadline

[08:00:48.0533] <ljharb>
that would be great if we have sufficient spec text

[09:06:05.0541] <Jack Works>
> <@jackworks:matrix.org> Missing parts:
> Static Semantics (including early errors, BoundName stuff)
> @@matcher
> Builtin matchers

üëÜ

[09:06:45.0103] <Jack Works>
but I guess built-in matchers will be hard to specify

[09:30:42.0169] <ljharb>
i don't think most of them will be

[09:31:08.0949] <ljharb>
eg, Boolean's matcher is "does it have a [[BooleanData]] internal slot", etc

[09:31:22.0492] <ljharb>
the only one that's tricky will be the error subclasses, because those will be like "has a [[ErrorData]] internal slot, and also "constructor is %TypeError%" or something

[09:31:38.0476] <Jack Works>
brand check is a big topic in tc39

[09:31:49.0650] <ljharb>
we do brand checks all over the place

[09:32:13.0854] <ljharb>
 * the only one that's tricky will be the error subclasses, because those will be like "has a [[ErrorData]] internal slot, and also "constructor is %TypeError%" or something

[09:32:20.0329] <ljharb>
like, a ton of places

[09:39:09.0672] <Jack Works>
Do we have a list of early errors? 

[09:41:26.0076] <ljharb>
"everything that's invalid syntax" :-p i don't think we made a concrete list

[09:59:27.0148] <Jack Works>
> <@ljharb:matrix.org> "everything that's invalid syntax" :-p i don't think we made a concrete list

I mean, for example, the top level identifier pattern can only appear at most once and at the end

[10:00:07.0139] <ljharb>
that's probably one of the few that we're artificially applying (as opposed to, falls out of the syntax)


2022-07-06
[06:52:00.0177] <Jack Works>
üëÄ we only have 3 days until deadline. do we want to advance it?

[07:53:26.0816] <ljharb>
i still say yes :-) what more do we think we need in the spec text for it to be sufficient?

[07:57:52.0088] <Jack Works>
early errors. I think a non-normative list will be enough, we can normatively specify it later.

[09:10:38.0300] <ljharb>
what early errors are there besides the "fake else must be in the else position" one?

[09:14:30.0955] <Jack Works>
> <@ljharb:matrix.org> what early errors are there besides the "fake else must be in the else position" one?

I don't know, this is why I need help üòÇ

[09:15:06.0551] <ljharb>
lol

[09:15:13.0123] <ljharb>
maybe let's just make the list of 1 right now?

[09:15:22.0546] <ljharb>
the spec doesn't have to be perfect, just initial


2022-07-07
[22:47:49.0608] <Jack Works>
Oh I remember

[22:48:02.0216] <Jack Works>
pattern `a | b & c` is an early error

[02:38:37.0678] <Jack Works>
ok I believe the spec is mostly completed

[02:38:46.0616] <Jack Works>
added early errors & built-in matchers

[02:39:03.0330] <Jack Works>
https://tc39.es/proposal-pattern-matching/

[02:56:19.0410] <Jack Works>
The built in matchers are very problematic. I believe it will be a blocker of this proposal. 

[02:57:15.0229] <Jack Works>
Problems:
subclassing Error, Map, Array, Set
Promise
AsyncFunction/AsyncGeneratorFunction

[02:57:46.0044] <Jack Works>
Also, the wrapper object of primitive types

[07:14:11.0869] <ljharb>
subclasses will have the right internal slot

[07:14:20.0761] <ljharb>
as do boxed primitives

[07:14:24.0616] <ljharb>
* as do boxed primitives

[07:14:36.0938] <ljharb>
I‚Äôm not sure why it‚Äôll be difficult; I‚Äôll try to make a PR today

[16:04:51.0519] <ljharb>
k, i've pushed up a bunch of spec fixes; i'm working on the builtin matchers now


2022-07-08
[20:44:56.0556] <ljharb>
i filed https://github.com/tc39/proposal-pattern-matching/pull/263 - i'm going to merge it later this evening if anyone wants to comment in the meantime, and then i'll file the relevant issues and add the agenda item for stage 2. (we can always retract the request later)

[22:22:35.0397] <ljharb>
ok - i've merged that PR, and updated https://github.com/tc39/proposal-pattern-matching/issues/175 to point to the 5 open questions, all of which i consider stage 2 concerns. there's 3 spec TODO comments for me that i'll get to in the coming days. If there's additional TODOs, please file an issue, or, push up an editor's emu-note with a TODO in it.

i've also added "pattern matching for stage 2" to the agenda with a 60 minute timebox, with me to present. Please directly push up a change to the agenda if you'd like to help me present, and please discuss here if the timebox should be longer or shorter.

[22:23:15.0488] <ljharb>
anyone who wants to volunteer to make the slides would also help me out; i'm much better at battledecks then i am at making content :-) (cc mpcsh)

[23:07:29.0811] <Jack Works>
> <@ljharb:matrix.org> i filed https://github.com/tc39/proposal-pattern-matching/pull/263 - i'm going to merge it later this evening if anyone wants to comment in the meantime, and then i'll file the relevant issues and add the agenda item for stage 2. (we can always retract the request later)

I see the new spec it's better!

[23:22:36.0186] <ljharb>
awesome, thanks!

[23:47:23.0123] <Jack Works>
I think we can reuse the slide last presented

[00:15:26.0558] <ljharb>
i was hoping so, with minor edits, and I‚Äôll do that if nobody gives me anything better :-)

[11:15:54.0228] <ljharb>
Jack Works: does https://tc39.es/proposal-pattern-matching/#prod-MatchPropertyList (and MatchElementList) allow for an optional trailing comma?

[11:16:08.0659] <ljharb>
 * Jack Works: does https://tc39.es/proposal-pattern-matching/#prod-MatchPropertyList (and MatchElementList) allow for an optional trailing comma?

[11:25:40.0421] <Jack Works>
> <@ljharb:matrix.org> Jack Works: does https://tc39.es/proposal-pattern-matching/#prod-MatchPropertyList (and MatchElementList) allow for an optional trailing comma?

I copied the spec of deconstructing, so it should be the same

[11:26:03.0977] <Jack Works>
* I copied the spec of deconstructing, so it should be the same

[11:27:56.0102] <ljharb>
hm, k

[11:30:19.0671] <ljharb>
i see the unobservable WeakMap and Set - any reason that's not a Record of Lists?

[11:34:27.0606] <Jack Works>
It's easier to express the semantics. Because I need a prop-value cache which might not be simple to specify using Record/List

[11:43:37.0100] <ljharb>
is SameValue the right cache key to use tho?

[11:43:59.0828] <ljharb>
for properties, it's just strings and symbols, and for iterables, if it yields the same thing twice it should still appear twice

[11:44:58.0217] <ljharb>
i totally get why you'd use a weakmap ofc, just wondering if it'd work almost as easily to use a Record

[11:47:43.0831] <ljharb>
same question with IteratedItems, why an array instead of a List

[11:48:39.0433] <Jack Works>
> <@ljharb:matrix.org> same question with IteratedItems, why an array instead of a List

Because I cannot store a spec list on a ECMAScript object 

[11:50:10.0434] <Jack Works>
And for every matchable it will have its own cache (to keep track of iterable/property access), so (to be stored in a WeakMap) the cache is an ES value too

[11:50:43.0814] <Jack Works>
* And for every matchable it will have its own cache (to keep track of iterable/property access), so (to be stored in a WeakMap) the cache is an ES value too

[11:56:24.0414] <ljharb>
ahh i see, so you want the ES object keyed, and Records can't do that

[11:56:35.0579] <ljharb>
and once you have a weakmap, you can't put spec values there.

[11:56:36.0207] <ljharb>
makes sense

[11:58:19.0492] <Jack Works>
I can make a new ES object with an internal slot that stores Record, but it seems unnecessary since there are already so many ES values

[12:06:49.0244] <ljharb>
yeah i agree

[12:07:03.0600] <ljharb>
a spec Map that can key on ES values would work, but that's also a lot


2022-07-10
[20:39:18.0632] <Jack Works>
https://twitter.com/littledan/status/1545619478385491968

[20:39:34.0453] <Jack Works>
üò• looks like people don't like pattern matching

[09:09:33.0147] <ljharb>
actually seems pretty positive to me

[09:10:05.0138] <ljharb>
naysayers are always the loudest and there‚Äôs very few and ‚Äúoverengineered‚Äù is the worst feedback - which implies they don‚Äôt understand all the use cases :-)


2022-07-11
[19:40:49.0797] <TabAtkins>
Yeah that feedback doesn't look unreasonable. I feel very safe ignoring "overengineered", since we're actually triangulating reasonably well on a minimal (but complete) feature set; that is indeed just people not realizing the use-cases we're trying to hit.

[20:19:01.0218] <rbuckton (PTO: 7/5 - 7/16)>
I'm still unhappy that `${x}` would likely block extractors in the future because of the `id{x}` conflict with `$` as a legal identifier. I'm hoping to present on extractors and the relation to pattern matching and ADT enums in a future TC39, but I'm in the middle of a cross-country move currently so I didn't have much time to prepare anything for next week's plenary. 

[20:23:39.0975] <TabAtkins>
Do you have a link to extractors again? 

[20:24:44.0775] <rbuckton (PTO: 7/5 - 7/16)>
I was thinking about putting together an extractor proposal that just relied on `Symbol.matcher` rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses `with`:
```js
const result = Option.Some{ value: 10 };
const Option.Some{ value } = result; // extractor is dual/inverse of constructor
...
match (result) {
  when Option.Some{ value }: console.log(value); // also dual/inverse here
  when Option.None: console.log("none");
}
```



[20:25:20.0731] <rbuckton (PTO: 7/5 - 7/16)>
I haven't updated it in a bit, but the gist is here: https://gist.github.com/rbuckton/ae46b33f383ba69880c7138c49b5e799

[20:32:40.0595] <rbuckton (PTO: 7/5 - 7/16)>
One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:

```js
enum Message of ADT {
  Quit,
  Move{ x, y },
  Write(message)
}

const msg = Message.Move{ x: 10, y: 10 };
const Message.Move{ x, y } = msg; // ok, declares x and y and initializes values
const Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)

match (msg) {
  when Message.Quit: process.exit();
  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);
  when Message.Write(message): console.log(message); 
}
```

Where the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`

[20:34:09.0983] <rbuckton (PTO: 7/5 - 7/16)>
 * One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:

```js
enum Message of ADT {
  Quit,
  Move{ x, y },
  Write(message)
}

const msg = Message.Move{ x: 10, y: 10 };
const Message.Move{ x, y } = msg; // ok, declares x and y and initializes values
const Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)

match (msg) {
  when Message.Quit: process.exit();
  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);
  when Message.Write(message): console.log(message); 
}
```

Where the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`

[20:37:25.0713] <rbuckton (PTO: 7/5 - 7/16)>
The `id{}` syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:
```js
element.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; 
```

[20:43:22.0757] <rbuckton (PTO: 7/5 - 7/16)>
`${}` doesn't "have" to block `id{}`, since `id {}` could still be legal, but it would be confusing to allow `x{}`, `x {}`, and `$ {}` but not `${}` because of its collision with `${}` in `match`.

[07:59:51.0148] <TabAtkins>
rbuckton (PTO: 7/5 - 7/16): So for extractors, I'm still eh on the {} arglist part even separate from this `${}` conflict. Having a keyword-only constructor seems just as annoying as having the indexed-only constructors we have today. I'd rather pursue a keyword+ arglist syntax, a la Python's.

[07:59:53.0774] <TabAtkins>
But I do see the reason you have it existing - as a parallel to the `{}` destructuring pattern.

[08:02:11.0595] <TabAtkins>
And your nested-extractors example is compelling for why going with something similar to match's `with` syntax isn't great.

[08:03:31.0094] <rbuckton (PTO: 7/5 - 7/16)>
I'm not clear on what you mean by "keyword only constructor"

