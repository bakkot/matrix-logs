2022-07-05
[19:10:40.0385] <Jack Works>
should we try to advance to stage 2? next meeting only have 5 days to the deadline

[08:00:48.0533] <ljharb>
that would be great if we have sufficient spec text

[09:06:05.0541] <Jack Works>
> <@jackworks:matrix.org> Missing parts:
> Static Semantics (including early errors, BoundName stuff)
> @@matcher
> Builtin matchers

üëÜ

[09:06:45.0103] <Jack Works>
but I guess built-in matchers will be hard to specify

[09:30:42.0169] <ljharb>
i don't think most of them will be

[09:31:08.0949] <ljharb>
eg, Boolean's matcher is "does it have a [[BooleanData]] internal slot", etc

[09:31:22.0492] <ljharb>
the only one that's tricky will be the error subclasses, because those will be like "has a [[ErrorData]] internal slot, and also "constructor is %TypeError%" or something

[09:31:38.0476] <Jack Works>
brand check is a big topic in tc39

[09:31:49.0650] <ljharb>
we do brand checks all over the place

[09:32:13.0854] <ljharb>
 * the only one that's tricky will be the error subclasses, because those will be like "has a [[ErrorData]] internal slot, and also "constructor is %TypeError%" or something

[09:32:20.0329] <ljharb>
like, a ton of places

[09:39:09.0672] <Jack Works>
Do we have a list of early errors? 

[09:41:26.0076] <ljharb>
"everything that's invalid syntax" :-p i don't think we made a concrete list

[09:59:27.0148] <Jack Works>
> <@ljharb:matrix.org> "everything that's invalid syntax" :-p i don't think we made a concrete list

I mean, for example, the top level identifier pattern can only appear at most once and at the end

[10:00:07.0139] <ljharb>
that's probably one of the few that we're artificially applying (as opposed to, falls out of the syntax)


2022-07-06
[06:52:00.0177] <Jack Works>
üëÄ we only have 3 days until deadline. do we want to advance it?

[07:53:26.0816] <ljharb>
i still say yes :-) what more do we think we need in the spec text for it to be sufficient?

[07:57:52.0088] <Jack Works>
early errors. I think a non-normative list will be enough, we can normatively specify it later.

[09:10:38.0300] <ljharb>
what early errors are there besides the "fake else must be in the else position" one?

[09:14:30.0955] <Jack Works>
> <@ljharb:matrix.org> what early errors are there besides the "fake else must be in the else position" one?

I don't know, this is why I need help üòÇ

[09:15:06.0551] <ljharb>
lol

[09:15:13.0123] <ljharb>
maybe let's just make the list of 1 right now?

[09:15:22.0546] <ljharb>
the spec doesn't have to be perfect, just initial


2022-07-07
[22:47:49.0608] <Jack Works>
Oh I remember

[22:48:02.0216] <Jack Works>
pattern `a | b & c` is an early error

[02:38:37.0678] <Jack Works>
ok I believe the spec is mostly completed

[02:38:46.0616] <Jack Works>
added early errors & built-in matchers

[02:39:03.0330] <Jack Works>
https://tc39.es/proposal-pattern-matching/

[02:56:19.0410] <Jack Works>
The built in matchers are very problematic. I believe it will be a blocker of this proposal. 

[02:57:15.0229] <Jack Works>
Problems:
subclassing Error, Map, Array, Set
Promise
AsyncFunction/AsyncGeneratorFunction

[02:57:46.0044] <Jack Works>
Also, the wrapper object of primitive types

[07:14:11.0869] <ljharb>
subclasses will have the right internal slot

[07:14:20.0761] <ljharb>
as do boxed primitives

[07:14:24.0616] <ljharb>
* as do boxed primitives

[07:14:36.0938] <ljharb>
I‚Äôm not sure why it‚Äôll be difficult; I‚Äôll try to make a PR today

[16:04:51.0519] <ljharb>
k, i've pushed up a bunch of spec fixes; i'm working on the builtin matchers now


2022-07-08
[20:44:56.0556] <ljharb>
i filed https://github.com/tc39/proposal-pattern-matching/pull/263 - i'm going to merge it later this evening if anyone wants to comment in the meantime, and then i'll file the relevant issues and add the agenda item for stage 2. (we can always retract the request later)

[22:22:35.0397] <ljharb>
ok - i've merged that PR, and updated https://github.com/tc39/proposal-pattern-matching/issues/175 to point to the 5 open questions, all of which i consider stage 2 concerns. there's 3 spec TODO comments for me that i'll get to in the coming days. If there's additional TODOs, please file an issue, or, push up an editor's emu-note with a TODO in it.

i've also added "pattern matching for stage 2" to the agenda with a 60 minute timebox, with me to present. Please directly push up a change to the agenda if you'd like to help me present, and please discuss here if the timebox should be longer or shorter.

[22:23:15.0488] <ljharb>
anyone who wants to volunteer to make the slides would also help me out; i'm much better at battledecks then i am at making content :-) (cc mpcsh)

[23:07:29.0811] <Jack Works>
> <@ljharb:matrix.org> i filed https://github.com/tc39/proposal-pattern-matching/pull/263 - i'm going to merge it later this evening if anyone wants to comment in the meantime, and then i'll file the relevant issues and add the agenda item for stage 2. (we can always retract the request later)

I see the new spec it's better!

[23:22:36.0186] <ljharb>
awesome, thanks!

[23:47:23.0123] <Jack Works>
I think we can reuse the slide last presented

[00:15:26.0558] <ljharb>
i was hoping so, with minor edits, and I‚Äôll do that if nobody gives me anything better :-)

[11:15:54.0228] <ljharb>
Jack Works: does https://tc39.es/proposal-pattern-matching/#prod-MatchPropertyList (and MatchElementList) allow for an optional trailing comma?

[11:16:08.0659] <ljharb>
 * Jack Works: does https://tc39.es/proposal-pattern-matching/#prod-MatchPropertyList (and MatchElementList) allow for an optional trailing comma?

[11:25:40.0421] <Jack Works>
> <@ljharb:matrix.org> Jack Works: does https://tc39.es/proposal-pattern-matching/#prod-MatchPropertyList (and MatchElementList) allow for an optional trailing comma?

I copied the spec of deconstructing, so it should be the same

[11:26:03.0977] <Jack Works>
* I copied the spec of deconstructing, so it should be the same

[11:27:56.0102] <ljharb>
hm, k

[11:30:19.0671] <ljharb>
i see the unobservable WeakMap and Set - any reason that's not a Record of Lists?

[11:34:27.0606] <Jack Works>
It's easier to express the semantics. Because I need a prop-value cache which might not be simple to specify using Record/List

[11:43:37.0100] <ljharb>
is SameValue the right cache key to use tho?

[11:43:59.0828] <ljharb>
for properties, it's just strings and symbols, and for iterables, if it yields the same thing twice it should still appear twice

[11:44:58.0217] <ljharb>
i totally get why you'd use a weakmap ofc, just wondering if it'd work almost as easily to use a Record

[11:47:43.0831] <ljharb>
same question with IteratedItems, why an array instead of a List

[11:48:39.0433] <Jack Works>
> <@ljharb:matrix.org> same question with IteratedItems, why an array instead of a List

Because I cannot store a spec list on a ECMAScript object 

[11:50:10.0434] <Jack Works>
And for every matchable it will have its own cache (to keep track of iterable/property access), so (to be stored in a WeakMap) the cache is an ES value too

[11:50:43.0814] <Jack Works>
* And for every matchable it will have its own cache (to keep track of iterable/property access), so (to be stored in a WeakMap) the cache is an ES value too

[11:56:24.0414] <ljharb>
ahh i see, so you want the ES object keyed, and Records can't do that

[11:56:35.0579] <ljharb>
and once you have a weakmap, you can't put spec values there.

[11:56:36.0207] <ljharb>
makes sense

[11:58:19.0492] <Jack Works>
I can make a new ES object with an internal slot that stores Record, but it seems unnecessary since there are already so many ES values

[12:06:49.0244] <ljharb>
yeah i agree

[12:07:03.0600] <ljharb>
a spec Map that can key on ES values would work, but that's also a lot


2022-07-10
[20:39:18.0632] <Jack Works>
https://twitter.com/littledan/status/1545619478385491968

[20:39:34.0453] <Jack Works>
üò• looks like people don't like pattern matching

[09:09:33.0147] <ljharb>
actually seems pretty positive to me

[09:10:05.0138] <ljharb>
naysayers are always the loudest and there‚Äôs very few and ‚Äúoverengineered‚Äù is the worst feedback - which implies they don‚Äôt understand all the use cases :-)


2022-07-11
[19:40:49.0797] <TabAtkins>
Yeah that feedback doesn't look unreasonable. I feel very safe ignoring "overengineered", since we're actually triangulating reasonably well on a minimal (but complete) feature set; that is indeed just people not realizing the use-cases we're trying to hit.

[20:19:01.0218] <rbuckton (PTO: 7/5 - 7/16)>
I'm still unhappy that `${x}` would likely block extractors in the future because of the `id{x}` conflict with `$` as a legal identifier. I'm hoping to present on extractors and the relation to pattern matching and ADT enums in a future TC39, but I'm in the middle of a cross-country move currently so I didn't have much time to prepare anything for next week's plenary. 

[20:23:39.0975] <TabAtkins>
Do you have a link to extractors again? 

[20:24:44.0775] <rbuckton (PTO: 7/5 - 7/16)>
I was thinking about putting together an extractor proposal that just relied on `Symbol.matcher` rather than a separate symbol with a similar purpose. That would allow this syntax instead of the one in the explainer that uses `with`:
```js
const result = Option.Some{ value: 10 };
const Option.Some{ value } = result; // extractor is dual/inverse of constructor
...
match (result) {
  when Option.Some{ value }: console.log(value); // also dual/inverse here
  when Option.None: console.log("none");
}
```



[20:25:20.0731] <rbuckton (PTO: 7/5 - 7/16)>
I haven't updated it in a bit, but the gist is here: https://gist.github.com/rbuckton/ae46b33f383ba69880c7138c49b5e799

[20:32:40.0595] <rbuckton (PTO: 7/5 - 7/16)>
One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:

```js
enum Message of ADT {
  Quit,
  Move{ x, y },
  Write(message)
}

const msg = Message.Move{ x: 10, y: 10 };
const Message.Move{ x, y } = msg; // ok, declares x and y and initializes values
const Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)

match (msg) {
  when Message.Quit: process.exit();
  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);
  when Message.Write(message): console.log(message); 
}
```

Where the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`

[20:34:09.0983] <rbuckton (PTO: 7/5 - 7/16)>
 * One reason for the design sketch for the proposal was to have a common syntax to rely on between ADT enums, destructuring, and pattern matching:

```js
enum Message of ADT {
  Quit,
  Move{ x, y },
  Write(message)
}

const msg = Message.Move{ x: 10, y: 10 };
const Message.Move{ x, y } = msg; // ok, declares x and y and initializes values
const Message.Write(y) = msg; // throws error since x is not a Message.move (i.e., result returned `{ match: false }`)

match (msg) {
  when Message.Quit: process.exit();
  when Message.Move{ x, y }: console.log(`move by x:${x}, y: ${y}`);
  when Message.Write(message): console.log(message); 
}
```

Where the declaration `Move{ x, y }` matches construction `Message.Move{ x: 10, y: 10 }`, destructuring `const Message.Move{x, y} = ...`, and pattern matching: `when Message.Move{ x, y }: ...`

[20:37:25.0713] <rbuckton (PTO: 7/5 - 7/16)>
The `id{}` syntax would also be a useful fit for a general-purpose object construction mechanism (possibly with its own built-in symbol rather than call/construct), so you could potentially have something like:
```js
element.style.border = CSS.Borders{ top: '1px solid black', left: '1px solid black' }; 
```

[20:43:22.0757] <rbuckton (PTO: 7/5 - 7/16)>
`${}` doesn't "have" to block `id{}`, since `id {}` could still be legal, but it would be confusing to allow `x{}`, `x {}`, and `$ {}` but not `${}` because of its collision with `${}` in `match`.

[07:59:51.0148] <TabAtkins>
rbuckton (PTO: 7/5 - 7/16): So for extractors, I'm still eh on the {} arglist part even separate from this `${}` conflict. Having a keyword-only constructor seems just as annoying as having the indexed-only constructors we have today. I'd rather pursue a keyword+ arglist syntax, a la Python's.

[07:59:53.0774] <TabAtkins>
But I do see the reason you have it existing - as a parallel to the `{}` destructuring pattern.

[08:02:11.0595] <TabAtkins>
And your nested-extractors example is compelling for why going with something similar to match's `with` syntax isn't great.

[08:03:31.0094] <rbuckton (PTO: 7/5 - 7/16)>
I'm not clear on what you mean by "keyword only constructor"

[08:08:52.0474] <TabAtkins>
`Move{x:1, y:1}` - listed as an enum constructor and possibly a normal-object constructor

[08:12:32.0861] <TabAtkins>
And hm, not *ideal*, but I suppose today's answer for keyword args - just pass an object - would work for extracting too. Just return a single-item array from unapply containing the object.

[08:17:10.0670] <TabAtkins>
`const Message.Move({x, y}) = foo()`, yeah that doesn't look awful to me?

[08:20:33.0770] <Jack Works>
> <@rbuckton:matrix.org> I'm still unhappy that `${x}` would likely block extractors in the future because of the `id{x}` conflict with `$` as a legal identifier. I'm hoping to present on extractors and the relation to pattern matching and ADT enums in a future TC39, but I'm in the middle of a cross-country move currently so I didn't have much time to prepare anything for next week's plenary. 

There is still ThisKindOf(pattern) extractor left for you 

[08:23:25.0807] <rbuckton (PTO: 7/5 - 7/16)>
That just adds more overhead, and potentially overcomplicated the ADT pattern for structured enum members:
```
const msg = Message.Move({ x: 10, y: 10 });
msg[0].x; // 10 

// vs

const msg = Message.Move{x: 10, y: 10 };
msg.x; // 10
```


2022-07-12
[21:27:10.0477] <Jack Works>
I found this part is not correct. Step 7 should not use `?` otherwise it will not close iterators

[09:53:43.0956] <ljharb>
good catch; want to put up a PR to fix it? the grammar stuff is more your domain than mine :-)

[12:07:04.0576] <ljharb>
any reviews on https://github.com/tc39/proposal-pattern-matching/pull/273 ?

[16:35:58.0734] <ljharb>
Jack Works: in addition to the step 7 PR, any chance you'd be able to put up a PR to handle a) adding semicolons between match clauses, and b) to require parens on or/and combinators? (see https://github.com/tc39/proposal-pattern-matching/issues/275#issuecomment-1182580760 ) i'm not entirely sure how to fix it


2022-07-13
[20:51:24.0843] <Jack Works>
that's also hard for me üòÇ

[20:51:30.0432] <ljharb>
lol oops

[20:51:42.0613] <ljharb>
not sure if anyone of the champion group is better at spec grammar

[20:51:57.0487] <ljharb>
i doubt any of this is a stage 2 blocker fwiw, but if we can rush in the fixes before plenary that'll help

[20:52:14.0269] <Jack Works>
I can fix RS problems now

[20:52:20.0271] <ljharb>
awesome

[09:53:42.0925] <ljharb>
TabAtkins: review on https://github.com/tc39/proposal-pattern-matching/pull/273 ? i'd like to land it before making another PR for the "universal subclassing" accomodations


2022-07-14
[11:03:58.0664] <TabAtkins>
FYI: Useful info from pre-meeting among Google folks:

[11:04:42.0222] <TabAtkins>
* Waldemar is hesitant about complexity (no surprise) but won't block since he knows others find it useful. Will very likely bring up specific syntax concerns, which we've been pretty good at addressing.

[11:06:06.0036] <TabAtkins>
Specifically, the "no separator between end of one clause and start of another" bit (third item in his OP of issue 275) is bothering him - I don't think we have any objections to ending clauses with semicolons and allowing ASI to generally make them omittable?

[11:08:10.0719] <TabAtkins>
* Might get pushback on the regex literal matcher. I consider it an important matcher, but not critical - we could drop it if it's required. However, I'd prefer to push back if the complaint comes up; the person who gave the feedback had apparently never written code that was "regexes in an if-else chain", so didn't understand the use-case. Considering that precise use-case was one of the major reasons Python added the `:=` operator, it's *definitely* highly prevalent. Still, this is potentially a topic we can relent on if necessary, imo.

[11:11:27.0752] <TabAtkins>
* Might get pushback on the lack of an automatic instanceof check. This is *extremely* easy to write a custom matcher for (especially with the bool handling now - `static [Symbol.matcher](val) { return val instanceof MyClass; }`), so we've avoided it partly to *appease* people concerned about feature bloat, but this is also a place I think we could relent on if necessary. Either doing it automatically (if the result of the interpolation pattern is a non-primitive without a matcher method, automatically do an instanceof check instead of a === check), or with syntax (`instanceof ${...}` as grammar?).

[11:23:32.0347] <ljharb>
i'm 100% on board with requiring semicolons (and letting ASI fix the error of omitting them)

[11:23:51.0391] <ljharb>
> <@tabatkins:matrix.org> * Might get pushback on the regex literal matcher. I consider it an important matcher, but not critical - we could drop it if it's required. However, I'd prefer to push back if the complaint comes up; the person who gave the feedback had apparently never written code that was "regexes in an if-else chain", so didn't understand the use-case. Considering that precise use-case was one of the major reasons Python added the `:=` operator, it's *definitely* highly prevalent. Still, this is potentially a topic we can relent on if necessary, imo.

i'd love to hear more about this pushback, was it just "doesn't seem useful to me personally"?

[11:23:57.0411] <ljharb>
PR 279 adds that, in a way that's robust for builtins but effectively uses instanceof for userland classes. the current approach there uses a new slot; i'm currently authoring an alternative approach that avoids adding a new slot to every object.

[11:24:15.0603] <ljharb>
> <@tabatkins:matrix.org> * Might get pushback on the lack of an automatic instanceof check. This is *extremely* easy to write a custom matcher for (especially with the bool handling now - `static [Symbol.matcher](val) { return val instanceof MyClass; }`), so we've avoided it partly to *appease* people concerned about feature bloat, but this is also a place I think we could relent on if necessary. Either doing it automatically (if the result of the interpolation pattern is a non-primitive without a matcher method, automatically do an instanceof check instead of a === check), or with syntax (`instanceof ${...}` as grammar?).

 * PR 279 adds that, in a way that's robust for builtins but effectively uses instanceof for userland classes

[11:24:37.0229] <ljharb>
 * PR 279 adds that, in a way that's robust for builtins but effectively uses instanceof for userland classes. the current approach there uses a new slot; i'm currently authoring an alternative approach that avoids adding a new slot to every object.

[11:24:54.0923] <TabAtkins>
Yes, the pushback was generally "this looks like unnecessary complexity and I don't get why it's there"

[11:25:13.0903] <TabAtkins>
and when I gave the example of a chain of if/else with regexes, the response was "i've never seen code that like before"

[11:25:45.0398] <ljharb>
since multiple folks will respond with "i write/read that kind of code all the time", i'm not concerned with that pushback

[11:26:16.0090] <TabAtkins>
yeah, and i'd like to push back with that exact argument, just giving a heads-up and my approval of "yeah we can drop it" if it proves necessary

[11:27:37.0507] <TabAtkins>
Real easy to write a custom matcher for it if it proves necessary, after all. just `function Regex(re){ return val=>({matches:re.test(val), value:re.exec(val)}); }`

[11:28:10.0802] <ljharb>
RegExp.prototype would have one anyways

[11:28:18.0184] <ljharb>
so you'd just `${/whatever/g}`, and you'd have to explicitly name bindings with `with`

[11:28:30.0731] <ljharb>
 * so you'd just `${/whatever/g}`, and you'd have to explicitly name bindings with `with`

[11:29:11.0207] <TabAtkins>
Oh right, we'd just drop that in there since adding those is "free" complexity. ^_^

[11:29:46.0644] <TabAtkins>
Re: 279, ah, I didn't realize that's what you were doing there. So the idea is that'll work for all classes, not just built-ins, automatically doing effectively an instanceof check?

[11:43:28.0733] <ljharb>
yes

[11:43:33.0636] <ljharb>
i just pushed up the latest commit; TAL

[12:22:47.0582] <TabAtkins>
ljharb: I see how the new AO would work to check something is a subclass, but I'm not seeing how it's invoked for arbitrary things, just a number of built-ins. Is there something I'm missing that will make `${Foo}` automatically instanceof-check the matchable to be a Foo or subclass, if there's no matcher manually specified?

[12:30:30.0563] <ljharb>
oh right - that's why i had Object set up this way (cc Jack Works )

[12:30:34.0745] <ljharb>
 * oh right - that's why i had Object set up this way (cc Jack Works )

[12:31:03.0732] <ljharb>
so basically, anything that extends from Object, or any non-primitive-wrapper builtin, will inherit a matcher that will work

[12:31:38.0029] <ljharb>
so if you do `class Foo {}` and then `${Foo}`, it will grab the Object matcher, which (after i update it) will walk the prototype and detect that the instance's `.constructor === Foo`, and return true

[12:31:47.0969] <TabAtkins>
I assumed I'd see something like that, yeah, just didn't see it.

[12:32:26.0497] <ljharb>
it's there in the MatchConstructorInstance AO - note, not in main, in PR 297

[12:32:40.0362] <ljharb>
oh wait, in `class Foo {}`, `Foo` inherits from `Function`, so it will just work as-is (with PR 297)

[12:33:25.0893] <ljharb>
 * it's there in the MatchConstructorInstance AO - note, not in main, in PR 297

[12:33:33.0864] <ljharb>
 * oh wait, in `class Foo {}`, `Foo` inherits from `Function`, so it will just work as-is (with PR 297)

[12:35:09.0664] <TabAtkins>
Yeah, I'm looking at 297. It won't work, because the Function checker still opens with an check for callables, immediately failing if the matchable isn't callable.

[12:36:13.0332] <ljharb>
oh right, snap

[12:36:15.0226] <ljharb>
hmm

[12:36:24.0737] <ljharb>
class constructors are callable tho

[12:36:31.0150] <ljharb>
they just call into %ThrowTypeError%

[12:36:43.0754] <TabAtkins>
the matchable is what's checked, aka the class instances, not the constructor

[12:36:47.0508] <TabAtkins>
the constructor just holds the matcher

[12:36:51.0655] <ljharb>
oh right

[12:36:53.0871] <ljharb>
hmm

[12:37:08.0307] <ljharb>
ok so that's a tricky thing to figure out then

[12:37:38.0407] <TabAtkins>
Right now, `match(function(){}) { when(${RandomClass}): ...; }` will succeed

[12:38:04.0208] <ljharb>
why? there's no Function.prototype matcher

[12:38:32.0291] <TabAtkins>
Okay so I'm *incredibly* confused now.

[12:38:35.0158] <ljharb>
ohh sorry i get what you mean

[12:42:31.0968] <ljharb>
ok so when a function is a matchable, `${RandomClass}` certainly shouldn't match

[12:42:50.0885] <ljharb>
it should match `Function`, but not "any function"

[12:43:10.0373] <TabAtkins>
Yeah you're right, I was mistaken.

[12:43:30.0015] <TabAtkins>
Oh no, wait, it still will.

[12:43:54.0393] <TabAtkins>
Becuase *one* of the checks if it the matchable (or a prototype) matches the given class, but the *other* is whether the matchable (or a prototype) matches the Function intrinsic.

[12:44:18.0365] <TabAtkins>
which random functions do, afaict

[12:47:26.0147] <TabAtkins>
I suspect what we might want to do instead is make the intrinsic argument optional, and only do the intrinsic check if it's passed, and then *not* pass the Function intrinsic's name in the Function matcher.

[12:47:39.0670] <ljharb>
right, hmm

[12:47:53.0510] <ljharb>
for Function, specifically, that might make sense

[12:47:59.0534] <TabAtkins>
Yes, only for that.

[12:48:05.0236] <ljharb>
altho, hmm

[12:48:08.0851] <ljharb>
wait

[12:48:19.0872] <ljharb>
if the `this` of the matcher is === Function, i think we do want to pass the intrinsic name

[12:48:33.0599] <TabAtkins>
I'd be fine with that, yes.

[12:48:43.0427] <ljharb>
and in that case, we also check callability?

[12:49:07.0111] <ljharb>
but if the `this` is not Function, then we do NOT check callability, and we omit the intrinsic name

[12:49:16.0166] <TabAtkins>
It'd get caught anyway so long as the matchable and the `Function` instance were from the same realm, but I'm fine making it as reliable as the other intrinsics.

[12:49:25.0386] <TabAtkins>
yeah

[12:49:39.0365] <ljharb>
oh right, i could instead of checking SameValue check for "any realm's %Function%"

[12:54:17.0149] <ljharb>
k, updated

[12:56:20.0446] <TabAtkins>
swap the order of the last two lines in the Function matcher, you're omitting/passing the intrinsic in the opposite cases

[12:57:14.0348] <TabAtkins>
otherwise lgtm after that fix

[13:18:03.0389] <TabAtkins>
nm, not lgtm, i dropped a comment with the correct fix.

[13:18:32.0546] <TabAtkins>
(This was the matcher on Function itself, which random classes would *not* inherit. We still need to add a matcher (the generic one) on Function.prototype, instead.)

[14:02:08.0524] <ljharb>
TabAtkins: ok, i think i updated it to do the right thing this time, TAL?

[16:20:56.0053] <mpcsh>
hi friends! sorry I've been so MIA ‚Äî¬†I'm rather underwater right now and need to unbury myself. I'll catch up on the above conversations soon‚Ñ¢Ô∏è.

I had a great conversation today with my colleague Willian Martins, and we discussed his upcoming stage 1 [catch guards](https://github.com/wmsbill/proposal-catch-guards) proposal. at its core, the goal of the proposal is twofold:

1. provide the ability to pattern-match inside what is currently the binding portion of a `catch`
2. provide the ability to _selectively_ catch ‚Äî¬†i.e. without a default case, no error would be caught. this obviates the common "check if we want to catch, then re-throw if not" pattern.

I caught Willian up on the current state of the pattern matching proposal, and we agreed that the best course of action, if you all are on board, is to merge this with pattern matching. our current `catch match` formulation doesn't provide anything beyond saving a level of indentation, but I think we can include Willian's proposal here in a really elegant way. specifically: use `catch match` as the keyword, allow a pattern in the parens, and then have the RHS simply be a `catch` RHS, rather than a `match` statement body. that way, we can pattern-match at what is currently the binding level of a `catch`, we don't have to introduce yet more keywords, and we can introduce the nice short-circuit re-throwing that Willian thought of.

I'll write this up as a PR, but I just wanted to take the temperature of the room. thoughts? TabAtkins ljharb Jack Works yulia danielrosenwasser rkirsling

[16:21:18.0478] <mpcsh>
 * hi friends! sorry I've been so MIA ‚Äî¬†I'm rather underwater right now and need to unbury myself. I'll catch up on the above conversations soon:tm:.

I had a great conversation today with my colleague Willian Martins, and we discussed his upcoming stage 1 [catch guards](https://github.com/wmsbill/proposal-catch-guards) proposal. at its core, the goal of the proposal is twofold:

1. provide the ability to pattern-match inside what is currently the binding portion of a `catch`
2. provide the ability to _selectively_ catch ‚Äî¬†i.e. without a default case, no error would be caught. this obviates the common "check if we want to catch, then re-throw if not" pattern.

I caught Willian up on the current state of the pattern matching proposal, and we agreed that the best course of action, if you all are on board, is to merge this with pattern matching. our current `catch match` formulation doesn't provide anything beyond saving a level of indentation, but I think we can include Willian's proposal here in a really elegant way. specifically: use `catch match` as the keyword, allow a pattern in the parens, and then have the RHS simply be a `catch` RHS, rather than a `match` statement body. that way, we can pattern-match at what is currently the binding level of a `catch`, we don't have to introduce yet more keywords, and we can introduce the nice short-circuit re-throwing that Willian thought of.

I'll write this up as a PR, but I just wanted to take the temperature of the room. thoughts? TabAtkins ljharb Jack Works yulia danielrosenwasser rkirsling

[16:21:26.0679] <mpcsh>
 * hi friends! sorry I've been so MIA ‚Äî¬†I'm rather underwater right now and need to unbury myself. I'll catch up on the above conversations soon‚Ñ¢Ô∏è.

I had a great conversation today with my colleague Willian Martins, and we discussed his upcoming stage 1 [catch guards](https://github.com/wmsbill/proposal-catch-guards) proposal. at its core, the goal of the proposal is twofold:

1. provide the ability to pattern-match inside what is currently the binding portion of a `catch`
2. provide the ability to _selectively_ catch ‚Äî¬†i.e. without a default case, no error would be caught. this obviates the common "check if we want to catch, then re-throw if not" pattern.

I caught Willian up on the current state of the pattern matching proposal, and we agreed that the best course of action, if you all are on board, is to merge this with pattern matching. our current `catch match` formulation doesn't provide anything beyond saving a level of indentation, but I think we can include Willian's proposal here in a really elegant way. specifically: use `catch match` as the keyword, allow a pattern in the parens, and then have the RHS simply be a `catch` RHS, rather than a `match` statement body. that way, we can pattern-match at what is currently the binding level of a `catch`, we don't have to introduce yet more keywords, and we can introduce the nice short-circuit re-throwing that Willian thought of.

I'll write this up as a PR, but I just wanted to take the temperature of the room. thoughts? TabAtkins ljharb Jack Works yulia danielrosenwasser rkirsling

[16:27:15.0906] <ljharb>
I absolutely don‚Äôt think we should merge in catch guards

[16:27:23.0011] <ljharb>
that risks tanking the entire proposal

[16:27:33.0355] <ljharb>
i think it should be a follow on once we‚Äôre at stage 3

[16:28:44.0994] <ljharb>
I‚Äôve also spoken to Willian; i already have been planning such a follow on proposal, and intentionally have been waiting til pattern matching has advanced.

[16:29:59.0514] <rkirsling>
yeah adding more seems like no regardless of anything else

[16:30:04.0129] <rkirsling>
 * yeah adding more seems like a no regardless of anything else

[16:40:48.0397] <TabAtkins>
Yeah no problem as a follow-on, hard reject as a merge-in at this stage.

[16:42:05.0450] <TabAtkins>
ljharb: I don't think we still need the `Function` special-case in the Function.prototype matcher, right? If the interpolation pattern is `${Function}` it'll already be invoking the `Function` matcher, rather than walking up the prototype to get the `Function.prototype` matcher.

[16:42:14.0710] <TabAtkins>
Is there a case I'm missing that makes it still necessary?

[16:42:47.0046] <TabAtkins>
 * ljharb: I don't think we still need the `Function` special-case in the Function.prototype matcher, right? If the interpolation pattern is `${Function}` it'll already be invoking the `Function` matcher, rather than walking up the prototype to get the `Function.prototype` matcher.

[16:44:01.0512] <ljharb>
TabAtkins:  if the matchable is `Function`, it'd hit the Function.prototype matcher, and without the special case, it wouldn't work on cross-realm Function contructors.

[16:44:14.0338] <ljharb>
 * TabAtkins:  if the matchable is `Function`, it'd hit the Function.prototype matcher, and without the special case, it wouldn't work on cross-realm Function contructors.

[16:44:44.0723] <TabAtkins>
Yeah, but that's only if the *pattern* was already something other than `Function`.

[16:44:52.0573] <ljharb>
oh wait right sorry

[16:45:08.0955] <ljharb>
it's so `Function.prototype[Symbol.matcher].call(Function)` does the right thing

[16:45:50.0123] <ljharb>
but also with `match (Function) { when ${function () {}} ‚Ä¶ }`

[16:45:58.0760] <TabAtkins>
But why is that important? The `Function` matcher doesn't live on Function.prototype. It's on Function itself, like any other class.

[16:46:06.0614] <ljharb>
it's a super edge case but there's no reason not to make it work

[16:46:15.0361] <TabAtkins>
We don't expect `MyClass.prototype[Symbol.matcher]` to work in general

[16:46:25.0994] <TabAtkins>
bc it'll be grabbing some matcher completely unrelated to `MyClass`

[16:46:35.0136] <ljharb>
that depends on how it's implemented

[16:46:55.0848] <ljharb>
if MyClass implements its own robust matcher, then it wouldn't work. but it absolutely should work if the matchable is `{ constructor: MyClass }` (with the default function prototype matcher)

[16:47:08.0264] <ljharb>
 * if MyClass implements its own robust matcher, then it wouldn't work. but it absolutely should work if the matchable is `{ constructor: MyClass }` (with the default function prototype matcher)

[16:48:04.0893] <TabAtkins>
That's an accident of implementation, tho, I'd think. It's required that a matchable like that *works*, given the spec we've written, but if we could cleanly avoid it we would.

[16:49:25.0317] <ljharb>
i'll think more on it, but it feels like we need a "base case", and Function is the base

[16:49:48.0360] <ljharb>
specifically because we omit the `*"%Function%"*` intrinsicName, that every other builtin constructor uses

[16:50:01.0724] <ljharb>
ohhh wait i think i thought of one

[16:50:17.0991] <ljharb>
`class F extends Function {}  match (new F()) { when ${Function} ‚Ä¶ }` needs to work

[16:50:27.0651] <ljharb>
and it needs to work even if F's Function is in a different realm

[16:50:47.0334] <ljharb>
and without that special case, it would work in same-realm (because `===`) but not cross-realm

[16:51:22.0994] <ljharb>
or hmm, maybe that's not an issue because as a derived class, F would inherit from Function?

[16:51:55.0635] <TabAtkins>
Yeah, it'll pick up the Function matcher.

[16:52:02.0576] <ljharb>
ok - so maybe we're fine then

[16:52:04.0742] <TabAtkins>
Since you inherit your super's statics

[16:52:18.0604] <ljharb>
hmm

[16:53:03.0226] <ljharb>
alrighty, i'll remove the special handling and i'll just be super thorough with test cases :-)

[16:53:22.0439] <TabAtkins>
kk ^_^


2022-07-15
[09:56:55.0481] <TabAtkins>
r+ on the latest version of 279, looks good to me now

[11:00:58.0616] <ljharb>
i'd love to get everyone's opinion in the champion group on 279 as well as 278, ideally before plenary next week (mpcsh danielrosenwasser yulia rkirsling Jack Works )

[11:01:52.0326] <ljharb>
 * i'd love to get everyone's opinion in the champion group on 279 as well as 278, ideally before plenary next week (mpcsh danielrosenwasser yulia rkirsling Jack Works )

[11:02:48.0671] <yulia>
Folks -- i will have to sadly step away as a champion

[11:03:12.0362] <yulia>
I don't have the time to fully dedicate to the proposal, and in its current shape i consider it to be too complex and trying to do too many things

[11:03:33.0655] <yulia>
i have had that concern for a long time, ive tried to raise it but it didn't feel like i could represent that accurately, so i am not longer really a champion in practice anyway

[11:11:28.0864] <TabAtkins>
yulia: Respect your decision, but I would still be interested in learning more about the "too complex" - I know you had that complaint earlier, but I've not been able to fully understand it, given the similarity in complexity (imo) to the corresponding constructs in many other languages.

[11:12:17.0020] <yulia>
I've just gotten out of a lot of meetings and im freshly back from having covid so im not sure ill be able to articulate it well now either

[11:12:31.0158] <yulia>
but: i don't think that the complexity in other languages warrents such a complex initial design

[11:13:39.0781] <yulia>
we should consider how to break up the proposal into smaller steps -- the argument has been "its all or nothing" and i disagree. This can have great improvements to JS if we do it in parts

[11:15:48.0091] <TabAtkins>
Yeah, no pressure right now, but I'd love to hear some more detailed articulation of your feelings, because we've heard "too complex" and I can't reasonably respond to it at that level (since I think it's not).

[11:25:46.0024] <TabAtkins>
To be a little more specific, I don't believe the proposal *can* in any meaningful way be broken up into smaller steps. You need the match() construct itself, and at least *most* of the match patterns, to have a useful feature. In theory we can boot a few bits to extension proposals, but in practice that would just draw out the feature's definition without actually reducing anything, since I feel they have very strong arguments for inclusion.

[11:26:27.0622] <TabAtkins>
I'm curious if the "smaller steps" is along the lines of "do less interpolation patterns in teh base proposal" or something more radical in cleaving the proposal into smaller pieces?

[12:43:15.0620] <yulia>
Let me come up with a clear realistic statement and bring it to you Monday. 

[13:13:20.0291] <rkirsling>
I do share Yulia's general sentiment but I agree that it's not concrete enough to be actionable so lemme give this a good think this afternoon too

[13:23:20.0109] <yulia>
I have a concrete suggestion, I want time to think of how to convert it properly

[13:30:58.0673] <yulia>
* I think I have a concrete suggestion, I want time to think of how to describe it properly

[13:54:54.0335] <TabAtkins>
Excellent thanks y'all

[13:55:07.0557] <TabAtkins>
(btw I'll be on vacation next week so I'm missing the meeting unfortunately, but I'll follow up)

