2024-09-03
[08:27:15.0126] <TabAtkins>
@room augh, I ended up with too much on my plate at the tail end of last week and am not ready for this meeting. I'm so sorry but gotta cancel, do y'all have availability later in the week? Or else next Monday?

[08:33:09.0312] <ljharb>
i can do the same time on friday

[08:42:53.0546] <Jack Works>
I also want to sleep early tonight üëÄ

[08:48:15.0727] <rbuckton>
I can also do Friday at the same time, or next Monday

[08:48:40.0951] <Jack Works>
if it can be 1 hr earlier that will be great 

[08:50:45.0035] <ljharb>
i can't do any earlier unfortunately, i have to drop my kids off at school

[08:50:59.0337] <ljharb>
why don't i move it to friday, and we can reschedule further if needed


2024-09-06
[08:37:02.0656] <TabAtkins>
Sorry, I clicked Yes on the invite but didn't actually ping the room - yeah, this morning is great.

[09:05:44.0699] <TabAtkins>
@room just in case anyone else is joining, meeting is starting now

[09:06:00.0475] <TabAtkins>
@room just in case anyone else is joing, meeting is starting now

[09:43:35.0901] <TabAtkins>
meeting notes: https://github.com/tc39/proposal-pattern-matching/issues/332

[10:01:34.0253] <rbuckton>
Regarding the contextual keyword issue, it's not that having both prefix and infix contextual keywords is impossible, but that they introduce complexity that must be managed, and that complexity could easily grow out of control. When new syntax would introduce an ambiguous parse, we must always choose an approach that favors backwards compatibility. 

Given the example:
```
for (using is of and [not/a+"/g]; b++; [/"/g, 5])
```

We would have to break down the grammar to align with ECMAScript syntax roll-out:
- `for..of` shipped before `using`
- `using` will probably ship before `is`

Prior to pattern matching, the above parse would treat `is` as an identifier and `and [not/a+"/g]; b++; [/"/g, 5]` as an expression. Therefore we would need to maintain that behavior. As waldemar points out, this is a complex issue that will resurface each time a proposal seeks to add a new feature. Unfortunately, I don't think just choosing `~=` is a solution to the overarching problem. There are a limited set of punctuators, and combining punctuators in more and more obscure ways will do little to convey their meaning, whereas contextual keywords give us a far wider space for future proposals to leverage. IMO, finding solutions to make it easier to address the prefix/infix complexity, such as automated validators, may be worth pursuing.

[10:26:25.0333] <TabAtkins>
I'm still giggling over the fact that `for(of of of)` is valid today.

[10:26:43.0987] <TabAtkins>
```js
var of = [1,2,3];
for(of of of) console.log(of);
```

[12:19:51.0187] <ljharb>
personally i think we won't be adding so many keywords of either type that the complexity is a problem

[12:46:33.0986] <TabAtkins>
The issue isn't convincing you, tho, it's convincing the committee.

[13:39:47.0084] <ljharb>
very true. but i'm hoping that "there's a list of ~10 exceptions" complies with the priorities of constituencies stuff given that it makes the language better, is convincing


2024-09-16
[08:03:48.0367] <Jack Works>
do we have meeting today 

[08:13:52.0917] <rbuckton>
It seems like no?

[11:05:50.0404] <ljharb>
I‚Äôm on a plane, so i couldn‚Äôt attend


2024-09-24
[09:06:48.0389] <ljharb>
TabAtkins: any update on slides?

[09:23:41.0531] <TabAtkins>
Not yet, but I have free time this afternoon at TPAC, I'll bang them out.

[09:52:36.0278] <ljharb>
awesome, that'd be great. agenda deadline is in 2-3 days

[09:52:46.0734] <ljharb>
 * awesome, that'd be great. agenda deadline is in 2-3 days, and we should all review them before we add advancement to the agenda

[10:26:51.0683] <TabAtkins>
yeah, np

[14:02:31.0788] <TabAtkins>
Did we end up deciding one way or the other on whether we're keeping the `when` prefix or just dropping it?


2024-09-25
[17:46:33.0609] <rbuckton>
My preference was to drop it, I'm not sure where others stand

[18:06:43.0374] <TabAtkins>
aight, first draft is https://docs.google.com/presentation/d/1ckdNcRpzMB7oV91k98gNkXxVtwkzqIv0vALPffSaU44/edit?usp=sharing

[18:06:50.0822] <TabAtkins>
i'm assuming "no `when`"

[18:12:22.0989] <rkirsling>
new slogan: "no when, no how"

[21:25:13.0432] <ljharb>
my strong preference is to keep it

[21:25:24.0185] <ljharb>
explicit > implicit

[21:25:48.0237] <ljharb>
but for stage 2 i'm content saying "we'll decide to keep or drop the `when` prefix before stage 2.7"

[21:26:33.0374] <ljharb>
slide 4, `undefined` literal - `null` is always a literal, no exceptions

[21:26:45.0048] <ljharb>
 * slide 4, `undefined` literal - `null` is always a literal, no exceptions, no matter what we decide

[21:27:07.0948] <ljharb>
oh oof, we decided not to make undefined and the infinities special?

[21:27:15.0816] <ljharb>
 * oh oof, we decided not to make undefined and the non-finites special?

[21:27:39.0937] <ljharb>
when you say `ident`, let's say `Identifier` in backticks, to be explicit about the grammar production

[21:28:48.0749] <ljharb>
for slide 6, falsiness implying "no match" is fine, and a *primitive* truthy value implying "match" is fine, but an object should be the `{ matched: boolean, value: unknown }` schema, yes?

[21:29:31.0239] <ljharb>
for slide 7, this is wrong - it needs to check for `Object(3)` - ie, boxed numbers - also, same for all primitive wrappers. `typeof` only detects primitives.

[21:30:39.0999] <ljharb>
slides 14 and 15 should reference caching.

[21:30:44.0508] <ljharb>
globally, `s/falsey/falsy`

[21:31:32.0933] <ljharb>
 * slides 14 and 15 should reference caching, even though it's explained on slide 18

[21:32:33.0156] <ljharb>
i'd love more elaboration on slide 17 also

[21:32:43.0135] <ljharb>
overall, awesome, this is a great first draft :-)

[21:44:12.0887] <Jack Works>
> <@tabatkins:matrix.org> i'm assuming "no `when`"

current spec is no when

[21:44:34.0396] <TabAtkins>
üëç

[21:44:49.0683] <TabAtkins>
Examples in the readme are still all over, wasn't 100% sure

[21:44:52.0128] <TabAtkins>
I'll fix

[21:47:03.0078] <TabAtkins>
> <@ljharb:matrix.org> for slide 6, falsiness implying "no match" is fine, and a *primitive* truthy value implying "match" is fine, but an object should be the `{ matched: boolean, value: unknown }` schema, yes?

Nah, remember we changed the model to let you tell which mode you're in (bool or arglist); in the bool mode it's just being a bool that matters, and in the list mode we expect a list but allow for bools

[21:47:32.0174] <ljharb>
hm, ok

[21:49:09.0796] <Jack Works>
> <@ljharb:matrix.org> slide 4, `undefined` literal - `null` is always a literal, no exceptions

currently in the spec, `undefined` is not a literal, it will find the "undefined" variable which might be shadowed. if we have concensus that this should not be like this, plz open an issue and I'll fix the spec

[21:50:05.0979] <ljharb>
originally we had `undefined`, `Infinity`, and `NaN` as "special", where they'd never be identifiers and always refer to the intuitive values

[21:51:29.0329] <Jack Works>
> Any non-reserved ident sequence, with dots and/or square brackets.

We have a little bit more than that. `this`, `MetaProperty`, `super` and `PrivateIdentifier` can also involve this. (see `PatternMatchingMemberExpression`)

[21:54:00.0732] <Jack Works>
slide 6

> Function is invoked with (subject, {matchType:‚Äúboolean‚Äù}).

it's f(subject, hint, receiver) right now. e.g. `f(subject, "boolean", thisValue)`

[21:54:16.0988] <Jack Works>
* slide 6

> Function is invoked with (subject, {matchType:‚Äúboolean‚Äù}).

it's `f(subject, hint, receiver)` right now. e.g. `f(subject, "boolean", thisValue)`

[21:55:20.0199] <Jack Works>
slide 7: actually we unbox boxed primitives (https://tc39.es/proposal-pattern-matching/#sec-number-%symbol.custommatcher%)

[21:55:25.0755] <Jack Works>
* slide 7: actually we unbox boxed primitives (https://tc39.es/proposal-pattern-matching/#sec-number-%symbol.custommatcher% )

[21:56:51.0755] <Jack Works>
side 8: I think it's better to add `hint, receiver` to match the spec https://tc39.es/proposal-pattern-matching/#sec-function.prototype-%symbol.custommatcher%

[22:06:47.0430] <Jack Works>
> If return value is `true` (not truthy!), same as returning `[]`.

slide 16. we don't have this in the spec, and I think this behavior might be a footgun. if a function returns `true`, you should use it like `f: ...`. Use it like `f(...): ...` is always an error

[22:07:21.0984] <Jack Works>
* > If return value is `true` (not truthy!), same as returning `[]`.

slide 16. we don't have this in the spec, and I think this behavior might be a footgun. if a function returns `true`, you should use it like `f: ...`. Use it like `f(...): ...` is always an error

current in spec: https://tc39.es/proposal-pattern-matching/#sec-invoke-custom-matcher

[22:10:28.0709] <Jack Works>
> <@jackworks:matrix.org> > If return value is `true` (not truthy!), same as returning `[]`.
> 
> slide 16. we don't have this in the spec, and I think this behavior might be a footgun. if a function returns `true`, you should use it like `f: ...`. Use it like `f(...): ...` is always an error

I see the example of this in slide 17. it might be OK if it looks better, but still it's not in the spec. please open an issue if we think this is OK.

[22:11:24.0570] <Jack Works>
* I see the example of this in slide 17. it might be OK if it looks better, but still, it's not in the spec. please open an issue if we think this is OK and I'll add it into the spec.

[09:20:56.0414] <TabAtkins>
Oh, that's definitely been explicitly discussed in the past.

[09:21:28.0264] <TabAtkins>
But hm, I'm probably fine with restricting it.

[10:10:12.0169] <TabAtkins>
> <@ljharb:matrix.org> i'd love more elaboration on slide 17 also

What sort of elaboration are you thinking of? In the slide itself (there's not really much space) or just in speaker notes?

[10:10:55.0287] <ljharb>
like "matches" and "doesn't match", i'm pretty confused about why some of those are

[10:44:41.0737] <TabAtkins>
Okay, I've addressed all of the feedback.

[10:45:03.0327] <TabAtkins>
ljharb: I've rewritten slide 17 a decent bit, is it clearer or do you still want more details in the notes?

[10:46:38.0120] <TabAtkins>
Now let me go rewrite the README, it's so inconsistent with both itself and the spec text proposal

[10:57:46.0236] <ljharb>
so why does `Option.Some` match 5, but `Option.some()` does not?

[10:58:25.0758] <ljharb>
also, in the second example, what happens with `Option.None(undefined)`? is that different than `Option.None()`?

