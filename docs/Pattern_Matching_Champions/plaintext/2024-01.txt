2024-01-06
[08:08:18.0231] <TabAtkins>
I'm on vacation next week so I won't be around for the meeting.


2024-01-08
[21:17:36.0830] <ljharb>
i'll be there but it's pretty important we all get on the same page, so it may not be worth it if tab won't be there. anyone else have thoughts on keeping or skipping the meeting?

[21:27:55.0027] <Jack Works>
no update since last one

[07:40:17.0394] <rbuckton>
I'm fine with skipping or postponing

[07:53:03.0421] <Jack Works>
I think I'll go sleep now, I'd also prefer skipping or postponing

[08:00:41.0102] <ljharb>
sounds good, i'll cancel it


2024-01-12
[12:33:16.0236] <ljharb>
i won't be at the meeting on the 22nd; i'm out of town


2024-01-16
[22:34:23.0252] <ljharb>
do we think there's any possibility we'll all be on the same page, and be ready to present, at the next meeting? if so we may want to try to schedule a meeting at a different time so we can be sure everyone shows up

[12:26:21.0641] <TabAtkins>
Okay, I'm back from vacation.

[12:26:43.0903] <TabAtkins>
And yes, I think so, so yeah let's find a time we can do if you're missing next monday.

[12:39:39.0519] <ljharb>
awesome. i can do this week, or next thursday/friday, or the week of the 29th

[15:21:15.0030] <mpcsh>
this week is tough for me, but next thurs / fri should be wide open


2024-01-17
[15:41:17.0831] <rbuckton>
FYI, I've started drafting a `void` "discard" binding proposal here: https://github.com/rbuckton/proposal-void-binding. The goal is to subsume the previous `using void` part of the resource management proposal into a more general purpose form for specifying "discarded" bindings, as an explicit _Elision_ marker, and for future use as a "discard" pattern for pattern matching. The explainer is very light on details at the moment, I plan to flesh it out over the next few days.


2024-01-18
[09:43:01.0330] <rbuckton>
This has now been fully fleshed-out with motivations, example syntax, intended semantics, etc.


2024-01-22
[06:28:19.0532] <dminor>
Are we rescheduling today's meeting?

[07:17:58.0101] <ljharb>
yes

[07:50:42.0808] <TabAtkins>
I'm be just a few minutes late to the meeting this morning

[07:50:58.0383] <TabAtkins>
Oh nm then


2024-01-23
[20:03:21.0492] <Jack Works>
hello, rbuckton will you consider update how customMatchers are written in https://onedrive.live.com/view.aspx?resid=934F1675ED4C1638%21299428&authkey=!AEyZcVuri5fJLbQ (page 17)? It does not match what pattern matching using now in raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html

[20:06:53.0706] <rbuckton>
I'm aware its a bit out of date, I'll fix it tomorrow.

[20:08:54.0967] <Jack Works>
in page 23, I think matching the inner value of a Map/Set is a footgun (when using the current semantic in the pm proposal) because it is ordered match

[20:25:35.0457] <rbuckton>
I may add a clarification. Slide 22 shows syntax pulled verbatim from the prior collection literals proposal explainer, while slide 23 illustrates the same text, but with the proposed syntax. In that slide I'm not specifically arguing for that example to be supported, but offering it as a contrast to the preceding slide.


2024-01-24
[14:58:10.0639] <rbuckton>
> <@jackworks:matrix.org> hello, rbuckton will you consider update how customMatchers are written in https://onedrive.live.com/view.aspx?resid=934F1675ED4C1638%21299428&authkey=!AEyZcVuri5fJLbQ (page 17)? It does not match what pattern matching using now in raw.githack.com/tc39/proposal-pattern-matching/new-spec/index.html

What is the purpose of `receiver` in a custom matcher? 

[15:02:44.0750] <rbuckton>
I'm not sure I'm a fan of how InvokeCustomMatcher makes custom matcher implementations more complicated.

[15:04:50.0158] <rbuckton>
In the slide you point to, I have to add a number of extra conditions around return values to align with `InvokeCustomMatcher` just doing a ToBoolean on the result when the hint is boolean, and I'm not a huge fan of return type inconsistency.

[15:11:14.0989] <rbuckton>
In my opinion, a "hint" should primarily inform the method as to whether it does or does not need to perform additional computation/allocation when it isn't necessary. Having to check `hint` to ensure my `return { match: false }` isn't interpreted as `true` doesn't really match with the idea of a hint.

[15:13:26.0109] <rbuckton>
Is there a reason we consider anything other than `MatchResult | boolean | undefined` to be a valid result? If we restricted the result to just those cases, then we can have simpler custom matcher bodies that only need to elide the `value` portion if it won't be used.

[15:18:01.0352] <rbuckton>
Ah, I guess it's just boolean or Iterable now?

[15:18:37.0521] <rbuckton>
To be honest, if we had ADT enums, I'd have suggested we have something like:

```
enum MatchResult {
  Fail,
}

[15:18:50.0059] <rbuckton>
 * To be honest, if we had ADT enums, I'd have suggested we have something like:

```
enum MatchResult {
  Fail,
  Pass,
  One(result),
  Many(...results)
}
```

[15:19:40.0321] <rbuckton>
So that we don't need a full iterator protocol for a unary extractor like `when Point({ x, y })`, just to wrap the `{ x, y }` result that will be further destructured.

[15:20:30.0043] <rbuckton>
 * To be honest, if we had ADT enums, I'd have suggested we have something like:

```
enum MatchResult {
  Fail,
  Pass,
  One(result),
  Many(...results)
}
```

And have a custom matcher return `MatchResult | boolean | undefined`

[15:21:01.0808] <rbuckton>
 * With `MatchResut.One(result)` so that we don't need a full iterator protocol for a unary extractor like `when Point({ x, y })`, just to wrap the `{ x, y }` result that will be further destructured.

[15:21:06.0500] <rbuckton>
 * With `MatchResut.One(result)` so that we don't need a full iterator protocol for a unary extractor like `when Point({ x, y })` just to wrap the `{ x, y }` result that will be further destructured.

[15:24:42.0420] <rbuckton>
> <@rbuckton:matrix.org> In my opinion, a "hint" should primarily inform the method as to whether it does or does not need to perform additional computation/allocation when it isn't necessary. Having to check `hint` to ensure my `return { match: false }` isn't interpreted as `true` doesn't really match with the idea of a hint.

After further reflection, _hint_ here isn't so bad since I don't need to differentiate between a `{ matched: false }` and a `{ matched: true }` anymore. I still think it would be nice to be able to optimize for the unary-extractor case in some way.


2024-01-25
[15:50:03.0117] <TabAtkins>
Jack Works: I don't understand how InvokeCustomMatcher works. You check for kind==BOOLEAN in step 8, and return the bool-ized result immediately, but then you check for kind==BOOLEAN *again* in step 11.

[15:53:40.0702] <TabAtkins>
I think what you *mean* to be doing is checking for if `result` is `true`, immediately after step 8, and returning an empty iterator in that case. Then step 10 can just return the GetIteratorCached result (right now the return value is just ignored), and you can delete steps 11 and 12.

[15:56:01.0757] <TabAtkins>
> <@rbuckton:matrix.org> Ah, I guess it's just boolean or Iterable now?

Right, we killed the "match result object" as it's no longer necessary.


2024-01-26
[16:05:44.0370] <TabAtkins>
Jack Works: I also don't think we actually need the note about `document.all` there in InvokeCustomMatcher; it's a bizarre legacy piece of the web platform that produces weird behavior *everywhere*. We're not particularly special here. ^_^

[16:06:49.0125] <TabAtkins>
(Tho also, in that example the second `if()` will only match if you write `null is f(let html, ...)`, since there will be more elements in the iterator than just the html element.)

