2021-11-16
[13:01:55.0865] <rbuckton>
I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:
```js
Symbol.destructure // symbol

enum Option of ADT {
  Some(value),
  None
}
 
const x = Option.Some(1);
const Option.Some(y) = x;
y; // 1
 
match (x) {
  when Option.Some(y) { ... }
  when None { ... }
}
```
Where an `Option.Some` instance has a `@@destructure` method:
```js
// return the actual value to destructure
Option.Some.prototype[Symbol.destructure] = function () { return [this.value]; }
```
And _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)

[13:05:01.0800] <rbuckton>
`match (x) { .. }` would recognize the `QualifiedName(BindingElementList)`/`QualifiedName{BindingPropertyList}` syntax and do the following: 
1. Throw if _QualifiedName_ does not have a `@@destructure` method.
2. Match if `x` is an instance of _QualifiedName_ and the result of the destructure method matches the rest of the pattern specified by _BindingElementList_/_BindingPropertyList_.

[13:05:52.0528] <rbuckton>
`let`/`const`/`var` would do the same except it would throw if (2) isn't a match.

[13:07:47.0703] <rbuckton>
That would make for a nice parallel syntax for ADT-style enums for construction and deconstruction (i.e., `x = Option.Some(y)` -> `Option.Some(y) = x`)

[13:08:06.0738] <rbuckton>
 * I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:
```js
Symbol.destructure // symbol

enum Option of ADT {
  Some(value),
  None
}
 
const x = Option.Some(1);
const Option.Some(y) = x;
y; // 1
 
match (x) {
  when Option.Some(y) { ... }
  when Option.None { ... }
}
```

Where an `Option.Some` instance has a `@@destructure` method:
```js
// return the actual value to destructure
Option.Some.prototype[Symbol.destructure] = function () { return [this.value]; }
```

And _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)

[15:03:45.0562] <Jack Works>
Yeah, if we have that expressiveness it will be very powerful. Currently I had to use @@matcher + deconstruction to design that. 

