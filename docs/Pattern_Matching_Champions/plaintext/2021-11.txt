2021-11-16
[13:01:55.0865] <rbuckton>
I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:
```js
Symbol.destructure // symbol

enum Option of ADT {
  Some(value),
  None
}
 
const x = Option.Some(1);
const Option.Some(y) = x;
y; // 1
 
match (x) {
  when Option.Some(y) { ... }
  when None { ... }
}
```
Where an `Option.Some` instance has a `@@destructure` method:
```js
// return the actual value to destructure
Option.Some.prototype[Symbol.destructure] = function () { return [this.value]; }
```
And _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)

[13:05:01.0800] <rbuckton>
`match (x) { .. }` would recognize the `QualifiedName(BindingElementList)`/`QualifiedName{BindingPropertyList}` syntax and do the following: 
1. Throw if _QualifiedName_ does not have a `@@destructure` method.
2. Match if `x` is an instance of _QualifiedName_ and the result of the destructure method matches the rest of the pattern specified by _BindingElementList_/_BindingPropertyList_.

[13:05:52.0528] <rbuckton>
`let`/`const`/`var` would do the same except it would throw if (2) isn't a match.

[13:07:47.0703] <rbuckton>
That would make for a nice parallel syntax for ADT-style enums for construction and deconstruction (i.e., `x = Option.Some(y)` -> `Option.Some(y) = x`)

[13:08:06.0738] <rbuckton>
 * I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:
```js
Symbol.destructure // symbol

enum Option of ADT {
  Some(value),
  None
}
 
const x = Option.Some(1);
const Option.Some(y) = x;
y; // 1
 
match (x) {
  when Option.Some(y) { ... }
  when Option.None { ... }
}
```

Where an `Option.Some` instance has a `@@destructure` method:
```js
// return the actual value to destructure
Option.Some.prototype[Symbol.destructure] = function () { return [this.value]; }
```

And _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)

[15:03:45.0562] <Jack Works>
Yeah, if we have that expressiveness it will be very powerful. Currently I had to use @@matcher + deconstruction to design that. 

[15:47:33.0196] <Jack Works>
One of the reason I split ADT Enum to have its own constructor object (introduce two binding for ADT Enum, the first one is normal Enum, the second one is the ADT constructor object) is that I'm worrying about combining them will make it impossible to match structures across the ShadowRealm

[15:49:39.0677] <Jack Works>
For example, @@matcher is not wrapped when the ADT constructor send across the ShadowRealm, but it's still possible to match the ADT via the original plain Enum and treat it as a "old style" tagged union. If we combine them (like rbuckton version) it will be not possible to match across ShadowRealm

[15:54:27.0849] <rbuckton>
Here's a sketch of a proposal for @@destructure: https://gist.github.com/rbuckton/ae46b33f383ba69880c7138c49b5e799


2021-11-17
[16:16:16.0196] <Jack Works>
This is amazing. Is it possible to also cover if let (like rust)?

[16:16:45.0449] <Jack Works>
And why you require a instanceof check? That's unreliable

[17:45:03.0974] <Jack Works>
Oops, syntax collision

[17:45:26.0929] <Jack Works>
(possibility?)

[18:25:23.0371] <rbuckton>
Its legal syntax, but always an error.

[18:25:34.0827] <rbuckton>
(a runtime error, but an error)

[18:25:52.0080] <rbuckton>
There was some discussion about this in TDZ last meeting I think

[18:36:57.0859] <rbuckton>
The `QualifiedName{BindingPropertyList}` syntax collides with the proposed `match` syntax though, which would mean we'd need to disambiguate somehow:
```js
// option 1 - add => to 'when' clause:
match (x) {
  when Message.Write(message) => { ... }
  when Message.Move{x, y} => { ... }
}
const Message.Move{x, y} = z;
const Message.Write(message) = z;
 
// option 2 - add disambiguator to InstanceBindingPattern:
match (x) {
  when Message.Write.(message) { ... }
  when Message.Move.{x, y} { ... }
}
const Message.Move.{x, y} = z;
const Message.Write.(message) = z;
 
// option 3 - drop InstanceObjectPattern
match (x) {
  when Message.Write(message) { ... }
  when Message.Move({x, y}) { ... }
}
const Message.Move({x, y}) = z;
const Message.Write(message) = z;
```

Option 3 maybe isn't so bad?

[18:39:25.0584] <rbuckton>
Option 3 could work because of how I define ADT enum for a record/object here: https://gist.github.com/rbuckton/192c2922650e05a1ca9cd7c01be7fc6c
A record/object ADT enum could have a @@destructure method that returns `[{ x, y }]`, so it would work with the nested destructuring pattern.

[18:51:50.0315] <rbuckton>
> <@jackworks:matrix.org> And why you require a instanceof check? That's unreliable

True, but you can hook `instanceof` using `Symbol.hasInstance` if your enum mapper wants to generate something more portable.

[18:54:26.0910] <ljharb>
Making that a protocol sounds like a non starter

[18:54:47.0429] <ljharb>
The entire and only value of destructuring is that it’s sugar for normal property access; a protocol would shred that

[18:55:03.0274] <ljharb>
* The entire and only value of destructuring is that it’s sugar for normal property access but without the duplicate naming; a protocol would shred that

[18:57:29.0943] <rbuckton>
There's plenty of prior art though. C#'s `Deconstruct`, Scala's `unapply`. You can already hook array destructuring using `[Symbol.iterator]`.

[18:58:04.0056] <rbuckton>
And I disagree that that's the only value. Pattern matching makes it even more valuable.

