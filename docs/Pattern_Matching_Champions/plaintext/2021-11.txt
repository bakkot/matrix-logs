2021-11-16
[13:01:55.0865] <rbuckton>
I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:
```js
Symbol.destructure // symbol

enum Option of ADT {
  Some(value),
  None
}
 
const x = Option.Some(1);
const Option.Some(y) = x;
y; // 1
 
match (x) {
  when Option.Some(y) { ... }
  when None { ... }
}
```
Where an `Option.Some` instance has a `@@destructure` method:
```js
// return the actual value to destructure
Option.Some.prototype[Symbol.destructure] = function () { return [this.value]; }
```
And _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)

[13:05:01.0800] <rbuckton>
`match (x) { .. }` would recognize the `QualifiedName(BindingElementList)`/`QualifiedName{BindingPropertyList}` syntax and do the following: 
1. Throw if _QualifiedName_ does not have a `@@destructure` method.
2. Match if `x` is an instance of _QualifiedName_ and the result of the destructure method matches the rest of the pattern specified by _BindingElementList_/_BindingPropertyList_.

[13:05:52.0528] <rbuckton>
`let`/`const`/`var` would do the same except it would throw if (2) isn't a match.

[13:07:47.0703] <rbuckton>
That would make for a nice parallel syntax for ADT-style enums for construction and deconstruction (i.e., `x = Option.Some(y)` -> `Option.Some(y) = x`)

[13:08:06.0738] <rbuckton>
 * I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:
```js
Symbol.destructure // symbol

enum Option of ADT {
  Some(value),
  None
}
 
const x = Option.Some(1);
const Option.Some(y) = x;
y; // 1
 
match (x) {
  when Option.Some(y) { ... }
  when Option.None { ... }
}
```

Where an `Option.Some` instance has a `@@destructure` method:
```js
// return the actual value to destructure
Option.Some.prototype[Symbol.destructure] = function () { return [this.value]; }
```

And _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)

[15:03:45.0562] <Jack Works>
Yeah, if we have that expressiveness it will be very powerful. Currently I had to use @@matcher + deconstruction to design that. 

[15:47:33.0196] <Jack Works>
One of the reason I split ADT Enum to have its own constructor object (introduce two binding for ADT Enum, the first one is normal Enum, the second one is the ADT constructor object) is that I'm worrying about combining them will make it impossible to match structures across the ShadowRealm

[15:49:39.0677] <Jack Works>
For example, @@matcher is not wrapped when the ADT constructor send across the ShadowRealm, but it's still possible to match the ADT via the original plain Enum and treat it as a "old style" tagged union. If we combine them (like rbuckton version) it will be not possible to match across ShadowRealm

