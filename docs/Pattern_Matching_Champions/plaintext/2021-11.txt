2021-11-16
[13:01:55.0865] <rbuckton>
I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:
```js
Symbol.destructure // symbol

enum Option of ADT {
  Some(value),
  None
}
 
const x = Option.Some(1);
const Option.Some(y) = x;
y; // 1
 
match (x) {
  when Option.Some(y) { ... }
  when None { ... }
}
```
Where an `Option.Some` instance has a `@@destructure` method:
```js
// return the actual value to destructure
Option.Some.prototype[Symbol.destructure] = function () { return [this.value]; }
```
And _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)

[13:05:01.0800] <rbuckton>
`match (x) { .. }` would recognize the `QualifiedName(BindingElementList)`/`QualifiedName{BindingPropertyList}` syntax and do the following: 
1. Throw if _QualifiedName_ does not have a `@@destructure` method.
2. Match if `x` is an instance of _QualifiedName_ and the result of the destructure method matches the rest of the pattern specified by _BindingElementList_/_BindingPropertyList_.

[13:05:52.0528] <rbuckton>
`let`/`const`/`var` would do the same except it would throw if (2) isn't a match.

[13:07:47.0703] <rbuckton>
That would make for a nice parallel syntax for ADT-style enums for construction and deconstruction (i.e., `x = Option.Some(y)` -> `Option.Some(y) = x`)

[13:08:06.0738] <rbuckton>
 * I've been looking at Rust and C# pattern matching today while revisiting my enum proposal in light of the new proposal by Jack Works. One thing that struck me about C# was that destructuring (nee. deconstruction) is user-controllable via a `Deconstruct`-named method. It got me to thinking whether we might be able to propose something similar:
```js
Symbol.destructure // symbol

enum Option of ADT {
  Some(value),
  None
}
 
const x = Option.Some(1);
const Option.Some(y) = x;
y; // 1
 
match (x) {
  when Option.Some(y) { ... }
  when Option.None { ... }
}
```

Where an `Option.Some` instance has a `@@destructure` method:
```js
// return the actual value to destructure
Option.Some.prototype[Symbol.destructure] = function () { return [this.value]; }
```

And _BindingPattern_ could evolve to allow `QualifiedName(BindingElementList)` and `QualifiedName{BindingPropertyList}` (where _QualifiedName_ is something like `a.b.c`, etc.)

[15:03:45.0562] <Jack Works>
Yeah, if we have that expressiveness it will be very powerful. Currently I had to use @@matcher + deconstruction to design that. 

[15:47:33.0196] <Jack Works>
One of the reason I split ADT Enum to have its own constructor object (introduce two binding for ADT Enum, the first one is normal Enum, the second one is the ADT constructor object) is that I'm worrying about combining them will make it impossible to match structures across the ShadowRealm

[15:49:39.0677] <Jack Works>
For example, @@matcher is not wrapped when the ADT constructor send across the ShadowRealm, but it's still possible to match the ADT via the original plain Enum and treat it as a "old style" tagged union. If we combine them (like rbuckton version) it will be not possible to match across ShadowRealm

[15:54:27.0849] <rbuckton>
Here's a sketch of a proposal for @@destructure: https://gist.github.com/rbuckton/ae46b33f383ba69880c7138c49b5e799


2021-11-17
[16:16:16.0196] <Jack Works>
This is amazing. Is it possible to also cover if let (like rust)?

[16:16:45.0449] <Jack Works>
And why you require a instanceof check? That's unreliable

[17:45:03.0974] <Jack Works>
Oops, syntax collision

[17:45:26.0929] <Jack Works>
(possibility?)

[18:25:23.0371] <rbuckton>
Its legal syntax, but always an error.

[18:25:34.0827] <rbuckton>
(a runtime error, but an error)

[18:25:52.0080] <rbuckton>
There was some discussion about this in TDZ last meeting I think

[18:36:57.0859] <rbuckton>
The `QualifiedName{BindingPropertyList}` syntax collides with the proposed `match` syntax though, which would mean we'd need to disambiguate somehow:
```js
// option 1 - add => to 'when' clause:
match (x) {
  when Message.Write(message) => { ... }
  when Message.Move{x, y} => { ... }
}
const Message.Move{x, y} = z;
const Message.Write(message) = z;
 
// option 2 - add disambiguator to InstanceBindingPattern:
match (x) {
  when Message.Write.(message) { ... }
  when Message.Move.{x, y} { ... }
}
const Message.Move.{x, y} = z;
const Message.Write.(message) = z;
 
// option 3 - drop InstanceObjectPattern
match (x) {
  when Message.Write(message) { ... }
  when Message.Move({x, y}) { ... }
}
const Message.Move({x, y}) = z;
const Message.Write(message) = z;
```

Option 3 maybe isn't so bad?

[18:39:25.0584] <rbuckton>
Option 3 could work because of how I define ADT enum for a record/object here: https://gist.github.com/rbuckton/192c2922650e05a1ca9cd7c01be7fc6c
A record/object ADT enum could have a @@destructure method that returns `[{ x, y }]`, so it would work with the nested destructuring pattern.

[18:51:50.0315] <rbuckton>
> <@jackworks:matrix.org> And why you require a instanceof check? That's unreliable

True, but you can hook `instanceof` using `Symbol.hasInstance` if your enum mapper wants to generate something more portable.

[18:54:26.0910] <ljharb>
Making that a protocol sounds like a non starter

[18:54:47.0429] <ljharb>
The entire and only value of destructuring is that it’s sugar for normal property access; a protocol would shred that

[18:55:03.0274] <ljharb>
* The entire and only value of destructuring is that it’s sugar for normal property access but without the duplicate naming; a protocol would shred that

[18:57:29.0943] <rbuckton>
There's plenty of prior art though. C#'s `Deconstruct`, Scala's `unapply`. You can already hook array destructuring using `[Symbol.iterator]`.

[18:58:04.0056] <rbuckton>
And I disagree that that's the only value. Pattern matching makes it even more valuable.

[19:53:04.0656] <ljharb>
The only current value :-) pattern matching’s value is predicated on it exactly matching the simplicity that is destructuring.

[19:53:29.0273] <ljharb>
Prior art is useful to inspire how we might do something; it’s irrelevant tho when its unidiomatic for the language.

[19:53:52.0662] <ljharb>
there’s tons of things tons of languages do that would be horrifically bad in JS; “prior art” isn’t a justification to add anything.

[09:14:32.0325] <rbuckton>
I've amended the proposal to align more with scala extractor objects (i.e., no built-in instanceof check, renamed `@@destructure` to `@@unapply` and moved it off the instance and onto the _QualifiedName_, dropped `QualifiedName{x,y}` and only have `QualifiedName(x)`). There's plenty of places I could see this being useful as it allows you to apply custom logic during destructuring:
```js
const MapExtractor = {
  [Symbol.unapply](value) { 
    const obj = {};
    for (const [key, value] of map) {
      obj[typeof key === "symbol" ? key : `${key}`] = value;
    }
    return [obj];
  }
}

const obj = {
  map: new Map().set("a", 1).set("b", 2)
};

const { map: MapExtractor({ a, b }) } = obj;
```

The ability to evaluate custom logic in the middle of a destructuring is something I've often wanted.

[09:14:57.0582] <rbuckton>
 * I've amended the proposal to align more with scala extractor objects (i.e., no built-in instanceof check, renamed `@@destructure` to `@@unapply` and moved it off the instance and onto the _QualifiedName_, dropped `QualifiedName{x,y}` and only have `QualifiedName(x)`). There's plenty of places I could see this being useful as it allows you to apply custom logic during destructuring:
```js
const MapExtractor = {
  [Symbol.unapply](value) { 
    const obj = {};
    for (const [key, value] of map) {
      obj[typeof key === "symbol" ? key : `${key}`] = value;
    }
    return [obj];
  }
}

const obj = {
  map: new Map().set("a", 1).set("b", 2)
};

const { map: MapExtractor({ a, b }) } = obj;
```

The ability to evaluate custom logic in the middle of a destructuring is something I've often wanted.

[09:18:51.0701] <rbuckton>
> <@ljharb:matrix.org> Prior art is useful to inspire how we might do something; it’s irrelevant tho when its unidiomatic for the language.

Destructuring itself was unidiomatic for JavaScript when it was added. I don't think this approach is unidiomatic, as it thematically aligns with other patterns we're considering for JavaScript such as pipeline, decorators, and pattern matching. It also would make it easier to work with ADT enums.

[09:22:40.0179] <ljharb>
no it wasn't

[09:22:59.0134] <ljharb>
`var x = o.x` was quite idiomatic. destructuring was just syntax sugar for that idiomatic pattern.

[09:24:13.0659] <ljharb>
The criteria for adding something can't solely be that there's places it "could" be useful; it also needs to fit with the expectations language users have. The expectation language users have is that destructuring is  exactly the same as not destructuring - just more concise. That's not an expectation worth breaking.

[09:33:11.0387] <rbuckton>
I don't think this breaks that expectation. You argue that destructuring is a concise form of this idiom:
```js
var x = o.x;
var { x } = o;
```

I'm arguing that extractors are just as applicable if you extend your example to this:

```js
var x = f(o.x);
```

[09:34:21.0555] <rbuckton>
The difference being that `f(o.x)` is the application of `o.x` to `f`, but inverting that in destructuring would be the "un-application".

[09:40:39.0733] <rbuckton>
Here's a slightly less contrived example:
```js
const InstantExtractor = {
    * [Symbol.unapply](value) {
        if (value instanceof Temporal.Instant) yield value;
        else if (value instanceof Date) yield Temporal.Instant.fromEpochMilliseconds(value.getTime());
        else if (typeof value === "string") yield Temporal.Instant.from(value);
    }
};

class Book {
    constructor({
        isbn,
        title,
        InstantExtractor(createdAt) = Temporal.Now.instant(),
        InstantExtractor(modifiedAt) = createdAt
    }) {
        this.isbn = isbn;
        this.title = title;
        this.createdAt = createdAt;
        this.modifiedAt = modifiedAt;
    }
}
```

[09:41:19.0075] <rbuckton>
 * Here's a slightly less contrived example:
```js
const InstantExtractor = {
    [Symbol.unapply](value) {
        if (value instanceof Temporal.Instant) return [value];
        if (value instanceof Date) return [Temporal.Instant.fromEpochMilliseconds(value.getTime())];
        if (typeof value === "string") return [Temporal.Instant.from(value)];
        return [undefined];
    }
};

class Book {
    constructor({
        isbn,
        title,
        InstantExtractor(createdAt) = Temporal.Now.instant(),
        InstantExtractor(modifiedAt) = createdAt
    }) {
        this.isbn = isbn;
        this.title = title;
        this.createdAt = createdAt;
        this.modifiedAt = modifiedAt;
    }
}
```

[09:42:14.0752] <rbuckton>
 * Here's a slightly less contrived example:
```js
const InstantExtractor = {
    * [Symbol.unapply](value) {
        if (value instanceof Temporal.Instant) yield value;
        else if (value instanceof Date) yield Temporal.Instant.fromEpochMilliseconds(value.getTime());
        else if (typeof value === "string") yield Temporal.Instant.from(value);
        else yield;
    }
};

class Book {
    constructor({
        isbn,
        title,
        InstantExtractor(createdAt) = Temporal.Now.instant(),
        InstantExtractor(modifiedAt) = createdAt
    }) {
        this.isbn = isbn;
        this.title = title;
        this.createdAt = createdAt;
        this.modifiedAt = modifiedAt;
    }
}
```

[09:42:50.0803] <rbuckton>
 * Here's a slightly less contrived example:
```js
const InstantExtractor = {
    * [Symbol.unapply](value) {
        if (value instanceof Temporal.Instant) yield value;
        else if (value instanceof Date) yield Temporal.Instant.fromEpochMilliseconds(value.getTime());
        else if (typeof value === "string") yield Temporal.Instant.from(value);
    }
};

class Book {
    constructor({
        isbn,
        title,
        InstantExtractor(createdAt) = Temporal.Now.instant(),
        InstantExtractor(modifiedAt) = createdAt
    }) {
        this.isbn = isbn;
        this.title = title;
        this.createdAt = createdAt;
        this.modifiedAt = modifiedAt;
    }
}
```

[09:49:37.0448] <rbuckton>
 * Here's a slightly less contrived example:
```js
const InstantExtractor = {
    * [Symbol.unapply](value) {
        if (value instanceof Temporal.Instant) yield value;
        else if (value instanceof Date) yield Temporal.Instant.fromEpochMilliseconds(value.getTime());
        else if (typeof value === "string") yield Temporal.Instant.from(value);
    }
};

class Book {
    constructor({
        isbn,
        title,
        InstantExtractor(createdAt) = Temporal.Now.instant(),
        InstantExtractor(modifiedAt) = createdAt
    }) {
        this.isbn = isbn;
        this.title = title;
        this.createdAt = createdAt;
        this.modifiedAt = modifiedAt;
    }
}
new Book({ isbn: "...", title: "...", createdAt: Temporal.from("...") });
new Book({ isbn: "...", title: "...", createdAt: "..." });
new Book({ isbn: "...", title: "...", createdAt: new Date() });
```

[10:03:47.0380] <rbuckton>
> <@jackworks:matrix.org> And why you require a instanceof check? That's unreliable

I removed the `instanceof` check from the runtime semantics along with my other recent changes. It could still be used in userland inside the `@@unapply` (née `@@destructure`) method, but built-ins could leverage private slots for brand checks.

[10:07:56.0987] <TabAtkins>
The current proposal does address this use-case, just with a slightly longer syntax: `when ^Option.Some() with val` instead of `when ^Option.some(val)`

[10:08:06.0874] <rbuckton>
Also, `@@unapply` isn't too different from `@@matcher`. An `@@unapply` method could just return null/undefined in place of a `matched` property, and instead of `^Expr as { x, y }` you would use `Expr({ x, y})`

[10:08:22.0366] <rbuckton>
Yes, but only in pattern matching.

[10:08:26.0151] <TabAtkins>
That way we allow arbitrary expressions (rather than just predefined named things) and don't have to invent a brand new destructuring variant

[10:08:43.0885] <TabAtkins>
Oh, I see, you are talking about destructuring

[10:09:10.0309] <rbuckton>
Yes, but it also applies to pattern matching since pattern matching partly relies on destructuring.

[10:10:02.0062] <TabAtkins>
Yes, tho technically we do so by explicitly using the same syntax as destructuring, rather than implicitly by importing destructuring.

[10:10:11.0882] <rbuckton>
Rust considers this to be part of pattern matching.

[10:12:34.0475] <rbuckton>
I think these two concepts are convergent:
```js
match (x) {
  when Option.Some(value: { status: 200 }) { ... }
  when Option.Some(value: { status: 404 }) { ... }
  when Option.None { ... }
}
```

[10:17:37.0365] <TabAtkins>
Yeah, Rust doesn't have support for arbitrary matchers, just the structural matching of their struct types.

[10:19:00.0064] <TabAtkins>
Similar for Python - rather than supporting a matching protocol, they have a syntax that looks similar to this, where you can destructure into a list or dict that looks like a constructor invocation

[10:35:18.0433] <rbuckton>
 * I think these two concepts are convergent:
```js
match (x) {
  when Option.Some({ status: 200 }) { ... }
  when Option.Some({ status: 404 }) { ... }
  when Option.None { ... }
}
```

[10:39:21.0705] <rbuckton>
C#'s approach is similar:
```cs
var result = x switch {
  Option.Some(Response { status: 200 }) => ...,
  Option.None => ...
};
```

[10:39:43.0355] <rbuckton>
Except C# has a `Deconstruct` method that it uses for extraction (so syntax+protocol)

[10:39:55.0902] <rbuckton>
 * Except C# has a `Deconstruct` method that it uses for extraction (so syntax+protocol)


2021-11-18
[17:40:23.0443] <Jack Works>
> <@rbuckton:matrix.org> I've amended the proposal to align more with scala extractor objects (i.e., no built-in instanceof check, renamed `@@destructure` to `@@unapply` and moved it off the instance and onto the _QualifiedName_, dropped `QualifiedName{x,y}` and only have `QualifiedName(x)`). There's plenty of places I could see this being useful as it allows you to apply custom logic during destructuring:
> ```js
> const MapExtractor = {
>   [Symbol.unapply](value) { 
>     const obj = {};
>     for (const [key, value] of map) {
>       obj[typeof key === "symbol" ? key : `${key}`] = value;
>     }
>     return [obj];
>   }
> }
> 
> const obj = {
>   map: new Map().set("a", 1).set("b", 2)
> };
> 
> const { map: MapExtractor({ a, b }) } = obj;
> ```
> 
> The ability to evaluate custom logic in the middle of a destructuring is something I've often wanted.

If you dropped the {} form, how it works with ADT objects? Match on the 1st argument? That creates a syntax irsymmetry

[17:42:44.0125] <Jack Works>
> <@rbuckton:matrix.org> Also, `@@unapply` isn't too different from `@@matcher`. An `@@unapply` method could just return null/undefined in place of a `matched` property, and instead of `^Expr as { x, y }` you would use `Expr({ x, y})`

So why not merging them? 

[17:42:48.0070] <rbuckton>
There's no syntax asymmetry for usage/extraction:

```js
enum Message of ADT {
   Move{x, y},
}

const msg = Message.Move({ x: 1, y: 1 });
const Message.Move({ x, y }) = msg;
```

[17:44:03.0541] <rbuckton>
It might even make sense to drop `PropertyName{x, y}` from ADT enums in favor of `PropertyName({x, y})` for declaration symmetry

[17:44:32.0293] <rbuckton>
```js
enum Message of ADT {
  Write(message),
  Move({ x, y })
}
```

[17:44:33.0450] <Jack Works>
> <@rbuckton:matrix.org> There's no syntax asymmetry for usage/extraction:
> 
> ```js
> enum Message of ADT {
>    Move{x, y},
> }
> 
> const msg = Message.Move({ x: 1, y: 1 });
> const Message.Move({ x, y }) = msg;
> ```

Hmm this is interesting. I was thinking of the definition body in the Enum and deconstruction syntax is asymmerty

[17:45:14.0383] <rbuckton>
In your proposal, ADT enum value construction uses `Foo.Bar({ x, y })` as well

[17:45:39.0877] <Jack Works>
> <@rbuckton:matrix.org> It might even make sense to drop `PropertyName{x, y}` from ADT enums in favor of `PropertyName({x, y})` for declaration symmetry

But if that's the case, will you allow Prop({ a: { b }})?

[17:47:09.0865] <rbuckton>
That might be a bridge too far, to be honest. 

[19:40:10.0585] <Jack Works>
I don't think that would be allowed either but developers might think it can

[09:48:15.0983] <rbuckton>
It wouldn't be allowed for the declaration, but would be allowed for construction and deconstruction. I don't think its so bad to disallow it at declaration, since enums would be a new feature and thus require learning the syntax to be able to use it.

[11:50:02.0917] <ljharb>
… what is an "ADT enum" and why is this concept important for enums and/or pattern matching?

[11:52:48.0873] <ljharb>
to me an enum is just a closed set of explicitly named values (any distinct values) that conceptually enumerates some domain

[13:02:54.0432] <jschoi>
> <@ljharb:matrix.org> … what is an "ADT enum" and why is this concept important for enums and/or pattern matching?

ADT = https://en.wikipedia.org/wiki/Generalized_algebraic_data_type in this case, I believe. 

[13:02:58.0716] <jschoi>
See also https://github.com/rbuckton/proposal-enum/issues/6

[13:03:51.0153] <jschoi>
They’re essentially structs with predefined categories. Or enums with additional payloads. Haskell, Rust, and Swift have them. They can use pattern matching on them. 

[13:04:07.0486] <jschoi>
* They’re essentially structs with predefined categories. Or enums with payload. Haskell, Rust, and Swift have them. They can use pattern matching on them. 

[13:04:50.0384] <jschoi>
* They’re essentially structs with predefined categories. Or enums with additional payloads. Haskell, Rust, and Swift have them. They can use pattern matching on them. 

[13:08:35.0135] <jschoi>
Like a Result type being made of the union of a Failure() singleton and a Success(value) type, after which Result values could be pattern matched between Failure() and Success(value) values, with value automatically being extracted in the Success branch. That’s probably what they’re talking about.  

[13:14:10.0575] <ljharb>
ok, but you can already do that with pattern matching wiht objects

[13:14:30.0837] <ljharb>
so sure, that should work, but that just means enums would need a very obvious and intuitive matcher protocol, right?

[13:15:32.0845] <jschoi>
Yes, as far as I can tell, but perhaps I’m missing something. 

[15:25:13.0751] <rbuckton>
> <@ljharb:matrix.org> so sure, that should work, but that just means enums would need a very obvious and intuitive matcher protocol, right?

ADT enums would, yes. That's what `@@unapply` or (`@@matcher`) would give you.

[15:27:56.0475] <rbuckton>
From what I've seen, languages that have ADT enums make heavy use of them alongside pattern matching as almost the majority use case.

[15:54:36.0231] <ljharb>
oh hm - we'd have to special-case enums in pattern matching tho somehow, because you'd want `when (enum.FOO)` to match, but the matcher protocol couldn't exist on, say, `1`

[15:55:03.0215] <ljharb>
or actually `enum.FOO` would just be the runtime value, so there's not even a matcher protocol needed?

[15:55:11.0455] <ljharb>
so yeah i'm still confused about the unapply stuff.

[15:56:05.0218] <ljharb>
```
match (x) {
  when (enum.foo) { … }
  when (enum.bar) { … }
  when (enum.baz) { … }
  else { … }
}
```
this would work just fine as-is, since each enum property is just a value, with no special affordance


2021-11-19
[16:02:24.0219] <rbuckton>
In Scala, an object with an `apply` method is essentially a function, and can behave similar to a constructor. So you can do something like `Book.apply(isbn, name)` (or just `Book(isbn, name)` and get a `Book` object back. You give it arguments and it gives you the result.

The `unapply` method is something like the inverse of a constructor. You give it the result and it gives you back the arguments. 

[16:04:28.0243] <rbuckton>
This is especially useful in pattern matching. In JS, (without extra syntax) it might look something like this

```js
const x = new Book(isbn, name);
const [isbn, name] = Book.unapply(x);
```

[16:05:52.0855] <rbuckton>
 * This is especially useful in pattern matching. In JS, (without extra syntax) it might look something like this
```js
const x = new Book(isbn, name);
const [isbn, name] = Book[Symbol.unapply](x);
```

[16:06:17.0297] <rbuckton>
With syntax it would instead look like this:
```js
const x = new Book(isbn, name);
const Book(isbn, name) = x;
```

[16:08:48.0079] <rbuckton>
This becomes even more powerful when used in a binding pattern, allowing you to evaluate extractor logic in the middle of a binding pattern:
```js
const books = [new Book(isbn, name, { publisher: "O'Reilly" })]
const [Book(isbn, name, { publisher )] = books;
```

[16:11:49.0490] <rbuckton>
The `const Book(isbn, name) = x;` syntax is also an example of pattern matching. Book's "unapply" might look like this:
```js
class Book {
  isbn;
  name;
  constructor(isbn, name) {
    this.isbn = isbn;
    this.name = name;
  }
  static [Symbol.unapply](book) {
    // return an iterable for a valid match.
    // return 'undefined' or 'null' to indicate unapply was unsuccessful.
    if (book instanceof Book) return [book.isbn, book.name];
  }
}
 
const Book(isbn, name) = null; // throws an error because the match failed.
```

[16:15:30.0957] <rbuckton>
As a result, `@@unapply` is very similar to the proposed `@@matcher` with the following distinctions:
- In `@@matcher` you return an object with `matched: true ` to indicate success. In `@@unapply` you return an iterable.
- In `@@matcher` you return an object with `matched: false` to indicate failure. In `@@unapply` you return null/undefined.
- In `@@matcher` you return an object with a `value` property that is destructured. In `@@unapply` you just return an iterable.
- In `@@matcher`, the destructured value can be an object or an iterable. In `@@unapply` it can only be an iterable (but that can contain an object.

[16:16:42.0918] <rbuckton>
(its possible `@@unapply` could return a non-iterable, though that wouldn't work with `const Foo(bar) = x` destructuring)

[16:20:26.0288] <rbuckton>
`match` syntax could be extended to support extractors in a way that is consistent with extractor binding patterns and other match clauses.

[16:22:06.0076] <rbuckton>
```js
match (msg) {
  when (Message.Move({ x, y })) { ... }
  when (Message.KeyPress({ alt: true, key })) { ... }
  else { ... }
}
```

[16:22:51.0055] <rbuckton>
 * ```js
match (msg) {
  when (Message.Move({ x, y })) { ... }
  when (Message.KeyPress({ alt: true, key })) { ... }
  else { ... }
}
```

[16:24:12.0827] <rbuckton>
 * In Scala, an object with an `apply` method is essentially a function, and can behave similar to a constructor. So you can do something like `Book.apply(isbn, name)` (or just `Book(isbn, name)`) and get a `Book` object back. You give it arguments and it gives you the result.

The `unapply` method is something like the inverse of a constructor. You give it the result and it gives you back the arguments.

[16:24:32.0653] <rbuckton>
 * This is especially useful in pattern matching. In JS, (without extra syntax) it might look something like this:
```js
const x = new Book(isbn, name);
const [isbn, name] = Book[Symbol.unapply](x);
```

[16:24:52.0967] <rbuckton>
 * This becomes even more powerful when used in a binding pattern, allowing you to evaluate extractor logic in the middle of the pattern:
```js
const books = [new Book(isbn, name, { publisher: "O'Reilly" })]
const [Book(isbn, name, { publisher )] = books;
```

[16:25:04.0442] <rbuckton>
 * This becomes even more powerful when used in a binding pattern, allowing you to evaluate extractor logic in the middle of the pattern:
```js
const books = [new Book(isbn, name, { publisher: "O'Reilly" })]
const [Book(isbn, name, { publisher })] = books;
```

[16:25:37.0898] <rbuckton>
 * This becomes even more powerful when used in a binding pattern, allowing you to evaluate extractor logic in the middle of the pattern:
```js
const books = [new Book("...isbn...", "...name...", { publisher: "O'Reilly" })]
const [Book(isbn, name, { publisher })] = books;
```

[16:26:16.0946] <rbuckton>
 * The `const Book(isbn, name) = x;` syntax is also an example of pattern matching. Book's "unapply" might look like this:
```js
class Book {
  isbn;
  name;
  constructor(isbn, name) {
    this.isbn = isbn;
    this.name = name;
  }
  static [Symbol.unapply](book) {
    // return an iterable for a valid match.
    // return 'undefined' or 'null' to indicate unapply was unsuccessful.
    if (book instanceof Book) return [book.isbn, book.name];
    return null;
  }
}
 
const Book(isbn, name) = null; // throws an error because the match failed.
```

[16:26:57.0176] <rbuckton>
 * As a result, `@@unapply` is very similar to the proposed `@@matcher` with the following distinctions:
- In `@@matcher` you return an object with `matched: true ` to indicate success. In `@@unapply` you return an iterable.
- In `@@matcher` you return an object with `matched: false` to indicate failure. In `@@unapply` you return null/undefined.
- In `@@matcher` you return an object with a `value` property that is destructured. In `@@unapply` you just return an iterable.
- In `@@matcher`, the destructured value can be an object or an iterable. In `@@unapply` it can only be an iterable (but that iterable could contain an object).

[22:56:37.0736] <ljharb>
i think if to explain the usefulness of a concept you have to describe another language, that maybe it's not that useful?

[22:56:54.0581] <ljharb>
my recollection of unapply in scala is that it's powerful but very confusing

