2024-04-01
[03:05:15.0921] <mpcsh>
hey folks, are we meeting today?

[07:54:23.0997] <ljharb>
I’m not sure we need to - separately I’m not feeling well, so I’ll be late if we are.

[08:25:03.0883] <rbuckton>
I am also not feeling well, so will not be in attendance unless there is a need.


2024-04-04
[08:04:33.0960] <rbuckton>
I'm confused by this example in the README.md, I don't think the 2nd parameter matches the proposed spec text:

```js
RegExp.prototype[Symbol.customMatcher] = function(subject, {matchType}) {
    const result = this.exec(subject);
    if(matchType == "boolean") return result;
    if(matchType == "extractor") return [result, ...result.slice(1)];
}
```
Isn't the 2nd argument just a string, and aren't the possible values `"boolean"` and `"list"`?

[08:12:02.0289] <rbuckton>
Also, I'm not sure I agree with the result for a RegExp custom matcher as suggested here: https://github.com/tc39/proposal-pattern-matching?tab=readme-ov-file#regex-extractor-patterns

To match against a RegExp, you may want to match against either named capture groups, positional capture groups, or the whole match. I think the matcher could just be:

```js
RegExp.prototype[Symbol.customMatcher] = function(subject, hint) {
    const result = this.exec(subject);
    if (hint === "boolean") return !!result;
    if (hint === "list") return result && [result];
}
```
And the pattern would look like:

```
when /(?<left>\d+) \+ (?<right>\d+)/({groups:{let left, let right}}): ...;
when /(\d+) \* (\d+)/([void, let left, let right]): ...;
when /\d+/([let digits]): ...;
```


[08:15:22.0406] <rbuckton>
The extra outputs from `...result.slice(1)` seem like unnecessary overhead for the sake of convenience as I doubt engines will optimize them away if unused.

[13:47:00.0985] <TabAtkins>
I was kinda wanting to be able to do the second and third cases as just `(void, let left, let right)` and `(let digits)` rather than requiring an array pattern as well, but I suppose that's not a big deal, yeah.

[14:03:38.0770] <rbuckton>
`(let digits)` doesn't work if you want to access groups. (at least, not without the abandoned `Foo{ }` syntax).

[14:08:13.0032] <rbuckton>
I'm in the middle of writing some code using C#'s pattern matching, and I may want to bring https://github.com/rbuckton/proposal-shorthand-improvements back at some point. C# has an object initialization syntax that lets you write code like this:
```cs
var a = new Foo() {
  Bar = 1,
  Baz.Quxx = 2,
}
```
which amounts to
```cs
var a = new Foo();
a.Bar = 1;
a.Baz.Quxx = 2;
```

and `{ Baz.Quxx = 2 }` is essentially the same as `{ Baz = { Quxx = 2 } }`.

[14:09:44.0076] <rbuckton>
And unnamed types can be `new { Bar, Baz.Quxx }` which is essentially `new { Bar = Bar, Quxx = Baz.Quxx }`. 

[14:10:31.0242] <rbuckton>
Apparently they have a similar shorthand syntax for pattern matching, `x is { Bar: 1, Baz.Quxx: 2 }`, which is the same as `x is { Bar: 1, Baz: { Quxx: 2 } }`.

[14:11:47.0372] <rbuckton>
Definitely not an MVP feature, but the deep property pattern seems potentially valuable and we're already parsing dotted names for extractors.

[14:12:36.0879] <rbuckton>
 * I'm in the middle of writing some code using C#'s pattern matching and ran into an interesting mechanism. C# has an object initialization syntax that lets you write code like this:

```cs
var a = new Foo() {
  Bar = 1,
  Baz.Quxx = 2,
}
```

which amounts to

```cs
var a = new Foo();
a.Bar = 1;
a.Baz.Quxx = 2;
```

and `{ Baz.Quxx = 2 }` is essentially the same as `{ Baz = { Quxx = 2 } }`.

[14:44:54.0886] <TabAtkins>
yeah, not an mvp, but that's definitely something we might want to do in the future


2024-04-05
[08:15:00.0655] <Jack Works>
> The pattern-matching champion group designed this proposal with a layering approach. It does not mean the proposal is an MVP. The champion group wishes to ship the proposal as a whole when possible, but we can drop some features if there is strong pushback from the committee.

> This approach allows the champion group to consider how all features combine and also how the proposal should behave if any of the features are missing.

 I hope this is the consensus, am I wrong? MVP may leads to another class design in my pov

