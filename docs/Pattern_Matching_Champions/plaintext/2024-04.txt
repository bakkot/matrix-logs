2024-04-01
[03:05:15.0921] <mpcsh>
hey folks, are we meeting today?

[07:54:23.0997] <ljharb>
I’m not sure we need to - separately I’m not feeling well, so I’ll be late if we are.

[08:25:03.0883] <rbuckton>
I am also not feeling well, so will not be in attendance unless there is a need.


2024-04-04
[08:04:33.0960] <rbuckton>
I'm confused by this example in the README.md, I don't think the 2nd parameter matches the proposed spec text:

```js
RegExp.prototype[Symbol.customMatcher] = function(subject, {matchType}) {
    const result = this.exec(subject);
    if(matchType == "boolean") return result;
    if(matchType == "extractor") return [result, ...result.slice(1)];
}
```
Isn't the 2nd argument just a string, and aren't the possible values `"boolean"` and `"list"`?

[08:12:02.0289] <rbuckton>
Also, I'm not sure I agree with the result for a RegExp custom matcher as suggested here: https://github.com/tc39/proposal-pattern-matching?tab=readme-ov-file#regex-extractor-patterns

To match against a RegExp, you may want to match against either named capture groups, positional capture groups, or the whole match. I think the matcher could just be:

```js
RegExp.prototype[Symbol.customMatcher] = function(subject, hint) {
    const result = this.exec(subject);
    if (hint === "boolean") return !!result;
    if (hint === "list") return result && [result];
}
```
And the pattern would look like:

```
when /(?<left>\d+) \+ (?<right>\d+)/({groups:{let left, let right}}): ...;
when /(\d+) \* (\d+)/([void, let left, let right]): ...;
when /\d+/([let digits]): ...;
```


[08:15:22.0406] <rbuckton>
The extra outputs from `...result.slice(1)` seem like unnecessary overhead for the sake of convenience as I doubt engines will optimize them away if unused.

[13:47:00.0985] <TabAtkins>
I was kinda wanting to be able to do the second and third cases as just `(void, let left, let right)` and `(let digits)` rather than requiring an array pattern as well, but I suppose that's not a big deal, yeah.

[14:03:38.0770] <rbuckton>
`(let digits)` doesn't work if you want to access groups. (at least, not without the abandoned `Foo{ }` syntax).

[14:08:13.0032] <rbuckton>
I'm in the middle of writing some code using C#'s pattern matching, and I may want to bring https://github.com/rbuckton/proposal-shorthand-improvements back at some point. C# has an object initialization syntax that lets you write code like this:
```cs
var a = new Foo() {
  Bar = 1,
  Baz.Quxx = 2,
}
```
which amounts to
```cs
var a = new Foo();
a.Bar = 1;
a.Baz.Quxx = 2;
```

and `{ Baz.Quxx = 2 }` is essentially the same as `{ Baz = { Quxx = 2 } }`.

[14:09:44.0076] <rbuckton>
And unnamed types can be `new { Bar, Baz.Quxx }` which is essentially `new { Bar = Bar, Quxx = Baz.Quxx }`. 

[14:10:31.0242] <rbuckton>
Apparently they have a similar shorthand syntax for pattern matching, `x is { Bar: 1, Baz.Quxx: 2 }`, which is the same as `x is { Bar: 1, Baz: { Quxx: 2 } }`.

[14:11:47.0372] <rbuckton>
Definitely not an MVP feature, but the deep property pattern seems potentially valuable and we're already parsing dotted names for extractors.

[14:12:36.0879] <rbuckton>
 * I'm in the middle of writing some code using C#'s pattern matching and ran into an interesting mechanism. C# has an object initialization syntax that lets you write code like this:

```cs
var a = new Foo() {
  Bar = 1,
  Baz.Quxx = 2,
}
```

which amounts to

```cs
var a = new Foo();
a.Bar = 1;
a.Baz.Quxx = 2;
```

and `{ Baz.Quxx = 2 }` is essentially the same as `{ Baz = { Quxx = 2 } }`.

[14:44:54.0886] <TabAtkins>
yeah, not an mvp, but that's definitely something we might want to do in the future


2024-04-05
[08:15:00.0655] <Jack Works>
> The pattern-matching champion group designed this proposal with a layering approach. It does not mean the proposal is an MVP. The champion group wishes to ship the proposal as a whole when possible, but we can drop some features if there is strong pushback from the committee.

> This approach allows the champion group to consider how all features combine and also how the proposal should behave if any of the features are missing.

 I hope this is the consensus, am I wrong? MVP may leads to another class design in my pov


2024-04-08
[15:41:38.0996] <rbuckton>
In the proposal `{}` explicitly matches `Object`, but destructuring does not. By restricting `{}` to `Object` you can't have patterns like

```js
match (value) {
}

[15:41:49.0408] <rbuckton>
 * In the proposal `{}` explicitly matches `Object`, but destructuring does not. By restricting `{}` to `Object` you can't have patterns like

```js
match (value) {
  when String & { length: 3 }: ...;
}
```

[15:42:23.0066] <rbuckton>
IMO, the only things that shouldn't match `{}` are `null` and `undefined`.

[15:43:07.0395] <ljharb>
+1, TS got this one right

[15:43:27.0054] <rbuckton>
https://tc39.es/proposal-pattern-matching/#sec-object-pattern-matches, every single Step 1.

[15:44:05.0483] <ljharb>
yeah that seems like an oversight.

[15:44:35.0918] <ljharb>
`{ length: 0 }` needs to match an empty string, eg

[15:44:47.0549] <ljharb>
 * `{ length: 0 }` needs to match an empty string, for example

[15:46:04.0572] <rbuckton>
It does mean that restricting things to a spec Object is a bit more complicated, though hopefully that can be handled by `when Object:` even for functions

[15:46:35.0173] <ljharb>
`when Object` indeed must match anything for which `Object(x) === x`

[16:06:43.0074] <rbuckton>
Probably still a little too early for a thorough review of the spec, but I noticed that https://tc39.es/proposal-pattern-matching/#sec-match-expression-clauses-runtime-semantics-evaluation only cares about ECMAScript language values rather than completion values, which doesn't work as it prevents ThrowCompletion from bubbling out of match (or `return`/`break`/`continue` in the event `do` expressions are supported).


2024-04-09
[19:57:09.0263] <Jack Works>
> <@ljharb:matrix.org> `{ length: 0 }` needs to match an empty string, for example

We don't do type coerce, but do we need to do primitive boxing?

[19:57:35.0693] <ljharb>
i mean, we could decide not to. but that would be a radical departure from the rest of the language.

[19:57:58.0090] <ljharb>
if you can do `x.length` on it, and you can do `const { length } = x` on it, you should be able to `{ length }` pattern match on it

[19:58:10.0410] <ljharb>
so i think "consistency with destructuring" forces us to do boxing, full stop

[20:00:10.0273] <Jack Works>
let's decide it next group meeting

[20:00:38.0329] <ljharb>
sure, that's fine, but i'm not clear on what possible argument could justify "different from destructuring"

[20:01:00.0825] <Jack Works>
> <@rbuckton:matrix.org> Probably still a little too early for a thorough review of the spec, but I noticed that https://tc39.es/proposal-pattern-matching/#sec-match-expression-clauses-runtime-semantics-evaluation only cares about ECMAScript language values rather than completion values, which doesn't work as it prevents ThrowCompletion from bubbling out of match (or `return`/`break`/`continue` in the event `do` expressions are supported).

returns either a normal completion containing either an ECMAScript language value or not-matched, or an abrupt completion

[20:01:11.0351] <ljharb>
also MM just posted an issue moments ago, and i'm not sure i understand it, but it seems like it's in direct conflict with the "bindings by default" change we made in response to yulia's feedback

[20:01:12.0910] <Jack Works>
Why do you say so? It contains Abrupt Completion

[20:54:39.0006] <rbuckton>
> <@jackworks:matrix.org> returns either a normal completion containing either an ECMAScript language value or not-matched, or an abrupt completion

Not the return. Step 2 of the 2nd and 3rd productions:

> 1. Let result be ? MatchExpressionClausesEvaluation of MatchExpressionClauses with arguments subject and cacheGroup.
> 2. If result is an ECMAScript language value, return result.
> 3. Return ? MatchExpressionClauseEvaluation of MatchExpressionClause with arguments subject and cacheGroup.

_result_ will never be an ECMAScript language value. We need to check for a normal completion whose value is `not-matched`.

[20:55:14.0495] <rbuckton>
Wait, I'm an idiot. That's handled by 1.

[20:55:44.0179] <rbuckton>
That's what I get for reading spec text on a 5hr car trip.

[20:57:36.0048] <rbuckton>
The use of ReturnIfAbrupt (?) sort of obfuscates the intention, IMO. It was easy to overlook the fact that what we care about is `not-matched`.

[20:58:16.0503] <rbuckton>
Either by explicitly looking for `not-matched`, or by adding an "Assert: _result_ is `not-matched`"

[21:08:49.0321] <Jack Works>
I'll do that next time


2024-04-10
[18:33:13.0268] <rbuckton>
It occurred to me while responding to https://github.com/tc39/proposal-pattern-matching/issues/322 that we could potentially simplify a pattern like `Number and let x` as `Number x`, i.e., treat `Pattern identifer` as `Pattern and let identifier`. You still need `let` for cases where you don't need some other pattern, but it would cut down on repetition in other places:

```js
match (command) {
  [("up" | "down" | "left" | "right") and let direction, Number and let steps]: handleMove(direction, steps);
  ["jump", Number and let howHigh]: jump(howHigh);
}
```

Could be simplified to
```js
match (command) {
  [("up" | "down" | "left" | "right") direction, Number steps]: handleMove(direction, steps);
  ["jump", Number howHigh]: jump(howHigh);
}
```

Though if we did want to support that, I'd almost want it to be a follow on so the community would have time to understand how `let`/`const` patterns work first.

[18:34:32.0950] <rbuckton>
I should note that this is actually somewhat similar to C# variable patterns as well, since C# variable patterns are actually `type identifier`, where `var` is a keyword that means "infer the type".

[18:37:45.0979] <rbuckton>
i.e., `x is string y` and `x is string and var y` are equivalent in C# 8.0

