2024-04-01
[03:05:15.0921] <mpcsh>
hey folks, are we meeting today?

[07:54:23.0997] <ljharb>
Iâ€™m not sure we need to - separately Iâ€™m not feeling well, so Iâ€™ll be late if we are.

[08:25:03.0883] <rbuckton>
I am also not feeling well, so will not be in attendance unless there is a need.


2024-04-04
[08:04:33.0960] <rbuckton>
I'm confused by this example in the README.md, I don't think the 2nd parameter matches the proposed spec text:

```js
RegExp.prototype[Symbol.customMatcher] = function(subject, {matchType}) {
    const result = this.exec(subject);
    if(matchType == "boolean") return result;
    if(matchType == "extractor") return [result, ...result.slice(1)];
}
```
Isn't the 2nd argument just a string, and aren't the possible values `"boolean"` and `"list"`?

[08:12:02.0289] <rbuckton>
Also, I'm not sure I agree with the result for a RegExp custom matcher as suggested here: https://github.com/tc39/proposal-pattern-matching?tab=readme-ov-file#regex-extractor-patterns

To match against a RegExp, you may want to match against either named capture groups, positional capture groups, or the whole match. I think the matcher could just be:

```js
RegExp.prototype[Symbol.customMatcher] = function(subject, hint) {
    const result = this.exec(subject);
    if (hint === "boolean") return !!result;
    if (hint === "list") return result && [result];
}
```
And the pattern would look like:

```
when /(?<left>\d+) \+ (?<right>\d+)/({groups:{let left, let right}}): ...;
when /(\d+) \* (\d+)/([void, let left, let right]): ...;
when /\d+/([let digits]): ...;
```


[08:15:22.0406] <rbuckton>
The extra outputs from `...result.slice(1)` seem like unnecessary overhead for the sake of convenience as I doubt engines will optimize them away if unused.

[13:47:00.0985] <TabAtkins>
I was kinda wanting to be able to do the second and third cases as just `(void, let left, let right)` and `(let digits)` rather than requiring an array pattern as well, but I suppose that's not a big deal, yeah.

[14:03:38.0770] <rbuckton>
`(let digits)` doesn't work if you want to access groups. (at least, not without the abandoned `Foo{ }` syntax).

[14:08:13.0032] <rbuckton>
I'm in the middle of writing some code using C#'s pattern matching, and I may want to bring https://github.com/rbuckton/proposal-shorthand-improvements back at some point. C# has an object initialization syntax that lets you write code like this:
```cs
var a = new Foo() {
  Bar = 1,
  Baz.Quxx = 2,
}
```
which amounts to
```cs
var a = new Foo();
a.Bar = 1;
a.Baz.Quxx = 2;
```

and `{ Baz.Quxx = 2 }` is essentially the same as `{ Baz = { Quxx = 2 } }`.

[14:09:44.0076] <rbuckton>
And unnamed types can be `new { Bar, Baz.Quxx }` which is essentially `new { Bar = Bar, Quxx = Baz.Quxx }`. 

[14:10:31.0242] <rbuckton>
Apparently they have a similar shorthand syntax for pattern matching, `x is { Bar: 1, Baz.Quxx: 2 }`, which is the same as `x is { Bar: 1, Baz: { Quxx: 2 } }`.

[14:11:47.0372] <rbuckton>
Definitely not an MVP feature, but the deep property pattern seems potentially valuable and we're already parsing dotted names for extractors.

[14:12:36.0879] <rbuckton>
 * I'm in the middle of writing some code using C#'s pattern matching and ran into an interesting mechanism. C# has an object initialization syntax that lets you write code like this:

```cs
var a = new Foo() {
  Bar = 1,
  Baz.Quxx = 2,
}
```

which amounts to

```cs
var a = new Foo();
a.Bar = 1;
a.Baz.Quxx = 2;
```

and `{ Baz.Quxx = 2 }` is essentially the same as `{ Baz = { Quxx = 2 } }`.

[14:44:54.0886] <TabAtkins>
yeah, not an mvp, but that's definitely something we might want to do in the future


2024-04-05
[08:15:00.0655] <Jack Works>
> The pattern-matching champion group designed this proposal with a layering approach. It does not mean the proposal is an MVP. The champion group wishes to ship the proposal as a whole when possible, but we can drop some features if there is strong pushback from the committee.

> This approach allows the champion group to consider how all features combine and also how the proposal should behave if any of the features are missing.

 I hope this is the consensus, am I wrong? MVP may leads to another class design in my pov


2024-04-08
[15:41:38.0996] <rbuckton>
In the proposal `{}` explicitly matches `Object`, but destructuring does not. By restricting `{}` to `Object` you can't have patterns like

```js
match (value) {
}

[15:41:49.0408] <rbuckton>
 * In the proposal `{}` explicitly matches `Object`, but destructuring does not. By restricting `{}` to `Object` you can't have patterns like

```js
match (value) {
  when String & { length: 3 }: ...;
}
```

[15:42:23.0066] <rbuckton>
IMO, the only things that shouldn't match `{}` are `null` and `undefined`.

[15:43:07.0395] <ljharb>
+1, TS got this one right

[15:43:27.0054] <rbuckton>
https://tc39.es/proposal-pattern-matching/#sec-object-pattern-matches, every single Step 1.

[15:44:05.0483] <ljharb>
yeah that seems like an oversight.

[15:44:35.0918] <ljharb>
`{ length: 0 }` needs to match an empty string, eg

[15:44:47.0549] <ljharb>
 * `{ length: 0 }` needs to match an empty string, for example

[15:46:04.0572] <rbuckton>
It does mean that restricting things to a spec Object is a bit more complicated, though hopefully that can be handled by `when Object:` even for functions

[15:46:35.0173] <ljharb>
`when Object` indeed must match anything for which `Object(x) === x`

[16:06:43.0074] <rbuckton>
Probably still a little too early for a thorough review of the spec, but I noticed that https://tc39.es/proposal-pattern-matching/#sec-match-expression-clauses-runtime-semantics-evaluation only cares about ECMAScript language values rather than completion values, which doesn't work as it prevents ThrowCompletion from bubbling out of match (or `return`/`break`/`continue` in the event `do` expressions are supported).


2024-04-09
[19:57:09.0263] <Jack Works>
> <@ljharb:matrix.org> `{ length: 0 }` needs to match an empty string, for example

We don't do type coerce, but do we need to do primitive boxing?

[19:57:35.0693] <ljharb>
i mean, we could decide not to. but that would be a radical departure from the rest of the language.

[19:57:58.0090] <ljharb>
if you can do `x.length` on it, and you can do `const { length } = x` on it, you should be able to `{ length }` pattern match on it

[19:58:10.0410] <ljharb>
so i think "consistency with destructuring" forces us to do boxing, full stop

[20:00:10.0273] <Jack Works>
let's decide it next group meeting

[20:00:38.0329] <ljharb>
sure, that's fine, but i'm not clear on what possible argument could justify "different from destructuring"

[20:01:00.0825] <Jack Works>
> <@rbuckton:matrix.org> Probably still a little too early for a thorough review of the spec, but I noticed that https://tc39.es/proposal-pattern-matching/#sec-match-expression-clauses-runtime-semantics-evaluation only cares about ECMAScript language values rather than completion values, which doesn't work as it prevents ThrowCompletion from bubbling out of match (or `return`/`break`/`continue` in the event `do` expressions are supported).

returns either a normal completion containing either an ECMAScript language value or not-matched, or an abrupt completion

[20:01:11.0351] <ljharb>
also MM just posted an issue moments ago, and i'm not sure i understand it, but it seems like it's in direct conflict with the "bindings by default" change we made in response to yulia's feedback

[20:01:12.0910] <Jack Works>
Why do you say so? It contains Abrupt Completion

[20:54:39.0006] <rbuckton>
> <@jackworks:matrix.org> returns either a normal completion containing either an ECMAScript language value or not-matched, or an abrupt completion

Not the return. Step 2 of the 2nd and 3rd productions:

> 1. Let result be ? MatchExpressionClausesEvaluation of MatchExpressionClauses with arguments subject and cacheGroup.
> 2. If result is an ECMAScript language value, return result.
> 3. Return ? MatchExpressionClauseEvaluation of MatchExpressionClause with arguments subject and cacheGroup.

_result_ will never be an ECMAScript language value. We need to check for a normal completion whose value is `not-matched`.

[20:55:14.0495] <rbuckton>
Wait, I'm an idiot. That's handled by 1.

[20:55:44.0179] <rbuckton>
That's what I get for reading spec text on a 5hr car trip.

[20:57:36.0048] <rbuckton>
The use of ReturnIfAbrupt (?) sort of obfuscates the intention, IMO. It was easy to overlook the fact that what we care about is `not-matched`.

[20:58:16.0503] <rbuckton>
Either by explicitly looking for `not-matched`, or by adding an "Assert: _result_ is `not-matched`"

[21:08:49.0321] <Jack Works>
I'll do that next time


2024-04-10
[18:33:13.0268] <rbuckton>
It occurred to me while responding to https://github.com/tc39/proposal-pattern-matching/issues/322 that we could potentially simplify a pattern like `Number and let x` as `Number x`, i.e., treat `Pattern identifer` as `Pattern and let identifier`. You still need `let` for cases where you don't need some other pattern, but it would cut down on repetition in other places:

```js
match (command) {
  [("up" | "down" | "left" | "right") and let direction, Number and let steps]: handleMove(direction, steps);
  ["jump", Number and let howHigh]: jump(howHigh);
}
```

Could be simplified to
```js
match (command) {
  [("up" | "down" | "left" | "right") direction, Number steps]: handleMove(direction, steps);
  ["jump", Number howHigh]: jump(howHigh);
}
```

Though if we did want to support that, I'd almost want it to be a follow on so the community would have time to understand how `let`/`const` patterns work first.

[18:34:32.0950] <rbuckton>
I should note that this is actually somewhat similar to C# variable patterns as well, since C# variable patterns are actually `type identifier`, where `var` is a keyword that means "infer the type".

[18:37:45.0979] <rbuckton>
i.e., `x is string y` and `x is string and var y` are equivalent in C# 8.0

[18:46:53.0225] <rbuckton>
 * It occurred to me while responding to https://github.com/tc39/proposal-pattern-matching/issues/322 that we could potentially simplify a pattern like `Number and let x` as `Number x`, i.e., treat `Pattern identifer` as `Pattern and let identifier`. You still need `let` for cases where you don't need some other pattern, but it would cut down on repetition in other places:

```js
match (command) {
  [("up" or "down" or "left" or "right") and let direction, Number and let steps]: handleMove(direction, steps);
  ["jump", Number and let howHigh]: jump(howHigh);
}
```

Could be simplified to

```js
match (command) {
  [("up" or "down" or "left" or "right") direction, Number steps]: handleMove(direction, steps);
  ["jump", Number howHigh]: jump(howHigh);
}
```

Though if we did want to support that, I'd almost want it to be a follow on so the community would have time to understand how `let`/`const` patterns work first.

[22:30:24.0352] <ljharb>
with the recent github discussions i'm wondering if we even want to present pattern matching this meeting :-/ certainly we won't be asking for stage 2

[04:24:18.0943] <dminor>
Please don't ask for Stage 2, we share the concerns about complexity and at the very least need more time to evaluate the proposal as it stands.

[04:25:11.0247] <dminor>
I'll open an issue with some of my questions / concerns. We also have a team work week next week, and I'm hoping to do a deep dive on this proposal and get more feedback then.

[05:17:05.0002] <rkirsling>
would be interested in knowing whether the issue I had written up resonates for your team

[06:40:19.0073] <ljharb>
also i donâ€™t have any slides from TabAtkins yet. anyone object to me removing pattern matching from the agenda?

[06:49:10.0856] <rbuckton>
In general I think it would be better to remove all of the syntax that is contentious from the proposal spec text, there's just way too much in there we don't have consensus on. Put the optional or contentious things in its own document to make the spec less intimidating.

[06:56:30.0289] <rbuckton>
For example, `?`/`has`/`hasOwn` look interesting as a follow-on, but maybe not MVP since they each can be solved in different ways. Maybe even RegExp patterns, considering the potential parser ambiguities, and can still be handled via an extractor by pulling the RegExp out of the pattern. Even relational patterns, despite my preference for inclusion, are not necessarily an MVP -- C# did not include them in their initial support for pattern matching either. Put all of these and anything else we lack consensus on into a separate document we can refer to regarding future capabilities, so that we can be sure we're considering them in the design space.'

[06:56:31.0946] <rbuckton>
 * For example, `?`/`has`/`hasOwn` look interesting as a follow-on, but maybe not MVP since they each can be solved in different ways. Maybe even RegExp patterns, considering the potential parser ambiguities, and can still be handled via an extractor by pulling the RegExp out of the pattern. Even relational patterns, despite my preference for inclusion, are not necessarily an MVP -- C# did not include them in their initial support for pattern matching either. Put all of these and anything else we lack consensus on into a separate document we can refer to regarding future capabilities, so that we can be sure we're considering them in the design space.

[06:59:23.0286] <rbuckton>
I don't think `match(v) {}` and `is` are themselves a tough sell, despite cover grammar issues to work out. The pattern syntax is what's expansive and needs to be paired down, so long as we ensure we continue to maintain the pattern matching invariants we've established.

[07:02:21.0776] <Jack Works>
> <@ljharb:matrix.org> also i donâ€™t have any slides from TabAtkins yet. anyone object to me removing pattern matching from the agenda?

do we need to still share updates, but not asking for stage 2

[07:03:18.0502] <ljharb>
i donâ€™t know if thereâ€™s even a point in sharing updates yet - itâ€™ll just invite debate on things weâ€™re likely to still change

[07:13:28.0086] <dminor>
i kind of think it would be best to skip the update, we're seeing good conversations on github already

[07:35:05.0889] <ljharb>
ok, removing it

[08:12:08.0397] <Jack Works>
ðŸ« 

[08:12:31.0754] <ljharb>
maybe in finland

[08:12:37.0985] <ljharb>
 * maybe we can present at the finland meeting

[08:15:04.0907] <Jack Works>
looks like the only way for proposals to get outside reviews is to put it on the agenda asking for an advance

[08:15:15.0479] <Jack Works>
this is unhealthy

[08:16:39.0171] <ljharb>
i mean in this case we kind of discouraged outside reviews until that time

