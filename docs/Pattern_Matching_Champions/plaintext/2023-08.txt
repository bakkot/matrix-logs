2023-08-07
[08:10:38.0946] <TabAtkins>
We didn't make useful quorum for the meeting, so offline ping: a couple of people wanted to take the gist back to their team to discuss before we made a final yay/nay on updating the proposal in the repo. Does anyone object to moving forward with this?


2023-08-08
[21:02:02.0099] <ljharb>
i've been traveling and haven't really had a chance to fully review the gist; i'll be back on the 10th. maybe we could plan to move forward early next week?


2023-08-16
[15:03:47.0722] <ljharb>
TabAtkins: gist review:
 - `plain-or-dotted-ident` presumably includes brackets and optional things and whatever, the same stuff a decorator allows after `@`?
 - for `<plain-or-dotted-ident>(<matcher-list>)`, what happens if it's a function that does not have a Symbol.matcher property?
 - i really like the desugaring example for `is`, but that falls apart with the bindings bit, and that makes me nervous
 - for bindings in an `if` does it also apply to an `else if` and every other else in the chain?

does the gist already incorporate all the discussion at the bottom of it?

 - there should not be an optin for regex named group bindings, since they're statically mentioned it's not the same as `with`. if someone doesn't want the bindings they just don't have to reference them.

[15:04:21.0061] <ljharb>
 * TabAtkins: gist review:

- `plain-or-dotted-ident` presumably includes brackets and optional things and whatever, the same stuff a decorator allows after `@`?
- for `<plain-or-dotted-ident>(<matcher-list>)`, what happens if it's a function that does not have a Symbol.matcher property?
- i really like the desugaring example for `is`, but that falls apart with the bindings bit, and that makes me nervous
- for bindings in an `if` does it also apply to an `else if` and every other else in the chain?

does the gist already incorporate all the discussion at the bottom of it?

- there should not be an optin for regex named group bindings, since they're statically mentioned it's not the same as `with`. if someone doesn't want the bindings they just don't have to reference them.

I like the name `Symbol.matcher` and since nobody knows about or uses `Symbol.match` i think it'd be a shame to pick a worse name for our symbol :-(

[15:04:40.0242] <ljharb>
 * TabAtkins: gist review:

- `plain-or-dotted-ident` presumably includes brackets and optional things and whatever, the same stuff a decorator allows after `@`?
- for `<plain-or-dotted-ident>(<matcher-list>)`, what happens if it's a function that does not have a Symbol.matcher property?
- i really like the desugaring example for `is`, but that falls apart with the bindings bit, and that makes me nervous
- for bindings in an `if` does it also apply to an `else if` and every other else in the chain?

does the gist already incorporate all the discussion at the bottom of it?

- there should not be an optin for regex named group bindings, since they're statically mentioned it's not the same as `with`. if someone doesn't want the bindings they just don't have to reference them.

I like the name `Symbol.matcher` and since nobody knows about or uses `Symbol.match` i think it'd be a shame to pick a worse name for our symbol :-( I very much do *not* want :"unapply" and think that would be a very confusing choice.


2023-08-17
[22:49:04.0623] <Jack Works>
based on my understanding:
- yes, it's the same as what the decorator has
- maybe it throws for things that don't have @@matcher
- no comment
- yes, and in TDZ if the match fails

[09:25:52.0421] <ljharb>
if the match fails why would you want the bindings available in the else, since they can't ever work?

[13:24:19.0334] <rbuckton>
> <@ljharb:matrix.org> TabAtkins: gist review:
> 
> - `plain-or-dotted-ident` presumably includes brackets and optional things and whatever, the same stuff a decorator allows after `@`?
> - for `<plain-or-dotted-ident>(<matcher-list>)`, what happens if it's a function that does not have a Symbol.matcher property?
> - i really like the desugaring example for `is`, but that falls apart with the bindings bit, and that makes me nervous
> - for bindings in an `if` does it also apply to an `else if` and every other else in the chain?
> 
> does the gist already incorporate all the discussion at the bottom of it?
> 
> - there should not be an optin for regex named group bindings, since they're statically mentioned it's not the same as `with`. if someone doesn't want the bindings they just don't have to reference them.
> 
> I like the name `Symbol.matcher` and since nobody knows about or uses `Symbol.match` i think it'd be a shame to pick a worse name for our symbol :-( I very much do *not* want :"unapply" and think that would be a very confusing choice.

Regarding `plain-or-dotted-ident` including brackets and optional things: No, it does not at present. Decorators also do not support optional chaining or brackets. Optional chaining might be feasible with decorators, but brackets are ambiguous with `ComputedPropertyName`, thus you must use parens to use them, i.e., `@(foo[bar])`.

I didn't include element-access-like brackets in Extractors since there were some potential *AssignmentPattern* conflicts I was considering at the time.

[13:47:01.0119] <ljharb>
ok, as long as it matches decorators Iâ€™m sure itâ€™s fine


2023-08-18
[08:44:40.0467] <Jack Works>
syntax is a hard thing huh


2023-08-21
[01:50:20.0670] <mpcsh>
hey friends, I am recovering from an anaphylactic reaction and will unfortunately have to miss tomorrow

[08:03:38.0808] <ljharb>
ron and i are waiting in the zoom; is anyone else coming?

[08:04:50.0694] <rbuckton>
I'm not sure what the agenda is for today, but I may need to drop early as I'm driving my daughter up to college this afternoon and have to leave around noon.

[08:07:12.0453] <TabAtkins>
Whoops I forgot about meeting, coming in now.

[08:07:53.0305] <TabAtkins>
Agenda is talking over Jordan's thoughts, I believe, and anyone else who has final comments before we pull the trigger

[08:10:10.0659] <TabAtkins>
Christ on a cracker the auth for Mozilla's instance is annoying

[08:10:48.0653] <TabAtkins>
I tried logging in with GitHub now it's trapped in a "you don't have access, fuck off" loop

[08:12:01.0210] <ljharb>
oof

[08:12:13.0385] <ljharb>
i think you could just join without being logged in

[08:12:35.0637] <TabAtkins>
You cannot

[08:12:47.0819] <ljharb>
hm, i did

[08:12:58.0864] <TabAtkins>
Not from the link in the calendar, at least

[08:13:44.0779] <TabAtkins>
I'm almost certain you didn't, I get bugged for auth no matter what way I try to log in

[08:14:03.0916] <TabAtkins>
I'm using a diff computer, almost there

[08:44:32.0434] <TabAtkins>
Discussion notes at https://gist.github.com/tabatkins/51f35f88d7eea61d9ecbe3e82da817a5?permalink_comment_id=4667292#gistcomment-4667292

[08:44:49.0729] <TabAtkins>
Summary: rough group consensus, I'll write up a PR updating the proposal this week and ping the group for review.


2023-08-22
[19:08:53.0034] <rkirsling>
I think I got really bummed out when we had a proposal going and then suddenly it was like "nope, back to the drawing board"

[19:13:13.0792] <rkirsling>
being in this space has shown me how freeform imagining of the design of hypothetical JS features is stress and not joy to me

[19:16:27.0680] <rkirsling>
so I've just been keeping space until there's something concrete again

[21:19:21.0720] <rbuckton>
I think the current proposal is very close to the original, solving many of the problems discussed without wholly reinventing the syntax. 

[22:43:51.0950] <rkirsling>
cool

[22:44:12.0595] <rkirsling>
looking forward to the PR ðŸ™‡

[13:00:44.0413] <TabAtkins>
yeah the changes are actually quite minor overall. just rejiggering a few bits to be consistent in a different way, and consistent with some planned future features.


2023-08-29
[11:02:52.0524] <TabAtkins>
I'm writing up the PR now, and I'm suddenly struck by an idea: instead of `when` as the branch introducer, should we use `is`? That makes it perfectly match up with the boolean form, just with an implicit LHS coming from the match block itself.

[11:03:55.0685] <TabAtkins>
that is:
```js
match(foo) {
  is [let a]: ...;
  is {bar}: ...;
  default: ...;
}
```

[11:04:12.0758] <TabAtkins>
which syncs up with saying `foo is [let a]` outside of the match construct

[13:03:21.0106] <ljharb>
that's not bad, but there's a distinct difference wrt bindings

[13:03:48.0733] <ljharb>
also "is" and "default" don't pair very well imo

[13:43:02.0124] <TabAtkins>
I think they pair up as well as when/default or case/default?

[13:43:41.0659] <TabAtkins>
What's the binding difference you're referring to? In each match-statement clause the bindings are visible to just that clause.

[13:43:54.0065] <ljharb>
`x is y` doesn't produce bindings by itself

[13:44:03.0904] <TabAtkins>
Yeah it does.

[13:45:03.0365] <TabAtkins>
At least, that was the idea. And then we just have scoping rules in if/for/etc to contain those bindings appropriately.

[13:45:22.0281] <ljharb>
O.o i didn't realize that

[13:45:32.0768] <ljharb>
i thought `is` was just like `instanceof`, a boolean operator with no side effects

[13:45:44.0485] <ljharb>
i thought it was *only* when attached to a block that it produced bindings

[13:46:30.0389] <TabAtkins>
Well huh I suppose I didn't write that part into the proposal gist. I'm happier to *not* do that, fwiw.

[13:46:46.0392] <ljharb>
i think it would be *super* weird for a lone boolean test to produce bindings

[13:46:54.0306] <TabAtkins>
But that still doesn't impact the usage here - each branch is a conditional *thing* and would have the same sort of binding behavior.

[13:47:02.0107] <ljharb>
you'd be able to like
```
{
   x is y;
}
```

[13:47:07.0109] <ljharb>
 * you'd be able to like

```
{
   x is y;
   /* bindings here */
}
```

[13:47:15.0185] <TabAtkins>
and x would be y after that, yeah ^_^

[13:47:22.0952] <ljharb>
right, that seems actively bad

[13:47:40.0374] <ljharb>
bindings in match are obviously critical, and they make sense in the specific constructs we discussed

[13:48:00.0739] <ljharb>
so having it be spelled "is" in match isn't inherently a problem, because "in match" is a separate context

[13:48:16.0170] <TabAtkins>
Anyway yeah I'll omit that, I haven't written the bindings section yet. But in a match(), each branch is essentially an if(), and you get bindings there, so it seems consistent.

[13:48:23.0629] <ljharb>
yeah i agree with that part

[13:49:10.0194] <ljharb>
if/default is the same amount of _objectionable_ to me as when/default, but i think when/default pairs more smoothly than is/default, and would love to explore other names (even if only within the champion group) for "default"

[13:49:12.0742] <ljharb>
 * if/default is the same amount of _objectionable_ to me as when/default, but i think when/default pairs more smoothly than is/default, and would love to explore other names (even if only within the champion group) for "default" with "is"

[13:49:40.0348] <ljharb>
(separately, it'd be really cool if `x is y` and `x is not y` both worked)

[13:50:01.0177] <TabAtkins>
they do both work, yeah

[13:50:06.0928] <TabAtkins>
`not y` is a valid pattern

[13:52:08.0192] <ljharb>
oh score

[13:52:40.0497] <ljharb>
ok well that is glorious and also fits nicely with `x not instanceof y` and `x not in y` if someone were to propose those in the future :-D


2023-08-30
[17:11:40.0647] <rbuckton>
> <@ljharb:matrix.org> i think it would be *super* weird for a lone boolean test to produce bindings

`is` introducing bindings is this proposals version of `if let` in Rust. It's extremely valuable in control flow and loops. 

[17:20:25.0543] <rbuckton>
It's more obviously useful when paired with something complex like extractors, i.e.:

```js
if (x is Option.Some(let value)) {
  // 'value' is in scope
}
else {
}
```
But is also useful in conditionals:

```js
const res = x is Option.Some(let value) ? Option.Some(compute(value)) : Option.None;
```

Because `let` bindings are just a pattern, they're fairly flexible:

```js
while (queue.shift() is { name: let jobName, arguments: let jobArgs }) {
  processJob(jobName, jobArgs);  
}
```



[18:05:49.0849] <rbuckton>
> <@ljharb:matrix.org> you'd be able to like
> 
> ```
> {
>    x is y;
>    /* bindings here */
> }
> ```

`x is y` doesn't produce a binding. `x is let y` would, but that's not the common case.

[18:17:59.0730] <ljharb>
hmm ok

[18:18:12.0839] <ljharb>
Iâ€™m fine with it working in the positive branch of ternaries fwiw

[18:18:36.0840] <ljharb>
but Iâ€™d expect the bare expression form to forbid let/const

