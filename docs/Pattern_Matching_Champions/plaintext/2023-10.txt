2023-10-02
[07:42:03.0157] <TabAtkins>
I'll be a few minutes late to the meeting this morning

[08:49:53.0499] <TabAtkins>
Notes from today's meeting: https://github.com/tc39/proposal-pattern-matching/issues/302

[13:34:48.0562] <TabAtkins>
Opened a new issue about Matthew's perf concern about extractor vs variable custom matchers: https://github.com/tc39/proposal-pattern-matching/issues/303


2023-10-03
[19:01:56.0681] <rkirsling>
> <@rkirsling:matrix.org> in theory you could keep nesting `is ... if (...)`s

I think this point may have been overlooked in the discussion about `is` and `if` 

[19:03:39.0464] <rkirsling>
this really is something that arises from the combination of the two

[19:06:49.0600] <rkirsling>
though I guess it's not exclusive to `if` _patterns_; it's mostly something that happens due to `is` existing

[19:07:50.0334] <rkirsling>
though as Ron mentioned immediately above, the spelling of `if` pattterns/guards as `if` is the compounding factors

[19:07:51.0600] <rkirsling>
 * though as Ron mentioned immediately above, the spelling of `if` pattterns/guards as `if` is the compounding factor

[19:08:10.0285] <rkirsling>
 * I guess it's not exclusive to `if` _patterns_; it's mostly something that happens due to `is` existing, but

[19:08:13.0755] <rkirsling>
 * as Ron mentioned immediately above, the spelling of `if` pattterns/guards as `if` is the compounding factor

[19:11:03.0512] <rkirsling>
basically
```
if (... is ... if (... is ... if (...)))
    if (...)
        return;
```
would be our new world of JS

[19:11:15.0627] <rkirsling>
 * basically

```
if (... is ... if (... is ... if (...)))
    if (...)
        return;
```

would be valid in our proposed world

[19:12:59.0535] <Jack Works>
syntactically valid does not mean developers must write that. otherwise `throw throw x` should also be banned 

[19:13:27.0416] <rkirsling>
that's not a counterargument

[19:18:36.0706] <rkirsling>
it would be completely negligent to not have a thorough discussion about such a case

[19:20:25.0203] <rkirsling>
the crux is that it would be extremely easy to write code in one can't easily tell what construct `if (...)` is

[19:21:39.0422] <rkirsling>
 * the crux is that it would be extremely easy to write code in which one can't easily tell what construct `if (...)` is

[19:22:28.0208] <Jack Works>
but both if statement and if pattern accept an expression and evaluate it and do truthy test

[19:22:55.0827] <Jack Works>
it's not so important to distinguish them, because they have the same semantics 

[19:23:50.0370] <rkirsling>
they absolutely do not have the same semantics; one is a control flow construct and one is a subexpression

[19:34:57.0263] <rkirsling>
 * they absolutely do not have the same semantics; one is a control flow construct and one is a boolean subexpression

[01:12:08.0203] <ljharb>
fwiw i'm strongly opposed to dropping `when` entirely

[01:12:26.0876] <ljharb>
also is matthew mathieu?

[01:12:52.0119] <ljharb>
 * fwiw i'm strongly opposed to dropping `when` entirely (but am flexible on spelling)

[01:15:49.0297] <ljharb>
also i commented on the perf concern on the issue; tldr, this isn't a thing that's usually a problem and not something we should be concerned about

[08:08:04.0473] <mgaudet>
it me.

[08:08:10.0738] <mgaudet>
I am implementer. Raising concern. 

[08:08:17.0634] <mgaudet>
FWIW

[08:09:07.0289] <mgaudet>
The iterator protocol is hard to optimize, and I'm trying to provide feedback that will result in a performant proposal 

[08:09:17.0930] <mgaudet>
or, at least have the -potential- to be performant

[08:49:18.0682] <rbuckton>
I think it's fine to pay the cost for classes, but maybe we just don't support unboxing for primitives. Either that, or we distinguish between `x is String` and `x is String()` somehow. Different symbol methods maybe? 

[10:59:55.0143] <TabAtkins>
Yeah that was my suggestion in the issue. 

[11:00:39.0011] <TabAtkins>
I assume that authors will similarly run into issues where constructing the iterator's contents might be expensive, and want to avoid doing that when the user is just calling `Foo` for a typecheck.

[11:03:36.0703] <TabAtkins>
> <@rkirsling:matrix.org> the crux is that it would be extremely easy to write code in which one can't easily tell what construct `if (...)` is

I think this is relevant if it's *easy* to write code like that and there is *benefit* to doing it, such that we can expect it to be a somewhat common pattern among authors. If it's just *possible* but *fairly silly* to write such code, then so long as the behavior is well-defined and not too surprising it's not something we need to worry about, imo. People can do *lots* of very silly things in their code; this is far from the only place where authors can nest to ridiculous degrees if they feel like it, and make their code hard to understand.

[11:07:08.0636] <TabAtkins>
For example, one can similarly nest IIAFEs into their if(), or deeply nested ternaries, both of which can be quite difficult to puzzle out. But there's rarely, if ever, a reason to do so, so we don't worry about it; the behavior is well-defined and, if you can follow the expression tree, unsurprising.

[13:55:37.0998] <TabAtkins>
ljharb: I'm resolving all your whitespace changes without merging them; I don't think there is remotely a common standard on this, and I have written code in this way my entire life.

[14:00:18.0084] <TabAtkins>
> <@ljharb:matrix.org> fwiw i'm strongly opposed to dropping `when` entirely (but am flexible on spelling)

Can you elaborate on this? What is your opposition?

[14:01:04.0497] <TabAtkins>
And notably, what in your mind distinguishes JS from most other languages which lack a clause-introducing keyword in their syntax?

[16:04:44.0245] <ljharb>
> <@mgaudet:mozilla.org> I am implementer. Raising concern. 

aha thanks, that clarifies :-)

[16:05:17.0573] <ljharb>
> <@rbuckton:matrix.org> I think it's fine to pay the cost for classes, but maybe we just don't support unboxing for primitives. Either that, or we distinguish between `x is String` and `x is String()` somehow. Different symbol methods maybe? 

i think it’s extremely important to unbox primitives by default; it’s a mistake the language makes that so difficult already.

[16:06:02.0026] <ljharb>
> <@tabatkins:matrix.org> Can you elaborate on this? What is your opposition?

i think it’s very valuable to have a clear syntactic marker for the start of a clause. (a word is clear, a token likely isn’t)

[16:06:53.0673] <TabAtkins>
Why do you think we need a marker beyond "start of the line"? the obvious formatting will make this very clear when read.

[16:07:18.0782] <rbuckton>
It's my impression that most TC39 members believe that boxing primitives is a bad idea to begin with, so I'm not sure interacting with boxing is a benefit if it might encourage it's use even more

[16:07:41.0185] <ljharb>
> <@tabatkins:matrix.org> And notably, what in your mind distinguishes JS from most other languages which lack a clause-introducing keyword in their syntax?

i care zero for other languages; i think our bar should be higher than that. Private fields, for example, avoids repeating a mistake every other language makes by making them actually private and not reflectable.

[16:07:59.0719] <ljharb>
> <@rbuckton:matrix.org> It's my impression that most TC39 members believe that boxing primitives is a bad idea to begin with, so I'm not sure interacting with boxing is a benefit if it might encourage it's use even more

absolutely, but this helps *reduce* boxing

[16:08:21.0923] <ljharb>
> <@tabatkins:matrix.org> Why do you think we need a marker beyond "start of the line"? the obvious formatting will make this very clear when read.

one thing JS has objectively demonstrated is that there’s no obvious formatting, ever

[16:08:37.0768] <rbuckton>
> <@ljharb:matrix.org> absolutely, but this helps *reduce* boxing

No it makes it easier to unbox. If that feature isn't there, then you must manually unbox, which discourages boxing.

[16:09:24.0035] <ljharb>
> <@rbuckton:matrix.org> No it makes it easier to unbox. If that feature isn't there, then you must manually unbox, which discourages boxing.

that’s a false conclusion. If someone boxes a primitive it’s because they don’t know any better, not because of the ease of unboxing. Also, the value you’re testing is highly likely not to be one you control or create.

[16:09:34.0903] <TabAtkins>
lol I think "start clauses on a new line, indent wrapped" if extremely obvious and if you do anything else you're hurting yourself in a way that we don't need to help you avoid.

[16:09:49.0462] <rbuckton>
> <@ljharb:matrix.org> i care zero for other languages; i think our bar should be higher than that. Private fields, for example, avoids repeating a mistake every other language makes by making them actually private and not reflectable.

The ability to reflect over private fields in in some languages is based on an established trust relationship. Unprivileged code in .NET cannot reflect over private fields.

[16:10:04.0803] <ljharb>
> <@tabatkins:matrix.org> lol I think "start clauses on a new line, indent wrapped" if extremely obvious and if you do anything else you're hurting yourself in a way that we don't need to help you avoid.

i agree with your sensibilities but not that people are rational enough in aggregate for that to hold.

[16:10:37.0137] <rbuckton>
> <@ljharb:matrix.org> i care zero for other languages; i think our bar should be higher than that. Private fields, for example, avoids repeating a mistake every other language makes by making them actually private and not reflectable.

I also don't agree what introducing a keyword sets a higher bar, it introduces unnecessary and avoidable repetition.

[16:10:41.0131] <TabAtkins>
the unboxing primitives discussion is a red herring - the point is that the built-in matchers are slightly expensive (and author-provided ones can potentially be more expensive), which is an annoying cost to pay when we're going to immediately throw away the value anyway because all we care about is "not false"

[16:10:46.0267] <rbuckton>
> <@ljharb:matrix.org> i care zero for other languages; i think our bar should be higher than that. Private fields, for example, avoids repeating a mistake every other language makes by making them actually private and not reflectable.

 * I also don't agree that introducing a keyword sets a higher bar, it introduces unnecessary and avoidable repetition.

[16:11:09.0606] <ljharb>
I’m very open to flexibility in the custom matcher protocol return value, to be clear

[16:11:16.0749] <ljharb>
i don’t think a second protocol makes any sense at all

[16:11:42.0944] <ljharb>
what I’m not open to is unnecessarily restrictive semantics for builtin primitives

[16:12:45.0894] <ljharb>
i don’t see how an internal slot check is hard to optimize; many prototype methods check it, on strings also.

[16:12:54.0475] <rbuckton>
> <@ljharb:matrix.org> i don’t think a second protocol makes any sense at all

Extractors are unary functions by design. If you want to control the return value somehow, you really shouldn't be doing that via an extra argument, IMO.

[16:13:04.0457] <ljharb>
and if it’s hard for userland code to match that, all the more reason for host code to have it available

[16:13:24.0415] <ljharb>
> <@rbuckton:matrix.org> Extractors are unary functions by design. If you want to control the return value somehow, you really shouldn't be doing that via an extra argument, IMO.

I’m sure there’s more nuance here we can discuss next meeting when I’m not still traveling.

[16:16:21.0299] <TabAtkins>
> <@ljharb:matrix.org> i don’t see how an internal slot check is hard to optimize; many prototype methods check it, on strings also.

I'm confused; that's not the cost being mentioned. It's the cost of creating a temp array (and for userland code, the potentially unbounded cost of constructing what goes in the array).

[16:16:52.0996] <ljharb>
ok so that’s about the return value, which has nothing necessarily to do with the semantics. i agree that it’d be nice to avoid that 

[16:17:17.0502] <ljharb>
however that same concern just came up last week wrt iterator joining, and nobody seemed worried about it

[16:17:33.0652] <TabAtkins>
Right. `Foo` will *always* ignore the return value other than checking if it's false or not, so incurring the cost of actually building the return value is unfortunate. Thus the pair of protocols.

[16:17:35.0737] <ljharb>
so I’m confused why mgaudet thinks a throwaway array is expensive here but fine in dozens of other places

[16:17:58.0444] <ljharb>
adding a new protocol seems way more expensive than a temp array imo

[16:18:14.0112] <TabAtkins>
Those are completely different types of cost; I don't see the connection.

[16:18:28.0866] <ljharb>
but since is produces bindings I’m not sure when it’s ever just a “test”

[16:18:38.0558] <TabAtkins>
???

[16:19:06.0319] <TabAtkins>
I'm talking about the pattern `Foo`, as opposed to the pattern `Foo(...)`.

[16:19:32.0352] <ljharb>
i think this will need to wait til we can discuss sync to clarify 

[16:19:37.0218] <TabAtkins>
Right now they both invoke the same method, but the former throws away the return value.

[16:19:49.0098] <TabAtkins>
Yeah, I'm *super* confused as to what you're actually talking about, ljharb ^_^

[16:20:23.0789] <ljharb>
the issue you filed and the notes summary cover multiple “conclusions”, some of which i strongly oppose, so we’re probably talking past each other


2023-10-04
[17:00:53.0951] <rkirsling>
> <@tabatkins:matrix.org> I think this is relevant if it's *easy* to write code like that and there is *benefit* to doing it, such that we can expect it to be a somewhat common pattern among authors. If it's just *possible* but *fairly silly* to write such code, then so long as the behavior is well-defined and not too surprising it's not something we need to worry about, imo. People can do *lots* of very silly things in their code; this is far from the only place where authors can nest to ridiculous degrees if they feel like it, and make their code hard to understand.

I don't really understand how to interact with this group when the response to my concerns is to pretend they don't exist

[17:02:00.0098] <rkirsling>
Tweeting "have you tried just not writing bad code?" is already not going to be a way to win friends when we're talking about _existing_ features 

[17:02:07.0268] <TabAtkins>
I'm not doing that? I'm providing my own reasoning.

[17:02:21.0337] <rkirsling>
This is a new feature; it needs to justify its own existencr

[17:02:29.0734] <rkirsling>
* This is a new feature; it needs to justify its own existence

[17:03:39.0152] <TabAtkins>
Like, I provided significant qualifications to my statement. I think they all apply here, and justify my judgement that is okay. If you disagree, feel free to say why! Especially if you feel any of my assumptions don't hold, it perhaps don't hold as strongly as I might think they do.

[17:04:24.0232] <TabAtkins>
* Like, I provided significant qualifications to my statement. I think they all apply here, and justify my judgement that is okay. If you disagree, feel free to say why! Especially if you feel any of my assumptions don't hold, or perhaps don't hold as strongly as I might think they do.

[17:07:06.0902] <TabAtkins>
An issue is that I think your objection, as stated, is a fully general counter argument to any new feature that can be nested; you can always sufficiently nest it to make it unreadable. Thus my qualifications about when I think your (valid!) concern applies, and why I think this situation doesn't meet those criteria.

[17:07:20.0681] <rkirsling>
I said it was extremely easy to write code that's very hard to read. This is literally part of my _initial reaction_. I'm not looking for edge cases, I'm literally just spelling out the basic facts of what this does to JS.

[17:07:39.0416] <rkirsling>
This is all brand new to me; I am your eyes before plenary shuts you down

[17:09:14.0651] <rkirsling>
Like, my expressions of reservation during plenary this week were all met with "oh, I'll be harsher if you're not willing"

[17:10:06.0630] <TabAtkins>
Yup, and my counter was that I don't *currently* believe that the problematic code you gave an example of is actually a realistic thing someone will write. I could be wrong; a semi-realistic example would help. 

[17:12:41.0567] <TabAtkins>
With sufficient elision, it's similarly easy to show short code that puts an IIAFE inside the default argument value of the arglist of another IIAFE, for example, which is practically unreadable with only one level of nesting. We don't judge that to be a concern tho, because it's rare and not particularly helpful vs the more readable ways to write that code.

[17:13:14.0625] <TabAtkins>
But there are other examples one can raise for various features that are realistic *and* similarly unreadable, and that's a problem to address 

[17:13:22.0356] <TabAtkins>
So the specifics matter, is what I'm saying

[17:15:38.0345] <rkirsling>
Sure but I pointed out a basic fact -- `if (...)` would now be two totally different constructs, which not only can appear adjacently but the new one is also nestable -- and there is strong interest in having me not say that but no interest in being like, "oh yes, we _could_ come up with a terrible example, couldn't we"

[17:18:02.0081] <rkirsling>
Seems like we're only looking for people to nod and agree

[17:39:53.0195] <Jack Works>
> <@ljharb:matrix.org> i think it’s extremely important to unbox primitives by default; it’s a mistake the language makes that so difficult already.

but nobody really use them right? boxed primitives

[17:40:13.0815] <ljharb>
Not on purpose, but way more than people realize by accident.

[17:40:53.0990] <ljharb>
My goal here is to absorb those accidents and be able to write code that pretends boxed primitives doesn’t exist, and *still works with them*, something that’s quite difficult today.

[17:51:06.0125] <rbuckton>
> <@ljharb:matrix.org> My goal here is to absorb those accidents and be able to write code that pretends boxed primitives doesn’t exist, and *still works with them*, something that’s quite difficult today.

Having `x is String` work for both boxed and unboxed primitives is fine. I'm not sure how valuable `x is String(let y)` is though. If you are writing that you are definitely *not* pretending boxed primitives don't exist. 

[18:06:35.0728] <ljharb>
i agree there’s no value there. However that seems like an unavoidable thing to fall out of the proposal’s semantics, and not a harmful one since it’ll be rare (unless it slows down normal usage, ofc)

[18:38:15.0577] <rkirsling>
So what's getting totally lost is why we want the things that we want.

`is` feels like "_huh? this is not the proposal I showed up for? we're here to make a better `switch`, not to pull a bait-and-switch_", yet wanting `if (x is Some(let v))` certainly makes sense. Still, it's clear that for the general POJO situation, `if (let { foo } = x)` would integrate better into the language.

And indeed, the temperature of the committee that I was experiencing last week is that having "pattern matching has a solution for that!" come up in the discussion of a half-dozen disparate proposals is a _worrying_ signal, that the feature has grown unreasonably large.

Although I was thinking yesterday that the spelling `if` is more of an issue than whether it's a pattern, this may have been mistaken. If `if` is a guard then it feels more natural to exclude it from `is`, which makes my largest concerns disappear. Patterns ought to be as simple as possible -- it's not even clear to me that `and` is a good idea; the thing that we really _need_ it for is a way to connect a binding to a pattern that's going to use that binding, and ironically that's the case where `and` is not the most intuitive keyword to read.

[18:40:58.0006] <rkirsling>
 * So what's getting totally lost is why we want the things that we want.

`is` feels like "_huh? this is not the proposal I showed up for? we're here to make a better `switch`, not to pull a bait-and-switch_", yet wanting `if (x is Some(let v))` certainly makes sense. Simultaneously, it's clear that for the general POJO situation, `if (let { foo } = x)` would integrate better into the language.

And indeed, the temperature of the committee that I was experiencing last week is that having "pattern matching has a solution for that!" come up in the discussion of a half-dozen disparate proposals is a _worrying_ signal, that the feature has grown unreasonably large.

Although I was thinking yesterday that the spelling `if` is more of an issue than whether it's a pattern, this may have been mistaken. If `if` is a guard then it feels more natural to exclude it from `is`, which makes my largest concerns disappear. Patterns ought to be as simple as possible -- it's not even clear to me that `and` is a good idea; the thing that we really _need_ it for is a way to connect a binding to a pattern that's going to use that binding, and ironically that's the case where `and` is not the most intuitive keyword to read.

[18:41:17.0562] <rkirsling>
 * So what's getting totally lost is why we want the things that we want.

`is` feels like "_huh? this is not the proposal I showed up for? we're here to make a better `switch`, not to pull a bait-and-switch_", yet wanting `if (x is Some(let v))` makes a lot of sense. Simultaneously, it's clear that for the general POJO situation, `if (let { foo } = x)` would integrate better into the language.

And indeed, the temperature of the committee that I was experiencing last week is that having "pattern matching has a solution for that!" come up in the discussion of a half-dozen disparate proposals is a _worrying_ signal, that the feature has grown unreasonably large.

Although I was thinking yesterday that the spelling `if` is more of an issue than whether it's a pattern, this may have been mistaken. If `if` is a guard then it feels more natural to exclude it from `is`, which makes my largest concerns disappear. Patterns ought to be as simple as possible -- it's not even clear to me that `and` is a good idea; the thing that we really _need_ it for is a way to connect a binding to a pattern that's going to use that binding, and ironically that's the case where `and` is not the most intuitive keyword to read.

[18:41:23.0784] <rkirsling>
 * So what's getting totally lost is why we want the things that we want.

`is` feels like "_huh? this is not the proposal I showed up for? we're here to make a better `switch`, not to pull a bait-and-switch_", yet wanting `if (x is Some(let v))` makes a lot of sense. Simultaneously though, it's clear that for the general POJO situation, `if (let { foo } = x)` would integrate better into the language.

And indeed, the temperature of the committee that I was experiencing last week is that having "pattern matching has a solution for that!" come up in the discussion of a half-dozen disparate proposals is a _worrying_ signal, that the feature has grown unreasonably large.

Although I was thinking yesterday that the spelling `if` is more of an issue than whether it's a pattern, this may have been mistaken. If `if` is a guard then it feels more natural to exclude it from `is`, which makes my largest concerns disappear. Patterns ought to be as simple as possible -- it's not even clear to me that `and` is a good idea; the thing that we really _need_ it for is a way to connect a binding to a pattern that's going to use that binding, and ironically that's the case where `and` is not the most intuitive keyword to read.

[18:46:18.0672] <rkirsling>
 * So what's getting totally lost is why we want the things that we want.

`is` feels like "_huh? this is not the proposal I showed up for? we're here to make a better `switch`, not to pull a bait-and-switch_", yet wanting `if (x is Some(let v))` makes a lot of sense. Simultaneously though, it's clear that for the general POJO situation, `if (let { foo } = x)` would integrate better into the language.

Indeed, the temperature of the committee that I was experiencing last week is that having "pattern matching has a solution for that!" come up in the discussion of a half-dozen disparate proposals is a _worrying_ signal, that the feature has grown unreasonably large.

Although I was thinking yesterday that the spelling `if` is more of an issue than whether it's a pattern, this may have been mistaken. If `if` is a guard then it feels more natural to exclude it from `is`, which makes my largest concerns disappear. Patterns ought to be as simple as possible -- it's not even clear to me that `and` is a good idea; the thing that we really _need_ it for is a way to connect a binding to a pattern that's going to use that binding, and ironically that's exactly the case where `and` is not the most intuitive keyword to read.

[18:50:18.0459] <rkirsling>
 * So what's getting totally lost is why we want the things that we want.

`is` feels like "_huh? this is not the proposal I showed up for? we're here to make a better `switch`, not to pull a bait-and-switch_", yet wanting `if (x is Some(let v))` makes a lot of sense. Simultaneously though, it's clear that for the general POJO situation, `if (let { foo } = x)` would integrate better into the language.

Indeed, the temperature of the committee that I was experiencing last week is that having "pattern matching has a solution for that!" come up in the discussion of a half-dozen disparate proposals is a _worrying_ signal, that the feature has grown unreasonably large.

Although I was thinking yesterday that the spelling `if` is more of an issue than whether it's a pattern, this may have been mistaken. If `if` is a guard then it feels more natural to exclude it from `is`, which makes my largest concerns disappear. I believe strongly that patterns should be as simple as possible -- it's not even clear to me that `and` is a good idea; the thing that we really _need_ it for is a way to connect a binding to a pattern that's going to use that binding, but ironically that's exactly the case where `and` is not the most intuitive keyword to read.

[18:50:54.0782] <rkirsling>
 * So what's getting totally lost is why we want the things that we want.

`is` feels like "_huh? this is not the proposal I showed up for? we're here to make a better `switch`, not to pull a bait-and-switch_", yet wanting `if (x is Some(let v))` makes a lot of sense. Simultaneously though, it's clear that for the general POJO situation, `if (let { foo } = x)` would integrate better into the language.

Indeed, the temperature of the committee that I was experiencing last week is that having "pattern matching has a solution for that!" come up in the discussion of a half-dozen disparate proposals is a _worrying_ signal, that the feature has grown unreasonably large.

Although I was thinking yesterday that the spelling `if` is more of an issue than whether it's a pattern, this may have been mistaken. If `if` is a guard then it feels more natural to exclude it from `is`, which makes my largest concerns disappear. I believe strongly that patterns should be as simple as possible -- it's not even clear to me that `and` is a good idea; the thing that we really _need_ it for is a way to connect a binding to a pattern that's going to use that binding, yet ironically that's exactly the case where `and` is not the most intuitive keyword to read.

[18:52:02.0620] <rkirsling>
 * Like, my expressions of reservation during plenary this past week were all met with "oh, I'll be harsher if you're not willing"

[18:55:47.0302] <rbuckton>
> <@rkirsling:matrix.org> So what's getting totally lost is why we want the things that we want.
> 
> `is` feels like "_huh? this is not the proposal I showed up for? we're here to make a better `switch`, not to pull a bait-and-switch_", yet wanting `if (x is Some(let v))` makes a lot of sense. Simultaneously though, it's clear that for the general POJO situation, `if (let { foo } = x)` would integrate better into the language.
> 
> Indeed, the temperature of the committee that I was experiencing last week is that having "pattern matching has a solution for that!" come up in the discussion of a half-dozen disparate proposals is a _worrying_ signal, that the feature has grown unreasonably large.
> 
> Although I was thinking yesterday that the spelling `if` is more of an issue than whether it's a pattern, this may have been mistaken. If `if` is a guard then it feels more natural to exclude it from `is`, which makes my largest concerns disappear. I believe strongly that patterns should be as simple as possible -- it's not even clear to me that `and` is a good idea; the thing that we really _need_ it for is a way to connect a binding to a pattern that's going to use that binding, yet ironically that's exactly the case where `and` is not the most intuitive keyword to read.

half a dozen sounds high? I recall mentioning it in relation to the negated `in`/`instanceof` proposal, which I had mentioned here in advance of plenary. I don't recall much more than that.

[18:56:39.0087] <rbuckton>
`if (let { foo } = x)` may align with existing destructuring, but existing destructuring cannot be easily extended into a full pattern matching mechanism. 

[18:58:03.0518] <rbuckton>
I also don't have a strong opinion on whether `if` should be excluded from `is`, only that if we have `if` patterns, then we shouldn't differ in what is allowed in the Pattern syntax between `if` and `match`.

[18:58:34.0044] <rkirsling>
"half-dozen" might be rounding up 😅 but I mean it in terms of folks' perception, regardless of the precise reality

[18:59:45.0988] <rbuckton>
If anything, I feel that `is not` is far more palatable than `!in` and `!instanceof`, though that comes from a position of trying not to clash with TypeScript syntax if possible.

[19:00:33.0981] <rbuckton>
Also, `if (let { foo } = x)` doesn't really work if it's not actually doing pattern matching. There's no condition in that case.

[19:01:23.0364] <rkirsling>
it may be the case that destructuring can't be extending into pattern matching, but what I'm saying is that we have a great language without pattern matching which wants for an if-let construct

[19:01:59.0173] <rkirsling>
to introduce not destructuring but instead a "competitor" to it in that space feels like the language is attacking itself

[19:02:00.0484] <rbuckton>
I believe we have a great language which wants for a pattern matching mechanism. 

[19:02:55.0907] <rbuckton>
There are so many things pattern matching can tie into with future proposals that can build upon it. A standalone `if let` mechanism is almost a throwaway feature. It doesn't add any other intrinsic value.

[19:04:11.0823] <rbuckton>
Pattern matching is a boon for FP-style development and is a vast improvement in terms of expressivity and usability of the language, especially with a cohesive syntax.

[19:05:09.0873] <rbuckton>
If anything, I see "this could be accomplished with pattern matching" to be an indication that we're on the path to getting this right. Not in a "shoehorn everything into pattern syntax" way, but in a "natural progression of the feature and its capabilities" way.

[19:07:04.0041] <rkirsling>
> <@rbuckton:matrix.org> There are so many things pattern matching can tie into with future proposals that can build upon it. A standalone `if let` mechanism is almost a throwaway feature. It doesn't add any other intrinsic value.

that's a very difficult philosophy for me to relate to 😓 ideally we'd never need to add anything to the language because it would already be enough. `if`-`let` is a simple extension of what we already have which adds value without introducing any worries about the ship capsizing

[19:07:21.0836] <rbuckton>
If anything, I find it regrettable that destructuring was defined to be so loose in how it handles patterns, which makes it very difficult to extend into a full blown pattern matching mechanism.

[19:08:00.0558] <rbuckton>
I don't see how `if let` is useful *without* pattern matching to go with it. 

[19:10:58.0481] <rbuckton>
I don't see JS as 100% done. It is merely "sufficient". There are far too many rough edges and improvements that can be made in the developer experience. Why add `class` when `function` and `prototype` are sufficient? Why add `let` when `var` is sufficient? 

[19:11:40.0303] <rbuckton>
That said, I'm not advocating for everything under the sun to be included in JS.

[19:12:00.0071] <rbuckton>
I'm advocating for features that provide a tangible benefit to a sizable population of JS users.

[19:13:21.0463] <rbuckton>
I advocated for class decorators to improve the developer experience for OOP devs. I have advocated for pattern matching to improve the experience for FP devs. 

[19:14:20.0050] <rbuckton>
I'm advocating for shared structs to improve the runtime capabilities for large applications like Office Web Apps, Google Docs, Teams, etc., that sorely need improvements in multithreading.

[19:16:36.0180] <rbuckton>
Yes, pattern matching is a fairly large feature, but I'd argue its more than worth its weight in complexity. I can guarantee I am going to reach for pattern matching about 100x more often than I would `Temporal`, or `bigint`.

[19:19:08.0776] <rbuckton>
And despite using the phrase "complexity", I don't find it to be too complex either. Once you have a grasp of the basics of pattern matching, each feature is complementary with the others.

[19:19:38.0579] <rbuckton>
This is where I found `${}` and `let when` to be so jarring, they felt out of place compared to other constructs.

[19:24:35.0281] <rbuckton>
with pattern matching, you can start simply and build:
- `v is String` to perform a simple type test
- `v is String or Number` to perform test two types
- `v is "foo" or "bar" or 1` to test specific values
- `v is { x: Number, y: Number }` to test shapes
- `match (v) { ... }` to test multiple branches
- `match (v) { { x: let x, y: let y }: ... }` to pull an POJO apart
- `match (v) { Point(let x, let y): ... }` to pull a class apart
- etc.

[19:25:32.0986] <rbuckton>
By the time you get to the 3rd bullet point, you've already been introduced to `or`. `and`, `not`, and `()` aren't a huge leap beyond that if you're familiar with `||`, `&&`, and `!`.

[19:32:12.0511] <rbuckton>
I could agree that `if` patterns are slightly out of step with the rest of the proposal, compared to an `if` clause. However, having them be patterns makes them more generally useful. With an `if` clause, you have to spend time and energy rearranging your pattern to satisfy the runtime requirements of a trailing `if` (which I mentioned above), while having `if` available as a pattern allows you to keep those (hopefully few) occurrences local to the subpattern that needs them. I hope, though, that the pattern matching syntax itself is expressive enough so as to avoid needing to lean on `if` except for the narrowest of corner cases.

[19:37:46.0443] <rbuckton>
For example: if we do not support relational patterns, you're more likely to need to lean on `if` to perform relational tests, like: 
```
match (p) {
  Point(let x, let y) if (x > 0 && y > 0): "positive x, positive y";
  Point(let x, let y) if (x > 0 && y < 0): "positive x, negative y";
  Point(let x, let y) if (x < 0 && y > 0): ...;
  Point(let x, let y) if (x < 0 && y < 0): ...;
  ...
}
```
While relational patterns would remove that need here:
  Point(> 0, > 0): "positive x, positive y";
  Point(> 0, < 0): "positive x, negative y";
  Point(< 0, > 0): ...;
  Point(< 0, < 0): ...;
  ...
}
```
The more expressive the pattern syntax, the less likely you'll actually see `if (x is ... if (y))` in actual code since you won't need that escape hatch.

[19:38:17.0656] <rbuckton>
 * For example: if we do not support relational patterns, you're more likely to need to lean on `if` to perform relational tests, like:

```
match (p) {
  Point(let x, let y) if (x > 0 && y > 0): "positive x, positive y";
  Point(let x, let y) if (x > 0 && y < 0): "positive x, negative y";
  Point(let x, let y) if (x < 0 && y > 0): ...;
  Point(let x, let y) if (x < 0 && y < 0): ...;
  ...
}
```

While relational patterns would remove that need here:

```
Point(> 0, > 0): "positive x, positive y";
Point(> 0, \< 0): "positive x, negative y";
Point(\< 0, > 0): ...;
Point(\< 0, \< 0): ...;
...
}

```

The more expressive the pattern syntax, the less likely you'll actually see `if (x is ... if (y))` in actual code since you won't need that escape hatch.


[19:38:37.0317] <rbuckton>
 * For example: if we do not support relational patterns, you're more likely to need to lean on `if` to perform relational tests, like:

```
match (p) {
  Point(let x, let y) if (x > 0 && y > 0): "positive x, positive y";
  Point(let x, let y) if (x > 0 && y < 0): "positive x, negative y";
  Point(let x, let y) if (x < 0 && y > 0): ...;
  Point(let x, let y) if (x < 0 && y < 0): ...;
  ...
}
```

While relational patterns would remove that need here:

```
match (p) {
  Point(> 0, > 0): "positive x, positive y";
  Point(> 0, \< 0): "positive x, negative y";
  Point(\< 0, > 0): ...;
  Point(\< 0, \< 0): ...;
  ...
}

```

The more expressive the pattern syntax, the less likely you'll actually see `if (x is ... if (y))` in actual code since you won't need that escape hatch.

[19:38:52.0788] <rbuckton>
 * For example: if we do not support relational patterns, you're more likely to need to lean on `if` to perform relational tests, like:

```
match (p) {
  Point(let x, let y) if (x > 0 && y > 0): "positive x, positive y";
  Point(let x, let y) if (x > 0 && y < 0): "positive x, negative y";
  Point(let x, let y) if (x < 0 && y > 0): ...;
  Point(let x, let y) if (x < 0 && y < 0): ...;
  ...
}
```

While relational patterns would remove that need here:

```
match (p) {
  Point(> 0, > 0): "positive x, positive y";
  Point(> 0, < 0): "positive x, negative y";
  Point(< 0, > 0): ...;
  Point(< 0, < 0): ...;
  ...
}

```

The more expressive the pattern syntax, the less likely you'll actually see `if (x is ... if (y))` in actual code since you won't need that escape hatch.

[19:41:07.0028] <rbuckton>
And that's what `if` patterns are: an escape hatch. Something you should hopefully never need to reach for.

[19:41:39.0109] <rbuckton>
 * I could agree that `if` patterns are slightly out of step with the rest of the proposal, compared to an `if` clause. However, having them be patterns makes them more generally useful. With an `if` clause, you have to spend time and energy rearranging your pattern to satisfy the runtime requirements of a trailing `if` (which I described a few days ago), while having `if` available as a pattern allows you to keep those (hopefully few) occurrences local to the subpattern that needs them. I hope, though, that the pattern matching syntax itself is expressive enough so as to avoid needing to lean on `if` except for the narrowest of corner cases.

[19:46:13.0600] <rbuckton>
And if `if` patterns exist and are disagreeable in some places, they can be called out by linters or by syntax highlighters to indicate their unique nature, to call attention to the use of the escape hatch. If you seen a `if` pattern, does that mean a lack of expressivity in pattern matching? Does that mean you should restructure your input to improve its matchability? Does that mean you're trying to do something too complicated and you should refactor to multiple statements? Any one, or all of these could apply.

[19:46:33.0318] <rbuckton>
 * And if `if` patterns exist and are disagreeable in some places, they can be called out by linters or by syntax highlighters to indicate their unique nature, to call attention to the use of the escape hatch. If you've seen a `if` pattern, does that mean a lack of expressivity in pattern matching? Does that mean you should restructure your input to improve its matchability? Does that mean you're trying to do something too complicated and you should refactor to multiple statements? Any one, or all of these could apply.

[21:27:24.0677] <Jack Works>
🤔 should we discuss it on the pattern matching repo? that's more accessible to the whole community 

[21:41:31.0745] <rkirsling>
Sure. My hope was that having a "sidebar" would improve communication but that hasn't worked out well; I've mostly felt very stressed out about having to be the lone dissenter

[21:43:58.0924] <Jack Works>
you can publish it on GitHub, maybe there are other guys objecting to this, don't feel too stressed 👀

[23:24:22.0404] <ljharb>
> <@rkirsling:matrix.org> So what's getting totally lost is why we want the things that we want.
> 
> `is` feels like "_huh? this is not the proposal I showed up for? we're here to make a better `switch`, not to pull a bait-and-switch_", yet wanting `if (x is Some(let v))` makes a lot of sense. Simultaneously though, it's clear that for the general POJO situation, `if (let { foo } = x)` would integrate better into the language.
> 
> Indeed, the temperature of the committee that I was experiencing last week is that having "pattern matching has a solution for that!" come up in the discussion of a half-dozen disparate proposals is a _worrying_ signal, that the feature has grown unreasonably large.
> 
> Although I was thinking yesterday that the spelling `if` is more of an issue than whether it's a pattern, this may have been mistaken. If `if` is a guard then it feels more natural to exclude it from `is`, which makes my largest concerns disappear. I believe strongly that patterns should be as simple as possible -- it's not even clear to me that `and` is a good idea; the thing that we really _need_ it for is a way to connect a binding to a pattern that's going to use that binding, yet ironically that's exactly the case where `and` is not the most intuitive keyword to read.

it's not a bait and switch; we got feedback from SM that we *can't* do a better switch unless we build it iteratively, and `is` makes perfect sense for that

[23:25:31.0647] <ljharb>
> <@jackworks:matrix.org> 🤔 should we discuss it on the pattern matching repo? that's more accessible to the whole community

i don't think more cooks will make for a better broth

[23:46:49.0670] <rkirsling>
right, I understand that that's where `is` came from

[23:50:11.0886] <rkirsling>
the irony is that a `match` statement creates a clearly delineated space in which new stuff can exist without threatening old stuff

[23:57:37.0548] <rkirsling>
as soon as you spill out of those braces and introduce patterns as a first-class concept, we now have to worry about interactions of patterns with literally everything else in the language, which is a _gigantic_ expansion of scope

[00:15:51.0072] <rkirsling>
this means that it's now far harder to reason about the totality of implications at hand, and I'm not totally clear whether SM is supportive of the place we've ended up, even if they encouraged proceeding in this general direction

[00:20:04.0220] <rkirsling>
> <@rkirsling:matrix.org> as soon as you spill out of those braces and introduce patterns as a first-class concept, we now have to worry about interactions of patterns with literally everything else in the language, which is a _gigantic_ expansion of scope

I expressed this worry out loud to various people at plenary, and everyone I talked to made me feel like my worry was, if anything, tame

[00:20:21.0583] <rkirsling>
> <@rkirsling:matrix.org> as soon as you spill out of those braces and introduce patterns as a first-class concept, we now have to worry about interactions of patterns with literally everything else in the language, which is a _gigantic_ expansion of scope

 * because I expressed this worry out loud to various people at plenary, and everyone I talked to made me feel like my worry was, if anything, tame

[00:57:33.0942] <rkirsling>
 * because I expressed this worry out loud to various people at plenary, and everyone I talked to made me feel like my worry was, if anything, tame

(tame, because what I'm trying so hard to protect is _existing JS_; I _am_ supportive of having a `match` statement, which is not a given!)

[02:02:53.0090] <ljharb>
i'm a bit confused about the implication of "protecting"; nothing we do here will break existing JS, it's just about existing developers' expectations and intuition, and the likelihood of bugs in both use and refactors, no?

[09:02:36.0705] <mgaudet>
just a meta-comment: i would say currently SpiderMonkey as a whole does not have a fully formed position; I've been attending the meeting to try to provide early forms of feedback such that if we do ultimately conclude we support the proposal, we think the proposal will be in a shape that we can implement with less challenges. As the PR comes together, I'll eventually try to get more of the team to sit down and actually ponder the proposal in more detail. 

My -personal- feelings are extremely mixed here. Interaction with the champions group has generally helped convince me of various pieces, but my natural inclination tends much closer to r.kirsling. 

[09:50:41.0561] <TabAtkins>
> <@rkirsling:matrix.org> Seems like we're only looking for people to nod and agree

This is an extremely bad read of our response to your feedback. I'm not sure how to restate it; I think I've been as clear as possible that your feedback was acknowledged, but we decided not to take action on it, and I gave the exact reasons why we decided that. I understand if you *disagree* with our conclusion, but casting that as us *ignoring* your feedback is simple wrong, and frankly a bit insulting. I'm not sure how I'm supposed to accept your feedback if the only allowed response is "we agree completely and have changed the proposal accordingly".

[09:51:31.0000] <TabAtkins>
And if you think I'm not being kind with that interpretation of your statements, well, same.

[09:58:52.0762] <TabAtkins>
I understand the frustration of being a dissenter among a group of supporters, but that is still a valuable position to take. But this proposal has been pulled in many, many directions by various people over the year+ it's been worked on; it absolutely can't satisfy everyone, and there are *strictly contradictory* desires for how it should look among the champions. We'll end up with something that will make everyone at least slightly unhappy vs their ideal version, guaranteed, but with luck we'll all be overall satisfied with the results.

[10:00:45.0728] <TabAtkins>
(Like, I still feel *very* strongly that losing `${...}` patterns is a big blow; it prevents us from generating on-the-fly matchers like `${caseless("foo-bar")}` to match the string "foo-bar" ignoring ascii case. Currently we can only dynamically generate matchers *if they're expressible as a regex literal*, which is is a funky restriction. But enough people pushed back on this that I dropped it for now; the rest of the proposal is still valuable and powerful and we can always revisit this in the future.)


2023-10-05
[17:43:03.0377] <rkirsling>
> <@tabatkins:matrix.org> And if you think I'm not being kind with that interpretation of your statements, well, same.

Sorry, this has indeed been quite difficult. What I was seeking in bringing the conversation here is a "step away from plenary and have a calm sidebar chat to resolve concerns" situation but I don't think this chat can actually replicate that; the illusion that it could has probably made this a worse choice than just using a GH issue

[18:01:52.0242] <rkirsling>
> <@ljharb:matrix.org> i'm a bit confused about the implication of "protecting"; nothing we do here will break existing JS, it's just about existing developers' expectations and intuition, and the likelihood of bugs in both use and refactors, no?

"protecting existing JS" was just my single-phrase summary of the worry I expressed -- of course we're not going to break the web regardless, but "we now have to worry about interactions of patterns with literally everything else in the language"

[18:02:46.0775] <rkirsling>
> <@rkirsling:matrix.org> combined with combinators and if patterns it's as if we're now not just redoing `switch` but also redoing destructuring, boolean operators, and ternaries; it feels like a bifurcation of the language

namely, this

[18:06:58.0063] <rkirsling>
Anyway, this started as me feeling that I must be missing some important rationale lurking behind our current approach, but

[18:07:33.0899] <rkirsling>
if, by this point, it's just me having a different opinion, I'm happy to try to formulate a clear statement of that on GH instead

[18:43:38.0559] <ljharb>
> <@rkirsling:matrix.org> "protecting existing JS" was just my single-phrase summary of the worry I expressed -- of course we're not going to break the web regardless, but "we now have to worry about interactions of patterns with literally everything else in the language"

that was always going to be the case; even if this proposal didn't include it, there's tons of follow-ons waiting in the wings to add patterns in lots of other places

[18:53:57.0993] <rkirsling>
fair enough

[18:55:36.0610] <rkirsling>
I mean, even with that possibility, I think "what's our absolute minimum for day 1 must-haves" is an important thing to have in mind

[18:55:51.0286] <rkirsling>
 * I mean, even with that possibility, I think "what's our absolute minimum for day 1 must-haves" is an important thing to have continually in mind

[18:57:46.0430] <rkirsling>
but I think that's sort of my point anyway: this is really shocking scope creep for a single proposal, but it wouldn't have to feel that way if it _weren't_ a single proposal

[22:11:32.0112] <rkirsling>
indeed, I think it's interesting that Python _rejected_ "and" and "not"
https://peps.python.org/pep-0622/#and-patterns

and deferred "patterns outside of `match`" as well as custom matchers
https://peps.python.org/pep-0622/#one-off-syntax-variant

[03:48:49.0534] <rbuckton>
I find the "rarely used" argument for `and` and `not` to be debatable. I've seen them both used quite often in C#

[04:54:24.0249] <ljharb>
i mean, i would use them a ton in JS. i don't understand why anyone would claim they're rarely used.

[05:00:35.0214] <Jack Works>
languages are different, maybe it's true that python doesn't need it

[05:49:11.0477] <rkirsling>
for me, it just feels a foreign concept, since none of the languages I've used pattern matching in have had that

[05:49:28.0407] <rkirsling>
is it just C# and F#?

[05:56:44.0003] <rkirsling>
the reason it feels "foreign" and not like, filling in a gap, is because you wouldn't expect to destructure something into two different shapes at once in an FP language

[05:57:56.0114] <rkirsling>
kinda feels like a paradigm break, like passing a function with side effects to map

[05:59:16.0881] <rkirsling>
 * for me, it just feels like a foreign concept, since none of the languages I've used pattern matching in have had that

[06:06:16.0151] <Jack Works>
> <@rkirsling:matrix.org> the reason it feels "foreign" and not like, filling in a gap, is because you wouldn't expect to destructure something into two different shapes at once in an FP language

yeah they can match based on nonimal type, but we're in JavaScript where objects can have arbitrary fields and no meaningful identity 

[06:08:25.0948] <rkirsling>
right

[06:09:17.0716] <rkirsling>
so in that sense a language like JS could probably be a reasonable exception (unlike with the `map` example)

[06:11:35.0383] <rbuckton>
Not all pattern matching is destructuring. Also, JS has a number of objects with internal brands (including user-defined objects with private fields) that make it necessary to be able to combine brand tests with other patterns. For example:

```
match (x) {
  when Map and { size: 0 }: ...;
}
```

[06:13:30.0108] <rkirsling>
mhm

[06:13:39.0787] <rbuckton>
> <@rkirsling:matrix.org> for me, it just feels like a foreign concept, since none of the languages I've used pattern matching in have had that

I wonder if we need something like https://rbuckton.github.io/regexp-features/ for pattern matching. Unfortunately, I don't have the bandwidth to do that myself at the moment.

[06:16:00.0695] <rbuckton>
`and` and `not` are also very useful with relational patterns, such as:
```
x is not in y
x is not String
x is >= 0 and < 10
```


[06:20:07.0617] <Jack Works>
> <@rbuckton:matrix.org> I wonder if we need something like https://rbuckton.github.io/regexp-features/ for pattern matching. Unfortunately, I don't have the bandwidth to do that myself at the moment.

I wonder if devs really adopt new features in regex ... (I also have the same worry about CSS).

[06:21:04.0878] <Jack Works>
they have the same feeling to me: (1) hard to learn (2) things cannot be done within it being done with JavaScript so developers already ok with it

[06:21:27.0951] <rkirsling>
> <@rbuckton:matrix.org> `and` and `not` are also very useful with relational patterns, such as:
> ```
> x is not in y
> x is not String
> x is >= 0 and < 10
> ```

note that a lot of languages would handle the last one with a range pattern

[06:22:19.0418] <Jack Works>
we decompose it into more basic ideas, isn't it good? 🤔

[06:23:25.0411] <rbuckton>
> <@rkirsling:matrix.org> note that a lot of languages would handle the last one with a range pattern

I'm not opposed to the idea of a range pattern, but `x is > 0 and <= 10` feels like a more natural transition for JS developers, as JS has no other concept of ranges at present (aside from the slice proposal, which has been dormant for awhile)

[06:23:58.0466] <rkirsling>
right it does feel like you'd expect it to go along with some other notion of ranges in JS

[06:25:52.0115] <rbuckton>
I do think range and slice notations would be useful for JS, at some point. I wouldn't want to tack that on to this.

[06:27:39.0401] <rbuckton>
Ranges are also a bit harder to conceptualize compared to relational comparisons, if you're not used to them, especially if you don't have a convenient syntax for open and closed ranges. It makes the `> 0` case harder, especially when dealing with floats.

[06:28:00.0192] <rbuckton>
 * Ranges are also a bit harder to conceptualize compared to relational comparisons, if you're not used to them. Especially if you don't have a convenient syntax for open and closed ranges. It makes the `> 0` case harder, especially when dealing with floats.

[06:32:07.0465] <rbuckton>
Strange that python adds grouped patterns, but not `and` or `not`, which are the main reasons you would need grouped patterns.

[06:42:53.0895] <rbuckton>
Also interesting that the rationale for Python to use `_` for discards is the exact opposite of ljharb's position as to why we can't use `_` for discards. 🤷

[06:44:06.0580] <rbuckton>
> In addition, this would put Python in a rather unique position: The underscore is as a wildcard pattern in _every_ programming language with pattern matching that we could find (including C#, Elixir, Erlang, F#, Grace, Haskell, Mathematica, OCaml, Ruby, Rust, Scala, Swift, and Thorn). Keeping in mind that many users of Python also work with other programming languages, have prior experience when learning Python, and may move on to other languages after having learned Python, we find that such well-established standards are important and relevant with respect to readability and learnability. In our view, concerns that this wildcard means that a regular name received special treatment are not strong enough to introduce syntax that would make Python special.

[06:44:21.0199] <rbuckton>
 * > In addition, this would put Python in a rather unique position: The underscore is [used] as a wildcard pattern in _every_ programming language with pattern matching that we could find (including C#, Elixir, Erlang, F#, Grace, Haskell, Mathematica, OCaml, Ruby, Rust, Scala, Swift, and Thorn). Keeping in mind that many users of Python also work with other programming languages, have prior experience when learning Python, and may move on to other languages after having learned Python, we find that such well-established standards are important and relevant with respect to readability and learnability. In our view, concerns that this wildcard means that a regular name received special treatment are not strong enough to introduce syntax that would make Python special.

