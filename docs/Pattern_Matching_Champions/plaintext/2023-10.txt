2023-10-02
[07:42:03.0157] <TabAtkins>
I'll be a few minutes late to the meeting this morning

[08:49:53.0499] <TabAtkins>
Notes from today's meeting: https://github.com/tc39/proposal-pattern-matching/issues/302

[13:34:48.0562] <TabAtkins>
Opened a new issue about Matthew's perf concern about extractor vs variable custom matchers: https://github.com/tc39/proposal-pattern-matching/issues/303


2023-10-03
[19:01:56.0681] <rkirsling>
> <@rkirsling:matrix.org> in theory you could keep nesting `is ... if (...)`s

I think this point may have been overlooked in the discussion about `is` and `if` 

[19:03:39.0464] <rkirsling>
this really is something that arises from the combination of the two

[19:06:49.0600] <rkirsling>
though I guess it's not exclusive to `if` _patterns_; it's mostly something that happens due to `is` existing

[19:07:50.0334] <rkirsling>
though as Ron mentioned immediately above, the spelling of `if` pattterns/guards as `if` is the compounding factors

[19:07:51.0600] <rkirsling>
 * though as Ron mentioned immediately above, the spelling of `if` pattterns/guards as `if` is the compounding factor

[19:08:10.0285] <rkirsling>
 * I guess it's not exclusive to `if` _patterns_; it's mostly something that happens due to `is` existing, but

[19:08:13.0755] <rkirsling>
 * as Ron mentioned immediately above, the spelling of `if` pattterns/guards as `if` is the compounding factor

[19:11:03.0512] <rkirsling>
basically
```
if (... is ... if (... is ... if (...)))
    if (...)
        return;
```
would be our new world of JS

[19:11:15.0627] <rkirsling>
 * basically

```
if (... is ... if (... is ... if (...)))
    if (...)
        return;
```

would be valid in our proposed world

[19:12:59.0535] <Jack Works>
syntactically valid does not mean developers must write that. otherwise `throw throw x` should also be banned 

[19:13:27.0416] <rkirsling>
that's not a counterargument

[19:18:36.0706] <rkirsling>
it would be completely negligent to not have a thorough discussion about such a case

[19:20:25.0203] <rkirsling>
the crux is that it would be extremely easy to write code in one can't easily tell what construct `if (...)` is

[19:21:39.0422] <rkirsling>
 * the crux is that it would be extremely easy to write code in which one can't easily tell what construct `if (...)` is

[19:22:28.0208] <Jack Works>
but both if statement and if pattern accept an expression and evaluate it and do truthy test

[19:22:55.0827] <Jack Works>
it's not so important to distinguish them, because they have the same semantics 

[19:23:50.0370] <rkirsling>
they absolutely do not have the same semantics; one is a control flow construct and one is a subexpression

[19:34:57.0263] <rkirsling>
 * they absolutely do not have the same semantics; one is a control flow construct and one is a boolean subexpression

[01:12:08.0203] <ljharb>
fwiw i'm strongly opposed to dropping `when` entirely

[01:12:26.0876] <ljharb>
also is matthew mathieu?

[01:12:52.0119] <ljharb>
 * fwiw i'm strongly opposed to dropping `when` entirely (but am flexible on spelling)

[01:15:49.0297] <ljharb>
also i commented on the perf concern on the issue; tldr, this isn't a thing that's usually a problem and not something we should be concerned about

[08:08:04.0473] <mgaudet>
it me.

[08:08:10.0738] <mgaudet>
I am implementer. Raising concern. 

[08:08:17.0634] <mgaudet>
FWIW

[08:09:07.0289] <mgaudet>
The iterator protocol is hard to optimize, and I'm trying to provide feedback that will result in a performant proposal 

[08:09:17.0930] <mgaudet>
or, at least have the -potential- to be performant

[08:49:18.0682] <rbuckton>
I think it's fine to pay the cost for classes, but maybe we just don't support unboxing for primitives. Either that, or we distinguish between `x is String` and `x is String()` somehow. Different symbol methods maybe? 

[10:59:55.0143] <TabAtkins>
Yeah that was my suggestion in the issue. 

[11:00:39.0011] <TabAtkins>
I assume that authors will similarly run into issues where constructing the iterator's contents might be expensive, and want to avoid doing that when the user is just calling `Foo` for a typecheck.

[11:03:36.0703] <TabAtkins>
> <@rkirsling:matrix.org> the crux is that it would be extremely easy to write code in which one can't easily tell what construct `if (...)` is

I think this is relevant if it's *easy* to write code like that and there is *benefit* to doing it, such that we can expect it to be a somewhat common pattern among authors. If it's just *possible* but *fairly silly* to write such code, then so long as the behavior is well-defined and not too surprising it's not something we need to worry about, imo. People can do *lots* of very silly things in their code; this is far from the only place where authors can nest to ridiculous degrees if they feel like it, and make their code hard to understand.

[11:07:08.0636] <TabAtkins>
For example, one can similarly nest IIAFEs into their if(), or deeply nested ternaries, both of which can be quite difficult to puzzle out. But there's rarely, if ever, a reason to do so, so we don't worry about it; the behavior is well-defined and, if you can follow the expression tree, unsurprising.

[13:55:37.0998] <TabAtkins>
ljharb: I'm resolving all your whitespace changes without merging them; I don't think there is remotely a common standard on this, and I have written code in this way my entire life.

[14:00:18.0084] <TabAtkins>
> <@ljharb:matrix.org> fwiw i'm strongly opposed to dropping `when` entirely (but am flexible on spelling)

Can you elaborate on this? What is your opposition?

[14:01:04.0497] <TabAtkins>
And notably, what in your mind distinguishes JS from most other languages which lack a clause-introducing keyword in their syntax?

[16:04:44.0245] <ljharb>
> <@mgaudet:mozilla.org> I am implementer. Raising concern. 

aha thanks, that clarifies :-)

