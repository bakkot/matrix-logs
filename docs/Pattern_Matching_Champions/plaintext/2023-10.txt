2023-10-02
[07:42:03.0157] <TabAtkins>
I'll be a few minutes late to the meeting this morning

[08:49:53.0499] <TabAtkins>
Notes from today's meeting: https://github.com/tc39/proposal-pattern-matching/issues/302

[13:34:48.0562] <TabAtkins>
Opened a new issue about Matthew's perf concern about extractor vs variable custom matchers: https://github.com/tc39/proposal-pattern-matching/issues/303


2023-10-03
[19:01:56.0681] <rkirsling>
> <@rkirsling:matrix.org> in theory you could keep nesting `is ... if (...)`s

I think this point may have been overlooked in the discussion about `is` and `if` 

[19:03:39.0464] <rkirsling>
this really is something that arises from the combination of the two

[19:06:49.0600] <rkirsling>
though I guess it's not exclusive to `if` _patterns_; it's mostly something that happens due to `is` existing

[19:07:50.0334] <rkirsling>
though as Ron mentioned immediately above, the spelling of `if` pattterns/guards as `if` is the compounding factors

[19:07:51.0600] <rkirsling>
 * though as Ron mentioned immediately above, the spelling of `if` pattterns/guards as `if` is the compounding factor

[19:08:10.0285] <rkirsling>
 * I guess it's not exclusive to `if` _patterns_; it's mostly something that happens due to `is` existing, but

[19:08:13.0755] <rkirsling>
 * as Ron mentioned immediately above, the spelling of `if` pattterns/guards as `if` is the compounding factor

[19:11:03.0512] <rkirsling>
basically
```
if (... is ... if (... is ... if (...)))
    if (...)
        return;
```
would be our new world of JS

[19:11:15.0627] <rkirsling>
 * basically

```
if (... is ... if (... is ... if (...)))
    if (...)
        return;
```

would be valid in our proposed world

[19:12:59.0535] <Jack Works>
syntactically valid does not mean developers must write that. otherwise `throw throw x` should also be banned 

[19:13:27.0416] <rkirsling>
that's not a counterargument

[19:18:36.0706] <rkirsling>
it would be completely negligent to not have a thorough discussion about such a case

[19:20:25.0203] <rkirsling>
the crux is that it would be extremely easy to write code in one can't easily tell what construct `if (...)` is

[19:21:39.0422] <rkirsling>
 * the crux is that it would be extremely easy to write code in which one can't easily tell what construct `if (...)` is

[19:22:28.0208] <Jack Works>
but both if statement and if pattern accept an expression and evaluate it and do truthy test

[19:22:55.0827] <Jack Works>
it's not so important to distinguish them, because they have the same semantics 

[19:23:50.0370] <rkirsling>
they absolutely do not have the same semantics; one is a control flow construct and one is a subexpression

[19:34:57.0263] <rkirsling>
 * they absolutely do not have the same semantics; one is a control flow construct and one is a boolean subexpression

[01:12:08.0203] <ljharb>
fwiw i'm strongly opposed to dropping `when` entirely

[01:12:26.0876] <ljharb>
also is matthew mathieu?

[01:12:52.0119] <ljharb>
 * fwiw i'm strongly opposed to dropping `when` entirely (but am flexible on spelling)

[01:15:49.0297] <ljharb>
also i commented on the perf concern on the issue; tldr, this isn't a thing that's usually a problem and not something we should be concerned about

[08:08:04.0473] <mgaudet>
it me.

[08:08:10.0738] <mgaudet>
I am implementer. Raising concern. 

[08:08:17.0634] <mgaudet>
FWIW

[08:09:07.0289] <mgaudet>
The iterator protocol is hard to optimize, and I'm trying to provide feedback that will result in a performant proposal 

[08:09:17.0930] <mgaudet>
or, at least have the -potential- to be performant

[08:49:18.0682] <rbuckton>
I think it's fine to pay the cost for classes, but maybe we just don't support unboxing for primitives. Either that, or we distinguish between `x is String` and `x is String()` somehow. Different symbol methods maybe? 

[10:59:55.0143] <TabAtkins>
Yeah that was my suggestion in the issue. 

[11:00:39.0011] <TabAtkins>
I assume that authors will similarly run into issues where constructing the iterator's contents might be expensive, and want to avoid doing that when the user is just calling `Foo` for a typecheck.

[11:03:36.0703] <TabAtkins>
> <@rkirsling:matrix.org> the crux is that it would be extremely easy to write code in which one can't easily tell what construct `if (...)` is

I think this is relevant if it's *easy* to write code like that and there is *benefit* to doing it, such that we can expect it to be a somewhat common pattern among authors. If it's just *possible* but *fairly silly* to write such code, then so long as the behavior is well-defined and not too surprising it's not something we need to worry about, imo. People can do *lots* of very silly things in their code; this is far from the only place where authors can nest to ridiculous degrees if they feel like it, and make their code hard to understand.

[11:07:08.0636] <TabAtkins>
For example, one can similarly nest IIAFEs into their if(), or deeply nested ternaries, both of which can be quite difficult to puzzle out. But there's rarely, if ever, a reason to do so, so we don't worry about it; the behavior is well-defined and, if you can follow the expression tree, unsurprising.

[13:55:37.0998] <TabAtkins>
ljharb: I'm resolving all your whitespace changes without merging them; I don't think there is remotely a common standard on this, and I have written code in this way my entire life.

[14:00:18.0084] <TabAtkins>
> <@ljharb:matrix.org> fwiw i'm strongly opposed to dropping `when` entirely (but am flexible on spelling)

Can you elaborate on this? What is your opposition?

[14:01:04.0497] <TabAtkins>
And notably, what in your mind distinguishes JS from most other languages which lack a clause-introducing keyword in their syntax?

[16:04:44.0245] <ljharb>
> <@mgaudet:mozilla.org> I am implementer. Raising concern. 

aha thanks, that clarifies :-)

[16:05:17.0573] <ljharb>
> <@rbuckton:matrix.org> I think it's fine to pay the cost for classes, but maybe we just don't support unboxing for primitives. Either that, or we distinguish between `x is String` and `x is String()` somehow. Different symbol methods maybe? 

i think it’s extremely important to unbox primitives by default; it’s a mistake the language makes that so difficult already.

[16:06:02.0026] <ljharb>
> <@tabatkins:matrix.org> Can you elaborate on this? What is your opposition?

i think it’s very valuable to have a clear syntactic marker for the start of a clause. (a word is clear, a token likely isn’t)

[16:06:53.0673] <TabAtkins>
Why do you think we need a marker beyond "start of the line"? the obvious formatting will make this very clear when read.

[16:07:18.0782] <rbuckton>
It's my impression that most TC39 members believe that boxing primitives is a bad idea to begin with, so I'm not sure interacting with boxing is a benefit if it might encourage it's use even more

[16:07:41.0185] <ljharb>
> <@tabatkins:matrix.org> And notably, what in your mind distinguishes JS from most other languages which lack a clause-introducing keyword in their syntax?

i care zero for other languages; i think our bar should be higher than that. Private fields, for example, avoids repeating a mistake every other language makes by making them actually private and not reflectable.

[16:07:59.0719] <ljharb>
> <@rbuckton:matrix.org> It's my impression that most TC39 members believe that boxing primitives is a bad idea to begin with, so I'm not sure interacting with boxing is a benefit if it might encourage it's use even more

absolutely, but this helps *reduce* boxing

[16:08:21.0923] <ljharb>
> <@tabatkins:matrix.org> Why do you think we need a marker beyond "start of the line"? the obvious formatting will make this very clear when read.

one thing JS has objectively demonstrated is that there’s no obvious formatting, ever

[16:08:37.0768] <rbuckton>
> <@ljharb:matrix.org> absolutely, but this helps *reduce* boxing

No it makes it easier to unbox. If that feature isn't there, then you must manually unbox, which discourages boxing.

[16:09:24.0035] <ljharb>
> <@rbuckton:matrix.org> No it makes it easier to unbox. If that feature isn't there, then you must manually unbox, which discourages boxing.

that’s a false conclusion. If someone boxes a primitive it’s because they don’t know any better, not because of the ease of unboxing. Also, the value you’re testing is highly likely not to be one you control or create.

[16:09:34.0903] <TabAtkins>
lol I think "start clauses on a new line, indent wrapped" if extremely obvious and if you do anything else you're hurting yourself in a way that we don't need to help you avoid.

[16:09:49.0462] <rbuckton>
> <@ljharb:matrix.org> i care zero for other languages; i think our bar should be higher than that. Private fields, for example, avoids repeating a mistake every other language makes by making them actually private and not reflectable.

The ability to reflect over private fields in in some languages is based on an established trust relationship. Unprivileged code in .NET cannot reflect over private fields.

[16:10:04.0803] <ljharb>
> <@tabatkins:matrix.org> lol I think "start clauses on a new line, indent wrapped" if extremely obvious and if you do anything else you're hurting yourself in a way that we don't need to help you avoid.

i agree with your sensibilities but not that people are rational enough in aggregate for that to hold.

[16:10:37.0137] <rbuckton>
> <@ljharb:matrix.org> i care zero for other languages; i think our bar should be higher than that. Private fields, for example, avoids repeating a mistake every other language makes by making them actually private and not reflectable.

I also don't agree what introducing a keyword sets a higher bar, it introduces unnecessary and avoidable repetition.

[16:10:41.0131] <TabAtkins>
the unboxing primitives discussion is a red herring - the point is that the built-in matchers are slightly expensive (and author-provided ones can potentially be more expensive), which is an annoying cost to pay when we're going to immediately throw away the value anyway because all we care about is "not false"

[16:10:46.0267] <rbuckton>
> <@ljharb:matrix.org> i care zero for other languages; i think our bar should be higher than that. Private fields, for example, avoids repeating a mistake every other language makes by making them actually private and not reflectable.

 * I also don't agree that introducing a keyword sets a higher bar, it introduces unnecessary and avoidable repetition.

[16:11:09.0606] <ljharb>
I’m very open to flexibility in the custom matcher protocol return value, to be clear

[16:11:16.0749] <ljharb>
i don’t think a second protocol makes any sense at all

[16:11:42.0944] <ljharb>
what I’m not open to is unnecessarily restrictive semantics for builtin primitives

[16:12:45.0894] <ljharb>
i don’t see how an internal slot check is hard to optimize; many prototype methods check it, on strings also.

[16:12:54.0475] <rbuckton>
> <@ljharb:matrix.org> i don’t think a second protocol makes any sense at all

Extractors are unary functions by design. If you want to control the return value somehow, you really shouldn't be doing that via an extra argument, IMO.

[16:13:04.0457] <ljharb>
and if it’s hard for userland code to match that, all the more reason for host code to have it available

[16:13:24.0415] <ljharb>
> <@rbuckton:matrix.org> Extractors are unary functions by design. If you want to control the return value somehow, you really shouldn't be doing that via an extra argument, IMO.

I’m sure there’s more nuance here we can discuss next meeting when I’m not still traveling.

[16:16:21.0299] <TabAtkins>
> <@ljharb:matrix.org> i don’t see how an internal slot check is hard to optimize; many prototype methods check it, on strings also.

I'm confused; that's not the cost being mentioned. It's the cost of creating a temp array (and for userland code, the potentially unbounded cost of constructing what goes in the array).

[16:16:52.0996] <ljharb>
ok so that’s about the return value, which has nothing necessarily to do with the semantics. i agree that it’d be nice to avoid that 

[16:17:17.0502] <ljharb>
however that same concern just came up last week wrt iterator joining, and nobody seemed worried about it

[16:17:33.0652] <TabAtkins>
Right. `Foo` will *always* ignore the return value other than checking if it's false or not, so incurring the cost of actually building the return value is unfortunate. Thus the pair of protocols.

[16:17:35.0737] <ljharb>
so I’m confused why mgaudet thinks a throwaway array is expensive here but fine in dozens of other places

[16:17:58.0444] <ljharb>
adding a new protocol seems way more expensive than a temp array imo

[16:18:14.0112] <TabAtkins>
Those are completely different types of cost; I don't see the connection.

[16:18:28.0866] <ljharb>
but since is produces bindings I’m not sure when it’s ever just a “test”

[16:18:38.0558] <TabAtkins>
???

[16:19:06.0319] <TabAtkins>
I'm talking about the pattern `Foo`, as opposed to the pattern `Foo(...)`.

[16:19:32.0352] <ljharb>
i think this will need to wait til we can discuss sync to clarify 

[16:19:37.0218] <TabAtkins>
Right now they both invoke the same method, but the former throws away the return value.

[16:19:49.0098] <TabAtkins>
Yeah, I'm *super* confused as to what you're actually talking about, ljharb ^_^

[16:20:23.0789] <ljharb>
the issue you filed and the notes summary cover multiple “conclusions”, some of which i strongly oppose, so we’re probably talking past each other


2023-10-04
[17:00:53.0951] <rkirsling>
> <@tabatkins:matrix.org> I think this is relevant if it's *easy* to write code like that and there is *benefit* to doing it, such that we can expect it to be a somewhat common pattern among authors. If it's just *possible* but *fairly silly* to write such code, then so long as the behavior is well-defined and not too surprising it's not something we need to worry about, imo. People can do *lots* of very silly things in their code; this is far from the only place where authors can nest to ridiculous degrees if they feel like it, and make their code hard to understand.

I don't really understand how to interact with this group when the response to my concerns is to pretend they don't exist

[17:02:00.0098] <rkirsling>
Tweeting "have you tried just not writing bad code?" is already not going to be a way to win friends when we're talking about _existing_ features 

[17:02:07.0268] <TabAtkins>
I'm not doing that? I'm providing my own reasoning.

[17:02:21.0337] <rkirsling>
This is a new feature; it needs to justify its own existencr

[17:02:29.0734] <rkirsling>
* This is a new feature; it needs to justify its own existence

[17:03:39.0152] <TabAtkins>
Like, I provided significant qualifications to my statement. I think they all apply here, and justify my judgement that is okay. If you disagree, feel free to say why! Especially if you feel any of my assumptions don't hold, it perhaps don't hold as strongly as I might think they do.

[17:04:24.0232] <TabAtkins>
* Like, I provided significant qualifications to my statement. I think they all apply here, and justify my judgement that is okay. If you disagree, feel free to say why! Especially if you feel any of my assumptions don't hold, or perhaps don't hold as strongly as I might think they do.

[17:07:06.0902] <TabAtkins>
An issue is that I think your objection, as stated, is a fully general counter argument to any new feature that can be nested; you can always sufficiently nest it to make it unreadable. Thus my qualifications about when I think your (valid!) concern applies, and why I think this situation doesn't meet those criteria.

[17:07:20.0681] <rkirsling>
I said it was extremely easy to write code that's very hard to read. This is literally part of my _initial reaction_. I'm not looking for edge cases, I'm literally just spelling out the basic facts of what this does to JS.

[17:07:39.0416] <rkirsling>
This is all brand new to me; I am your eyes before plenary shuts you down

[17:09:14.0651] <rkirsling>
Like, my expressions of reservation during plenary this week were all met with "oh, I'll be harsher if you're not willing"

[17:10:06.0630] <TabAtkins>
Yup, and my counter was that I don't *currently* believe that the problematic code you gave an example of is actually a realistic thing someone will write. I could be wrong; a semi-realistic example would help. 

[17:12:41.0567] <TabAtkins>
With sufficient elision, it's similarly easy to show short code that puts an IIAFE inside the default argument value of the arglist of another IIAFE, for example, which is practically unreadable with only one level of nesting. We don't judge that to be a concern tho, because it's rare and not particularly helpful vs the more readable ways to write that code.

[17:13:14.0625] <TabAtkins>
But there are other examples one can raise for various features that are realistic *and* similarly unreadable, and that's a problem to address 

[17:13:22.0356] <TabAtkins>
So the specifics matter, is what I'm saying

[17:15:38.0345] <rkirsling>
Sure but I pointed out a basic fact -- `if (...)` would now be two totally different constructs, which not only can appear adjacently but the new one is also nestable -- and there is strong interest in having me not say that but no interest in being like, "oh yes, we _could_ come up with a terrible example, couldn't we"

[17:18:02.0081] <rkirsling>
Seems like we're only looking for people to nod and agree

[17:39:53.0195] <Jack Works>
> <@ljharb:matrix.org> i think it’s extremely important to unbox primitives by default; it’s a mistake the language makes that so difficult already.

but nobody really use them right? boxed primitives

[17:40:13.0815] <ljharb>
Not on purpose, but way more than people realize by accident.

[17:40:53.0990] <ljharb>
My goal here is to absorb those accidents and be able to write code that pretends boxed primitives doesn’t exist, and *still works with them*, something that’s quite difficult today.

[17:51:06.0125] <rbuckton>
> <@ljharb:matrix.org> My goal here is to absorb those accidents and be able to write code that pretends boxed primitives doesn’t exist, and *still works with them*, something that’s quite difficult today.

Having `x is String` work for both boxed and unboxed primitives is fine. I'm not sure how valuable `x is String(let y)` is though. If you are writing that you are definitely *not* pretending boxed primitives don't exist. 

