2022-03-11
[00:33:18.0710] <Jack Works>
I presented pattern matching to JSCIG and get some feedbacks

[00:40:29.0351] <Jack Works>
Some feedbacks are about the confusions/bugs in the slides, I have commented on the slide.

[00:40:42.0474] <Jack Works>
The rest are about the proposal design, and I think we can do better

[01:01:08.0179] <Jack Works>
https://github.com/tc39/proposal-pattern-matching/issues/248

[01:03:33.0695] <Jack Works>
other feedbacks are not too formal so I will post it here

[01:04:47.0333] <Jack Works>

Feedback:

```js
when ([ 'go', dir and ('n' or 'e' or 's' or 'w')]):
```

> if I need to write `dir and ('n' or 'e' or 's' or 'w')`, there is no way to extract them out. I have to copy and paste.

[01:10:59.0742] <Jack Works>
Feedback 2: 

Syntax has too much noise in it.

Question: Why a `()` after `when` is required? It's enough to separate LHS and RHS with the `:` we have. (I don't remember why we made that decision so ...)

[01:12:53.0922] <Jack Works>
Feedback 3:

`Symbol.match` and `Symbol.matcher` creates confusion

[01:15:55.0109] <Jack Works>
And the final problem, the current Custom Matcher is too verbose on syntax.

I wish it could be the rbuckton 's unapply form and also bring it to the destructing:

```js
match (val) {
    when (Some(val)): val,
    when (None()): undefined
}
```

And if we have this form, the alternative syntax I proposed in issue #248 will become


```js
match (val) {
    when (NaN): NaN
    default(Magic): console.log("default case with", Magic)
}
```

[01:16:44.0260] <Jack Works>
üôè really want this one, it's much simpler to use

[09:10:41.0752] <ljharb>
Jack Works: we talked about the identifier pattern in a previous meeting that i'm pretty sure you were present for; my last comment on that issue sums it up

[09:11:02.0182] <ljharb>
iow:
```
when ([foo])
```
needs to work, therefore
```
when (foo)
```
must also work

[09:11:34.0533] <ljharb>
> <@jackworks:matrix.org> Feedback 2: 
> 
> Syntax has too much noise in it.
> 
> Question: Why a `()` after `when` is required? It's enough to separate LHS and RHS with the `:` we have. (I don't remember why we made that decision so ...)

it's not enough imo; the parens are a necessary boundary. container characters aren't noise, they're explicit easy-to-tune-out boundary markers.

[09:18:17.0358] <Jack Works>
> <@ljharb:matrix.org> iow:
> ```
> when ([foo])
> ```
> needs to work, therefore
> ```
> when (foo)
> ```
> must also work

But it's already not working in most places.

And when we discussed this, I didn't recall that we have considered the future special identifier pattern like undefined and infinity.

Take that into our consideration, I think the solo identifier pattern should be a syntax error. There are better ways to do it. `default(binding)`. This way is also more clear on visuals. Easier to read. 

[09:18:31.0240] <ljharb>
what do you mean not working in most places?

[09:18:39.0319] <ljharb>
anywhere inside a pattern, a bare identifier is an irrefutable match

[09:18:55.0203] <ljharb>
(undefined and infinity and NaN aren't future patterns, they're part of this proposal)

[09:19:11.0109] <ljharb>
`default(binding)` simply *can not work* for nested matches, like inside an array or object

[09:19:32.0967] <ljharb>
and, because of `if`, you need to be able to do `when (foo) if (condition)`, which the `default()` wouldn't support, because "default with if" would be bizarre

[09:19:56.0724] <ljharb>
we certainly could make `when (foo)` by itself a syntax error - we already will, if it's not the last clause - but i'm not sure what value that would add

[09:20:00.0744] <Jack Works>
> <@ljharb:matrix.org> what do you mean not working in most places?

Solo identifier pattern as a syntax error if it does not occur at last. So in most places it's not working. 

[09:20:12.0308] <ljharb>
ah, i see what you mean

[09:20:30.0701] <ljharb>
sure, that's a reasonable argument for making it a syntax error always at the top level. i do not think that `default(binding)` is a good idea or makes sense

[09:20:55.0337] <ljharb>
but i also don't think `when (foo)` is harmful or bad, as long as it's the last clause

[09:21:01.0452] <Jack Works>
> <@ljharb:matrix.org> anywhere inside a pattern, a bare identifier is an irrefutable match

Yes other identifier pattern is useful. I only mean the topmost sole identifier pattern. 

[09:21:49.0329] <ljharb>
banning `when (foo)` even as the last item creates an inconsistency tho

[09:22:06.0691] <ljharb>
it seems more like something that should be linted against, if someone doesn't like the style, rather than banned at the language level

[09:22:18.0246] <Jack Works>
> <@ljharb:matrix.org> sure, that's a reasonable argument for making it a syntax error always at the top level. i do not think that `default(binding)` is a good idea or makes sense

It's like `catch(error)`, or if you don't like it, we may also have `default with binding`

[09:22:43.0728] <ljharb>
why would you need the binding tho?

[09:22:56.0740] <Jack Works>
ü§î oh wait... Yes that reminds me, the issue I mentioned also affects nested pattern

[09:22:58.0396] <ljharb>
i don't personally have any use case for `when (foo)`, it just naturally falls out of consistency with being able to do it nested

[09:23:06.0606] <ljharb>
and i see zero harm in allowing it

[09:23:09.0166] <Jack Works>
Since we need irfutable pattern

[09:23:38.0171] <Jack Works>
Ban the topmost cannot solve the problem 

[09:24:30.0125] <ljharb>
if the problem is "irrefutable patterns", yes, that's unavoidable

[09:25:47.0233] <Jack Works>
I understand now. So... are we sure we didn't miss anything? What if we really need to add something special? That's really not possible... 

[09:25:56.0958] <ljharb>
why would there ever be any new special things?

[09:26:05.0699] <ljharb>
that `undefined` is an identifier is a historical mistake

[09:26:20.0562] <ljharb>
and `-0` and `+0` are special patterns because of -0, which also won't be repeated

[09:26:38.0070] <Jack Works>
Hmm I don't know, maybe, when we have Decimals, we have a decimal version of DecimalNaN

[09:26:50.0291] <ljharb>
(`NaN` and `Infinity` are also special patterns because they're identifiers instead of keywords)

[09:27:05.0661] <ljharb>
if we had Decimals, and they added a NaN (which i doubt), they'd not be able to add it as an identifier, for all these reasons

[09:27:09.0353] <Jack Works>
Yeah, what if we have more NaN in the language... 

[09:27:26.0730] <ljharb>
lol if this proposal helps ensure no added NaNs to the language, i think we'd get stage 4 tomorrow

[09:27:42.0880] <Jack Works>
üòÜ

[09:27:49.0937] <Jack Works>
But what about Infinity? 

[09:28:06.0610] <Jack Works>
Maybe some new number kind will have its own Infinity 

[09:34:00.0929] <Jack Works>
Well, that might be reasonable that "we won't add new special identifier patterns in the future" 

[09:36:18.0586] <ljharb>
exactly, i think we can say that

[09:36:34.0705] <ljharb>
since, we shouldn't anyways

[09:40:35.0311] <Jack Works>
Ok that's cool

[09:43:09.0709] <Jack Works>
> <@jackworks:matrix.org> And the final problem, the current Custom Matcher is too verbose on syntax.
> 
> I wish it could be the rbuckton 's unapply form and also bring it to the destructing:
> 
> ```js
> match (val) {
>     when (Some(val)): val,
>     when (None()): undefined
> }
> ```
> 
> And if we have this form, the alternative syntax I proposed in issue #248 will become
> 
> 
> ```js
> match (val) {
>     when (NaN): NaN
>     default(Magic): console.log("default case with", Magic)
> }
> ```

And what about this? I really hope we can have this form and we can also bring it to the destructor syntax.

It's works nicer than the current syntax and have the same feature

[10:11:10.0936] <ljharb>
"works nicer" is pretty subjective; i am not a fan of that form

[10:11:43.0704] <ljharb>
but also, changing destructuring is far out of scope of this proposal; if we want something in both, it needs to be added to both at the same time

[15:47:08.0015] <rbuckton>
I plan to present extractors at an upcoming meeting, but unfortunately have a conflict at the end of this month and won't be able to attend. 


2022-03-12
[16:38:16.0423] <jschoi>
> <@rbuckton:matrix.org> I plan to present extractors at an upcoming meeting, but unfortunately have a conflict at the end of this month and won't be able to attend. 

Won‚Äôt be able to attend the plenary or another meeting?

[17:02:22.0893] <rbuckton>
I won't be able to attend plenary this month.

[19:16:30.0334] <Jack Works>
> <@ljharb:matrix.org> but also, changing destructuring is far out of scope of this proposal; if we want something in both, it needs to be added to both at the same time

if rbuckton pushes his proposal, is it possible to switch to that form?

[20:14:08.0323] <ljharb>
if it advances to stage 2, then sure. but i don‚Äôt see that happening before pattern matching does.

[20:15:29.0741] <Jack Works>
üòã

[02:06:20.0588] <jschoi>
Pattern matching is seeking Stage 2 at next plenary, but is it a problem that do expressions are still at Stage 1? 

[02:09:46.0831] <Jack Works>
Yeah, the current pattern matching proposal doesn't depend on the semantics of due expression

