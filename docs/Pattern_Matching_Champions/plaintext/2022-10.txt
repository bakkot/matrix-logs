2022-10-02
[19:23:23.0517] <Jack Works>
> <@tabatkins:matrix.org> I'm fine with this, tho do we want to have it as part of the main proposal, or layered as a "next step"?

I want to gradually change the current spec into "next step"

[19:23:41.0409] <Jack Works>
rewriting this whole spec from the ground up is a little pain

[19:24:27.0695] <Jack Works>
so if everyone like `expr is pattern` expression, I can merge that


2022-10-05
[12:47:44.0722] <TabAtkins>
Yeah, I think lgtm from me. We can discuss exactly what subset we want to present for the Stage 2 request later.

[12:47:53.0567] <TabAtkins>
It's straightforward and useful


2022-10-06
[10:44:22.0522] <ljharb>
sure, that's a fair point


2022-10-21
[07:15:42.0035] <Jack Works>
so what's next? change `{ a }` from direct match to `{ a: let a }`? is this valid? `{ a: let {x, y} }`?

[09:46:18.0898] <ljharb>
i'm still not comfortable with that direction, especially including let and/or const (and/or var)

[09:46:21.0972] <ljharb>
 * i'm still not comfortable with that direction, especially including let and/or const (and/or var)

[12:09:30.0337] <rbuckton>
I'm open to other ideas, though I'm not in favor of completely divorcing declarations from pattern matching. 

[12:10:19.0072] <rbuckton>
While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)

[12:12:22.0821] <rbuckton>
 * While I prefer the explicit `let`, I'm also partial to Rust-like `@` bindings (i.e., `when { a: Number, b: c @ String }: c`)

[12:15:31.0495] <rbuckton>
I know `::` was under discussion at some point, but I found the examples confusing. I'm also concerned about using `::` when there have been multiple proposals considering it for call-like behavior that could potentially apply to Extractors as well (i.e., `when { a: foo::Message(b) }` could potentially be a thing)

[13:31:30.0821] <TabAtkins>
(I also could never actually quite decipher the `::` examples that were produced, at least not in a consistent way.)

[13:32:26.0389] <TabAtkins>
But yeah I don't have a strong opinion on how the irrefutable pattern is spelled.

[13:33:06.0140] <TabAtkins>
The Rust `@` pattern requires you to still specify a pattern, right? You can't just say "bind to this name, no further checks"?

[14:02:49.0331] <rbuckton>
Rust binds by default unless you specify a pattern or identifier that already exists, in which case it treats it as a pattern.

[14:03:26.0964] <rbuckton>
that kind of ambiguity wouldn't work well in JS though.

[14:06:39.0559] <rbuckton>
If we did use `@`, it would probably need to be necessary for all bindings. So `when { x: y }` would _always_ treat `y` as a pattern, meaning you'd need to write `when { x: y @ }` to introduce a binding. 

[14:08:03.0040] <rbuckton>
That syntax seems a little awkward, which is why I still prefer `when { x: let y }` to introduce a binding and `when { x: let y & pattern }` to bind *and* match. The `let` syntax is not as terse, but its much less ambiguous.

