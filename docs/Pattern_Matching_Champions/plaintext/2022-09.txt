2022-09-01
[23:42:39.0969] <yulia>
> <@tabatkins:matrix.org> And then `a` creates a binding but `b` doesn't, which feels weird. Testing for a property's existence should consistently add a binding or not, I think.

this isn't true of the current specification, which is why i tried this

[23:44:13.0304] <yulia>
from our last conversation, i understood that this only creates one binding, an alias `{b: {c: {d: e}}}`

[23:45:28.0957] <TabAtkins>
It is true in the current spec.

[23:45:38.0074] <yulia>
you would have bindings for b, c, and d there?

[23:45:46.0875] <TabAtkins>
No?

[23:46:13.0877] <yulia>
then i am a little lost about your comment

[23:46:36.0161] <TabAtkins>
In the current spec it's consistent. Testing for a property never adds a binding.

[23:46:48.0880] <yulia>
unless it is an unconditional match

[23:46:52.0190] <yulia>
which is testing for a property

[23:46:52.0556] <TabAtkins>
You have to establish a binding via a pattern 

[23:47:18.0256] <TabAtkins>
? Do you mean like {a}?

[23:47:21.0217] <yulia>
or it has an and -- which is also incredibly hard to understand

[23:47:22.0017] <yulia>
yes

[23:47:44.0927] <yulia>
finally there is aliasing

[23:47:48.0890] <yulia>
which is not a test

[23:47:59.0303] <yulia>
rather it is an "unconditional property check"

[23:48:47.0399] <TabAtkins>
That expands into {a:a}, exactly like every other instance of the object literal pattern in the language, so it's testing *and* then doing an ident matcher.

[23:49:30.0334] <yulia>
so it is not either or. it is either test or test and bind but only in certain circumstances

[23:49:54.0778] <yulia>
and sometimes alias, through the same syntax used for test only

[23:50:19.0856] <TabAtkins>
No, it's perfectly consistent. The syntax has a shortcut shared across the language, which is well known and familiar to authors.

[23:50:40.0349] <TabAtkins>
There is no "certain circumstances"

[23:51:28.0802] <yulia>
yes, and is obviously already in the language

[23:53:02.0118] <yulia>
lets take this down a notch. I read your initial language as rather dismissive so i became defensive

[23:53:21.0570] <TabAtkins>
If it's midnight and I'm in my phone in bed trying to type on a phone keyboard

[23:53:26.0950] <TabAtkins>
Zero hostility intended

[23:53:32.0653] <TabAtkins>
*oh it's

[23:53:42.0564] <yulia>
ok, sorry to keep you up!

[23:55:13.0074] <yulia>
the syntax isn't ultimately that important, I was just trying something

[23:55:25.0564] <TabAtkins>
I don't understand what you mean by "sometimes alias". This seems to imply you're seeing a *third* case in the syntax?

[23:56:01.0532] <yulia>
in the case of { a: b } 

[23:56:31.0310] <yulia>
i just really dislike this double use of the right hand side for both test and alias, thats what i've been trying to address

[23:57:33.0518] <TabAtkins>
Still confused - what on the rhs is doing a test there?

[23:57:41.0270] <yulia>
in that case it isn't

[23:57:50.0885] <yulia>
its unconditional

[23:58:28.0044] <yulia>
i am fine with {a, b, c: { e: f}} as a pattern I am less fine if we mix in test values like  {a: 500, b, c: { e: f}}

[23:58:34.0783] <yulia>
so for the test value i was proposing `::`

[23:58:45.0906] <yulia>
`{a :: 500, b, c: { e: f}}`

[23:59:50.0392] <yulia>
i was under the impression that a would be bound in either case -- sorry for that. it does put a bit of a damper in what i was hoping for which was that this could be used universally for enforcing values, but yes, not having `c :: etc` is also inconsistent

[00:00:01.0133] <TabAtkins>
What is {e:f} if not a test value as well, tho?

[00:00:11.0729] <yulia>
but the above would allow something like `(if let a :: 100 = b) { ...}`

[00:00:26.0001] <yulia>
> <@tabatkins:matrix.org> What is {e:f} if not a test value as well, tho?

this works exactly like destructuring, so this is an alias from e to f

[00:00:55.0379] <TabAtkins>
Right, but it's also testing the value of the c property for an e property, right?

[00:01:28.0399] <yulia>
yes

[00:02:27.0925] <TabAtkins>
So I think this is where I'm getting confused. You seem to be drawing a distinction between patterns that I can't wrap my head around?

[00:02:55.0078] <yulia>
`::` i guess i am thinking of this as an exclusive match

[00:03:21.0599] <yulia>
where as something like the destructuring short hand is a partial match looking for certain properties on an object

[00:04:02.0457] <yulia>
but now that i think of it, `let a : Int = 500` may be possible, though i haven't considered other cases

[00:04:36.0153] <yulia>
it just wouldn't work on objects themselves

[00:04:47.0981] <yulia>
though i wasn't thinking of that before anyway

[00:05:41.0297] <yulia>
this can also be addressed with the match keyword. I was just hoping that it would be recognizable as the same thing in all cases

[00:09:30.0818] <TabAtkins>
What I mean is you seem to be treating `100` as a fundamentally different construct in the syntax from `{c:d}`, such that the matcher needs to be written with a different introductory glyph. I still haven't grasped what that distinction you're making is. (In the current spec they're the same sort of thing - both patterns, of different types.) 

But I really do need to get to sleep so I'll pick this up async in the morning. ðŸ˜ƒ

[00:11:46.0979] <yulia>
sure, it was just a thought experiment to address comments i got in our call

