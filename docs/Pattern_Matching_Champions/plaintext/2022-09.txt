2022-09-01
[23:42:39.0969] <yulia>
> <@tabatkins:matrix.org> And then `a` creates a binding but `b` doesn't, which feels weird. Testing for a property's existence should consistently add a binding or not, I think.

this isn't true of the current specification, which is why i tried this

[23:44:13.0304] <yulia>
from our last conversation, i understood that this only creates one binding, an alias `{b: {c: {d: e}}}`

[23:45:28.0957] <TabAtkins>
It is true in the current spec.

[23:45:38.0074] <yulia>
you would have bindings for b, c, and d there?

[23:45:46.0875] <TabAtkins>
No?

[23:46:13.0877] <yulia>
then i am a little lost about your comment

[23:46:36.0161] <TabAtkins>
In the current spec it's consistent. Testing for a property never adds a binding.

[23:46:48.0880] <yulia>
unless it is an unconditional match

[23:46:52.0190] <yulia>
which is testing for a property

[23:46:52.0556] <TabAtkins>
You have to establish a binding via a pattern 

[23:47:18.0256] <TabAtkins>
? Do you mean like {a}?

[23:47:21.0217] <yulia>
or it has an and -- which is also incredibly hard to understand

[23:47:22.0017] <yulia>
yes

[23:47:44.0927] <yulia>
finally there is aliasing

[23:47:48.0890] <yulia>
which is not a test

[23:47:59.0303] <yulia>
rather it is an "unconditional property check"

[23:48:47.0399] <TabAtkins>
That expands into {a:a}, exactly like every other instance of the object literal pattern in the language, so it's testing *and* then doing an ident matcher.

[23:49:30.0334] <yulia>
so it is not either or. it is either test or test and bind but only in certain circumstances

[23:49:54.0778] <yulia>
and sometimes alias, through the same syntax used for test only

