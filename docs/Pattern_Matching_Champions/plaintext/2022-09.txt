2022-09-01
[23:42:39.0969] <yulia>
> <@tabatkins:matrix.org> And then `a` creates a binding but `b` doesn't, which feels weird. Testing for a property's existence should consistently add a binding or not, I think.

this isn't true of the current specification, which is why i tried this

[23:44:13.0304] <yulia>
from our last conversation, i understood that this only creates one binding, an alias `{b: {c: {d: e}}}`

[23:45:28.0957] <TabAtkins>
It is true in the current spec.

[23:45:38.0074] <yulia>
you would have bindings for b, c, and d there?

[23:45:46.0875] <TabAtkins>
No?

[23:46:13.0877] <yulia>
then i am a little lost about your comment

[23:46:36.0161] <TabAtkins>
In the current spec it's consistent. Testing for a property never adds a binding.

[23:46:48.0880] <yulia>
unless it is an unconditional match

[23:46:52.0190] <yulia>
which is testing for a property

[23:46:52.0556] <TabAtkins>
You have to establish a binding via a pattern 

[23:47:18.0256] <TabAtkins>
? Do you mean like {a}?

[23:47:21.0217] <yulia>
or it has an and -- which is also incredibly hard to understand

[23:47:22.0017] <yulia>
yes

[23:47:44.0927] <yulia>
finally there is aliasing

[23:47:48.0890] <yulia>
which is not a test

[23:47:59.0303] <yulia>
rather it is an "unconditional property check"

[23:48:47.0399] <TabAtkins>
That expands into {a:a}, exactly like every other instance of the object literal pattern in the language, so it's testing *and* then doing an ident matcher.

[23:49:30.0334] <yulia>
so it is not either or. it is either test or test and bind but only in certain circumstances

[23:49:54.0778] <yulia>
and sometimes alias, through the same syntax used for test only

[23:50:19.0856] <TabAtkins>
No, it's perfectly consistent. The syntax has a shortcut shared across the language, which is well known and familiar to authors.

[23:50:40.0349] <TabAtkins>
There is no "certain circumstances"

[23:51:28.0802] <yulia>
yes, and is obviously already in the language

[23:53:02.0118] <yulia>
lets take this down a notch. I read your initial language as rather dismissive so i became defensive

[23:53:21.0570] <TabAtkins>
If it's midnight and I'm in my phone in bed trying to type on a phone keyboard

[23:53:26.0950] <TabAtkins>
Zero hostility intended

[23:53:32.0653] <TabAtkins>
*oh it's

[23:53:42.0564] <yulia>
ok, sorry to keep you up!

[23:55:13.0074] <yulia>
the syntax isn't ultimately that important, I was just trying something

[23:55:25.0564] <TabAtkins>
I don't understand what you mean by "sometimes alias". This seems to imply you're seeing a *third* case in the syntax?

[23:56:01.0532] <yulia>
in the case of { a: b } 

[23:56:31.0310] <yulia>
i just really dislike this double use of the right hand side for both test and alias, thats what i've been trying to address

[23:57:33.0518] <TabAtkins>
Still confused - what on the rhs is doing a test there?

[23:57:41.0270] <yulia>
in that case it isn't

[23:57:50.0885] <yulia>
its unconditional

[23:58:28.0044] <yulia>
i am fine with {a, b, c: { e: f}} as a pattern I am less fine if we mix in test values like  {a: 500, b, c: { e: f}}

[23:58:34.0783] <yulia>
so for the test value i was proposing `::`

[23:58:45.0906] <yulia>
`{a :: 500, b, c: { e: f}}`

[23:59:50.0392] <yulia>
i was under the impression that a would be bound in either case -- sorry for that. it does put a bit of a damper in what i was hoping for which was that this could be used universally for enforcing values, but yes, not having `c :: etc` is also inconsistent

[00:00:01.0133] <TabAtkins>
What is {e:f} if not a test value as well, tho?

[00:00:11.0729] <yulia>
but the above would allow something like `(if let a :: 100 = b) { ...}`

[00:00:26.0001] <yulia>
> <@tabatkins:matrix.org> What is {e:f} if not a test value as well, tho?

this works exactly like destructuring, so this is an alias from e to f

[00:00:55.0379] <TabAtkins>
Right, but it's also testing the value of the c property for an e property, right?

[00:01:28.0399] <yulia>
yes

[00:02:27.0925] <TabAtkins>
So I think this is where I'm getting confused. You seem to be drawing a distinction between patterns that I can't wrap my head around?

[00:02:55.0078] <yulia>
`::` i guess i am thinking of this as an exclusive match

[00:03:21.0599] <yulia>
where as something like the destructuring short hand is a partial match looking for certain properties on an object

[00:04:02.0457] <yulia>
but now that i think of it, `let a : Int = 500` may be possible, though i haven't considered other cases

[00:04:36.0153] <yulia>
it just wouldn't work on objects themselves

[00:04:47.0981] <yulia>
though i wasn't thinking of that before anyway

[00:05:41.0297] <yulia>
this can also be addressed with the match keyword. I was just hoping that it would be recognizable as the same thing in all cases

[00:09:30.0818] <TabAtkins>
What I mean is you seem to be treating `100` as a fundamentally different construct in the syntax from `{c:d}`, such that the matcher needs to be written with a different introductory glyph. I still haven't grasped what that distinction you're making is. (In the current spec they're the same sort of thing - both patterns, of different types.) 

But I really do need to get to sleep so I'll pick this up async in the morning. ðŸ˜ƒ

[00:11:46.0979] <yulia>
sure, it was just a thought experiment to address comments i got in our call

[10:51:16.0072] <TabAtkins>
All right, at my desk and done with the office fire drill. ^_^

[10:54:05.0501] <TabAtkins>
So my final comment is where I'm at right now. It seems clear that you (@yulia) have a mental model that separates "does the matchable equal this value" (like `100`) and "does the matchable have these properties" (like `{c: d}`). I'd like to dive into that, because I think I've circled around to that being the *fundamental* disagreement, and I don't understand what the distinction you're drawing is (so, I can't actually discuss its upsides or downsides).

[10:54:15.0651] <TabAtkins>
Could you go into more detail about your thoughts there?

[10:54:33.0542] <TabAtkins>
yulia: ^^^ (sorry, for some reason it didn't tag you in the previous message)

[11:57:48.0999] <rbuckton>
FYI: I've just put up a PR to add Extractors (nee. "Extractor Objects") to the September meeting agenda. It primarily focuses on extractors in Binding and Assignment patterns, as I expect any discussion related to pattern matching implications would happen in the pattern matching proposal.


2022-09-02
[01:10:27.0675] <yulia>
TabAtkins: maybe lets sit down and get into the details. From my perspective there isn't so much of a fundamental disagreement, but a usecase discussion to be had. I don't necessarily think i have the answer to it, for what it is worth

[09:54:48.0437] <TabAtkins>
Spoilers: Yulia and I had a great discussion and I'll try to get a writeup together very soon.


2022-09-03
[07:01:12.0708] <TabAtkins>
Okay here's the write-up https://gist.github.com/tabatkins/74c66e216bfa0a3cf03d2b5e762557a9

[10:37:49.0650] <rbuckton>
> <@tabatkins:matrix.org> Okay here's the write-up https://gist.github.com/tabatkins/74c66e216bfa0a3cf03d2b5e762557a9

I'll try to take some time to give this my undivided attention after the holiday. I'm also working on a write-up to capture my own thoughts on pattern matching as well, breaking things down into core tenets and exploring the kind of layering yulia has proposed. 

[10:41:39.0388] <rbuckton>
While I have strong reservations about the _syntax_ yulia proposed (and the example syntax used in the writeup), I do strongly agree with the _capabilities_ that she's seeking. 

[10:46:04.0437] <rbuckton>
It would help to have a syntax-free breakdown of the specific capabilities. I think it might be easier to get agreement on specific capabilities to support before bikeshedding on syntax (even if it is intended to be illustrative). In fact, it might be better to discuss such capabilities in terms of equivalent existing syntax in _other_ languages (if it exists), since those will often have well understood semantics that can inform the discussion (i.e., "why does language X do it this way?", "what kinds of consequences would changes to these semantics have if we needed to make changes to match JS?", etc.)

[10:50:22.0701] <rbuckton>
I know I tend to lean heavily on prior art, but I also see no sense in re-inventing the wheel. Prior art should be informative, we should understand the historical reasons and rationale behind the features adopted by other languages, as well as the benefits and consequences those features have within that language. From there we can determine whether such features and semantics are compatible with JS, whether to break from those semantics to align with JS, or whether to build something new from whole cloth.

[13:50:35.0233] <rbuckton>
Are there any other languages that have an interpolation mechanism (like the proposed `${}`) as part of their pattern matching syntax? 


2022-09-04
[22:58:35.0687] <Jack Works>
That's an interesting problem


2022-09-07
[10:19:53.0652] <TabAtkins>
I believe it's rare to have a full "escape back to normal expression syntax" switch. It seems that most just allow for idents and possibly identifier descent (dotted/etc), referring to bindings visible from the outside.

[10:21:13.0254] <TabAtkins>
Tho note that interpolation *mostly* exists to distinguish the ident space from irrefutable matchers. The ability to do arbitrary expressions is a nice benefit that we layered on *since* we have a well-defined boundary (and it's what the syntax does in template strings).

[15:40:49.0450] <rbuckton>
I've been discussing interpolation with some other members of the TypeScript team. One of the strong opinions I've heard is that interpolation shouldn't be necessary if we have clear semantics around how identifiers are resolved, especially if an explicit syntax is necessary to declare bindings:

```
when (Foo): ...; // look up `Foo` in scope, match the input to it (either a primitive value or a custom matcher)
when ({ x }): ...; // either a syntax error, or merely tests for the presence of the property
when ({ x: let x }): ...; // declare `x` and bind it. `let x` is an irrefutable matcher (always matches)
when ({ x: x }): ...; // look up `x` in scope, match property `x` to it (either a primitive value or a custom matcher)
when ({ x: Infinity }): ...; // look up `Infinity` in scope, match the input to it.
when ({ x: -Infinity }): ...; // look up `Infinity` in scope, negate it, match the input to it.
when ({ x: undefined }): ...; // look up `undefined` in scope, match the input to it.
```
There's no ambiguity here: Bindings are explicit (via `let`/`const` patterns), and shorthand property patterns are either illegal, or merely test for presence (i.e., property exists but value doesn't matter). The resolution rules for identifiers remain the same as anywhere else in JS.

[15:43:17.0354] <rbuckton>
Alternatively, there's also Rust's `@`-like syntax for bindings:
```
when ({ x@x }): ...; // bind `x` property to variable `x`
```
But I'd like to be able to control whether the binding is mutable or immutable, and I'd be concerned about `@` conflicting with some other future decorator target.

[15:44:32.0129] <TabAtkins>
Those last three are all primitive matchers, but otherwise yes, if we move irrefutable matchers to a separate syntax then we can resolve idents by as references instead.

[15:45:02.0124] <TabAtkins>
Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.

[15:45:19.0246] <rbuckton>
I don't think it makes sense to treat `Infinity`, `NaN`, or `undefined` any differently than any other Identifier, since that's how resolution works everywhere else.

[15:47:17.0157] <rbuckton>
> <@tabatkins:matrix.org> Tho that limits us to *just* idents (and possible dotted-ident sequences), meaning you might ahve to prepare some matcher values into temp variables beforehand.

I definitely want qualified named (i.e., `a.b`) as well. And I'm fine with preparing matchers beforehand. I'd rather not have `when ({ x: ${value => arbitraryCondition} }): ...;` as it significantly reduces readability.

[15:57:30.0357] <TabAtkins>
Well, `-Infinity` needs to be treated specially, since it's *not* an identifier, it's an unary-minus expression whose argument is `Infinity`.

[15:57:43.0171] <TabAtkins>
(Same for all negative numbers, in fact.)

[15:58:50.0978] <TabAtkins>
And so either we treat `-Infinity` as a baked-in pattern (and for consistency, do the same for `Infinity`), or we have to recognize unary-minus expressions *in general*, so `-foo` is also valid.

[16:00:08.0319] <TabAtkins>
(unary-plus as well)

[16:01:14.0264] <TabAtkins>
While stashing functions into the interpolation pattern isn't great (you should indeed just extract that and give it a name), things like `${foo+"bar"}` aren't unreasonable to match against, I think.

[16:02:29.0391] <TabAtkins>
Also, being able to call functions, or refer to things with `[]` syntax, both seem reasonable to me.

[16:09:10.0259] <rbuckton>
`-Infinity` could be `` `-` SomeMoreRestrictiveMatchPattern `` that allows numeric literals and identifiers, and just performs a `ToNumber` on the identifiers.

[16:14:26.0370] <rbuckton>
I don't see why `-foo` shouldn't be viable. Lets say we allow identifier patterns to reference anything in scope, and that non-Object values match using SameValue (or SameValueZero), while Object values match as custom matchers. Why wouldn't you want to allow:
```js
const SOME_CONSTANT = 1;
match (input) {
  when (SOME_CONSTANT): ...;
  when (-SOME_CONSTANT): ...;
}
```
I don't think it makes sense to extend any further than prefix `+`/`-`, though maybe bitmasks/bit shifts could maybe be a thing?

[16:15:53.0310] <rbuckton>
bitmasks could be kind of useful with numeric enums, i.e.:
```js
match (node.modifierFlags) {
  when (ModifierFlags.Export | ModifierFlags.Default): ...; // default export
  when (ModifierFlags.Export): ...; // named export
}
```

[16:18:29.0101] <rbuckton>
But that would also be possible with a guard, so its not that much of an issue.

[16:27:00.0786] <TabAtkins>
Right, this is the slippery slope I'd prefer to not get into. Mixing expression syntax into pattern syntax will make things a *lot* more complicate.d

[16:28:25.0723] <rbuckton>
I put together a document detailing five core tenets that I believe could serve as a guide to discussions about pattern matching syntax and semantics. I've intentionally avoided using any syntax from the current pattern matching proposal or yulia's suggestions to instead focus on the underlying driving principles of pattern matching. All examples instead use syntax from Rust, Scala, C#, or F# for reference. I'd appreciate commentary and feedback and whether this makes sense to adopt as a set of principles for the proposal: https://gist.github.com/rbuckton/fca8b4ecc4eb16422b01f2557203082b

[16:29:43.0128] <rbuckton>
I think it could be useful as a reference for any future discussion about pattern matching syntax or potential layering.

