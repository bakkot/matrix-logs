2022-07-07
[10:32:39.0232] <jschoi>
Yeah, TabAtkins, thanks for continuing to engage with him and othersâ€”Iâ€™ve been really busy myself, so I havenâ€™t been able to work much on outreach or updates myself. ğŸ˜”

[13:25:11.0750] <TabAtkins>
And now I'm back to just closing issue threads because the participants refuse to stay on topic and instead keep relitigating the core question. :/

[13:26:02.0737] <TabAtkins>
Should have done that one weeks ago, but I know Kevin personally and wanted to keep things friendly, but good *lord* I do not have time nor interest to engage in dueling essays where every point was brought up and addressed last year.

[13:29:00.0837] <TabAtkins>
(if he has made novel points I missed them in the screenfuls of text that each post of his produces)

[13:29:32.0997] <jschoi>
Insofar that we have already addressed many points of argument that people keep perseverating over, we should add an FAQ section or an FAQ document that summarizes positions, so we could simply point to them every time something gets brought up again. Iâ€™ve meant to do this for a year now, but I just havenâ€™t had time. My apologies about thisâ€”maybe if I had done so earlier, we would have had you deal with a few less circular threads. 

[13:29:45.0390] <TabAtkins>
I doubt it. ^_^

[13:33:52.0041] <shu>
at least stare decisis have entered people's vocabularies recently

[13:34:21.0454] <TabAtkins>
ah yes, the "stand your ground" rule

[13:34:33.0866] <shu>
though i guess in this case it's more like res judicata than stare decisis

[13:34:40.0159] <shu>
 * though i guess in this case it's more like res judicata than stare decisis

[13:47:37.0559] <jschoi>
â€œStare decisisâ€ (n.): The act of staring decisively at each other, without budging.

[14:20:27.0031] <rkirsling>
this has truly been a depressing proposal, sociologically speaking

[14:22:39.0842] <TabAtkins>
huh, for some reason I can't hide Kevin's latest response in https://github.com/tc39/proposal-pipeline-operator/issues/238#issuecomment-1178231937 (but could hide his earlier ones)

[15:09:32.0938] <ljharb>
TabAtkins: sometimes i see no "hide" link present, especially when the anchor link points to that specific comment - i usually click the timestamp of another comment and hard-refresh

[15:11:32.0129] <TabAtkins>
Ah, that was indeed the problem. How confusing. Thanks!

[15:22:39.0271] <rbuckton (PTO: 7/5 - 7/16)>
Have we ever tried to quantify how much of the ecosystem prefers Hack-style vs. F#-style? It's unfortunate that much of the early negative response was so vitrolic, but I still wonder if Hack-style was the right direction. This proposal constantly feels like it's being pushed uphill. 

[15:26:58.0909] <shu>
do you plan to hire Pew?

[15:28:00.0903] <rbuckton (PTO: 7/5 - 7/16)>
No, no budget for that

[15:33:20.0793] <jschoi>
For what itâ€™s worth, I view reconciliation with call-this syntax to be a much greater obstacle to pipe operator compared to its syntax particulars like Hack/F#â€”or the choice of the topic, for that matter.â€¨(That is, Jordanâ€™s prior condition to pipeâ€™s advancement to StageÂ 2 that a this-binding-or-calling syntax also â€œeventuallyâ€ advance, and the fact that we have some strong opposition to any such this-binding/calling syntax.)â€¨This is one of the two topics that the pipe incubator was chartered to discuss, and we might have some time this plenary to discuss it. But if pipe fails to ever reach StageÂ 4, itâ€™s going to be because of that critical issue.

[15:33:42.0026] <jschoi>
> <@rbuckton:matrix.org> Have we ever tried to quantify how much of the ecosystem prefers Hack-style vs. F#-style? It's unfortunate that much of the early negative response was so vitrolic, but I still wonder if Hack-style was the right direction. This proposal constantly feels like it's being pushed uphill. 

 * For what itâ€™s worth, I view reconciliation with call-this syntax to be a much greater obstacle to pipe operator compared to its syntax particulars like Hack/F#â€”or the choice of the topic, for that matter.â€¨(That is, Jordanâ€™s prior condition to pipeâ€™s advancement to StageÂ 2 that a this-binding-or-calling syntax also â€œeventuallyâ€ advance, and the fact that we have some strong opposition to any such this-binding/calling syntax.)â€¨This is one of the two topics that the pipe incubator was chartered to discuss, and we might have some time this plenary to discuss it. But if pipe fails to ever reach StageÂ 4, itâ€™s going to be because of that critical issue.

[15:34:06.0966] <jschoi>
â€œThe default is that neither proposal advances, and Iâ€™m fine with that,â€ so to speak. Well, I can sympathize with gatekeeping [whatâ€™s left of] the core languageâ€™s simplicity, even if I shed one tear doing so. :â€™)

[15:34:40.0697] <jschoi>
* â€œThe default is that neither proposal advances, and Iâ€™m fine with that,â€ so to speak. Well, I can sympathize with gatekeeping [whatâ€™s left of] the core languageâ€™s simplicity, even if I shed one tear doing so. :â€™)

[15:35:36.0171] <rbuckton (PTO: 7/5 - 7/16)>
I am still, and probably always be, in favor of F#-style + PFA, even with the limitations regarding yield and await. 

[15:37:02.0585] <jschoi>
* That is to say, Jordan will probably always block StageÂ 4 for pipe unless call-this or something like it reaches StageÂ 3 or 4, as he essentially warned when it reached StageÂ 2 way back c. 2017. 

And (someone elseâ€™s words) â€œthe default is that neither proposal advances, and Iâ€™m fine with that,â€ so to speak. I suppose I can sympathize with gatekeeping [whatâ€™s left of] the core languageâ€™s simplicity, even if I shed one tear doing so. :â€™)

[15:40:25.0270] <jschoi>
I can certainly sympathize, though my perspective is colored by my Clojure heritage. Speaking of which, thereâ€™s always Elixir style. Or Clojureâ€™s operator-all-the-pipes-theyâ€™re-all-just-macros style (->, ->>, as->, cond->, etc.), heh.

[15:40:35.0341] <jschoi>
* I can certainly sympathize, though my perspective is colored by my Clojure heritage. Speaking of which, thereâ€™s always Elixir style. Or Clojureâ€™s operator-all-the-pipes-theyâ€™re-all-just-macros style (->, ->>, as->, cond->, etc.), heh.

[15:56:38.0902] <rbuckton (PTO: 7/5 - 7/16)>
> <@jschoi:matrix.org> I can certainly sympathize, though my perspective is colored by my Clojure heritage. Speaking of which, thereâ€™s always Elixir style. Or Clojureâ€™s operator-all-the-pipes-theyâ€™re-all-just-macros style (->, ->>, as->, cond->, etc.), heh.

Strongly imposed to Elixir style implicit parameter injection, it just adds more confusion over JS's existing implicit `this`. 

[15:58:26.0183] <rbuckton (PTO: 7/5 - 7/16)>
At least both Hack-style and F#-style are explicit. Hack-style with a topic, F#-style with `x |> F` meaning `F(x)` (plus PFA explicit placeholders). 

[16:00:08.0272] <rbuckton (PTO: 7/5 - 7/16)>
And I still feel if you're using `|>` to do simple expressions like `a + b`, you're holding it wrong. Its the wrong tool for the job. 

[16:01:15.0286] <jschoi>
Yeah, I agree about Elixir style. Anyways, all of these things are different ways to deal with the dichotomy between unary functional languages and n-ary functional languages. Something like a unaryâ€“n-ary functional impedance mismatch, to varying degrees.

[16:01:20.0809] <jschoi>
* Yeah, I agree about Elixir style. Anyways, all of these things are different ways to deal with the dichotomy between unary functional languages and n-ary functional languages. Something like a unaryâ€“n-ary functional impedance mismatch, to varying degrees.

[16:02:19.0086] <ljharb>
i suspect pipeline is the right tool for the job any time you have something complex to pass into a function, or a function call's return value to pass into a function.

[16:04:37.0360] <rbuckton (PTO: 7/5 - 7/16)>
> <@ljharb:matrix.org> i suspect pipeline is the right tool for the job any time you have something complex to pass into a function, or a function call's return value to pass into a function.

That's exactly my point. Piping through functions is the right use. The contrived `x |> % + 1` examples are the ones I think are a poor use.

[16:05:07.0864] <ljharb>
sure. but i don't think those are at all the only ones that support hack

[16:05:45.0586] <rbuckton (PTO: 7/5 - 7/16)>
I'd much rather have `do {}` or a `let..in` syntax for those cases.

[16:06:03.0177] <ljharb>
personally i have a bunch of examples that would work equally well in either style, and a bunch of examples where hack avoids creating a bunch of extra arrow functions, and close to zero examples (but nonzero) where F# is simpler

[16:10:46.0703] <jschoi>
I think `complexExpr |> % + 1` is contrived insofar that you could always replace it with `complexExpr + 1`. Itâ€™s because `+` is a fairly loose operator. In contrast, `complexExpr |> % ** 2` may not be so contrived, since otherwise it probably would have to be `(complexExpr) ** 2` with parenthesesâ€”and now imagine tacking on more and more (syntactically tight) operationsâ€¦

[16:17:18.0363] <jschoi>
Function calls are a very syntactically tight operation, involving circumflex operators. It is for that reason that it is quite inconvenient to write and to read deeply nested function calls. But this is also generalizable to deeply nested â€œsyntactically tight operationsâ€, of which function calls are a subset. + expressions donâ€™t fit as well in that set, but there are other ones that do.
(And thereâ€™s also prefix operations like await and -â€”even though they are syntactically loose, they also mess with writing and reading when applied to deeply nested expressions due to reading order switching between LTR and RTL.)
*Both* F# pipes and Hack pipes try to solve *all* these problems, in their own ways (e.g., `veryDeeplyNestedExpression |> negate` vs. `veryDeeplyNestedExpression |> -%`.

[16:19:18.0870] <jschoi>
* Function calls are a very syntactically tight operation, involving circumflex operators. It is for that reason that it is quite inconvenient to write and to read deeply nested function calls. But this is also generalizable to deeply nested â€œsyntactically tight operationsâ€, of which function calls are a subset. + expressions donâ€™t fit as well in that set, but there are other ones that do.
(And thereâ€™s also prefix operations like await and -â€”even though they are syntactically loose, they also mess with writing and reading when applied to deeply nested expressions due to reading order switching between LTR and RTL.)
*Both* F# pipes and Hack pipes try to solve *all* these problems, in their own ways (e.g., `veryDeeplyNestedExpression |> negate` vs. `veryDeeplyNestedExpression |> -%`.


2022-07-08
[18:48:52.0922] <rkirsling>
(oh man I know that was just a typo but the idea of a language where a combining circumflex would serve as an operator is quite amusing to me)


2022-07-09
[19:38:25.0282] <TabAtkins>
Every time someone says "non-function use-cases are contrived" I look back at all the times I've gone "fuck, I wish I had pipeline right now, this is kinda annoying to write" and how they're a pretty substantial mix of functions and operators and just go.... really?

[19:39:14.0940] <TabAtkins>
I fundamentally do not understand how this assertion can be made when I know for a fact how many times I, personally, want non-functions.

[19:42:42.0391] <TabAtkins>
> <@ljharb:matrix.org> personally i have a bunch of examples that would work equally well in either style, and a bunch of examples where hack avoids creating a bunch of extra arrow functions, and close to zero examples (but nonzero) where F# is simpler

Yes, this is my experience precisely. I often want to pipe into functions (sometimes unary, sometimes not; PFA would address the latter cases), but I also often want to linearize other things (mostly math stuff, calling methods on something complex, and of course `await` every. single. fucking. time). 

[10:04:45.0583] <Richard Gibson>
I frequently want to construct e.g. a Map or Set, which currently requires `new` (as in `â€¦ |> (entries => new Map(entries))` if tacit/point-free or `â€¦ |> (new Map(^))` if not)

[10:24:07.0653] <jschoi>
Did we ever consider `*` as a topic token? `f() |> g({ x: * })`. I donâ€™t remember why `*` was disqualified, if it was at all.

(Otherwise, the top runner is `^^`, given `@`â€™s recent problems found by WH.)

[10:24:30.0254] <jschoi>
Is it because of yield *? (This is such a rare case that we could require it to be `yield (*)`.)

[10:24:58.0058] <jschoi>
* Is it because of yield *? (This is such a rare case that we could require it to be `yield (*)`.)

[10:25:07.0397] <jschoi>
* Is it because of `yield *`? (This is such a rare case that we could require it to be `yield (*)`.)

[10:27:01.0089] <jschoi>
Or maybe itâ€™s because of `**`â€¦`f() |> g(**2)` is terrible but we would probably require separation between topic `*` and binary `*`/`**` anyway, just from the tokenization perspective. I probably wouldnâ€™t be a big deal to make people use a space to disambiguate the tokenization here.

[10:27:17.0333] <jschoi>
* Or maybe itâ€™s because of **â€¦f() |> g(***2) is terrible but we would probably require separation between topic * and binary */** anyway, just from the tokenization perspective. Itâ€™s not a big ask to make people use a space to disambiguate the tokenization here.

[10:27:47.0894] <jschoi>
* Or maybe itâ€™s because of `**`â€¦`f() |> g(**2)` is terrible but we would probably require separation between topic `*` and binary `*`/`**` anyway, just from the tokenization perspective. I probably wouldnâ€™t be a big deal to make people use a space to disambiguate the tokenization here.


2022-07-10
[10:51:22.0305] <rbuckton (PTO: 7/5 - 7/16)>
There was an interesting discussion in the last TC39/JavaScript Tools meeting about how pipeline was more statically analyzable by bundlers as a means of inlining and optimizing. I do wonder about the statements from implementers that F#-style couldn't be optimized. I definitely believe that F#+PFA could have been optimized to reduce actual function allocations. i.e., `x |> f~(?)` would have had no more overhead than `x |> f(%)`. 


2022-07-11
[18:44:54.0303] <rbuckton (PTO: 7/5 - 7/16)>
Could we, perhaps, appease the functional programming folks by using `|>` for Hack pipes, `||>` for F# pipes, and `|||>` for function composition? i.e., 
- `x |> expr` - First-order pipelining, i.e. evaluating expressions (i.e., "evaluate pipeline" or "expression pipeline"). Has a topic.
- `x ||> F` - Second-order pipelining, i.e. calling unary functions (i.e., "call pipeline" or "function pipeline"). Does not have a topic.
- `F |||> G` - Third-order pipelining, i.e. composition of unary functions (i.e., "compose pipeline"). Does not have a topic.

This makes some sense as far as first-order vs. higher-order pipeline:

```
// first-order
x |> F(%) |> G(%) 

// second-order
x ||> F ||> G

// third-order
// NOTE: this is backwards from f . g === g(f(x)), but perhaps we 
//       could introduce a "back pipe" `<|||` as a true point/compose operator
x ||> (F |||> G)
x |> (F |||> G)(%)
```

[18:46:25.0044] <rbuckton (PTO: 7/5 - 7/16)>
That would not only cover the FP crowd but also the data science crowd.

[18:48:34.0886] <rbuckton (PTO: 7/5 - 7/16)>
And if we wanted true point/compose, we could pair it with "back pipes" like in F#:
```
G(%) <| F(%) <| x // trickier to parse though
G <|| F <|| x
(G <||| F) <|| x
```

[18:50:06.0930] <rbuckton (PTO: 7/5 - 7/16)>
The back-pipe variant has similarities to decorator application as well:
```
class C {
  @F
  @G
  method() {}
}
 
F <||
G <||
function () {}
```

[19:04:03.0598] <rbuckton (PTO: 7/5 - 7/16)>
Then there's something for everyone, and while there might be some that ask "But can't we use `|>` for the F# case?" we could say that `|>` means "first-order", `||>` means "second-order" and `|||>` means "third-order" as a heuristic roughly based in first-order vs. higher-order logic.

[19:13:37.0483] <rbuckton (PTO: 7/5 - 7/16)>
For example, suppose we had my [functional operators](https://github.com/rbuckton/proposal-functional-operators) and PFA proposals:

```
a * b + c
a {*} b {+} c 
plus(times(a, b), c)

// first-order
a |> % * b |> % + c
a |> % {*} b |> % {+} c
a |> times(a, b) |> plus(%, c)
 
// second-order
a ||> {*} b ||> {+} c
a ||> times~(?, b) ||> plus~(?, c)
 
// third-order
a ||> ({*} b |||> {+} c)
a ||> (times~(?, b) |||> plus~(?, c))
```

[19:14:42.0865] <rbuckton (PTO: 7/5 - 7/16)>
 * For example, suppose we had my [functional operators](https://github.com/rbuckton/proposal-functional-operators) and PFA proposals:

```
a * b + c
a {*} b {+} c 
plus(times(a, b), c)

// first-order
a |> % * b |> % + c
a |> % {*} b |> % {+} c
a |> times(a, b) |> plus(%, c)
 
// second-order
a ||> {*} b ||> {+} c
a ||> times~(?, b) ||> plus~(?, c)
 
// third-order
a ||> ({*} b |||> {+} c)
a ||> (times~(?, b) |||> plus~(?, c))
```

[19:43:34.0688] <TabAtkins>
> <@jschoi:matrix.org> Did we ever consider `*` as a topic token? `f() |> g({ x: * })`. I donâ€™t remember why `*` was disqualified, if it was at all.
> 
> (Otherwise, the top runner is `^^`, given `@`â€™s recent problems found by WH.)

Binary operators are all problematic, and common ones like `*` are bad separately bc it's not unlikely that authors will multiply the topic by something.

[19:44:12.0145] <TabAtkins>
But yeah, `*` vs `**` and `yield*` all make `*` even worse, specifically.

[19:50:45.0138] <TabAtkins>
rbuckton (PTO: 7/5 - 7/16): Putting aside that I'm very confident a second pipe won't make it thru committee (the majority of the benefit of pipeline is already granted by the first one), I've no problem with pursuing tacit pipes in the future, so long as they don't block *this* proposal (either by trying to claim syntax, or by getting bundled into this proposal as a package).

[19:56:04.0541] <rbuckton (PTO: 7/5 - 7/16)>
It might have more credence if its promoted as a compromise for FP/Data Science, and that it may have less impact on performance if a first-order `|>` already exists, i.e.: The folks that need it will use it, as they would have been using unary functions anyways (so perf impact would be equivalent), but general use cases could lean on `|>` instead. Linters could, in theory, point users to using `|>` over `||>` (or `|||>`) when their usage would benefit from simplification.

[19:57:11.0709] <rbuckton (PTO: 7/5 - 7/16)>
And it would help to include, rather than alienate, existing FP libraries in the ecosystem.

[20:01:45.0070] <rbuckton (PTO: 7/5 - 7/16)>
 * And it would be a way to include, rather than alienate, existing FP libraries in the ecosystem.

[20:05:14.0372] <rkirsling>
while any empirical data would obviously confirm that `*` is more widely used than `^`, I will never not hate that `^^` is in the running just because we consider `^` uncommon in practice

[20:05:50.0065] <rkirsling>
I've said that here before but I guess I should say it more publicly/formally

[20:18:01.0120] <TabAtkins>
Like I said, I've no problem with it *so long as it doesn't do anything to block this one*; promoting it as a compromise solution implies that it's a package with the current pipeline and will only hurt our chances of getting either thru.

[05:38:55.0326] <jschoi>
> <@tabatkins:matrix.org> Binary operators are all problematic, and common ones like `*` are bad separately bc it's not unlikely that authors will multiply the topic by something.

Yeah, agreed, but I think that requiring separation between the topic and binary `*`/`**` might not be a big cost. 

I suspect maybe >90% of uses of pipe will be with function calls or object/array literals `f() |> g([*], 0), and it may be worth optimizing for those cases, rather than for `f() |> * ** 2`. And even `f() |> * ** 2` isnâ€™t that unreadable. 
Itâ€™s worth at least considering, since it probably is basically the only single-character token left. 

[05:39:43.0785] <jschoi>
> <@rkirsling:matrix.org> while any empirical data would obviously confirm that `*` is more widely used than `^`, I will never not hate that `^^` is in the running just because we consider `^` uncommon in practice

Disliking `^^` then, are you? ğŸ™‚

[05:40:21.0610] <jschoi>
> <@rkirsling:matrix.org> while any empirical data would obviously confirm that `*` is more widely used than `^`, I will never not hate that `^^` is in the running just because we consider `^` uncommon in practice

 * You dislike `^^` then, is that right? If so, Iâ€™ll add it to the table. ğŸ™‚

[05:42:01.0831] <jschoi>
* You dislike `^^` then, is that right, Ross? If so, Iâ€™ll add it to the wiki pageâ€™s Table of Opinions. ğŸ™‚ 

[05:43:44.0435] <jschoi>
> <@tabatkins:matrix.org> Binary operators are all problematic, and common ones like `*` are bad separately bc it's not unlikely that authors will multiply the topic by something.

 * Yeah, agreed, but I think that requiring separation between the topic and binary `*`/`**` might not be a big cost.

I suspect maybe >90% of uses of pipe will be with function calls or object/array/tuple/record literals `f() |> g(#[*], 0)`, and it may be worth optimizing readability for those cases, rather than for `f() |> * ** 2`. And even `f() |> * ** 2` isnâ€™t that unreadable, I think.
â€¨Itâ€™s worth at least considering, since it probably is basically the only single-character token left.

[06:02:09.0639] <Ashley Claymore>
I'm presuming `~` was discussed? It's at least only a unary operator and not binary. And uncommon

[06:02:16.0868] <Ashley Claymore>
 * I'm presuming `~` was discussed? It's at least only a unary operator and not binary. And uncommon

[06:03:08.0868] <Ashley Claymore>
I guess `~(1)` is visually ambiguous

[06:03:54.0860] <Ashley Claymore>
 * I guess `~(1)` is visually ambiguous

[06:06:55.0554] <jschoi>
`~` is nice and we havenâ€™t discussed it properly either. `f() |> g(#[~], 0) |> ~(~)`, hmmâ€¦

PFA syntax would use `~`. But `f() |> (~)~(0, ?)` would be quite rare!

[06:08:08.0750] <jschoi>
(Iâ€™ve added a breakout session for topic tokens to the plenary although we might not have time.)

[06:08:53.0190] <Ashley Claymore>
To call it would have to do something like: `(~)(arg)`

[06:09:52.0354] <jschoi>
Oh yeah. Which might not be that badâ€¦?

Which is worse:
`f() |> * ** 2`
`f() |> (~)(0)`

[06:10:51.0037] <jschoi>
* Oh yeah. Which might not be that badâ€¦?
Which is worse (or at least which would be more common):â€¨`f() |> * ** 2`â€¨`f() |> (~)(2)`

[06:11:37.0160] <Ashley Claymore>
could be a hazard if someone writes `~(arg)` and expects a function call. If arg can be converted to a number it wonâ€™t throw either 

[06:12:11.0517] <Ashley Claymore>
but again, maybe thatâ€™s OK for the benefit of a single character token

[06:13:18.0337] <jschoi>
At least it will throw if itâ€™s the only expected use of topic in the pipe body.â€¨`f() |> ~(2)` is a SyntaxError: â€œPipe body contains no topic.â€

[06:13:57.0413] <jschoi>
> <@aclaymore:matrix.org> could be a hazard if someone writes `~(arg)` and expects a function call. If arg can be converted to a number it wonâ€™t throw either 

 * At least it will throw if itâ€™s the only expected use of topic in the pipe body.â€¨`f() |> ~(2)` is a SyntaxError: â€œPipe body contains no topic.â€

[06:16:05.0411] <jschoi>
 * At least it will throw if itâ€™s the only expected use of topic in the pipe body.â€¨

`f() |> ~(2)` would be a SyntaxError: â€œPipe body contains no topic.â€

(`f() |> #[~(2), ~ + 1]` would not be a SyntaxError, but is that situation going to be common? Hmm.)

[06:19:09.0123] <Ashley Claymore>
Ah yes. I had completely forgotten about "it will throw if itâ€™s the only expected use of topic in the pipe body."

[06:52:55.0128] <TabAtkins>
`* * * ** *`

[06:54:45.0158] <jschoi>
That example makes my eyes feel like theyâ€™re bleeding, but at least thatâ€™s hardly ever going to happen. R-Right?

[06:55:14.0352] <TabAtkins>
I'm just saying, math is a lot more common than binary xor ğŸ˜…

[06:56:30.0876] <jschoi>
Yeah, true. Thoughâ€¦I think was RBN or WH or someone who said that we can always come up with contrived examples, like `#[#[#[#[##, this.#blah, #{#[this.#a, this.#b, ##]}], ##]]]`.
The key is whether an example is going to be common enough to be a concern. 
Frequency Ã— impact per occurrence = expected impact.

[06:56:58.0348] <jschoi>
Itâ€™s true that the frequency of binary `*` and `**` > the frequency of prefix `~`â€¦

[06:57:47.0789] <jschoi>
â€¦Will the frequency of calling-a-topic-as-a-function be comparable to the frequency of binary `*` and `**`? It is tough to say.

[07:47:18.0353] <TabAtkins>
Right, my big concern is that multiplication is pretty common (and I've wanted to use pipe in precisely a spot where I'd multiply the topic). Xoring the topic, or calling as a function, are both way less common, yeah. (And outside of lambda calculus, calling the topic as a function *and* using the topic as an argument would be incredibly rare, so avoiding the early error will be super uncommon.)

[07:47:50.0291] <TabAtkins>
I also don't feel good about the `yield*` case

[07:48:51.0429] <jschoi>
Sounds reasonable! I think I agree. I will add these opinions to the wiki table when I can.

[07:50:52.0447] <jschoi>
 * Sounds reasonable! I think I agree that topic `~` is probably better than topic `*`. I will add these opinions to the wiki table when I can.

[07:52:01.0016] <jschoi>
 * Sounds reasonable! I think I agree that topic `~` is probably better than topic `*`. (And it should still work with PFA syntax: `f() |> g~(~, 0)`.) I will add these opinions to the wiki table when I can.

[07:55:26.0838] <TabAtkins>
 * `\* \* \* \*\* \*\`

[07:55:40.0163] <TabAtkins>
 * `* * * ** *`

[14:17:06.0511] <rkirsling>
yeah, I think I'd feel less bad about `~`

[14:17:54.0454] <rkirsling>
to be clear, I'm not blocking wrt `^^`, it just makes me slightly sad (...which is ironic when viewed as kaomoji lol)

[14:24:50.0809] <rkirsling>
I say "slightly" because re-noticing in the wiki table that empirical rarity is _not_ the only justification for `^^` makes me feel less awful 

[14:30:11.0561] <jschoi>
Iâ€™m not sure why I thought `*` would be any different from `% ` and `^`, which Shu and others are against because they would require InputElementDiv/InputElementRegExpâ€“style contextuality in the lexer. `*` is not different from `%` and `^`; it suffers from the same problem, and so `*` is out.
I donâ€™t think `~` suffers from the same problem? I left a comment with some examples but Iâ€™m not 100% sure.

[14:30:53.0096] <jschoi>
* Iâ€™m not sure why I thought `*` would be any different from `% ` and `^`, which Shu and others are against because they would require InputElementDiv/InputElementRegExpâ€“style contextuality in the lexer. `*` is not different from `%` and `^`; it suffers from the same problem, and so `*` is out.
I donâ€™t think `~` suffers from the same problem? I left a comment with some examples but Iâ€™m not 100% sure.

[15:11:41.0024] <TabAtkins>
Apologies, I thought you'd already noticed that - I referenced the contextuality problem indirectly in my first response to `*`.


2022-07-13
[06:42:16.0663] <jschoi>
I think the `f() |> ~ + ~` case is unfortunate enough to exclude ~ as topic, but `f() |> ~~ + ~~` should work, right?
`^^`, `~~`, `%%`, `@@`, `##`.

[06:43:53.0420] <jschoi>
* I think the `f() |> ~ + ~` case is unfortunate enough to exclude ~ as topic, but `f() |> ~~ + ~~` should work, right?
`^^`, `~~`, `%%`, `@@`, `##`.

[07:13:27.0310] <rbuckton (PTO: 7/5 - 7/16)>
Isn't `~~(n) ` still valid JS? I don't think doubling is a solution. 

[09:04:52.0641] <jschoi>
Youâ€™re right; no doubled prefixes allowed.

[09:54:24.0847] <TabAtkins>
Yeah double binaries is good, double unaries isn't.

[10:41:18.0623] <rkirsling>
`#~` though? ;)

[11:26:29.0970] <rbuckton (PTO: 7/5 - 7/16)>
Not even sure double binaries is good. What if we'd had pipeline before `**`, would we have excluded `**` from the list of potential topics? What are the chances we might want to leverage a double binary for some other related math operation in the future?

I was tempted to suggest `@it` and banning `it` in a decorator (though you could still potentially do `@(it)`), except I'm fairly certain decorator test frameworks (or decorator support in existing frameworks) will pop up when decorators is finalized.

[11:27:14.0559] <rbuckton (PTO: 7/5 - 7/16)>
 * Not even sure double binaries is good. What if we'd had pipeline before `**`, would we have excluded `**` from the list of potential topics? What are the chances we might want to leverage a double binary for some other related math operation in the future?

I was tempted to suggest `@it` and banning `it` in a decorator (though you could still potentially do `@(it)`), except I'm fairly certain decorator test frameworks (or decorator support in existing frameworks) will pop up when decorators is finalized.

[11:28:13.0697] <rbuckton (PTO: 7/5 - 7/16)>
(especially since I already wrote one 7 years ago for TS decorators while exploring the feature, though I never published it)

[12:09:56.0333] <Ashley Claymore>
presumably 'banning' unary `~` in a pipe body is a very unpopular opinion

[12:10:26.0334] <Ashley Claymore>
 * presumably 'banning' unary `~` in a pipe body is a very unpopular opinion. (I'm a ^^ fan, but just curious)

[12:16:25.0516] <rkirsling>
what's interesting about unaries though is that they don't warrant a separate pipe

[12:16:51.0084] <rbuckton (PTO: 7/5 - 7/16)>
Yes. TS compiler wants to use pipes and we internally use bitmasks, so we would be strongly against banning `~` or `^` inside a pipe

[12:17:20.0837] <rkirsling>
i.e. you can do `~~x |> foo(#)` or `y |> ~~bar(#)`, there's no need for `|> ~~#`

[12:17:42.0634] <rkirsling>
 * i.e. you can do `~~x |> foo(#)` or `y |> ~~bar(#)`, there's no need for `|> ~~#`

[12:27:18.0282] <rbuckton (PTO: 7/5 - 7/16)>
Inside the TS compiler, our `binarySearch` function returns the twos-complement of the greatest lower bound when a match isn't found, so `result >= 0` equals an exact match, and `~result` indicates an potential insert location. I could potentially see a case where someone could leverage `~` in a pipe such that:
```js
binarySearch(array, value) |> ~ >= 0 ? array[~] : array[~~]; // greatest lower bound
binarySearch(array, value) |> ~ >= 0 ? array[~] : array[~~ + 1]; // least upper bound
```
As you can see, this wouldn't work with `~` or `~~` (or any arbitrary length of `~`).


[12:29:12.0832] <rbuckton (PTO: 7/5 - 7/16)>
I much prefer the readability of an identifier here:
```js
binarySearch(array, value) |> it >= 0 ? array[it] : array[~it]; // greatest lower bound
binarySearch(array, value) |> it >= 0 ? array[it] : array[~it + 1]; // least upper bound
```

[12:32:39.0928] <rbuckton (PTO: 7/5 - 7/16)>
Though we're much more likely to see the topic used with `~` in less ambiguous cases such as in the call to `setEmitFlags` below:
```js
return factory.createBinaryExpression(...)
  |> setOriginalNode(~, node)
  |> setSourceMapRange(~, { pos: ..., end: ... })
  |> setEmitFlags(~, getEmitFlags(node) & ~EmitFlags.NoComments);
```

[12:40:19.0606] <jschoi>
For what itâ€™s worth, I am slowly coming around to using an identifier.
But I think that it really ought to be considered a contextual keyword like `await` and `yield`.
The keyword would be something that, from now on, we would discourage developers from using as an ordinary variable, just like how developers should not use `await` and `yield` as ordinary variables.

[12:40:28.0533] <jschoi>
 * For what itâ€™s worth, I am slowly coming around to using an identifier.
But I think that it really ought to be considered a contextual keyword like `await` and `yield`.
The keyword would be something that, from now on, we would discourage developers from using as an ordinary variable, just like how developers should not use `await` and `yield` as ordinary variables.

[12:40:35.0518] <rbuckton (PTO: 7/5 - 7/16)>
 * Inside the TS compiler, our `binarySearch` function returns the twos-complement of the greatest lower bound when a match isn't found, so `result >= 0` equals an exact match, and `~result` indicates an potential insert location. I could potentially see a case where someone could leverage `~` in a pipe such that:

```js
binarySearch(array, value) |> (~ >= 0 ? array[~] : array[~~]); // greatest lower bound
binarySearch(array, value) |> (~ >= 0 ? array[~] : array[~~ + 1]); // least upper bound
```

As you can see, this wouldn't work with `~` or `~~` (or any arbitrary length of `~`).

[12:40:53.0206] <rbuckton (PTO: 7/5 - 7/16)>
 * I much prefer the readability of an identifier here:

```js
binarySearch(array, value) |> (it >= 0 ? array[it] : array[~it]); // greatest lower bound
binarySearch(array, value) |> (it >= 0 ? array[it] : array[~it + 1]); // least upper bound
```

[12:42:02.0015] <rbuckton (PTO: 7/5 - 7/16)>
If that's the case, I'd go for something like `$_` or `$$`. I've seen `__` used too often for unused parameters, i.e. `f((_, __, x) => { ... })`

[12:42:03.0802] <jschoi>
```js
binarySearch(array, value) |> ($$ >= 0 ? array[$$] : array[~$$ + 1]);
binarySearch(array, value) |> (__ >= 0 ? array[__] : array[~__ + 1]);
```

[12:42:13.0347] <jschoi>
Right, that makes sense.

[12:43:23.0725] <rbuckton (PTO: 7/5 - 7/16)>
I generally prefer `$_` over `$$` despite it being a bit tricker to type, since `_` often indicates a placeholder in multiple languages, and there's precedent in many shell scripts and some languages for `$_`.

[12:45:47.0348] <rbuckton (PTO: 7/5 - 7/16)>
Plus editors can easily offer a completion for `$_` on the right of a `|>`, so its more likely someone just does `$<tab>`

[12:51:01.0995] <rkirsling>
yeah I've expressed before that something with `_` would feel the most "obvious" to me

[12:51:04.0695] <jschoi>
I mildly prefer `$$` to `$_` because: `$_` is already being used in some contexts like browser inspectors (although admittedly this is a niche case; there might be other extant uses), `$$` is indeed easier to type, and `$_` is uglier to me than `$$`. As you know, `$_` is valid syntax for variables in Bash/Perl/Ruby but `$$` is not. But this is a mild preference.

[12:51:08.0172] <rkirsling>
 * yeah I've expressed before that something with `_` would feel the most "obvious" to me

[12:51:11.0009] <rbuckton (PTO: 7/5 - 7/16)>
If the completion case is strong enough, a longer keyword like `topic` is potentially just as viable since an editor could rank it higher in a completion list.

[12:51:11.0666] <jschoi>
 * I mildly prefer `$$` to `$_` because: `$_` is already being used in some contexts like browser inspectors (although admittedly this is a niche case; there might be other extant uses), `$$` is indeed easier to type, and `$_` is uglier to me than `$$`. As you know, `$_` is valid syntax for variables in Bash/Perl/Ruby but `$$` is not. But this is a mild preference.

[12:52:28.0711] <rbuckton (PTO: 7/5 - 7/16)>
`$_` in dev tools is a power-user corner case that isn't used in any actual code and is fairly fragile anyways. I'm not as concerned about running into issues there.

[12:53:44.0614] <rbuckton (PTO: 7/5 - 7/16)>
 * `$_` in dev tools is a power-user corner case that isn't used in any actual code and is fairly fragile anyways. I'm not as concerned about running into issues there.

[12:55:26.0692] <jschoi>
The most important thing for me is if `$_` really is not being already used by libraries and such. The same would be with `$$`; common usage of `$$` would make it much less attractive to me.

[12:55:33.0123] <jschoi>
 * The most important thing for me is if `$_` really is not being already used by libraries and such. The same would be with `$$`; common usage of `$$` would make it much less attractive to me.

[13:02:02.0475] <rbuckton (PTO: 7/5 - 7/16)>
A quick search via GitHub's codesearch for `language:js symbol:$$` shows a fair number of projects that use `$$` as an alias for `document.querySelectorAll`. I found over 100+ files.

A similar search for `language:js symbol:$_` has 18 results, though it tells me the results are not exhaustive.

[13:02:52.0690] <rbuckton (PTO: 7/5 - 7/16)>
 * A quick search via GitHub's codesearch for `language:js symbol:$$` shows a fair number of projects that use `$$` as an alias for `document.querySelectorAll`. I found over 100+ files.

~~A similar search for `language:js symbol:$_` has 18 results.~~ I need to recheck this due to an error in the query, so this may not be accurate...

[13:03:00.0169] <rbuckton (PTO: 7/5 - 7/16)>
 * A quick search via GitHub's codesearch for `language:js symbol:$$` shows a fair number of projects that use `$$` as an alias for `document.querySelectorAll`. I found over 100+ files.

~A similar search for `language:js symbol:$_` has 18 results.~ I need to recheck this due to an error in the query, so this may not be accurate...

[13:04:05.0556] <rbuckton (PTO: 7/5 - 7/16)>
GitHub is telling me results are not exhaustive, but still only provides me with 18 total matches.

[13:04:58.0019] <rbuckton (PTO: 7/5 - 7/16)>
 * A quick search via GitHub's codesearch for `language:js symbol:$$` shows a fair number of projects that use `$$` as an alias for `document.querySelectorAll`. I found over 100+ files.

A similar search for `language:js symbol:$_` has 18 results, though it tells me the results are not exhaustive.

[13:05:14.0273] <Justin Ridgewell>
Does `$_` get set while in the expression

[13:05:24.0921] <Justin Ridgewell>
I thought it was only done at statement positions

[13:06:59.0283] <rbuckton (PTO: 7/5 - 7/16)>
 * A quick search via GitHub's codesearch for `language:js symbol:$$` shows a fair number of projects that use `$$` as an alias for `document.querySelectorAll`. I found over 100+ files.

A similar search for `language:js symbol:$_` has 18 results, though it tells me the results are not exhaustive. Of those 18 results, some are substring matches and don't count.

[13:07:38.0627] <rbuckton (PTO: 7/5 - 7/16)>
 * A quick search via GitHub's codesearch for `language:js symbol:$$` shows a fair number of projects that use `$$` as an alias for `document.querySelectorAll`. I found over 100+ files.

A similar search for `language:js symbol:$_` has 18 results, though it tells me the results are not exhaustive. Of those 18 results, 15 are substring matches and don't count.

[13:07:56.0483] <jschoi>
Excellent data, thank you.

[13:08:07.0536] <jschoi>
 * Excellent data, thank you.

[13:08:51.0712] <jschoi>
I wonder how many people were using `yield` and `await` as variables before generators and async functionsâ€¦not that it matters. New uses ought to be be zero now.

[13:08:58.0994] <rbuckton (PTO: 7/5 - 7/16)>
Yeah, that seems to be the case. There are only three exact matches for `$_` and they are either `var $_ = ` or `window.$_ = `, and the `window.$_ = ` case reports a deprecation warning.

[13:09:11.0123] <jschoi>
 * I wonder how many people were using `yield` and `await` as variables before generators and async functionsâ€¦not that it matters. New uses ought to be be zero now.

[13:10:37.0443] <rbuckton (PTO: 7/5 - 7/16)>
`yield` was probably more common than `await`, since `yield` can also be used a noun in agriculture and finance

[13:11:19.0601] <rbuckton (PTO: 7/5 - 7/16)>
I don't know if there were any actual statistics collected for either case, however.

[13:13:00.0152] <jschoi>
 * I mildly prefer `$$` to `$_` because: `$_` is already being used in some contexts like browser inspectors (although admittedly this is a niche case; there might be other extant uses), `$$` is indeed easier to type, and `$_` is uglier to me than `$$`. As you know, the fact that `$_` but not `$$` is valid syntax for variables in Bash/Perl/Ruby, so `$_`â€™s use is an incident of those languagesâ€™ peculiarities. 
But this is a mild preference.

[13:13:04.0954] <rbuckton (PTO: 7/5 - 7/16)>
`yield` though ran into a case where Mozilla shipped generators unflagged prior to ES2015 without a `*` marker on the function, so that may have curtailed use somewhat.

[13:13:26.0194] <rbuckton (PTO: 7/5 - 7/16)>
(if memory serves correctly)

[13:17:00.0288] <jschoi>
The usage statistics are compelling that `$_` is better than `$$`. I have been convinced.

[13:17:00.0613] <rbuckton (PTO: 7/5 - 7/16)>
Disregard my earlier comment about counts. I refined my search to get around the "too exhaustive warning" and found more instances of `$_` than initially reported.

[13:17:08.0936] <jschoi>
Oh, okay, in that case, never mind. ğŸ¥²

[13:17:25.0096] <jschoi>
 * Oh, okay, in that case, never mind. ğŸ¥²

[13:17:59.0028] <rbuckton (PTO: 7/5 - 7/16)>
cs won't give me accurate counts however, though it seems most cases are either:
```js
var $_ = function ...;
const $_ = ...;
class $_ { ... }
function $_ {}
```

[13:18:35.0196] <rbuckton (PTO: 7/5 - 7/16)>
I'd have to find a different way to query to get more accurate counts from GitHub's corpus of OSS projects.

[13:19:02.0968] <jschoi>
I wonder why they use `$_`, hmm. I guess itâ€™s still true that `$$` is still oftenÂ (?) used to mean `document.querySelectorAll`, probably as an adjunct to jQuery or whatever.

[13:19:32.0412] <jschoi>
I would support an identifier as the topic reference only if the idea is that we would be blessing a new (contextual) keyword, and that, , from now on, developers should never use the keyword as an ordinary variable. Just like `await` and `yield`. This is why I donâ€™t think `it` is acceptable.


[13:20:23.0868] <jschoi>
When I see `await` and `yield`, I donâ€™t have to think, â€œIs this a variable or a keyword?â€Â Because nobody uses them as ordinary variables. This is very much not the case for `it`.


[13:20:24.0326] <jschoi>
If we blessed, say, `$_` into the topic reference as a contextual keyword, then I would expect linters to ban `$_` as an ordinary variableâ€¦just like how (I think?) they do with `await` and `yield`.

[13:20:49.0726] <jschoi>
 * I would support an identifier as the topic reference only if the idea is that we would be blessing a new (contextual) keyword, and that, from now on, developers should never use the keyword as an ordinary variable. Just like `await` and `yield`. This is why I donâ€™t think `it` is acceptable.

[13:21:08.0817] <jschoi>
 * If we blessed, say, `$_` into the topic reference as a contextual keyword, then I would expect linters to ban `$_` as an ordinary variableâ€¦just like how (I think?) they might do with `await` and `yield`.

[13:21:11.0655] <rbuckton (PTO: 7/5 - 7/16)>
I think there are others on the committee that may have a specific tool for querying such usage, but I do know know offhand what that is.

[13:21:13.0714] <jschoi>
 * If we blessed, say, `$_` into the topic reference as a contextual keyword, then I would expect linters to ban `$_` as an ordinary variableâ€¦just like how (I think?) they do with `await` and `yield`.

[13:21:26.0919] <jschoi>
Gzemnid?

[13:31:09.0849] <rbuckton (PTO: 7/5 - 7/16)>
If that's it, I'm not sure what versions of node it works with because it won't install on my machine using a recent version of node :/

[13:34:15.0109] <jschoi>
No need to install anything (maybe except `lz4`). You can download a dataset (last updated in 2019) from https://gzemnid.nodejs.org/datasets/out.2019-06-04/. Then use the `search.topcode.sh` script (download from the same directory).

[14:10:51.0600] <rbuckton (PTO: 7/5 - 7/16)>
```sh
$ ./scripts/search.topcode.sh '[ .(\n]\$\$[ .(\n]' | wc -l
27831
$ ./scripts/search.topcode.sh '[ .(\n]\$\_[ .(\n]' | wc -l
530
```

[14:10:57.0088] <rbuckton (PTO: 7/5 - 7/16)>
 * ```sh
$ ./scripts/search.topcode.sh '[ .(\n]\$\$[ .(\n]' | wc -l
27831
$ ./scripts/search.topcode.sh '[ .(\n]\$\_[ .(\n]' | wc -l
530
```

[14:11:21.0363] <rbuckton (PTO: 7/5 - 7/16)>
Very rough regexp to avoid $$ or $_ in the middle of an identifier.

[14:30:19.0879] <rbuckton (PTO: 7/5 - 7/16)>
still a number of false positives from comments like `// $_` though

[14:40:50.0883] <jschoi>
Nice. We used `| grep -E --invert-match '//.*whatever'` when we tried to analyze Gzemnid for `.bind` and `.call`.

[14:40:58.0078] <jschoi>
 * Nice. We used `grep -E --invert-match '//.*whatever'` when we tried to analyze Gzemnid for `.bind` and `.call`.

[14:41:33.0400] <jschoi>
 * Nice. We used `| grep -E --invert-match '//.*whatever'` when we tried to analyze Gzemnid for `.bind` and `.call`.

[15:13:44.0707] <rbuckton (PTO: 7/5 - 7/16)>
Quite a few false positives due to string literals and comments and this doesn't handle unicode identifiers, but here's an updated query:
```sh
$ ./scripts/search.topcode.sh '[^$_\\[:alnum:]](\$\$)[^$_[:alnum:]]' | wc -l
38639
$ ./scripts/search.topcode.sh '[^$_\\[:alnum:]](\$\_)[^$_[:alnum:]]' | wc -l
629
```

[15:14:25.0018] <rbuckton (PTO: 7/5 - 7/16)>
It's too bad `\P{ID_Continue}` doesn't work in `grep`

[15:39:32.0278] <Richard Gibson>
> <@jschoi:matrix.org> I mildly prefer `$$` to `$_` because: `$_` is already being used in some contexts like browser inspectors (although admittedly this is a niche case; there might be other extant uses), `$$` is indeed easier to type, and `$_` is uglier to me than `$$`. As you know, the fact that `$_` but not `$$` is valid syntax for variables in Bash/Perl/Ruby, so `$_`â€™s use is an incident of those languagesâ€™ peculiarities. 
> But this is a mild preference.

`$$` is also used in browser developer tools: https://developer.chrome.com/docs/devtools/console/utilities/#querySelectorAll-function


2022-07-14
[17:01:13.0401] <Richard Gibson>
> <@rbuckton:matrix.org> It's too bad `\P{ID_Continue}` doesn't work in `grep`

would you settle for GNU awk supporting `/[0-9A-Z_a-zÂªÂµÂ·ÂºÃ€-Ã–Ã˜-Ã¶ Ã¸-ËË†-Ë‘Ë -Ë¤Ë¬Ë®Ì€-Í´Í¶Í·Íº-Í½Í¿Î†-ÎŠ ÎŒÎ-Î¡Î£-ÏµÏ·-ÒÒƒ-Ò‡ÒŠ-Ô¯Ô±-Õ–Õ™Õ -ÖˆÖ‘-Ö½Ö¿××‚×„×…×‡ ×-×ª×¯-×²Ø-ØšØ -Ù©Ù®-Û“Û•-ÛœÛŸ-Û¨Ûª-Û¼ Û¿Ü-İŠİ-Ş±ß€-ßµßºß½à €-à ­à¡€-à¡›à¡ -à¡ª à¡°-à¢‡à¢‰-à¢à¢˜-à£¡à££-à¥£à¥¦-à¥¯à¥±-à¦ƒà¦…-à¦Œ à¦à¦à¦“-à¦¨à¦ª-à¦°à¦²à¦¶-à¦¹à¦¼-à§„à§‡à§ˆà§‹-à§à§— à§œà§à§Ÿ-à§£à§¦-à§±à§¼à§¾à¨-à¨ƒà¨…-à¨Šà¨à¨à¨“-à¨¨ à¨ª-à¨°à¨²à¨³à¨µà¨¶à¨¸à¨¹à¨¼à¨¾-à©‚à©‡à©ˆà©‹-à©à©‘à©™-à©œ à©à©¦-à©µàª-àªƒàª…-àªàª-àª‘àª“-àª¨àªª-àª°àª²àª³ àªµ-àª¹àª¼-à«…à«‡-à«‰à«‹-à«à«à« -à«£à«¦-à«¯à«¹-à«¿à¬-à¬ƒ à¬…-à¬Œà¬à¬à¬“-à¬¨à¬ª-à¬°à¬²à¬³à¬µ-à¬¹à¬¼-à­„à­‡à­ˆà­‹-à­à­•-à­— à­œà­à­Ÿ-à­£à­¦-à­¯à­±à®‚à®ƒà®…-à®Šà®-à®à®’-à®•à®™ à®šà®œà®à®Ÿà®£à®¤à®¨-à®ªà®®-à®¹à®¾-à¯‚à¯†-à¯ˆà¯Š-à¯ à¯à¯—à¯¦-à¯¯à°€-à°Œà°-à°à°’-à°¨à°ª-à°¹à°¼-à±„à±†-à±ˆà±Š-à±à±•à±– à±˜-à±šà±à± -à±£à±¦-à±¯à²€-à²ƒà²…-à²Œà²-à²à²’-à²¨ à²ª-à²³à²µ-à²¹à²¼-à³„à³†-à³ˆà³Š-à³à³•à³–à³à³à³ -à³£ à³¦-à³¯à³±à³²à´€-à´Œà´-à´à´’-àµ„àµ†-àµˆàµŠ-àµàµ”-àµ— àµŸ-àµ£àµ¦-àµ¯àµº-àµ¿à¶-à¶ƒà¶…-à¶–à¶š-à¶±à¶³-à¶» à¶½à·€-à·†à·Šà·-à·”à·–à·˜-à·Ÿà·¦-à·¯à·²à·³à¸-à¸ºà¹€-à¹ à¹-à¹™àºàº‚àº„àº†-àºŠàºŒ-àº£àº¥àº§-àº½à»€-à»„à»†à»ˆ-à» à»-à»™à»œ-à»Ÿà¼€à¼˜à¼™à¼ -à¼©à¼µà¼·à¼¹à¼¾-à½‡à½‰-à½¬à½±-à¾„à¾†-à¾—à¾™-à¾¼à¿† á€€-á‰á-á‚á‚ -áƒ…áƒ‡áƒáƒ-áƒºáƒ¼-á‰ˆá‰Š-á‰á‰-á‰– á‰˜á‰š-á‰á‰ -áŠˆáŠŠ-áŠáŠ-áŠ°áŠ²-áŠµáŠ¸-áŠ¾á‹€á‹‚-á‹… á‹ˆ-á‹–á‹˜-áŒáŒ’-áŒ•áŒ˜-ášá-áŸá©-á±á€-á á -áµá¸-á½á-á™¬á™¯-á™¿áš-áššáš -á›ªá›®-á›¸ áœ€-áœ•áœŸ-áœ´á€-á“á -á¬á®-á°á²á³á€-áŸ“áŸ— áŸœáŸáŸ -áŸ©á -á ™á  -á¡¸á¢€-á¢ªá¢°-á£µá¤€-á¤á¤ -á¤«á¤°-á¤» á¥†-á¥­á¥°-á¥´á¦€-á¦«á¦°-á§‰á§-á§šá¨€-á¨›á¨ -á©á© -á©¼á©¿-áª‰ áª-áª™áª§áª°-áª½áª¿-á«á¬€-á­Œá­-á­™á­«-á­³á®€-á¯³ á°€-á°·á±€-á±‰á±-á±½á²€-á²ˆá²-á²ºá²½-á²¿á³-á³’á³”-á³º á´€-á¼•á¼˜-á¼á¼ -á½…á½ˆ-á½á½-á½—á½™á½›á½á½Ÿ-á½½ á¾€-á¾´á¾¶-á¾¼á¾¾á¿‚-á¿„á¿†-á¿Œá¿-á¿“á¿–-á¿›á¿ -á¿¬ á¿²-á¿´á¿¶-á¿¼â€¿â€â”â±â¿â‚-â‚œâƒ-âƒœâƒ¡âƒ¥-âƒ° â„‚â„‡â„Š-â„“â„•â„˜-â„â„¤â„¦â„¨â„ª-â„¹â„¼-â„¿â……-â…‰ â…â… -â†ˆâ°€-â³¤â³«-â³³â´€-â´¥â´§â´­â´°-âµ§âµ¯âµ¿-â¶– â¶ -â¶¦â¶¨-â¶®â¶°-â¶¶â¶¸-â¶¾â·€-â·†â·ˆ-â·â·-â·– â·˜-â·â· -â·¿ã€…-ã€‡ã€¡-ã€¯ã€±-ã€µã€¸-ã€¼ã-ã‚–ã‚™-ã‚Ÿ ã‚¡-ãƒºãƒ¼-ãƒ¿ã„…-ã„¯ã„±-ã†ã† -ã†¿ã‡°-ã‡¿ã€-ä¶¿ ä¸€-ê’Œê“-ê“½ê”€-ê˜Œê˜-ê˜«ê™€-ê™¯ê™´-ê™½ê™¿-ê›± êœ—-êœŸêœ¢-êˆê‹-êŸŠêŸêŸ‘êŸ“êŸ•-êŸ™êŸ²-ê §ê ¬ê¡€-ê¡³ê¢€-ê£… ê£-ê£™ê£ -ê£·ê£»ê£½-ê¤­ê¤°-ê¥“ê¥ -ê¥¼ê¦€-ê§€ê§-ê§™ ê§ -ê§¾ê¨€-ê¨¶ê©€-ê©ê©-ê©™ê© -ê©¶ê©º-ê«‚ê«›-ê« ê« -ê«¯ê«²-ê«¶ê¬-ê¬†ê¬‰-ê¬ê¬‘-ê¬–ê¬ -ê¬¦ê¬¨-ê¬® ê¬°-ê­šê­œ-ê­©ê­°-ê¯ªê¯¬ê¯­ê¯°-ê¯¹ê°€-í£í°-íŸ†íŸ‹-íŸ» ï¤€-ï©­ï©°-ï«™ï¬€-ï¬†ï¬“-ï¬—ï¬-ï¬¨ï¬ª-ï¬¶ï¬¸-ï¬¼ ï¬¾ï­€ï­ï­ƒï­„ï­†-ï®±ï¯“-ï´½ïµ-ï¶ï¶’-ï·‡ï·°-ï·»ï¸ -ï¸¯ ï¸³ï¸´ï¹-ï¹ï¹°-ï¹´ï¹¶-ï»¼ï¼-ï¼™ï¼¡-ï¼ºï¼¿ï½-ï½š ï½¦-ï¾¾ï¿‚-ï¿‡ï¿Š-ï¿ï¿’-ï¿—ï¿š-ï¿œğ€€-ğ€‹ğ€-ğ€¦ ğ€¨-ğ€ºğ€¼ğ€½ğ€¿-ğğ-ğğ‚€-ğƒºğ…€-ğ…´ğ‡½ğŠ€-ğŠœ ğŠ -ğ‹ğ‹ ğŒ€-ğŒŸğŒ­-ğŠğ-ğºğ€-ğğ -ğƒğˆ-ğ ğ‘-ğ•ğ€-ğ’ğ’ -ğ’©ğ’°-ğ““ğ“˜-ğ“»ğ”€-ğ”§ğ”°-ğ•£ ğ•°-ğ•ºğ•¼-ğ–Šğ–Œ-ğ–’ğ–”ğ–•ğ–—-ğ–¡ğ–£-ğ–±ğ–³-ğ–¹ğ–» ğ–¼ğ˜€-ğœ¶ğ€-ğ•ğ -ğ§ğ€-ğ…ğ‡-ğ°ğ²-ğºğ €-ğ … ğ ˆğ Š-ğ µğ ·ğ ¸ğ ¼ğ ¿-ğ¡•ğ¡ -ğ¡¶ğ¢€-ğ¢ğ£ -ğ£²ğ£´ğ£µ ğ¤€-ğ¤•ğ¤ -ğ¤¹ğ¦€-ğ¦·ğ¦¾ğ¦¿ğ¨€-ğ¨ƒğ¨…ğ¨†ğ¨Œ-ğ¨“ğ¨•-ğ¨— ğ¨™-ğ¨µğ¨¸-ğ¨ºğ¨¿ğ© -ğ©¼ğª€-ğªœğ«€-ğ«‡ğ«‰-ğ«¦ğ¬€-ğ¬µ ğ­€-ğ­•ğ­ -ğ­²ğ®€-ğ®‘ğ°€-ğ±ˆğ²€-ğ²²ğ³€-ğ³²ğ´€-ğ´§ ğ´°-ğ´¹ğº€-ğº©ğº«ğº¬ğº°ğº±ğ¼€-ğ¼œğ¼§ğ¼°-ğ½ğ½°-ğ¾…ğ¾°-ğ¿„ ğ¿ -ğ¿¶ğ‘€€-ğ‘†ğ‘¦-ğ‘µğ‘¿-ğ‘‚ºğ‘ƒ‚ğ‘ƒ-ğ‘ƒ¨ğ‘ƒ°-ğ‘ƒ¹ğ‘„€-ğ‘„´ ğ‘„¶-ğ‘„¿ğ‘…„-ğ‘…‡ğ‘…-ğ‘…³ğ‘…¶ğ‘†€-ğ‘‡„ğ‘‡‰-ğ‘‡Œğ‘‡-ğ‘‡šğ‘‡œğ‘ˆ€-ğ‘ˆ‘ ğ‘ˆ“-ğ‘ˆ·ğ‘ˆ¾ğ‘Š€-ğ‘Š†ğ‘Šˆğ‘ŠŠ-ğ‘Šğ‘Š-ğ‘Šğ‘ŠŸ-ğ‘Š¨ğ‘Š°-ğ‘‹ªğ‘‹°-ğ‘‹¹ğ‘Œ€-ğ‘Œƒ ğ‘Œ…-ğ‘ŒŒğ‘Œğ‘Œğ‘Œ“-ğ‘Œ¨ğ‘Œª-ğ‘Œ°ğ‘Œ²ğ‘Œ³ğ‘Œµ-ğ‘Œ¹ğ‘Œ»-ğ‘„ğ‘‡ğ‘ˆğ‘‹-ğ‘ ğ‘ğ‘—ğ‘-ğ‘£ğ‘¦-ğ‘¬ğ‘°-ğ‘´ğ‘€-ğ‘‘Šğ‘‘-ğ‘‘™ğ‘‘-ğ‘‘¡ğ‘’€-ğ‘“… ğ‘“‡ğ‘“-ğ‘“™ğ‘–€-ğ‘–µğ‘–¸-ğ‘—€ğ‘—˜-ğ‘—ğ‘˜€-ğ‘™€ğ‘™„ğ‘™-ğ‘™™ğ‘š€-ğ‘š¸ ğ‘›€-ğ‘›‰ğ‘œ€-ğ‘œšğ‘œ-ğ‘œ«ğ‘œ°-ğ‘œ¹ğ‘€-ğ‘†ğ‘ €-ğ‘ ºğ‘¢ -ğ‘£© ğ‘£¿-ğ‘¤†ğ‘¤‰ğ‘¤Œ-ğ‘¤“ğ‘¤•ğ‘¤–ğ‘¤˜-ğ‘¤µğ‘¤·ğ‘¤¸ğ‘¤»-ğ‘¥ƒğ‘¥-ğ‘¥™ğ‘¦ -ğ‘¦§ ğ‘¦ª-ğ‘§—ğ‘§š-ğ‘§¡ğ‘§£ğ‘§¤ğ‘¨€-ğ‘¨¾ğ‘©‡ğ‘©-ğ‘ª™ğ‘ªğ‘ª°-ğ‘«¸ğ‘°€-ğ‘°ˆ ğ‘°Š-ğ‘°¶ğ‘°¸-ğ‘±€ğ‘±-ğ‘±™ğ‘±²-ğ‘²ğ‘²’-ğ‘²§ğ‘²©-ğ‘²¶ğ‘´€-ğ‘´† ğ‘´ˆğ‘´‰ğ‘´‹-ğ‘´¶ğ‘´ºğ‘´¼ğ‘´½ğ‘´¿-ğ‘µ‡ğ‘µ-ğ‘µ™ğ‘µ -ğ‘µ¥ğ‘µ§ğ‘µ¨ğ‘µª-ğ‘¶ğ‘¶ğ‘¶‘ğ‘¶“-ğ‘¶˜ ğ‘¶ -ğ‘¶©ğ‘» -ğ‘»¶ğ‘¾°ğ’€€-ğ’™ğ’€-ğ’‘®ğ’’€-ğ’•ƒğ’¾-ğ’¿°ğ“€€-ğ“® ğ”€-ğ”™†ğ– €-ğ–¨¸ğ–©€-ğ–©ğ–© -ğ–©©ğ–©°-ğ–ª¾ğ–«€-ğ–«‰ğ–«-ğ–«­ğ–«°-ğ–«´ ğ–¬€-ğ–¬¶ğ–­€-ğ–­ƒğ–­-ğ–­™ğ–­£-ğ–­·ğ–­½-ğ–®ğ–¹€-ğ–¹¿ğ–¼€-ğ–½Šğ–½-ğ–¾‡ğ–¾-ğ–¾Ÿ ğ–¿ ğ–¿¡ğ–¿£ğ–¿¤ğ–¿°ğ–¿±ğ—€€-ğ˜Ÿ·ğ˜ €-ğ˜³•ğ˜´€-ğ˜´ˆğš¿°-ğš¿³ğš¿µ-ğš¿» ğš¿½ğš¿¾ğ›€€-ğ›„¢ğ›…-ğ›…’ğ›…¤-ğ›…§ğ›…°-ğ›‹»ğ›°€-ğ›±ªğ›±°-ğ›±¼ğ›²€-ğ›²ˆ ğ›²-ğ›²™ğ›²ğ›²ğœ¼€-ğœ¼­ğœ¼°-ğœ½†ğ…¥-ğ…©ğ…­-ğ…²ğ…»-ğ†‚ğ†…-ğ†‹ğ†ª-ğ†­ğ‰‚-ğ‰„ ğ€-ğ‘”ğ‘–-ğ’œğ’ğ’Ÿğ’¢ğ’¥ğ’¦ğ’©-ğ’¬ğ’®-ğ’¹ğ’»ğ’½-ğ“ƒ ğ“…-ğ”…ğ”‡-ğ”Šğ”-ğ””ğ”–-ğ”œğ”-ğ”¹ğ”»-ğ”¾ğ•€-ğ•„ ğ•†ğ•Š-ğ•ğ•’-ğš¥ğš¨-ğ›€ğ›‚-ğ›šğ›œ-ğ›ºğ›¼-ğœ”ğœ–-ğœ´ ğœ¶-ğğ-ğ®ğ°-ğˆğŠ-ğ¨ğª-ğŸ‚ğŸ„-ğŸ‹ğŸ-ğŸ¿ğ¨€-ğ¨¶ğ¨»-ğ©¬ğ©µğª„ğª›-ğªŸğª¡-ğª¯ ğ¼€-ğ¼ğ€€-ğ€†ğ€ˆ-ğ€˜ğ€›-ğ€¡ğ€£ğ€¤ğ€¦-ğ€ªğ„€-ğ„¬ğ„°-ğ„½ ğ…€-ğ…‰ğ…ğŠ-ğŠ®ğ‹€-ğ‹¹ğŸ -ğŸ¦ğŸ¨-ğŸ«ğŸ­ğŸ®ğŸ°-ğŸ¾ ğ €-ğ£„ğ£-ğ£–ğ¤€-ğ¥‹ğ¥-ğ¥™ğ¸€-ğ¸ƒğ¸…-ğ¸Ÿğ¸¡ğ¸¢ğ¸¤ ğ¸§ğ¸©-ğ¸²ğ¸´-ğ¸·ğ¸¹ğ¸»ğ¹‚ğ¹‡ğ¹‰ğ¹‹ğ¹-ğ¹ğ¹‘ğ¹’ğ¹”ğ¹—ğ¹™ ğ¹›ğ¹ğ¹Ÿğ¹¡ğ¹¢ğ¹¤ğ¹§-ğ¹ªğ¹¬-ğ¹²ğ¹´-ğ¹·ğ¹¹-ğ¹¼ğ¹¾ğº€-ğº‰ ğº‹-ğº›ğº¡-ğº£ğº¥-ğº©ğº«-ğº»ğŸ¯°-ğŸ¯¹ğ €€-ğª›Ÿğªœ€-ğ«œ¸ ğ«€-ğ« ğ«  -ğ¬º¡ğ¬º°-ğ®¯ ğ¯ €-ğ¯¨ğ°€€-ğ±Š]/`?

(pattern extracted from https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%5B%3AID_Continue%3A%5D%26%5B%3AVariation_Selector%3DNo%3A%5D%5D&g=&i= , which is technically incorrect because it excludes variation selectors but is otherwise good)

[17:18:15.0705] <shu>
what sorcery is this


2022-07-15
[05:25:29.0557] <jschoi>
https://github.com/tc39/proposal-pipeline-operator/issues/217#issuecomment-1184910976â€¨
> Edit: After it was clarified a more independent route of addressing my concerns can be feasible in the future, contrary to what I interpreted from strong stances expressed to me recently, I will bow out of these discussions indefinitely accordingly. My feedback regarding hack-style pipes impact on the functional-programming ecosystem can always be revisited whenever it next makes sense.
***

I wonder to what this is referring; it was a pretty sudden change.

[05:27:11.0929] <jschoi>
 The closest thing I can think of is my mentioning in https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1184950270 of the (small) possibility that Function.pipe and/or flow may be standardized, and that developers may use pipe/flow widely enough to warrant considering split-mix syntax again: `x |>> f |>> g |>> h |> [^^]`.

[05:27:35.0342] <jschoi>
* https://github.com/tc39/proposal-pipeline-operator/issues/217#issuecomment-1184910976
Edit: After it was clarified a more independent route of addressing my concerns can be feasible in the future, contrary to what I interpreted from strong stances expressed to me recently, I will bow out of these discussions indefinitely accordingly. My feedback regarding hack-style pipes impact on the functional-programming ecosystem can always be revisited whenever it next makes sense.
I wonder to what this is referring; it was a pretty sudden change.

[05:27:53.0154] <jschoi>
* https://github.com/tc39/proposal-pipeline-operator/issues/217#issuecomment-1184910976â€¨
> Edit: After it was clarified a more independent route of addressing my concerns can be feasible in the future, contrary to what I interpreted from strong stances expressed to me recently, I will bow out of these discussions indefinitely accordingly. My feedback regarding hack-style pipes impact on the functional-programming ecosystem can always be revisited whenever it next makes sense.â€¨
I wonder to what this is referring; it was a pretty sudden change.

[05:28:06.0667] <jschoi>
* https://github.com/tc39/proposal-pipeline-operator/issues/217#issuecomment-1184910976â€¨
> Edit: After it was clarified a more independent route of addressing my concerns can be feasible in the future, contrary to what I interpreted from strong stances expressed to me recently, I will bow out of these discussions indefinitely accordingly. My feedback regarding hack-style pipes impact on the functional-programming ecosystem can always be revisited whenever it next makes sense.
***

I wonder to what this is referring; it was a pretty sudden change.

[09:23:50.0176] <TabAtkins>
Me and Shu talked with them privately

[10:59:42.0005] <ljharb>
any chance long essay-like comments were discouraged in these conversations?

[11:09:22.0996] <TabAtkins>
Very explicitly by me, yes.

[11:09:39.0247] <TabAtkins>
Like, ended the conversation with "don't do this"


2022-07-22
[17:57:00.0153] <sffc>
Hi all, jschoi invited me to this channel. I expressed the position during the meeting today that I think it would be worthwhile to continue exploring the space of API functions for method chaining. Although the Function.pipe proposal didn't reach Stage 1, I think it would be helpful to consider that direction in the context of the Pipeline proposal.

The Pipeline champions considered "hack style" and "F# style" options for the pipeline proposal. I would like to see how the use cases would pan out with a third "API style" option. In other words, take the examples that motivate the pipeline syntax operator and show how they would work with Function.pipe, Function.pipeAsync, etc.

[18:05:34.0083] <sffc>
Opened an issue: https://github.com/tc39/proposal-pipeline-operator/issues/273

[20:40:10.0815] <jschoi>
Well, we could do an explicit comparison between topic pipe and pipe function in the explainer, butâ€¦chances are itâ€™s not going to get very far. 
Pipe functions donâ€™t pipe through n-arg function calls, array/object literals, or other things, other than await for pipeAsync. 
I never wanted to position the pipe/flow functions as anything other than an adjunct to the topic pipe. 

[20:43:29.0376] <jschoi>
sffc: I had actually invited you to the room here, primarily, to let both you and HE Shi-Jun know that Iâ€™m planning to withdraw proposal-function-pipe-flow, and I wanted to offer championing that proposal to you before I archive it. Otherwise I would make it inactive, since I just donâ€™t see any significant chance of it advancing in Committee given the feedback I got today. (My apologies for not making this clearer in my direct message!)

[20:44:34.0609] <jschoi>
(Also, a forewarning: that proposal-pipeline-operatorâ€™s issues can get very hot. Weâ€™ve had numerous CoC problems in that repository. ğŸ¥²)

[20:44:59.0586] <jschoi>
 * sffc: I had actually invited you to the room here, primarily, to let both you and HE Shi-Jun know that Iâ€™m planning to withdraw proposal-function-pipe-flow, and I wanted to offer championing that proposal to you before I archive it. Otherwise I would make it inactive, since I just donâ€™t see any significant chance of it advancing in Committee given the feedback I got today. (My apologies for not making this clearer in my direct message!)

[20:49:36.0725] <jschoi>
Anyways, regarding your new issue, it might be worth at least exploring the possibility of replacing operators with API. But I suspect it will not get far. For example, consider the explainerâ€™s first example, from React:

```js
console.log(
  chalk.dim(
    `$ ${Object.keys(envars)
      .map(envar =>
        `${envar}=${envars[envar]}`)
      .join(' ')
    }`,
    'node',
    args.join(' ')));
```

This is not an example where the pipe function would shine:

```js
pipe(
  Object.keys(envars)
    .map(envar => `${envar}=${envars[envar]}`)
    .join(' '),
  $ => `$ ${%}`,
  $ => chalk.dim(%, 'node', args.join(' ')),
  $ => console.log(%),
);
```

The explainerâ€™s â€œreal-world codeâ€ section has many examples like this. 

[20:49:55.0459] <jschoi>
 * Anyways, regarding your new issue, it might be worth at least exploring the possibility of replacing operators with API. But I suspect it will not get far. For example, consider the explainerâ€™s first example, from React:

```js
console.log(
  chalk.dim(
    `$ ${Object.keys(envars)
      .map(envar =>
        `${envar}=${envars[envar]}`)
      .join(' ')
    }`,
    'node',
    args.join(' ')));
```

This is not an example where the pipe function would shine:

```js
pipe(
  Object.keys(envars)
    .map(envar => `${envar}=${envars[envar]}`)
    .join(' '),
  $ => `$ ${%}`,
  $ => chalk.dim(%, 'node', args.join(' ')),
  $ => console.log(%),
);
```

The explainerâ€™s â€œreal-world codeâ€ section has many examples like this. 

[20:52:21.0599] <jschoi>
(To be honest, I had wanted to wait until we decided exactly what we should do with proposal-function-pipe-flowâ€”withdraw and archive versus transfer championing to you or Haxâ€”before we announced that it failed to get StageÂ 1. Because thereâ€™s a good chance that people are going to get heated after the announcement, so I wanted to make sure we had a coordinated presentation to the community when we announced it. My apologies for not making this clear! Please do let me know if you want to champion proposal-function-pipe-flow or if you are fine with me withdrawing it.)

[20:54:31.0229] <jschoi>
 * Anyways, regarding your new issue, it might be worth at least exploring the possibility of replacing operators with API. But I suspect it will not get far. For example, consider the explainerâ€™s first example, from React:

```js
console.log(
  chalk.dim(
    `$ ${Object.keys(envars)
      .map(envar =>
        `${envar}=${envars[envar]}`)
      .join(' ')
    }`,
    'node',
    args.join(' ')));
```

This is not an example where the pipe function would shine:

```js
pipe(
  Object.keys(envars)
    .map(envar => `${envar}=${envars[envar]}`)
    .join(' '),
  $ => `$ ${%}`,
  $ => chalk.dim(%, 'node', args.join(' ')),
  console.log,
);
```

The explainerâ€™s â€œreal-world codeâ€ section has many examples like this.

[20:55:22.0873] <jschoi>
 * Anyways, regarding your new issue, it might be worth at least exploring the possibility of replacing operators with API. But I suspect it will not get far. For example, consider the explainerâ€™s first example, from React:

```js
console.log(
  chalk.dim(
    `$ ${Object.keys(envars)
      .map(envar =>
        `${envar}=${envars[envar]}`)
      .join(' ')
    }`,
    'node',
    args.join(' ')));
```

This is not an example where the pipe function would shine compared to the pipe operator (especially given the encouraging-throwaway-closures concern from the engines):

```js
pipe(
  Object.keys(envars)
    .map(envar => `${envar}=${envars[envar]}`)
    .join(' '),
  $ => `$ ${%}`,
  $ => chalk.dim(%, 'node', args.join(' ')),
  console.log,
);
```

The explainerâ€™s â€œreal-world codeâ€ section has many examples like this.

[20:56:40.0123] <jschoi>
 * Anyways, regarding your new issue, it might be worth at least exploring the possibility of replacing operators with API. But I suspect it will not get far. For example, consider the explainerâ€™s first example, from React:

```js
console.log(
  chalk.dim(
    `$ ${Object.keys(envars)
      .map(envar =>
        `${envar}=${envars[envar]}`)
      .join(' ')
    }`,
    'node',
    args.join(' ')));
```

This is not an example where the pipe function would shine compared to the pipe operator (especially given the encouraging-throwaway-closures concern from the engines):

```js
pipe(
  Object.keys(envars)
    .map(envar => `${envar}=${envars[envar]}`)
    .join(' '),
  v => `$ ${v}`,
  v => chalk.dim(v, 'node', args.join(' ')),
  console.log,
);
```

The explainerâ€™s â€œreal-world codeâ€ section has many examples like this.

[20:57:17.0121] <sffc>
Hey! If you can post those examples on my issue that would be great to get the conversation started

[20:58:42.0685] <sffc>
I'm not currently interested in championing the proposal. But maybe in the future. I think the best path is to finish the main pipeline proposal, get people to start using it, and then a year later, reopen this proposal. That's a multi-year process but things in TC39 take time :)

[21:00:48.0042] <sffc>
Actually the iterator helpers proposal is a good example of that. Iterators have been around for several years now but they didn't come with a lot of standard library functions. So now the champions of iterator helpers can point to packages people have made to work around limitations in iterators in order to motivate their proposal.

[21:00:48.0887] <jschoi>
Sounds good; thank you! (Iâ€™ll give HE Shi-Jun a few days to also respond before I freeze the repository.)

[21:01:55.0280] <sffc>
So basically, after pipeline gets users, you can point to pain points to motivate the Function.pipe proposal.

[21:09:32.0821] <jschoi>
sffc: Would you mind also getting rid of the mention, from your issue text, that proposal-function-pipe-flow failed to reach StageÂ 1? I want to publicly announce it myself first in the announcement thread in a few days.

[21:10:13.0747] <jschoi>
 * sffc: Would you mind also getting rid of the mention, from your issue text, that proposal-function-pipe-flow failed to reach StageÂ 1? I want to publicly announce it myself first in the announcement thread in a few days, after Iâ€™ve determined what its fate is going to be.

[21:12:01.0657] <jschoi>
 * sffc: Would you mind also getting rid of the mention, from your issue text, that proposal-function-pipe-flow failed to reach StageÂ 1? I want to be the first to broadly announce it myself in the announcement thread, after Iâ€™ve determined what the repositoryâ€™s fate is going to be. 

[21:14:26.0418] <sffc>
> <@jschoi:matrix.org> sffc: Would you mind also getting rid of the mention, from your issue text, that proposal-function-pipe-flow failed to reach StageÂ 1? I want to be the first to broadly announce it myself in the announcement thread, after Iâ€™ve determined what the repositoryâ€™s fate is going to be. 

Done 

[21:15:10.0865] <jschoi>
Thank you! And welcome to the pipe room!ğŸš°

[21:59:06.0040] <rkirsling>
https://static.wikia.nocookie.net/mario/images/4/44/SMB_Warpzone.png/revision/latest?cb=20200331123731

