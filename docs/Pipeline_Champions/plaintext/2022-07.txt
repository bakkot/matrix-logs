2022-07-07
[10:32:39.0232] <jschoi>
Yeah, TabAtkins, thanks for continuing to engage with him and others‚ÄîI‚Äôve been really busy myself, so I haven‚Äôt been able to work much on outreach or updates myself. üòî

[13:25:11.0750] <TabAtkins>
And now I'm back to just closing issue threads because the participants refuse to stay on topic and instead keep relitigating the core question. :/

[13:26:02.0737] <TabAtkins>
Should have done that one weeks ago, but I know Kevin personally and wanted to keep things friendly, but good *lord* I do not have time nor interest to engage in dueling essays where every point was brought up and addressed last year.

[13:29:00.0837] <TabAtkins>
(if he has made novel points I missed them in the screenfuls of text that each post of his produces)

[13:29:32.0997] <jschoi>
Insofar that we have already addressed many points of argument that people keep perseverating over, we should add an FAQ section or an FAQ document that summarizes positions, so we could simply point to them every time something gets brought up again. I‚Äôve meant to do this for a year now, but I just haven‚Äôt had time. My apologies about this‚Äîmaybe if I had done so earlier, we would have had you deal with a few less circular threads. 

[13:29:45.0390] <TabAtkins>
I doubt it. ^_^

[13:33:52.0041] <shu>
at least stare decisis have entered people's vocabularies recently

[13:34:21.0454] <TabAtkins>
ah yes, the "stand your ground" rule

[13:34:33.0866] <shu>
though i guess in this case it's more like res judicata than stare decisis

[13:34:40.0159] <shu>
 * though i guess in this case it's more like res judicata than stare decisis

[13:47:37.0559] <jschoi>
‚ÄúStare decisis‚Äù (n.): The act of staring decisively at each other, without budging.

[14:20:27.0031] <rkirsling>
this has truly been a depressing proposal, sociologically speaking

[14:22:39.0842] <TabAtkins>
huh, for some reason I can't hide Kevin's latest response in https://github.com/tc39/proposal-pipeline-operator/issues/238#issuecomment-1178231937 (but could hide his earlier ones)

[15:09:32.0938] <ljharb>
TabAtkins: sometimes i see no "hide" link present, especially when the anchor link points to that specific comment - i usually click the timestamp of another comment and hard-refresh

[15:11:32.0129] <TabAtkins>
Ah, that was indeed the problem. How confusing. Thanks!

[15:22:39.0271] <rbuckton (PTO: 7/5 - 7/16)>
Have we ever tried to quantify how much of the ecosystem prefers Hack-style vs. F#-style? It's unfortunate that much of the early negative response was so vitrolic, but I still wonder if Hack-style was the right direction. This proposal constantly feels like it's being pushed uphill. 

[15:26:58.0909] <shu>
do you plan to hire Pew?

[15:28:00.0903] <rbuckton (PTO: 7/5 - 7/16)>
No, no budget for that

[15:33:20.0793] <jschoi>
For what it‚Äôs worth, I view reconciliation with call-this syntax to be a much greater obstacle to pipe operator compared to its syntax particulars like Hack/F#‚Äîor the choice of the topic, for that matter.‚Ä®(That is, Jordan‚Äôs prior condition to pipe‚Äôs advancement to Stage¬†2 that a this-binding-or-calling syntax also ‚Äúeventually‚Äù advance, and the fact that we have some strong opposition to any such this-binding/calling syntax.)‚Ä®This is one of the two topics that the pipe incubator was chartered to discuss, and we might have some time this plenary to discuss it. But if pipe fails to ever reach Stage¬†4, it‚Äôs going to be because of that critical issue.

[15:33:42.0026] <jschoi>
> <@rbuckton:matrix.org> Have we ever tried to quantify how much of the ecosystem prefers Hack-style vs. F#-style? It's unfortunate that much of the early negative response was so vitrolic, but I still wonder if Hack-style was the right direction. This proposal constantly feels like it's being pushed uphill. 

 * For what it‚Äôs worth, I view reconciliation with call-this syntax to be a much greater obstacle to pipe operator compared to its syntax particulars like Hack/F#‚Äîor the choice of the topic, for that matter.‚Ä®(That is, Jordan‚Äôs prior condition to pipe‚Äôs advancement to Stage¬†2 that a this-binding-or-calling syntax also ‚Äúeventually‚Äù advance, and the fact that we have some strong opposition to any such this-binding/calling syntax.)‚Ä®This is one of the two topics that the pipe incubator was chartered to discuss, and we might have some time this plenary to discuss it. But if pipe fails to ever reach Stage¬†4, it‚Äôs going to be because of that critical issue.

[15:34:06.0966] <jschoi>
‚ÄúThe default is that neither proposal advances, and I‚Äôm fine with that,‚Äù so to speak. Well, I can sympathize with gatekeeping [what‚Äôs left of] the core language‚Äôs simplicity, even if I shed one tear doing so. :‚Äô)

[15:34:40.0697] <jschoi>
* ‚ÄúThe default is that neither proposal advances, and I‚Äôm fine with that,‚Äù so to speak. Well, I can sympathize with gatekeeping [what‚Äôs left of] the core language‚Äôs simplicity, even if I shed one tear doing so. :‚Äô)

[15:35:36.0171] <rbuckton (PTO: 7/5 - 7/16)>
I am still, and probably always be, in favor of F#-style + PFA, even with the limitations regarding yield and await. 

[15:37:02.0585] <jschoi>
* That is to say, Jordan will probably always block Stage¬†4 for pipe unless call-this or something like it reaches Stage¬†3 or 4, as he essentially warned when it reached Stage¬†2 way back c. 2017. 

And (someone else‚Äôs words) ‚Äúthe default is that neither proposal advances, and I‚Äôm fine with that,‚Äù so to speak. I suppose I can sympathize with gatekeeping [what‚Äôs left of] the core language‚Äôs simplicity, even if I shed one tear doing so. :‚Äô)

[15:40:25.0270] <jschoi>
I can certainly sympathize, though my perspective is colored by my Clojure heritage. Speaking of which, there‚Äôs always Elixir style. Or Clojure‚Äôs operator-all-the-pipes-they‚Äôre-all-just-macros style (->, ->>, as->, cond->, etc.), heh.

[15:40:35.0341] <jschoi>
* I can certainly sympathize, though my perspective is colored by my Clojure heritage. Speaking of which, there‚Äôs always Elixir style. Or Clojure‚Äôs operator-all-the-pipes-they‚Äôre-all-just-macros style (->, ->>, as->, cond->, etc.), heh.

[15:56:38.0902] <rbuckton (PTO: 7/5 - 7/16)>
> <@jschoi:matrix.org> I can certainly sympathize, though my perspective is colored by my Clojure heritage. Speaking of which, there‚Äôs always Elixir style. Or Clojure‚Äôs operator-all-the-pipes-they‚Äôre-all-just-macros style (->, ->>, as->, cond->, etc.), heh.

Strongly imposed to Elixir style implicit parameter injection, it just adds more confusion over JS's existing implicit `this`. 

[15:58:26.0183] <rbuckton (PTO: 7/5 - 7/16)>
At least both Hack-style and F#-style are explicit. Hack-style with a topic, F#-style with `x |> F` meaning `F(x)` (plus PFA explicit placeholders). 

[16:00:08.0272] <rbuckton (PTO: 7/5 - 7/16)>
And I still feel if you're using `|>` to do simple expressions like `a + b`, you're holding it wrong. Its the wrong tool for the job. 

[16:01:15.0286] <jschoi>
Yeah, I agree about Elixir style. Anyways, all of these things are different ways to deal with the dichotomy between unary functional languages and n-ary functional languages. Something like a unary‚Äìn-ary functional impedance mismatch, to varying degrees.

[16:01:20.0809] <jschoi>
* Yeah, I agree about Elixir style. Anyways, all of these things are different ways to deal with the dichotomy between unary functional languages and n-ary functional languages. Something like a unary‚Äìn-ary functional impedance mismatch, to varying degrees.

[16:02:19.0086] <ljharb>
i suspect pipeline is the right tool for the job any time you have something complex to pass into a function, or a function call's return value to pass into a function.

[16:04:37.0360] <rbuckton (PTO: 7/5 - 7/16)>
> <@ljharb:matrix.org> i suspect pipeline is the right tool for the job any time you have something complex to pass into a function, or a function call's return value to pass into a function.

That's exactly my point. Piping through functions is the right use. The contrived `x |> % + 1` examples are the ones I think are a poor use.

[16:05:07.0864] <ljharb>
sure. but i don't think those are at all the only ones that support hack

[16:05:45.0586] <rbuckton (PTO: 7/5 - 7/16)>
I'd much rather have `do {}` or a `let..in` syntax for those cases.

[16:06:03.0177] <ljharb>
personally i have a bunch of examples that would work equally well in either style, and a bunch of examples where hack avoids creating a bunch of extra arrow functions, and close to zero examples (but nonzero) where F# is simpler

[16:10:46.0703] <jschoi>
I think `complexExpr |> % + 1` is contrived insofar that you could always replace it with `complexExpr + 1`. It‚Äôs because `+` is a fairly loose operator. In contrast, `complexExpr |> % ** 2` may not be so contrived, since otherwise it probably would have to be `(complexExpr) ** 2` with parentheses‚Äîand now imagine tacking on more and more (syntactically tight) operations‚Ä¶

[16:17:18.0363] <jschoi>
Function calls are a very syntactically tight operation, involving circumflex operators. It is for that reason that it is quite inconvenient to write and to read deeply nested function calls. But this is also generalizable to deeply nested ‚Äúsyntactically tight operations‚Äù, of which function calls are a subset. + expressions don‚Äôt fit as well in that set, but there are other ones that do.
(And there‚Äôs also prefix operations like await and -‚Äîeven though they are syntactically loose, they also mess with writing and reading when applied to deeply nested expressions due to reading order switching between LTR and RTL.)
*Both* F# pipes and Hack pipes try to solve *all* these problems, in their own ways (e.g., `veryDeeplyNestedExpression |> negate` vs. `veryDeeplyNestedExpression |> -%`.

[16:19:18.0870] <jschoi>
* Function calls are a very syntactically tight operation, involving circumflex operators. It is for that reason that it is quite inconvenient to write and to read deeply nested function calls. But this is also generalizable to deeply nested ‚Äúsyntactically tight operations‚Äù, of which function calls are a subset. + expressions don‚Äôt fit as well in that set, but there are other ones that do.
(And there‚Äôs also prefix operations like await and -‚Äîeven though they are syntactically loose, they also mess with writing and reading when applied to deeply nested expressions due to reading order switching between LTR and RTL.)
*Both* F# pipes and Hack pipes try to solve *all* these problems, in their own ways (e.g., `veryDeeplyNestedExpression |> negate` vs. `veryDeeplyNestedExpression |> -%`.


2022-07-08
[18:48:52.0922] <rkirsling>
(oh man I know that was just a typo but the idea of a language where a combining circumflex would serve as an operator is quite amusing to me)


2022-07-09
[19:38:25.0282] <TabAtkins>
Every time someone says "non-function use-cases are contrived" I look back at all the times I've gone "fuck, I wish I had pipeline right now, this is kinda annoying to write" and how they're a pretty substantial mix of functions and operators and just go.... really?

[19:39:14.0940] <TabAtkins>
I fundamentally do not understand how this assertion can be made when I know for a fact how many times I, personally, want non-functions.

[19:42:42.0391] <TabAtkins>
> <@ljharb:matrix.org> personally i have a bunch of examples that would work equally well in either style, and a bunch of examples where hack avoids creating a bunch of extra arrow functions, and close to zero examples (but nonzero) where F# is simpler

Yes, this is my experience precisely. I often want to pipe into functions (sometimes unary, sometimes not; PFA would address the latter cases), but I also often want to linearize other things (mostly math stuff, calling methods on something complex, and of course `await` every. single. fucking. time). 

[10:04:45.0583] <Richard Gibson>
I frequently want to construct e.g. a Map or Set, which currently requires `new` (as in `‚Ä¶ |> (entries => new Map(entries))` if tacit/point-free or `‚Ä¶ |> (new Map(^))` if not)

[10:24:07.0653] <jschoi>
Did we ever consider `*` as a topic token? `f() |> g({ x: * })`. I don‚Äôt remember why `*` was disqualified, if it was at all.

(Otherwise, the top runner is `^^`, given `@`‚Äôs recent problems found by WH.)

[10:24:30.0254] <jschoi>
Is it because of yield *? (This is such a rare case that we could require it to be `yield (*)`.)

[10:24:58.0058] <jschoi>
* Is it because of yield *? (This is such a rare case that we could require it to be `yield (*)`.)

[10:25:07.0397] <jschoi>
* Is it because of `yield *`? (This is such a rare case that we could require it to be `yield (*)`.)

[10:27:01.0089] <jschoi>
Or maybe it‚Äôs because of `**`‚Ä¶`f() |> g(**2)` is terrible but we would probably require separation between topic `*` and binary `*`/`**` anyway, just from the tokenization perspective. I probably wouldn‚Äôt be a big deal to make people use a space to disambiguate the tokenization here.

[10:27:17.0333] <jschoi>
* Or maybe it‚Äôs because of **‚Ä¶f() |> g(***2) is terrible but we would probably require separation between topic * and binary */** anyway, just from the tokenization perspective. It‚Äôs not a big ask to make people use a space to disambiguate the tokenization here.

[10:27:47.0894] <jschoi>
* Or maybe it‚Äôs because of `**`‚Ä¶`f() |> g(**2)` is terrible but we would probably require separation between topic `*` and binary `*`/`**` anyway, just from the tokenization perspective. I probably wouldn‚Äôt be a big deal to make people use a space to disambiguate the tokenization here.


2022-07-10
[10:51:22.0305] <rbuckton (PTO: 7/5 - 7/16)>
There was an interesting discussion in the last TC39/JavaScript Tools meeting about how pipeline was more statically analyzable by bundlers as a means of inlining and optimizing. I do wonder about the statements from implementers that F#-style couldn't be optimized. I definitely believe that F#+PFA could have been optimized to reduce actual function allocations. i.e., `x |> f~(?)` would have had no more overhead than `x |> f(%)`. 

