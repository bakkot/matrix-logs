2022-03-16
[09:53:50.0931] <jschoi>
At the next plenary, I am planning to present the results of the dataflow ad-hoc meeting (as well as the results of the recent function-helpers incubator meeting), with an eye towards future advancement of the pipe operator and a bind/call-this operator. Hopefully that sounds good to everyone. 

[09:54:17.0603] <jschoi>
I also plan to ask for time to bikeshed both the topic reference and the syntax of bind/call-this. 

[09:55:00.0726] <jschoi>
I‚Äôll try to have slides for these by March 18. 

[10:25:11.0635] <TabAtkins>
Yes, that matches what I was expecting. So just to be clear - we're asking the committee to help decide the topic reference this meeting, but *not* asking for Stage 2 yet, right? That'll be next meeting, assuming the bikeshedding concludes satisfactorily?

[10:50:30.0940] <jschoi>
> <@tabatkins:matrix.org> Yes, that matches what I was expecting. So just to be clear - we're asking the committee to help decide the topic reference this meeting, but *not* asking for Stage 2 yet, right? That'll be next meeting, assuming the bikeshedding concludes satisfactorily?

Yeah, just updates, no advancement. 

[10:52:42.0113] <jschoi>
There are cross-cutting concerns between the pipe operator and bind/call-this for Jordan, so I want to try to have them not stay too far apart in process. 

[10:52:57.0047] <jschoi>
Also, Tab, did you mean Stage 3 for pipe in the following plenary?

[10:53:02.0908] <TabAtkins>
yes

[10:53:07.0893] <TabAtkins>
the next stage

[10:53:14.0624] <TabAtkins>
whichever


2022-03-18
[19:28:46.0697] <jschoi>
FYI: https://github.com/tc39/agendas/pull/1133



[19:29:24.0723] <jschoi>
(Please update https://github.com/tc39/agendas/blob/main/2022/03.md#schedule-constraints if you have schedule constraints and don‚Äôt want to miss the topic-reference bikeshedding, the bind-this syntax bikeshedding, or the holistic dataflow redux. ljharb, you have some constraints, so you might want to do so.)

[19:49:26.0108] <ljharb>
thanks, will do

[19:49:44.0712] <ljharb>
I‚Äôll land your PR shortly also

[20:35:17.0239] <jschoi>
Just also made a community update: https://github.com/tc39/proposal-pipeline-operator/issues/232#issuecomment-1071995811

[10:30:18.0562] <jschoi>
I‚Äôve come around to `#` as the topic reference again, even if tuple literals go with `#[]`.

Requiring separation between topic and property access isn‚Äôt too bad: `x |> (#)[0]`‚Ä¶since dynamically accessing the property of a topic is going to be strictly less common than using the topic reference itself. And it‚Äôs not really a ‚Äúspecial case‚Äù‚Ä¶or at least it‚Äôs as much as a special case as requiring separation between `(^^)^y` or `(%%)%y`.

Our candidates right now are `#`, `^^`, `%%`, `@@`, and `##`.

[10:30:32.0315] <jschoi>
> <@ljharb:matrix.org> jschoi: `x |> #y in #` isn't all too bad, to be sure (with `#` or `##`)

 * I‚Äôve come around to `#` as the topic reference again, even if tuple literals go with `#[]`.

Requiring separation between topic and property access isn‚Äôt too bad: `x |> (#)[0]`‚Ä¶since dynamically accessing the property of a topic is going to be strictly less common than using the topic reference itself. And it‚Äôs not really a ‚Äúspecial case‚Äù‚Ä¶or at least it‚Äôs as much as a special case as requiring separation between `(^^)^ y` or `(%%)% y`.

Our candidates right now are `#`, `^^`, `%%`, `@@`, and `##`.

[10:30:41.0511] <jschoi>
 * I‚Äôve come around to `#` as the topic reference again, even if tuple literals go with `#[]`.

Requiring separation between topic and property access isn‚Äôt too bad: `x |> (#)[0]`‚Ä¶since dynamically accessing the property of a topic is going to be strictly less common than using the topic reference itself. And it‚Äôs not really a ‚Äúspecial case‚Äù‚Ä¶or at least it‚Äôs as much as a special case as requiring separation between `(^^)^y` or `(%%)%y`.

Our candidates right now are `#`, `^^`, `%%`, `@@`, and `##`.

[10:30:55.0250] <ljharb>
in that case you'd do `(#)[x]` but `#.x` and `#?.[x]`?

[10:30:58.0834] <jschoi>
Yes.

[10:31:04.0797] <ljharb>
 * in that case you'd do `(#)[x]` but `#.x` and `#?.[x]`?

[10:31:18.0549] <ljharb>
so it's only non-optional bracketed access that would need parens

[10:31:19.0832] <jschoi>
Leaving the `#[` token to be reserved for tuple literals.

[10:31:21.0251] <jschoi>
Yes.

[10:31:24.0042] <ljharb>
 * so it's only non-optional bracketed access that would need parens

[10:31:28.0519] <jschoi>
 * Leaving the `#[` token to be reserved for tuple literals.

[10:31:34.0422] <ljharb>
while in practice that's probably fine, that is an odd inconsistency

[10:32:32.0225] <ljharb>
i assume in Records, `#\n{` wouldn't be allowed

[10:32:46.0728] <jschoi>
Yes, I believe they are making `#[` and `#{` their own lexical tokens.

[10:33:31.0985] <jschoi>
https://tc39.es/proposal-record-tuple/#sec-punctuators

[10:35:40.0336] <jschoi>
Requiring parentheses to distinguish dynamic access `(#)[0]` from tuple `#[0]` is an odd inconsistency, I agree, but‚Ä¶
The benefit of having a single- rather than double-character token (which would occur very frequently, every time a topic occurs) might be great enough to outweigh the cost of that inconsistency (which would occur relatively infrequently).

[10:39:35.0272] <jschoi>
 * Requiring parentheses to distinguish dynamic access `(#)[0]` from tuple `#[0]` is an odd inconsistency, I agree, but‚Ä¶
The benefit of having a single- rather than double-character token (which would occur very frequently, every time a topic occurs) might be great enough to outweigh the cost of that inconsistency (which would occur relatively infrequently).

[10:44:39.0194] <TabAtkins>
Oh no, `#[0]` being a tuple *by default* is absolutely awful. Property access is going to remain *far* more common than tuple literals, forever.

[10:45:00.0880] <TabAtkins>
So long as tuples stick with `#[]` a single `#` for topic is verboten, imo.

[10:45:36.0890] <TabAtkins>
`(#)[0]` is, by itself, a substantially worse outcome than `##` everywhere for all other uses.

[10:45:56.0142] <TabAtkins>
(God, just *typing* it is awful - the hash and the parens are on different hands and all Shifted.)

[10:51:31.0434] <jschoi>
> <@tabatkins:matrix.org> `(#)[0]` is, by itself, a substantially worse outcome than `##` everywhere for all other uses.

Well, if we must have a two-character token (tuples are likely to go with `#[]` in the end), then I would rather have `^^` or `%%` than `##`‚Ä¶because, although topic references (and property access on them) may become more frequent than tuple literals‚Ä¶I expect tuple literals to be far more common than bitwise xor or remainder. 

[10:52:22.0679] <TabAtkins>
All of these are fine with me; my weak aesthetic preference is still for `##` but I'm happy to stick with whatever the committee decides on.

[10:53:53.0965] <jschoi>
I suppose that saying ‚Äúwe can‚Äôt fully disqualify `#` until the tuple champions commit to `#[]` syntax‚Äù is tantamount to saying ‚Äúwe cannot advance pipe operator until tuples advance too‚Äù. Which would probably be Bad.

[10:57:10.0261] <jschoi>
(It‚Äôs still a shame that we can‚Äôt have a single-character topic though. ü•≤)

[10:58:30.0840] <rbuckton>
> <@jschoi:matrix.org> (It‚Äôs still a shame that we can‚Äôt have a single-character topic though. ü•≤)

It's a shame we can't have an Identifier topic, imo. Double character isn't so bad, at least. 

[11:29:59.0050] <jschoi>
https://docs.google.com/presentation/d/1dDucwsW8qM22yWLr_NHFmAiAltQSht3AXYW00kET4GA/edit?usp=sharing

[11:33:42.0304] <TabAtkins>
Slide 2's find() looks weird - it'd take an arrow function, surely, rather than constructing a comparison out of three strings?

[11:34:07.0233] <TabAtkins>
In all the examples those three args move as a unit anyway, so having them separate doesn't seem to be valuable for what you're showing off.

[11:35:36.0833] <TabAtkins>
otherwise +1

[11:36:48.0614] <jschoi>
> <@tabatkins:matrix.org> Slide 2's find() looks weird - it'd take an arrow function, surely, rather than constructing a comparison out of three strings?

Yeah, I took this code from this Firebase video about its new modular API (https://www.youtube.com/watch?v=r5eJQ3nPc6A).
I‚Äôll revisit the example and see if I can make it more compelling. Let me know if you have any ideas.

[11:37:26.0769] <jschoi>
I do think that arguments are an important part of reading order, and the fact that nested function calls require zigzagging of arguments is an important disadvantage of nested function calls.

[11:37:31.0750] <jschoi>
 * I do think that arguments are an important part of reading order, and the fact that nested function calls require zigzagging of arguments is an important disadvantage of nested function calls.

[11:37:51.0972] <TabAtkins>
The code is reasonable otherwise, that's just a *really weird* set of arguments for a find() function.

[11:38:23.0044] <TabAtkins>
Just swapping that trio out for `x=>x.name == "fruit"` woudl work

[11:38:48.0236] <jschoi>
Yeah, good idea. I think I‚Äôll replace it with `.find(pred)`.

[11:38:58.0742] <TabAtkins>
Sure, that works.

[11:43:00.0232] <jschoi>
And done. Thanks for the suggestion.

[11:43:04.0732] <jschoi>
 * And done. Thanks for suggestion.

[11:43:06.0884] <jschoi>
 * And done. Thanks for the suggestion.

[11:52:11.0288] <TabAtkins>
Yeah, the 4-2-1-0-3-5 order really works now

[15:27:52.0024] <jschoi>
ljharb: I‚Äôm making slides for the bind/call-this operator plenary bikeshedding.

I wanted to confirm your opinion‚Äîthough you would block the pipe operator if bind/call-this did not advance, would you still block the pipe operator if Function.unThis advanced instead?

[15:27:54.0746] <jschoi>


I ask because Mark Miller had stated in the previous plenary that he is currently against any dataflow syntax proposal other than pipe operator to advance, but he is fine with functions (https://github.com/tc39/notes/blob/main/meetings/2022-01/jan-26.md#holistic-discussion-of-tc39-dataflow-proposals). So I am wondering what would happen if he stated that he would block any bind/call-this syntax‚Ä¶I would then pursue Function.unThis instead. Would this be acceptable to you as a substitute for a bind-this operator?

[15:32:14.0525] <jschoi>
https://docs.google.com/presentation/d/1-MLGCibETPX8NiIvNJ1xOxiMS-NB8GCbDGNcB5patiU/edit?usp=sharing

[15:44:32.0276] <ljharb>
> <@jschoi:matrix.org> ljharb: I‚Äôm making slides for the bind/call-this operator plenary bikeshedding.
> 
> I wanted to confirm your opinion‚Äîthough you would block the pipe operator if bind/call-this did not advance, would you still block the pipe operator if Function.unThis advanced instead?

yes, i want a syntactic mechanism that restores receiver-first ordering. Function.callBind is just sugar for `Function.call.bind`, it doesn't really add much otherwise


2022-03-19
[17:18:12.0234] <jschoi>
ljharb: Got it, thank you. I will not float Function.unThis as an alternative possibility to bind-this/call-this.
Although I will direct the bikeshedding over bind/call-this‚Äôs syntax, I will try to push `rec :> f(arg0)` as my favored syntax, since rkirsling and Justin Ridgewell are also fine with it.


[17:18:18.0783] <jschoi>
I will also try to be persuasive to MM and company that both pipe and bind-this deserve to be in the language (‚Äúbig frequency
√ó big clunkiness = worth improving with syntax‚Äù). 

[17:18:50.0756] <jschoi>
I wonder if it would be more persuasive if we dropped the binding semantics without arguments (making `rec :> f` an error)‚Ä¶That would get rid the overlap with PFA syntax and pipe operator.

[17:19:38.0205] <jschoi>
We could always add binding semantics later. And, as people have pointed out, most binding involves extraction from the same original owner object as the receiver, which requires repetition in `rec :> rec.f` anyway.

[17:20:01.0715] <jschoi>
 * We could always add binding semantics later. And, as people have pointed out, most binding involves extraction from the same original owner object as the receiver, which requires repetition in `rec :> rec.f` anyway.

[17:20:13.0962] <jschoi>
 * We could always add binding semantics later. And, as people have pointed out, most binding involves extraction from the same original owner object as the receiver, which requires clunky repetition in `rec :> rec.f` anyway.

[17:20:18.0509] <ljharb>
i am perfectly content to not have the binding form, but also it seems practically zero-cost to have, so I‚Äôm not sure why we‚Äôd drop it

[17:20:23.0511] <Justin Ridgewell>
I personally want a call syntax, and don‚Äôt care at all about the binding ability

[17:21:10.0444] <Justin Ridgewell>
** a receiver-first call syntax

[17:23:17.0853] <jschoi>
Because some other representatives (definitely TabAtkins, hence his call-this syntax idea‚Ä¶maybe yulia | sick during January plenary?) have expressed concerns about new proposals overlapping with each other ‚Äì and the desire to minimize overlap between features where possible. So this may make it more palatable in that sense.

[17:23:20.0562] <jschoi>
We did resolve in the post-plenary meeting, ‚ÄúIn general, some overlap is okay, but too much is bad; we have to decide this on a case-by-case basis.‚Äù

[17:24:01.0766] <jschoi>
In this case, it seems to be ‚Äúnot really much loss, not really much gain, maybe punt to later‚Äù. I don‚Äôt have strong opinions on this issue myself, other than whatever it takes to garner the most support within Committee‚Ä¶

[17:24:19.0726] <jschoi>
> <@ljharb:matrix.org> i am perfectly content to not have the binding form, but also it seems practically zero-cost to have, so I‚Äôm not sure why we‚Äôd drop it

 * Because some other representatives (definitely TabAtkins, hence his call-this syntax idea‚Ä¶maybe yulia | sick during January plenary?) have expressed concerns about new proposals overlapping with each other ‚Äì and the desire to minimize overlap between features where possible. So this may make it more palatable in that sense.

[17:25:21.0136] <jschoi>
Persuading MM about bind-this‚Äôs worth is going to be important, because if we cannot persuade MM to not block bind-this, then JHD will block pipe operator‚Ä¶In the situation that we have, we must have both or neither.

[17:25:44.0761] <ljharb>
sure, agreed. As long as i have one or the other syntax, in proper receiver-first order, I‚Äôm happy

[17:26:56.0664] <jschoi>
Just to clarify: You had expressed in the January post-plenary meeting that you do greatly prefer bind-this (receiver first) to call-this (function first), but even call-this would be acceptable enough for you not to block the pipe operator. That‚Äôs still true, right?

[17:27:06.0452] <jschoi>
> <@ljharb:matrix.org> sure, agreed. As long as i have one or the other syntax, in proper receiver-first order, I‚Äôm happy

 * Just to clarify: You had expressed in the January post-plenary meeting that you do greatly prefer bind-this (receiver first) to call-this (function first), but even call-this would be acceptable enough for you not to block the pipe operator. That‚Äôs still true, right?

[17:27:56.0849] <jschoi>
 * Because some other representatives (definitely TabAtkins, hence their call-this syntax idea‚Ä¶maybe yulia | sick during January plenary?) have expressed concerns about new proposals overlapping with each other ‚Äì and the desire to minimize overlap between features where possible. So this may make it more palatable in that sense.

[17:31:34.0400] <ljharb>
Yes, but i also don‚Äôt think call-this holds its syntax weight without receiver-first

[17:31:40.0050] <ljharb>
we already have .call for that

[17:32:34.0014] <ljharb>
call-this would provide the robustness i want, but without the aesthetics/ergonomics it deserves, iow

[17:32:35.0543] <jschoi>
`.call` is still clunky; I‚Äôd make a conciseness argument there, especially for such a frequently used feature of the language.

[17:32:52.0945] <ljharb>
* call-this would provide the robustness i want, but without the aesthetics/ergonomics it deserves, iow

[17:34:43.0638] <jschoi>
If I drop binding from `r :> f()`, then it no longer would make sense to call it ‚Äúbind-this‚Äù. 
Therefore I plan to start calling the proposal as a whole the ‚Äúthis‚Äù operator, and I will distinguish `r :> f()` versus `f.@(r)` with ‚Äúreceiver first‚Äù versus ‚Äúfunction first‚Äù.

[17:36:03.0378] <jschoi>
 * If we drop binding from `r :> f()`, then it no longer would make sense to call it ‚Äúbind-this‚Äù.
Therefore I plan to start calling the proposal as a whole the ‚Äúthis‚Äù operator, and we can continue to distinguish `r :> f()` versus `f.@(r)` with ‚Äúreceiver first‚Äù versus ‚Äúfunction first‚Äù.

[17:52:40.0950] <jschoi>
Justin Ridgewell: You‚Äôve expressed before the desire for object-oriented programmers to use less prototype methods and more individually exported functions. This is a big reason why you have supported adding the pipe operator. It‚Äôs part of a bigger shift in the ecosystem, e.g., with Firebase‚Äôs new JS API.

However, if both the pipe operator and the ‚Äúthis‚Äù operator get added to the language‚Ä¶do you anticipate yourself or other programmers individually exporting `this`-based functions for use with the ‚Äúthis‚Äù operator ‚Äì rather than non-`this`-based functions for use with the pipe operator?


[17:52:45.0600] <jschoi>
I ask this because I anticipate viral ecosystem schism to continue being a (weak?) concern from Waldemar and maybe Tab and others. 

[17:53:10.0156] <jschoi>
We concluded that this concern was relatively weak in the post-plenary meeting, but it‚Äôs probably going to get brought up again‚Ä¶

[17:53:13.0889] <jschoi>
 * We affirmed that this concern was relatively weak in the post-plenary meeting, but it‚Äôs probably going to get brought up again‚Ä¶

[17:53:21.0922] <jschoi>
 * We concluded that this concern was relatively weak in the post-plenary meeting, but it‚Äôs probably going to get brought up again‚Ä¶

[17:54:29.0786] <jschoi>
 * If we drop binding from `r :> f()`, then it no longer would make sense to call it ‚Äúbind-this‚Äù.
Therefore I plan to start calling the proposal as a whole the ‚Äúcall-this‚Äù operator, and we can continue to distinguish `r :> f()` versus `f.@(r)` with ‚Äúreceiver first‚Äù versus ‚Äúfunction first‚Äù.

[17:54:42.0611] <jschoi>
 * If we drop binding from `r :> f()`, then it no longer would make sense to call it ‚Äúbind-this‚Äù.
Therefore I plan to start calling the proposal as a whole the ‚Äúthis‚Äù operator, and we can continue to distinguish `r :> f()` versus `f.@(r)` with ‚Äúreceiver first‚Äù versus ‚Äúfunction first‚Äù.

[17:56:07.0155] <jschoi>
 * If we drop binding from `r :> f()`, then it no longer would make sense to call it ‚Äúbind-this‚Äù.
Therefore I plan to start calling the proposal as a whole the ‚Äúthis‚Äù operator (‚Äúcall-on operator‚Äù?), and we can continue to distinguish `r :> f()` versus `f.@(r)` with ‚Äúreceiver first‚Äù versus ‚Äúfunction first‚Äù.

[17:57:00.0689] <jschoi>
 * If we drop binding from `r :> f()`, then it no longer would make sense to call it ‚Äúbind-this‚Äù.
Therefore I plan to start calling the proposal as a whole the ‚Äúthis‚Äù operator (‚Äúcall-this‚Äù?), and we can continue to distinguish `r :> f()` versus `f.@(r)` with ‚Äúreceiver first‚Äù versus ‚Äúfunction first‚Äù.

[18:16:34.0361] <jschoi>
TabAtkins: If we drop function binding from `rec :> fn()`, then the overlap with PFA syntax disappears. Is it okay if I call this new proposal ‚Äúreceiver-first call-this‚Äù, and change your idea to ‚Äúfunction-first call-this‚Äù? I‚Äôm asking since you have first claim to the ‚Äúcall-first‚Äù name.

[18:17:10.0644] <TabAtkins>
Yeah that's fine, I have no attachment to the proposal except as a way to thread the syntax needle

