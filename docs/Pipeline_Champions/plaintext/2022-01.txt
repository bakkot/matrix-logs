2022-01-04
[09:57:40.0857] <TabAtkins>
jschoi: Oh man, this diagram is great.

[10:00:53.0632] <TabAtkins>
Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?

[10:04:02.0427] <jschoi>
> <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?

According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. 

[10:04:12.0521] <jschoi>
* > <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?

The trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. 

[10:04:28.0087] <jschoi>
* > <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?

According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. 

[10:04:37.0857] <TabAtkins>
I'm talking at a higher level of parsing, before evaluation occurs.

[10:04:43.0781] <jschoi>
Oh wait I see. 

[10:04:50.0854] <jschoi>
Yeah, I see. 

[10:05:07.0756] <TabAtkins>
The ?: trinary really poisons single-colon usage.

[10:10:38.0200] <Nicolò>
TS and Flow are a nightmare to parse because of their usage of : for return type annotations (especially of arrow functions)

[10:19:16.0455] <TabAtkins>
Hrmmm, Extension's `obj::foo = 1` syntax for setters doesn't generalize. `obj::foo::bar = 1` will call `foo` as a getter, then `bar` as a setter, meaning you still can't use it for functional data structures, which need to unfold the earlier parts of the assignment chain into get/set pairs.

[10:23:09.0446] <jschoi>
Regarding `x?y::z:f()`, I figure that it would be a SyntaxError to include an unparenthesized trinary extensions expression inside a trinary conditional expression.

Regarding `obj::foo::bar = 1`, yeah, that is a problem, and I don’t know how it could actually work.

CC: HE Shi-Jun 



[10:24:09.0896] <jschoi>
(By the way, Nicolò: if babel/babel#13973 looks good to you, I’m going to start work on `@[]`/`@{}` syntax for tuples/records soon based on that pull request.)

[10:54:32.0182] <TabAtkins>
Okay yeah, looking over it freshly and in depth now, I think Extension's only real wins are (a) reusing methods that happen to be generic enough to be useful on arbitrary objects (relatively rare outside of Array), and (b) adding getters/setters to objects without having to screw with the prototype.

[10:55:26.0343] <TabAtkins>
The NS polymorphism letting you define a `function foo(arg0, arg1)` and then call it as `arg0::NS:meth(arg1)` isn't any better than pipe's `arg0 |> NS.meth(##, arg1)`, and pipe has less magic going on in that case.

[10:56:26.0184] <TabAtkins>
The "add a *method* to an existing class without screwing with the prototype" use-case is handled just as well by pipe, as above.

[11:02:55.0858] <TabAtkins>
And yeah, just confirmed for myself that existing getters/setters don't handle functional data structures well either; `x.foo.bar.baz` just calls the "foo" and "bar" getters then the "baz" setter and nothing else

[12:04:06.0570] <jschoi>
I imagine that whatever “property descriptor” objects that extensions use would actually have to be a new kind of recursive “reference record” object, but Hax might have something else to say about this.

[12:04:27.0052] <jschoi>
I wonder if it would be worth carving out January plenary time to present this diagram and discuss all of these proposals at once…

[12:26:11.0731] <TabAtkins>
I think it would be, yeah

[12:26:20.0427] <TabAtkins>
Wrote up my thoughts after digesting this: https://gist.github.com/tabatkins/60d831d3e304e3e7316d473f5c1f269b

[12:28:06.0088] <TabAtkins>
IIRC, ljharb's main desired use-case for bind-this was method extraction - I forget, was it for reliable use on objects of the type it was extracted from (just protecting against prototype mutation) or for calling on different types of objects?

[12:33:22.0742] <ljharb>
it's for whatever it takes for me to robustly invoke a function while providing the receiver

method extraction + normal invocation achieves this. so too would syntax to call with a receiver.

[12:33:38.0075] <jschoi>
My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)

[12:33:57.0267] <ljharb>
 * it's for whatever it takes for me to robustly invoke a function while providing the receiver

method extraction + normal invocation achieves this. so too would syntax to call with a receiver.

[12:34:22.0879] <jschoi>
* My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)

[12:35:30.0048] <jschoi>
The sheer frequency of already-extant .call occurrences alone suggests that .call may be worth optimizing for better word order and conciseness. The pipe operator solves .call’s word order but not .call’s conciseness.

[12:35:49.0828] <jschoi>
* My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined; they exceed even console.log occurrences. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)

[12:35:58.0788] <jschoi>
* My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined; .call occurrences exceed even console.log occurrences. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (The second use case actually occurs quite frequently in the dataset, from what I recall, but I’d need to recheck.)

[12:37:22.0369] <jschoi>
* The sheer frequency of already-extant .call occurrences suggests that .call may be worth optimizing for better word order and conciseness. The pipe operator solves .call’s word order but not .call’s conciseness.

[12:37:37.0523] <jschoi>
* The sheer frequency of already-extant .call occurrences alone suggests that .call may be worth optimizing for better word order and conciseness. The pipe operator solves .call’s word order but not .call’s conciseness.

[12:38:53.0343] <jschoi>
Some more details about found extant use cases for .call can be found starting at https://github.com/tc39/proposal-bind-this/issues/12#issuecomment-939400362.

[12:39:47.0390] <jschoi>
…which resulted in the results listed in https://github.com/tc39/proposal-bind-this/blob/main/README.md#bind-and-call-are-very-common.

[12:40:55.0098] <jschoi>
To sum up, I think that the second and third use cases that you list for bind-this in the Gist are (perhaps surprisingly) not rare; they are in fact very frequent in existing code, and therefore they may be worth optimizing for. So I disagree with that part of the Gist, although this reasoning is obviously motivated by the fact that I am bind-this’s champion, haha.

[12:41:01.0434] <jschoi>
I think the rest of the Gist makes sense; great job in general.

[12:41:18.0286] <jschoi>
* To sum up, I think that the second and third use cases that you list for bind-this in the Gist are (perhaps surprisingly) not rare; they are very frequent in existing code. So I disagree with that part of the Gist, although this reasoning is obviously motivated by the fact that I am bind-this’s champion, haha.

[12:41:24.0788] <jschoi>
* I think the rest of the Gist makes sense; great job in general.

[12:41:40.0766] <jschoi>
* To sum up, I think that the second and third use cases that you list for bind-this in the Gist are (perhaps surprisingly) not rare; they are in fact very frequent in existing code, and therefore they may be worth optimizing for. So I disagree with that part of the Gist, although this reasoning is obviously motivated by the fact that I am bind-this’s champion, haha.

[12:42:07.0006] <jschoi>
* My argument for bind-this is that .bind and .call (especially .call) are immensely common in general; .call occurrences in the top-1000-downloaded NPM packages are more frequent than .slice, .set, and .push occurrences combined; .call occurrences exceed even console.log occurrences. I think there are at least four or five different use cases in which .call occurs in, although I suppose they could be lumped together into your second and third use cases. (You say that your second use case is rare, but it actually occurs quite frequently in the NPM dataset, from what I recall, but I’d need to recheck.)

[12:47:31.0699] <TabAtkins>
I need to reread your .call() data; it's still the case that I have approximately never seen those methods used in real code, so the extremely heavy usage still blows me away.

[12:48:52.0147] <jschoi>
That would be great. The procedure to print all dataset matches in a terminal is hidden in a <details> element, at the bottom of that section in README.md.

[12:49:12.0893] <jschoi>
* That would be great. The procedure to print all dataset matches in a terminal is hidden in a <details> element, at the bottom of that section in README.md.

[12:51:54.0014] <TabAtkins>
Okay, yeah, the "reuse an array method" cases being very common are unsurprising, but generally iterator helpers and/or just using `[...x]` are just as good. The Object.prototype stuff, similarly - those should all go thru the same transform as `Object.hasOwn()`, honestly.

[12:53:34.0109] <TabAtkins>
Any anything around transpiled code isn't, imo, an important use-case. Transpilers don't need nice syntax for what they're doing, they're outputting write-only code in the first place.

[12:54:25.0605] <jschoi>
Yes, agreed on transpilation: we did exclude any transpilation artifacts that we found (they’re excluded in the CLI command and are also listed in a table with explanations in the README.md <details> element.)

[12:54:35.0166] <jschoi>
* Yes, agreed on transpilation: we did exclude any transpilation artifacts that we found (they’re excluded in the CLI command and are also listed in a table with explanations in the README.md <details> element.)

[12:55:32.0526] <jschoi>
* Yes, definitely agreed on not caring about optimizing for transpilation: we did exclude any transpilation artifacts that we found (they’re excluded in the CLI command and are also listed in a table with explanations in the README.md <details> element.)

[12:55:42.0290] <jschoi>
* Yes, definitely agreed on not caring about optimizing for transpilation: we did exclude any transpilation artifacts that we found (they’re excluded by the CLI command and are also listed in a table with explanations in the README.md <details> element.)


2022-01-06
[10:27:02.0385] <TabAtkins>
Okay, just reminding myself: an "uncurry-this" operator (or unforgeable function) would satisfy ljharb's usecase, right? You'd be able to reliably yank methods off of classes and then later call them with specific objects, just as a normal function taking the object as its first arg. If we can limit it to that one usage, the overlap with pipe disappears, and it instead works nicely _with_ pipe.

[10:27:19.0122] <TabAtkins>
 * Okay, just reminding myself: an "uncurry-this" operator (or unforgeable function) would satisfy ljharb's usecase, right? You'd be able to reliably yank methods off of classes and then later call them with specific objects, just as a normal function taking the object as its first arg. If we can limit it to that one usage, the overlap with pipe disappears, and it instead works nicely _with_ pipe.

[10:28:36.0423] <ljharb>
something that lets me, eg, `const { slice } = Array.prototype; slice::(receiver, ...args)` or `const slice = ::Array.prototype.slice; slice(receiver, ...args)` would work

[10:28:48.0601] <TabAtkins>
Yes, exactly.

[10:28:54.0806] <ljharb>
and yes i 100% agree that it works very well in concert with pipe

[10:28:59.0937] <ljharb>
the call form in particular

[10:29:16.0006] <ljharb>
and both would also work well in concert with `getIntrinsic`

[10:51:52.0694] <TabAtkins>
All right, I've added a nota bene to my summary essay covering this: https://gist.github.com/tabatkins/60d831d3e304e3e7316d473f5c1f269b#nota-bene-reliable-method-calling

[10:52:10.0045] <TabAtkins>
I agree that the call-operator version works better, for several reasons I outline here.

[11:06:13.0674] <jschoi>
If I may try summarizing: between `arrayLike |> slice::(##, 1)` and `arrayLike |> ##::slice(1)`, you prefer the former, Tab, right?

[11:08:42.0988] <jschoi>
(The former uses the newly proposed “call-on” operator while the latter uses the “bind-this” operator.)

[11:15:21.0281] <TabAtkins>
yes, strongly prefer the former

[11:16:01.0111] <TabAtkins>
It solves the problem just as elegantly, but without the possibility of people writing libraries intentionally aimed at that calling style

[11:16:12.0214] <Ashley Claymore>
I imagine `arrayLike |> ##::slice(1)` appearing on it's own (not as part of a longer pipe) would be uncommon as one could write `arrayLike::slice(1)`

[11:16:23.0791] <TabAtkins>
right, exactly

[11:16:25.0262] <Ashley Claymore>
> <@jschoi:matrix.org> If I may try summarizing: between `arrayLike |> slice::(##, 1)` and `arrayLike |> ##::slice(1)`, you prefer the former, Tab, right?

 * I imagine `arrayLike |> ##::slice(1)` appearing on it's own (not as part of a longer pipe) would be uncommon as one could write `arrayLike::slice(1)`

[11:17:18.0683] <jschoi>
Yes, I did `arrayLike |> ##::slice(1)` only to show parallelism, but it would actually be `arrayLike::slice(1)`.

[11:17:19.0068] <TabAtkins>
also, I think it's better ad-hoc - `arrayLike::Array.prototype.slice(1)` requires us to be pretty careful with precedence to get right, but `Array.prototyype.slice::(arrayLike, 1)` is easy

[11:18:12.0588] <TabAtkins>
i think it's pretty easy to explain, too, since it's literally just "`.call()`, but an operator"

[11:18:29.0633] <jschoi>
I think this is understandable. I can try proposing a rival-rival call-on operator at the next meeting along with Function.pipe.

[11:18:51.0730] <TabAtkins>
Let's get in on that together, and we can rope in Jordan too. ^_^

[11:19:18.0382] <TabAtkins>
i'm thinking over how I might present your diagram for an overview/discussion

[11:22:42.0010] <TabAtkins>
invites sent, lmk if anyone else wants in

[11:22:55.0942] <Ashley Claymore>
> <@tabatkins:matrix.org> i think it's pretty easy to explain, too, since it's literally just "`.call()`, but an operator"

that seems like a potential weakness? Seems that makes the benefit mostly about protection against `Function.prototype.call` being patched? Which can be done with `Array.prototype.slice |> ReflectApply(##, arrayLike, 1)`

[11:23:31.0886] <TabAtkins>
Well it's ".call(), but more convenient". 

[11:23:38.0601] <jschoi>
I would argue the primary benefit is that `.call` is very common and we are shortening a very common function.

[11:24:25.0895] <jschoi>
(I’d also be particularly interested to know how much Richard Gibson feels call-on would overlap with other dataflow proposals.)

[11:25:33.0444] <Ashley Claymore>
`call` is already quite short and doesn't involve holding shift to type?

[11:26:24.0468] <jschoi>
I guess I do need to work out how things would change with having to use pipe with call-on to get the word-order benefit…

[11:26:37.0719] <TabAtkins>
not if you're worried about patching, which is a big part of this in the first place

[11:27:02.0193] <TabAtkins>
`meth |> ReflectApply(##, obj, args)` is a lot longer ^_^

[11:27:22.0061] <jschoi>
And also obscures the meaning of the code (important, since this use case actually very commonly occurs).

[11:27:47.0184] <jschoi>
* And also obscures the meaning of the code (which very commonly occurs).

[11:28:08.0170] <jschoi>
* And also obscures the meaning of the code (important, since this use case actually very commonly occurs).

[11:28:58.0934] <jschoi>
It would probably be `obj |> ReflectApply(meth, ##, args)`, though.

[11:29:24.0399] <jschoi>
Versus `obj |> meth::(##, args)`.

[11:29:34.0876] <TabAtkins>
ah yeah, sure

[11:31:27.0074] <TabAtkins>
I will admit tho, that a major motivation for this particular shape is to solve this use-case *without* overlapping over dataflow proposals. Between Pipe and PFA, the other bind-this operations can be done reasonably well already; this covers the last significant unhandled use-case (afaict) without stomping on either of those.

[11:34:50.0317] <jschoi>
My argument for bind-this had been that .call’s frequency (as well as, to a lesser extent, .bind’s) is sufficiently high to justify optimizing its word order and brevity with syntax, even in spite of its overlap with the pipe operator, similarly to how Function.pipe is useful in spite of the pipe operator. But if we can solve word order and brevity by combining with pipe instead of overlapping with it, so much the better. The syntax of call-on is simpler, too.

[11:35:28.0327] <jschoi>
* My argument for bind-this had been that .call’s frequency (as well as, to a lesser extent, .bind’s) is sufficiently high to justify optimizing its word order and brevity with syntax, even in spite of its overlap with the pipe operator, similarly to how Function.pipe is useful in spite of the pipe operator. But if we can solve word order and brevity by combining with pipe instead of overlapping with it, so much the better. The syntax of call-on is simpler, too. And, although call-on does not improve using .bind, .bind’s frequency is not nearly as high as .call’s.

[11:35:34.0797] <jschoi>
* My argument for bind-this had been that .call’s frequency (as well as, to a lesser extent, .bind’s) is sufficiently high to justify optimizing its word order and brevity with syntax, even in spite of its overlap with the pipe operator, similarly to how Function.pipe is useful in spite of the pipe operator. But if we can solve word order and brevity by combining with pipe instead of overlapping with it, so much the better. The syntax of call-on is simpler, too. And, although call-on does not improve using .bind, .bind’s frequency is not nearly as high as .call’s, so it is less important.

[11:36:21.0060] <TabAtkins>
And when .bind is just used to hard-bind a method to the object it's already sitting on, PFA covers that well on its own. The remaining "hard-bind a method to an unrelated object" is, afaict, a lot less common.

[11:36:22.0930] <jschoi>
* My argument for bind-this had been that .call’s frequency (as well as, to a lesser extent, .bind’s) is sufficiently high to justify optimizing its word order and brevity with syntax, even in spite of its overlap with the pipe operator, similarly to how Function.pipe is useful in spite of the pipe operator. But if we can optimize .call’s word order and brevity by combining with the pipe instead of overlapping with it, so much the better. The syntax of call-on is simpler, too. And, although call-on does not improve using .bind, .bind’s frequency is not nearly as high as .call’s, so it is less important.

[11:36:34.0234] <Ashley Claymore>
Another potential solution to avoiding `Function.prototype.call` tampering. Is a build step.
A tool that looks for `someMethod.$call(obj, ...args)` and transforms it to `reflectApply(someMethod, obj, args)`.
It could install `Function.prototype.$call` during development to avoid needing to transform during fast dev builds. And only transform for production.

[11:36:44.0288] <ljharb>
TabAtkins:  i definitely would prefer something that's ordered like receiver, function, arguments tho

[11:37:00.0550] <ljharb>
build steps don't solve the problem for packages, and it's very dangerous to transpile code you didn't author, so i wouldn't want us to recommend that.

[11:37:07.0681] <ljharb>
 * TabAtkins:  i definitely would prefer something that's ordered like receiver, function, arguments tho

[11:37:17.0161] <ljharb>
 * build steps don't solve the problem for packages, and it's very dangerous to transpile code you didn't author

[11:37:22.0056] <ljharb>
 * build steps don't solve the problem for packages, and it's very dangerous to transpile code you didn't author, so i wouldn't want us to recommend that.

[11:37:26.0437] <jschoi>
The receiver–function–arguments word order is solved (albeit slightly more verbosely) with pipe operator + call-on.

[11:37:54.0142] <TabAtkins>
I understand why that order is appealing, but note that using that order makes it easy to publish modules that are *intended* to be called with this syntax, promoting ecosystem forking that we don't want.

[11:38:01.0747] <ljharb>
how? `fn |> ^::(receiver, ...args)` has the same ordering issue as `fn::(receiver, ...args)`

[11:38:06.0937] <jschoi>
`receiver |> fn::(#, ...args)` has the desired word order. @ljharb 

[11:38:10.0334] <TabAtkins>
Thus the overlap with pipe that makes some committee members uncomfortable, yeah

[11:38:20.0073] <ljharb>
any function that looks at `this` is intended to be called with this syntax - which includes most builtin methods. no explicit intention beyond that is or should be required.

[11:38:24.0624] <ljharb>
 * any function that looks at `this` is intended to be called with this syntax - which includes most builtin methods

[11:38:34.0875] <ljharb>
 * any function that looks at `this` is intended to be called with this syntax - which includes most builtin methods. no explicit intention is or should be equired.

[11:38:36.0210] <ljharb>
 * any function that looks at `this` is intended to be called with this syntax - which includes most builtin methods. no explicit intention is or should be required.

[11:38:38.0380] <jschoi>
* `receiver |> fn::(#, ...args)`.

[11:38:39.0334] <ljharb>
 * any function that looks at `this` is intended to be called with this syntax - which includes most builtin methods. no explicit intention beyond that is or should be required.

[11:38:43.0843] <TabAtkins>
Right, publishing a module where *free-floating functions* are authored to use `this` is, imo, bad.

[11:39:18.0030] <ljharb>
i'm not sure what you mean, that's already a thing people can (and sometimes do) do

[11:39:18.0500] <jschoi>
* `receiver |> fn::(#, ...args)` has the desired word order.

[11:39:37.0933] <TabAtkins>
Who does that today? You'd have to use `.call()` to invoke the functions.

[11:39:40.0676] <ljharb>
it's not our place to discourage `export default function (...args) { this }`, that's a normal part of the language

[11:39:43.0894] <ljharb>
yes, that's right, you would

[11:39:50.0087] <jschoi>
* `receiver |> fn::(#, ...args)` has the desired word order. @ljharb 

[11:39:59.0438] <ljharb>
and "use `.call()`" is the thing that needs to be made easier/more robust

[11:40:02.0326] <ljharb>
 * and "use `.call()`" is the thing that needs to be made easier/more robust

[11:40:02.0403] <TabAtkins>
Okay, well that's werid and people can be weird if they want. But that's not something normal libraries do.

