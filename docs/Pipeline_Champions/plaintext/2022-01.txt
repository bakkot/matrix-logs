2022-01-04
[09:57:40.0857] <TabAtkins>
jschoi: Oh man, this diagram is great.

[10:00:53.0632] <TabAtkins>
Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?

[10:04:02.0427] <jschoi>
> <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?

According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. 

[10:04:12.0521] <jschoi>
* > <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?

The trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. 

[10:04:28.0087] <jschoi>
* > <@tabatkins:matrix.org> Hmm, I wonder if Extensions has a way to handle the syntax ambiguity of its trinary form - is `x?y::z:f()` equal to `x ? (y::z:f())` or `x ? (y::z) : f()`? Does it depend on whether there's a trailing `: elseVal` afterwards?

According to Hax’s slides, the trinary form is type-polymorphic depending on whether the middle operand evaluates into a constructor or not. 

[10:04:37.0857] <TabAtkins>
I'm talking at a higher level of parsing, before evaluation occurs.

[10:04:43.0781] <jschoi>
Oh wait I see. 

[10:04:50.0854] <jschoi>
Yeah, I see. 

[10:05:07.0756] <TabAtkins>
The ?: trinary really poisons single-colon usage.

[10:10:38.0200] <Nicolò>
TS and Flow are a nightmare to parse because of their usage of : for return type annotations (especially of arrow functions)

[10:19:16.0455] <TabAtkins>
Hrmmm, Extension's `obj::foo = 1` syntax for setters doesn't generalize. `obj::foo::bar = 1` will call `foo` as a getter, then `bar` as a setter, meaning you still can't use it for functional data structures, which need to unfold the earlier parts of the assignment chain into get/set pairs.

[10:23:09.0446] <jschoi>
Regarding `x?y::z:f()`, I figure that it would be a SyntaxError to include an unparenthesized trinary extensions expression inside a trinary conditional expression.

Regarding `obj::foo::bar = 1`, yeah, that is a problem, and I don’t know how it could actually work.

CC: HE Shi-Jun 



[10:24:09.0896] <jschoi>
(By the way, Nicolò: if babel/babel#13973 looks good to you, I’m going to start work on `@[]`/`@{}` syntax for tuples/records soon based on that pull request.)

[10:54:32.0182] <TabAtkins>
Okay yeah, looking over it freshly and in depth now, I think Extension's only real wins are (a) reusing methods that happen to be generic enough to be useful on arbitrary objects (relatively rare outside of Array), and (b) adding getters/setters to objects without having to screw with the prototype.

[10:55:26.0343] <TabAtkins>
The NS polymorphism letting you define a `function foo(arg0, arg1)` and then call it as `arg0::NS:meth(arg1)` isn't any better than pipe's `arg0 |> NS.meth(##, arg1)`, and pipe has less magic going on in that case.

[10:56:26.0184] <TabAtkins>
The "add a *method* to an existing class without screwing with the prototype" use-case is handled just as well by pipe, as above.

[11:02:55.0858] <TabAtkins>
And yeah, just confirmed for myself that existing getters/setters don't handle functional data structures well either; `x.foo.bar.baz` just calls the "foo" and "bar" getters then the "baz" setter and nothing else

[12:04:06.0570] <jschoi>
I imagine that whatever “property descriptor” objects that extensions use would actually have to be a new kind of recursive “reference record” object, but Hax might have something else to say about this.

[12:04:27.0052] <jschoi>
I wonder if it would be worth carving out January plenary time to present this diagram and discuss all of these proposals at once…

[12:26:11.0731] <TabAtkins>
I think it would be, yeah

[12:26:20.0427] <TabAtkins>
Wrote up my thoughts after digesting this: https://gist.github.com/tabatkins/60d831d3e304e3e7316d473f5c1f269b

[12:28:06.0088] <TabAtkins>
IIRC, ljharb's main desired use-case for bind-this was method extraction - I forget, was it for reliable use on objects of the type it was extracted from (just protecting against prototype mutation) or for calling on different types of objects?

