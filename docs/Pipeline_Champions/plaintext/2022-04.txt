2022-04-01
[07:56:43.0339] <jschoi>
There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

[07:57:23.0986] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come. I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers?)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

[07:58:55.0287] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

[08:00:45.0803] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

…or maybe ban any DecoratorList Expression immediately following `|>`.

[08:01:30.0622] <jschoi>
So the plan is to use a cover grammar ShortCircuitExpression `|>` CoverPipeBodyOrDecoratedExpression. PipeBody is the usual. DecoratedExpression is something like DecoratorList Expression. It’s an early error if DecoratedExpression covers CoverPipeBodyOrDecoratedExpression.

[08:02:12.0932] <nicolo-ribaudo>
I have heard about obejct property decorators, but never about decorators for the whole object. It can just be a function call?

[08:02:31.0626] <jschoi>
Not sure. Take a look at https://github.com/tc39/proposal-decorators/blob/master/EXTENSIONS.md#object-literal-and-property-decorators-and-annotations.

[08:04:00.0411] <pokute>
It feels a bit that pipeline is taking into account other possible proposals in a way that many other proposals don't.

[08:04:07.0203] <pokute>
 * It feels a bit that pipeline is taking into account other possible proposals in a way that many other proposals don't.

[08:04:51.0389] <jschoi>
Since (if?) we’re going with `@` as the topic reference, I think it’s reasonable to try to future proof against any potential future conflict with future decorator extensions. 

[08:05:03.0561] <jschoi>
It’s only decorators really that pipe has to be careful about.

