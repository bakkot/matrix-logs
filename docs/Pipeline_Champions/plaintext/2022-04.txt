2022-04-01
[07:56:43.0339] <jschoi>
There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

[07:57:23.0986] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come. I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers?)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

[07:58:55.0287] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

[08:00:45.0803] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

…or maybe ban any DecoratorList Expression immediately following `|>`.

[08:01:30.0622] <jschoi>
So the plan is to use a cover grammar ShortCircuitExpression `|>` CoverPipeBodyOrDecoratedExpression. PipeBody is the usual. DecoratedExpression is something like DecoratorList Expression. It’s an early error if DecoratedExpression covers CoverPipeBodyOrDecoratedExpression.

[08:02:12.0932] <nicolo-ribaudo>
I have heard about obejct property decorators, but never about decorators for the whole object. It can just be a function call?

[08:02:31.0626] <jschoi>
Not sure. Take a look at https://github.com/tc39/proposal-decorators/blob/master/EXTENSIONS.md#object-literal-and-property-decorators-and-annotations.

[08:04:00.0411] <pokute>
It feels a bit that pipeline is taking into account other possible proposals in a way that many other proposals don't.

[08:04:07.0203] <pokute>
 * It feels a bit that pipeline is taking into account other possible proposals in a way that many other proposals don't.

[08:04:51.0389] <jschoi>
Since (if?) we’re going with `@` as the topic reference, I think it’s reasonable to try to future proof against any potential future conflict with future decorator extensions. 

[08:05:03.0561] <jschoi>
It’s only decorators really that pipe has to be careful about.

[08:05:18.0924] <jschoi>
* The only proposal that that pipe has to be careful about is decorators.

[08:05:39.0221] <pokute>
It though that we have to be careful about infix operators too.

[08:05:51.0800] <jschoi>
(…Well, I guess there’s the dataflow stuff in general. Like how pipe will not advance unless bind-this advances. But I’m talking about syntax only.)

[08:06:27.0452] <jschoi>
> <@pokute:matrix.org> It though that we have to be careful about infix operators too.

I don’t think we have to be careful about future non-identifier infix operators. It’s future infix operators that have to be careful of pipe (or specifically of the `@` topic). And those future proposals will be able to use some simple lookahead rules when they get proposed (https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912), and it should be fine.

[08:07:06.0821] <jschoi>
* > <@pokute:matrix.org> It though that we have to be careful about infix operators too.

I don’t think we have to be careful about future non-identifier infix operators. It’s future infix operators that have to be careful of pipe (or specifically of the `@` topic). And those future proposals will be able to use some simple lookahead rules when they get proposed, and it should be fine.

[08:07:28.0152] <jschoi>
* > <@pokute:matrix.org> It though that we have to be careful about infix operators too.

I don’t think we have to be careful about future non-identifier infix operators. It’s future infix operators that have to be careful of pipe (or specifically of the `@` topic). And those future proposals will be able to use some simple lookahead rules when they get proposed (https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912), and it should be fine.

[08:07:36.0262] <jschoi>
* (…Well, I guess there’s the dataflow stuff in general. Like how pipe will not advance unless bind-this advances. But I’m talking about syntax only.)

[08:08:20.0049] <nicolo-ribaudo>
I wish we could just ban ASI after pipes

[08:08:34.0200] <nicolo-ribaudo>
If that would be enough

[08:09:09.0392] <jschoi>
I’ll think about if we can do that instead.

[08:10:04.0608] <jschoi>
But the problem isn’t that ASI is happening. It’s that developers might expect ASI to happen when it wouldn’t.


