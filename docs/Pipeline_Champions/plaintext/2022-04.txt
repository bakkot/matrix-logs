2022-04-01
[07:56:43.0339] <jschoi>
There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
â€¦also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
â€¦only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I donâ€™t think thereâ€™s anything else on the expression level that might get decoratedâ€¦Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

[07:57:23.0986] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
â€¦also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come. I donâ€™t think thereâ€™s anything else on the expression level that might get decoratedâ€¦Maybe identifiers?)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
â€¦only has one reasonable interpretation (as `x |> @(d); { 0 }`).

[07:58:55.0287] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
â€¦also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
â€¦only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I donâ€™t think thereâ€™s anything else on the expression level that might get decoratedâ€¦Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

[08:00:45.0803] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
â€¦also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
â€¦only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I donâ€™t think thereâ€™s anything else on the expression level that might get decoratedâ€¦Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

â€¦or maybe ban any DecoratorList Expression immediately following `|>`.

[08:01:30.0622] <jschoi>
So the plan is to use a cover grammar ShortCircuitExpression `|>` CoverPipeBodyOrDecoratedExpression. PipeBody is the usual. DecoratedExpression is something like DecoratorList Expression. Itâ€™s an early error if DecoratedExpression covers CoverPipeBodyOrDecoratedExpression.

[08:02:12.0932] <nicolo-ribaudo>
I have heard about obejct property decorators, but never about decorators for the whole object. It can just be a function call?

[08:02:31.0626] <jschoi>
Not sure. Take a look at https://github.com/tc39/proposal-decorators/blob/master/EXTENSIONS.md#object-literal-and-property-decorators-and-annotations.

[08:04:00.0411] <pokute>
It feels a bit that pipeline is taking into account other possible proposals in a way that many other proposals don't.

[08:04:07.0203] <pokute>
 * It feels a bit that pipeline is taking into account other possible proposals in a way that many other proposals don't.

[08:04:51.0389] <jschoi>
Since (if?) weâ€™re going with `@` as the topic reference, I think itâ€™s reasonable to try to future proof against any potential future conflict with future decorator extensions. 

[08:05:03.0561] <jschoi>
Itâ€™s only decorators really that pipe has to be careful about.

[08:05:18.0924] <jschoi>
* The only proposal that that pipe has to be careful about is decorators.

[08:05:39.0221] <pokute>
It though that we have to be careful about infix operators too.

[08:05:51.0800] <jschoi>
(â€¦Well, I guess thereâ€™s the dataflow stuff in general. Like how pipe will not advance unless bind-this advances. But Iâ€™m talking about syntax only.)

[08:06:27.0452] <jschoi>
> <@pokute:matrix.org> It though that we have to be careful about infix operators too.

I donâ€™t think we have to be careful about future non-identifier infix operators. Itâ€™s future infix operators that have to be careful of pipe (or specifically of the `@` topic). And those future proposals will be able to use some simple lookahead rules when they get proposed (https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912), and it should be fine.

[08:07:06.0821] <jschoi>
* > <@pokute:matrix.org> It though that we have to be careful about infix operators too.

I donâ€™t think we have to be careful about future non-identifier infix operators. Itâ€™s future infix operators that have to be careful of pipe (or specifically of the `@` topic). And those future proposals will be able to use some simple lookahead rules when they get proposed, and it should be fine.

[08:07:28.0152] <jschoi>
* > <@pokute:matrix.org> It though that we have to be careful about infix operators too.

I donâ€™t think we have to be careful about future non-identifier infix operators. Itâ€™s future infix operators that have to be careful of pipe (or specifically of the `@` topic). And those future proposals will be able to use some simple lookahead rules when they get proposed (https://github.com/tc39/proposal-pipeline-operator/issues/91#issuecomment-1085006912), and it should be fine.

[08:07:36.0262] <jschoi>
* (â€¦Well, I guess thereâ€™s the dataflow stuff in general. Like how pipe will not advance unless bind-this advances. But Iâ€™m talking about syntax only.)

[08:08:20.0049] <nicolo-ribaudo>
I wish we could just ban ASI after pipes

[08:08:34.0200] <nicolo-ribaudo>
If that would be enough

[08:09:09.0392] <jschoi>
Iâ€™ll think about if we can do that instead.

[08:10:04.0608] <jschoi>
But the problem isnâ€™t that ASI is happening. Itâ€™s that developers might expect ASI to happen when it wouldnâ€™t.


[08:10:59.0271] <jschoi>
```js
x |> @(d)
class C {}
```
Here, ASI would *not* happen. It would be equivalent to:
```js
x |> (@(d) class C {})
```
But a developer might expect ASI to happen, as if it were:
```js
x |> @(d); class C {}
```


[08:11:05.0566] <jschoi>
* ```js
x |> @(d)
class C {}
```
Here, ASI would *not* happen. It would be equivalent to:
```js
x |> (@(d) class C {})
```
But a developer might expect ASI to happen, as if it were:
```js
x |> @(d); class C {}
```


[08:11:48.0490] <nicolo-ribaudo>
Well, that's the same expectation in
```
a = b
[c].map(f)
```

[08:12:06.0775] <nicolo-ribaudo>
If you use ASI, learn it and don't complain ðŸ¤·

[08:12:11.0478] <jschoi>
Yes, that is true, heh.

[08:12:26.0206] <jschoi>
But there is also future-proofing. 

[08:12:36.0907] <jschoi>
```js
x |> @(d)
{ a: 0 }
```

[08:12:54.0416] <jschoi>
ASI *does* happenâ€¦until object-literal decorators get added.

[08:12:55.0412] <nicolo-ribaudo>
We could ask to the other delegates if anyone feels like all those decorators extensions are a possibility on the future

[08:14:03.0758] <jschoi>
I think itâ€™s reasonable to just ban PipeExpression : ShortCircuitExpression `|>` DecoratorList Expression.
Come to think of it, we probably donâ€™t even need a cover grammar.

[08:14:30.0130] <nicolo-ribaudo>
That's a great idea

[08:15:21.0531] <pokute>
That's always a pipe token, never decorator (missing parens I think)

[08:15:29.0456] <pokute>
 * That's always a pipe token, never decorator (missing parens I think)

[08:16:29.0781] <jschoi>
> <@jschoi:matrix.org> I think itâ€™s reasonable to just ban PipeExpression : ShortCircuitExpression `|>` DecoratorList Expression.
> Come to think of it, we probably donâ€™t even need a cover grammar.

```
PipeExpression :
  ShortCircuitExpression `|>` PipeBody
  ShortCircuitExpression `|>` [lookahead âˆ‰ {`class`}] DecoratorList Expression
```
It is a Syntax Error if PipeBody covers DecoratorList `class` BindingIdentifier? ClassTail.
It is a Syntax Error if PipeExpression covers ShortCircuitExpression `|>` DecoratorList Expression.


[08:17:20.0003] <jschoi>
> <@pokute:matrix.org> That's always a pipe token, never decorator (missing parens I think)

It is currently two statements because PipeBody will only parse up to a valid expression, and `@d { a: 0 }` is not a valid expressionâ€¦until, in the future, they add object-literal decorators. Then `@d { a: 0 }` suddenly becomes a valid expression.

[08:18:09.0199] <pokute>
> <@jschoi:matrix.org> It is currently two statements because PipeBody will only parse up to a valid expression, and `@d { a: 0 }` is not a valid expressionâ€¦until, in the future, they add object-literal decorators. Then `@d { a: 0 }` suddenly becomes a valid expression.

Aren't decorators illegal in pipe body unless inside parens?

[08:19:17.0339] <pokute>
Or did I just mess up everything in my mind? :-)

[08:20:23.0015] <jschoi>
> <@pokute:matrix.org> Aren't decorators illegal in pipe body unless inside parens?

Right now, the plan is:
```js
x |> @(foo) class { x = @ }
```
â€¦is illegal.
```js
x |> (@(foo) class { x = @ })
```
â€¦is legal.
```js
x |> (() => @(foo) class { x = @ })
```
â€¦is legal.
```js
x |> do { @(foo) class { x = @ }; }
```
â€¦is legal.


[08:20:57.0680] <jschoi>
The plan is that, if PipeBody covers a decorated class, then it is an early error.

[08:21:43.0594] <jschoi>
But we also need to cover for future cases that are not yet covered by PipeBody because they are not yet valid expressions (like `@(foo) function () {}` or `@(foo) { a: 0 }`).

[08:21:59.0925] <jschoi>
* > <@pokute:matrix.org> Aren't decorators illegal in pipe body unless inside parens?

Right now, the plan is:
```js
x |> @(foo) class { x = @ }
```
â€¦is illegal.
```js
x |> (@(foo) class { x = @ })
```
â€¦is legal.
```js
x |> (() => @(foo) class { x = @ })
```
â€¦is legal.
```js
x |> do { @(foo) class { x = @ }; }
```
â€¦is legal.


[08:22:21.0547] <jschoi>
And, as usual, developers should be discouraged from putting any decorators inside pipe bodies anywayâ€¦

[08:24:00.0566] <pokute>
I would expect that ```x |> (@(d)
{ a: 0 })``` to be a minimal valid usage.

[08:24:44.0467] <pokute>
Could we expect that infix operators to always be in `x infixOp y` form and never in `x (infixOp) y`?

[08:24:52.0084] <pokute>
 * Could we expect that infix operators to always be in `x infixOp y` form and never in `x (infixOp) y`?

