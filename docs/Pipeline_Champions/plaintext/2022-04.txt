2022-04-01
[07:56:43.0339] <jschoi>
There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

[07:57:23.0986] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come. I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers?)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

[07:58:55.0287] <jschoi>
* There are vague future plans for object-literal decorators like `@(d) { x: 0 }`. So:
```js
x |> @(d)
{ x: 0 }
```
…also needs to be future proofed with an early error. We presumably should do the same with array literals. (And tuple/record literals when they come.)

Blocks are fine.
```js
x |> @(d)
{ 0 }
```
…only has one reasonable interpretation (as `x |> @(d); { 0 }`).

I don’t think there’s anything else on the expression level that might get decorated…Maybe identifiers? Right now there are only plans for parameter identifiers so maybe we also ban this too:

```js
x |> @(d)
y
```

