2026-02-13
[13:54:58.0221] <sffc>
Oli is available to join next Wednesday. I'm confirming the exact time.


2026-02-17
[07:58:31.0038] <eemeli>
For consideration on our call tomorrow, I've filed two separate PRs for Amount:
- [Re-include unit conversion in the proposal](https://github.com/tc39/proposal-amount/pull/80)
- [Simplify instance API](https://github.com/tc39/proposal-amount/pull/81)

The former is as discussed on our last call; the latter is a separate change that I think would make Amount fit its use cases more closely, without extending beyond them.

There's also a small fix-up PR mostly adding links to TC39 discussions for Amount.

[09:44:52.0850] <sffc>
Oli is available 8-9 PT.

[11:44:04.0357] <eemeli>
Works for me.


2026-02-18
[23:11:06.0031] <Jesse>
I'll be there

[23:27:34.0082] <ljharb>
i won't be able to make it (in general) during that time.

[13:18:52.0584] <eemeli>
I've updated both of my PRs as discussed today.

[13:39:41.0978] <Richard Gibson>
[cc sffc] relative to our conversation about non-decimal Intl mathematical values, it looks like [ToIntlMathematicalValue](https://tc39.es/ecma402/#sec-tointlmathematicalvalue) requires that every non-bigint input for which [RoundMVResult](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-roundmvresult) produces an infinite result is treated as that infinity—and that implementations get it wrong: https://github.com/tc39/test262/issues/4933


2026-02-19
[18:34:53.0000] <sffc>
Yes that's right; I recall seeing this before. I think Firefox is the only browser doing the right thing

[18:51:38.0760] <sffc>
eemeli: want to give an update on this in TG2 tomorrow?

[18:51:59.0791] <sffc>
* ---
@eemeli:mozilla.org: want to give an update on Amount in TG2 tomorrow?

[18:52:08.0801] <sffc>
*  

@eemeli:mozilla.org: want to give an update on Amount in TG2 tomorrow?

[21:59:00.0668] <eemeli>
Sure, can do.


2026-02-20
[23:55:38.0076] <eemeli>
I've now merged Amount PRs #80 and #81, so that the work on spec text updates can start. Was it Jesse who's taking point on that?

[00:01:03.0544] <Jesse>
yup, just saw your merge -- I'm on it

[00:01:05.0752] <Jesse>
thanks!


2026-02-24
[16:44:39.0710] <sffc>
I am on the hook for updating the spec for Intl MV Limits PR, and probably Intl Unit Protocol assuming we want to advance it. Anything else?

[00:13:36.0908] <Jesse>
I think that's it

[00:14:07.0006] <Jesse>
I'll open a PR for Amount spec text updates

[00:17:35.0836] <Jesse>
shall we go for Stage 2?

[02:50:24.0047] <eemeli>
I think so, if we get the spec text in good enough shape.


2026-02-25
[04:27:46.0364] <eemeli>
Richard Gibson: Just to make sure I understand [this comment](https://github.com/tc39/proposal-intl-keep-trailing-zeros/pull/10#issuecomment-3949688212) right, do you mean that you'd prefer the following formatting results?
```
let sf = new Intl.NumberFormat('en', { notation: 'scientific' })
sf.format('101') // '1.01E2'
sf.format('100') // '1E2'
sf.format('1.00') // '1.00E0'
```

If so, I don't think I agree, as I think the trailing zeros of `'100'` should also be retained. Note that this only affects formatting with scientific or engineering notation, as those are the only cases where we might end up formatting trailing zeros that are parts of the integer in the input as fractional zeros of the output.

[04:28:19.0399] <eemeli>
* Richard Gibson: Just to make sure I understand [this comment](https://github.com/tc39/proposal-intl-keep-trailing-zeros/pull/10#issuecomment-3949688212) right, do you mean that you'd prefer the following formatting results?

```
let sf = new Intl.NumberFormat('en', { notation: 'scientific' })
sf.format('101')  // '1.01E2'
sf.format('100')  // '1E2'
sf.format('1.00') // '1.00E0'
```

If so, I don't think I agree, as I think the trailing zeros of `'100'` should also be retained. Note that this only affects formatting with scientific or engineering notation, as those are the only cases where we might end up formatting trailing zeros that are parts of the integer in the input as fractional zeros of the output.

[08:25:21.0807] <Richard Gibson>
yes, that is what I mean. There is ambiguity regarding zeros in `"100"`, but the conventions with which I'm familiar treat them as insignificant (as described in material from e.g. [Significant Figures Calculator](https://www.sigfigscalculator.com/articles/significant-figures-rules.php#title:~:text=Rule%204%20%2D%20final%20or%20trailing%20zeroes%20are%20significant%20only%20after%20a%20decimal%20point), [Columbia University](https://ccnmtl.columbia.edu/projects/mmt/frontiers/web/chapter_5/6665.html#:~:text=Trailing%20zeros%20in%20a%20whole%20number%20with%20no%20decimal%20shown%20are%20NOT%20significant), [Texas A&M University](https://www.chem.tamu.edu/class/fyp/mathrev/mr-sigfg.html#:~:text=x%20102-,Trailing%20zeros%20are%20significant%20only%20if%20the%20decimal%20point%20is%20specified,-.), and [Khan Academy](https://en.khanacademy.org/science/grade-11-physics-snc-aligned/x1d0fed5276339e80:measurements/x1d0fed5276339e80:analyzing-accuracy-precision-and-derived-quantity-uncertainties/v/more-on-significant-figures))

[08:29:44.0871] <Richard Gibson>
but further note that specific rules regarding disambiguation of trailing zeros are independent of the main point about how the spec should represent string-based decimals

[08:31:52.0556] <Richard Gibson>
* but further note that specific rules regarding disambiguation of trailing zeros are independent of the main point about how the spec should internally represent string-based decimals

[08:39:49.0695] <Richard Gibson>
* but further note that specific rules regarding disambiguation of trailing zeros are independent of the main point about how the spec should internally represent string-based decimals. Treating integer zeros as significant would change only the second data row of that table, from ["d₁…dₖ", x + s] (*d × 10^(x + s)*) to ["d₁…dₖ0₁…0ₛ", x] (*(d × 10^s) × 10^x*)

[08:40:21.0171] <Richard Gibson>
* but further note that specific rules regarding disambiguation of trailing zeros are independent of the main point about how the spec should internally represent string-based decimals. Treating integer zeros as significant would change only the second data row of that table, from \["d₁…dₖ", x + s\] (_d × 10^(x + s)_) to \["d₁…dₖ0₁…0ₛ", x\] (_(d × 10^s) × 10^x_).

[11:01:34.0969] <eemeli>
While I agree that there is some ambiguity here, we do also have a convention on this directly within ECMA-262:
```
(100).toPrecision(1) // '1e+2'
(100).toPrecision(3) // '100'
```

As I see it, we should follow the existing spec precedent, especially as this only impacts the results when formatting with scientific or engineering notation.

[11:02:50.0966] <Richard Gibson>
I don't think that is a relevant precedent

[11:08:53.0349] <eemeli>
Context here is that I'm currently working on an update to the proposal's PR #10 that'll disregard the exponent in the string digits calculation, along with any and all leading zeros. This will match your latest proposal pretty closely, only diverging by considering "100" and "1.00" as belonging to the same sequence, as you put it.

[11:11:33.0322] <eemeli>
My own sense here is that this understanding is more useful, as it's easier to get the ignore-integral-trailing-zeros behaviour by wrapping the formattable numeric string in `Number()`.

[11:15:55.0839] <eemeli>
If we understood `"100"` to have only one significant digit, you'd need to transform it as `(100).toExponential(2)` to ensure that it's parsed as having three significant digits.

