2026-02-13
[13:54:58.0221] <sffc>
Oli is available to join next Wednesday. I'm confirming the exact time.


2026-02-17
[07:58:31.0038] <eemeli>
For consideration on our call tomorrow, I've filed two separate PRs for Amount:
- [Re-include unit conversion in the proposal](https://github.com/tc39/proposal-amount/pull/80)
- [Simplify instance API](https://github.com/tc39/proposal-amount/pull/81)

The former is as discussed on our last call; the latter is a separate change that I think would make Amount fit its use cases more closely, without extending beyond them.

There's also a small fix-up PR mostly adding links to TC39 discussions for Amount.

[09:44:52.0850] <sffc>
Oli is available 8-9 PT.

[11:44:04.0357] <eemeli>
Works for me.


2026-02-18
[23:11:06.0031] <Jesse>
I'll be there

[23:27:34.0082] <ljharb>
i won't be able to make it (in general) during that time.

[13:18:52.0584] <eemeli>
I've updated both of my PRs as discussed today.

[13:39:41.0978] <Richard Gibson>
[cc sffc] relative to our conversation about non-decimal Intl mathematical values, it looks like [ToIntlMathematicalValue](https://tc39.es/ecma402/#sec-tointlmathematicalvalue) requires that every non-bigint input for which [RoundMVResult](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-roundmvresult) produces an infinite result is treated as that infinity‚Äîand that implementations get it wrong: https://github.com/tc39/test262/issues/4933


2026-02-19
[18:34:53.0000] <sffc>
Yes that's right; I recall seeing this before. I think Firefox is the only browser doing the right thing

[18:51:38.0760] <sffc>
eemeli: want to give an update on this in TG2 tomorrow?

[18:51:59.0791] <sffc>
* ---
@eemeli:mozilla.org: want to give an update on Amount in TG2 tomorrow?

[18:52:08.0801] <sffc>
* ¬†

@eemeli:mozilla.org: want to give an update on Amount in TG2 tomorrow?

[21:59:00.0668] <eemeli>
Sure, can do.


2026-02-20
[23:55:38.0076] <eemeli>
I've now merged Amount PRs #80 and #81, so that the work on spec text updates can start. Was it Jesse who's taking point on that?

[00:01:03.0544] <Jesse>
yup, just saw your merge -- I'm on it

[00:01:05.0752] <Jesse>
thanks!


2026-02-24
[16:44:39.0710] <sffc>
I am on the hook for updating the spec for Intl MV Limits PR, and probably Intl Unit Protocol assuming we want to advance it. Anything else?

[00:13:36.0908] <Jesse>
I think that's it

[00:14:07.0006] <Jesse>
I'll open a PR for Amount spec text updates

[00:17:35.0836] <Jesse>
shall we go for Stage 2?

[02:50:24.0047] <eemeli>
I think so, if we get the spec text in good enough shape.


2026-02-25
[04:27:46.0364] <eemeli>
Richard Gibson: Just to make sure I understand [this comment](https://github.com/tc39/proposal-intl-keep-trailing-zeros/pull/10#issuecomment-3949688212) right, do you mean that you'd prefer the following formatting results?
```
let sf = new Intl.NumberFormat('en', { notation: 'scientific' })
sf.format('101') // '1.01E2'
sf.format('100') // '1E2'
sf.format('1.00') // '1.00E0'
```

If so, I don't think I agree, as I think the trailing zeros of `'100'` should also be retained. Note that this only affects formatting with scientific or engineering notation, as those are the only cases where we might end up formatting trailing zeros that are parts of the integer in the input as fractional zeros of the output.

[04:28:19.0399] <eemeli>
* Richard Gibson: Just to make sure I understand [this comment](https://github.com/tc39/proposal-intl-keep-trailing-zeros/pull/10#issuecomment-3949688212) right, do you mean that you'd prefer the following formatting results?

```
let sf = new Intl.NumberFormat('en', { notation: 'scientific' })
sf.format('101')  // '1.01E2'
sf.format('100')  // '1E2'
sf.format('1.00') // '1.00E0'
```

If so, I don't think I agree, as I think the trailing zeros of `'100'` should also be retained. Note that this only affects formatting with scientific or engineering notation, as those are the only cases where we might end up formatting trailing zeros that are parts of the integer in the input as fractional zeros of the output.

[08:25:21.0807] <Richard Gibson>
yes, that is what I mean. There is ambiguity regarding zeros in `"100"`, but the conventions with which I'm familiar treat them as insignificant (as described in material from e.g. [Significant Figures Calculator](https://www.sigfigscalculator.com/articles/significant-figures-rules.php#title:~:text=Rule%204%20%2D%20final%20or%20trailing%20zeroes%20are%20significant%20only%20after%20a%20decimal%20point), [Columbia University](https://ccnmtl.columbia.edu/projects/mmt/frontiers/web/chapter_5/6665.html#:~:text=Trailing%20zeros%20in%20a%20whole%20number%20with%20no%20decimal%20shown%20are%20NOT%20significant), [Texas A&M University](https://www.chem.tamu.edu/class/fyp/mathrev/mr-sigfg.html#:~:text=x%20102-,Trailing%20zeros%20are%20significant%20only%20if%20the%20decimal%20point%20is%20specified,-.), and [Khan Academy](https://en.khanacademy.org/science/grade-11-physics-snc-aligned/x1d0fed5276339e80:measurements/x1d0fed5276339e80:analyzing-accuracy-precision-and-derived-quantity-uncertainties/v/more-on-significant-figures))

[08:29:44.0871] <Richard Gibson>
but further note that specific rules regarding disambiguation of trailing zeros are independent of the main point about how the spec should represent string-based decimals

[08:31:52.0556] <Richard Gibson>
* but further note that specific rules regarding disambiguation of trailing zeros are independent of the main point about how the spec should internally represent string-based decimals

[08:39:49.0695] <Richard Gibson>
* but further note that specific rules regarding disambiguation of trailing zeros are independent of the main point about how the spec should internally represent string-based decimals. Treating integer zeros as significant would change only the second data row of that table, from ["d‚ÇÅ‚Ä¶d‚Çñ", x + s] (*d √ó 10^(x + s)*) to ["d‚ÇÅ‚Ä¶d‚Çñ0‚ÇÅ‚Ä¶0‚Çõ", x] (*(d √ó 10^s) √ó 10^x*)

[08:40:21.0171] <Richard Gibson>
* but further note that specific rules regarding disambiguation of trailing zeros are independent of the main point about how the spec should internally represent string-based decimals. Treating integer zeros as significant would change only the second data row of that table, from \["d‚ÇÅ‚Ä¶d‚Çñ", x + s\] (_d √ó 10^(x + s)_) to \["d‚ÇÅ‚Ä¶d‚Çñ0‚ÇÅ‚Ä¶0‚Çõ", x\] (_(d √ó 10^s) √ó 10^x_).

[11:01:34.0969] <eemeli>
While I agree that there is some ambiguity here, we do also have a convention on this directly within ECMA-262:
```
(100).toPrecision(1) // '1e+2'
(100).toPrecision(3) // '100'
```

As I see it, we should follow the existing spec precedent, especially as this only impacts the results when formatting with scientific or engineering notation.

[11:02:50.0966] <Richard Gibson>
I don't think that is a relevant precedent

[11:08:53.0349] <eemeli>
Context here is that I'm currently working on an update to the proposal's PR #10 that'll disregard the exponent in the string digits calculation, along with any and all leading zeros. This will match your latest proposal pretty closely, only diverging by considering "100" and "1.00" as belonging to the same sequence, as you put it.

[11:11:33.0322] <eemeli>
My own sense here is that this understanding is more useful, as it's easier to get the ignore-integral-trailing-zeros behaviour by wrapping the formattable numeric string in `Number()`.

[11:15:55.0839] <eemeli>
If we understood `"100"` to have only one significant digit, you'd need to transform it as `(100).toExponential(2)` to ensure that it's parsed as having three significant digits.

[11:16:12.0812] <eemeli>
* If we understood `"100"` to have only one significant digit, you'd need to transform it as `Number("100").toExponential(2)` to ensure that it's parsed as having three significant digits.

[11:19:45.0145] <eemeli>
I think it would also mean that we'd want to do this to ensure that round-tripping was not lossy, while keeping the value as simple as possible:
```
let a = new Amount(100, { significantDigits: 3 })
a.value // '1.00e+2'

let b = new Amount(101, { significantDigits: 3 })
b.value // '101'
```
That seems unnecessarily clumsy?

[11:22:15.0074] <eemeli>
(yes, that's mixing in Amount stuff with keep-trailing-zeros, but I'm pretty sure we want those to match each others' logics)

[11:28:19.0099] <eemeli>
And that then loops us back to `Number.p.toPrecision()`, as a consideration of 100 as having one significant digit would mean that
```
n.toPrecision(p)
```
and
```
new Amount(n, { significantDigits: p }).value
```
would not always be equal for Number values of `n`.


2026-02-26
[23:08:21.0323] <Jesse>
Richard brings up an aspect of Amount + Intl that wasn't on my radar at all: measurement systems and unit overrides. Could we discuss that at today's call?

[23:56:09.0026] <sffc>
I think we just need to define whether 100 has 1 or 3 significant digits. I lean toward 3. 100 and 101 intuitively have the same number of significant digits. You count 99, 100, 101. I shouldn't be forced to write "1.00E2" to make a 3-digit number. I consider a low-precision integer sufficiently uncommon that I'm okay if you need to write "1E2" in order to get it.

[00:09:53.0745] <eemeli>
Jesse: In [this commit](https://github.com/tc39/proposal-amount/pull/84/changes/06ca77bb26164932088507d33ba5be470530c825) you're presenting Claude Opus 4.6 as a co-author. Is that not a problem, given our [AI policy](https://github.com/tc39/how-we-work/blob/main/AI_POLICY.md)?

[00:11:25.0583] <sffc>
Heh, I think that AI Policy was written in the brief period when chatbots were going viral but before AI coding agents became viable. It probably needs to be updated again.

[00:12:02.0221] <eemeli>
It was merged in two weeks ago.

[00:12:38.0636] <sffc>
Yes but I remember reviewing the text of it at a TG1 meeting in 2025, I think in the middle of 2025.

[00:12:59.0584] <sffc>
I'm tasked with writing a similar AI usage policy for contributions to Unicode. It's likely going to say that AI tool usage is acceptable so long as it is disclosed.

[00:15:42.0954] <sffc>
My recollection is that bakkot wrote the policy in response to a whole bunch of AI slop comments on proposal issues. We definitely need to address this new use case of AI tools that produce halfway-decent spec text and potentially save time.

[00:18:18.0168] <nicolo-ribaudo>
Fwiw I remember mentioning copilot autocompletions during that discussion, and that seemed to be acceptable 

[00:29:47.0068] <eemeli>
To clarify, I personally don't find the private use of LLMs like here objectionable, but I do think that it's technically speaking against the current policy, which clearly states:
> Any contributions or comments must be your own writing, not the product of large language models (LLMs) or other tools.

Furthermore, our IP policy requires contributors [to sign](https://github.com/tc39/how-we-work/blob/main/ip.md#contributor-ipr-license) the non-member contributor agreement, which Claude has not/cannot do.

[00:44:10.0722] <sffc>
---
If Amount contains the Intl.NF.prototype.format change, then Intl Unit Protocol basically amounts to pulling that specific change out into its own mini proposal, right?

[00:51:41.0973] <Jesse>
happy to drop that commit; I just used the tool to find an AO (`CopyDataProperties`) that I had been overlooking. This was a case of using Claude as a sort of power grep

[00:54:20.0552] <nicolo-ribaudo>
Let's maybe just amend the commit and remove the attribution then? üòÖ

[01:04:33.0874] <eemeli>
I'm not sure what you mean by "measurement systems", but on unit overrides this seems relevant: https://github.com/sffc/proposal-intl-unit-protocol/issues/3

[01:06:42.0339] <eemeli>
Yes.

[01:10:52.0084] <Jesse>
I understood Richard's coment to be about parsing locale strings that specify things like measurement systems and unit overrides

[01:11:12.0453] <Jesse>
(initially; and then, how that handle such things in the spec)

[01:15:11.0206] <Jesse>
I'd like to discuss this in the call tonight, if possible, so we can reach a state that's not _too_ handwavy

[01:16:13.0355] <Jesse>
thinking backwards from the deadline, it would be nice to make a decision about whether this should prevent us from trying to go to stage 2

[01:18:21.0480] <Jesse>
one possible decision would be to say that we want to discuss this in TG2 first

[01:23:37.0315] <eemeli>
Ah, I presume you mean [this comment](https://github.com/tc39/proposal-amount/pull/84#discussion_r2854546506) on the Amount PR, and not the comment on the keep-trailling-zeros PR I linked to earlier.

[01:23:55.0227] <Jesse>
yeah that one

[01:24:17.0598] <Jesse>
sorry for the confusion; channels got crossed

[01:25:41.0758] <Jesse>
I'd be OK with just punting on this issue; just use whatever the resolved locale specifies, and ignore any request for alternative measurement systems

[01:25:56.0926] <Jesse>
iow deferring to stage 2

[01:26:22.0759] <Jesse>
after discussing in TG2

[01:26:48.0541] <Jesse>
but again, I might be misunderstanding Richard's suggestion

[01:29:09.0645] <eemeli>
We should discuss that on the call. I think for Stage 2 it's enough to consider "just" as a part of locale handling. `-u-mu` is pretty straightforward; `-u-ms` is more interesting as we don't have a corresponding Intl.NumberFormat option for it.

[03:17:57.0059] <eemeli>
A quick review of https://github.com/tc39/proposal-intl-keep-trailing-zeros/pull/14 would be appreciated; it only updates the baseline spec for the proposal's diff as e.g. https://github.com/tc39/ecma402/pull/1026 covered many of the changes also made in this proposal to PluralRules.

[05:36:46.0765] <Jesse>
I think I've reached a sort of steady state with the Amount spec text PR; thanks for all your feedback. I'd love it if we could discuss some of the outstanding issues in today's JS numerics call

[07:36:30.0388] <Richard Gibson>
I don't care if those differ, and I think they're planned to anyway‚Äîunless you want Amount value to inherit the arbitrary 1e-6 switch from leading decimal point to exponential?

[07:37:48.0056] <Richard Gibson>
hmm, I guess we need to talk more about synthesized Amount `value`. One possibility is that it is _always_ in scientific notation, which would have the benefit of always being unambiguous w.r.t. significant digits

[07:47:08.0664] <Jesse>
I also kinda like the scientific notation approach to significant digits

[07:54:54.0242] <eemeli>
I'd be happy to adopt the 1e-6 boundary, at least initially. It is a bit arbitrary, but it is a thing that's already in the language. Therefore I'd presume it as our null hypothesis until and unless some other  representation can be shown to be better in some way.

[07:59:03.0647] <Richard Gibson>
an always-scientific format would be better in at least two ways: unambiguous representation of significant digits and simplicity of machine processing

[08:05:12.0845] <eemeli>
I would not object to always using exponential/scientific notation.


2026-02-27
[17:40:34.0044] <sffc>
Where did we land on currency amounts? Are they exported via the `unit` getter?

[17:40:55.0888] <sffc>
(we can change in Stage 2 but I want to make sure Intl Unit Protocol is up to date)

[17:45:23.0097] <sffc>
Draft slides: https://docs.google.com/presentation/d/1ECuRD0MU6-Z5DzBJaOi5W3u7f2kf_PZYZU9cXjg5Ock/edit?slide=id.p#slide=id.p

[17:46:00.0228] <sffc>
I intend to copy the Intl spec from Amount into Intl Unit Protocol as late as possible before the deadline

[17:51:29.0293] <Richard Gibson>
yes, with no special treatment other than "_Unit identifiers consisting of three upper-case ASCII letters will be formatted with `style: 'currency'`_": https://github.com/tc39/proposal-amount?tab=readme-ov-file#units-including-currency

[18:11:54.0334] <sffc>
I added my two proposals to the agenda, pending the spec availability for Intl Unit Protocol: https://github.com/tc39/agendas/commit/f6f0435b4ceda82c31f997b02473ffb15027dbd7

[06:32:47.0863] <eemeli>
Draft slides for Amount: https://docs.google.com/presentation/d/1SAD0bgB_SOWrtz1YZuySC4YHdMxBs0vTnS7buQa311c/edit?usp=sharing

Please request permissions as necessary; for now I added ecma402-delegates@chromium.org as editor.

[07:30:06.0731] <Jesse>
I've opened a (somewhat) simplified PR to align with the README changes: https://github.com/tc39/proposal-amount/pull/85

[07:48:43.0677] <Jesse>
would someone like to file an issue about using exponential notation?

[07:49:22.0149] <Jesse>
(that idea isn't in the spec text PR)

[07:52:48.0396] <Jesse>
it wasn't quite clear to me, upon reflection, what the scope of the idea was:

[07:54:34.0548] <Jesse>
when we say we want to use exponential notation for string-y Amounts, do we also convert things like `"123.456"` into `"1.23456e2"`?

[07:54:51.0359] <Jesse>
like, `new Amount("123.456").value === "1.23456e2"`?

[07:56:36.0024] <Jesse>
or do we convert to exponential notation only when some kind of calculation (rounding, reducing, or expanding fraction or significant digits)?

[07:58:59.0492] <nicolo-ribaudo>
This would change the precision, right?

[08:00:25.0881] <Richard Gibson>
I think I'm fine with this

[08:01:47.0924] <nicolo-ribaudo>
Nevermind, ignore this üòÖ

[08:02:03.0604] <Jesse>
<del>I think</del> oh ok

[08:08:56.0258] <Richard Gibson>
...but I guess that's to be sorted out in the issue. Preserving an input string as-is entails lots of potential variation‚Äîleading zeros, casing of "e" in the exponential part, optionality of "+" for a positive exponent, and arguably even non-decimal representations like "0x0" or "0o7". Although that last one seems best handled by converting to Number, such that `new Amount("0xFF").value === 255`.

[08:26:03.0105] <Richard Gibson>
eemeli: would you like to discuss https://github.com/tc39/proposal-intl-keep-trailing-zeros/pull/10#discussion_r2863142664 here, or in that PR, or in the test262 PR? The assertion that seems wrong to me is `assert.sameValue(nf.format('1.2345e-1000'), '0.0000')`‚Äîthe significant digits of 1.2345e-1000 are all below the representable threshold, and preserving their _count_ while moving their _position_ is unjustified. That output should be "0.00000000000000000000", just like how `nf.format('1.2345e-20')` would be "0.00000000000000000001".

[08:35:57.0163] <eemeli>
I gave it a review; it's still got a whole bunch of text that's not needed if we instead refer to Number.p.toExponential and FormatNumericToString.

[08:37:39.0705] <eemeli>
I'd prefer for the string .value to always be normalised as using exponential notation. I'll submit an issue, also covering the treatment of non-finite values.

[08:42:14.0921] <eemeli>
Here might be easiest. To me, the situation is analogous with
```
assert.sameValue(nf3.format('1.99999'), '2.000');
```
which does the same sort of rounding, just to a different integer.

Overall, I don't think the line you're pointing at would be the place where I'd apply the change, as while it would change the treatment of `'1.2345e-1000'`, it would keep the formatting of `'1.2345e-200'` as `'0.0000'`, and I don't see why those ought to be different.

[08:42:33.0006] <Jesse>
the normalization I have in mind might be: string argument `s` comes in, but we store `Number(s).toExponential()`

[08:43:03.0470] <eemeli>
Yeah, except we don't actually force the string value to fit in Number limits.

[08:43:17.0168] <eemeli>
And we don't cap the precision at 100.

[08:44:08.0366] <eemeli>
... and we'll need to retain the trailing zeros.

[08:45:53.0285] <Jesse>
do you mean in the `.convertTo` text?

[08:47:16.0724] <eemeli>
See my line comments, also in the constructor.

[08:47:26.0171] <Jesse>
oh ok, thanks -- will do

[08:50:11.0640] <eemeli>
Richard Gibson: I think the issue you're raising is really rather close to https://github.com/tc39/proposal-intl-keep-trailing-zeros/issues/11, which we resolved at the November pleanry.

[08:51:25.0877] <Richard Gibson>
>  To me, the situation is analogous with `assert.sameValue(nf3.format('1.99999'), '2.000')` which does the same sort of rounding, just to a different integer.

I see that `nf3` has { minimumSignificantDigits: 2, maximumSignificantDigits: 4 }, so I agree. Rounding up to 2.000 as part of clamping significant digits is analogous to rounding down to 0.00000000000000000000 as part of clamping fractional digits.

> Overall, I don't think the line you're pointing at would be the place where I'd apply the change, as while it would change the treatment of '1.2345e-1000', it would keep the formatting of '1.2345e-200' as '0.0000', and I don't see why those ought to be different.

that seems plausible to me; I was unclear on the overall changes when I posted that comment and the proposed spec text since then anyway. I agree that "1.2345e-1000" and "1.2345e-200" should be subject to the same treatment, and should produce the same output when 1e-200 is below a digits threshold.

[08:53:38.0163] <Richard Gibson>
that looks like a separate issue to me

[08:56:40.0810] <eemeli>
Richard Gibson: My takeaway from that discussion (at least what I see as relevant here) is that we should retain the significant-digits precision when the input does not contain trailing zeros, but the formatted output does, because of rounding. And so to me, `1.23e-1000` is an input value from which we count a _stringDigitCount_ of 3, which we ought to retain when formatting it as `0.00`.

[09:00:23.0300] <Richard Gibson>
that is not my takeaway at all, and I'm strongly opposed to retaining the count while moving the position. 1.23e-1000 wants to format like "0.0‚Ä¶0‚Ä¶0123", which maximumFractionDigits rounds to "0.0‚Ä¶0". In the absence of trailing zero preservation that would be further transformed to "0", but with such preservation we want it right at the maximum.

[09:02:29.0688] <eemeli>
Would you want `1.23e-100` to format the same way?

[09:03:26.0677] <Richard Gibson>
yes

[09:04:00.0590] <eemeli>
Richard Gibson: Regarding "retaining the count while moving the position", does that mean that you think we should drop trailing zeros when formatting with `style: 'percent'`?

[09:04:00.0882] <Richard Gibson>
* yes, for exactly the same reason

[09:04:30.0474] <eemeli>
* Richard Gibson: Regarding "strongly opposed to retaining the count while moving the position", does that mean that you think we should drop trailing zeros when formatting with `style: 'percent'`?

[09:05:38.0177] <eemeli>
And similarly, when using a different notattion than what's used in an input string?

[09:05:44.0561] <Richard Gibson>
do you have a concrete example?

[09:06:24.0052] <eemeli>
From the test suite:
```
const pf = new Intl.NumberFormat('en-US', {
  style: 'percent',
  maximumFractionDigits: 10,
});

assert.sameValue(pf.format('0.5000'), '50.00%');
```

[09:06:36.0150] <Ben Allen>
Yay, thank you! I'll go over them and flesh them out (update the "recent changes" slide, etc). it'll be a good chance to catch up on everything that's happened while I've been focused on era monthcode

[09:07:24.0641] <eemeli>
Also:
```
const sf = new Intl.NumberFormat('en-US', { notation: 'scientific' });
assert.sameValue(sf.format('0.01200'), '1.200E-2');
```

[09:07:29.0909] <Richard Gibson>
that looks reasonable to me; `style: 'percent'` explicitly scales the input while `maximumFractionDigits` affects the _output_

[09:08:22.0532] <Richard Gibson>
also exactly right because it's preserving significant digits and not affecting fractional digits at all

[09:09:16.0770] <eemeli>
Richard Gibson: Ok, so the only problematic case is when we have a very small number like `1.23e-200` that we're formatting as some representation of zero, then?

[09:09:40.0833] <Richard Gibson>
that what it seems like to me

[09:09:46.0335] <Richard Gibson>
* that's what it seems like to me

[09:10:25.0120] <eemeli>
And you would prefer that we format that using whatever's the max precision.

[09:15:44.0761] <eemeli>
Richard Gibson: If the PR is otherwise acceptable, could I file an issue and work on a separate PR specifically about addressing that?

[09:16:52.0748] <Richard Gibson>
yes, I think that works. I'll re-review the current PR with an appropriate scope of changes.

[09:18:32.0149] <eemeli>
Thanks, that would be helpful. PR #10 is changing so much of the implementation that it might be easier for @sffc to review the whole of the proosal with it included, once the rendered spec text is available.

[09:18:55.0135] <eemeli>
* Thanks, that would be helpful. PR #10 is changing so much of the implementation that it might be easier for @sffc to review the whole of the proposal with it included, once the rendered spec text is available.

[09:29:43.0926] <eemeli>
Richard Gibson: https://github.com/tc39/proposal-intl-keep-trailing-zeros/issues/15

[09:30:18.0960] <eemeli>
* Thanks, that would be helpful. PR #10 is changing so much of the implementation that it might be easier for sffc to review the whole of the proposal with it included, once the rendered spec text is available.

[10:07:47.0746] <eemeli>
I went with a readme PR instead: https://github.com/tc39/proposal-amount/pull/86

[10:10:51.0671] <Jesse>
I've taken care of the review comments -- thanks eemeli !

[10:10:57.0792] <Jesse>
I was able to trim quite a lot

[10:27:09.0285] <sffc>
> <@eemeli:mozilla.org> Draft slides for Amount: https://docs.google.com/presentation/d/1SAD0bgB_SOWrtz1YZuySC4YHdMxBs0vTnS7buQa311c/edit?usp=sharing
> 
> Please request permissions as necessary; for now I added ecma402-delegates@chromium.org as editor.

Cool. Worthwhile reiterating the motivation, with an emphasis now on this meeting a requirement for smart units

[10:27:30.0025] <eemeli>
Jesse: Gave you another review, https://github.com/tc39/proposal-amount/pull/85#pullrequestreview-3868361030

[10:29:24.0888] <sffc>
> <@jesse:igalia.com> when we say we want to use exponential notation for string-y Amounts, do we also convert things like `"123.456"` into `"1.23456e2"`?

I think I prefer string decimals to be always normalized to this form; "10.00E2" and "1.000E3" and "1000" should be equal.

[10:32:11.0968] <sffc>
> <@eemeli:mozilla.org> Thanks, that would be helpful. PR #10 is changing so much of the implementation that it might be easier for sffc to review the whole of the proposal with it included, once the rendered spec text is available.

Yes it seemed that way when I last looked. I would prefer to read the whole proposal in rendered form once you merge with Richard's approval

[11:08:46.0542] <eemeli>
A rendered view of the keep-trailing-zeros spec including PR #10's changes is currently available at https://eemeli.org/tc39-proposal-intl-keep-trailing-zeros/

[11:38:32.0006] <Jesse>
done!

[11:57:51.0556] <eemeli>
One more thing, then I think it's good. Note that I've not really looked at the Intl changes almost at all, as I trust that Shane will go through those when moving them to his proposal.

I think I'm done for the day; will check in sometime tomorrow. I've submitted agenda items for keep-trailing-zeros and import-text; I trust that someone else will put one in for amount.

[13:42:42.0956] <Jesse>
took care of it!

[13:42:51.0792] <Jesse>
I'm also stepping away for today


2026-02-28
[23:03:59.0865] <eemeli>
The agenda now includes a "Stage 2 Decimal update", and nothing on Amount. That seems... incorrect?

[00:08:26.0328] <Jesse>
on it -- that should say amount; nothing is planned for decimal

[00:11:16.0528] <Jesse>
ah there was both decimal _and_ amount. Should be just amount

[00:12:03.0959] <Jesse>
fixed

[00:47:30.0048] <eemeli>
Jesse: I approved https://github.com/tc39/proposal-amount/pull/85, after piling on some more changes to it.

[00:52:24.0364] <eemeli>
Oh, I'd not noticed the Amount one as I got stuck on the Decimal. I'm kinda dubious that 30 mins is enough; I think we should ask for an hour.

