2025-09-02
[06:11:50.0738] <Jesse>
reminder -- we have a JS numerics call on Thursday!

[06:12:28.0669] <Jesse>
the main topic is to try to settle on how we want to handle infinity in the data model

[06:32:20.0263] <Jesse>
agenda is at https://docs.google.com/document/d/1O2EQC61TIDtkcvDSkhDf4N_R9GioT0foU2tH9HBdMdQ/edit?pli=1&tab=t.0#heading=h.v13inqtu2ric


2025-09-04
[09:02:50.0288] <sffc>
Running a few minutes late


2025-09-18
[08:30:06.0935] <eemeli>
We have a call today, yes?

[08:46:54.0255] <Jesse>
yes!

[08:47:06.0816] <Jesse>
agenda here: https://docs.google.com/document/d/1O2EQC61TIDtkcvDSkhDf4N_R9GioT0foU2tH9HBdMdQ/edit?pli=1&tab=t.0

[09:52:31.0485] <Jesse>
taking a look at https://github.com/tc39/proposal-amount/issues/54 , I think the SDO in keep-trailing-zeros should take care of most/all of these?

[09:53:17.0470] <Jesse>
(the version of the spec that WH is referring to is an older one that predates our pirating of some of keep-trailing-zero's functionality, specifically the SDO that computes significant digits)

[09:54:28.0236] <Jesse>
B-en would you be willing to add an open question to plenary in the amount slides about parsing numbers with units in them? E.g. `new Amount("42[kg]")

[09:54:33.0629] <Jesse>
* B-en would you be willing to add an open question to plenary in the amount slides about parsing numbers with units in them? E.g. \`new Amount("42\[kg\]")`

[09:54:41.0414] <Jesse>
* B-en would you be willing to add an open question to plenary in the amount slides about parsing numbers with units in them? E.g. `new Amount("42\[kg\]")`

[09:55:19.0910] <Jesse>
there was also an open question about what keep-trailing-zeroes does in Intl.NF when given exponential notation strings like "3e-5"

[09:57:06.0240] <Ben Allen>
and our current position is basically just... "we dunno?"

[09:57:12.0082] <Jesse>
yeah

[09:58:24.0385] <Jesse>
this might intersect with discussions about notation for numbers-with-units in ther contexts like CLDR etc. we're sort of rolling with a new (?) bracket notation

[10:01:13.0152] <Jesse>
there's also a todo to make an issue to discuss creatng amounts from an amount. I see a reference to that here: https://github.com/tc39/proposal-amount/issues/49#issuecomment-3286110669

[10:02:50.0591] <Jesse>
I'm not sure what the issue is? It seems to me that we'd like to have the property `new Amount(new Amount(a, b), c)` equivalent to new Amount(a, b).with(c)

[10:02:59.0031] <Jesse>
* I'm not sure what the issue is? It seems to me that we'd like to have the property `new Amount(new Amount(a, b), c)` equivalent to `new Amount(a, b).with(c)`

[10:04:58.0797] <Jesse>
or to put it differently: should we ban `new Amount(new Amount(...))`?

[10:05:45.0291] <Jesse>
thinking ahead to decimal and other number-y things, I suppose we should support them. but they'll be objects so I suppose we'd need to do some brand checks


2025-09-19
[20:29:42.0771] <sffc>
Jesse, can you make the polyfill available someplace like https://tc39.es/proposal-amount/docs/ so that people can use it in the web inspector like they can with the Temporal polyfill?

[23:43:45.0975] <Jesse>
great idea -- I'm on it!

[00:46:28.0500] <sffc>
I made some PRs to the README: https://github.com/tc39/proposal-amount/pull/60, https://github.com/tc39/proposal-amount/pull/61

[05:41:51.0151] <nicolo-ribaudo>
From the accounting software I use :)

[09:48:26.0666] <sffc>
Important Update: I had a discussion with folks from the V8 team about pushback on the proposal, who hold similar perspectives as some of the other skeptics. Good news is that we arrived at common ground on the proposal being acceptable, but with a name such as `FormattableAmount` that emphasizes that its semantics are around formatting as opposed to arithmetic or other things that users might want to use them for. I think we should go to Stage 2 with that name in order to avoid potential issues during plenary. We can continue to discuss the name during Stage 2.

[09:49:04.0004] <sffc>
The V8 folks also want us to engage more proactively with the HTML `<amount>` proposal, which I agree with.

[10:06:10.0127] <eemeli>
I am not comfortable with changing the proposed name without a discussion in committee about it. To me, `FormattableAmount` implies that it should not be used for interchange. If that is the case, then we should re-consider whether it ought to go under the `Intl` namespace.

[10:16:13.0851] <sffc>
I mostly agree but also see the perspective that Amount sounds like something that wants to eventually get arithmetic and be used in other contexts

[10:17:23.0342] <sffc>
This was late breaking feedback and we didn't have time to bike shed a name that would fully convey "useful for interchange and formatting but not arithmetic"

[10:18:14.0537] <sffc>
I think we should have that discussion during Stage 2. I don't want to keep being stuck in Stage 1 because every meeting some new delegate raises some new concern

[10:19:20.0762] <sffc>
Maybe InterchangeAmount?

[10:20:03.0695] <sffc>
At this point I won't block Intl.Amount either, because I'd rather get Stage 2

[10:22:58.0845] <sffc>
The other feedback I got from V8 team was, "there's multiple ways to represent precision, why do we want to bless significant digits" to which my answer was "because 402 and 262 already do that in their stringification APIs" to which the response was "well then emphasize that this thing has string semantics"

[10:24:12.0177] <sffc>
I wish this feedback had come in a month ago but I only received it at 1700 UTC yesterday

[10:39:47.0575] <sffc>
But, well, better now than "in plenary"

[10:42:17.0819] <eemeli>
If these are Stage 2 blockers, we should not rush to make changes to the proposal before it's presented next week, but either try for Stage 2 with what we have now, or withdraw the presentation, take the time to review and update, and then bring it up at the next meeting.

[10:43:14.0798] <eemeli>
* If these are Stage 2 blockers, we should not rush to make changes to the proposal before it's presented next week, but either
1. try for Stage 2 with what we have now, or
2. withdraw the presentation, take the time to review and update, and then bring it up at the next meeting.

[10:46:14.0956] <eemeli>
My preference would be for the latter, actually. Better to get this to Stage 2 on our next attempt, rather than fail to do multiple times running.

[10:46:32.0618] <sffc>
We've already done (2) once, I don't want to do it again. I didn't hear anything new from V8, just more strongly held

[10:47:01.0072] <eemeli>
When have we withdrawn an Amount presentation?

[10:47:28.0512] <sffc>
Withdrawn from asking for Stage 2, which we did in July

[10:48:19.0124] <sffc>
I'm playing with the "Google consensus" here. We had that in July which is why I'm frustrated that we don't seem to have it now on September, maybe due to the Shu transition or people being on vacation

[10:48:39.0149] <sffc>
But we have it if we pick a name like FormattableAmount

[10:49:59.0766] <eemeli>
Will the concerns about "Amount" be raised in an issue on the repo?

[10:50:08.0492] <sffc>
If we delay Stage 2 again, it just invites more delegates to rehash these same points again. I would feel different if I felt that the feedback I got from V8 raised novel concerns.

[10:51:25.0129] <nicolo-ribaudo>
Could we go with "AmountPlaceholder" and say we'll decide it in stage 2?

[10:51:33.0347] <sffc>
The V8 team rarely posts their actual position on GitHub; they channel it through Shu and now Rezvan. I got the opportunity to talk directly with them because I work at Google

[10:52:45.0764] <sffc>
I think SM does the same, channeling it through Dan or Yulia

[10:53:40.0667] <eemeli>
To some extent yes, but for specific issues like this I'd expect the concerns to be raised as issues as well as in committee.

[10:55:34.0714] <eemeli>
`FormattableAmount` or any other iteration of the name is a solution to some problem with the proposal as it's currently presented. If that problem is that there's disagreement about the use cases or intended utility, then we should have that explicitly recognised before we jump to a solution. I'm not at all sure that renaming is the right solution, and I'm not really sure what the problem is that you want to solve with it.

[10:56:42.0920] <eemeli>
(Also, it's 9pm on Friday evening for me, I'm already down two pints, and hence I don't think I'm in a state where I should be agreeing to any significant changes to the proposal before Monday.)

[10:56:43.0329] <sffc>
I said the two problems in my first set of comments in this channel

[10:57:50.0276] <eemeli>
So if the problem is
> its semantics are around formatting as opposed to arithmetic or other things that users might want to use them for

Then interchange is out as a rationalisation, yes?

[10:58:54.0962] <sffc>
(1) they really really don't want arithmetic and don't want to be put in a position where they have to fight people trying to add it, and (2) they aren't convinced 262 should be blessing this specific representation of precision for the general case of physical quantities since there are other ways to represent precision

[10:59:03.0423] <eemeli>
And if the focus ought to be on the formatting, then that changes how we ought to be presenting the precision, as then we're presumably talkign about the precision of the formatted result, rather than the precision of the mathematical value.

[10:59:26.0525] <sffc>
They seem okay with the interchange aspect

[11:00:12.0719] <eemeli>
If that's the case, then "formattable" doesn't seem like an appropriate qualifier for the name.

[11:00:48.0094] <sffc>
I agree but it gets us closer. AdjectiveAmount where Adjective has something to do with the desired use case

[11:01:24.0872] <eemeli>
> they really really don't want arithmetic

What does this mean about Decimal? Is that effectively DOA?

[11:02:44.0180] <sffc>
I think it means the specific version where we add arithmetic to Amount is dead. Not necessarily Decimal but that's a different discussion.

[11:03:45.0982] <sffc>
We didn't discuss too deeply about whether unit conversion could be acceptable. I think we might have a slightly better chance there 

[11:05:36.0688] <eemeli>
I don't really see how changing the name is required to prevent arithmetic from being added later, when the same effect would be achievable by the V8 team clearly stating that while they're fine with an Amount (as currently proposed) without arithmetic, they would not be fine with later proposals adding such arithmetic.

[11:07:13.0756] <sffc>
It's more about emphasizing the desired purpose. A dev might reasonably want to do math on an Amount, but not on a FormatableAmount

[11:07:56.0867] <eemeli>
Similarly, a dev might reasonably want to use an Amount for interchange, but not a FormattableAmount.

[11:09:28.0214] <eemeli>
And so if the Amount is meant to be primarily formattable, then it rather logically could make sense as Intl.Amount.

[11:09:38.0065] <eemeli>
(I'll be logging off for the night in max 15 mins.)

[11:12:14.0300] <eemeli>
Is the V8 team concerned about Amount math happening in the spec, or Amount math happening in general? I would presume that we'd end up with some userland libraries adding such capabilities to Amount. But perhaps not to FormattableAmount.

[11:15:04.0430] <sffc>
I think we can get consensus on a name that covers interchange and formatting but also discourages arithmetic

[11:15:33.0863] <sffc>
I don't have a suggestion at this moment for that name. InteropAmount?

[11:16:51.0586] <sffc>
That's a good nuanced question that I don't have an answer to

[11:17:39.0657] <eemeli>
Exactly; I'd like to have the discussion about the problem before we have the discussion about the solution.

[11:21:07.0679] <sffc>
There's also the second concern; he pointed at a thermometer on the wall and said it measures barometric pressure to 5 millibar, but Amount can't represent that, and it can't represent 5ft 9in either, so it isn't a very good solution for representing physical quantities in general. Michael Ficarra raised similar concerns with 3/4 Mile (rational amounts).

[11:22:08.0921] <sffc>
So their position is that the name should emphasize that we are picking a very specific representation, one that is based on the needs of formatting

[11:23:10.0699] <eemeli>
That also implies that we should consider `roundingIncrement` or similar.

[11:23:54.0274] <eemeli>
(Train's arriving at my station; will try not to work over the weekend, so might take until Monday that I can continue here.)

[11:24:46.0539] <sffc>
Supporting `roundingIncrement` in the constructor is a good idea, probably one we should add. I don't think that resolves concerns about the relationship between the data model and the name of the type


2025-09-21
[00:36:41.0449] <Jesse>
oh no -- it looks like when I tweaked the GitHub Pages setup for Amount, people ended up looking at an old version of the spec

[00:36:46.0560] <Jesse>
https://github.com/tc39/proposal-amount/issues/54#issuecomment-3315302152

[00:37:17.0549] <Jesse>
the comment only makes sense if you realize that WH must have been looking at an old spec; we *did* make those changes

[04:52:51.0659] <nicolo-ribaudo>
sffc Does the discussion above mean that the V8 team would not be ok with adding unit conversion / smart units to these objects?

[09:03:40.0256] <sffc>
> <@nicolo-ribaudo:matrix.org> sffc Does the discussion above mean that the V8 team would not be ok with adding unit conversion / smart units to these objects?

We didn't go into depth but I think it might actually be easier to make that argument than general arithmetic, if the goal is to exactly mirror what Intl would be doing, string to string

[09:06:46.0509] <sffc>
(I'm trying my best to channel the position I heard from them which probably is not 100% on the dot)

[09:12:04.0395] <Rob Palmer>
It seems important to have someone from V8 present during this topic. Do you know who will attend? 


2025-09-22
[23:06:09.0928] <Jesse>
If we’re getting the calculations of significant digits wrong, even after adapting keep-trailing-zeros’s SDO, I wonder if there’s a bug in the SDO or whether I’m using it incorrectly

[23:07:05.0892] <Jesse>
what do we think of the suggestion to not even compute significant digits?

[23:07:32.0141] <Jesse>
JRL usually comes but I’m not sure if he’s in the V8 team

[23:37:13.0431] <eemeli>
Morning. I've not looked at issues yet, but not computing significant digits has been on my mind as a decent solution. As in, I don't think without further information we can know whether `'4200'` has two or four significant digits, or whether `'0.042'` and `'4.2e-2'` have the same or different numbers of significant digits. I'll go find an issue where to comment on this more publicly.

[23:58:21.0934] <Jesse>
regarding the issue of arithmetic, I thought we generally wanted to avoid that. At most, arithmetic would happen internally when doing unit conversions, but that's different from Amount offering you an API for doing arithmetic

[23:58:47.0794] <Jesse>
I'd say https://github.com/tc39/proposal-amount/issues/54 is a good candidate

[00:02:21.0880] <nicolo-ribaudo>
It seems like you just forgot to subtract from the number of fractional digits the exponent, for numbers written in exponential notation 

[00:02:46.0631] <nicolo-ribaudo>
And then use the conversion between fractional and significant that WH proposes in the issue?

[00:03:02.0955] <Jesse>
IIRC the spec already has a notion of "significant digit" whereby `4200` has 2 significant digits (a block of trailing zeros is ignored)

[00:03:06.0944] <Jesse>
*but*

[00:03:16.0543] <Jesse>
you're right that those *could* be significant

[00:04:18.0611] <nicolo-ribaudo>
We should convert between the two using the algorithm we've always told Mark when he asked about the relationship between the two

[00:05:10.0600] <Jesse>
the proposal as it stands does allow you to stipulate that `4200` has 4 digits

[00:06:05.0397] <nicolo-ribaudo>
That seems what I expect

[00:06:10.0965] <nicolo-ribaudo>
And 4.2e2 has 2

[00:06:21.0183] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> We should convert between the two using the algorithm we've always told Mark when he asked about the relationship between the two

significant = fractional + ceil(1+ log10(value)), I think

[00:06:30.0442] <eemeli>
Added my comment to #54.

[00:07:37.0445] <Jesse>
I thnk the keep-trailing-zeros would say `4200` has 4 if I understand http://tc39.es/proposal-intl-keep-trailing-zeros/#sec-runtime-semantics-stringintlmv 

[00:07:56.0581] <nicolo-ribaudo>
Idk I studied in school that for significant digits you include all the zeros on the right of the number

[00:07:59.0596] <Jesse>
right, we can calculate one from the other

[00:08:02.0698] <eemeli>
That's what it should be doing, yes.

[00:08:08.0533] <Jesse>
well, in a certain understanding of "significant digits"

[00:08:19.0244] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> Idk I studied in school that for significant digits you include all the zeros on the right of the number

Which makes the answer for 4200 quite clear

[00:10:12.0950] <Jesse>
I think the calculation approach doesn't work well with the current "ignore tailing zeroes, including in the integer part" perspective

[00:10:38.0642] <Jesse>
because it works with the mathematical value rather than a presentation of it

[00:10:42.0220] <eemeli>
I think saying how many significant digits 4200 has is problematic, and we should only do so if we need to. So, given that we can and do calculate how many fraction digits it has, what is the need for us to calculate significant digits for it?

[00:11:27.0771] <eemeli>
If it's in order to provide information about the number, then we'd be much better off reporting `integerDigits` in addition to `fractionDigits`.

[00:11:44.0552] <Jesse>
ah, interesting suggestion

[00:13:20.0562] <eemeli>
That pair is much more absolutely calculable from the value, match each other closely, and can e.g. give an indicator of how much space is needed to represent the number, or whether e.g. exponential notation might be appropriate for it.

[00:14:06.0024] <nicolo-ribaudo>
Mh I guess yeah if the goal is formatting/interchange you don't need significant digits

[00:14:26.0564] <eemeli>
To be clear, I'm not necesarily saying we _should_ include `integerDigits`, I'm trying to provide an alternative to the one use case I'm aware of for a calculated `significantDigits`.

[00:16:02.0088] <Jesse>
I think we should have that in our back pocket as a counterproposal; I expect WH to bring this up in discussion

[01:59:33.0376] <Jesse>
I don't quite see why the current spec fails to handle 0 and -0, but if I understand https://github.com/tc39/proposal-amount/issues/54#issuecomment-3316517702 correctly, the reason why we don't handle `"NaN"` correctly is because the SDO for StringIntlMV apparently doesn't handle that string? I took a look at the grammar and AOs and SDOs like `ToNumber` and `StringNumericValue` but don't see how those produce NaN. Is that the root cause of the concern?

[02:03:11.0393] <Jesse>
Ah, I think I see what is meant: we should "handle" `"NaN"` as a failure to parse a decimal string

[02:05:01.0232] <Jesse>
it took me a while to understand this becasue we've been talking about NaN as a valid string to be handled; but it seems that , following this approach,`"NaN"` is just an invalid notation for decimal strings, just like `"xyz"` would be an invalid decimal string

[03:34:05.0439] <Jesse>
there's a bit more: https://github.com/tc39/proposal-amount/issues/54#issuecomment-3317514477

[03:35:36.0388] <Jesse>
I wonder if we might want to just remove support for significant digits in the constructor and `with`, though we could keep the significant property (it would be calculated in the constructor)

[03:36:08.0023] <Jesse>
also, given the thinking of fraction digits that allows negative values, I wonder if we should also support that in the constructor and `.with`

[05:10:04.0255] <Jesse>
https://github.com/tc39/proposal-amount/issues/64 is an attempt to settle on how we should address the issues raised by Agoric in recent TG3 calls

[06:32:14.0339] <eemeli>
I've just commented on both #54 and #64.

I'm concerned that with negative fraction digits we'd be inventing a novel way of expressing numerical precision, and that this does not match what we already have in the language in Intl.NumberFormat and Number.p.toPrecision.

[06:57:04.0509] <nicolo-ribaudo>
I gave some examples in 54. Note that Intl.NumberFormat and Number.p.toFixed (toPrecision deals with significant digits, not fractionals) do not accept negative values but also never emit exponential notation. Negative fractional digits only ever happen with exponential notation.

[06:57:12.0043] <nicolo-ribaudo>
* I gave some examples in 54. Note that Intl.NumberFormat and Number.p.toFixed (toPrecision deals with significant digits, not fractionals) do not accept negative values but also never emit exponential notation. Negative fractional digits would only ever happen with exponential notation.

[06:59:04.0098] <nicolo-ribaudo>
The PostgreSQL case is actually more interesting than the Java one, since JS more frequently interfaces with it

[07:03:20.0353] <Jesse>
I just took a look at postgres.js and see that they just handle NUMERIC as strings https://github.com/porsager/postgres?tab=readme-ov-file#numbers-bigint-numeric 

[08:44:26.0767] <sffc>
I'll be channeling the Google position during plenary, fyi. Which is basically what I said on Friday

[08:44:42.0512] <sffc>
We had some additional discussion this morning

[08:45:10.0404] <sffc>
So I think keep the slides as they have been, and the name change will come as a comment from me

[09:32:40.0272] <sffc>
Oh I thought we were still asking for Stage 2

[09:33:13.0946] <nicolo-ribaudo>
Oh well, good that Ben still called out that it is for stage 2 on the agenda and stage 2 is on the table if the contention is resolved

[09:33:25.0384] <sffc>
ok

[09:33:34.0322] <nicolo-ribaudo>
Ideally we'll have a continuation for once WH is happy with Jesse's PR

[09:53:43.0421] <nicolo-ribaudo>
Rendering of negative fractional digits should always switch to exponential, right?

[09:55:39.0927] <sffc>
yeah if we allow them that's how they would need to behave, or we could reject them (and force significant digits to always be at least as many as integer digits)

[10:01:17.0137] <sffc>
30 minutes is optimistic Ben :)

[10:01:54.0678] <nicolo-ribaudo>
Is it correct that this is how Intl behaves? https://github.com/tc39/proposal-amount/issues/54#issuecomment-3320206259

[10:03:22.0068] <sffc>
"the table from Waldemar above" => which table? there are multiple tables in his OP

[10:04:52.0615] <nicolo-ribaudo>
_significantDigits_ section

[10:04:57.0349] <Jesse>
I think he means the corrected behavior table significant digits

[10:06:04.0988] <Jesse>
I'd prefer to work in a "safe space" with this significant digits, where we "know" what to do. What do we think about allowing significant digits to be present but throw if the given string uses exponential notation?

[10:06:28.0991] <Jesse>
(actualy even there we might run into trouble)

[10:06:36.0597] <sffc>
I believe the table under "significantDigits" aligns with my expectation and understanding of how Intl.NF behaves

[10:07:18.0376] <sffc>
Where the value 0 requires its own set of special rules

[10:07:44.0257] <Jesse>
I propose using -Infinity for zero; it makes the equation work

[10:08:08.0446] <nicolo-ribaudo>
I'm fine with either Infinity or 1 + fractional

[10:08:11.0795] <nicolo-ribaudo>
* I'm fine with either -Infinity or 1 + fractional

[10:08:20.0429] <Ben Allen>
I've messaged CDA about potentially getting more time than that

[10:08:25.0524] <nicolo-ribaudo>
(assuming that 1 + fractional is what Intl does)

[10:31:56.0530] <eemeli>
Not just Intl, also: `(0).toPrecision(3) === "0.00"`.

[10:34:39.0283] <nicolo-ribaudo>
I'm going to open a PR with how I think significant digits should be done

[11:21:54.0906] <sffc>
Since we have a continuation item now, would anyone like to have a meeting to plan how to address the issues from the V8 team?

[11:22:10.0033] <sffc>
(a champions call in advance of the continuation)

[11:22:31.0077] <nicolo-ribaudo>
I'd be happy to meet at :00, or right after the TC39 meeting

[11:22:52.0169] <nicolo-ribaudo>
Actually, I'm ready in 15 min too

[11:26:05.0774] <Jesse>
I could chat too

[11:34:18.0890] <nicolo-ribaudo>
https://github.com/tc39/proposal-amount/pull/66

[11:56:50.0497] <sffc>
I put a slot for right after TC39 but can move it up if there isn't otherwise a conflict with Mathieu's work

[11:57:39.0697] <nicolo-ribaudo>
I'm taking notes but I don't actually care to be present for these topics

[11:57:58.0687] <nicolo-ribaudo>
And for Eemeli it's already very late, I'd hate asking to stay around for longer :)

[11:58:43.0411] <nicolo-ribaudo>
I'll stop taking notes after this topic

[12:04:09.0758] <Jesse>
lmk where I should go

[12:04:16.0196] <nicolo-ribaudo>
eemeli / Ben Allen ? :)

[12:04:17.0853] <Jesse>
we can use the JS numerics call

[12:05:27.0240] <eemeli>
Yeah, I'm not up for a meeting after TC 39 ends, which will be at 23:00 my time.

[12:05:35.0152] <nicolo-ribaudo>
What about now?

[12:05:39.0931] <sffc>
I'm in https://meet.google.com/rnj-tbvq-qea

[12:05:52.0579] <Jesse>
joining

[12:06:01.0406] <eemeli>
Eh, fine.

[13:11:05.0354] <nicolo-ribaudo>
A slides duel where we keep switching screen between Shane's slides and Ben's slides

[13:11:13.0310] <Ben Allen>
no thank you

[13:16:12.0524] <Jesse>
a parallel zoom call


2025-09-23
[22:05:47.0413] <sffc>
I've gotten one LGTM so far on my slides (which reiterate what I posted here earlier and what we discussed in the champions call). I like the idea of me presenting the position slides and then Ben presenting proposed solutions.


2025-09-24
[22:55:49.0320] <sffc>
Slides for the Intl MV Limit: https://docs.google.com/presentation/d/1V1BC6PtJ7-q6zVvsgKt9dcaLmIeeLnE3s8DwP4KOl7Q/edit?slide=id.p#slide=id.p

[00:44:56.0666] <eemeli>
- Slides 4-7: IntlMVs determined from bigints are not accounted for. These mean that there is not "a discrete, fixed set of MVs representable", or an upper limit to the values. For instance, this works fine: `new Intl.NumberFormat().format(2n * (10n ** 308n))`.
- Slide 6: How do you get to 20k digits with a 10k limit on significant digits?
- Slide 7 should probably mention removing the spec-mandated limits as an alternative, even if it's not preferred.

[07:28:20.0995] <sffc>
Slide 3 already says "The limit currently applies only to String, not to BigInt." I'll try to be more clear that everything that follows also applies only to String and not BigInt.

20k digits because there are 10k before the decimal point and 10k after the decimal point.

OK I'll add that alternative.

[07:32:11.0645] <eemeli>
> 20k digits because there are 10k before the decimal point and 10k after the decimal point.

... of which the fraction digits will be all zeros due to the 10k significant digit limit, no?

[07:49:55.0689] <sffc>
The significant digit limit in the PR is not 10k digits; it is up to 10k digits before the decimal separator and up to 10k digits after the decimal separator, or up to 20k total

[07:56:20.0741] <eemeli>
sffc:  Ok, I'd misunderstood the limits based on _q_ in the algorithm, and got confused by your use of "significant digits" in the slides and previously. Isn't the limit then a limit on **fraction digits** instead?

[08:14:29.0815] <ljharb>
I’m confused; why would the name “amount” imply arbitrary math, and what’s the danger of someone thinking it does for the 3 seconds before they realize they can’t?

[08:15:23.0426] <ljharb>
(also the name is a major semantic imo and should block stage 2)

[08:15:29.0718] <Jesse>
I also don't quite register that implication but I'll sympathize with the thinking, in aligment with "naming is hard"

[08:16:07.0591] <ljharb>
right but what’s the problem of someone thinking that

[08:16:15.0930] <sffc>
Temporal names weren't decided until during Stage 2

[08:16:19.0559] <ljharb>
people intuit wrong things all the time

[08:16:26.0539] <Jesse>
Eemeli reminded us that "amount" -- which was not the original name -- was chosen to align with `<amount>`

[08:16:51.0739] <ljharb>
> <@sffc:mozilla.org> Temporal names weren't decided until during Stage 2

the global “Temporal” was decided before stage 2; this isn’t within a namespace so it’s unrelated

[08:17:47.0107] <ljharb>
property names on an object aren’t a major semantic; the root container of a thing is

[08:18:40.0294] <ljharb>
> <@ljharb:matrix.org> people intuit wrong things all the time

so why does it matter if a few people intuit the wrong thing? 

[08:20:20.0205] <Jesse>
my hope is that aligning with `<amount>` helps here because `<amount>` is also just basically a container

[08:24:02.0063] <ljharb>
also i do not understand why we'd remove tonumber and tobigint; you can already put the string into the constructors so why make it much less ergonomic and much more likely to be done incorrectly?

[08:33:38.0018] <nicolo-ribaudo>
eemeli I can't get on the queue right after you, but an interchange example is PostgreSQL. It supports "number with X fractional digits" column types, and a generic adapter can only represent it as an amount

[08:33:42.0923] <nicolo-ribaudo>
Then user code decides how to interpret it

[08:33:57.0598] <nicolo-ribaudo>
Just in case you want to mention it

[08:39:04.0627] <Richard Gibson>
more precisely, number with total digit count X with a fixed relationship to the decimal point: https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-NUMERIC-DECIMAL

[08:57:27.0853] <eemeli>
Should we ask for Stage 2?

[09:01:17.0719] <sffc>
In a continuation

[09:01:54.0369] <ljharb>
have we been listening to the same topic?

[09:02:13.0873] <nicolo-ribaudo>
Do we think a continuation is going to help convincing more people? The only thing that I think we could still explore is showing how annoying math is to the V8 team, even with toNumber()

[09:02:59.0191] <ljharb>
multiple delegates have expressed that they're unconvinced this is better than "an object shape", and i've indicated that the root name is a major semantic blocking stage 2

[09:05:21.0172] <Jesse>
I got the impression that the name isn't much of an issue; that is, the idea of renaming wouldn't be a solution

[09:05:32.0065] <nicolo-ribaudo>
I think we should present again the unit conversions proposal, asking:

- do we want this
- if so, where would we put it

[09:06:05.0618] <nicolo-ribaudo>
Because that answers:
- why not just a protocol
- why not in Intl

And I was hoping that plain Amount is sufficiently self-motivated

[09:06:16.0881] <nicolo-ribaudo>
But that would show why you need _something_ to attach things on

[09:26:33.0984] <sffc>
I think there's still headroom to get an understanding between the V8 position and the Jordan position

[10:43:01.0817] <sffc>
My read of the room is that V8 is the only stakeholder who doesn't agree with the name Amount. Is that right?

[10:43:48.0573] <Ben Allen>
That appears to be correct

[10:46:50.0221] <sffc>
Ok so putting the name aside, V8 _seems_ okay with Amount as proposed if it has only toString, resulting in code such as `Number.parseFloat(amount.toString())` if someone wanted to make it into a Number. (Number.parseFloat conveniently appears to ignores annotations)

[10:48:10.0825] <sffc>
Besides trying to address V8's position, I think this is _better than_ Amount.prototype.toNumber() because it makes it explicit that rounding/truncation might happen

[10:57:22.0405] <sffc>
Also, my read of the last 20 minutes of discussion is that there's risk to introducing a protocol _without_ introducing a primordial, as we learned with Iterator. Is that right? Does that address Kevin's concern, or does he still prefer the protocol-only approach?

[11:04:48.0090] <sffc>
This proposal is getting to the point where it may appear to some like we're flailing and wasting committee time, but every time we engage in discussion, we _are_ making progress. It's just a really hard problem to solve.\

[11:04:48.0331] <Jesse>
that's also my read of the situation

[11:05:35.0784] <Jesse>
but it's phrased in such a way that I'm not confident that he'd be *ok* with a primordial

[11:07:30.0339] <nicolo-ribaudo>
What's our plan for unit conversion methods? Because if we want those on the prototype, that might be something to convince Kevin that we shouldn't do the protocol-only approach now

[11:08:00.0532] <Jesse>
I thought there some examples in the old measure slides & README

[11:08:40.0910] <Jesse>
like `new Amount("123.456", { unit: "km" }).convetTo("mile")` IIRC?

[11:09:19.0319] <nicolo-ribaudo>
I guess? But we have to be careful also to not imply "this proposal is motivated by a future proposal"

[11:09:33.0743] <Jesse>
I thought one skinny version of that involved just SI units (hence no "mile", etc.)

[11:09:41.0331] <Jesse>
right

[11:10:13.0500] <nicolo-ribaudo>
How's the current plenary topic going? Unfortunately it's going to be a little bit still until when I'm back

[11:10:26.0452] <Jesse>
typical security discussions: going long

[11:10:26.0675] <Ben Allen>
it seems like it'll be going for a while

[11:18:19.0400] <eemeli>
One way to motivate a reified Amount with unit conversion would be to propose `usage` as an Intl.NumberFormat c'tor option. In a separate proposal, mind.

[11:18:55.0998] <eemeli>
I.e. the Intl part of Smart Units.

[11:23:34.0663] <ljharb>
v8 hasn't made it clear why the name Amount is actually a problem btw - iow, what is the risk they see in someone having incorrect expectations that are immediately disproven when they interact with the api?

[11:24:50.0206] <eemeli>
I understood the concern to be that Amount starts a slippery slope to new arithmetic.

[11:25:20.0284] <ljharb>
"slippery slope" is also the most well-known logical fallacy, so i'd hope they have a better leg to stand on

[11:34:50.0719] <Jesse>
in a world with both Amount and Decimal, I would hope that programmers who might *think* they want arithmetic on Amount would discover arithmetic on Decimal, which I imagine is probably what they're looking for in most cases

[11:37:27.0130] <sffc>
Here's a comment that might clarify:
> one concern with Amount is that it's somewhat overly generic, as evidenced by the observation that people have all sorts of expectations of what an Amount type should be able to do. For example, you have to explicitly tell them that Smart Units is a separate proposal. This is relevant because at the same time there are concerns that some of these expected use cases have questionable value and/or feasibility. So one way to decrease resistance is to make it clearer what the proposal is about by making the name more specific. And one of several ways of making it more specific is to make it at least hint at the use case. (I'm not saying that's the only or the best way; in fact perhaps NumberWithUnit would be preferable precisely because it's more neutral, more just-the-facts; OTOH it doesn't include the precision which IIUC is a big part of what motivates you personally to pursue this, and NumberWithUnitAndPrecision is getting rather unwieldy.)

[11:37:37.0131] <ljharb>
and they'd just `.toDecimal()` and do the math anyways, in that world

[11:38:10.0554] <ljharb>
but what is the *concrete damage* feared from it being overly generic?

[11:38:23.0452] <ljharb>
iow, ok, some people might have wrong expectations. why should i care about that?

[11:39:30.0165] <ljharb>
there's lots of things people expect to be able to do and then are sad to find out they can't or shouldn't. as long as that's not the majority, that's _fine_

[11:39:47.0118] <ljharb>
* there's lots of things people expect to be able to do and then are sad to find out they can't or shouldn't. as long as that's not the majority, that's _fine_. and if they want to be able to do it, or to "should" do it, then that's what new proposals are for

[11:40:29.0997] <Jesse>
well, we *did* start with "Measure", which is (imo) a good suggestive name

[11:44:42.0000] <sffc>
The position as I understand it is that it's good language design to lead people in the right direction and bad language design to mislead people.

[11:48:33.0918] <Jesse>
in the Prior Art issue it looks like "quantity" occurs pretty frequently

[11:49:32.0126] <Jesse>
maybe we could embrace the concern about "arbitraryt math" and say sure, we might end up doing a linear transformation (a*x + b) from one amount to another, but that's it

[11:49:32.0584] <eemeli>
If we do want to emphasize that this isn't meant for arithmetic, we should just call it Intl.Amount.

[11:49:39.0440] <Jesse>
(thninking ahead to unit conversion)

[11:51:30.0015] <nicolo-ribaudo>
I understand API misleading people, but "Amount" doesn't tell me "math" more than any of the other names (even NumberWithUnit) do

[11:52:39.0314] <sffc>
I agree, but there's at least one person on the V8 team who think that Amount does imply more. It might be something we can iterate on offline.

[11:53:15.0491] <nicolo-ribaudo>
I would actually say that anything that contains Number or similar in the name makes me think more of math

[11:53:27.0729] <eemeli>
Btw, I've generated a concern for myself about the meaning of this:
```
let nf = new Intl.NumberFormat('en', { style: 'percent' })
nf.format(new Amount(0.1234, { fractionDigits: 2 }))
nf.format({ value: 0.1234, fractionDigits: 2 })
```
should either/both of those format as `12%` or `12.34%`? If we consider an object protocol, that is.

[11:53:29.0060] <Jesse>
concretely, could we just iterate on a list? We did present that in the 1st continuation today is the name issue

[11:53:46.0473] <Jesse>
(I guess that's probably a good thing -- opportunity for endless bikeshedding)

[11:53:58.0392] <nicolo-ribaudo>
> <@eemeli:mozilla.org> Btw, I've generated a concern for myself about the meaning of this:
> ```
> let nf = new Intl.NumberFormat('en', { style: 'percent' })
> nf.format(new Amount(0.1234, { fractionDigits: 2 }))
> nf.format({ value: 0.1234, fractionDigits: 2 })
> ```
> should either/both of those format as `12%` or `12.34%`? If we consider an object protocol, that is.

I'd say 12%

[11:56:18.0914] <ljharb>
i agree. but i think that the vast majority of people won't be misled here.

[11:56:38.0150] <ljharb>
then it's not meant for non-intl use cases, which is inaccurate.

[11:57:07.0705] <ljharb>
right but there will always be nonzero people who have incorrect expectations. that's notable but shouldn't ever force a rename

[11:57:53.0740] <ljharb>
iow just with our sample size of 100ish, it sounds like only 1-2 people might have the incorrect expectation here, and that seems perfectly acceptable to me

[11:58:11.0243] <ljharb>
* iow just with our sample size of 100ish, it sounds like only 1-2 people might have the incorrect expectation here, and that seems perfectly acceptable to me, esp when there's no equally good alternative

[12:06:04.0307] <eemeli>
The challenge with the object protocol form at least is that this is what we have now:
```
let nf = new Intl.NumberFormat('en', { style: 'percent', maximumFractionDigits: 2 })
nf.format(0.1234)
```
results in `12.34%`.

[12:19:05.0042] <sffc>
Ben Allen or Jesse, it would be productive if you could scrub the notes as well as the matrix to identify a comprehensive list of delegates who had opinions one way or another about the proposal so that we can have an action plan to get alignment before the next meeting.

[12:20:46.0514] <sffc>
The goal should be to not return to plenary until we have out-of-band +1s from every organization with delegates who have opinions on the proposal.

[12:21:30.0883] <sffc>
I remain cautiously optimistic that there's still light at the end of the tunnel, but it will take time and creativity.

[12:22:41.0765] <Jesse>
agree

[12:23:16.0044] <Jesse>
it seems that the name is a real (mental) blocker for some; I propose creating an issue about that

[12:23:30.0702] <Jesse>
it would be great to spread that issue around

[12:24:40.0776] <Jesse>
there's also the issue of converters to Number and BigInt

[12:25:47.0292] <ljharb>
i think a container for stuff must provide a way to extract each item independently 

[12:26:02.0679] <eemeli>
Eh, conversion via string works fine esp. if the Amount has no unit. And if it might, user code will need to deal with that.

[12:26:06.0225] <ljharb>
if it's parsing from a string, nobody should ever have to replicate that parsing logic outside of a polyfill

[12:26:16.0197] <eemeli>
As in, `Number(amount)` and `BigInt(amount)`.

[12:26:19.0992] <ljharb>
* if it's parsing from a string, nobody should ever have to replicate that parsing logic outside of a polyfill - that'd be a recipe for disaster

[12:26:30.0002] <ljharb>
right but "stripping off the unit" is a problem, for bigint at least

[12:26:55.0449] <ljharb>
(and it's pretty obvious that `new Amount(3.5).toBigInt() === 3n`)

[12:26:57.0194] <eemeli>
`Number('1[kilogram]')` also fails.

[12:27:03.0297] <Jesse>
I can also put a Temporal-style coobook together

[12:27:09.0628] <ljharb>
true, but there's parseFloat too. there's no parseBigInt tho

[12:27:11.0782] <Jesse>
it wouldn't be nearly as big as Temporal's but it might help

[12:27:49.0989] <Jesse>
oh, interesting to hear that intuition -- atm that would throw (because it's not an integer)

[12:28:16.0739] <Jesse>
like rounding beforehand to make it into an integer

[12:28:52.0408] <ljharb>
i mean i could do something convoluted like "with zero fractional digits" first but it's pretty silly to make me jump through that hoop

[12:29:11.0827] <ljharb>
converting any numeric to a bigint obviously will drop the fractional part (assuming it doesn't throw)

[12:29:22.0733] <ljharb>
just because bigint made a bunch of user-harmful decisions wrt throwing doesn't mean the rest of the language has to

[12:29:57.0164] <Jesse>
the spec at the moment reflects the intuition that 3.5 would throw for the same reason that `BigInt("3.5")` throws

[12:31:21.0257] <Jesse>
these could even be cookbook item: "how to convert an Amount to a Number"; "how to convert an Amount to a BigInt"

[12:33:28.0137] <ljharb>
i really don't think we should use bigint as a precedent

[12:33:48.0350] <ljharb>
and altho that's not the hill i'll die on, i think there should be conversion methods regardless

[12:34:41.0501] <Jesse>
tbh I don't quite follow the thinking that says "if we have toNumber() this is a slippery slope to people doing math". I'm playing devil's advocate and trying to get into their shoes

[12:35:54.0315] <Jesse>
I thnk that comment was even packaged as a comment almost about decimal, not about amount as such

[12:36:01.0535] <eemeli>
Thinking of a protocol-only approach, that too should include a way to assign precision relating to the numerical value, rather than its formatted representation. Which is probably best done via a digit string representation. So that leads to something like `Math.stringify()` that would take a value and a bag of options that would look very much like the planned Amount options bag.

[12:36:03.0951] <Jesse>
but I would need to go back to the notes

[12:37:31.0735] <eemeli>
I'm going to need to firm up my thoughts a bit, but I'm starting to think that we ought to drop the `.fractionDigits` and `.significantDigits` accessors.

[12:37:43.0355] <eemeli>
* I'm going to need to firm up my thoughts a bit, but I'm starting to think that we ought to drop the `.fractionDigits` and `.significantDigits` accessors from Amount.

[12:38:30.0582] <ljharb>
again, if it's a container for a thing, it must provide access to each of those things

[12:38:43.0503] <ljharb>
so i don't think the accessor can be dropped without dropping the concept

[12:38:46.0093] <eemeli>
If this did result in a BigInt value, why would it be `3n` and not `4n`?

[12:39:07.0531] <ljharb>
ha, ok true, typical JS rounding would have that be 4n

[12:39:17.0978] <ljharb>
pretend i said 3.4 :-p

[12:39:19.0195] <Jesse>
in certain moments we talk about Amounts being opaque 

[12:39:26.0726] <eemeli>
The digit counters aren't things that are contained, but modifiers for the value.

[12:39:53.0852] <eemeli>
Or at least that's one potential approach.

[12:39:55.0126] <ljharb>
if it's being stored internally as state, there needs to be a way to read that state (and "parse a string" doesn't count)

[12:40:07.0484] <sffc>
I think `new Amount(3.5).toBigInt()` should throw and if you want to guarantee that it's safe you should `new Amount(3.5).withFractionDigits(0, { roundingMode: "trunc" }).toBigInt()`

[12:40:35.0376] <ljharb>
fwiw i think that'd be unfortunate but acceptable

[12:40:52.0727] <eemeli>
Or maybe even `new Amount(Math.round(3.5)).toBigInt()`.

[12:41:16.0081] <sffc>
Or `new Amount(3.5).toBigInt({ roundingMode: "trunc" })`

[12:43:02.0428] <eemeli>
From the Intl.NumberFormat PoV, the only precision indicator we need is something that indicates how many trailing zeros the value has.

[12:43:27.0870] <Jesse>
right the thinking for transformers is that we want to ensure that the thing in the domain belongs to the range, without preprocessing

[12:43:44.0167] <Jesse>
so in this case it was: if it isn't an integer, toBigInt ought to throw

[12:43:56.0233] <eemeli>
Do we have an explicit use case expressed somewhere for another precision consumer? Preferably with example code.

[12:44:45.0119] <eemeli>
If we don't, then we don't have a use case for `.fractionDigits` or `.significantDigits`.

[12:46:18.0481] <Jesse>
hmm but what about the "don't use internal slots in Intl.NF" concern? There were two ways out of that (1) use properties/accessors instead (i.e., solve it via duck typing), (2) call "toString" and do some lightweight parsing

[12:47:06.0531] <eemeli>
Not an issue, because `new Amount(3.5, { significantDigits: 4 }).toString()` is `'3.500'`.

[12:47:46.0854] <eemeli>
Intl.NF will only want the stringified value of the Amount.

[12:48:10.0486] <Jesse>
do we support killing the amount? like `new Amount(42, { unit: "miles" }).with({unit: undefined})`

[12:48:23.0891] <Jesse>
sorry unit

[12:48:31.0583] <eemeli>
That currently throws, and should continue to do so.

[12:50:51.0069] <ljharb>
every use case that uses the string is a use case for those parts, assuming they show up in it

[12:51:22.0877] <ljharb>
if the constructor parses a string, nobody else should ever have to replicate the parsing logic, which means *all* meaningful tokens must be separately accessible

[12:52:33.0035] <eemeli>
Do any of the pre-existing numerical value parsers in JS do that?

[12:53:00.0503] <ljharb>
i mean, the only meaningful part is the number itself

[12:53:32.0188] <ljharb>
but there really isn't a preexisting similar case here imo, something that's meant to parse a string or take individual parts, and be a container for the parts

[12:55:02.0357] <eemeli>
I think Amount is more about emitting a string, rather than parsing one.

[12:59:07.0828] <Jesse>
one use case I can imagine for exposing fraction/significant digits would be reading in a value from a DB that uses a numeric schema  I don't know (like, I don't know how many significant/fraction digits they use out-of-band). I make an amount from that value (or values), do some calculation, and can then make an amount based on the result of the calculation, passing along a suitable `{ fractiondigits: originalAmount.fractionDigits }`

[12:59:48.0559] <Jesse>
(if I know that info out-of-band, I can probably just do `computedValue.toFixed(5)` for example)

[13:02:15.0268] <Jesse>
I don't quite remember why we decided to expose that information, though; IIRC for a long time we were thinking of amounts as opaque, iow (as I understood it) providing essentially only `toString` and `with`

[13:05:08.0661] <Jesse>
it might have been the thinking that ljharb is following, along the lines of: if we think of this as a container, we should expose the component parts

[13:05:30.0133] <Jesse>
(not saying you're the originator of this argument ljharb)

[13:06:22.0095] <ljharb>
then it should just be a function that returns a string?

[13:06:44.0912] <ljharb>
* then it should just be a function that returns a string? the builtin can be a function that returns a function that takes options and returns a string.

[13:07:36.0245] <Jesse>
wow, we're getting functional up in here!

[13:08:13.0035] <eemeli>
ljharb: That's pretty much what I meant with this comment.

[13:09:25.0658] <ljharb>
don't get me wrong, i prefer an Amount instance, it's more idiomatic and natural

[13:11:21.0231] <eemeli>
And it makes including a unit much more convenient.

[13:13:03.0705] <eemeli>
As well as being a better platform for future unit conversion work.

[13:32:47.0162] <sffc>
I think the V8 team will have a visceral reaction to "just use a string" but that might be productive as it motivates the primordial 

[13:43:41.0545] <ljharb>
i mean imo either it's just a string, or a thunk factory for a string, or a proper class instance named Amount

[13:52:34.0116] <Richard Gibson>
you don't think the Temporal.$type.from functions fit that description?

[13:52:49.0162] <ljharb>
oh yeah maybe so

[13:53:01.0424] <ljharb>
and presumably basically everything they parse is accessible?

[13:53:20.0132] <Richard Gibson>
at least to a first approximation, yes

[13:54:10.0724] <Richard Gibson>
but they don't expose the difference between e.g. UTC offset `-05` vs `-05:00`

[14:37:24.0746] <ljharb>
sure, in that case precision isn't important and neither case has different semantics, right?

[14:38:22.0266] <sffc>
yeah, I care a lot about precision but in this case they are representing a UTC Offset and ISO _defines_ that `-05` and `-05:00` are exactly equivalent

