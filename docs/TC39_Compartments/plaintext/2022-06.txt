2022-06-06
[21:18:13.0183] <Kris Kowal>
Thank you ljharb for creating this space and welcome interested parties in module loader virtualization. I‚Äôve invited as many handles as I could recognize at a glance and I will try to gather the missing champions and collaborators.

[21:24:03.0794] <Kris Kowal>
By wave of an update, I‚Äôm working with the champion group to narrow the focus of the Compartments proposal to just module loader virtualization https://github.com/tc39/proposal-compartments/pull/46

[21:26:15.0964] <Kris Kowal>
Specifically in order to present the narrowest profile to the wind. There‚Äôs enough interest in the topic and two years of experience vetting the Compartments proposal (stage 1) that it‚Äôs time to push for 2.

[21:27:46.0767] <Kris Kowal>
By which I mean I hope to present on behalf of champions and collaborators, not at this plenary, but the next one in July, resources and alignment willing.

[21:31:28.0179] <Kris Kowal>
I invite Luca Casonato and guybedford (Guy Bedford) specifically because of our mutual interest. Talking with Guy yesterday, there‚Äôs substantial overlap between the problems that import reflection seeks to solve https://github.com/tc39/proposal-import-reflection, and the solutions that Compartments provide. And, Compartments I believe solve those problems without needing new syntax (relitigating the original import assertions proposal (import as)), relaxing idempotent import, or complicating cache keys.

[21:36:03.0402] <Kris Kowal>
I invite Surma because I believe the Compartments design can help inform the conversation about module blocks. One of our goals with Compartments is to create a clear distinction between a StaticModuleRecord and a ModuleDescriptor, which 262 currently conflates. Separating those concerns makes clear to me at least that we should choose whether a module block is re√Øfied as a StaticModuleRecord or a ModuleDescriptor, the latter containing the former. If a block is a StaticModuleRecord, that suggests easy portability between workers but doesn‚Äôt imply a full module specifier or module metadata.

[21:37:03.0559] <Kris Kowal>
The Compartments API also cleanly separates module specifier namespaces from module metadata, since we find that import.meta.url in particular must be a host-specific extension, and must be omissible in some hosts.

[21:37:43.0412] <Kris Kowal>
I think that position also clarifies our feelings about some of the design tensions we see in module blocks and look forward to discussing that.

[21:40:55.0474] <Kris Kowal>
My hope is to recruit you all to our common cause üôÇ


2022-06-07
[21:29:01.0191] <Jack Works>
Hello ~

[21:53:50.0131] <Jack Works>
In the [current](https://github.com/tc39/proposal-compartments/blob/6a180313515f6faec2818dad229e6921109b50f5/README.md) `ThirdPartyStaticModuleRecord` API, the initialize function only receives a `ModuleEnvironmentRecord` (which looks like only containing `import` and `export` bindings). There is no way to access the `globalThis` of the current executing compartment.

Lacking this ability make it impossible to compile a ES Module into a `ThirdPartyStaticModuleRecord`.

[22:17:54.0323] <Kris Kowal>
For folks tuning in, Jack is trying to build a no-eval shim for Compartments that precompiles ESM into a bundle.

[22:18:25.0948] <Kris Kowal>
I assume you‚Äôre aware that third-party static-module-records can‚Äôt emulate live bindings.

[22:19:30.0107] <Kris Kowal>
Jack Works: Have you looked at https://github.com/endojs/endo/blob/master/packages/compartment-mapper/src/bundle.js

[22:20:06.0187] <Kris Kowal>
That uses the SES shim‚Äôs static module record to create a bundle. It‚Äôs not a complete implementation, but it might be similar to your approach.

[22:20:07.0298] <Jack Works>
> <@kriskowal:matrix.org> I assume you‚Äôre aware that third-party static-module-records can‚Äôt emulate live bindings.

I'm aware that it cannot get the globalThis of the current compartment (it didn't pass as an argument in the initialize function)

[22:21:41.0513] <Kris Kowal>
Yes. My point was tangential to that concern.

[22:21:57.0796] <Kris Kowal>
I imagine we could thread globalThis into the initialize options bag.

[22:22:33.0092] <Kris Kowal>
I‚Äôm not entirely sure why it‚Äôs necessary for your implementation.

[22:22:58.0425] <Jack Works>
For example, I write `Math`.

[22:22:58.0894] <Kris Kowal>
Oh, I see.

[22:23:16.0079] <Jack Works>
I need to look it up in the current compartment's globalThis 

[22:23:35.0453] <Kris Kowal>
Thanks, I understand. The crux of the issue is that static module records must be reusable between compartments, and the global environment varies from initialization to initialization.

[22:23:39.0104] <Jack Works>
And those unresolved global variable lookup should be per-compartment

[22:23:51.0651] <Kris Kowal>
So, indeed, we should thread globalThis into the initializer.

[22:25:11.0417] <Jack Works>
I previously understand ModuleRecordEnvironment as "an exotic object that is a reification of 'lexical scope(import export bindings) and dynamic scope (globalThis)" 

[22:25:43.0491] <Jack Works>
But you just clarified that Module environment record does not contain globalThis so I need a new mechanism for this

[22:26:25.0809] <Kris Kowal>
That is certainly a reasonable design and I‚Äôm open to entertaining the idea still. I will make a point to ask Moddable for a clarification about what they did in XS.

[22:27:27.0190] <Kris Kowal>
But otherwise, whether or not to have module environment record capture global environment record is something we will want engine vendors to motivate.

[22:32:39.0222] <Kris Kowal>
Oh, module environment record *mustn‚Äôt* capture global environment record, because that includes top-level declarations of Script eval. Modules aren‚Äôt supposed to see those.

[22:33:24.0040] <Kris Kowal>
So either module environment record needs to fall through to properties of globalThis, or we need to thread globalThis into the module initializer.

[22:33:55.0951] <Kris Kowal>
Again, either way is fine with me.

[22:34:10.0968] <Kris Kowal>
And I‚Äôll make a note in the proposal README refresh PR.

[22:34:11.0275] <Jack Works>
Aren't decls created in Script either eval-by-eval or on globalThis? 

[22:34:21.0744] <Jack Works>
* Aren't decls created in Script either eval-by-eval or on globalThis? 

[22:34:38.0450] <Kris Kowal>
Yes, that‚Äôs true most of the time. 262 does not currently specify the behavior of REPLs.

[22:34:49.0809] <Kris Kowal>
But REPLs persist the ‚Äúglobal contour‚Äù between evals.

[22:35:33.0686] <Jack Works>
Oh I didn't notice REPLs. Does that specified in the language? I thought it was made by implementation for debugging 

[22:35:48.0048] <Kris Kowal>
That‚Äôs not something I hope to address in Draft 1 but expressly supporting the REPL case in the language would be an obvious thing to add to Compartment.

[22:35:57.0945] <Kris Kowal>
It‚Äôs not specified in the language.

[22:38:48.0368] <Jack Works>
I'm ok with either, but in a normal ES module, if you import x, then you no longer be able to refer to the global x (globalThis.x is not a direct refer). So if we want to have binding shallow behavior, or you still want to have globalLexicals in the API, I guess making it all in one object will be easier. 

[22:42:32.0982] <Kris Kowal>
globalLexicals would be analogous to globalContour. The former applies to modules only, the latter to scripts only. I haven‚Äôt added globalLexicals to the proposal yet, and might not until we discuss the layering of Lockdown. globalLexicals have a very limited use, and we found a way to avoid it for now at Agoric. That is, metering guest code.

[22:44:09.0232] <Kris Kowal>
But your hint is good. If we did have globalLexicals, having the module environment record reflect the entire top of stack would be more desirable.

[22:45:21.0284] <Kris Kowal>
I think that convinces me that we should put the burden on the module environment record.

[09:21:57.0126] <Kris Kowal>
(Aside: Moddable‚Äôs invention of ‚Äúmodule descriptors‚Äù is truly wonderful in simplifying the Compartment API. We‚Äôve been able to remove the `compartment.module` method and the `moduleMapHook`.)

