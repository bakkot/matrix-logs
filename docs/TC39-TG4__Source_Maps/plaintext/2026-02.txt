2026-02-02
[09:07:06.0015] <Caio Lima>
Holger Benl: I'm taking a look at your branch there and I'm wondering what do you consider it mostly hack there. Is it because it is doing an additional pass on each original and another on generated AST to get scopes info, or is there anything else?

[09:07:42.0491] <Caio Lima>
* Holger Benl: I'm taking a look at your branch for scopes on Terser there and I'm wondering what do you consider it mostly hack there. Is it because it is doing an additional pass on each original and another on generated AST to get scopes info, or is there anything else?

[09:09:31.0844] <Caio Lima>
I'm wondering here if it's possible to embed original scopes while traversing for parsing and generated scopes when traversing for optimizing/printing, but I particularly like that it's a separated pass.

[09:41:54.0239] <Holger Benl>
I called it a hack because my changes were very ad-hoc, I was just looking at a couple of simple examples and adding fixes to make them work, without really trying to fully understand how terser works and how to best fit this feature into its architecture. For many of these fixes (especially how the original locations attached to the AST nodes are handled while terser transforms the code) I am not sure if they're correct in all situations.

[09:45:50.0491] <Holger Benl>
* I called it a hack because my changes were very ad-hoc, I was just looking at a couple of simple examples and adding fixes to make them work, without really trying to fully understand how terser works and how to best fit this feature into its architecture. For many of these fixes (especially how the original locations attached to the AST nodes and information about original names are handled while terser transforms the code) I am not sure if they're correct in all situations.

[09:47:20.0526] <Holger Benl>
* I called it a hack because my changes were very ad-hoc, I was just looking at a couple of simple examples and adding fixes to make them work, without really trying to fully understand how terser works and how to best fit this feature into its architecture. For many of these fixes (especially how the original locations attached to the AST nodes are handled and how the original names are tracked while terser transforms the code) I am not sure if they're correct in all situations.


2026-02-11
[09:00:55.0786] <asumu>
Hi folks, TG4 meeting starting now!


2026-02-12
[09:53:25.0243] <Chris de Almeida>
Hi there.  Who are the current editors of the spec?  Only Asumu is listed on the HTML version, but Jon and Nicolo are listed in addition on Ecma's PDF version.

[09:54:19.0553] <Nic>
It's Asumu right now, we had all of the names because of the original conversion work of getting the spec into Ecma


2026-02-26
[05:31:06.0751] <Caio Lima>
Hey all, I'm taking a look into inlining and scopes for generated code, and I got a bit confused with this example: https://github.com/hbenl/tc39-proposal-scope-mapping/blob/master/test/getOriginalFrames/inline-into-function.test.ts. There we have a call chain of toplevel -> outer -> inner -> log. My confusion is that with the ranges we are using for the scope in this test, we skip inner fully. Which means that if we place a bp on line 3 (first line of log), the stack will have something like log <-outer<-toplevel. Was it intentional to skip inner there?

[05:37:36.0620] <Holger Benl>
I don't think we're skipping inner: the ranges contain two callsites (for inner and log) and getOriginalFrames() does contain a frame for inner: https://github.com/hbenl/tc39-proposal-scope-mapping/blob/50d3c7b7c52a1876100867925f2038b94e04ef31/test/getOriginalFrames/inline-into-function.test.ts#L244-L249

[05:39:57.0613] <Holger Benl>
Or do you mean the input for getOriginalFrames()? That only contains one frame but the test shows that getOriginalFrames() will recreate the frames for inner and log from that.

[08:59:37.0070] <asumu>
Hi folks, scopes meeting is starting soon!

[09:23:53.0558] <Simon Zünd>
https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/core/sdk/SourceMapScopesInfo.ts;l=529;drc=0832f0943d8cf75120726045afeea11c577f1ab9

[09:23:59.0481] <Simon Zünd>
This is the Chrome Impl

[09:25:32.0711] <Caio Lima>
```
const CALL_CHANCE = 0.5;

function log(x) {
  console.log(x);
}

function inner(x) {
  log(x);
}

function outer(x) {
  const shouldCall = Math.random() < CALL_CHANCE;
  console.log('Do we log?', shouldCall);
  if (shouldCall) {
    inner(x);
  }
}

outer(42);
outer(null);
```

[09:42:08.0495] <Caio Lima>
As we talked in the meeting, I was just reeding the test wrongly.

[09:49:05.0609] <Caio Lima>
Oh, I figured out what confused me there. It's because in this example I as running https://szuend.github.io/scope-proposal-examples/04_inline_into_function/inline_into_function.html, the source map is with the old version where it has "originalScopes", and "generatedRanges" keys, instead of having it inside "scopes".

[09:49:39.0810] <Caio Lima>
That's why when I run on Chrome dev tools, I get 2 anonymous frames, instead of the expected stack frame.

