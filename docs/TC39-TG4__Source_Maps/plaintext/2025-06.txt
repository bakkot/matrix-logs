2025-06-05
[00:01:40.0537] <Rob Palmer>
In the current sourcemap spec, for the specific case of an inline sourcemap (embedded in the executable JS via Base64 for example), is there a way to reference the current file without knowing it's name? 

[00:02:09.0196] <Rob Palmer>
Specifically I wonder if "file" or "sources" can use the value "."

[00:03:24.0868] <Rob Palmer>
* In the current sourcemap spec, for the specific case of an inline sourcemap (embedded in the executable JS via Base64 for example), is there a way to reference the current file without knowing its name? 

[00:07:00.0183] <Nic>
No. The meaning of the "file" field is currently left up to whoever is using the source map.
 
If I were to implement it "." wouldn't work, because I would resolve it as `new URL(".", generatedFile)` which would strip the last segment from the generated file URL. However, `new URL("", generatedFile)` returns generatedFile, so maybe "" works. But it's unspecified.

[00:08:29.0931] <Nic>
For sources that might actually work, because we define URL resolution for them

[00:08:51.0975] <Rob Palmer>
The spec seems to indicate URLs are permitted for both fields. 

[00:09:07.0038] <Rob Palmer>
Ah

[00:09:10.0545] <Rob Palmer>
You are right

[00:10:12.0045] <Rob Palmer>
Do you think we could enhance the spec to formalise the empty string as a self-reference? 

[00:10:31.0548] <Rob Palmer>
(at least for the case of an inline sourcemap) 

[00:12:06.0049] <Nic>
I need to double check for the current spec for sources actually implies that "" works, and if it does we can just add a note

[00:12:29.0623] <Rob Palmer>
That would be excellent! 

[00:12:36.0273] <Nic>
For file, it might be more difficult because I fear that the reason it's currently unspecified is that we don't know how tools use it, or worse that they disagree

[00:15:47.0973] <Rob Palmer>
If it is not possible to enhance/strengthen "file", my next question will be: what is the smallest change we can make to the spec to permit the inline use-case to reference itself for both field? (with some kind of constant rather than needing to vary based on knowledge of the filename) 

[00:17:30.0975] <Rob Palmer>
The specific use-case is type-stripping runtimes that execute *.ts files directly, but need to provide an inline comment to inform debuggers that there has been no change of filename, to appease the debugger. 

[00:18:44.0680] <Rob Palmer>
Whilst this can be achieved by injecting the filename, this is wasteful and turns what could be an easily understandable constant into a mysterious ever-changing Base64 that varies from file to file.


2025-06-06
[03:16:51.0928] <Chengzhong Wu>
Any plans to update https://sourcemaps.info/spec.html to link to https://tc39.es/ecma426/?

[04:37:46.0333] <jkup>
I made a PR https://github.com/bugsnag/sourcemaps.info/pull/6

[04:37:58.0592] <jkup>
Repo looks quite old, I'll give it a few weeks and then maybe try to find the owner on socials?


2025-06-11
[01:30:56.0677] <Shumaf Lovpache>
Hi everyone. My team recently discovered an interesting technique used by React Server components.

The React Server components machinery (in particular [react-client](https://github.com/facebook/react/tree/main/packages/react-client)) creates fake scripts with the same source map as a real user code to preserve source mapped traces in the browser. It allows recreating the top stack frame of the server code on the client preserving mapping to the original source code.

Consider an example ([github repo](https://github.com/Soarex16/next-15-server-components-reproduction-app)):

```js
export default function Home() {
  console.log('Home');
  return <div>
    <main>
      <h1>Header</h1>
      Some text
    </main>
    <footer>Footer</footer>
  </div>;
}
```

If you open this example in a browser, it will print to console the following message (first picture)
And clicking to “page.tsx:3” points to the original source (second picture).

From the user perspective, it’s a really neat feature, but unfortunately, this technique confuses js debuggers ([issue on GH](https://github.com/vercel/next.js/issues/77733)). This happens because debuggers think that this piece of code was bundled in different places multiple times.

So when the user put a breakpoint, the debugger put breakpoints in all these fake scripts causing redundant breaks.

Here is an example of one of the scripts:

```js
/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */

({"Home":_=>

        _()})

//# sourceURL=rsc://React/Server/webpack-internal:///(rsc)/./app/page.tsx?0

//# sourceMappingURL=http://localhost:3000/__nextjs_source-map?filename=webpack-internal%3A%2F%2F%2F%28rsc%29%2F.%2Fapp%2Fpage.tsx
```

We have several options for solving this problem, and all of them require coordination between debuggers and frameworks. Since it affects all major debuggers – Chrome DevTools, WebStorm, VS Code, I’m asking for your feedback as a starting point for discussion with the community.  
Here they are:

* Use some heuristics (like matching file structure, comments, etc.) to detect fake scripts that don't need breakpoints. This approach is unreliable and can easily break if React changes scripts structure in the future.  
* Use some comment similar to \# sourceMappingURL to indicate that this file should be skipped by the debugger  
* For fake scripts generate source maps with some extra field (like ignoreList but for generated code):

```json
{
  "version" : 3,
  "file": "out.js",
  "ignored": true,
  rest of the source map ...
}
```

[01:49:36.0490] <Simon Zünd>
Not sure I fully follow, why are the fake scripts needed? Is it because due to the server rendering no JS would actually run on the browser-side?

