<!DOCTYPE html><html><head>
  <meta charset="UTF-8">
  <title>TC39-TG4_ Source Maps on 2025-06-11</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39-TG4_ Source Maps";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39-TG4_ Source Maps<br>2025-06-11<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2025-06-06" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39-TG4_ Source Maps">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Wed Jun 11 2025 01:30:56 GMT-0700 (Pacific Daylight Time)">08:30</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-5" title="@sshumaf:matrix.org">Shumaf Lovpache</span>&gt;</div></td><td class="msg-cell"><p>Hi everyone. My team recently discovered an interesting technique used by React Server components.</p>
<p>The React Server components machinery (in particular <a href="https://github.com/facebook/react/tree/main/packages/react-client">react-client</a>) creates fake scripts with the same source map as a real user code to preserve source mapped traces in the browser. It allows recreating the top stack frame of the server code on the client preserving mapping to the original source code.</p>
<p>Consider an example (<a href="https://github.com/Soarex16/next-15-server-components-reproduction-app">github repo</a>):</p>
<pre><code class="language-js">export default function Home() {
  console.log('Home');
  return &lt;div&gt;
    &lt;main&gt;
      &lt;h1&gt;Header&lt;/h1&gt;
      Some text
    &lt;/main&gt;
    &lt;footer&gt;Footer&lt;/footer&gt;
  &lt;/div&gt;;
}
</code></pre>
<p>If you open this example in a browser, it will print to console the following message (first picture)<br>And clicking to “page.tsx:3” points to the original source (second picture).</p>
<p>From the user perspective, it’s a really neat feature, but unfortunately, this technique confuses js debuggers (<a href="https://github.com/vercel/next.js/issues/77733">issue on GH</a>). This happens because debuggers think that this piece of code was bundled in different places multiple times.</p>
<p>So when the user put a breakpoint, the debugger put breakpoints in all these fake scripts causing redundant breaks.</p>
<p>Here is an example of one of the scripts:</p>
<pre><code class="language-js">/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */

({"Home":_=&gt;

        _()})

//# sourceURL=rsc://React/Server/webpack-internal:///(rsc)/./app/page.tsx?0

//# sourceMappingURL=http://localhost:3000/__nextjs_source-map?filename=webpack-internal%3A%2F%2F%2F%28rsc%29%2F.%2Fapp%2Fpage.tsx
</code></pre>
<p>We have several options for solving this problem, and all of them require coordination between debuggers and frameworks. Since it affects all major debuggers – Chrome DevTools, WebStorm, VS Code, I’m asking for your feedback as a starting point for discussion with the community.<br>
Here they are:</p>
<ul>
<li>Use some heuristics (like matching file structure, comments, etc.) to detect fake scripts that don't need breakpoints. This approach is unreliable and can easily break if React changes scripts structure in the future.</li>
<li>Use some comment similar to # sourceMappingURL to indicate that this file should be skipped by the debugger</li>
<li>For fake scripts generate source maps with some extra field (like ignoreList but for generated code):</li>
</ul>
<pre><code class="language-json">{
  "version" : 3,
  "file": "out.js",
  "ignored": true,
  rest of the source map ...
}
</code></pre>
</td></tr>

</tbody></table></div></div></div>
</body></html>