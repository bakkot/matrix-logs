2023-08-14
[11:30:02.0884] <ramsey>
Is anyone aware of any language tags that would return "bottom-to-top" when passed to icu4c's `uloc_getLineOrientation()` function?

[11:31:18.0020] <ramsey>
For example, I've tried `pgl-Ogam` (Primitive Irish, Ogham script), but that returns "top-to-bottom" (which maybe is wrong?)

[11:32:58.0774] <ramsey>
Also, I know this is a channel for ECMA-402, but I was looking into the Intl Locale Info Proposal, which has a `getTextInfo()` method that includes (character) `direction`, and I was wondering why "line direction" was left out, but maybe it's because there are no language tags that would produce "bottom-to-top" in ICU

[11:35:20.0197] <littledan>
Wow, this is a pretty advanced question. I wonder if people over on the Unicode Slack would have that background, about what's in CLDR

[11:36:11.0758] <ramsey>
I wasn't aware of the Unicode Slack. I had gone looking for some chat channel for them on IRC or Matrix. Do you have a link?

[11:49:15.0541] <littledan>
ramsey: If you DM me your email address, I'll make sure you get an invite

[14:11:38.0269] <sffc>
See some previous discussion on this topic here: https://github.com/tc39/proposal-intl-locale-info/issues/59

[14:11:50.0039] <sffc>
"textInfo.direction is a very simplified model of reality"

[14:31:34.0350] <ramsey>
sffc: Thanks!


2023-08-17
[02:36:13.0712] <hsivonen>
Does there exist stated design rationale for why `Intl.Collator` (which, unlike many other APIs, doesn't format anything) falls back to the host locale instead of falling back to `und`? Considering that the root collation is more likely to be valid for a language that isn't explicitly listed in CLDR than a non-root host-language collation, the specified behavior seems unfortunate. Moreover, it's bad that the distinction isn't visible in the typical CI locale of en-US.

[05:36:44.0103] <littledan>
Everything in Intl falls back to the host locale… I think that’s the extent of the rationale.

[05:37:56.0327] <littledan>
If we wanted to work on Intl.Collator, we should probably address the thing where the design forces a bunch of recalculation of the collation key to do any sorting…

[07:39:40.0816] <sffc>
> Moreover, it's bad that the distinction isn't visible in the typical CI locale of en-US.
Can you check the resolved options to get the locale?


2023-08-21
[02:27:56.0530] <hsivonen>
> <@sffc:mozilla.org> > Moreover, it's bad that the distinction isn't visible in the typical CI locale of en-US.
> Can you check the resolved options to get the locale?

Possibly, yeah, if one goes looking for it, instead of just testing sort behavior.

[02:28:03.0991] <hsivonen>
> <@littledan:matrix.org> Everything in Intl falls back to the host locale… I think that’s the extent of the rationale.

Thanks.

[02:30:17.0007] <hsivonen>
> <@littledan:matrix.org> If we wanted to work on Intl.Collator, we should probably address the thing where the design forces a bunch of recalculation of the collation key to do any sorting…

Unlikely. According to ICU4C docs, the number of comparisons that you need to do to amortize the collation key generation is high, and collation keys are rarely appropriate. (FWIW, it appears that even SQLite's ICU4C mode sorts without stored collation keys even though the use case for stored collation keys is "databases")

[08:30:53.0220] <sffc>
Let's please not use locale sensitive sorting in a database. My team just spent a quarter making a special version of ICU to help a database team not corrupt their data when upgrading our library.

[14:50:04.0588] <justingrant>
> > (FWIW, it appears that even SQLite's ICU4C mode sorts without stored collation keys even though the use case for stored collation keys is "databases")

> My team just spent a quarter making a special version of ICU to help a database team not corrupt their data when upgrading our library.

By "stored collation key" do you mean that when a column is stored with a particular collation, then (as an implementation detail) a collation key is also stored along with that column's data?

sffc was this an existing 3rd-party DBMS like Oracle or MySQL?  Or was it a custom internal Google thing?

If the former, then I'd be curious to learn if any RDBMS does that. AFAIK, I/O is much more expensive than CPU in most modern platforms, so it seems fine to recalculate a collation key whenever sorting or comparing while running a query or when building a persisted index. Yes, it's slower, but if perf is a problem then building an index is typically the right solution rather than optimizing table scans. 


2023-08-22
[02:55:04.0664] <hsivonen>
> <@justingrant:matrix.org> > > (FWIW, it appears that even SQLite's ICU4C mode sorts without stored collation keys even though the use case for stored collation keys is "databases")
> 
> > My team just spent a quarter making a special version of ICU to help a database team not corrupt their data when upgrading our library.
> 
> By "stored collation key" do you mean that when a column is stored with a particular collation, then (as an implementation detail) a collation key is also stored along with that column's data?
> 
> sffc was this an existing 3rd-party DBMS like Oracle or MySQL?  Or was it a custom internal Google thing?
> 
> If the former, then I'd be curious to learn if any RDBMS does that. AFAIK, I/O is much more expensive than CPU in most modern platforms, so it seems fine to recalculate a collation key whenever sorting or comparing while running a query or when building a persisted index. Yes, it's slower, but if perf is a problem then building an index is typically the right solution rather than optimizing table scans.

For an index to be the right solution, the database needs to be willing and performance-wise capable of rebuilding the index upon collation library and/or CLDR update. Otherwise, you get value-added services like AWS maintaining a glibc whose collation behavior is frozen to accommodate Postgres creating a collation-dependent persistent index.

[09:54:47.0182] <sffc>
Yes what Henri mentioned is the type of problem I was referencing

[16:25:55.0418] <justingrant>
Got it. So Postgres relies on the OS's glibc for collation instead of statically linking a particular snapshot of a collation library with each release?  Or is the OS's glibc fixed to match Postgres's behavior so that client apps will sort exactly like the DBMS does, even when not running any DB-related code?

Regardless, how can this problem actually be solved?  If I want to have a case-insensitive, accent-insensitive DB index, and the rules for accent-insensitive comparison change between ICU releases, then the index has to be rebuilt, right?


2023-08-23
[18:36:40.0945] <tewuzij>
Well case insensitivity is terrible anyway

[18:43:58.0603] <sffc>
Databases aren't my area of expertise but if you want fuzzy searching you should normalize your text with NFD and Case Fold and build a search db out of that, rather than making a key with a version-sensitive sorting function

[18:49:24.0559] <sffc>
Collator-based matching is really powerful though so maybe there's a valid reason to consider building an index with a Collator-based transform

[20:54:04.0868] <littledan>
I kinda got the idea that collation keys might be better than NFD + case fold for some of these fuzzy comparison/searching cases from https://www.unicode.org/reports/tr10/#Searching but I hear about a lot more real systems using nfd+fold

[20:54:45.0969] <littledan>
So maybe I misinterpreted that section

[20:55:47.0496] <littledan>
(The non-stability point is well noted!)

