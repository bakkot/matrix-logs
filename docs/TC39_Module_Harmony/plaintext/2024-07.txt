2024-07-01
[16:08:30.0735] <kriskowal>
Food for thought for folks in this room. For ModuleSource instances, XS reflected bindings with a `bindings` array and the mood in the room currently favors `import()`, `exports()`, and `reexports()` methods that return arrays of import specifiers, names, and import specifiers respectively. A virtual module source would be obliged to provide one or the other, but the XS `bindings` reflects a detail that is probably important. The evaluation of a virtual module source needs to get a namespace object that reflects the _internal_ names for all the bindings, like `import {x as y} from 'z'` would have `y` on the external namespace, and the `x` property on the internal namespace. This allows for `import {x as y} from 'a'; import {x as z} from 'b'`. This is a detail that the `imports()`, `exports()`, and `reexports()` expression of bindings can’t express.


2024-07-02
[17:43:17.0505] <kriskowal>
guybedford: were you imagining that `source.imports()` return through to WebAssembly.Module.imports(source)` without mapping the {module, name, kind} treble to just name?

[17:43:31.0270] <kriskowal>
 * guybedford: were you imagining that `source.imports()` return through to `WebAssembly.Module.imports(source)` without mapping the {module, name, kind} treble to just name?

[17:43:44.0093] <kriskowal>
 * guybedford: were you imagining that `source.imports()` return through to `WebAssembly.Module.imports(source)` without mapping the `{module, name, kind}` treble to just `name`?

[17:44:41.0364] <kriskowal>
I would invite folks to join TG3 tomorrow to discuss module harmony topics. I don’t think we have an agenda.

[17:44:55.0806] <kriskowal>
 * I would invite folks to join TG3 Wed to discuss module harmony topics. I don’t think we have an agenda.

[22:32:50.0805] <jakobjingleheimer>
I already have plans for tomorrow

[10:46:17.0385] <guybedford>
Are you saying that in the case of a reexport - there is a desire to see the exact reexport binding mapping?

When we originally evaluated, our concern was the fact that `import { x } from './y'; export { x }` and `export { x } from './y'` are semantically equivalent, but would reflect differently in the bindings. With the bindings scheme we have now both of the above would have the same output for the exports() and imports() analysis.

[10:47:02.0443] <guybedford>
so if we did provide a reexports scheme, then the question is should those be represented the same or differently? And if not the same, is this is a useful analysis from a semantic point of view?

[10:49:32.0813] <guybedford>
it could be interpreted that way although is an entirely new implementation


2024-07-03
[09:51:47.0867] <guybedford>
This very interesting case came up in Node.js today  -https://github.com/bojavou/disambiguate-namespace

[09:52:05.0771] <guybedford>
Apparently when `export * as X from 'x'` was specified, we inadvertantly specified value deduping!!?????

[09:52:34.0223] <guybedford>
that is `export * from './a'; export * from './b'` where both `a` and `b` contain the source text `export * as X from 'x'` IS NOT AMBIGUOUS!

[09:52:52.0495] <guybedford>
might be some V8 / Firefox divergence in the implementation

[09:56:22.0640] <guybedford>
are we sure this is the correctly specified behaviour and not algorithmically incorrect?

[09:57:06.0447] <guybedford>
would be interested to hear others' takes on this

[10:03:29.0980] <nicolo-ribaudo>
I have no idea about what is the expected behaviour, but it'd be interesting to dig up the notes to see if it was every discussed

