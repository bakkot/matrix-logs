2024-07-01
[16:08:30.0735] <kriskowal>
Food for thought for folks in this room. For ModuleSource instances, XS reflected bindings with a `bindings` array and the mood in the room currently favors `import()`, `exports()`, and `reexports()` methods that return arrays of import specifiers, names, and import specifiers respectively. A virtual module source would be obliged to provide one or the other, but the XS `bindings` reflects a detail that is probably important. The evaluation of a virtual module source needs to get a namespace object that reflects the _internal_ names for all the bindings, like `import {x as y} from 'z'` would have `y` on the external namespace, and the `x` property on the internal namespace. This allows for `import {x as y} from 'a'; import {x as z} from 'b'`. This is a detail that the `imports()`, `exports()`, and `reexports()` expression of bindings can’t express.


2024-07-02
[17:43:17.0505] <kriskowal>
guybedford: were you imagining that `source.imports()` return through to WebAssembly.Module.imports(source)` without mapping the {module, name, kind} treble to just name?

[17:43:31.0270] <kriskowal>
 * guybedford: were you imagining that `source.imports()` return through to `WebAssembly.Module.imports(source)` without mapping the {module, name, kind} treble to just name?

[17:43:44.0093] <kriskowal>
 * guybedford: were you imagining that `source.imports()` return through to `WebAssembly.Module.imports(source)` without mapping the `{module, name, kind}` treble to just `name`?

[17:44:41.0364] <kriskowal>
I would invite folks to join TG3 tomorrow to discuss module harmony topics. I don’t think we have an agenda.

[17:44:55.0806] <kriskowal>
 * I would invite folks to join TG3 Wed to discuss module harmony topics. I don’t think we have an agenda.

[22:32:50.0805] <jakobjingleheimer>
I already have plans for tomorrow

[10:46:17.0385] <guybedford>
Are you saying that in the case of a reexport - there is a desire to see the exact reexport binding mapping?

When we originally evaluated, our concern was the fact that `import { x } from './y'; export { x }` and `export { x } from './y'` are semantically equivalent, but would reflect differently in the bindings. With the bindings scheme we have now both of the above would have the same output for the exports() and imports() analysis.

[10:47:02.0443] <guybedford>
so if we did provide a reexports scheme, then the question is should those be represented the same or differently? And if not the same, is this is a useful analysis from a semantic point of view?

[10:49:32.0813] <guybedford>
it could be interpreted that way although is an entirely new implementation


2024-07-03
[09:51:47.0867] <guybedford>
This very interesting case came up in Node.js today  -https://github.com/bojavou/disambiguate-namespace

[09:52:05.0771] <guybedford>
Apparently when `export * as X from 'x'` was specified, we inadvertantly specified value deduping!!?????

[09:52:34.0223] <guybedford>
that is `export * from './a'; export * from './b'` where both `a` and `b` contain the source text `export * as X from 'x'` IS NOT AMBIGUOUS!

[09:52:52.0495] <guybedford>
might be some V8 / Firefox divergence in the implementation

[09:56:22.0640] <guybedford>
are we sure this is the correctly specified behaviour and not algorithmically incorrect?

[09:57:06.0447] <guybedford>
would be interested to hear others' takes on this

[10:03:29.0980] <nicolo-ribaudo>
I have no idea about what is the expected behaviour, but it'd be interesting to dig up the notes to see if it was every discussed

[10:20:31.0092] <guybedford>
Firefox and V8 do different things - it's an error in V8 and works in Firefox

[10:20:39.0816] <guybedford>
strictly speaking, Firefox is following the spec correctly

[10:33:20.0298] <nicolo-ribaudo>
My intuition is that the spec behaviour is correct, since those two exports are pointing to the same binding internally

[10:34:02.0545] <nicolo-ribaudo>
For most people either behaviour would be ok though, since nobody thinks about the binding of the namespace object (but only about its value)

[10:35:13.0009] <nicolo-ribaudo>
It's the same as `export { foo as X } from "X"` in both `a` and `b` is not ambiguous, because they both point to the binding `foo`. `*` is just a special binding name, the same way as `default` is

[10:35:37.0453] <guybedford>
I suppose so!

[11:15:09.0141] <Jack Works>
so for this case, `import {x} from '...'; export {x}` must be reflected as "reexport" x from '...'

[11:15:33.0764] <Jack Works>
> <@guybedford:matrix.org> This very interesting case came up in Node.js today  -https://github.com/bojavou/disambiguate-namespace

otherwise this might not be reflected

[14:59:05.0527] <kriskowal>
On the topic of `bindings` vs `imports`, `exports`, and `reexports`, I observed during TG3 that a virtual module source constructor needs bindings, but doesn’t necessarily need to be able to see the bindings of another module source. To make a mock, seeing the `exports` of another module is sufficient to create the appropriate `bindings`. So, I am no longer convinced there’s an issue with coherence.

[15:03:16.0115] <kriskowal>
Consider:
```
const source = new ModuleSouce({
  bindings: [
    { import: 'x', as: 'a', from: '1.js' },
    {import: 'x', as: 'b', from: '2.js'},
    {export: 'default'},
    {exportAllFrom: '3.js'},
  ],
  evaluate(ns) {
    ns.default = ns.a + ns.b;
  },
});
source.exports() // ['default']
source.imports() // ['1.js', '2.js']
source.reexports() // ['3.js']
```

[15:03:28.0488] <kriskowal>
 * Consider:

```
const source = new ModuleSouce({
  bindings: [
    {import: 'x', as: 'a', from: '1.js' },
    {import: 'x', as: 'b', from: '2.js'},
    {export: 'default'},
    {exportAllFrom: '3.js'},
  ],
  evaluate(ns) {
    ns.default = ns.a + ns.b;
  },
});
source.exports() // ['default']
source.imports() // ['1.js', '2.js']
source.reexports() // ['3.js']
```

[15:05:18.0238] <guybedford>
the argument that is currently swaying it back for me is actually this ambiguous question though

[15:05:35.0010] <guybedford>
that even if we can determine the names, determining ambiguous exports requires the reexports information

[15:05:57.0337] <guybedford>
so you can make a wrapper with just knowing export star and direct exports

[15:06:10.0508] <guybedford>
but you can't detect ambiguous exports without reexports info

[15:06:24.0296] <guybedford>
I know when we previously discussed that we determined that was okay not to be able to do

[15:06:35.0027] <guybedford>
but there's certainly an argument there still I suppose

[15:07:11.0451] <kriskowal>
We may need to go deeper into concrete cases to resolve the question.

[15:07:53.0019] <kriskowal>
I have so far struggled to come up with a compelling “auto-mock” with the primitives we have.

[15:09:11.0829] <kriskowal>
But with some more specific constraints and limitations, there’s probably a reasonable, practical module adapter for something like instrumenting all exported functions.

[15:10:07.0137] <kriskowal>
It probably remains useful to think about the question in relation to virtual module sources.

[15:10:32.0637] <guybedford>
I guess the use case question is also - how useful is it to trace reexports

[15:10:39.0438] <guybedford>
and determine their original definer

[15:11:39.0399] <kriskowal>
Right. We need a motivating use case. I can imagine one, but it’s pretty imaginary: providing primitives for LSP to navigate the the definition of an imported name.

[15:12:15.0511] <kriskowal>
That’s tenuous because your LSP is going to be looking at the full source text.

[15:14:33.0762] <kriskowal>
The real and present motivating use case for module source reflection is a bundler, and for a bundler, all you need is `imports()` (assuming it includes `reexports()`). You need `exports()` only to fail-during-bundling if there’s a name collision between multiple reexports.

[15:15:33.0791] <kriskowal>
I suppose the ambiguity does come to bear, though, even in the bundling case. You would have to know that two names from disparate reexports correspond to the same value to know whether there was a conflict.

[15:17:02.0525] <kriskowal>
/me drives another nail into his export-star-from plushie

[15:57:28.0566] <guybedford>
right so previously we determined perhaps exact conflict detection isn't a necessary use case

[15:57:36.0580] <guybedford>
but if it is we can readdress that too

[15:59:22.0750] <guybedford>
I've posted https://github.com/tc39/proposal-esm-phase-imports/issues/20


2024-07-04
[00:32:43.0320] <nicolo-ribaudo>
The use case for exports() is that you might want to wrap your module in another, and you need to know if there is a default to re-export or not

[00:33:15.0970] <nicolo-ribaudo>
Or you want to wrap it and wrap all its exported functions in some logging utility 

[04:03:34.0086] <littledan>
I don’t think this proposal has enough machinery to let you do those re-exports because the set of exported names has to be static.

[04:04:40.0089] <littledan>
That is what has always confused me about the presence of these methods in the proposal. And bundlers are operating at a very different “time” from the other operations on module sources.

[04:06:55.0227] <Jack Works>
for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics 

[04:17:40.0311] <littledan>
> <@jackworks:matrix.org> for the virtualization motivation, it's important to emulate ES module semantics. although this proposal itself cannot achieve that, with a bunch of other proposals we may do that in the future. the ability to detect ambiguous star export is also needed to fully implement ES semantics 

Agreed. The question in my mind was, which parts will and won’t be useful to incrementally ship, when we aren’t yet including that bunch of other proposals yet. I think we all agree on not cutting off the ability to detect ambiguous star exports in the future, right?

[04:20:29.0938] <Jack Works>
if we reflect "import {x} from y; export { x }" as imports: [x from y]; export: [x from y], like the source code was "export { x } from y", we can detect this case without make the api surface complex

[07:24:30.0272] <nicolo-ribaudo>
The set has to be static at module creation time. i.e. you could do this:
```js
async function wrapModuleHidingX(url) {
  const source = await import.source(url);
  const names = source.exportNames().filter(name => name !== "x");
  return new ModuleSource(`
    export { ${ names.join(",") } } from "${url}";
  `);
}
```

[08:49:08.0282] <nicolo-ribaudo>
From the modules call today:
```js
// mod1
export let a;
export { a as b };

// mod2
export { a as x } from "mod1";

// mod3
export { b as x } from "mod3";

// mod4
export * from "mod2"
export * from "mod3"
```

_If_ the use case is to detect not-actually-ambiguous ambigous re-exports, then the source of `mod1` needs a way to say that `a` and `b` internally refer to the same local binding

[08:52:47.0464] <guybedford>
from the above discussion - it is not enough to have a reexports analysis providing `{ importName, exportName }` it must provide the full list of `{ importName, exportName, localName }` for both reexported and local bindings

