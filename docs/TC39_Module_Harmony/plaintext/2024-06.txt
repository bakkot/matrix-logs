2024-06-05
[11:32:56.0905] <jakobjingleheimer>
I can attend tomorrow but only for the first ~30 mins cuz I have to go to the airport

[15:08:09.0473] <ljharb>
do you want me to cancel yalls meeting next week, since it's plenary week?

[15:10:10.0923] <nicolo-ribaudo>
Yes please!


2024-06-06
[07:37:00.0994] <nicolo-ribaudo>
I think I might be up to 30 minutes late today 

[08:06:31.0249] <jakobjingleheimer>
My internet just died

[08:09:32.0390] <Chengzhong Wu>
No one showed up in the room yet.

[08:19:24.0042] <guybedford>
Was late this side myself again unfortunately. If folks have something to bring up, I'm in the meeting now.


2024-06-07
[04:54:15.0206] <littledan>
Whatâ€™s the motivation for the AbstractModuleSource methods in the ESM source imports proposal? They feel separate from the stated goals. The rationale that I was able to find was:

> These helper methods are designed to allow for determining the static public exports and public imports of a module, but do not give information about the internal module identifiers or dynamic import.

[08:58:21.0401] <guybedford>
littledan: they are in effect loader primitives, that we can do "while we are specifying it". Also effectively replaces the need for eg https://www.npmjs.com/package/es-module-lexer which clearly is needed.

[08:59:32.0348] <guybedford>
They are somewhat of an orthogonal feature though, that could be worth more explicitly calling out as a use case though certainly. Point taken - I can add some more motivation here around the es-module-lexer use case it solves.

[09:08:40.0168] <littledan>
but they're defined for all AbstractModuleSources, e.g., also for WebAssembly?

[09:09:22.0026] <littledan>
I'm also wondering how much you've worked out about the identity of source modules as they're postMessage'd around. Does it go by resolved specifier, or are they cloned the way that module expressions are?

[09:10:16.0174] <guybedford>
Yes, because these are properties of all cyclic module records

[09:10:39.0698] <guybedford>
and if Wasm supports top-level await in future or import meta, it might even support those

[09:11:20.0424] <guybedford>
For the transfer, this is exactly what we are hoping to treat as a Stage 2.7 concern, since it involves interactions with other spec texts

[09:11:48.0153] <guybedford>
it may likely involve a spec refactoring to more clearly define the module key, which I cover in more detail in the presentation

[09:12:45.0553] <littledan>
> <@guybedford:matrix.org> They are somewhat of an orthogonal feature though, that could be worth more explicitly calling out as a use case though certainly. Point taken - I can add some more motivation here around the es-module-lexer use case it solves.

It might be worth calling out whether you're open to splitting this part out, given the very separate nature of the motivation and the lack of hard dependencies in either direction.

[09:13:45.0990] <guybedford>
yeah I can call that out

[10:14:30.0820] <guybedford>
I've posted https://github.com/tc39/proposal-esm-phase-imports/pull/16 to separate this in the proposal readme.


2024-06-10
[03:51:45.0147] <Aapo Alasuutari>
I ran into an interesting corner case where spec/implementations differ from what I at least initially would've expected:

I have a case where due to loosely typed names, a single module can match multiple names. (eg. Asking for a module with caret version 1.0.0 and 1.0.1 in a part of the URL can resolve to the same concrete module). I had the bright idea of avoiding duplication of modules by responding with HTML redirects from the server (to be exact, a ServiceWorker intercepts the request and performs the final redirect arbitration). This works fine in getting the right module, but it does not deduplicate them.

I presume this is right and proper from the spec standpoint but on the other hand, is it what is really wanted? Is module redirection a reasonable thing to consider?

[03:59:11.0308] <Aapo Alasuutari>
* I ran into an interesting corner case where spec/implementations differ from what I at least initially would've expected:

I have a case where due to loosely versioned names, a single module can match multiple names. (eg. Asking for a module with caret version 1.0.0 and 1.0.1 in a part of the URL can resolve to the same concrete module). I had the bright idea of avoiding duplication of modules by responding with HTML redirects from the server (to be exact, a ServiceWorker intercepts the request and performs the final redirect arbitration). This works fine in getting the right module, but it does not deduplicate them.

I presume this is right and proper from the spec standpoint but on the other hand, is it what is really wanted? Is module redirection a reasonable thing to consider?

[04:10:28.0380] <Aapo Alasuutari>
As code this would be:
```js
const modA = await import("mod--^1.0.0"); // server responds with redirect to "mod--1.0.0"
const modB = await import("mod--1.0.0");
const modC = await import("mod"); // import-map redirects to "mod--1.0.0"

modB === modC; // true
modA === modB; // false
```

[05:22:39.0130] <nicolo-ribaudo>
Aapo Alasuutari You can read about it at https://github.com/whatwg/html/issues/3624

[05:40:11.0955] <Aapo Alasuutari>
> <@nicolo-ribaudo:matrix.org> Aapo Alasuutari You can read about it at https://github.com/whatwg/html/issues/3624

Thank you. Makes sense, though it's always unfortunate to see your bright idea get dashed on the rocks of reality :D

[05:42:10.0470] <Aapo Alasuutari>
I guess the best option is for the server to return `export *; import foo; export default foo;` as a kind of minimal redirect-like Module.


2024-06-11
[05:14:55.0410] <Luca Casonato>
Yes, but be careful that `import foo; export default foo` only works if the module actually has a default export

[05:15:13.0183] <Luca Casonato>
so the redirect module has to be dependant on the input module

[05:15:22.0570] <Luca Casonato>
 * so the redirect module has to be dependant on the module you are redirecting

[05:23:59.0189] <nicolo-ribaudo>
Also, you need to use `export { default } from "X"` otherwise you break the live binding 

