2025-09-10
[09:52:02.0403] <nicolo-ribaudo>
Hey, I don't remember if I mentioned last time we met, but I was talking with joyee (who worked on the recent module changes in Node.js), and he'd be curious to talk about module hooks to see where we are and how that relates to the Node.js system. Zb Tenerowicz (ZTZ/naugtur) / kriskowal do you plan to attend one of our upcoming meetings? :)

[10:09:39.0856] <kriskowal>
I’ll try to attend tomorrow. ZB has been able to drop in regularly recently.

[10:11:50.0862] <Zb Tenerowicz (ZTZ/naugtur)>
I'll try to join tomorrow, yes


2025-09-11
[20:34:49.0310] <guybedford>
seems there was a pretty critical oversight in the type css import spec - https://github.com/whatwg/html/issues/11629

[20:34:57.0550] <guybedford>
hopefully it gets corrected soon!

[20:35:23.0303] <guybedford>
see you all tomorrow

[09:02:09.0074] <nicolo-ribaudo>
Meeting time!

[14:28:56.0462] <kriskowal>
nicolo-ribaudo guybedford what’s the current deal for preserving the referrer of a module source if it’s transferred over post message to another worker, such that relative module specifiers converge on the same sources for shallow dependencies?

[14:30:23.0127] <kriskowal>
I assume it’s currently an implementation- or host-defined behavior backed by the host data internal slot, made transferrable.

[14:30:35.0579] <kriskowal>
* I assume it’s currently an implementation- or host-defined behavior backed by the host data internal slot, made transferrable of postmessage and structuredclone.

[14:34:07.0020] <kriskowal>
I’m mulling a mechanism to bind a module source to its specifier explicitly like `import(new ModuleSource('import "../x.js"'), { base: new URL('lib/y.js', import.meta.url).href })` or `import.source` with same args to avoid execution (and incidentally have a different module memo key)

[14:37:07.0853] <kriskowal>
@bakkot hinted that using dynamic import to bind sources was an option, given that we (including me) disfavor using the `ModuleSource` constructor. He was referring specifically to `importHook`, which doesn’t necessarily apply to the base module specifier but could. If the base specifier is currently an implementation specific detail that of transferrable module sources, given that it’s necessarily a serializable string, we could adopt it in 262 and bind it either way.

[15:12:53.0703] <guybedford>
It's just the baseURL property of the HTML module script here, which is separately serialized and deserialized when transferring a module script. Because the module script is [[HostDefined]] on the module record, both the record and its "HTML wrapper" of the module script get serialized together

[15:15:27.0789] <kriskowal>
Yeah, that’s what I recall. Thanks.

[15:15:30.0610] <guybedford>
I think indirection would be needed either through an instance or through another field to support configurable ids. Alternatively this could be done specifically at registry injection time i.e. return { id, source } from the load hook

[15:15:59.0489] <guybedford>
* I think indirection would be needed either through an instance or through another field to support configurable ids. Alternatively this could be done specifically at registry injection time i.e. return { id?, source } from the load hook

[15:16:42.0007] <kriskowal>
The `importHook` case is actually fine, because the hook is invoked knowing the cache key, which is the base specifier already.

[15:17:37.0257] <kriskowal>
The case of a `ModuleSource(text)` lifted from text is not really germane yet since we don’t have a lift-from-text, but I’m thinking ahead to how we bind that to the supplementary base/referrer.

[15:18:38.0541] <kriskowal>
It can’t be the `[[HostDefined]]` slot because we can’t stomp over origin metadata for purposes of CSP.

[15:19:21.0027] <kriskowal>
So I think we just end up with a slot in 262 that tends to coïncide with information currently only in [[HostDefined]].

[15:19:24.0939] <guybedford>
in the ModuleSource(text) case we might have more flexibility to override the baseURL actually since theres another field on the module script I added to track whether it is 'evalish' or not

[15:19:43.0508] <guybedford>
so the baseURL is no longer a security check, but just for resolution at that point

[15:20:07.0000] <guybedford>
it's more in the non-eval case that it's a csp concern to override, although I guess we could always just have two baseURLs as well - cspBaseURL and resolverBaseURL

