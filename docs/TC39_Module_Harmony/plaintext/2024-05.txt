2024-05-01
[16:12:26.0134] <guybedford>
Thanks for the feedback, I've added another agenda item to tomorrow's meeting to discuss weak imports again as well if anyone would like to join that discussion


2024-05-02
[08:04:46.0819] <jakobjingleheimer>
Sorry, i can't make it today, and then i'm on holiday for a few weeks

[08:05:14.0444] <Chengzhong Wu>
I have a conflict as well

[08:53:35.0114] <nicolo-ribaudo>
Ughh power went out

[09:05:58.0219] <guybedford>
I've updated the notes from the weak discussion in the meeting today at https://docs.google.com/document/d/1CD5lIBZLl24XBWbQhokqBdt4Zl7wPAcFJKJrgePr9HU/edit?pli=1

[09:06:16.0953] <guybedford>
jakebailey: nicolo-ribaudo please make any corrections or additions as necessary, and feel free to share

[09:06:24.0101] <guybedford>
would be great to find our true weak champion!

[16:00:41.0196] <jakebailey>
I got it working enough to use from tsc, the public API, and run our test suite. https://github.com/microsoft/TypeScript/pull/58419

[16:01:01.0490] <jakebailey>
No idea if CI passes, `gh act` was not playing nice locally so I could not check üôÇ


2024-05-03
[18:00:49.0793] <kriskowal>
Thanks for the notes.

[18:02:38.0148] <kriskowal>
(Hard no on a registry from me, fwiw.)

[18:03:09.0030] <kriskowal>
What‚Äôs the key differentiator between `import weak` vs `import defer` or `import source`?

[18:54:36.0306] <Richard Gibson>
IIUC, `weak` indicates that a module (or presumably a related entity in the case of e.g. `source`) should be returned if already available but otherwise the barest of stubs should appear in its place. It's like an opportunistic ESM analog of old-school feature testing.

[19:07:21.0592] <jakebailey>
The definition we were working with was "if resolution fails, return undefined", so more "optional" than anything 

[19:13:22.0436] <kriskowal>
That is interesting because it could apply at finer granularity of individual bindings, syntactically like import type in ts

[19:16:37.0123] <kriskowal>
Could be virtualized by allowing importHook to return undefined instead of throwing

[19:17:17.0103] <kriskowal>
Or tolerating the exception if weakly imported. ‚Äúoptional import‚Äù as it were

[19:18:18.0484] <kriskowal>
Or optionality could be indicated as we do elsewhere in destructuring with an explicit default

[19:45:02.0372] <jakebailey>
Yeah; the difference between the "deferred" import is that a deferred import will still error if the resolution fails, before anything else even happens. In that sense I prefer the term "optional" for clarity, especially given "weak" has existing connotations elsewhere

[19:45:23.0271] <jakebailey>
Though I honestly can't remember what a "source" import is.

[20:35:39.0677] <kriskowal>
Source imports are for grabbing a handle on the compiled source and not executing, to pass it to a worker, multiply instantiate, or isolate in another evaluation context (think mocks, dsls, or sandboxes)

[20:35:54.0380] <jakebailey>
Gotcha üôÇ

[02:43:12.0570] <Chengzhong Wu>
the term "weak" sounds strongly relevant to memory management to me. How abot "import optional"?

[02:47:44.0524] <nicolo-ribaudo>
`try import`

[02:47:51.0161] <nicolo-ribaudo>
Since it's suppressing an error

[02:50:40.0420] <Rob Palmer>
I think that "weak" could be fully understood by module experts such as those in this room and is an appropriate name for the proposal.  To the wider world, I don't think it conveys "ability to tolerate failure" in the way that other words could, so maybe not good as a language keyword.  Others that might work:

- `optional`try" or "maybe" or "attempt"

[02:51:43.0852] <Rob Palmer>
 * I think that "weak" could be fully understood by module experts such as those in this room and is an appropriate name for the proposal.  To the wider world, I don't think it conveys "ability to tolerate failure" in the way that other words could, so maybe not good as a language keyword.  Others that might work:

- `optional`
- `try`
- `maybe`
- `attempt`

[02:52:37.0002] <Rob Palmer>
`maybe import ns as * from "this-might-not-exist";`

[02:53:02.0263] <Rob Palmer>
`attempt import ns as * from "this-might-not-exist";

[02:53:18.0023] <Rob Palmer>
 * `attempt import ns as * from "this-might-not-exist";`

[02:53:37.0817] <Rob Palmer>
(I am joking about leading with it, but the sentence like nature is cute)

[02:54:23.0748] <Chengzhong Wu>
> <@nicolo-ribaudo:matrix.org> `try import`

suffix vs. prefix, my first impression is that `import optional_or_try nil from "nil"` might be easier to be parsed by toolings than `optional_or_try import nil from "nil"`

[02:56:10.0337] <Rob Palmer>
If we had `from "mod" import x` all of this would go away and we could have `from "mod" try import x`

[02:57:34.0629] <Chengzhong Wu>
`from "mod" try import x` reads different meaning to me... it could mean optional export names...

[03:19:06.0456] <nicolo-ribaudo>
> <@legendecas:matrix.org> suffix vs. prefix, my first impression is that `import optional_or_try nil from "nil"` might be easier to be parsed by toolings than `optional_or_try import nil from "nil"`

Well `try` is a keyword, so `try import` is fully unambiguous and doesn't even require NLT restrictions 

[07:55:21.0315] <joyee>
maybe import looks cute‚Ä¶.bonus points if there can be a named exports syntax using with ? :)

[07:59:27.0401] <bakkot>
I kind of like "fallible imports" but it is a moderately obscure word

[09:20:11.0075] <ljharb>
> <@nicolo-ribaudo:matrix.org> Since it's suppressing an error

that's not what `try` does, though :-)

[09:20:50.0122] <ljharb>
> <@nicolo-ribaudo:matrix.org> Since it's suppressing an error

 * that's not what `try` does, though :-) catch is what suppresses errors, try just makes them catchable

[09:22:05.0145] <kriskowal>
Strawpoke:
import * as x = {} from ‚Äúx‚Äù

[09:36:01.0101] <nicolo-ribaudo>
> <@ljharb:matrix.org> that's not what `try` does, though :-) catch is what suppresses errors, try just makes them catchable

`try import "foo" catch (e) { console.log("Failed importing foo") }` :P

[09:37:14.0567] <ljharb>
right. it's the catch that does it tho, as you can see by using try finally (which would have to work with any `try import` keyword, too)

[09:40:55.0447] <joyee>
Throwing on error feels like repeating the issue that URL.parse() tries to solve (compared to new URL())

[10:51:40.0706] <littledan>
import { foo } from.? "bar";

[10:52:07.0336] <littledan>
import?. { foo } from "bar";

[10:52:16.0885] <littledan>
(there are not serious suggestions)

[10:54:19.0842] <kriskowal>
Strawpoke:
import * as foo = {} from "bar";
import foo = {} from "bar";
import { foo = {} } from "bar";
import bar = {}, { baz = {}, qux } from "foo";
Where in the last, we expect "foo" to load but don‚Äôt expect it to export bar and baz, but do expect it to export qux.

