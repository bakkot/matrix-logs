2025-05-01
[05:58:23.0650] <jakobjingleheimer>
I'll use the time to review your node PR

[08:05:05.0319] <guybedford>
Thanks that would be great!

[08:20:54.0165] <nicolo-ribaudo>
https://github.com/tc39/ecma262/issues/3582 I think I found a bug with module evaluation, but I think it's a regression

[08:22:04.0529] <nicolo-ribaudo>
* https://github.com/tc39/ecma262/issues/3582 I think I found a bug with module evaluation

[09:48:28.0215] <guybedford>
good catch, it seems like we either need to clarify that it can be unset for errored modules, or to set it to some arbitrary value in this case

[09:55:35.0698] <guybedford>
another approach might be to move the CycleRoot set into the linking algorithm, but this would imply creating a proper equivalence between DFS for link and DFS for evaluate which doesn't currently exist

[09:56:50.0390] <guybedford>
The algorithm as written though, never did proper state transitions on error in evaluate (DFS transitions), and that was a property from the start. Sticking with that model would effectively mean just saying [[CycleRoot]] can be unset...

[09:57:09.0378] <guybedford>
I'm pretty sure this doesn't affects any real execution paths fwiw

[10:23:03.0169] <nicolo-ribaudo>
I opened https://github.com/tc39/ecma262/pull/3583, which defaults it to the module itself, and I _think_ it's fine to do it in the error case

[11:09:07.0954] <guybedford>
Yeah I'm pretty sure that works, as an import to any module in an errored cycle should still find that error and throw it before trying further evaluations.

[11:36:43.0617] <shu>
nicolo-ribaudo guybedford as the only two people in the world who have this machinery in their heads, any ideas for editorially improving understanding?

[11:37:07.0603] <shu>
i was thinking maybe an interactive example?

[11:37:12.0811] <shu>
how do people teach graph algorithms?

[11:38:02.0158] <shu>
i learned graphs from dr greibach, who taught on transparencies...


2025-05-02
[23:35:33.0449] <nicolo-ribaudo>
The problem is that this is not just a graph, but each node has also a ton of different states, and for evaluation they are _all_ relevant

[23:36:16.0330] <nicolo-ribaudo>
I do have an interactive example (linked to in that PR), maybe I could join the next editors call and we could consider how to embed smaller versions of it in the spec, together with the existing examples?

[01:52:14.0268] <nicolo-ribaudo>
shu Maybe another approach would be to make [[Status]] an enum with a payload, like Rust enums, so that the various slots are only available when they are relevant, and they transition more atomically.

e.g. given that [[AsyncEvaluationOrder]] is only relevant while a module is evaluating-async, it would be used as `If _module_.[[Status]] is an AsyncEvaluationState Record, use _module_.[[Status]].[[AsyncEvaluationOrder]]`

[01:52:51.0357] <nicolo-ribaudo>
Or like, [[EvaluationError]] would be defined on the EvaluatedState Record

[01:56:58.0700] <nicolo-ribaudo>
Or maybe we could draw some sort of state machine representing the various valid intermediate states that modules go through during the process, and how they transition between them

[02:21:26.0438] <nicolo-ribaudo>
* shu Maybe another approach would be to make \[\[Status\]\] an enum with a payload, like Rust enums, so that the various slots are only available when they are relevant, and they transition more atomically.

e.g. given that \[\[AsyncEvaluationOrder\]\] is only relevant while a module is evaluating-async, it would be used as `Assert: _module_.[[Status]] is an AsyncEvaluationState Record. Use _module_.[[Status]].[[AsyncEvaluationOrder]]`

[02:53:04.0063] <nicolo-ribaudo>
I opened a PR with a test262 test for a top-level await case that was not previously covered, if anybody has time please review :) https://github.com/tc39/test262/pull/4465

[08:14:57.0875] <shu>
it'd be very late for you in CET, but would be appreciated


2025-05-05
[15:56:06.0043] <guybedford>
As per usual, if anyone has anything for the agenda this week, please add it to the minutes document for us to schedule the meeting.


2025-05-06
[14:28:06.0313] <kriskowal>
Iâ€™m hoping to participate in Module Harmony more as the year progresses. But, the current recurring meeting time continues to overlap a block of reserved parenting time. +1hr is much more feasible. +2hr is absolutely feasible. I am hoping to make progress on import hooks, which has some remaining decision axes.

[14:29:43.0663] <guybedford>
When I start at Cloudflare in a couple of weeks - then as soon I've got a handle on my schedule I was hoping to finally look into the meeting timing again, so I'm hopeful we can figure out a crossover soon


2025-05-08
[19:26:20.0988] <guybedford>
It looks like we do have an agenda item for tomorrow for modules in engine-262, happy to discuss that if we have critical mass for the meeting, although I'm also not sure who added that one

[23:09:31.0185] <nicolo-ribaudo>
It was me :)

[23:09:39.0859] <nicolo-ribaudo>
But it's not urgent 

[23:10:40.0112] <guybedford>
ah, shall we perhaps bump to next week?

[23:11:26.0628] <nicolo-ribaudo>
Sure

[23:12:33.0044] <guybedford>
unless it's urgent or you want to run it, might make sense while the agenda is shorter

[23:16:11.0863] <nicolo-ribaudo>
It would probably fit in 15 minutes 

[23:19:00.0926] <guybedford>
we can discuss it if it would be useful sooner, we just need to make a decision for the meeting tomorrow

[23:23:02.0674] <nicolo-ribaudo>
Ok let's wait until there is more content so we can fill the hours. I also will have a topic for some editorial aspects of modules in 262, but I'm not ready to present it tomorrow 

[23:23:15.0428] <nicolo-ribaudo>
* Ok let's wait until there is more content so we can fill the hour. I also will have a topic for some editorial aspects of modules in 262, but I'm not ready to present it tomorrow 

[23:25:23.0505] <guybedford>
okay, unless something else comes up let's skip the meeting tomorrow then, and then pick back up again from next week. Will update the agenda item for next week.

