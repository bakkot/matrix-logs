2025-11-06
[08:39:28.0169] <Jacob Smith>
I have a conflict and can't make it tonight

[09:01:30.0655] <nicolo-ribaudo>
Meeting time :)

[09:01:47.0273] <kriskowal>
I think Iâ€™m in the lobby

[09:02:50.0592] <nicolo-ribaudo>
Til there is a lobby

[09:03:12.0365] <nicolo-ribaudo>
Guy and I are hosts but don't see you

[09:03:30.0228] <guybedford>
This one right? https://meet.google.com/row-whjm-rpn


2025-11-10
[10:41:27.0121] <guybedford>
Further to the discussion last meeting about source phase architecture in v8 being tough to integrate

[10:41:51.0687] <guybedford>
both Deno and Cloudflare now resolve dependencies of source phase moudles, effectively in violation of the spec, just because that's the natural implementation path .... :(

[10:41:53.0041] <guybedford>
https://github.com/denoland/deno/issues/31240

[11:23:40.0608] <Chengzhong Wu>
Deno didn't implement V8's source phase callbacks. Would you mind elaborating why this is a V8 issue?

[11:24:31.0264] <Chengzhong Wu>
In other words, Deno didn't implement V8's source phase support at all.

[11:28:38.0139] <guybedford>
Yeah I see that's the root cause here. Would be nice if implementers didn't have to do anything to get source phase though...

[11:29:04.0579] <Chengzhong Wu>
I'm not sure it will help in Deno's case

[11:29:19.0149] <Chengzhong Wu>
Deno is literally resolving before even reaching to V8

[11:31:33.0591] <guybedford>
yeah, I see that, and that makes sense I suppose. Ideally implementations would _just_ need to opt-out of their prefetching for source phase, and then all phases and imports work out after that.

[11:32:55.0623] <Chengzhong Wu>
If an embedder did not implement the source phase support, V8 does not enable the feature by default (at the moment, this is still hidden behind the flag `--js-source-phase-imports`)

[11:33:36.0403] <Chengzhong Wu>
I can see that this could be improved by asking V8 taking over the resolution step, so that V8 can stop resolving source import dependencies

[11:33:43.0990] <Chengzhong Wu>
* I can see that this could be potentially improved by asking V8 taking over the resolution step, so that V8 can stop resolving source import dependencies

[11:34:51.0955] <Chengzhong Wu>
However, I'd doubt the complexity of it because resolution can be either sync (node.js) or async (web).

[11:35:06.0850] <Chengzhong Wu>
* However, I'd doubt the complexity of it because resolution can be either sync (node.js) or async (web & node.js).

[11:35:13.0126] <guybedford>
resolution is always now synchronous on both the web and node

[11:35:28.0293] <Chengzhong Wu>
node still allows async resolution

[11:36:03.0642] <guybedford>
is it not fully deprecated yet?

[11:36:19.0133] <Chengzhong Wu>
it's.. not even under the discussion of deprecation

[11:36:40.0904] <Chengzhong Wu>
* it's.. not even under the discussion of deprecation AFAICT

[11:38:09.0048] <guybedford>
I guess there's two main architectures that might work for V8 - `HostResolveImportedModuleSource` as the new primitive that obtains sources first as a separate object (that can have compile cache etc)

[11:38:37.0394] <guybedford>
or we stick with `HostResolveImportedModuleV2` or `HostResolveImportedModuleWithPhase` that takes a phase argument as a hint, then returns a module without resolving dependencies

[11:39:26.0755] <guybedford>
Yeah, so a new v2 / or we extend it to apply to all modules

[11:40:05.0382] <Chengzhong Wu>
not sure if we are referring to the same thing. Are you referring to `HostImportModuleWithPhaseDynamicallyCallback`?

[11:40:20.0500] <guybedford>
yes, as either being replaced or extended

[11:41:30.0110] <Chengzhong Wu>
`HostImportModuleWithPhaseDynamicallyCallback` is only invoked for `import.source()` calls, it already takes an argument of `ModuleImportPhase`

[11:41:47.0055] <guybedford>
I understand that and I've implemented that in both Node.js and Cloudflare

[11:42:20.0930] <guybedford>
what I'm talking about is how we extend this to work for JS modules and sources more generally, while avoiding implementer complexity, as implementer feedback

[11:44:03.0141] <joyee>
It no longer does at least on the main thread (only allows it on the async loader hook thread when async loader hooks are registered)

[11:44:15.0413] <Chengzhong Wu>
Putting Deno's issue aside, it's not easy for me to understand what's the exact issue you are trying to improve. I assume you are trying to push V8 taking over the implementation of resolution steps, and ask host to resolve for each `referrer, specifier, attributes` pairs?

[11:44:33.0812] <guybedford>
no, just to separate source phase from instance phase in the V8 pipeline

[11:44:41.0715] <Chengzhong Wu>
but... it is still allowed, right?

[11:44:44.0893] <guybedford>
sources as first-class representations in v8

[11:45:13.0598] <guybedford>
i.e. both for WebAssembly Module Record, and for Source Text Module Record

[11:45:24.0608] <Chengzhong Wu>
i.e. we still need to support async resolution, not being able to remove the support entirely

[11:47:35.0070] <joyee>
We technically could, it's just going to be a breaking change for a fairly niche use case in an experimental feature (when you expect an async loader to affect the resolution of subsequent loader on the loader thread - say you register a typescript loader, and you want to load a zip loader written in typescript, that sort of thing)

[11:47:53.0726] <Chengzhong Wu>
I think the current `v8::Module` maps to the Module Record in the spec text. Both are essentially representation of module instance record

[11:47:54.0702] <Chengzhong Wu>
https://github.com/tc39/proposal-esm-phase-imports/issues/53

[11:48:19.0083] <guybedford>
right, but in the spec `[[ModuleSource]]` is a field on the module record

[11:48:42.0322] <guybedford>
so we need to use the module as the handle for the module source, or separate the module source wrapper into its own thing

[11:48:48.0703] <guybedford>
as I say two main paths

[11:49:30.0270] <Chengzhong Wu>
V8 did not expose internal AbstractModuleSource to the API. It could be exposed as a first class representation. But it'd still be great to distinguish it in the spec as a first step

[11:49:41.0013] <Chengzhong Wu>
* V8 did not expose internal AbstractModuleSource to the API. It could be potentially exposed as a first class representation. But it'd still be great to distinguish it in the spec as a first step

[11:49:50.0545] <guybedford>
having `v8::WasmModule` will help I think too

