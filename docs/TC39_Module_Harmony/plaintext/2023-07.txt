2023-07-03
[16:46:14.0737] <littledan>
Thanks for updating the Wasm ESM integration for source imports


2023-07-05
[12:31:26.0119] <littledan>
so, the champion's stance is, "Please implement all of Wasm/ESM integration. however, if you want to ship only the source part, do it with this particular form of error." right?


2023-07-06
[09:41:26.0545] <ljharb>
ok to delete next week's meeting, due to plenary?

[10:06:00.0271] <nicolo-ribaudo>
Yes!

[12:31:31.0055] <danielrosenwasser>
Hey folks, pardon my ignorance, but I've been trying to piece together the story of how Shadow Realms, Compartments, and SES sort of fits together to allow untrusted code to execute (apart from availability concerns). Does this sound right?

1. Components allow you to create a new intermediate "global scope", but where the intrinsics and `globalThis` are still shared with those of the current Realm (a.k.a. the host?).
2. To "safely" run arbitrary code inside of a Component, one would need to lock down the intrinsics (i.e. the proposed `lockdown()` in SES)
3. Because it is impractical to lock down your own Realm, that's where Shadow Realms come in. You create a separate Shadow Realm, lock that down, and run arbitrary code within a Compartment in that Realm.

is that the right intuition? Is there anything I'm missing?

[12:31:49.0838] <danielrosenwasser>
 * Hey folks, pardon my ignorance, but I've been trying to piece together the story of how Shadow Realms, Compartments, and SES/Hardened JavaScript sort of fit together to allow untrusted code to execute (apart from availability concerns). Does this sound right?

1. Components allow you to create a new intermediate "global scope", but where the intrinsics and `globalThis` are still shared with those of the current Realm (a.k.a. the host?).
2. To "safely" run arbitrary code inside of a Component, one would need to lock down the intrinsics (i.e. the proposed `lockdown()` in SES)
3. Because it is impractical to lock down your own Realm, that's where Shadow Realms come in. You create a separate Shadow Realm, lock that down, and run arbitrary code within a Compartment in that Realm.

is that the right intuition? Is there anything I'm missing?

[16:06:59.0412] <Mathieu Hofman>
In Compartments / Evaluators, the `globalThis` would not be shared, but the intrinsics would be shared for the Realm. For Evaluators, it may be possible to have different evaluators share the same global object, including the realm's original global object, though obviously that would not be useful as an integrity boundary.

[16:09:00.0904] <Mathieu Hofman>
It should be possible to lockdown your own realm.

[16:11:21.0699] <Mathieu Hofman>
ShadowRealm and Compartments are mostly orthogonal. The problem that ShadowRealm solves is that some code expects a non locked down environment (compatibility), and it's impossible to virtualize another environment on some hosts (aka browsers) where the main realm's global object has powerful non configurable properties.

[16:11:47.0309] <Mathieu Hofman>
I'll let Kris Kowal correct any misrepresentation I may have made


2023-07-07
[17:00:22.0217] <Kris Kowal>
Mathieu Hofman’s points are all correct. ShadowRealm is an orthogonal and sometimes complementary approach to Lockdown and Compartments (or the more surgical Evaluators + Module Harmony)

[17:01:56.0081] <Kris Kowal>
Lockdown makes the surrounding realm suitable for multiple guest programs. The surrounding realm can be a ShadowRealm, but does not have to be.

[17:04:44.0700] <Kris Kowal>
danielrosenwasser So, point 3 is not the case: it is practical to lockdown() an ordinary realm.

[17:06:18.0391] <Kris Kowal>
But running lockdown in the primary realm does mean less JavaScript will function normally in that realm. So, a shadow realm could be useful for those cases.

[17:06:36.0377] <danielrosenwasser>
right, that's really what I meant

[17:06:50.0595] <danielrosenwasser>
e.g. your own code expects an "unlocked" realm, but it's a sufficient constraint on guest code where you want to reused the same Realm instead of spinning up a Shadow Realm per guest

[17:06:56.0563] <danielrosenwasser>
 * e.g. your own code expects an "unlocked" realm, but it's a sufficient constraint on guest code where you want to reuse the same Realm instead of spinning up a Shadow Realm per guest

[17:07:07.0526] <Kris Kowal>
Yes, that is a nice arrangement.

[17:07:50.0976] <Kris Kowal>
Not one we’ve had the opportunity to try yet though! We’ve been locking down primary realms, including worker realms, for all of Agoric’s work.

[17:09:13.0675] <Kris Kowal>
Shims are not really a problem. Lockdown just has to cooperate with the shim. After shims, the biggest problem is usually property override mistakes, which aren’t really detectable until you’ve frozen some intrinsics.

[17:10:35.0314] <Kris Kowal>
Notably, code of the flavor `{}.constructor = myConstructor` or `myPrototype.toString =` have to be changed to use `Object.defineProperty`, but then you’re golden. Folks using Hardened JavaScript generally get by these obstacles by patching the package and sending up a PR.

[17:12:09.0806] <bakkot>
ugh

[17:12:18.0324] <bakkot>
can we make Object.prototype.constructor/toString be more exotic instead of that

[17:12:29.0607] <Kris Kowal>
That would be nice. We would like that.

[17:12:53.0736] <danielrosenwasser>
(I would like to know what that means too :D)

[17:12:56.0696] <bakkot>
I want to make it more exotic anyway https://github.com/tc39/proposal-symbol-proto/issues/1

[17:13:36.0700] <danielrosenwasser>
So would Shadow Realms not also be an alternative sandboxing technique? It sounds like it provides similar guarantees without needing a lockdown, but at the expense of a higher footprint

[17:13:44.0483] <Kris Kowal>
Yes, that proposal is consistent with our aims and also hits the data-only prototype-pollution-attack firmly on the head.

[17:14:35.0640] <Kris Kowal>
I would say complementary. Lockdown gives you multi-tenant realms, including multi-tenant shadowrealms.

[17:15:05.0120] <Kris Kowal>
And multi-tenancy comes with its own bag of trade-offs.

