2023-09-04
[19:26:02.0885] <Jack Works>
I have a performance question. if a and b are the same type (no type conversion will happen), then is a==b fast as a===b?

[07:32:38.0670] <kai>
I'm also curious, from a specification point of view, the conversion of IsLooselyEqual to IsStrictlyEqual does require additional operations, but both abstract operations have their own type judgments for the operands. For the case where the two operands are of the same type, whether it can be optimized it


2023-09-05
[14:51:15.0223] <ljharb>
shu: i have a package that sets Symbol.isConcatSpreadable on a few objects, for the purpose of ensuring that array concat still works as expected even if someone does `Array.prototype[Symbol.isConcatSpreadable] = true`, or has an array with an own property set on it.

a user is reporting that v8 becomes permanently slow if Symbol.isConcatSpreadable is ever set, even once, on any object - and deleting it later doesn't fix it. is there anything that could be done here to make it less pathological to set it on an arbitrary object?

[14:53:34.0064] <ljharb>
https://github.com/ljharb/safe-array-concat/pull/3#issuecomment-1707355732 for context

[15:10:46.0912] <shu>
this i can easily confirm: assigning a property on _any_ object with a name of `Symbol.isConcatSpreadable` triggers the protector

[15:10:53.0874] <shu>
protectors are 1-way, there's no way to un-trigger them

[15:13:37.0799] <shu>
the short answer is i don't know to make it less pathological, because the concat spreadable behavior is that we need to check it on arbitrary objects

[15:13:42.0715] <bakkot>
https://chromium.googlesource.com/v8/v8.git/+/HEAD/src/builtins/builtins-array.cc#1276

[15:13:48.0178] <shu>
there might be something possible here to carve out more fast paths

[15:13:49.0034] <bakkot>
"Slow path if @@isConcatSpreadable has been used"

[15:15:00.0920] <shu>
the current tradeoff is that Symbol.isConcatSpreadable is rare enough to just have a blanket slow path

[15:28:24.0209] <shu>
here's the data: https://chromestatus.com/metrics/feature/timeline/popularity/3261

[15:28:29.0504] <shu>
it's more than i thought actually

[15:28:34.0885] <shu>
but still not *that* much

[15:29:48.0211] <shu>
the main problem i see is that the slow path for Array.concat is *really* slow, like, it uses a hash table for the numbers for the resulting array

