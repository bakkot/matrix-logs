2023-02-01
[18:17:41.0250] <rkirsling>
so uh

[18:17:55.0134] <rkirsling>
the note in https://tc39.es/proposal-set-methods/#sec-set.prototype.intersection seems kind of surprising, upon attempting implementation

[18:18:10.0767] <rkirsling>
 * the note in https://tc39.es/proposal-set-methods/#sec-set.prototype.intersection seems kind of surprising, upon attempting implementation

[18:18:44.0629] <rkirsling>
because it seems like it's literally saying "hey V8 and JSC, why don't you redo your existing Set impls to match SM"

[18:19:48.0595] <rkirsling>
given that you're not gonna copy a Set into a new data structure in order to perform an operation on it

[18:20:18.0107] <rkirsling>
 * given that copying a Set into a new data structure in order to perform an operation on it is not going to constitute a perf win

[18:24:21.0359] <bakkot>
I looked into V8's and believed it would work

[18:24:24.0226] <rkirsling>
ah damn, or maybe not V8

[18:24:25.0636] <rkirsling>
https://github.com/v8/v8/blob/main/src/objects/ordered-hash-table.h#L30-L32

[18:24:27.0356] <bakkot>
in the same way described there

[18:24:37.0437] <bakkot>
if JSC's doesn't, that's a good data point and we could consider a different sorting option

[18:24:47.0652] <rkirsling>
in JSC a Set is a hashmap with a linked list

[18:25:44.0009] <bakkot>
hm, how does that... work

[18:26:16.0623] <rkirsling>
ah I mean that like, the buckets have a `next()` (and incidentally `prev()`)

[18:26:38.0157] <bakkot>
hm

[18:26:45.0600] <bakkot>
but are not contiguous in memory?

[18:28:52.0001] <rkirsling>
yeah exactly

[18:29:42.0741] <bakkot>
so how does iterator invalidation work? I guess chasing down all the iterators and updating them?

[18:29:56.0875] <bakkot>
or not invalidation _per se_ but if you delete an item that an iterator is pointing to

[18:32:07.0766] <bakkot>
hm. so this is fixable without redoing the entire implementation by e.g. adding uint64_t to each bucket to keep track of when items were added, but that does cost an extra word per item, which is a little unfortunate (and I guess requires you to re-scan the whole list once a total of 2^64 items have been added to a set over its lifetime)

[18:32:14.0765] <bakkot>
but the extra word per item is maybe not worth it

[18:32:24.0424] <bakkot>
I was really hoping this would be easy in all the engines, darn

[18:32:57.0379] <bakkot>
 * but the extra word per item is maybe not worth it

[18:33:38.0635] <rkirsling>
https://github.com/WebKit/WebKit/blob/main/Source/JavaScriptCore/runtime/HashMapImplInlines.h#L279-L304 is what happens upon delete(item)

[18:34:09.0781] <bakkot>
(that is: with each Set add a uint64_t, which is incremented whenever you add an item to the set, and never decremented; whenever you make a bucket put the value from that uint64_t in a field on the bucket. then you can sort buckets based on that field.)

[18:34:10.0180] <rkirsling>
yeah, sorry for the bubble bursting ðŸ˜“

[18:34:35.0169] <rkirsling>
> <@bakkot:matrix.org> (that is: with each Set add a uint64_t, which is incremented whenever you add an item to the set, and never decremented; whenever you make a bucket put the value from that uint64_t in a field on the bucket. then you can sort buckets based on that field.)

oh I see, yeah

[18:36:20.0144] <bakkot>
do you happen to know where HashMapImpl is instantiated with a concrete HashMapBucketType, so I can look at the buckets?

[18:37:12.0273] <bakkot>
nvm, found it/one

[18:38:56.0136] <rkirsling>
yeah, for Set it's HashMapBucket<HashMapBucketDataKey>

[18:40:23.0276] <bakkot>
so I see there is a `offsetOfNext` method

[18:40:25.0342] <bakkot>
no idea what that's for

[18:41:26.0326] <bakkot>
oh, it's the offset _of the field_, not the offset of the next bucket, so not the thing you'd need

[18:42:06.0396] <rkirsling>
right exactly

[18:42:14.0963] <rkirsling>
I got excited about that for a second at first too

[18:42:35.0328] <rkirsling>
but unfortunately those are just helpers for JIT to find exact locations in memory

