<!DOCTYPE html><html><head>
  <title>TC39 Structs and Shared Structs on 2024-01-18</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Structs and Shared Structs";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Structs and Shared Structs<br>2024-01-18<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2023-12-18" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Structs and Shared Structs">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Thu Jan 18 2024 09:59:49 GMT-0800 (Pacific Standard Time)">17:59</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">My apologies, I will be about 2 minutes late to the working session today</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Thu Jan 18 2024 11:01:18 GMT-0800 (Pacific Standard Time)">19:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><span class="nick-8">shu</span>: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would having the inherited struct just maintain the initial field layout of the base struct be sufficient?</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Thu Jan 18 2024 11:03:04 GMT-0800 (Pacific Standard Time)">19:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">i think the benefit is more like "full composability with rest of the language", mainly</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Thu Jan 18 2024 11:03:24 GMT-0800 (Pacific Standard Time)">19:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">i know the field has kind of soured on inheritance hierarchies vs inline storage of stuff</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Thu Jan 18 2024 11:03:59 GMT-0800 (Pacific Standard Time)">19:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">but for e.g. AST nodes, you probably do want an inheritance hierarchy in the "layout prefix" sense that i was imagining</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Thu Jan 18 2024 11:04:11 GMT-0800 (Pacific Standard Time)">19:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><code>AstNodeBase</code> has <code>loc</code> or whatever</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Thu Jan 18 2024 11:04:46 GMT-0800 (Pacific Standard Time)">19:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I'm more asking if there is any reason that <code>struct B extends A {}</code> needs to care about <code>A</code> other than its field layout (if you ignore TLS prototypes and constructor initialization logic)</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Thu Jan 18 2024 11:05:12 GMT-0800 (Pacific Standard Time)">19:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">(aside from internal AST reasons)</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Thu Jan 18 2024 11:05:39 GMT-0800 (Pacific Standard Time)">19:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">ooh</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Thu Jan 18 2024 11:05:39 GMT-0800 (Pacific Standard Time)">19:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">It goes to simplifying the syntax I've been considering.</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Thu Jan 18 2024 11:05:50 GMT-0800 (Pacific Standard Time)">19:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">i feel like no?</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Thu Jan 18 2024 11:05:55 GMT-0800 (Pacific Standard Time)">19:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">my intention was literally for layout</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Thu Jan 18 2024 11:06:43 GMT-0800 (Pacific Standard Time)">19:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">In classes, field order is determined by calling <code>super()</code>, where each <code>super</code> constructor installs its fields and returns the thing to be the used as the <code>this</code> in the subclass constructor.</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Thu Jan 18 2024 11:06:53 GMT-0800 (Pacific Standard Time)">19:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">That helps</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Thu Jan 18 2024 11:08:35 GMT-0800 (Pacific Standard Time)">19:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><p>what i want for struct inheritance semantics:</p>
<ul>
<li>one shot initialization. even if we allow field initializers or user-programmable constructors, they get a fully initialized instance with all fields initialized to a sentinel (<code>undefined</code>, i guess)</li>
<li>superclass's fields precede your own fields</li>
</ul>
</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Thu Jan 18 2024 11:08:57 GMT-0800 (Pacific Standard Time)">19:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">the invariant is that a half-constructed, out-of-declared-order instance is not observable if you use structs</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Thu Jan 18 2024 11:14:10 GMT-0800 (Pacific Standard Time)">19:14</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><p>That syntax sketch I wrote up a few months back has a lot of corner cases to handle future complexity, like:</p>
<ul>
<li>declaring whether a struct has a <code>null</code> prototype, or a "shared" prototype, or a TLS prototype.</li>
<li>declaring whether a struct field is "non-shared" on a shared struct (i.e., a TLS-backed field).</li>
<li>indicating whether a method is shared or non-shared, for a potential future that might somehow include shared functions.</li>
</ul>
<p>I'd like to cut a lot of that for simplicity's sake. For example, every <code>struct</code> declaration has a non-shared prototype (a TLS prototype for shared structs). You can use <code>extends null</code> if you don't need the prototype, and we can just make that work as opposed to how <code>class extends null</code> doesn't work today.</p>
</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Thu Jan 18 2024 11:14:53 GMT-0800 (Pacific Standard Time)">19:14</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">So <code>shared struct A extends B {}</code> gives <code>A</code> a TLS prototype that inherits from <code>B</code>'s TLS prototype.</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Thu Jan 18 2024 11:15:37 GMT-0800 (Pacific Standard Time)">19:15</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If you do <code>shared struct A extends B {}</code> and <code>B</code> isn't shared, it doesn't matter. You just get <code>A</code> with the same layout as <code>B</code>, except it's shared, and the prototypes are non-shared anyways.</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Thu Jan 18 2024 11:17:48 GMT-0800 (Pacific Standard Time)">19:17</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">In a <code>struct</code> constructor, <code>super()</code> could be designed such that it doesn't support return override tricks, since the layout is already wired up.</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Thu Jan 18 2024 11:19:02 GMT-0800 (Pacific Standard Time)">19:19</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">And we could just assume methods are non-shared by default, and if shared functions ever becomes a thing you have to opt-in on a method-by-method basis. That seems like a good idea anyways, since you'd want to explicitly indicate that you'd thought about thread safety for a given "shared" method anyways.</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Thu Jan 18 2024 11:19:11 GMT-0800 (Pacific Standard Time)">19:19</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">All of that makes the syntax fairly simple.</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Thu Jan 18 2024 11:25:25 GMT-0800 (Pacific Standard Time)">19:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><p>Basically:</p>
<pre><code>// non-shared struct
struct S1 {
  foo; // fixed-layout, non-shared field

  constructor() { } // realm-local constructor

  bar() { } // attached to realm-local prototype
  get baz() { } // attached to realm-local prototype
  set baz(value) { } // attached to realm-local prototype
}

// shared struct
shared struct S2 {
  foo; // fixed-layout, shared field

  constructor() { } // realm-local constructor

  bar() { } // attached to realm-local prototype
  get baz() { } // attached to realm-local prototype
  set baz(value) { } // attached to realm-local prototype
}

// null prototypes
struct S3 extends null {
  foo; // fixed-layout, non-shared field

  constructor() { } // realm-local constructor

  // cannot have methods/getters/setters
}

shared struct S4 extends null {
  foo; // fixed-layout, shared field

  constructor() { } // realm-local constructor

  // cannot have methods/getters/setters
}

// subclassing
struct S5 extends S1 {} // ok
struct S6 extends S2 {} // ok? S6 would be non-shared, even though S2 is declared as shared
shared struct S7 extends S1 {} // ok? S7 would be shared, even though S1 is declared as non-shared
shared struct S8 extends S2 {} // ok
</code></pre>
</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Thu Jan 18 2024 11:27:20 GMT-0800 (Pacific Standard Time)">19:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Ideally, we could find some way of supporting private names and <code>accessor</code>, as I'd also like to support decorators long term. The private names bit is tricky for shared structs, though, as you wouldn't be able to guarantee "hard privacy" if it were supported, but private names are necessary to support <code>accessor</code> for decorators.</td></tr>

</tbody></table></div></div></div>
</body></html>