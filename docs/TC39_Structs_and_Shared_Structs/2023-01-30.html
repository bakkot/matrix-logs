<!DOCTYPE html><html><head>
  <title>TC39 Structs and Shared Structs on 2023-01-30</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Structs and Shared Structs";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Structs and Shared Structs<br>2023-01-30<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2023-01-29" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Structs and Shared Structs">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Sun Jan 29 2023 21:11:38 GMT-0800 (Pacific Standard Time)">05:11</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">Right, this is why I concluded that the only reference point we could use is the module system</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Sun Jan 29 2023 22:07:30 GMT-0800 (Pacific Standard Time)">06:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell">just like builtin modules, there'd always have to be a way to access the same functionality in Scripts - how would that work at all with the module system?</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Mon Jan 30 2023 00:39:53 GMT-0800 (Pacific Standard Time)">08:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">Automatically de-duping types based on module could also be difficult when the bundler inlines the defining module into separate main and worker bundles. It would need to know this module is an entry-point that should not be inlined</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Mon Jan 30 2023 00:43:25 GMT-0800 (Pacific Standard Time)">08:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell"><p>For manually registering a prototype:</p>
<ul>
<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>
</ul>
</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Mon Jan 30 2023 00:48:49 GMT-0800 (Pacific Standard Time)">08:48</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell"><ul>
<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then "just work" from that point on. But needs to answer: what carries the "type" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the "transferable objects" list)</li>
</ul>
</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Mon Jan 30 2023 00:51:47 GMT-0800 (Pacific Standard Time)">08:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell"><ul>
<li>or is everything automatic, for the use case <span class="nick-15">rbuckton</span> mentioned where an npm package of shared structs "just works across workers" with no orchestration (ignoring ensuring the bundler&amp;server are configured as required)</li>
</ul></td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Mon Jan 30 2023 06:53:09 GMT-0800 (Pacific Standard Time)">14:53</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <p>For manually registering a prototype:</p>
<ul>
<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>
</ul>
</blockquote></mx-reply>This seems infeasible for any complex, nested set of structs</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Mon Jan 30 2023 06:57:25 GMT-0800 (Pacific Standard Time)">14:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <ul>
<li>or is everything automatic, for the use case <span class="nick-15">rbuckton</span> mentioned where an npm package of shared structs "just works across workers" with no orchestration (ignoring ensuring the bundler&amp;server are configured as required)</li>
</ul></blockquote></mx-reply>While this would be nice to have as a default, I don't think "automatic only" is feasible w/o making structs unbundleable.</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Mon Jan 30 2023 07:02:58 GMT-0800 (Pacific Standard Time)">15:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <ul>
<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then "just work" from that point on. But needs to answer: what carries the "type" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the "transferable objects" list)</li>
</ul>
</blockquote></mx-reply>Once per realm is consistent with primitives like <code>Number.prototype</code>, <code>Boolean.prototype</code>, etc. The question is whether structs are more "object"-like or more "primitive"-like, since Objects are effectively per-Agent since you can hand one to another realm and it still walks the original prototype chain.</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Mon Jan 30 2023 07:09:32 GMT-0800 (Pacific Standard Time)">15:09</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">Once per-realm has the consequence that the value would not meet the current 'sealed'  guarantees. Maybe this is OK, but also maybe not</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Mon Jan 30 2023 07:10:01 GMT-0800 (Pacific Standard Time)">15:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I think regarding dynamic prototype lookup we agreed this would be a per-realm behavior like for primitives, which means whatever registry must be at most per realm</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Mon Jan 30 2023 07:11:56 GMT-0800 (Pacific Standard Time)">15:11</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">while that is 'like' primitives, it's more because primitives are not objects in the first place</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Mon Jan 30 2023 07:12:08 GMT-0800 (Pacific Standard Time)">15:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">If the only realms that existed were shadow realms, objects would effectively be per realm and not per agent</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Mon Jan 30 2023 07:12:17 GMT-0800 (Pacific Standard Time)">15:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">so they go via toObject, an object doesn't change via toObject</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Mon Jan 30 2023 07:12:36 GMT-0800 (Pacific Standard Time)">15:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">if only!</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Mon Jan 30 2023 07:13:20 GMT-0800 (Pacific Standard Time)">15:13</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">And  because of the existence of Shadow Realm, you cannot have a mechanism which would expose objects from another realm across the callable boundary</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Mon Jan 30 2023 07:13:35 GMT-0800 (Pacific Standard Time)">15:13</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">which a per agent registry would effectively do</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Mon Jan 30 2023 07:14:51 GMT-0800 (Pacific Standard Time)">15:14</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">but because of same-origin-iframes and node 'vm' there would still need to be defined behavior for same-agent-cross-realm semantics</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Mon Jan 30 2023 07:14:58 GMT-0800 (Pacific Standard Time)">15:14</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">ShadowRealms is the easy case :)</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Mon Jan 30 2023 07:15:25 GMT-0800 (Pacific Standard Time)">15:15</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">easy ~= can't pass objects, so can't pass structs</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Mon Jan 30 2023 07:18:07 GMT-0800 (Pacific Standard Time)">15:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">well technically can only pass struct between agents with host APIs, but we're still discussing how that works here ;)
A host could very well add an API to pass structs between shadow realms</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Mon Jan 30 2023 07:18:37 GMT-0800 (Pacific Standard Time)">15:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">(I really want to get my structured clone extension mechanism ironed out, as it'd work to pass objects between shadow realms)</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Mon Jan 30 2023 07:27:07 GMT-0800 (Pacific Standard Time)">15:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">As I said earlier, if we had a restriction that a shared struct must be a top-level declaration then most type identity registration would occur during application start up (with the exception of portions of the module graph loaded dynamically via <code>import()</code>), which means conflicts (be they intentional or unintentional) would primarily occur early. Malicious code wouldn't be able to hijack an already-registered type identity.</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Mon Jan 30 2023 07:28:16 GMT-0800 (Pacific Standard Time)">15:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell">how would that restriction work in Script?</td></tr>

</tbody></table></div></div></div>
</body></html>