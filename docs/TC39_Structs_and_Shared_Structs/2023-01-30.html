<!DOCTYPE html><html><head>
  <title>TC39 Structs and Shared Structs on 2023-01-30</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Structs and Shared Structs";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Structs and Shared Structs<br>2023-01-30<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2023-01-29" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Structs and Shared Structs">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Sun Jan 29 2023 21:11:38 GMT-0800 (Pacific Standard Time)">05:11</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">Right, this is why I concluded that the only reference point we could use is the module system</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Sun Jan 29 2023 22:07:30 GMT-0800 (Pacific Standard Time)">06:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell">just like builtin modules, there'd always have to be a way to access the same functionality in Scripts - how would that work at all with the module system?</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Mon Jan 30 2023 00:39:53 GMT-0800 (Pacific Standard Time)">08:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">Automatically de-duping types based on module could also be difficult when the bundler inlines the defining module into separate main and worker bundles. It would need to know this module is an entry-point that should not be inlined</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Mon Jan 30 2023 00:43:25 GMT-0800 (Pacific Standard Time)">08:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell"><p>For manually registering a prototype:</p>
<ul>
<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>
</ul>
</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Mon Jan 30 2023 00:48:49 GMT-0800 (Pacific Standard Time)">08:48</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell"><ul>
<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then "just work" from that point on. But needs to answer: what carries the "type" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the "transferable objects" list)</li>
</ul>
</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Mon Jan 30 2023 00:51:47 GMT-0800 (Pacific Standard Time)">08:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell"><ul>
<li>or is everything automatic, for the use case <span class="nick-15">rbuckton</span> mentioned where an npm package of shared structs "just works across workers" with no orchestration (ignoring ensuring the bundler&amp;server are configured as required)</li>
</ul></td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Mon Jan 30 2023 06:53:09 GMT-0800 (Pacific Standard Time)">14:53</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <p>For manually registering a prototype:</p>
<ul>
<li><code>StructClass.adopt(orphanedInstance)</code> is potential the simplest to explain on its own but per-instance-per-agent uses the most memory, and requires the most orchestration as each individual instance needs to be adopted before methods can be called</li>
</ul>
</blockquote></mx-reply>This seems infeasible for any complex, nested set of structs</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Mon Jan 30 2023 06:57:25 GMT-0800 (Pacific Standard Time)">14:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <ul>
<li>or is everything automatic, for the use case <span class="nick-15">rbuckton</span> mentioned where an npm package of shared structs "just works across workers" with no orchestration (ignoring ensuring the bundler&amp;server are configured as required)</li>
</ul></blockquote></mx-reply>While this would be nice to have as a default, I don't think "automatic only" is feasible w/o making structs unbundleable.</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Mon Jan 30 2023 07:02:58 GMT-0800 (Pacific Standard Time)">15:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <ul>
<li>registering once per type, reduces memory and is a one time orchestration (per type,per non-original-agent) which can then "just work" from that point on. But needs to answer: what carries the "type" being registered? Is the registry per-agent, or per-realm, or per-comms-channel*? (* a bit like the "transferable objects" list)</li>
</ul>
</blockquote></mx-reply>Once per realm is consistent with primitives like <code>Number.prototype</code>, <code>Boolean.prototype</code>, etc. The question is whether structs are more "object"-like or more "primitive"-like, since Objects are effectively per-Agent since you can hand one to another realm and it still walks the original prototype chain.</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Mon Jan 30 2023 07:09:32 GMT-0800 (Pacific Standard Time)">15:09</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">Once per-realm has the consequence that the value would not meet the current 'sealed'  guarantees. Maybe this is OK, but also maybe not</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Mon Jan 30 2023 07:10:01 GMT-0800 (Pacific Standard Time)">15:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I think regarding dynamic prototype lookup we agreed this would be a per-realm behavior like for primitives, which means whatever registry must be at most per realm</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Mon Jan 30 2023 07:11:56 GMT-0800 (Pacific Standard Time)">15:11</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">while that is 'like' primitives, it's more because primitives are not objects in the first place</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Mon Jan 30 2023 07:12:08 GMT-0800 (Pacific Standard Time)">15:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">If the only realms that existed were shadow realms, objects would effectively be per realm and not per agent</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Mon Jan 30 2023 07:12:17 GMT-0800 (Pacific Standard Time)">15:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">so they go via toObject, an object doesn't change via toObject</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Mon Jan 30 2023 07:12:36 GMT-0800 (Pacific Standard Time)">15:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">if only!</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Mon Jan 30 2023 07:13:20 GMT-0800 (Pacific Standard Time)">15:13</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">And  because of the existence of Shadow Realm, you cannot have a mechanism which would expose objects from another realm across the callable boundary</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Mon Jan 30 2023 07:13:35 GMT-0800 (Pacific Standard Time)">15:13</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">which a per agent registry would effectively do</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Mon Jan 30 2023 07:14:51 GMT-0800 (Pacific Standard Time)">15:14</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">but because of same-origin-iframes and node 'vm' there would still need to be defined behavior for same-agent-cross-realm semantics</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Mon Jan 30 2023 07:14:58 GMT-0800 (Pacific Standard Time)">15:14</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">ShadowRealms is the easy case :)</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Mon Jan 30 2023 07:15:25 GMT-0800 (Pacific Standard Time)">15:15</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">easy ~= can't pass objects, so can't pass structs</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Mon Jan 30 2023 07:18:07 GMT-0800 (Pacific Standard Time)">15:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">well technically can only pass struct between agents with host APIs, but we're still discussing how that works here ;)
A host could very well add an API to pass structs between shadow realms</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Mon Jan 30 2023 07:18:37 GMT-0800 (Pacific Standard Time)">15:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">(I really want to get my structured clone extension mechanism ironed out, as it'd work to pass objects between shadow realms)</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Mon Jan 30 2023 07:27:07 GMT-0800 (Pacific Standard Time)">15:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">As I said earlier, if we had a restriction that a shared struct must be a top-level declaration then most type identity registration would occur during application start up (with the exception of portions of the module graph loaded dynamically via <code>import()</code>), which means conflicts (be they intentional or unintentional) would primarily occur early. Malicious code wouldn't be able to hijack an already-registered type identity.</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Mon Jan 30 2023 07:28:16 GMT-0800 (Pacific Standard Time)">15:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell">how would that restriction work in Script?</td></tr>
  <tr class="msg" id="L24"><td class="ts-cell"><a class="ts" href="#L24" alt="Mon Jan 30 2023 07:30:55 GMT-0800 (Pacific Standard Time)">15:30</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> how would that restriction work in Script?</blockquote></mx-reply>They would also need to be at the top-level of a Script, so no using a function as a factory for shared struct <em>types</em>. When evaluation of the module/script body completes, the file cannot produce new struct types. Yes, this isn't 100% reliable, but is at least as reliable as the current mechanisms used today to capture intrinsics before they can be patched/modified by other code.</td></tr>
  <tr class="msg" id="L25"><td class="ts-cell"><a class="ts" href="#L25" alt="Mon Jan 30 2023 07:32:15 GMT-0800 (Pacific Standard Time)">15:32</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I think that restriction is completely unrealistic, and makes it impossible to use this feature in a lot of programs</td></tr>
  <tr class="msg" id="L26"><td class="ts-cell"><a class="ts" href="#L26" alt="Mon Jan 30 2023 07:33:03 GMT-0800 (Pacific Standard Time)">15:33</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I only suggested the restriction as a possible remediation for the concern about type identity registration being forgeable.</td></tr>
  <tr class="msg" id="L27"><td class="ts-cell"><a class="ts" href="#L27" alt="Mon Jan 30 2023 07:34:06 GMT-0800 (Pacific Standard Time)">15:34</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Realistically, even without this restriction, a type identity registry that depends on a first-in wins mechanism is still as reliable as existing intrinsic-capturing mechanisms.</td></tr>
  <tr class="msg" id="L28"><td class="ts-cell"><a class="ts" href="#L28" alt="Mon Jan 30 2023 07:34:20 GMT-0800 (Pacific Standard Time)">15:34</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">Javascript is a dynamic language. That suggestion is equivalent to forbidding features from the dynamic part of the language</td></tr>
  <tr class="msg" id="L29"><td class="ts-cell"><a class="ts" href="#L29" alt="Mon Jan 30 2023 07:34:45 GMT-0800 (Pacific Standard Time)">15:34</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">We already do that with features like <code>export</code></td></tr>
  <tr class="msg" id="L30"><td class="ts-cell"><a class="ts" href="#L30" alt="Mon Jan 30 2023 07:35:02 GMT-0800 (Pacific Standard Time)">15:35</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">And I have explained why first win semantics for a global registry is a non-starter</td></tr>
  <tr class="msg" id="L31"><td class="ts-cell"><a class="ts" href="#L31" alt="Mon Jan 30 2023 07:35:08 GMT-0800 (Pacific Standard Time)">15:35</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I don't want that restriction.</td></tr>
  <tr class="msg" id="L32"><td class="ts-cell"><a class="ts" href="#L32" alt="Mon Jan 30 2023 07:35:27 GMT-0800 (Pacific Standard Time)">15:35</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> And I have explained why first win semantics for a global registry is a non-starter</blockquote></mx-reply>Per-agent global, or cross-agent global?</td></tr>
  <tr class="msg" id="L33"><td class="ts-cell"><a class="ts" href="#L33" alt="Mon Jan 30 2023 07:35:41 GMT-0800 (Pacific Standard Time)">15:35</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">even per realm</td></tr>
  <tr class="msg" id="L34"><td class="ts-cell"><a class="ts" href="#L34" alt="Mon Jan 30 2023 07:36:44 GMT-0800 (Pacific Standard Time)">15:36</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><code>export</code> being first win is not a precendent, like object spread is not a precendent. Both have a local effect (module or object)</td></tr>
  <tr class="msg" id="L35"><td class="ts-cell"><a class="ts" href="#L35" alt="Mon Jan 30 2023 07:37:03 GMT-0800 (Pacific Standard Time)">15:37</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I still am not clear on why you believe a per-agent (or per-realm) write-only registry is a non-starter. If you don't want adversarial code to register first, you register first.</td></tr>
  <tr class="msg" id="L36"><td class="ts-cell"><a class="ts" href="#L36" alt="Mon Jan 30 2023 07:37:24 GMT-0800 (Pacific Standard Time)">15:37</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">who is "you"</td></tr>
  <tr class="msg" id="L37"><td class="ts-cell"><a class="ts" href="#L37" alt="Mon Jan 30 2023 07:37:36 GMT-0800 (Pacific Standard Time)">15:37</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">You, the application developer.</td></tr>
  <tr class="msg" id="L38"><td class="ts-cell"><a class="ts" href="#L38" alt="Mon Jan 30 2023 07:38:09 GMT-0800 (Pacific Standard Time)">15:38</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">Ok what about 2 libraries that the application load. Should lib1 be able to interfere with lib2 ?</td></tr>
  <tr class="msg" id="L39"><td class="ts-cell"><a class="ts" href="#L39" alt="Mon Jan 30 2023 07:39:11 GMT-0800 (Pacific Standard Time)">15:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If you are a middleware, or a plugin, or something else running in a host environment where you don't control the environment, then you ensure your type identity is sufficiently unique. If you are the host environment loading a middleware, or plugin, etc., you architect your environment to be resilient to such a conflict.</td></tr>
  <tr class="msg" id="L40"><td class="ts-cell"><a class="ts" href="#L40" alt="Mon Jan 30 2023 07:39:24 GMT-0800 (Pacific Standard Time)">15:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">there is no observable global mutable state in 262, and we would 100% block anything that introduces anything like it</td></tr>
  <tr class="msg" id="L41"><td class="ts-cell"><a class="ts" href="#L41" alt="Mon Jan 30 2023 07:39:39 GMT-0800 (Pacific Standard Time)">15:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell">the global object isn't that?</td></tr>
  <tr class="msg" id="L42"><td class="ts-cell"><a class="ts" href="#L42" alt="Mon Jan 30 2023 07:39:49 GMT-0800 (Pacific Standard Time)">15:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell">or do you mean across realms (bigger than global, "universal" maybe)</td></tr>
  <tr class="msg" id="L43"><td class="ts-cell"><a class="ts" href="#L43" alt="Mon Jan 30 2023 07:39:55 GMT-0800 (Pacific Standard Time)">15:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">minus the intrinsics/primordial objects themselves</td></tr>
  <tr class="msg" id="L44"><td class="ts-cell"><a class="ts" href="#L44" alt="Mon Jan 30 2023 07:39:57 GMT-0800 (Pacific Standard Time)">15:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">hidden *</td></tr>
  <tr class="msg" id="L45"><td class="ts-cell"><a class="ts" href="#L45" alt="Mon Jan 30 2023 07:40:12 GMT-0800 (Pacific Standard Time)">15:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">sorry I forgot the hidden part</td></tr>
  <tr class="msg" id="L46"><td class="ts-cell"><a class="ts" href="#L46" alt="Mon Jan 30 2023 07:40:25 GMT-0800 (Pacific Standard Time)">15:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell">there's a few of those too already, but they're all freezeable ofc</td></tr>
  <tr class="msg" id="L47"><td class="ts-cell"><a class="ts" href="#L47" alt="Mon Jan 30 2023 07:40:30 GMT-0800 (Pacific Standard Time)">15:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">where ?</td></tr>
  <tr class="msg" id="L48"><td class="ts-cell"><a class="ts" href="#L48" alt="Mon Jan 30 2023 07:40:41 GMT-0800 (Pacific Standard Time)">15:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell"><code>AsyncFunction</code> is one, no?</td></tr>
  <tr class="msg" id="L49"><td class="ts-cell"><a class="ts" href="#L49" alt="Mon Jan 30 2023 07:40:48 GMT-0800 (Pacific Standard Time)">15:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">hidden = internal</td></tr>
  <tr class="msg" id="L50"><td class="ts-cell"><a class="ts" href="#L50" alt="Mon Jan 30 2023 07:40:59 GMT-0800 (Pacific Standard Time)">15:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@aclaymore:matrix.org">Ashley Claymore</span>&gt;</div></td><td class="msg-cell">i.e. not impacted by being frozen</td></tr>
  <tr class="msg" id="L51"><td class="ts-cell"><a class="ts" href="#L51" alt="Mon Jan 30 2023 07:41:02 GMT-0800 (Pacific Standard Time)">15:41</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">yes the hidden intrinsics, which we're trying to fix</td></tr>
  <tr class="msg" id="L52"><td class="ts-cell"><a class="ts" href="#L52" alt="Mon Jan 30 2023 07:41:53 GMT-0800 (Pacific Standard Time)">15:41</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">ashley has the correct wording there, AsyncFunction is accessible to JS code</td></tr>
  <tr class="msg" id="L53"><td class="ts-cell"><a class="ts" href="#L53" alt="Mon Jan 30 2023 07:42:03 GMT-0800 (Pacific Standard Time)">15:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Ok what about 2 libraries that the application load. Should lib1 be able to interfere with lib2 ?</blockquote></mx-reply>If lib2 doesn't want <em>unintentional</em> interference, they should use sufficiently unique type identities. If lib1 performs <em>intentional</em> interference, that's up to the application developer/host environment to mitigate, and a best effort from the runtime to surface that information early, hence the first-in wins registry. If you can only write new unique identities to the registry, either lib1 or lib2 will fail rather than be ignorant of hijacking.</td></tr>
  <tr class="msg" id="L54"><td class="ts-cell"><a class="ts" href="#L54" alt="Mon Jan 30 2023 07:43:28 GMT-0800 (Pacific Standard Time)">15:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> i.e. not impacted by being frozen</blockquote></mx-reply>good thing RegExp.prototype isn't a regex anymore :-p</td></tr>
  <tr class="msg" id="L55"><td class="ts-cell"><a class="ts" href="#L55" alt="Mon Jan 30 2023 07:43:32 GMT-0800 (Pacific Standard Time)">15:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If the concern is about the registry not being freezable, that could be made possible via an API as well.</td></tr>
  <tr class="msg" id="L56"><td class="ts-cell"><a class="ts" href="#L56" alt="Mon Jan 30 2023 07:43:54 GMT-0800 (Pacific Standard Time)">15:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">But again that would prevent the feature from working</td></tr>
  <tr class="msg" id="L57"><td class="ts-cell"><a class="ts" href="#L57" alt="Mon Jan 30 2023 07:44:59 GMT-0800 (Pacific Standard Time)">15:44</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Yes, if malicious code were to freeze the registry your application would stop working. Which would be a fairly good indication that there is malicious code freezing the registry (at least, with a sufficiently clear error message).</td></tr>
  <tr class="msg" id="L58"><td class="ts-cell"><a class="ts" href="#L58" alt="Mon Jan 30 2023 07:45:14 GMT-0800 (Pacific Standard Time)">15:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I want any JS feature where I can dynamically load code, that will keep working regardless of previous code that was loaded and executed (if you ignore mutation to the global object and intrinsics)</td></tr>
  <tr class="msg" id="L59"><td class="ts-cell"><a class="ts" href="#L59" alt="Mon Jan 30 2023 07:45:18 GMT-0800 (Pacific Standard Time)">15:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Just like some packages not working with SES when it locks down the environment.</td></tr>
  <tr class="msg" id="L60"><td class="ts-cell"><a class="ts" href="#L60" alt="Mon Jan 30 2023 07:46:33 GMT-0800 (Pacific Standard Time)">15:46</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">It feels like you are arguing two opposing positions: Such a registry must be mutable so that code keeps working, but malicious code shouldn't be able to mutate it to hijack it.</td></tr>
  <tr class="msg" id="L61"><td class="ts-cell"><a class="ts" href="#L61" alt="Mon Jan 30 2023 07:48:23 GMT-0800 (Pacific Standard Time)">15:48</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">No, I'm arguing this feature cannot use a global registry with forgeable keys because it'd be impossible to make it safe</td></tr>
  <tr class="msg" id="L62"><td class="ts-cell"><a class="ts" href="#L62" alt="Mon Jan 30 2023 07:48:37 GMT-0800 (Pacific Standard Time)">15:48</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Perhaps it would be better to outline the specific capabilities we want, the limitations of the environment and ecosystem, and the concerns we have for any given solution. From there we can better determine hard and fast requirements and find potential compromises.</td></tr>
  <tr class="msg" id="L63"><td class="ts-cell"><a class="ts" href="#L63" alt="Mon Jan 30 2023 07:49:38 GMT-0800 (Pacific Standard Time)">15:49</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> No, I'm arguing this feature cannot use a global registry with forgeable keys because it'd be impossible to make it safe</blockquote></mx-reply>I'm more than willing to entertain other solutions, but its important that the developer experience doesn't make the feature wholly unusable.</td></tr>
  <tr class="msg" id="L64"><td class="ts-cell"><a class="ts" href="#L64" alt="Mon Jan 30 2023 07:49:56 GMT-0800 (Pacific Standard Time)">15:49</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">you can have a global registry, as long as it cannot be used by code that hasn't been previously introduced to each other to interact.</td></tr>
  <tr class="msg" id="L65"><td class="ts-cell"><a class="ts" href="#L65" alt="Mon Jan 30 2023 07:50:34 GMT-0800 (Pacific Standard Time)">15:50</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Needing to patch or wire up the prototype in <code>onmessage</code> is terrible DX.</td></tr>
  <tr class="msg" id="L66"><td class="ts-cell"><a class="ts" href="#L66" alt="Mon Jan 30 2023 07:51:06 GMT-0800 (Pacific Standard Time)">15:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">How would you describe how these introductions should work?</td></tr>
  <tr class="msg" id="L67"><td class="ts-cell"><a class="ts" href="#L67" alt="Mon Jan 30 2023 07:51:34 GMT-0800 (Pacific Standard Time)">15:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">This is the reason I would block any string based registry that you can ask the question (directly or indirectly) "do you have this key"</td></tr>
  <tr class="msg" id="L68"><td class="ts-cell"><a class="ts" href="#L68" alt="Mon Jan 30 2023 07:52:15 GMT-0800 (Pacific Standard Time)">15:52</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Needing to patch or wire up the prototype in <code>onmessage</code> is terrible DX.</blockquote></mx-reply>I say this as someone who wrote a package that implements struct-like behavior backed by <code>SharedArrayBuffer</code> that does this. The only reason it works is that the "structs" you create are fully typed, so you don't have to walk a graph to wire up prototypes because it does that for you.</td></tr>
  <tr class="msg" id="L69"><td class="ts-cell"><a class="ts" href="#L69" alt="Mon Jan 30 2023 07:54:51 GMT-0800 (Pacific Standard Time)">15:54</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> This is the reason I would block any string based registry that you can ask the question (directly or indirectly) "do you have this key"</blockquote></mx-reply>How deep does this concern extend? Agent-scoped registries, apparently, but what about realm-scoped registry?</td></tr>
  <tr class="msg" id="L70"><td class="ts-cell"><a class="ts" href="#L70" alt="Mon Jan 30 2023 07:55:17 GMT-0800 (Pacific Standard Time)">15:55</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">realm scoped registries too</td></tr>
  <tr class="msg" id="L71"><td class="ts-cell"><a class="ts" href="#L71" alt="Mon Jan 30 2023 07:58:22 GMT-0800 (Pacific Standard Time)">15:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">To clarify, your concern is that such a string-based registry could be used as a side-channel for communication (i.e., it could be used to exfiltrate data)?</td></tr>
  <tr class="msg" id="L72"><td class="ts-cell"><a class="ts" href="#L72" alt="Mon Jan 30 2023 07:59:02 GMT-0800 (Pacific Standard Time)">15:59</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">hm there seems to be a lot of back and forth i've missed here, is there a tl;dr (no rush)?</td></tr>
  <tr class="msg" id="L73"><td class="ts-cell"><a class="ts" href="#L73" alt="Mon Jan 30 2023 07:59:06 GMT-0800 (Pacific Standard Time)">15:59</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">In the solution I presented, the application either has to do a manual bootstrap (sending once over postMessage the unforgeable type identifier, and wire it to the expected implementation), or give up on prototype continuity (aka an incoming shared struct's dynamic proto would not be the same object as the dynamic proto of an "equivalent" shared struct created locally)</td></tr>
  <tr class="msg" id="L74"><td class="ts-cell"><a class="ts" href="#L74" alt="Mon Jan 30 2023 07:59:47 GMT-0800 (Pacific Standard Time)">15:59</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">side channel and/or denial of service</td></tr>
  <tr class="msg" id="L75"><td class="ts-cell"><a class="ts" href="#L75" alt="Mon Jan 30 2023 08:01:16 GMT-0800 (Pacific Standard Time)">16:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">If we had module block with stable identity over postMessage, the discontinuity could be mitigated</td></tr>
  <tr class="msg" id="L76"><td class="ts-cell"><a class="ts" href="#L76" alt="Mon Jan 30 2023 08:01:22 GMT-0800 (Pacific Standard Time)">16:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> In the solution I presented, the application either has to do a manual bootstrap (sending once over postMessage the unforgeable type identifier, and wire it to the expected implementation), or give up on prototype continuity (aka an incoming shared struct's dynamic proto would not be the same object as the dynamic proto of an "equivalent" shared struct created locally)</blockquote></mx-reply>What if such a registry were per-channel? i.e., a <code>MessagePort</code> might have an internal registry of type-identity to prototype, and you'd have to set up that registry on each side?</td></tr>
  <tr class="msg" id="L77"><td class="ts-cell"><a class="ts" href="#L77" alt="Mon Jan 30 2023 08:02:09 GMT-0800 (Pacific Standard Time)">16:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> If we had module block with stable identity over postMessage, the discontinuity could be mitigated</blockquote></mx-reply>Because you send the module block over <code>postMessage</code> to evaluate so that both sides have the same representation?</td></tr>
  <tr class="msg" id="L78"><td class="ts-cell"><a class="ts" href="#L78" alt="Mon Jan 30 2023 08:02:58 GMT-0800 (Pacific Standard Time)">16:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I think a per-channel registry would likely exacerbate identity discontinuity issues, but since they registration would be tied to a non-global capability, it would be acceptable to use forgeable identifiers</td></tr>
  <tr class="msg" id="L79"><td class="ts-cell"><a class="ts" href="#L79" alt="Mon Jan 30 2023 08:06:54 GMT-0800 (Pacific Standard Time)">16:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">My concerns with bootstrapping with a module block is how much other information would need to be bootstrapped along with it to support code-sharing (i.e., imports and package dependencies) making it harder for the other side to ensure initialization is consistent (i.e., any registration that needs to happen, or perhaps conditional imports depending on whether the code is running in the browser main thread or in a worker, etc.).
And if that were easily solvable, we could also potentially solve that by bootstrapping just with the struct type definition itself (i.e., can we do this without depending on module blocks?).</td></tr>
  <tr class="msg" id="L80"><td class="ts-cell"><a class="ts" href="#L80" alt="Mon Jan 30 2023 08:08:36 GMT-0800 (Pacific Standard Time)">16:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I think a per-channel registry would likely exacerbate identity discontinuity issues, but since they registration would be tied to a non-global capability, it would be acceptable to use forgeable identifiers</blockquote></mx-reply>From an API standpoint, I could potentially see there being some kind of built-in <code>SharedStructTypeIdentityRegistry</code> that a package could export, such that a host could import the registry and use it to configure a <code>MessagePort</code>.</td></tr>
  <tr class="msg" id="L81"><td class="ts-cell"><a class="ts" href="#L81" alt="Mon Jan 30 2023 08:10:09 GMT-0800 (Pacific Standard Time)">16:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> hm there seems to be a lot of back and forth i've missed here, is there a tl;dr (no rush)?</blockquote></mx-reply>How to manage type identity across Agents/Realms/etc. in a way that doesn't violate security concerns, but works for bundlers (so solely relying on module id/file path isn't viable).</td></tr>
  <tr class="msg" id="L82"><td class="ts-cell"><a class="ts" href="#L82" alt="Mon Jan 30 2023 08:10:18 GMT-0800 (Pacific Standard Time)">16:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Because you send the module block over <code>postMessage</code> to evaluate so that both sides have the same representation?</blockquote></mx-reply>Kinda. Each agent could have its own type for an "equivalent" shared struct, but if the code declaring the struct uses a module instance to define the struct's behavior / dynamic prototype, that module instance can be automatically loaded by other realms. When receiving a struct of that type, the observed prototype object would be the same as the prototype of the locally defined struct, if the local definition used the same module instance (which required module instances to be stable across agents). The "mostly mitigated" part is because the constructor couldn't be on the prototype, as that is realm specific of course</td></tr>
  <tr class="msg" id="L83"><td class="ts-cell"><a class="ts" href="#L83" alt="Mon Jan 30 2023 08:12:56 GMT-0800 (Pacific Standard Time)">16:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> From an API standpoint, I could potentially see there being some kind of built-in <code>SharedStructTypeIdentityRegistry</code> that a package could export, such that a host could import the registry and use it to configure a <code>MessagePort</code>.</blockquote></mx-reply>I did not understand this suggestion</td></tr>
  <tr class="msg" id="L84"><td class="ts-cell"><a class="ts" href="#L84" alt="Mon Jan 30 2023 08:16:01 GMT-0800 (Pacific Standard Time)">16:16</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I'm mostly suggesting a way to simply the DX around registration, making it easier to combine registries from multiple packages, and to define the composite registry on each side of a message port. </td></tr>
  <tr class="msg" id="L85"><td class="ts-cell"><a class="ts" href="#L85" alt="Mon Jan 30 2023 08:17:40 GMT-0800 (Pacific Standard Time)">16:17</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">The code that runs on each side could be different for the same struct type given practices such as bundling and tree shaking, and in some cases a struct type may need a method tailored to an environment (i.e., can its methods access node-native bindings, can this method only be run in the browser), etc.</td></tr>
  <tr class="msg" id="L86"><td class="ts-cell"><a class="ts" href="#L86" alt="Mon Jan 30 2023 08:18:43 GMT-0800 (Pacific Standard Time)">16:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Having an observably similar prototype is profoundly useful, but mandating a similar prototype limits flexibility.</td></tr>
  <tr class="msg" id="L87"><td class="ts-cell"><a class="ts" href="#L87" alt="Mon Jan 30 2023 08:20:33 GMT-0800 (Pacific Standard Time)">16:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">TLDR here is that registration would be implicit the first time a struct of a given type is shared with another realm/agent if the struct definition used a module instance at declaration. If the same module instance loaded in 2 different agents has a stable identity, aka if <code>receivedModuleInstance === importedModuleInstance</code>, then you don't have any prototype discontinuity issues. If the bundler messes up these module identities, then the program has to first send the type identity explicitly over a <code>postMessage</code> and the receiving code has to manually do <code>SharedStructType.register(receivedModuleType, importedModuleInstance)</code></td></tr>
  <tr class="msg" id="L88"><td class="ts-cell"><a class="ts" href="#L88" alt="Mon Jan 30 2023 08:25:40 GMT-0800 (Pacific Standard Time)">16:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">Btw, you can use string identifier over <code>postMessage</code> for the application to know what the opaque type identifier is about, restoring your string based semantics. That would be scoped to whatever is holding the string identifier registry (possibly the channel itself).</td></tr>
  <tr class="msg" id="L89"><td class="ts-cell"><a class="ts" href="#L89" alt="Mon Jan 30 2023 08:27:18 GMT-0800 (Pacific Standard Time)">16:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Btw, you can use string identifier over <code>postMessage</code> for the application to know what the opaque type identifier is about, restoring your string based semantics. That would be scoped to whatever is holding the string identifier registry (possibly the channel itself).</blockquote></mx-reply>That's still a poor DX as it would significantly overcomplicate <code>onmessage</code> handlers by requiring custom scaffolding in every project to bootstrap.</td></tr>
  <tr class="msg" id="L90"><td class="ts-cell"><a class="ts" href="#L90" alt="Mon Jan 30 2023 08:28:43 GMT-0800 (Pacific Standard Time)">16:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">The <code>SharedStructTypeIdentityRegistry</code> suggestion above would handle the per-channel string identifier registry without requiring prior communication between each side of a channel.</td></tr>
  <tr class="msg" id="L91"><td class="ts-cell"><a class="ts" href="#L91" alt="Mon Jan 30 2023 08:38:05 GMT-0800 (Pacific Standard Time)">16:38</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><p>Consider, for example:</p>
<pre><code class="language-js">// node_modules/threejs/src/registry.js
export const structRegistryWriter = new StructTypeRegistryWriter();
export const structRegistry = structRegistryWriter.registry;

// node_modules/threejs/src/math/Vector2.js
import { structRegistryWriter } from "../registry.js"

@structRegistry.register("http://threejs.com/structs/Vector2")
shared struct Vector2 { ... }

// main.js
import { Vector2, structRegistry } from "threejs";

const worker = new Worker("./worker.js", { structRegistry });
worker.postMessage(new Vector2(0, 0));

// worker.js
import { structRegistry } from "threejs";
import { parentPort } from "worker_threads";
parentPort.addRegistry(structRegistry);
parentPort.on("message", v =&gt; {
  v.whatever();
});
</code></pre>
</td></tr>
  <tr class="msg" id="L92"><td class="ts-cell"><a class="ts" href="#L92" alt="Mon Jan 30 2023 08:39:19 GMT-0800 (Pacific Standard Time)">16:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Both the main and worker threads load the same struct type, though they could be in different bundles and tree shaking could remove some members. They independently associate type registries with their sides of the channel.</td></tr>
  <tr class="msg" id="L93"><td class="ts-cell"><a class="ts" href="#L93" alt="Mon Jan 30 2023 08:40:54 GMT-0800 (Pacific Standard Time)">16:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">While not automatic, the registration mechanism stays as out of the way as possible to simplify the developer experience.</td></tr>
  <tr class="msg" id="L94"><td class="ts-cell"><a class="ts" href="#L94" alt="Mon Jan 30 2023 08:41:42 GMT-0800 (Pacific Standard Time)">16:41</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><p>Basically it'd look like</p>
<pre><code class="language-js">// Done by all workers independently
import Vector2DPrototype from "vector2dBehavior.js" with { reflect: "module" };
const { constructor: Vector2D, type: Vector2DType } = SharedStructType.prepare(["x", "y"]);
SharedStructType.register(Vector2DType, Vector2DPrototype);
const Vector2DUUID = '...';
const structAwareChannel = new MessageChannel();
structAwareChannel.register(Vector2DUUID, Vector2DType, Vector2DPrototype);

// worker1.js
const v1 = new Vector2D({x: 1, y: 2});
structAwareChannel.postMessage({v1});

// worker2.js
channel.on("message", ({v1}) =&gt; {
  console.log(v1 instanceof Vector2D); // true because prototype match even though type instance different
});
</code></pre>
</td></tr>
  <tr class="msg" id="L95"><td class="ts-cell"><a class="ts" href="#L95" alt="Mon Jan 30 2023 08:44:56 GMT-0800 (Pacific Standard Time)">16:44</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">That's definitely not great for the actual proposal, that seems far to easy to get wrong. Maybe ok in the prototyping stage, but not long term.</td></tr>
  <tr class="msg" id="L96"><td class="ts-cell"><a class="ts" href="#L96" alt="Mon Jan 30 2023 08:45:23 GMT-0800 (Pacific Standard Time)">16:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I actually don't think our approaches diverge that much</td></tr>
  <tr class="msg" id="L97"><td class="ts-cell"><a class="ts" href="#L97" alt="Mon Jan 30 2023 08:45:46 GMT-0800 (Pacific Standard Time)">16:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">What happens if <code>vector2dBehavior.js</code> requires a package already loaded on the worker? Will it import the worker version, or carry along its transitive dependencies to be re-evaluated on the worker?</td></tr>
  <tr class="msg" id="L98"><td class="ts-cell"><a class="ts" href="#L98" alt="Mon Jan 30 2023 08:46:13 GMT-0800 (Pacific Standard Time)">16:46</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">if the struct types are declared independently, they will have different types, and thus different constructors</td></tr>
  <tr class="msg" id="L99"><td class="ts-cell"><a class="ts" href="#L99" alt="Mon Jan 30 2023 08:47:20 GMT-0800 (Pacific Standard Time)">16:47</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> What happens if <code>vector2dBehavior.js</code> requires a package already loaded on the worker? Will it import the worker version, or carry along its transitive dependencies to be re-evaluated on the worker?</blockquote></mx-reply>Doesn't matter?</td></tr>
  <tr class="msg" id="L100"><td class="ts-cell"><a class="ts" href="#L100" alt="Mon Jan 30 2023 08:48:07 GMT-0800 (Pacific Standard Time)">16:48</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a <code>SharedStructType</code> constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like <code>with { reflect: "module" }</code> or module blocks, which are nowhere near ready for adoption.</td></tr>
  <tr class="msg" id="L101"><td class="ts-cell"><a class="ts" href="#L101" alt="Mon Jan 30 2023 08:49:26 GMT-0800 (Pacific Standard Time)">16:49</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">Yes I agree a dependency on module instances is not great, hence why I removed that from my original proposal. We can skip it here, the only effect is that you won't get implicit fallback registration</td></tr>
  <tr class="msg" id="L102"><td class="ts-cell"><a class="ts" href="#L102" alt="Mon Jan 30 2023 08:49:26 GMT-0800 (Pacific Standard Time)">16:49</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Doesn't matter?</blockquote></mx-reply>It matters if the dependent module has side-effects, or if it doubles the amount of runtime memory used because it depends on a large package.</td></tr>
  <tr class="msg" id="L103"><td class="ts-cell"><a class="ts" href="#L103" alt="Mon Jan 30 2023 08:50:05 GMT-0800 (Pacific Standard Time)">16:50</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">the behavior of loading a module instance is a general question for module import to answer, and is not really relevant for this proposal</td></tr>
  <tr class="msg" id="L104"><td class="ts-cell"><a class="ts" href="#L104" alt="Mon Jan 30 2023 08:50:44 GMT-0800 (Pacific Standard Time)">16:50</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I only included it so that a behavior can be implicitly shared with other realms/agent without having to rely on a per channel registration on each side</td></tr>
  <tr class="msg" id="L105"><td class="ts-cell"><a class="ts" href="#L105" alt="Mon Jan 30 2023 08:53:23 GMT-0800 (Pacific Standard Time)">16:53</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">It would be great to find an approach that allows for the implicit import of behavior for cases that don't care about prototype continuity, yet not force a dependency on module instances</td></tr>
  <tr class="msg" id="L106"><td class="ts-cell"><a class="ts" href="#L106" alt="Mon Jan 30 2023 09:01:32 GMT-0800 (Pacific Standard Time)">17:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Your suggestion depends on features not present in the origin trial, but uses an API that is likely unique to the origin trial. @shu can clarify, but I believe the reason the trial uses a <code>SharedStructType</code> constructor in place of syntax as that's much easier to add behind a flag to get early feedback on. I'm not sure how likely we could depend on a proposal like <code>with { reflect: "module" }</code> or module blocks, which are nowhere near ready for adoption.</blockquote></mx-reply>that is accurate</td></tr>
  <tr class="msg" id="L107"><td class="ts-cell"><a class="ts" href="#L107" alt="Mon Jan 30 2023 09:12:24 GMT-0800 (Pacific Standard Time)">17:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I'm of two opinions on prototype continuity, each based on the overall direction we take for the proposal:

If the methods of shared structs only had access to a thread-safe locked-down global in a globally shared realm where they can only access other shared functions or shared structs or imports of the same (i.e., something like the "shared module" approach), then I favor prototype continuity because its easy and has an already limited surface area. 

If the methods of shared structs are derived from code independently run in each Agent, then I only care about prototype continuity insomuch as a well-written program should be importing the same shared struct definition from the same file/package in each agent, and that any prototype continuity that exists will fall out naturally from that. By loosening the any restriction of prototype continuity, bundlers can take advantage of tree shaking, renaming, inlining, etc.

Since we seem to be leaning towards the latter approach, I'm less concerned about prototype continuity.</td></tr>

</tbody></table></div></div></div>
</body></html>