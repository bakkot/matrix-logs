2021-11-15
[07:50:51.0211] <shu>
our next working session is coming up on Nov 18, 10-11 PT. any conflicts?

[13:55:41.0834] <Mathieu Hofman>
It's not optimal for me but I can make it work


2021-11-16
[13:12:12.0137] <rbuckton>
I've been talking with Jack Works about his enum proposal and how it relates to mine. One of the things that came up was a sketch I made for supporting ADT-style enumerations that was based on my struct proposal: https://gist.github.com/rbuckton/4a5108fab40ac90551bf82d9884711b5. I've been revisiting that, as I'd like to make sure whatever solution we end up for enums will be consistent with structs/shared structs so that we might be able to have a "shared enum" (whose value could be stored in a field on a "shared struct").

[13:13:34.0385] <shu>
hm, a bit future looking at first blush, but happy to discuss

[15:24:15.0708] <Jack Works>
> <@rbuckton:matrix.org> I've been talking with Jack Works about his enum proposal and how it relates to mine. One of the things that came up was a sketch I made for supporting ADT-style enumerations that was based on my struct proposal: https://gist.github.com/rbuckton/4a5108fab40ac90551bf82d9884711b5. I've been revisiting that, as I'd like to make sure whatever solution we end up for enums will be consistent with structs/shared structs so that we might be able to have a "shared enum" (whose value could be stored in a field on a "shared struct").

So we're going to have 3 different styles of object. Normal object, Records and Structs. I think support all of them in ADT enum is important.


2021-11-18
[10:02:42.0521] <shu>
rbuckton: working session call happening now if you can make it

[11:17:23.0183] <shu>
Mathieu Hofman: so if we do allow them in weak collections, it's probably not the case that they become eternal the minute they get put in there, but that they become eternal if there is a cycle

[11:17:45.0535] <shu>
which is an implementation problem that i can live with, i guess

[11:17:52.0062] <shu>
the spec can say, they are allowed in weak collections

[11:17:59.0157] <Mathieu Hofman>
correct, engines could always figure out directed graph through internal weakrefs

[11:18:09.0299] <shu>
but until XX years from now when massive rearchitecting has been undertaken, know that in practice cycles will leak

[11:18:16.0934] <shu>
which is still compliant, but unfortunate

[11:18:30.0939] <shu>
there's no good language reason to disallow them

[11:18:52.0442] <Mathieu Hofman>
I just wanted to point out you were opening pandora's box

[11:18:54.0333] <shu>
there is a safety aspect of disallowing shared -> unshared edges, since obviously multiple threads accessing an unshared thing can't work

[11:19:10.0615] <Mathieu Hofman>
I've been trying to keep it closed in a few places where these things came up

[11:19:12.0759] <shu>
this is not a problem for weak collections, since there's a per-thread view of the weak collection

[11:19:23.0472] <shu>
what's the pandora's box? cycles between shared and unshared?

[11:19:42.0145] <Mathieu Hofman>
the requirement for a distributed garbage collection

[11:19:51.0024] <shu>
ah, i see

[11:20:06.0268] <shu>
yes, indeed, it is inherent in a shared memory proposal to open that pandora's box

[11:20:25.0698] <shu>
much of the work internally i've been doing before proposing this in public is to get a roadmap worked out for GC evolution to support a shared memory future

[11:20:33.0458] <shu>
and it sounds like at least V8 and JSC are converging on what to do

[11:20:35.0075] <Mathieu Hofman>
well SharedArrayBuffer avoided that bullet with unstable identities between agents

[11:20:40.0801] <shu>
correct

[11:20:54.0568] <shu>
but it's also a "solved" problem in the literature, at least

[11:21:02.0921] <shu>
there are plenty of GCed languages with shared memory

[11:21:39.0604] <Mathieu Hofman>
it's solved if you have a single GC, nothing is published for cooperative distributed gc

[11:21:55.0710] <shu>
i guess i don't know what you mean by distributed

[11:22:04.0184] <shu>
independently collected heaps that point to each other?

[11:22:28.0793] <Mathieu Hofman>
multiple local GCs coordinating to identify and prune distributed cycles

[11:22:37.0738] <shu>
ah i see

[11:22:49.0652] <shu>
but that implementation is not a requirement

[11:23:22.0610] <shu>
the prevailing wisdom seems to be to do a single marking phase across all threads

[11:23:32.0718] <Mathieu Hofman>
I do have a proposal to solve that, but as you mentioned, the motivation is probably not going to be Web user agents

