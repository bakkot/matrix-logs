2024-10-01
[23:38:21.0264] <littledan>
we could've introduced an optimized fake getter scheme for class fields (Kevin [zenparsing] raised that at some point) but we decided not to, partly due to implementation complexity/expected slowness


2024-10-10
[09:57:11.0280] <rbuckton>
Since it is plenary week, should we assume the structs meeting is cancelled for today?

[09:57:43.0857] <nicolo-ribaudo>
Yes

[09:58:10.0761] <nicolo-ribaudo>
Unless we want to have little stage 2 party :P

[09:59:40.0344] <rbuckton>
I'd rather save that for the next meeting

[16:16:39.0738] <shu>
i talked with jordan and mark in the hallway and i think we have promising directions to explore for both of the big issue areas of:

- unsafe {} opposition
- jordan's concern of "i want every object to be able to get private fields"

the "can be used as weakmap keys" concern basically 100% rides on implementation feasibility from others at this point, and i don't think it's useful for this group to design around it yet

[16:18:47.0637] <shu>
for unsafe {}, mark is also happy with "all shared struct fields always private", then we don't need unsafe {}, because the idea is the public API must be written by the developer, which should be threadsafe

the implementation constraint for me with that world is that we must be able to compile #-names in shared structs just as normal property slots. because of the "#-names have different identities depending on the evaluation of the class declaration" thing, they are wildly inefficient in engines. this problem might not exist at all if we have the restriction that struct decls are top-level only and thus can't be reevaluated anyways

so that sounds like a promising thing for us to explore

[16:20:13.0754] <shu>
for "i want to stamp private fields", jordan is happy with an outcome where we expose a new method like preventExtensions that also prohibits any object from being stampable. mark has been independently working on a new integrity level that already has that capability, and is happy to unbundle that new method from the integrity level.

so it sounds like if we just introduce that method, here or independently, that solves it. everyone AFAIK agrees return override is loathsome so that method would be a good addition independently anyway

[16:20:47.0718] <shu>
structs, then, would be born as if that method were already called on them

[16:21:53.0571] <shu>
oh, one additional caveat to the unsafe {} thing, without unsafe {}, shared arrays would just work, which is also racy. i flagged this to mark, who thinks that is actually fine and as intended, because the indexed properties _are_ the public API of an array

