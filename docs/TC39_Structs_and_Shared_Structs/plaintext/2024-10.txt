2024-10-01
[23:38:21.0264] <littledan>
we could've introduced an optimized fake getter scheme for class fields (Kevin [zenparsing] raised that at some point) but we decided not to, partly due to implementation complexity/expected slowness


2024-10-10
[09:57:11.0280] <rbuckton>
Since it is plenary week, should we assume the structs meeting is cancelled for today?

[09:57:43.0857] <nicolo-ribaudo>
Yes

[09:58:10.0761] <nicolo-ribaudo>
Unless we want to have little stage 2 party :P

[09:59:40.0344] <rbuckton>
I'd rather save that for the next meeting

[16:16:39.0738] <shu>
i talked with jordan and mark in the hallway and i think we have promising directions to explore for both of the big issue areas of:

- unsafe {} opposition
- jordan's concern of "i want every object to be able to get private fields"

the "can be used as weakmap keys" concern basically 100% rides on implementation feasibility from others at this point, and i don't think it's useful for this group to design around it yet

[16:18:47.0637] <shu>
for unsafe {}, mark is also happy with "all shared struct fields always private", then we don't need unsafe {}, because the idea is the public API must be written by the developer, which should be threadsafe

the implementation constraint for me with that world is that we must be able to compile #-names in shared structs just as normal property slots. because of the "#-names have different identities depending on the evaluation of the class declaration" thing, they are wildly inefficient in engines. this problem might not exist at all if we have the restriction that struct decls are top-level only and thus can't be reevaluated anyways

so that sounds like a promising thing for us to explore

[16:20:13.0754] <shu>
for "i want to stamp private fields", jordan is happy with an outcome where we expose a new method like preventExtensions that also prohibits any object from being stampable. mark has been independently working on a new integrity level that already has that capability, and is happy to unbundle that new method from the integrity level.

so it sounds like if we just introduce that method, here or independently, that solves it. everyone AFAIK agrees return override is loathsome so that method would be a good addition independently anyway

[16:20:47.0718] <shu>
structs, then, would be born as if that method were already called on them

[16:21:53.0571] <shu>
oh, one additional caveat to the unsafe {} thing, without unsafe {}, shared arrays would just work, which is also racy. i flagged this to mark, who thinks that is actually fine and as intended, because the indexed properties _are_ the public API of an array

[16:38:55.0499] <Mathieu Hofman>
> for "i want to stamp private fields", jordan is happy with an outcome where we expose a new method like preventExtensions that also prohibits any object from being stampable
That is great news

> mark has been independently working on a new integrity level that already has that capability, and is happy to unbundle that new method from the integrity level.
Yeah we've been going at this from different approaches for a couple years now. In the latest iteration we were thinking of a new explicit integrity level above "freeze", but I have to think if we lower that to an explicit integrity level right above "prevent extensions". The thing is that we wanted to attach some different proxy trap semantics as well, and I don't know if that can work in that case.

> for unsafe {}, mark is also happy with "all shared struct fields always private", then we don't need unsafe {}
I had independently been mulling over this, and the 2 issues I came up with are:
- WASM integration: I doubt an FFI style approach and wasm having to go through JS would be acceptable for every shared field access?
- shared struct extend: the semantics of privates in JS is lexical. I think we may need a notion of protected here. Or at least a way to extract and represent the power to access private fields (which could be used to solve the wasm issue as well)

[16:39:15.0049] <Mathieu Hofman>
 * > for "i want to stamp private fields", jordan is happy with an outcome where we expose a new method like preventExtensions that also prohibits any object from being stampable

That is great news

> mark has been independently working on a new integrity level that already has that capability, and is happy to unbundle that new method from the integrity level.

Yeah we've been going at this from different approaches for a couple years now. In the latest iteration we were thinking of a new explicit integrity level above "freeze", but I have to think if we lower that to an explicit integrity level right above "prevent extensions". The thing is that we wanted to attach some different proxy trap semantics as well, and I don't know if that can work in that case.

> for unsafe {}, mark is also happy with "all shared struct fields always private", then we don't need unsafe {}

I had independently been mulling over this, and the 2 issues I came up with are:

- WASM integration: I doubt an FFI style approach and wasm having to go through JS would be acceptable for every shared field access?
- shared struct extend: the semantics of privates in JS is lexical. I think we may need a notion of protected here. Or at least a way to extract and represent the power to access private fields (which could be used to solve the wasm issue as well)

[16:40:00.0527] <Mathieu Hofman>
 * > for "i want to stamp private fields", jordan is happy with an outcome where we expose a new method like preventExtensions that also prohibits any object from being stampable

That is great news

> mark has been independently working on a new integrity level that already has that capability, and is happy to unbundle that new method from the integrity level.

Yeah we've been going at this from different approaches for a couple years now. In the latest iteration we were thinking of a new explicit integrity level above "freeze", but I have to think if could we lower that to an explicit integrity level right above "prevent extensions". The thing is that we wanted to attach some different proxy trap semantics as well, and I don't know if that can work in that case.

> for unsafe {}, mark is also happy with "all shared struct fields always private", then we don't need unsafe {}

I had independently been mulling over this, and the 2 issues I came up with are:

- WASM integration: I doubt an FFI style approach and wasm having to go through JS would be acceptable for every shared field access?
- shared struct extend: the semantics of privates in JS is lexical. I think we may need a notion of protected here. Or at least a way to extract and represent the power to access private fields (which could be used to solve the wasm issue as well)

[16:42:04.0507] <Mathieu Hofman>
 * > for "i want to stamp private fields", jordan is happy with an outcome where we expose a new method like preventExtensions that also prohibits any object from being stampable

That is great news

> mark has been independently working on a new integrity level that already has that capability, and is happy to unbundle that new method from the integrity level.

Yeah we've been going at this from different approaches for a couple years now. In the latest iteration we were thinking of a new explicit integrity level above "freeze", but I have to think if could we lower that to an explicit integrity level right above "prevent extensions". The thing is that we wanted to attach some different proxy trap semantics as well, and provide a signal to not trigger the override mistake, and I don't know if that can work in that case.

> for unsafe {}, mark is also happy with "all shared struct fields always private", then we don't need unsafe {}

I had independently been mulling over this, and the 2 issues I came up with are:

- WASM integration: I doubt an FFI style approach and wasm having to go through JS would be acceptable for every shared field access?
- shared struct extend: the semantics of privates in JS is lexical. I think we may need a notion of protected here. Or at least a way to extract and represent the power to access private fields (which could be used to solve the wasm issue as well)


2024-10-11
[17:13:22.0770] <shu>
> WASM integration: I doubt an FFI style approach and wasm having to go through JS would be acceptable for every shared field access?

privacy is a source-language level concept, not a target language level concept. how JS structs are reflected in wasm is just an independent discussion IMO.

[17:14:03.0684] <shu>
> shared struct extend: the semantics of privates in JS is lexical. I think we may need a notion of protected here. Or at least a way to extract and represent the power to access private fields (which could be used to solve the wasm issue as well)

yes, the existing semantics of #-names binds us in a way. i don't have a good answer

[17:14:21.0753] <shu>
like wasmgc structs don't have names, just offsets, right?

[17:14:27.0402] <shu>
privacy is just not a question there

[17:30:22.0020] <rbuckton>
> <@shuyuguo:matrix.org> for unsafe {}, mark is also happy with "all shared struct fields always private", then we don't need unsafe {}, because the idea is the public API must be written by the developer, which should be threadsafe
> 
> the implementation constraint for me with that world is that we must be able to compile #-names in shared structs just as normal property slots. because of the "#-names have different identities depending on the evaluation of the class declaration" thing, they are wildly inefficient in engines. this problem might not exist at all if we have the restriction that struct decls are top-level only and thus can't be reevaluated anyways
> 
> so that sounds like a promising thing for us to explore

If struct fields are always private, how would you even use them with Atomics? I'm not sure I'm in favor of that direction, for more reasons than that.

