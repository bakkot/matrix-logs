2024-10-01
[23:38:21.0264] <littledan>
we could've introduced an optimized fake getter scheme for class fields (Kevin [zenparsing] raised that at some point) but we decided not to, partly due to implementation complexity/expected slowness


2024-10-10
[09:57:11.0280] <rbuckton>
Since it is plenary week, should we assume the structs meeting is cancelled for today?

[09:57:43.0857] <nicolo-ribaudo>
Yes

[09:58:10.0761] <nicolo-ribaudo>
Unless we want to have little stage 2 party :P

[09:59:40.0344] <rbuckton>
I'd rather save that for the next meeting

[16:16:39.0738] <shu>
i talked with jordan and mark in the hallway and i think we have promising directions to explore for both of the big issue areas of:

- unsafe {} opposition
- jordan's concern of "i want every object to be able to get private fields"

the "can be used as weakmap keys" concern basically 100% rides on implementation feasibility from others at this point, and i don't think it's useful for this group to design around it yet

[16:18:47.0637] <shu>
for unsafe {}, mark is also happy with "all shared struct fields always private", then we don't need unsafe {}, because the idea is the public API must be written by the developer, which should be threadsafe

the implementation constraint for me with that world is that we must be able to compile #-names in shared structs just as normal property slots. because of the "#-names have different identities depending on the evaluation of the class declaration" thing, they are wildly inefficient in engines. this problem might not exist at all if we have the restriction that struct decls are top-level only and thus can't be reevaluated anyways

so that sounds like a promising thing for us to explore

